[
  {
    "discussion_id": "2354789875",
    "pr_number": 9304,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/chargebee/transformers.rs",
    "created_at": "2025-09-17T08:48:22+00:00",
    "commented_code": "})\n     }\n }\n+\n+#[derive(Debug, Serialize)]\n+pub struct ChargebeeCustomerCreateRequest {\n+    #[serde(rename = \"id\")]\n+    pub customer_id: CustomerId,\n+    #[serde(rename = \"first_name\")]\n+    pub name: Option<Secret<String>>,\n+    pub email: Option<Email>,\n+    pub billing_address: Option<api_models::payments::AddressDetails>,\n+}\n+\n+impl TryFrom<&ChargebeeRouterData<&hyperswitch_domain_models::types::ConnectorCustomerRouterData>>\n+    for ChargebeeCustomerCreateRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+\n+    fn try_from(\n+        item: &ChargebeeRouterData<&hyperswitch_domain_models::types::ConnectorCustomerRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let req = &item.router_data.request;\n+\n+        Ok(Self {\n+            customer_id: req\n+                .customer_id\n+                .as_ref()\n+                .ok_or_else(|| errors::ConnectorError::MissingRequiredField {\n+                    field_name: \"customer_id\",\n+                })?\n+                .clone(),\n+            name: req.name.clone(),\n+            email: req.email.clone(),\n+            billing_address: req.billing_address.clone(),\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Deserialize, Serialize, Clone)]\n+pub struct ChargebeeCustomerCreateResponse {\n+    pub customer: ChargebeeCustomerDetails,\n+}\n+\n+#[derive(Debug, Deserialize, Serialize, Clone)]\n+pub struct ChargebeeCustomerDetails {\n+    pub id: String,\n+    pub name: Option<Secret<String>>,\n+    pub email: Option<Email>,\n+    pub billing_address: Option<api_models::payments::AddressDetails>,\n+}\n+\n+impl\n+    TryFrom<\n+        ResponseRouterData<\n+            CreateConnectorCustomer,\n+            ChargebeeCustomerCreateResponse,\n+            ConnectorCustomerData,\n+            PaymentsResponseData,\n+        >,\n+    > for hyperswitch_domain_models::types::ConnectorCustomerRouterData\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+\n+    fn try_from(\n+        item: ResponseRouterData<\n+            CreateConnectorCustomer,\n+            ChargebeeCustomerCreateResponse,\n+            ConnectorCustomerData,\n+            PaymentsResponseData,\n+        >,\n+    ) -> Result<Self, Self::Error> {\n+        let c = &item.response.customer;\n+\n+        Ok(Self {\n+            response: Ok(PaymentsResponseData::ConnectorCustomerResponse {\n+                connector_customer_id: c.id.clone(),\n+                name: c.name.as_ref().map(|n| n.clone().expose()),\n+                email: c.email.as_ref().map(|e| e.clone().expose().expose()),\n+                billing_address: c.billing_address.clone(),\n+            }),\n+            ..item.data\n+        })",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2354789875",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9304,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/chargebee/transformers.rs",
        "discussion_id": "2354789875",
        "commented_code": "@@ -821,3 +829,85 @@ impl<F, T>\n         })\n     }\n }\n+\n+#[derive(Debug, Serialize)]\n+pub struct ChargebeeCustomerCreateRequest {\n+    #[serde(rename = \"id\")]\n+    pub customer_id: CustomerId,\n+    #[serde(rename = \"first_name\")]\n+    pub name: Option<Secret<String>>,\n+    pub email: Option<Email>,\n+    pub billing_address: Option<api_models::payments::AddressDetails>,\n+}\n+\n+impl TryFrom<&ChargebeeRouterData<&hyperswitch_domain_models::types::ConnectorCustomerRouterData>>\n+    for ChargebeeCustomerCreateRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+\n+    fn try_from(\n+        item: &ChargebeeRouterData<&hyperswitch_domain_models::types::ConnectorCustomerRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let req = &item.router_data.request;\n+\n+        Ok(Self {\n+            customer_id: req\n+                .customer_id\n+                .as_ref()\n+                .ok_or_else(|| errors::ConnectorError::MissingRequiredField {\n+                    field_name: \"customer_id\",\n+                })?\n+                .clone(),\n+            name: req.name.clone(),\n+            email: req.email.clone(),\n+            billing_address: req.billing_address.clone(),\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Deserialize, Serialize, Clone)]\n+pub struct ChargebeeCustomerCreateResponse {\n+    pub customer: ChargebeeCustomerDetails,\n+}\n+\n+#[derive(Debug, Deserialize, Serialize, Clone)]\n+pub struct ChargebeeCustomerDetails {\n+    pub id: String,\n+    pub name: Option<Secret<String>>,\n+    pub email: Option<Email>,\n+    pub billing_address: Option<api_models::payments::AddressDetails>,\n+}\n+\n+impl\n+    TryFrom<\n+        ResponseRouterData<\n+            CreateConnectorCustomer,\n+            ChargebeeCustomerCreateResponse,\n+            ConnectorCustomerData,\n+            PaymentsResponseData,\n+        >,\n+    > for hyperswitch_domain_models::types::ConnectorCustomerRouterData\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+\n+    fn try_from(\n+        item: ResponseRouterData<\n+            CreateConnectorCustomer,\n+            ChargebeeCustomerCreateResponse,\n+            ConnectorCustomerData,\n+            PaymentsResponseData,\n+        >,\n+    ) -> Result<Self, Self::Error> {\n+        let c = &item.response.customer;\n+\n+        Ok(Self {\n+            response: Ok(PaymentsResponseData::ConnectorCustomerResponse {\n+                connector_customer_id: c.id.clone(),\n+                name: c.name.as_ref().map(|n| n.clone().expose()),\n+                email: c.email.as_ref().map(|e| e.clone().expose().expose()),\n+                billing_address: c.billing_address.clone(),\n+            }),\n+            ..item.data\n+        })",
        "comment_created_at": "2025-09-17T08:48:22+00:00",
        "comment_author": "deepanshu-iiitu",
        "comment_body": "Please use meaningful variable names instead of c/n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952176318",
    "pr_number": 7062,
    "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
    "created_at": "2025-02-12T08:18:10+00:00",
    "commented_code": "})\n }\n \n+fn create_amazon_pay_delivery_options(\n+    value: &serde_json::Value,\n+) -> Result<AmazonPayDeliveryOptions, errors::ApiErrorResponse> {\n+    let id = value\n+        .get(\"id\")\n+        .and_then(|v| v.as_str())",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "1952176318",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
        "discussion_id": "1952176318",
        "commented_code": "@@ -1054,6 +1062,187 @@ fn create_paypal_sdk_session_token(\n     })\n }\n \n+fn create_amazon_pay_delivery_options(\n+    value: &serde_json::Value,\n+) -> Result<AmazonPayDeliveryOptions, errors::ApiErrorResponse> {\n+    let id = value\n+        .get(\"id\")\n+        .and_then(|v| v.as_str())",
        "comment_created_at": "2025-02-12T08:18:10+00:00",
        "comment_author": "ShankarSinghC",
        "comment_body": "Consider renaming the variable 'v' to something more descriptive, like 'id_value'\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2348452755",
    "pr_number": 9122,
    "pr_file": "crates/router/src/core/payment_methods/vault.rs",
    "created_at": "2025-09-15T09:49:02+00:00",
    "commented_code": "Ok(lookup_key)\n     }\n \n-    #[cfg(feature = \"payouts\")]\n+    #[cfg(feature = \"v2\")]\n+    #[instrument(skip_all)]\n+    pub async fn store_payment_method_data_in_locker(",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2348452755",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9122,
        "pr_file": "crates/router/src/core/payment_methods/vault.rs",
        "discussion_id": "2348452755",
        "commented_code": "@@ -951,7 +1062,42 @@ impl Vault {\n         Ok(lookup_key)\n     }\n \n-    #[cfg(feature = \"payouts\")]\n+    #[cfg(feature = \"v2\")]\n+    #[instrument(skip_all)]\n+    pub async fn store_payment_method_data_in_locker(",
        "comment_created_at": "2025-09-15T09:49:02+00:00",
        "comment_author": "prasunna09",
        "comment_body": "nit: rename the fn wrt temp locker",
        "pr_file_module": null
      },
      {
        "comment_id": "2348531285",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9122,
        "pr_file": "crates/router/src/core/payment_methods/vault.rs",
        "discussion_id": "2348452755",
        "commented_code": "@@ -951,7 +1062,42 @@ impl Vault {\n         Ok(lookup_key)\n     }\n \n-    #[cfg(feature = \"payouts\")]\n+    #[cfg(feature = \"v2\")]\n+    #[instrument(skip_all)]\n+    pub async fn store_payment_method_data_in_locker(",
        "comment_created_at": "2025-09-15T10:21:28+00:00",
        "comment_author": "AnuthaDev",
        "comment_body": "This is a trait method and has a v1 equivalent. Some functions common between v1 and v2 call this method, so renaming only in v2 would require additional boilerplate and I am not sure we should also rename it in v1.\r\n\r\nAdding a comment to explain it is temp locker",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254135951",
    "pr_number": 8628,
    "pr_file": "crates/router/src/types/api/fraud_check.rs",
    "created_at": "2025-08-05T12:01:45+00:00",
    "commented_code": "pub struct ConnectorRoutingData {\n     pub connector_data: ConnectorData,\n     pub network: Option<common_enums::CardNetwork>,\n+    pub action_type: Option<ActionType>,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2254135951",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8628,
        "pr_file": "crates/router/src/types/api/fraud_check.rs",
        "discussion_id": "2254135951",
        "commented_code": "@@ -33,6 +37,7 @@ pub enum ConnectorCallType {\n pub struct ConnectorRoutingData {\n     pub connector_data: ConnectorData,\n     pub network: Option<common_enums::CardNetwork>,\n+    pub action_type: Option<ActionType>,",
        "comment_created_at": "2025-08-05T12:01:45+00:00",
        "comment_author": "prasunna09",
        "comment_body": "please add  a comment that this is used for mandates currently. since `action_type` is not self-explanatory.",
        "pr_file_module": null
      },
      {
        "comment_id": "2319987075",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8628,
        "pr_file": "crates/router/src/types/api/fraud_check.rs",
        "discussion_id": "2254135951",
        "commented_code": "@@ -33,6 +37,7 @@ pub enum ConnectorCallType {\n pub struct ConnectorRoutingData {\n     pub connector_data: ConnectorData,\n     pub network: Option<common_enums::CardNetwork>,\n+    pub action_type: Option<ActionType>,",
        "comment_created_at": "2025-09-03T19:34:21+00:00",
        "comment_author": "prasunna09",
        "comment_body": "this can be `mandate_type` or some other similar name.\r\nAre we not modifying this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2300081809",
    "pr_number": 8728,
    "pr_file": "crates/hyperswitch_interfaces/src/api.rs",
    "created_at": "2025-08-26T07:35:17+00:00",
    "commented_code": "false\n     }\n \n+    /// Whether SDK session token generation is enabled for this connector\n+    fn is_sdk_session_token_generation_enabled(&self) -> bool {\n+        false\n+    }\n+\n+    /// Payment method types that support SDK session token generation\n+    fn supported_payment_methods_for_sdk_session_token(&self) -> Vec<PaymentMethodType> {\n+        vec![]\n+    }\n+\n+    /// Validate if SDK session token generation is allowed for given payment method type\n+    fn validate_sdk_session_token_for_payment_method(\n+        &self,\n+        current_core_payment_method_type: &PaymentMethodType,\n+    ) -> bool {\n+        if self.is_sdk_session_token_generation_enabled() {\n+            self.supported_payment_methods_for_sdk_session_token()\n+                .contains(current_core_payment_method_type)\n+        } else {\n+            false\n+        }\n+    }\n+",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2300081809",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8728,
        "pr_file": "crates/hyperswitch_interfaces/src/api.rs",
        "discussion_id": "2300081809",
        "commented_code": "@@ -397,6 +397,29 @@ pub trait ConnectorSpecifications {\n         false\n     }\n \n+    /// Whether SDK session token generation is enabled for this connector\n+    fn is_sdk_session_token_generation_enabled(&self) -> bool {\n+        false\n+    }\n+\n+    /// Payment method types that support SDK session token generation\n+    fn supported_payment_methods_for_sdk_session_token(&self) -> Vec<PaymentMethodType> {\n+        vec![]\n+    }\n+\n+    /// Validate if SDK session token generation is allowed for given payment method type\n+    fn validate_sdk_session_token_for_payment_method(\n+        &self,\n+        current_core_payment_method_type: &PaymentMethodType,\n+    ) -> bool {\n+        if self.is_sdk_session_token_generation_enabled() {\n+            self.supported_payment_methods_for_sdk_session_token()\n+                .contains(current_core_payment_method_type)\n+        } else {\n+            false\n+        }\n+    }\n+",
        "comment_created_at": "2025-08-26T07:35:17+00:00",
        "comment_author": "ShankarSinghC",
        "comment_body": "From the method names, it is not clear what the flow is \u2014 whether it is the Hyperswitch SDK flow or the client token generation flow.\r\n\r\nCan we name this better ?\r\nExample:\r\nis_sdk_client_token_generation_enabled",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2300086101",
    "pr_number": 8728,
    "pr_file": "crates/hyperswitch_interfaces/src/api.rs",
    "created_at": "2025-08-26T07:37:05+00:00",
    "commented_code": "false\n     }\n \n+    /// Whether SDK session token generation is enabled for this connector\n+    fn is_sdk_session_token_generation_enabled(&self) -> bool {\n+        false\n+    }\n+\n+    /// Payment method types that support SDK session token generation\n+    fn supported_payment_methods_for_sdk_session_token(&self) -> Vec<PaymentMethodType> {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2300086101",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8728,
        "pr_file": "crates/hyperswitch_interfaces/src/api.rs",
        "discussion_id": "2300086101",
        "commented_code": "@@ -397,6 +397,29 @@ pub trait ConnectorSpecifications {\n         false\n     }\n \n+    /// Whether SDK session token generation is enabled for this connector\n+    fn is_sdk_session_token_generation_enabled(&self) -> bool {\n+        false\n+    }\n+\n+    /// Payment method types that support SDK session token generation\n+    fn supported_payment_methods_for_sdk_session_token(&self) -> Vec<PaymentMethodType> {",
        "comment_created_at": "2025-08-26T07:37:05+00:00",
        "comment_author": "ShankarSinghC",
        "comment_body": "The method name says `supported_payment_methods` but it returns payment method types",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2340206354",
    "pr_number": 9303,
    "pr_file": "crates/hyperswitch_domain_models/src/router_response_types/subscriptions.rs",
    "created_at": "2025-09-11T11:06:34+00:00",
    "commented_code": "+use common_enums::enums;\n+use common_utils::types::MinorUnit;\n+use time::PrimitiveDateTime;\n+\n+#[derive(Debug, Clone)]\n+pub struct SubscriptionCreateResponse {\n+    pub subscription_id: String,\n+    pub status: String,\n+    pub customer_id: String,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2340206354",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9303,
        "pr_file": "crates/hyperswitch_domain_models/src/router_response_types/subscriptions.rs",
        "discussion_id": "2340206354",
        "commented_code": "@@ -0,0 +1,14 @@\n+use common_enums::enums;\n+use common_utils::types::MinorUnit;\n+use time::PrimitiveDateTime;\n+\n+#[derive(Debug, Clone)]\n+pub struct SubscriptionCreateResponse {\n+    pub subscription_id: String,\n+    pub status: String,\n+    pub customer_id: String,",
        "comment_created_at": "2025-09-11T11:06:34+00:00",
        "comment_author": "jagan-jaya",
        "comment_body": "```suggestion\r\n    pub customer_id: id_type::CustomerId,\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2320927008",
    "pr_number": 9123,
    "pr_file": "crates/api_models/src/subscription.rs",
    "created_at": "2025-09-04T06:04:48+00:00",
    "commented_code": "+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,\n+    pub plan_id: Option<String>,\n+    pub coupon_code: Option<String>,\n+    pub mca_id: Option<String>,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2320927008",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/api_models/src/subscription.rs",
        "discussion_id": "2320927008",
        "commented_code": "@@ -0,0 +1,108 @@\n+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,\n+    pub plan_id: Option<String>,\n+    pub coupon_code: Option<String>,\n+    pub mca_id: Option<String>,",
        "comment_created_at": "2025-09-04T06:04:48+00:00",
        "comment_author": "sai-harsha-vardhan",
        "comment_body": "Please use domain type for MCA ID",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2321180467",
    "pr_number": 9123,
    "pr_file": "crates/api_models/src/subscription.rs",
    "created_at": "2025-09-04T07:56:09+00:00",
    "commented_code": "+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2321180467",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/api_models/src/subscription.rs",
        "discussion_id": "2321180467",
        "commented_code": "@@ -0,0 +1,108 @@\n+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,",
        "comment_created_at": "2025-09-04T07:56:09+00:00",
        "comment_author": "sai-harsha-vardhan",
        "comment_body": "Can we have domain type for subscription_id?",
        "pr_file_module": null
      },
      {
        "comment_id": "2336650036",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/api_models/src/subscription.rs",
        "discussion_id": "2321180467",
        "commented_code": "@@ -0,0 +1,108 @@\n+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,",
        "comment_created_at": "2025-09-10T12:47:20+00:00",
        "comment_author": "prajjwalkumar17",
        "comment_body": "We can have this, probably in some another PR, if required an issue can be created, but right now due to push from product this can be ignored.",
        "pr_file_module": null
      },
      {
        "comment_id": "2339056773",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/api_models/src/subscription.rs",
        "discussion_id": "2321180467",
        "commented_code": "@@ -0,0 +1,108 @@\n+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,",
        "comment_created_at": "2025-09-11T07:13:35+00:00",
        "comment_author": "sai-harsha-vardhan",
        "comment_body": "Please create an issue for this",
        "pr_file_module": null
      },
      {
        "comment_id": "2339110893",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/api_models/src/subscription.rs",
        "discussion_id": "2321180467",
        "commented_code": "@@ -0,0 +1,108 @@\n+use common_utils::{events::ApiEventMetric, pii};\n+\n+use crate::{\n+    customers::{CustomerRequest, CustomerResponse},\n+    payments::CustomerDetailsResponse,\n+};\n+\n+pub const SUBSCRIPTION_ID_PREFIX: &str = \"sub\";\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct CreateSubscriptionRequest {\n+    pub subscription_id: Option<String>,",
        "comment_created_at": "2025-09-11T07:26:48+00:00",
        "comment_author": "sai-harsha-vardhan",
        "comment_body": "As this is relatively small change, it would be better if we make this changes here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135109496",
    "pr_number": 8197,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
    "created_at": "2025-06-09T06:25:24+00:00",
    "commented_code": "#[serde(rename = \"payment_method_options[card][network]\")]\n     pub payment_method_data_card_preferred_network: Option<StripeCardNetwork>,\n }\n+\n+#[derive(Debug, Eq, PartialEq, Serialize)]\n+pub struct StripeProxyCardData {\n+    #[serde(rename = \"payment_method_data[type]\")]\n+    pub payment_method_data_type: StripePaymentMethodType,\n+    #[serde(rename = \"payment_method_data[card][number]\")]\n+    pub payment_method_data_card_number: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_month]\")]\n+    pub payment_method_data_card_exp_month: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_year]\")]\n+    pub payment_method_data_card_exp_year: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][cvc]\")]\n+    pub payment_method_data_card_cvc: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][request_three_d_secure]\")]\n+    pub payment_method_auth_type: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][network]\")]\n+    pub payment_method_data_card_preferred_network: Option<Secret<String>>,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2135109496",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8197,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
        "discussion_id": "2135109496",
        "commented_code": "@@ -258,6 +258,25 @@ pub struct StripeCardData {\n     #[serde(rename = \"payment_method_options[card][network]\")]\n     pub payment_method_data_card_preferred_network: Option<StripeCardNetwork>,\n }\n+\n+#[derive(Debug, Eq, PartialEq, Serialize)]\n+pub struct StripeProxyCardData {\n+    #[serde(rename = \"payment_method_data[type]\")]\n+    pub payment_method_data_type: StripePaymentMethodType,\n+    #[serde(rename = \"payment_method_data[card][number]\")]\n+    pub payment_method_data_card_number: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_month]\")]\n+    pub payment_method_data_card_exp_month: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_year]\")]\n+    pub payment_method_data_card_exp_year: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][cvc]\")]\n+    pub payment_method_data_card_cvc: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][request_three_d_secure]\")]\n+    pub payment_method_auth_type: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][network]\")]\n+    pub payment_method_data_card_preferred_network: Option<Secret<String>>,",
        "comment_created_at": "2025-06-09T06:25:24+00:00",
        "comment_author": "deepanshu-iiitu",
        "comment_body": "Can we use enum StripeCardNetwork instead of String?",
        "pr_file_module": null
      },
      {
        "comment_id": "2135137465",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8197,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/stripe/transformers.rs",
        "discussion_id": "2135109496",
        "commented_code": "@@ -258,6 +258,25 @@ pub struct StripeCardData {\n     #[serde(rename = \"payment_method_options[card][network]\")]\n     pub payment_method_data_card_preferred_network: Option<StripeCardNetwork>,\n }\n+\n+#[derive(Debug, Eq, PartialEq, Serialize)]\n+pub struct StripeProxyCardData {\n+    #[serde(rename = \"payment_method_data[type]\")]\n+    pub payment_method_data_type: StripePaymentMethodType,\n+    #[serde(rename = \"payment_method_data[card][number]\")]\n+    pub payment_method_data_card_number: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_month]\")]\n+    pub payment_method_data_card_exp_month: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][exp_year]\")]\n+    pub payment_method_data_card_exp_year: Secret<String>,\n+    #[serde(rename = \"payment_method_data[card][cvc]\")]\n+    pub payment_method_data_card_cvc: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][request_three_d_secure]\")]\n+    pub payment_method_auth_type: Option<Secret<String>>,\n+    #[serde(rename = \"payment_method_options[card][network]\")]\n+    pub payment_method_data_card_preferred_network: Option<Secret<String>>,",
        "comment_created_at": "2025-06-09T06:47:12+00:00",
        "comment_author": "su-shivanshmathur",
        "comment_body": "Sure",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2309707429",
    "pr_number": 9030,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/peachpayments/transformers.rs",
    "created_at": "2025-08-29T09:44:29+00:00",
    "commented_code": "+use common_enums::enums;\n+use common_utils::types::{StringMinorUnit, StringMinorUnitForConnector, AmountConvertor};\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n+    router_flow_types::refunds::{Execute, RSync},\n+    router_request_types::ResponseId,\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsCancelRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{Secret, ExposeInterface};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+};\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PeachpaymentsRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PeachpaymentsRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Card Gateway API Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsPaymentsRequest {\n+    #[serde(rename = \"chargeMethod\")]\n+    pub charge_method: String,\n+    #[serde(rename = \"referenceId\")]\n+    pub reference_id: String,\n+    #[serde(rename = \"ecommerceCardPaymentOnlyTransactionData\")]\n+    pub ecommerce_card_payment_only_transaction_data: EcommerceCardPaymentOnlyTransactionData,\n+    #[serde(rename = \"posData\")]\n+    pub pos_data: serde_json::Value,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyTransactionData {\n+    #[serde(rename = \"merchantInformation\")]\n+    pub merchant_information: MerchantInformation,\n+    pub routing: Routing,\n+    pub card: CardDetails,\n+    pub amount: AmountDetails,\n+    #[serde(rename = \"threeDSData\", skip_serializing_if = \"Option::is_none\")]\n+    pub three_ds_data: Option<ThreeDSData>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct MerchantInformation {\n+    #[serde(rename = \"clientMerchantReferenceId\")]\n+    pub client_merchant_reference_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub name: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mcc: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub phone: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub email: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mobile: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub address: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub city: Option<String>,\n+    #[serde(rename = \"postalCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub postal_code: Option<String>,\n+    #[serde(rename = \"regionCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub region_code: Option<String>,\n+    #[serde(rename = \"merchantType\", skip_serializing_if = \"Option::is_none\")]\n+    pub merchant_type: Option<String>,\n+    #[serde(rename = \"websiteUrl\", skip_serializing_if = \"Option::is_none\")]\n+    pub website_url: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct Routing {\n+    pub route: String,\n+    pub mid: String,\n+    pub tid: String,\n+    #[serde(rename = \"visaPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub visa_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"masterCardPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub master_card_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"subMid\", skip_serializing_if = \"Option::is_none\")]\n+    pub sub_mid: Option<String>,\n+    #[serde(rename = \"amexId\", skip_serializing_if = \"Option::is_none\")]\n+    pub amex_id: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct CardDetails {\n+    pub pan: Secret<String>,\n+    #[serde(rename = \"cardholderName\", skip_serializing_if = \"Option::is_none\")]\n+    pub cardholder_name: Option<Secret<String>>,\n+    #[serde(rename = \"expiryYear\")]\n+    pub expiry_year: Secret<String>,\n+    #[serde(rename = \"expiryMonth\")]\n+    pub expiry_month: Secret<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cvv: Option<Secret<String>>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n+pub struct AmountDetails {\n+    pub amount: i64,\n+    #[serde(rename = \"currencyCode\")]\n+    pub currency_code: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct ThreeDSData {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cavv: Option<Secret<String>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tavv: Option<Secret<String>>,\n+    pub eci: String,\n+    #[serde(rename = \"dsTransId\")]\n+    pub ds_trans_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub xid: Option<String>,\n+    #[serde(rename = \"authenticationStatus\")]\n+    pub authentication_status: String,\n+    #[serde(rename = \"threeDSVersion\")]\n+    pub three_ds_version: String,\n+}\n+\n+// Confirm Transaction Request (for capture)\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsConfirmRequest {\n+    #[serde(rename = \"ecommerceCardPaymentOnlyConfirmationData\")]\n+    pub ecommerce_card_payment_only_confirmation_data: EcommerceCardPaymentOnlyConfirmationData,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyConfirmationData {\n+    pub amount: AmountDetails,\n+}\n+\n+// Void Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsVoidRequest {\n+    #[serde(rename = \"paymentMethod\")]\n+    pub payment_method: String,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+    #[serde(rename = \"failureReason\")]\n+    pub failure_reason: String,\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsCaptureRouterData>>\n+    for PeachpaymentsConfirmRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let amount_in_cents = StringMinorUnitForConnector\n+            .convert_back(item.amount.clone(), item.router_data.request.currency)\n+            .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+            .get_amount_as_i64();\n+\n+        let amount = AmountDetails {\n+            amount: amount_in_cents,\n+            currency_code: item.router_data.request.currency.to_string(),\n+        };\n+\n+        let confirmation_data = EcommerceCardPaymentOnlyConfirmationData {\n+            amount,\n+        };\n+\n+        Ok(Self {\n+            ecommerce_card_payment_only_confirmation_data: confirmation_data,\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PaymentsCancelRouterData> for PeachpaymentsVoidRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(item: &PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n+        use std::time::{SystemTime, UNIX_EPOCH};\n+        \n+        // Create simple UTC timestamp - PeachPayments expects ISO 8601 format\n+        let now = SystemTime::now()\n+            .duration_since(UNIX_EPOCH)\n+            .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?\n+            .as_secs();\n+        \n+        // Create a simple ISO 8601 timestamp (YYYY-MM-DDTHH:MM:SSZ format)\n+        // For simplicity, we'll use a basic format that should be acceptable\n+        let send_date_time = format!(\"{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z\",\n+            1970 + (now / 31536000), // Very rough year calculation\n+            1 + ((now % 31536000) / 2628000), // Very rough month\n+            1 + ((now % 2628000) / 86400), // Day\n+            (now % 86400) / 3600, // Hour\n+            (now % 3600) / 60, // Minute\n+            now % 60 // Second\n+        );\n+        \n+        Ok(Self {\n+            payment_method: \"ecommerce_card_payment_only\".to_string(),",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2309707429",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9030,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/peachpayments/transformers.rs",
        "discussion_id": "2309707429",
        "commented_code": "@@ -0,0 +1,976 @@\n+use common_enums::enums;\n+use common_utils::types::{StringMinorUnit, StringMinorUnitForConnector, AmountConvertor};\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n+    router_flow_types::refunds::{Execute, RSync},\n+    router_request_types::ResponseId,\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsCancelRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{Secret, ExposeInterface};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+};\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PeachpaymentsRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PeachpaymentsRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Card Gateway API Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsPaymentsRequest {\n+    #[serde(rename = \"chargeMethod\")]\n+    pub charge_method: String,\n+    #[serde(rename = \"referenceId\")]\n+    pub reference_id: String,\n+    #[serde(rename = \"ecommerceCardPaymentOnlyTransactionData\")]\n+    pub ecommerce_card_payment_only_transaction_data: EcommerceCardPaymentOnlyTransactionData,\n+    #[serde(rename = \"posData\")]\n+    pub pos_data: serde_json::Value,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyTransactionData {\n+    #[serde(rename = \"merchantInformation\")]\n+    pub merchant_information: MerchantInformation,\n+    pub routing: Routing,\n+    pub card: CardDetails,\n+    pub amount: AmountDetails,\n+    #[serde(rename = \"threeDSData\", skip_serializing_if = \"Option::is_none\")]\n+    pub three_ds_data: Option<ThreeDSData>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct MerchantInformation {\n+    #[serde(rename = \"clientMerchantReferenceId\")]\n+    pub client_merchant_reference_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub name: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mcc: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub phone: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub email: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mobile: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub address: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub city: Option<String>,\n+    #[serde(rename = \"postalCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub postal_code: Option<String>,\n+    #[serde(rename = \"regionCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub region_code: Option<String>,\n+    #[serde(rename = \"merchantType\", skip_serializing_if = \"Option::is_none\")]\n+    pub merchant_type: Option<String>,\n+    #[serde(rename = \"websiteUrl\", skip_serializing_if = \"Option::is_none\")]\n+    pub website_url: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct Routing {\n+    pub route: String,\n+    pub mid: String,\n+    pub tid: String,\n+    #[serde(rename = \"visaPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub visa_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"masterCardPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub master_card_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"subMid\", skip_serializing_if = \"Option::is_none\")]\n+    pub sub_mid: Option<String>,\n+    #[serde(rename = \"amexId\", skip_serializing_if = \"Option::is_none\")]\n+    pub amex_id: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct CardDetails {\n+    pub pan: Secret<String>,\n+    #[serde(rename = \"cardholderName\", skip_serializing_if = \"Option::is_none\")]\n+    pub cardholder_name: Option<Secret<String>>,\n+    #[serde(rename = \"expiryYear\")]\n+    pub expiry_year: Secret<String>,\n+    #[serde(rename = \"expiryMonth\")]\n+    pub expiry_month: Secret<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cvv: Option<Secret<String>>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n+pub struct AmountDetails {\n+    pub amount: i64,\n+    #[serde(rename = \"currencyCode\")]\n+    pub currency_code: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct ThreeDSData {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cavv: Option<Secret<String>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tavv: Option<Secret<String>>,\n+    pub eci: String,\n+    #[serde(rename = \"dsTransId\")]\n+    pub ds_trans_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub xid: Option<String>,\n+    #[serde(rename = \"authenticationStatus\")]\n+    pub authentication_status: String,\n+    #[serde(rename = \"threeDSVersion\")]\n+    pub three_ds_version: String,\n+}\n+\n+// Confirm Transaction Request (for capture)\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsConfirmRequest {\n+    #[serde(rename = \"ecommerceCardPaymentOnlyConfirmationData\")]\n+    pub ecommerce_card_payment_only_confirmation_data: EcommerceCardPaymentOnlyConfirmationData,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyConfirmationData {\n+    pub amount: AmountDetails,\n+}\n+\n+// Void Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsVoidRequest {\n+    #[serde(rename = \"paymentMethod\")]\n+    pub payment_method: String,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+    #[serde(rename = \"failureReason\")]\n+    pub failure_reason: String,\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsCaptureRouterData>>\n+    for PeachpaymentsConfirmRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let amount_in_cents = StringMinorUnitForConnector\n+            .convert_back(item.amount.clone(), item.router_data.request.currency)\n+            .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+            .get_amount_as_i64();\n+\n+        let amount = AmountDetails {\n+            amount: amount_in_cents,\n+            currency_code: item.router_data.request.currency.to_string(),\n+        };\n+\n+        let confirmation_data = EcommerceCardPaymentOnlyConfirmationData {\n+            amount,\n+        };\n+\n+        Ok(Self {\n+            ecommerce_card_payment_only_confirmation_data: confirmation_data,\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PaymentsCancelRouterData> for PeachpaymentsVoidRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(item: &PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n+        use std::time::{SystemTime, UNIX_EPOCH};\n+        \n+        // Create simple UTC timestamp - PeachPayments expects ISO 8601 format\n+        let now = SystemTime::now()\n+            .duration_since(UNIX_EPOCH)\n+            .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?\n+            .as_secs();\n+        \n+        // Create a simple ISO 8601 timestamp (YYYY-MM-DDTHH:MM:SSZ format)\n+        // For simplicity, we'll use a basic format that should be acceptable\n+        let send_date_time = format!(\"{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z\",\n+            1970 + (now / 31536000), // Very rough year calculation\n+            1 + ((now % 31536000) / 2628000), // Very rough month\n+            1 + ((now % 2628000) / 86400), // Day\n+            (now % 86400) / 3600, // Hour\n+            (now % 3600) / 60, // Minute\n+            now % 60 // Second\n+        );\n+        \n+        Ok(Self {\n+            payment_method: \"ecommerce_card_payment_only\".to_string(),",
        "comment_created_at": "2025-08-29T09:44:29+00:00",
        "comment_author": "bsayak03",
        "comment_body": "Can we make this field's type a enum and add `ecommerce_card_payment_only` as an enum variant?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2309835048",
    "pr_number": 9030,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/peachpayments/transformers.rs",
    "created_at": "2025-08-29T10:44:50+00:00",
    "commented_code": "+use common_enums::enums;\n+use common_utils::types::{StringMinorUnit, StringMinorUnitForConnector, AmountConvertor};\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n+    router_flow_types::refunds::{Execute, RSync},\n+    router_request_types::ResponseId,\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsCancelRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{Secret, ExposeInterface};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+};\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PeachpaymentsRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PeachpaymentsRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Card Gateway API Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsPaymentsRequest {\n+    #[serde(rename = \"chargeMethod\")]\n+    pub charge_method: String,\n+    #[serde(rename = \"referenceId\")]\n+    pub reference_id: String,\n+    #[serde(rename = \"ecommerceCardPaymentOnlyTransactionData\")]\n+    pub ecommerce_card_payment_only_transaction_data: EcommerceCardPaymentOnlyTransactionData,\n+    #[serde(rename = \"posData\")]\n+    pub pos_data: serde_json::Value,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyTransactionData {\n+    #[serde(rename = \"merchantInformation\")]\n+    pub merchant_information: MerchantInformation,\n+    pub routing: Routing,\n+    pub card: CardDetails,\n+    pub amount: AmountDetails,\n+    #[serde(rename = \"threeDSData\", skip_serializing_if = \"Option::is_none\")]\n+    pub three_ds_data: Option<ThreeDSData>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct MerchantInformation {\n+    #[serde(rename = \"clientMerchantReferenceId\")]\n+    pub client_merchant_reference_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub name: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mcc: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub phone: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub email: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mobile: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub address: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub city: Option<String>,\n+    #[serde(rename = \"postalCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub postal_code: Option<String>,\n+    #[serde(rename = \"regionCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub region_code: Option<String>,\n+    #[serde(rename = \"merchantType\", skip_serializing_if = \"Option::is_none\")]\n+    pub merchant_type: Option<String>,\n+    #[serde(rename = \"websiteUrl\", skip_serializing_if = \"Option::is_none\")]\n+    pub website_url: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct Routing {\n+    pub route: String,\n+    pub mid: String,\n+    pub tid: String,\n+    #[serde(rename = \"visaPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub visa_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"masterCardPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub master_card_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"subMid\", skip_serializing_if = \"Option::is_none\")]\n+    pub sub_mid: Option<String>,\n+    #[serde(rename = \"amexId\", skip_serializing_if = \"Option::is_none\")]\n+    pub amex_id: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct CardDetails {\n+    pub pan: Secret<String>,\n+    #[serde(rename = \"cardholderName\", skip_serializing_if = \"Option::is_none\")]\n+    pub cardholder_name: Option<Secret<String>>,\n+    #[serde(rename = \"expiryYear\")]\n+    pub expiry_year: Secret<String>,\n+    #[serde(rename = \"expiryMonth\")]\n+    pub expiry_month: Secret<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cvv: Option<Secret<String>>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n+pub struct AmountDetails {\n+    pub amount: i64,\n+    #[serde(rename = \"currencyCode\")]\n+    pub currency_code: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct ThreeDSData {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cavv: Option<Secret<String>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tavv: Option<Secret<String>>,\n+    pub eci: String,\n+    #[serde(rename = \"dsTransId\")]\n+    pub ds_trans_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub xid: Option<String>,\n+    #[serde(rename = \"authenticationStatus\")]\n+    pub authentication_status: String,\n+    #[serde(rename = \"threeDSVersion\")]\n+    pub three_ds_version: String,\n+}\n+\n+// Confirm Transaction Request (for capture)\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsConfirmRequest {\n+    #[serde(rename = \"ecommerceCardPaymentOnlyConfirmationData\")]\n+    pub ecommerce_card_payment_only_confirmation_data: EcommerceCardPaymentOnlyConfirmationData,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyConfirmationData {\n+    pub amount: AmountDetails,\n+}\n+\n+// Void Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsVoidRequest {\n+    #[serde(rename = \"paymentMethod\")]\n+    pub payment_method: String,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+    #[serde(rename = \"failureReason\")]\n+    pub failure_reason: String,\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsCaptureRouterData>>\n+    for PeachpaymentsConfirmRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let amount_in_cents = StringMinorUnitForConnector\n+            .convert_back(item.amount.clone(), item.router_data.request.currency)\n+            .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+            .get_amount_as_i64();\n+\n+        let amount = AmountDetails {\n+            amount: amount_in_cents,\n+            currency_code: item.router_data.request.currency.to_string(),\n+        };\n+\n+        let confirmation_data = EcommerceCardPaymentOnlyConfirmationData {\n+            amount,\n+        };\n+\n+        Ok(Self {\n+            ecommerce_card_payment_only_confirmation_data: confirmation_data,\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PaymentsCancelRouterData> for PeachpaymentsVoidRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(item: &PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n+        use std::time::{SystemTime, UNIX_EPOCH};\n+        \n+        // Create simple UTC timestamp - PeachPayments expects ISO 8601 format\n+        let now = SystemTime::now()\n+            .duration_since(UNIX_EPOCH)\n+            .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?\n+            .as_secs();\n+        \n+        // Create a simple ISO 8601 timestamp (YYYY-MM-DDTHH:MM:SSZ format)\n+        // For simplicity, we'll use a basic format that should be acceptable\n+        let send_date_time = format!(\"{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z\",\n+            1970 + (now / 31536000), // Very rough year calculation\n+            1 + ((now % 31536000) / 2628000), // Very rough month\n+            1 + ((now % 2628000) / 86400), // Day\n+            (now % 86400) / 3600, // Hour\n+            (now % 3600) / 60, // Minute\n+            now % 60 // Second\n+        );\n+        \n+        Ok(Self {\n+            payment_method: \"ecommerce_card_payment_only\".to_string(),\n+            send_date_time,\n+            failure_reason: item.request.cancellation_reason\n+                .as_ref()\n+                .map(|reason| reason.to_string())\n+                .unwrap_or_else(|| \"timeout\".to_string()), // Use timeout as default like the script\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsAuthorizeRouterData>>\n+    for PeachpaymentsPaymentsRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                let amount_in_cents = StringMinorUnitForConnector\n+                    .convert_back(item.amount.clone(), item.router_data.request.currency)\n+                    .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+                    .get_amount_as_i64();\n+\n+                // Get merchant metadata from connector configuration\n+                let metadata = item.router_data.connector_meta_data.as_ref()\n+                    .ok_or(errors::ConnectorError::NoConnectorMetaData)?\n+                    .clone()\n+                    .expose();\n+                \n+                let metadata_obj = metadata.as_object()\n+                    .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                        config: \"connector metadata must be a JSON object\"\n+                    })?;\n+                \n+                let merchant_information = MerchantInformation {\n+                    client_merchant_reference_id: item.router_data.connector_request_reference_id.clone(),\n+                    name: metadata_obj.get(\"merchant_name\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    mcc: metadata_obj.get(\"mcc\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    phone: metadata_obj.get(\"merchant_phone\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    email: metadata_obj.get(\"merchant_email\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    mobile: metadata_obj.get(\"merchant_mobile\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    address: metadata_obj.get(\"merchant_address\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    city: metadata_obj.get(\"merchant_city\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    postal_code: metadata_obj.get(\"merchant_postal_code\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    region_code: metadata_obj.get(\"merchant_region_code\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    merchant_type: metadata_obj.get(\"merchant_type\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    website_url: metadata_obj.get(\"merchant_website\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                };\n+\n+                // Get routing configuration from metadata\n+                let routing = Routing {\n+                    route: metadata_obj.get(\"routing_route\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_route is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    mid: metadata_obj.get(\"routing_mid\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_mid is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    tid: metadata_obj.get(\"routing_tid\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_tid is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    visa_payment_facilitator_id: metadata_obj.get(\"visa_payment_facilitator_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    master_card_payment_facilitator_id: metadata_obj.get(\"master_card_payment_facilitator_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    sub_mid: metadata_obj.get(\"sub_mid\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    amex_id: metadata_obj.get(\"amex_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                };\n+\n+                let card = CardDetails {\n+                    pan: Secret::new(req_card.card_number.to_string()),\n+                    cardholder_name: req_card.card_holder_name.map(|name| name),\n+                    expiry_year: {\n+                        // Convert 4-digit year to 2-digit year (e.g., \"2025\" -> \"25\")\n+                        let year_str = req_card.card_exp_year.clone().expose();\n+                        if year_str.len() == 4 {\n+                            Secret::new(year_str[2..].to_string())\n+                        } else {\n+                            req_card.card_exp_year.clone()\n+                        }\n+                    },\n+                    expiry_month: req_card.card_exp_month.clone(),\n+                    cvv: Some(req_card.card_cvc.clone()),\n+                };\n+\n+                let amount = AmountDetails {\n+                    amount: amount_in_cents,\n+                    currency_code: item.router_data.request.currency.to_string(),\n+                };\n+\n+                // Extract 3DS data if available\n+                let three_ds_data = item.router_data.request.authentication_data.as_ref().and_then(|auth_data| {\n+                    // Only include 3DS data if we have essential fields (ECI is most critical)\n+                    if let Some(eci) = &auth_data.eci {\n+                        let ds_trans_id = auth_data.ds_trans_id.clone()\n+                            .or_else(|| auth_data.threeds_server_transaction_id.clone())?;\n+                        \n+                        // Determine authentication status based on ECI value\n+                        let authentication_status = match eci.as_str() {\n+                            \"05\" | \"06\" => \"Y\".to_string(),  // Fully authenticated\n+                            \"07\" => \"A\".to_string(),         // Attempted authentication / liability shift \n+                            _ => \"N\".to_string(),            // Not authenticated / failed\n+                        };\n+",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2309835048",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9030,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/peachpayments/transformers.rs",
        "discussion_id": "2309835048",
        "commented_code": "@@ -0,0 +1,976 @@\n+use common_enums::enums;\n+use common_utils::types::{StringMinorUnit, StringMinorUnitForConnector, AmountConvertor};\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, ErrorResponse, RouterData},\n+    router_flow_types::refunds::{Execute, RSync},\n+    router_request_types::ResponseId,\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, PaymentsCancelRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{Secret, ExposeInterface};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+};\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PeachpaymentsRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PeachpaymentsRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Card Gateway API Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsPaymentsRequest {\n+    #[serde(rename = \"chargeMethod\")]\n+    pub charge_method: String,\n+    #[serde(rename = \"referenceId\")]\n+    pub reference_id: String,\n+    #[serde(rename = \"ecommerceCardPaymentOnlyTransactionData\")]\n+    pub ecommerce_card_payment_only_transaction_data: EcommerceCardPaymentOnlyTransactionData,\n+    #[serde(rename = \"posData\")]\n+    pub pos_data: serde_json::Value,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyTransactionData {\n+    #[serde(rename = \"merchantInformation\")]\n+    pub merchant_information: MerchantInformation,\n+    pub routing: Routing,\n+    pub card: CardDetails,\n+    pub amount: AmountDetails,\n+    #[serde(rename = \"threeDSData\", skip_serializing_if = \"Option::is_none\")]\n+    pub three_ds_data: Option<ThreeDSData>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct MerchantInformation {\n+    #[serde(rename = \"clientMerchantReferenceId\")]\n+    pub client_merchant_reference_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub name: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mcc: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub phone: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub email: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub mobile: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub address: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub city: Option<String>,\n+    #[serde(rename = \"postalCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub postal_code: Option<String>,\n+    #[serde(rename = \"regionCode\", skip_serializing_if = \"Option::is_none\")]\n+    pub region_code: Option<String>,\n+    #[serde(rename = \"merchantType\", skip_serializing_if = \"Option::is_none\")]\n+    pub merchant_type: Option<String>,\n+    #[serde(rename = \"websiteUrl\", skip_serializing_if = \"Option::is_none\")]\n+    pub website_url: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct Routing {\n+    pub route: String,\n+    pub mid: String,\n+    pub tid: String,\n+    #[serde(rename = \"visaPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub visa_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"masterCardPaymentFacilitatorId\", skip_serializing_if = \"Option::is_none\")]\n+    pub master_card_payment_facilitator_id: Option<String>,\n+    #[serde(rename = \"subMid\", skip_serializing_if = \"Option::is_none\")]\n+    pub sub_mid: Option<String>,\n+    #[serde(rename = \"amexId\", skip_serializing_if = \"Option::is_none\")]\n+    pub amex_id: Option<String>,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct CardDetails {\n+    pub pan: Secret<String>,\n+    #[serde(rename = \"cardholderName\", skip_serializing_if = \"Option::is_none\")]\n+    pub cardholder_name: Option<Secret<String>>,\n+    #[serde(rename = \"expiryYear\")]\n+    pub expiry_year: Secret<String>,\n+    #[serde(rename = \"expiryMonth\")]\n+    pub expiry_month: Secret<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cvv: Option<Secret<String>>,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n+pub struct AmountDetails {\n+    pub amount: i64,\n+    #[serde(rename = \"currencyCode\")]\n+    pub currency_code: String,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct ThreeDSData {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub cavv: Option<Secret<String>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tavv: Option<Secret<String>>,\n+    pub eci: String,\n+    #[serde(rename = \"dsTransId\")]\n+    pub ds_trans_id: String,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub xid: Option<String>,\n+    #[serde(rename = \"authenticationStatus\")]\n+    pub authentication_status: String,\n+    #[serde(rename = \"threeDSVersion\")]\n+    pub three_ds_version: String,\n+}\n+\n+// Confirm Transaction Request (for capture)\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsConfirmRequest {\n+    #[serde(rename = \"ecommerceCardPaymentOnlyConfirmationData\")]\n+    pub ecommerce_card_payment_only_confirmation_data: EcommerceCardPaymentOnlyConfirmationData,\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct EcommerceCardPaymentOnlyConfirmationData {\n+    pub amount: AmountDetails,\n+}\n+\n+// Void Transaction Request\n+#[derive(Debug, Serialize, PartialEq)]\n+pub struct PeachpaymentsVoidRequest {\n+    #[serde(rename = \"paymentMethod\")]\n+    pub payment_method: String,\n+    #[serde(rename = \"sendDateTime\")]\n+    pub send_date_time: String,\n+    #[serde(rename = \"failureReason\")]\n+    pub failure_reason: String,\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsCaptureRouterData>>\n+    for PeachpaymentsConfirmRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        let amount_in_cents = StringMinorUnitForConnector\n+            .convert_back(item.amount.clone(), item.router_data.request.currency)\n+            .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+            .get_amount_as_i64();\n+\n+        let amount = AmountDetails {\n+            amount: amount_in_cents,\n+            currency_code: item.router_data.request.currency.to_string(),\n+        };\n+\n+        let confirmation_data = EcommerceCardPaymentOnlyConfirmationData {\n+            amount,\n+        };\n+\n+        Ok(Self {\n+            ecommerce_card_payment_only_confirmation_data: confirmation_data,\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PaymentsCancelRouterData> for PeachpaymentsVoidRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(item: &PaymentsCancelRouterData) -> Result<Self, Self::Error> {\n+        use std::time::{SystemTime, UNIX_EPOCH};\n+        \n+        // Create simple UTC timestamp - PeachPayments expects ISO 8601 format\n+        let now = SystemTime::now()\n+            .duration_since(UNIX_EPOCH)\n+            .map_err(|_| errors::ConnectorError::RequestEncodingFailed)?\n+            .as_secs();\n+        \n+        // Create a simple ISO 8601 timestamp (YYYY-MM-DDTHH:MM:SSZ format)\n+        // For simplicity, we'll use a basic format that should be acceptable\n+        let send_date_time = format!(\"{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z\",\n+            1970 + (now / 31536000), // Very rough year calculation\n+            1 + ((now % 31536000) / 2628000), // Very rough month\n+            1 + ((now % 2628000) / 86400), // Day\n+            (now % 86400) / 3600, // Hour\n+            (now % 3600) / 60, // Minute\n+            now % 60 // Second\n+        );\n+        \n+        Ok(Self {\n+            payment_method: \"ecommerce_card_payment_only\".to_string(),\n+            send_date_time,\n+            failure_reason: item.request.cancellation_reason\n+                .as_ref()\n+                .map(|reason| reason.to_string())\n+                .unwrap_or_else(|| \"timeout\".to_string()), // Use timeout as default like the script\n+        })\n+    }\n+}\n+\n+impl TryFrom<&PeachpaymentsRouterData<&PaymentsAuthorizeRouterData>>\n+    for PeachpaymentsPaymentsRequest\n+{\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PeachpaymentsRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                let amount_in_cents = StringMinorUnitForConnector\n+                    .convert_back(item.amount.clone(), item.router_data.request.currency)\n+                    .map_err(|_| errors::ConnectorError::ParsingFailed)?\n+                    .get_amount_as_i64();\n+\n+                // Get merchant metadata from connector configuration\n+                let metadata = item.router_data.connector_meta_data.as_ref()\n+                    .ok_or(errors::ConnectorError::NoConnectorMetaData)?\n+                    .clone()\n+                    .expose();\n+                \n+                let metadata_obj = metadata.as_object()\n+                    .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                        config: \"connector metadata must be a JSON object\"\n+                    })?;\n+                \n+                let merchant_information = MerchantInformation {\n+                    client_merchant_reference_id: item.router_data.connector_request_reference_id.clone(),\n+                    name: metadata_obj.get(\"merchant_name\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    mcc: metadata_obj.get(\"mcc\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    phone: metadata_obj.get(\"merchant_phone\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    email: metadata_obj.get(\"merchant_email\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    mobile: metadata_obj.get(\"merchant_mobile\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    address: metadata_obj.get(\"merchant_address\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    city: metadata_obj.get(\"merchant_city\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    postal_code: metadata_obj.get(\"merchant_postal_code\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    region_code: metadata_obj.get(\"merchant_region_code\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    merchant_type: metadata_obj.get(\"merchant_type\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    website_url: metadata_obj.get(\"merchant_website\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                };\n+\n+                // Get routing configuration from metadata\n+                let routing = Routing {\n+                    route: metadata_obj.get(\"routing_route\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_route is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    mid: metadata_obj.get(\"routing_mid\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_mid is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    tid: metadata_obj.get(\"routing_tid\")\n+                        .and_then(|v| v.as_str())\n+                        .ok_or(errors::ConnectorError::InvalidConnectorConfig { \n+                            config: \"routing_tid is required in connector metadata\"\n+                        })?\n+                        .to_string(),\n+                    visa_payment_facilitator_id: metadata_obj.get(\"visa_payment_facilitator_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    master_card_payment_facilitator_id: metadata_obj.get(\"master_card_payment_facilitator_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    sub_mid: metadata_obj.get(\"sub_mid\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                    amex_id: metadata_obj.get(\"amex_id\")\n+                        .and_then(|v| v.as_str())\n+                        .map(|s| s.to_string()),\n+                };\n+\n+                let card = CardDetails {\n+                    pan: Secret::new(req_card.card_number.to_string()),\n+                    cardholder_name: req_card.card_holder_name.map(|name| name),\n+                    expiry_year: {\n+                        // Convert 4-digit year to 2-digit year (e.g., \"2025\" -> \"25\")\n+                        let year_str = req_card.card_exp_year.clone().expose();\n+                        if year_str.len() == 4 {\n+                            Secret::new(year_str[2..].to_string())\n+                        } else {\n+                            req_card.card_exp_year.clone()\n+                        }\n+                    },\n+                    expiry_month: req_card.card_exp_month.clone(),\n+                    cvv: Some(req_card.card_cvc.clone()),\n+                };\n+\n+                let amount = AmountDetails {\n+                    amount: amount_in_cents,\n+                    currency_code: item.router_data.request.currency.to_string(),\n+                };\n+\n+                // Extract 3DS data if available\n+                let three_ds_data = item.router_data.request.authentication_data.as_ref().and_then(|auth_data| {\n+                    // Only include 3DS data if we have essential fields (ECI is most critical)\n+                    if let Some(eci) = &auth_data.eci {\n+                        let ds_trans_id = auth_data.ds_trans_id.clone()\n+                            .or_else(|| auth_data.threeds_server_transaction_id.clone())?;\n+                        \n+                        // Determine authentication status based on ECI value\n+                        let authentication_status = match eci.as_str() {\n+                            \"05\" | \"06\" => \"Y\".to_string(),  // Fully authenticated\n+                            \"07\" => \"A\".to_string(),         // Attempted authentication / liability shift \n+                            _ => \"N\".to_string(),            // Not authenticated / failed\n+                        };\n+                        ",
        "comment_created_at": "2025-08-29T10:44:50+00:00",
        "comment_author": "bsayak03",
        "comment_body": "can we make `authentication_status` field an enum which contains variants like `Y`, `A` and `N`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179738646",
    "pr_number": 8500,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/payload/transformers.rs",
    "created_at": "2025-07-02T10:47:23+00:00",
    "commented_code": "+use common_enums::enums;\n+use common_utils::types::StringMinorUnit;\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, RouterData},\n+    router_flow_types::{\n+        payments::PaymentMethodToken,\n+        refunds::{Execute, RSync},\n+    },\n+    router_request_types::{PaymentMethodTokenizationData, ResponseId},\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{PeekInterface, Secret};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::RouterData as _,\n+};\n+\n+// Webhook structures for Payload API\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookBody {\n+    pub id: String,\n+    pub event: String,\n+    pub data: PayloadWebhookData,\n+    pub created_at: String,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookData {\n+    pub transaction: Option<PayloadPaymentsResponse>,\n+    pub refund: Option<RefundResponse>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookSignature {\n+    pub timestamp: String,\n+    pub signature: String,\n+}\n+\n+// Struct to represent billing address fields for Payload API\n+#[derive(Debug)]\n+struct BillingAddressFields {\n+    line1: Option<String>,\n+    city: Option<String>,\n+    state: Option<String>,\n+    postal_code: Option<String>,\n+    country: Option<String>,\n+}\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PayloadRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PayloadRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Request structures for Payload API (form-urlencoded) - Flattened with bracket notation for nested fields\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub struct PayloadPaymentsRequest {\n+    amount: StringMinorUnit,\n+    #[serde(rename = \"type\")]\n+    r#type: String,\n+    status: String,\n+    #[serde(rename = \"payment_method[type]\")]\n+    payment_method_type: String,\n+    #[serde(\n+        rename = \"payment_method[card][card_number]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_number: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][expiry]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_expiry: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][card_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_code: Option<String>,\n+    #[serde(rename = \"payment_method[id]\", skip_serializing_if = \"Option::is_none\")]\n+    payment_method_id: Option<String>, // For tokenized payments\n+    // Billing address fields for AVS validation\n+    #[serde(\n+        rename = \"payment_method[billing_address][street_address]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_line1: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][city]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_city: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][state_province]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_state: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][postal_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_postal_code: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][country_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_country: Option<String>,\n+}\n+\n+// Capture request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCaptureRequest {\n+    status: String,\n+}\n+\n+// Cancel/Void request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCancelRequest {\n+    status: String,\n+}\n+\n+// Helper function to extract billing address from router data\n+fn extract_billing_address_for_payload(\n+    address_details: Option<&hyperswitch_domain_models::address::Address>,\n+) -> BillingAddressFields {\n+    match address_details.and_then(|addr| addr.address.as_ref()) {\n+        Some(address) => BillingAddressFields {\n+            // Extract actual address fields, converting Secret<String> to String\n+            line1: address.line1.as_ref().map(|line1| line1.peek().to_string()),\n+            city: address.city.clone(),\n+            state: address.state.as_ref().map(|state| state.peek().to_string()),\n+            postal_code: address.zip.as_ref().map(|zip| zip.peek().to_string()),\n+            country: address.country.map(|country| country.to_string()),\n+        },\n+        None => BillingAddressFields {\n+            // Fallback to default values when no address is provided\n+            line1: Some(\"123 Test Street\".to_string()),\n+            city: Some(\"New York\".to_string()),\n+            state: Some(\"NY\".to_string()),\n+            postal_code: Some(\"10001\".to_string()),\n+            country: Some(\"US\".to_string()),\n+        },\n+    }\n+}\n+\n+impl TryFrom<&PayloadRouterData<&PaymentsAuthorizeRouterData>> for PayloadPaymentsRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PayloadRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                // Format expiry as MM/YY according to Payload specs\n+                let year_str = req_card.card_exp_year.peek();\n+                let year_two_digit = if year_str.len() >= 2 {\n+                    year_str\n+                        .chars()\n+                        .rev()\n+                        .take(2)\n+                        .collect::<String>()\n+                        .chars()\n+                        .rev()\n+                        .collect()\n+                } else {\n+                    year_str.to_string()\n+                };\n+                let expiry = format!(\"{}/{}\", req_card.card_exp_month.peek(), year_two_digit);\n+\n+                // Determine the correct status based on capture method\n+                // For auto-capture, we want the payment to be processed immediately\n+                // For manual capture, we want it to be authorized only\n+                let status = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) => \"processed\".to_string(),\n+                    Some(common_enums::CaptureMethod::Manual)\n+                    | Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic)\n+                    | None => \"authorized\".to_string(),\n+                };\n+\n+                // Extract billing address from router data\n+                let billing_address =\n+                    extract_billing_address_for_payload(item.router_data.get_optional_billing());\n+\n+                Ok(Self {\n+                    amount: item.amount.clone(),\n+                    r#type: \"payment\".to_string(),\n+                    status,\n+                    payment_method_type: \"card\".to_string(),\n+                    payment_method_card_number: Some(req_card.card_number.peek().to_string()),\n+                    payment_method_card_expiry: Some(expiry),\n+                    payment_method_card_code: Some(req_card.card_cvc.peek().to_string()),\n+                    payment_method_id: None,\n+                    // Use extracted billing address or fallback to defaults\n+                    billing_address_line1: billing_address.line1,\n+                    billing_address_city: billing_address.city,\n+                    billing_address_state: billing_address.state,\n+                    billing_address_postal_code: billing_address.postal_code,\n+                    billing_address_country: billing_address.country,\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        }\n+    }\n+}\n+\n+// Capture request transformer\n+impl TryFrom<&PayloadRouterData<&PaymentsCaptureRouterData>> for PayloadCaptureRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        _item: &PayloadRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"processed\".to_string(),",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2179738646",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8500,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/payload/transformers.rs",
        "discussion_id": "2179738646",
        "commented_code": "@@ -0,0 +1,643 @@\n+use common_enums::enums;\n+use common_utils::types::StringMinorUnit;\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, RouterData},\n+    router_flow_types::{\n+        payments::PaymentMethodToken,\n+        refunds::{Execute, RSync},\n+    },\n+    router_request_types::{PaymentMethodTokenizationData, ResponseId},\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{PeekInterface, Secret};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::RouterData as _,\n+};\n+\n+// Webhook structures for Payload API\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookBody {\n+    pub id: String,\n+    pub event: String,\n+    pub data: PayloadWebhookData,\n+    pub created_at: String,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookData {\n+    pub transaction: Option<PayloadPaymentsResponse>,\n+    pub refund: Option<RefundResponse>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookSignature {\n+    pub timestamp: String,\n+    pub signature: String,\n+}\n+\n+// Struct to represent billing address fields for Payload API\n+#[derive(Debug)]\n+struct BillingAddressFields {\n+    line1: Option<String>,\n+    city: Option<String>,\n+    state: Option<String>,\n+    postal_code: Option<String>,\n+    country: Option<String>,\n+}\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PayloadRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PayloadRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Request structures for Payload API (form-urlencoded) - Flattened with bracket notation for nested fields\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub struct PayloadPaymentsRequest {\n+    amount: StringMinorUnit,\n+    #[serde(rename = \"type\")]\n+    r#type: String,\n+    status: String,\n+    #[serde(rename = \"payment_method[type]\")]\n+    payment_method_type: String,\n+    #[serde(\n+        rename = \"payment_method[card][card_number]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_number: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][expiry]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_expiry: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][card_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_code: Option<String>,\n+    #[serde(rename = \"payment_method[id]\", skip_serializing_if = \"Option::is_none\")]\n+    payment_method_id: Option<String>, // For tokenized payments\n+    // Billing address fields for AVS validation\n+    #[serde(\n+        rename = \"payment_method[billing_address][street_address]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_line1: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][city]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_city: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][state_province]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_state: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][postal_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_postal_code: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][country_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_country: Option<String>,\n+}\n+\n+// Capture request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCaptureRequest {\n+    status: String,\n+}\n+\n+// Cancel/Void request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCancelRequest {\n+    status: String,\n+}\n+\n+// Helper function to extract billing address from router data\n+fn extract_billing_address_for_payload(\n+    address_details: Option<&hyperswitch_domain_models::address::Address>,\n+) -> BillingAddressFields {\n+    match address_details.and_then(|addr| addr.address.as_ref()) {\n+        Some(address) => BillingAddressFields {\n+            // Extract actual address fields, converting Secret<String> to String\n+            line1: address.line1.as_ref().map(|line1| line1.peek().to_string()),\n+            city: address.city.clone(),\n+            state: address.state.as_ref().map(|state| state.peek().to_string()),\n+            postal_code: address.zip.as_ref().map(|zip| zip.peek().to_string()),\n+            country: address.country.map(|country| country.to_string()),\n+        },\n+        None => BillingAddressFields {\n+            // Fallback to default values when no address is provided\n+            line1: Some(\"123 Test Street\".to_string()),\n+            city: Some(\"New York\".to_string()),\n+            state: Some(\"NY\".to_string()),\n+            postal_code: Some(\"10001\".to_string()),\n+            country: Some(\"US\".to_string()),\n+        },\n+    }\n+}\n+\n+impl TryFrom<&PayloadRouterData<&PaymentsAuthorizeRouterData>> for PayloadPaymentsRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PayloadRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                // Format expiry as MM/YY according to Payload specs\n+                let year_str = req_card.card_exp_year.peek();\n+                let year_two_digit = if year_str.len() >= 2 {\n+                    year_str\n+                        .chars()\n+                        .rev()\n+                        .take(2)\n+                        .collect::<String>()\n+                        .chars()\n+                        .rev()\n+                        .collect()\n+                } else {\n+                    year_str.to_string()\n+                };\n+                let expiry = format!(\"{}/{}\", req_card.card_exp_month.peek(), year_two_digit);\n+\n+                // Determine the correct status based on capture method\n+                // For auto-capture, we want the payment to be processed immediately\n+                // For manual capture, we want it to be authorized only\n+                let status = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) => \"processed\".to_string(),\n+                    Some(common_enums::CaptureMethod::Manual)\n+                    | Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic)\n+                    | None => \"authorized\".to_string(),\n+                };\n+\n+                // Extract billing address from router data\n+                let billing_address =\n+                    extract_billing_address_for_payload(item.router_data.get_optional_billing());\n+\n+                Ok(Self {\n+                    amount: item.amount.clone(),\n+                    r#type: \"payment\".to_string(),\n+                    status,\n+                    payment_method_type: \"card\".to_string(),\n+                    payment_method_card_number: Some(req_card.card_number.peek().to_string()),\n+                    payment_method_card_expiry: Some(expiry),\n+                    payment_method_card_code: Some(req_card.card_cvc.peek().to_string()),\n+                    payment_method_id: None,\n+                    // Use extracted billing address or fallback to defaults\n+                    billing_address_line1: billing_address.line1,\n+                    billing_address_city: billing_address.city,\n+                    billing_address_state: billing_address.state,\n+                    billing_address_postal_code: billing_address.postal_code,\n+                    billing_address_country: billing_address.country,\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        }\n+    }\n+}\n+\n+// Capture request transformer\n+impl TryFrom<&PayloadRouterData<&PaymentsCaptureRouterData>> for PayloadCaptureRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        _item: &PayloadRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"processed\".to_string(),",
        "comment_created_at": "2025-07-02T10:47:23+00:00",
        "comment_author": "pixincreate",
        "comment_body": "status mapping is wrong. should be using an enum instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179738847",
    "pr_number": 8500,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/payload/transformers.rs",
    "created_at": "2025-07-02T10:47:30+00:00",
    "commented_code": "+use common_enums::enums;\n+use common_utils::types::StringMinorUnit;\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, RouterData},\n+    router_flow_types::{\n+        payments::PaymentMethodToken,\n+        refunds::{Execute, RSync},\n+    },\n+    router_request_types::{PaymentMethodTokenizationData, ResponseId},\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{PeekInterface, Secret};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::RouterData as _,\n+};\n+\n+// Webhook structures for Payload API\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookBody {\n+    pub id: String,\n+    pub event: String,\n+    pub data: PayloadWebhookData,\n+    pub created_at: String,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookData {\n+    pub transaction: Option<PayloadPaymentsResponse>,\n+    pub refund: Option<RefundResponse>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookSignature {\n+    pub timestamp: String,\n+    pub signature: String,\n+}\n+\n+// Struct to represent billing address fields for Payload API\n+#[derive(Debug)]\n+struct BillingAddressFields {\n+    line1: Option<String>,\n+    city: Option<String>,\n+    state: Option<String>,\n+    postal_code: Option<String>,\n+    country: Option<String>,\n+}\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PayloadRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PayloadRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Request structures for Payload API (form-urlencoded) - Flattened with bracket notation for nested fields\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub struct PayloadPaymentsRequest {\n+    amount: StringMinorUnit,\n+    #[serde(rename = \"type\")]\n+    r#type: String,\n+    status: String,\n+    #[serde(rename = \"payment_method[type]\")]\n+    payment_method_type: String,\n+    #[serde(\n+        rename = \"payment_method[card][card_number]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_number: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][expiry]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_expiry: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][card_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_code: Option<String>,\n+    #[serde(rename = \"payment_method[id]\", skip_serializing_if = \"Option::is_none\")]\n+    payment_method_id: Option<String>, // For tokenized payments\n+    // Billing address fields for AVS validation\n+    #[serde(\n+        rename = \"payment_method[billing_address][street_address]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_line1: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][city]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_city: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][state_province]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_state: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][postal_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_postal_code: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][country_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_country: Option<String>,\n+}\n+\n+// Capture request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCaptureRequest {\n+    status: String,\n+}\n+\n+// Cancel/Void request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCancelRequest {\n+    status: String,\n+}\n+\n+// Helper function to extract billing address from router data\n+fn extract_billing_address_for_payload(\n+    address_details: Option<&hyperswitch_domain_models::address::Address>,\n+) -> BillingAddressFields {\n+    match address_details.and_then(|addr| addr.address.as_ref()) {\n+        Some(address) => BillingAddressFields {\n+            // Extract actual address fields, converting Secret<String> to String\n+            line1: address.line1.as_ref().map(|line1| line1.peek().to_string()),\n+            city: address.city.clone(),\n+            state: address.state.as_ref().map(|state| state.peek().to_string()),\n+            postal_code: address.zip.as_ref().map(|zip| zip.peek().to_string()),\n+            country: address.country.map(|country| country.to_string()),\n+        },\n+        None => BillingAddressFields {\n+            // Fallback to default values when no address is provided\n+            line1: Some(\"123 Test Street\".to_string()),\n+            city: Some(\"New York\".to_string()),\n+            state: Some(\"NY\".to_string()),\n+            postal_code: Some(\"10001\".to_string()),\n+            country: Some(\"US\".to_string()),\n+        },\n+    }\n+}\n+\n+impl TryFrom<&PayloadRouterData<&PaymentsAuthorizeRouterData>> for PayloadPaymentsRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PayloadRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                // Format expiry as MM/YY according to Payload specs\n+                let year_str = req_card.card_exp_year.peek();\n+                let year_two_digit = if year_str.len() >= 2 {\n+                    year_str\n+                        .chars()\n+                        .rev()\n+                        .take(2)\n+                        .collect::<String>()\n+                        .chars()\n+                        .rev()\n+                        .collect()\n+                } else {\n+                    year_str.to_string()\n+                };\n+                let expiry = format!(\"{}/{}\", req_card.card_exp_month.peek(), year_two_digit);\n+\n+                // Determine the correct status based on capture method\n+                // For auto-capture, we want the payment to be processed immediately\n+                // For manual capture, we want it to be authorized only\n+                let status = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) => \"processed\".to_string(),\n+                    Some(common_enums::CaptureMethod::Manual)\n+                    | Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic)\n+                    | None => \"authorized\".to_string(),\n+                };\n+\n+                // Extract billing address from router data\n+                let billing_address =\n+                    extract_billing_address_for_payload(item.router_data.get_optional_billing());\n+\n+                Ok(Self {\n+                    amount: item.amount.clone(),\n+                    r#type: \"payment\".to_string(),\n+                    status,\n+                    payment_method_type: \"card\".to_string(),\n+                    payment_method_card_number: Some(req_card.card_number.peek().to_string()),\n+                    payment_method_card_expiry: Some(expiry),\n+                    payment_method_card_code: Some(req_card.card_cvc.peek().to_string()),\n+                    payment_method_id: None,\n+                    // Use extracted billing address or fallback to defaults\n+                    billing_address_line1: billing_address.line1,\n+                    billing_address_city: billing_address.city,\n+                    billing_address_state: billing_address.state,\n+                    billing_address_postal_code: billing_address.postal_code,\n+                    billing_address_country: billing_address.country,\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        }\n+    }\n+}\n+\n+// Capture request transformer\n+impl TryFrom<&PayloadRouterData<&PaymentsCaptureRouterData>> for PayloadCaptureRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        _item: &PayloadRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"processed\".to_string(),\n+        })\n+    }\n+}\n+\n+// Cancel request transformer (for Void operations)\n+impl<T> TryFrom<&PayloadRouterData<T>> for PayloadCancelRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(_item: &PayloadRouterData<T>) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"voided\".to_string(),",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2179738847",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8500,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/payload/transformers.rs",
        "discussion_id": "2179738847",
        "commented_code": "@@ -0,0 +1,643 @@\n+use common_enums::enums;\n+use common_utils::types::StringMinorUnit;\n+use hyperswitch_domain_models::{\n+    payment_method_data::PaymentMethodData,\n+    router_data::{ConnectorAuthType, RouterData},\n+    router_flow_types::{\n+        payments::PaymentMethodToken,\n+        refunds::{Execute, RSync},\n+    },\n+    router_request_types::{PaymentMethodTokenizationData, ResponseId},\n+    router_response_types::{PaymentsResponseData, RefundsResponseData},\n+    types::{PaymentsAuthorizeRouterData, PaymentsCaptureRouterData, RefundsRouterData},\n+};\n+use hyperswitch_interfaces::errors;\n+use masking::{PeekInterface, Secret};\n+use serde::{Deserialize, Serialize};\n+\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::RouterData as _,\n+};\n+\n+// Webhook structures for Payload API\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookBody {\n+    pub id: String,\n+    pub event: String,\n+    pub data: PayloadWebhookData,\n+    pub created_at: String,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookData {\n+    pub transaction: Option<PayloadPaymentsResponse>,\n+    pub refund: Option<RefundResponse>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize)]\n+pub struct PayloadWebhookSignature {\n+    pub timestamp: String,\n+    pub signature: String,\n+}\n+\n+// Struct to represent billing address fields for Payload API\n+#[derive(Debug)]\n+struct BillingAddressFields {\n+    line1: Option<String>,\n+    city: Option<String>,\n+    state: Option<String>,\n+    postal_code: Option<String>,\n+    country: Option<String>,\n+}\n+\n+//TODO: Fill the struct with respective fields\n+pub struct PayloadRouterData<T> {\n+    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub router_data: T,\n+}\n+\n+impl<T> From<(StringMinorUnit, T)> for PayloadRouterData<T> {\n+    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n+        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+        Self {\n+            amount,\n+            router_data: item,\n+        }\n+    }\n+}\n+\n+// Request structures for Payload API (form-urlencoded) - Flattened with bracket notation for nested fields\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub struct PayloadPaymentsRequest {\n+    amount: StringMinorUnit,\n+    #[serde(rename = \"type\")]\n+    r#type: String,\n+    status: String,\n+    #[serde(rename = \"payment_method[type]\")]\n+    payment_method_type: String,\n+    #[serde(\n+        rename = \"payment_method[card][card_number]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_number: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][expiry]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_expiry: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[card][card_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    payment_method_card_code: Option<String>,\n+    #[serde(rename = \"payment_method[id]\", skip_serializing_if = \"Option::is_none\")]\n+    payment_method_id: Option<String>, // For tokenized payments\n+    // Billing address fields for AVS validation\n+    #[serde(\n+        rename = \"payment_method[billing_address][street_address]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_line1: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][city]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_city: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][state_province]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_state: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][postal_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_postal_code: Option<String>,\n+    #[serde(\n+        rename = \"payment_method[billing_address][country_code]\",\n+        skip_serializing_if = \"Option::is_none\"\n+    )]\n+    billing_address_country: Option<String>,\n+}\n+\n+// Capture request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCaptureRequest {\n+    status: String,\n+}\n+\n+// Cancel/Void request structure\n+#[derive(Debug, Serialize)]\n+pub struct PayloadCancelRequest {\n+    status: String,\n+}\n+\n+// Helper function to extract billing address from router data\n+fn extract_billing_address_for_payload(\n+    address_details: Option<&hyperswitch_domain_models::address::Address>,\n+) -> BillingAddressFields {\n+    match address_details.and_then(|addr| addr.address.as_ref()) {\n+        Some(address) => BillingAddressFields {\n+            // Extract actual address fields, converting Secret<String> to String\n+            line1: address.line1.as_ref().map(|line1| line1.peek().to_string()),\n+            city: address.city.clone(),\n+            state: address.state.as_ref().map(|state| state.peek().to_string()),\n+            postal_code: address.zip.as_ref().map(|zip| zip.peek().to_string()),\n+            country: address.country.map(|country| country.to_string()),\n+        },\n+        None => BillingAddressFields {\n+            // Fallback to default values when no address is provided\n+            line1: Some(\"123 Test Street\".to_string()),\n+            city: Some(\"New York\".to_string()),\n+            state: Some(\"NY\".to_string()),\n+            postal_code: Some(\"10001\".to_string()),\n+            country: Some(\"US\".to_string()),\n+        },\n+    }\n+}\n+\n+impl TryFrom<&PayloadRouterData<&PaymentsAuthorizeRouterData>> for PayloadPaymentsRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        item: &PayloadRouterData<&PaymentsAuthorizeRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        match item.router_data.request.payment_method_data.clone() {\n+            PaymentMethodData::Card(req_card) => {\n+                // Format expiry as MM/YY according to Payload specs\n+                let year_str = req_card.card_exp_year.peek();\n+                let year_two_digit = if year_str.len() >= 2 {\n+                    year_str\n+                        .chars()\n+                        .rev()\n+                        .take(2)\n+                        .collect::<String>()\n+                        .chars()\n+                        .rev()\n+                        .collect()\n+                } else {\n+                    year_str.to_string()\n+                };\n+                let expiry = format!(\"{}/{}\", req_card.card_exp_month.peek(), year_two_digit);\n+\n+                // Determine the correct status based on capture method\n+                // For auto-capture, we want the payment to be processed immediately\n+                // For manual capture, we want it to be authorized only\n+                let status = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) => \"processed\".to_string(),\n+                    Some(common_enums::CaptureMethod::Manual)\n+                    | Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic)\n+                    | None => \"authorized\".to_string(),\n+                };\n+\n+                // Extract billing address from router data\n+                let billing_address =\n+                    extract_billing_address_for_payload(item.router_data.get_optional_billing());\n+\n+                Ok(Self {\n+                    amount: item.amount.clone(),\n+                    r#type: \"payment\".to_string(),\n+                    status,\n+                    payment_method_type: \"card\".to_string(),\n+                    payment_method_card_number: Some(req_card.card_number.peek().to_string()),\n+                    payment_method_card_expiry: Some(expiry),\n+                    payment_method_card_code: Some(req_card.card_cvc.peek().to_string()),\n+                    payment_method_id: None,\n+                    // Use extracted billing address or fallback to defaults\n+                    billing_address_line1: billing_address.line1,\n+                    billing_address_city: billing_address.city,\n+                    billing_address_state: billing_address.state,\n+                    billing_address_postal_code: billing_address.postal_code,\n+                    billing_address_country: billing_address.country,\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        }\n+    }\n+}\n+\n+// Capture request transformer\n+impl TryFrom<&PayloadRouterData<&PaymentsCaptureRouterData>> for PayloadCaptureRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(\n+        _item: &PayloadRouterData<&PaymentsCaptureRouterData>,\n+    ) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"processed\".to_string(),\n+        })\n+    }\n+}\n+\n+// Cancel request transformer (for Void operations)\n+impl<T> TryFrom<&PayloadRouterData<T>> for PayloadCancelRequest {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn try_from(_item: &PayloadRouterData<T>) -> Result<Self, Self::Error> {\n+        Ok(Self {\n+            status: \"voided\".to_string(),",
        "comment_created_at": "2025-07-02T10:47:30+00:00",
        "comment_author": "pixincreate",
        "comment_body": "status mapping is wrong. should be using an enum instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328436778",
    "pr_number": 9289,
    "pr_file": "crates/external_services/src/superposition/mod.rs",
    "created_at": "2025-09-07T01:46:25+00:00",
    "commented_code": null,
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2328436778",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9289,
        "pr_file": "crates/external_services/src/superposition/mod.rs",
        "discussion_id": "2328436778",
        "commented_code": null,
        "comment_created_at": "2025-09-07T01:46:25+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Avoid the `mod.rs` naming convention, clippy should have also caught this.\r\n\r\nRename this file to `crates/external_services/src/superposition.rs`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328437714",
    "pr_number": 9289,
    "pr_file": "crates/external_services/src/superposition/service.rs",
    "created_at": "2025-09-07T01:49:19+00:00",
    "commented_code": "+use std::sync::Arc;\n+\n+use common_utils::errors::CustomResult;\n+use error_stack::ResultExt;\n+\n+use super::{\n+    interface::{ConfigContext, SuperpositionError, SuperpositionInterface},\n+    superposition::{SuperpositionClient, SuperpositionClientConfig},\n+};\n+\n+/// Configuration for the superposition service\n+pub type SuperpositionConfig = SuperpositionClientConfig;\n+\n+/// Main superposition service implementation  \n+#[derive(Debug)]\n+pub struct SuperpositionService {\n+    superposition_client: Option<Arc<SuperpositionClient>>,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2328437714",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9289,
        "pr_file": "crates/external_services/src/superposition/service.rs",
        "discussion_id": "2328437714",
        "commented_code": "@@ -0,0 +1,96 @@\n+use std::sync::Arc;\n+\n+use common_utils::errors::CustomResult;\n+use error_stack::ResultExt;\n+\n+use super::{\n+    interface::{ConfigContext, SuperpositionError, SuperpositionInterface},\n+    superposition::{SuperpositionClient, SuperpositionClientConfig},\n+};\n+\n+/// Configuration for the superposition service\n+pub type SuperpositionConfig = SuperpositionClientConfig;\n+\n+/// Main superposition service implementation  \n+#[derive(Debug)]\n+pub struct SuperpositionService {\n+    superposition_client: Option<Arc<SuperpositionClient>>,",
        "comment_created_at": "2025-09-07T01:49:19+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Nit: We can call this just `client`, since the struct name already indicates that this is about superposition.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328444025",
    "pr_number": 9289,
    "pr_file": "crates/external_services/src/superposition/superposition.rs",
    "created_at": "2025-09-07T02:16:17+00:00",
    "commented_code": null,
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2328444025",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9289,
        "pr_file": "crates/external_services/src/superposition/superposition.rs",
        "discussion_id": "2328444025",
        "commented_code": null,
        "comment_created_at": "2025-09-07T02:16:17+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Also, what's with this module inception? Why is both the folder named `superposition` and the file also named the same? \r\n\r\nCan't we move all this logic to `crates/external_services/src/superposition/mod.rs`, which would then be renamed as `crates/external_services/src/superposition.rs`?",
        "pr_file_module": null
      }
    ]
  }
]