[
  {
    "discussion_id": "2336509547",
    "pr_number": 9122,
    "pr_file": "crates/router/src/core/payments/operations/payment_confirm_intent.rs",
    "created_at": "2025-09-10T11:54:52+00:00",
    "commented_code": "})\n             .attach_printable(\"payment_method_data should be card_token when a token is passed\")?,\n \n-            (None, Some(domain::PaymentMethodData::Card(card)), Some(_customer_acceptance)) => {\n-                let customer_id = match &payment_data.payment_intent.customer_id {\n-                    Some(customer_id) => customer_id.clone(),\n-                    None => {\n-                        return Err(errors::ApiErrorResponse::InvalidDataValue {\n-                            field_name: \"customer_id\",\n-                        })\n-                        .attach_printable(\"customer_id not provided\");\n-                    }\n+            (None, Some(pm_data @ domain::PaymentMethodData::Card(card)), customer_acceptance) => {\n+                let payment_method_pm_data = if let Some(_customer_acceptance) = customer_acceptance",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2336509547",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9122,
        "pr_file": "crates/router/src/core/payments/operations/payment_confirm_intent.rs",
        "discussion_id": "2336509547",
        "commented_code": "@@ -471,43 +471,63 @@ impl<F: Clone + Send + Sync> Domain<F, PaymentsConfirmIntentRequest, PaymentConf\n             })\n             .attach_printable(\"payment_method_data should be card_token when a token is passed\")?,\n \n-            (None, Some(domain::PaymentMethodData::Card(card)), Some(_customer_acceptance)) => {\n-                let customer_id = match &payment_data.payment_intent.customer_id {\n-                    Some(customer_id) => customer_id.clone(),\n-                    None => {\n-                        return Err(errors::ApiErrorResponse::InvalidDataValue {\n-                            field_name: \"customer_id\",\n-                        })\n-                        .attach_printable(\"customer_id not provided\");\n-                    }\n+            (None, Some(pm_data @ domain::PaymentMethodData::Card(card)), customer_acceptance) => {\n+                let payment_method_pm_data = if let Some(_customer_acceptance) = customer_acceptance",
        "comment_created_at": "2025-09-10T11:54:52+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "nit: if the inner value is not being used, do `is_some()` check",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2338645640",
    "pr_number": 9294,
    "pr_file": "crates/router/src/core/revenue_recovery.rs",
    "created_at": "2025-09-11T05:35:17+00:00",
    "commented_code": "}\n     };\n \n+    // External Payments which enter the calculate workflow for the first time will have active attempt id as None\n+    // Then we dont need to send an webhook to the merchant as its not a failure from our side.\n+    // Thus we dont need to a payment get call for such payments.\n+    let is_there_an_active_payment_attempt_id = payment_intent.active_attempt_id.is_some();",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2338645640",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9294,
        "pr_file": "crates/router/src/core/revenue_recovery.rs",
        "discussion_id": "2338645640",
        "commented_code": "@@ -488,6 +519,20 @@ pub async fn perform_calculate_workflow(\n         }\n     };\n \n+    // External Payments which enter the calculate workflow for the first time will have active attempt id as None\n+    // Then we dont need to send an webhook to the merchant as its not a failure from our side.\n+    // Thus we dont need to a payment get call for such payments.\n+    let is_there_an_active_payment_attempt_id = payment_intent.active_attempt_id.is_some();",
        "comment_created_at": "2025-09-11T05:35:17+00:00",
        "comment_author": "Aprabhat19",
        "comment_body": "Do not handle ` is there an active attempt id ` like this, do a map and handle the None case if required",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2332299494",
    "pr_number": 9282,
    "pr_file": "crates/router/src/workflows/payment_sync.rs",
    "created_at": "2025-09-09T07:29:26+00:00",
    "commented_code": "}\n }\n \n+/// Schedule the task for retry and update redis token expiry time\n+///\n+/// Returns bool which indicates whether this was the last retry or not\n+#[cfg(feature = \"v2\")]\n+pub async fn recovery_retry_sync_task(\n+    state: &SessionState,\n+    connector_customer_id: Option<String>,\n+    connector: String,\n+    merchant_id: common_utils::id_type::MerchantId,\n+    pt: storage::ProcessTracker,\n+) -> Result<bool, sch_errors::ProcessTrackerError> {\n+    let db = &*state.store;\n+    let schedule_time =\n+        get_sync_process_schedule_time(db, &connector, &merchant_id, pt.retry_count + 1).await?;\n+    match schedule_time {\n+        Some(s_time) => {\n+            db.as_scheduler().retry_process(pt, s_time).await?;\n+            match connector_customer_id {\n+                Some(connector_customer_id) => {\n+                    match update_token_expiry_based_on_schedule_time(\n+                        state,\n+                        &connector_customer_id,\n+                        Some(s_time),\n+                    )\n+                    .await\n+                    {\n+                        Ok(_) => {}\n+                        Err(e) => {\n+                            logger::error!(\n+                                error = ?e,\n+                                connector_customer_id = %connector_customer_id,\n+                                \"Failed to update the token expiry time in redis\"\n+                            );\n+                        }\n+                    };\n+                }\n+                None => logger::warn!(\n+                    \"No connector customer id found in payment intent feature metadata\"\n+                ),\n+            }\n+            Ok(false)\n+        }\n+        None => {\n+            db.as_scheduler()\n+                .finish_process_with_business_status(pt, business_status::RETRIES_EXCEEDED)\n+                .await?;\n+            Ok(true)\n+        }\n+    }",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2332299494",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9282,
        "pr_file": "crates/router/src/workflows/payment_sync.rs",
        "discussion_id": "2332299494",
        "commented_code": "@@ -303,6 +305,56 @@ pub async fn retry_sync_task(\n     }\n }\n \n+/// Schedule the task for retry and update redis token expiry time\n+///\n+/// Returns bool which indicates whether this was the last retry or not\n+#[cfg(feature = \"v2\")]\n+pub async fn recovery_retry_sync_task(\n+    state: &SessionState,\n+    connector_customer_id: Option<String>,\n+    connector: String,\n+    merchant_id: common_utils::id_type::MerchantId,\n+    pt: storage::ProcessTracker,\n+) -> Result<bool, sch_errors::ProcessTrackerError> {\n+    let db = &*state.store;\n+    let schedule_time =\n+        get_sync_process_schedule_time(db, &connector, &merchant_id, pt.retry_count + 1).await?;\n+    match schedule_time {\n+        Some(s_time) => {\n+            db.as_scheduler().retry_process(pt, s_time).await?;\n+            match connector_customer_id {\n+                Some(connector_customer_id) => {\n+                    match update_token_expiry_based_on_schedule_time(\n+                        state,\n+                        &connector_customer_id,\n+                        Some(s_time),\n+                    )\n+                    .await\n+                    {\n+                        Ok(_) => {}\n+                        Err(e) => {\n+                            logger::error!(\n+                                error = ?e,\n+                                connector_customer_id = %connector_customer_id,\n+                                \"Failed to update the token expiry time in redis\"\n+                            );\n+                        }\n+                    };\n+                }\n+                None => logger::warn!(\n+                    \"No connector customer id found in payment intent feature metadata\"\n+                ),\n+            }\n+            Ok(false)\n+        }\n+        None => {\n+            db.as_scheduler()\n+                .finish_process_with_business_status(pt, business_status::RETRIES_EXCEEDED)\n+                .await?;\n+            Ok(true)\n+        }\n+    }",
        "comment_created_at": "2025-09-09T07:29:26+00:00",
        "comment_author": "hrithikesh026",
        "comment_body": "This can be written in a better way using Option apis. like `.map`, `.and_then` etc.\r\nToo much indentation affects readability.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013709319",
    "pr_number": 7062,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/amazonpay/transformers.rs",
    "created_at": "2025-03-26T09:27:15+00:00",
    "commented_code": "-use common_enums::enums;\n-use common_utils::types::StringMinorUnit;\n+use std::collections::HashMap;\n+\n+use common_enums::{enums, CaptureMethod};\n+use common_utils::{errors::CustomResult, types::StringMajorUnit};\n use hyperswitch_domain_models::{\n-    payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n     types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{PeekInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::{\n-    types::{RefundsResponseRouterData, ResponseRouterData},\n-    utils::PaymentsAuthorizeRequestData,\n-};\n+use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n \n-//TODO: Fill the struct with respective fields\n pub struct AmazonpayRouterData<T> {\n-    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub amount: StringMajorUnit,\n     pub router_data: T,\n }\n \n-impl<T> From<(StringMinorUnit, T)> for AmazonpayRouterData<T> {\n-    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n-        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+impl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n+    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n         Self {\n             amount,\n             router_data: item,\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n #[derive(Default, Debug, Serialize, PartialEq)]\n-pub struct AmazonpayPaymentsRequest {\n-    amount: StringMinorUnit,\n-    card: AmazonpayCard,\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AmazonpayFinalizeRequest {\n+    charge_amount: ChargeAmount,\n+    total_order_amount: Option<TotalOrderAmount>,\n+    shipping_address: AddressDetails,\n+    payment_intent: PaymentIntent,\n }\n \n-#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n-pub struct AmazonpayCard {\n-    number: cards::CardNumber,\n-    expiry_month: Secret<String>,\n-    expiry_year: Secret<String>,\n-    cvc: Secret<String>,\n-    complete: bool,\n+#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ChargeAmount {\n+    amount: StringMajorUnit,\n+    currency_code: common_enums::Currency,\n }\n \n-impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayPaymentsRequest {\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct TotalOrderAmount {\n+    amount: Option<StringMajorUnit>,\n+    currency_code: Option<common_enums::Currency>,\n+    can_handle_pending_authorization: Option<bool>,\n+    supplementary_data: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Deserialize, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AddressDetails {\n+    name: Option<String>,\n+    address_line_1: Option<String>,\n+    address_line_2: Option<String>,\n+    address_line_3: Option<String>,\n+    city: Option<String>,\n+    state_or_region: Option<String>,\n+    postal_code: Option<String>,\n+    country_code: Option<common_enums::CountryAlpha2>,\n+    phone_number: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub enum PaymentIntent {\n+    #[default]\n+    AuthorizeWithCapture,\n+}\n+\n+fn get_amazonpay_capture_type(\n+    item: Option<CaptureMethod>,\n+) -> CustomResult<Option<PaymentIntent>, errors::ConnectorError> {\n+    match item {\n+        Some(CaptureMethod::Automatic) => Ok(Some(PaymentIntent::AuthorizeWithCapture)),\n+        Some(_) => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n+        None => Err(errors::ConnectorError::MissingRequiredField {\n+            field_name: \"capture_method\",\n+        }\n+        .into()),\n+    }\n+}\n+\n+impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayFinalizeRequest {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(\n         item: &AmazonpayRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n-        match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(req_card) => {\n-                let card = AmazonpayCard {\n-                    number: req_card.card_number,\n-                    expiry_month: req_card.card_exp_month,\n-                    expiry_year: req_card.card_exp_year,\n-                    cvc: req_card.card_cvc,\n-                    complete: item.router_data.request.is_auto_capture()?,\n-                };\n-                Ok(Self {\n-                    amount: item.amount.clone(),\n-                    card,\n-                })\n+        let charge_amount = ChargeAmount {\n+            amount: item.amount.clone(),\n+            currency_code: common_enums::Currency::USD,\n+        };\n+        let shipping_address_details = item.router_data.address.get_shipping();\n+        let shipping_address = if let Some(shipping) = shipping_address_details {\n+            if let Some(address_details) = shipping.address.as_ref() {\n+                AddressDetails {\n+                    name: address_details\n+                        .get_optional_full_name()\n+                        .map(|secret_name| secret_name.peek().to_string()),\n+                    address_line_1: address_details\n+                        .line1\n+                        .clone()\n+                        .map(|l1| l1.peek().to_string()),\n+                    address_line_2: address_details\n+                        .line2\n+                        .clone()\n+                        .map(|l2| l2.peek().to_string()),\n+                    address_line_3: address_details\n+                        .line3\n+                        .clone()\n+                        .map(|l3| l3.peek().to_string()),\n+                    city: address_details.city.clone(),\n+                    state_or_region: address_details\n+                        .state\n+                        .clone()\n+                        .map(|state| state.peek().to_string()),\n+                    postal_code: address_details\n+                        .zip\n+                        .clone()\n+                        .map(|zip| zip.peek().to_string()),\n+                    country_code: address_details.country,\n+                    phone_number: shipping\n+                        .phone\n+                        .as_ref()\n+                        .and_then(|phone| phone.number.as_ref())\n+                        .map(|phone_number| phone_number.peek().to_string()),\n+                }\n+            } else {\n+                AddressDetails::default()\n             }\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        } else {\n+            AddressDetails::default()",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2013709319",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/amazonpay/transformers.rs",
        "discussion_id": "2013709319",
        "commented_code": "@@ -1,121 +1,457 @@\n-use common_enums::enums;\n-use common_utils::types::StringMinorUnit;\n+use std::collections::HashMap;\n+\n+use common_enums::{enums, CaptureMethod};\n+use common_utils::{errors::CustomResult, types::StringMajorUnit};\n use hyperswitch_domain_models::{\n-    payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n     types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{PeekInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::{\n-    types::{RefundsResponseRouterData, ResponseRouterData},\n-    utils::PaymentsAuthorizeRequestData,\n-};\n+use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n \n-//TODO: Fill the struct with respective fields\n pub struct AmazonpayRouterData<T> {\n-    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub amount: StringMajorUnit,\n     pub router_data: T,\n }\n \n-impl<T> From<(StringMinorUnit, T)> for AmazonpayRouterData<T> {\n-    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n-        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+impl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n+    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n         Self {\n             amount,\n             router_data: item,\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n #[derive(Default, Debug, Serialize, PartialEq)]\n-pub struct AmazonpayPaymentsRequest {\n-    amount: StringMinorUnit,\n-    card: AmazonpayCard,\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AmazonpayFinalizeRequest {\n+    charge_amount: ChargeAmount,\n+    total_order_amount: Option<TotalOrderAmount>,\n+    shipping_address: AddressDetails,\n+    payment_intent: PaymentIntent,\n }\n \n-#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n-pub struct AmazonpayCard {\n-    number: cards::CardNumber,\n-    expiry_month: Secret<String>,\n-    expiry_year: Secret<String>,\n-    cvc: Secret<String>,\n-    complete: bool,\n+#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ChargeAmount {\n+    amount: StringMajorUnit,\n+    currency_code: common_enums::Currency,\n }\n \n-impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayPaymentsRequest {\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct TotalOrderAmount {\n+    amount: Option<StringMajorUnit>,\n+    currency_code: Option<common_enums::Currency>,\n+    can_handle_pending_authorization: Option<bool>,\n+    supplementary_data: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Deserialize, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AddressDetails {\n+    name: Option<String>,\n+    address_line_1: Option<String>,\n+    address_line_2: Option<String>,\n+    address_line_3: Option<String>,\n+    city: Option<String>,\n+    state_or_region: Option<String>,\n+    postal_code: Option<String>,\n+    country_code: Option<common_enums::CountryAlpha2>,\n+    phone_number: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub enum PaymentIntent {\n+    #[default]\n+    AuthorizeWithCapture,\n+}\n+\n+fn get_amazonpay_capture_type(\n+    item: Option<CaptureMethod>,\n+) -> CustomResult<Option<PaymentIntent>, errors::ConnectorError> {\n+    match item {\n+        Some(CaptureMethod::Automatic) => Ok(Some(PaymentIntent::AuthorizeWithCapture)),\n+        Some(_) => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n+        None => Err(errors::ConnectorError::MissingRequiredField {\n+            field_name: \"capture_method\",\n+        }\n+        .into()),\n+    }\n+}\n+\n+impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayFinalizeRequest {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(\n         item: &AmazonpayRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n-        match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(req_card) => {\n-                let card = AmazonpayCard {\n-                    number: req_card.card_number,\n-                    expiry_month: req_card.card_exp_month,\n-                    expiry_year: req_card.card_exp_year,\n-                    cvc: req_card.card_cvc,\n-                    complete: item.router_data.request.is_auto_capture()?,\n-                };\n-                Ok(Self {\n-                    amount: item.amount.clone(),\n-                    card,\n-                })\n+        let charge_amount = ChargeAmount {\n+            amount: item.amount.clone(),\n+            currency_code: common_enums::Currency::USD,\n+        };\n+        let shipping_address_details = item.router_data.address.get_shipping();\n+        let shipping_address = if let Some(shipping) = shipping_address_details {\n+            if let Some(address_details) = shipping.address.as_ref() {\n+                AddressDetails {\n+                    name: address_details\n+                        .get_optional_full_name()\n+                        .map(|secret_name| secret_name.peek().to_string()),\n+                    address_line_1: address_details\n+                        .line1\n+                        .clone()\n+                        .map(|l1| l1.peek().to_string()),\n+                    address_line_2: address_details\n+                        .line2\n+                        .clone()\n+                        .map(|l2| l2.peek().to_string()),\n+                    address_line_3: address_details\n+                        .line3\n+                        .clone()\n+                        .map(|l3| l3.peek().to_string()),\n+                    city: address_details.city.clone(),\n+                    state_or_region: address_details\n+                        .state\n+                        .clone()\n+                        .map(|state| state.peek().to_string()),\n+                    postal_code: address_details\n+                        .zip\n+                        .clone()\n+                        .map(|zip| zip.peek().to_string()),\n+                    country_code: address_details.country,\n+                    phone_number: shipping\n+                        .phone\n+                        .as_ref()\n+                        .and_then(|phone| phone.number.as_ref())\n+                        .map(|phone_number| phone_number.peek().to_string()),\n+                }\n+            } else {\n+                AddressDetails::default()\n             }\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        } else {\n+            AddressDetails::default()",
        "comment_created_at": "2025-03-26T09:27:15+00:00",
        "comment_author": "AkshayaFoiger",
        "comment_body": "If address is a mandatory field throw an error here, else return None. Also it is better to use a `map`",
        "pr_file_module": null
      }
    ]
  }
]