[
  {
    "discussion_id": "2184876262",
    "pr_number": 541,
    "pr_file": "apps/web/app/api/labels/create/route.ts",
    "created_at": "2025-07-04T09:39:25+00:00",
    "commented_code": "+import { NextResponse } from \"next/server\";\n+import { withEmailAccount } from \"@/utils/middleware\";\n+import prisma from \"@/utils/prisma\";\n+import { createEmailProvider } from \"@/utils/email/provider\";\n+import { z } from \"zod\";\n+\n+const createLabelBody = z.object({\n+  name: z.string(),\n+  description: z.string().nullish(),\n+});\n+\n+export const POST = withEmailAccount(async (request) => {\n+  const emailAccountId = request.auth.emailAccountId;\n+  const body = await request.json();\n+  const { name, description } = createLabelBody.parse(body);\n+\n+  // Get the provider from the related account\n+  const emailAccount = await prisma.emailAccount.findUnique({\n+    where: { id: emailAccountId },\n+    select: {\n+      account: {\n+        select: {\n+          provider: true,\n+        },\n+      },\n+    },\n+  });",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2184876262",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 541,
        "pr_file": "apps/web/app/api/labels/create/route.ts",
        "discussion_id": "2184876262",
        "commented_code": "@@ -0,0 +1,44 @@\n+import { NextResponse } from \"next/server\";\n+import { withEmailAccount } from \"@/utils/middleware\";\n+import prisma from \"@/utils/prisma\";\n+import { createEmailProvider } from \"@/utils/email/provider\";\n+import { z } from \"zod\";\n+\n+const createLabelBody = z.object({\n+  name: z.string(),\n+  description: z.string().nullish(),\n+});\n+\n+export const POST = withEmailAccount(async (request) => {\n+  const emailAccountId = request.auth.emailAccountId;\n+  const body = await request.json();\n+  const { name, description } = createLabelBody.parse(body);\n+\n+  // Get the provider from the related account\n+  const emailAccount = await prisma.emailAccount.findUnique({\n+    where: { id: emailAccountId },\n+    select: {\n+      account: {\n+        select: {\n+          provider: true,\n+        },\n+      },\n+    },\n+  });",
        "comment_created_at": "2025-07-04T09:39:25+00:00",
        "comment_author": "elie222",
        "comment_body": "as we do this in a few places, probably good to just make this:\r\n\r\nawait getProvider() or getAccountProvider()\r\n\r\ncould even optimise it, and store the result in redis similar to what we do here:\r\n`apps/web/utils/redis/account-validation.ts`\r\n\r\nespecially as accountid<>provider will never actually change.\r\n\r\nwe could actually reuse the existing getEmailAccount and have it store an object instead: { email, provider } (instead of just the email string). but to not break production, you need to check if the cached result is an object, and if it isn't, then it's like we have nothing in the cache. and it needs to refetched. alternative is to use a new validation key",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154606360",
    "pr_number": 510,
    "pr_file": "apps/web/utils/email.ts",
    "created_at": "2025-06-18T13:25:37+00:00",
    "commented_code": "export function extractEmailAddress(email: string): string {\n   if (!email) return \"\";\n \n-  // Standard email pattern that matches common email formats\n-  // Allows:\n-  // - Letters, numbers, dots, and plus signs in local part\n-  // - Standard domain formats\n-  // - Case insensitive\n-  // - Emails anywhere within text\n-  const emailPattern = /[a-zA-Z0-9.+]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/i;\n+  // Try to extract from angle brackets first\n+  const bracketMatch = email.match(/<([^<>]+)>$/);\n+  if (bracketMatch) {\n+    const candidate = bracketMatch[1].trim();\n+    if (isValidEmail(candidate)) {\n+      return candidate;\n+    }\n+  }\n+\n+  // If no brackets or invalid email in brackets, try the whole string\n+  if (isValidEmail(email.trim())) {\n+    return email.trim();\n+  }\n \n-  // Try last bracketed content first\n-  const match = email.match(/<([^<>]+)>$/);\n-  if (match && emailPattern.test(match[1].trim())) {\n-    return match[1].trim();\n+  // As a last resort, look for any email-like pattern in the string\n+  const emailPattern = /\\b[^\\s<>]+@[^\\s<>]+\\.[^\\s<>]+\\b/g;\n+  const matches = email.match(emailPattern);\n+  if (matches) {\n+    // Try each match to find a valid email\n+    for (const match of matches) {\n+      if (isValidEmail(match)) {\n+        return match;\n+      }\n+    }\n   }\n \n-  // Fall back to finding any email in the string\n-  const rawMatch = email.match(emailPattern);\n-  return rawMatch ? rawMatch[0] : \"\";\n+  return \"\";\n+}\n+\n+// Use Zod's built-in email validation\n+function isValidEmail(email: string): boolean {\n+  return z.string().email().safeParse(email).success;\n }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2154606360",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 510,
        "pr_file": "apps/web/utils/email.ts",
        "discussion_id": "2154606360",
        "commented_code": "@@ -16,23 +17,38 @@ export function extractNameFromEmail(email: string) {\n export function extractEmailAddress(email: string): string {\n   if (!email) return \"\";\n \n-  // Standard email pattern that matches common email formats\n-  // Allows:\n-  // - Letters, numbers, dots, and plus signs in local part\n-  // - Standard domain formats\n-  // - Case insensitive\n-  // - Emails anywhere within text\n-  const emailPattern = /[a-zA-Z0-9.+]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/i;\n+  // Try to extract from angle brackets first\n+  const bracketMatch = email.match(/<([^<>]+)>$/);\n+  if (bracketMatch) {\n+    const candidate = bracketMatch[1].trim();\n+    if (isValidEmail(candidate)) {\n+      return candidate;\n+    }\n+  }\n+\n+  // If no brackets or invalid email in brackets, try the whole string\n+  if (isValidEmail(email.trim())) {\n+    return email.trim();\n+  }\n \n-  // Try last bracketed content first\n-  const match = email.match(/<([^<>]+)>$/);\n-  if (match && emailPattern.test(match[1].trim())) {\n-    return match[1].trim();\n+  // As a last resort, look for any email-like pattern in the string\n+  const emailPattern = /\\b[^\\s<>]+@[^\\s<>]+\\.[^\\s<>]+\\b/g;\n+  const matches = email.match(emailPattern);\n+  if (matches) {\n+    // Try each match to find a valid email\n+    for (const match of matches) {\n+      if (isValidEmail(match)) {\n+        return match;\n+      }\n+    }\n   }\n \n-  // Fall back to finding any email in the string\n-  const rawMatch = email.match(emailPattern);\n-  return rawMatch ? rawMatch[0] : \"\";\n+  return \"\";\n+}\n+\n+// Use Zod's built-in email validation\n+function isValidEmail(email: string): boolean {\n+  return z.string().email().safeParse(email).success;\n }",
        "comment_created_at": "2025-06-18T13:25:37+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Cache the Zod schema to avoid re-allocating on every call**\n\n`z.string().email()` allocates a new schema object each invocation, which is unnecessary and can become hot in tight loops.\n\n```diff\n-// Use Zod's built-in email validation\n-function isValidEmail(email: string): boolean {\n-  return z.string().email().safeParse(email).success;\n-}\n+const emailSchema = z.string().email();\n+\n+function isValidEmail(email: string): boolean {\n+  return emailSchema.safeParse(email).success;\n+}\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nconst emailSchema = z.string().email();\n\nfunction isValidEmail(email: string): boolean {\n  return emailSchema.safeParse(email).success;\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/email.ts around lines 49 to 52, the isValidEmail function\ncreates a new Zod schema on every call, causing unnecessary allocations. To fix\nthis, define the Zod email schema once outside the function as a constant, then\nreuse this cached schema inside isValidEmail to perform the validation. This\navoids repeated schema creation and improves performance.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140530987",
    "pr_number": 503,
    "pr_file": "apps/web/utils/llms/model.ts",
    "created_at": "2025-06-11T15:47:49+00:00",
    "commented_code": "const aiApiKey = userAi.aiApiKey;\n   let aiProvider: string;\n   let aiModel: string | null = null;\n+  const providerOptions: Record<string, any> = {};\n \n   // If user has not api key set, then use default model\n   // If they do they can use the model of their choice\n   if (aiApiKey) {\n     aiProvider = userAi.aiProvider || defaultProvider;\n-\n-    if (userAi.aiModel) {\n-      aiModel = userAi.aiModel;\n-    }\n+    aiModel = userAi.aiModel || null;\n   } else {\n     aiProvider = defaultProvider;\n+    aiModel = env.DEFAULT_LLM_MODEL || null;\n \n-    function selectRandomModel() {\n-      // TODO: remove hard coding\n-      // to avoid rate limits, we'll select a random model\n+    // Allow custom logic in production with fallbacks that doesn't impact self-hosters\n+    if (aiProvider === Provider.CUSTOM) {\n+      // choose randomly between bedrock sonnet 3.7, sonnet 4, and openrouter\n       const models = [\n-        env.DEFAULT_LLM_MODEL,\n-        // \"anthropic/claude-3.7-sonnet\",\n-        // \"anthropic/claude-sonnet-4\",\n-        \"google/gemini-2.5-pro-preview-03-25\",\n-        \"google/gemini-2.5-pro-preview-05-06\",\n+        {\n+          provider: Provider.ANTHROPIC,\n+          model: Model.CLAUDE_3_7_SONNET_BEDROCK,\n+        },\n+        {\n+          provider: Provider.ANTHROPIC,\n+          model: Model.CLAUDE_4_SONNET_BEDROCK,\n+        },\n+        {\n+          provider: Provider.OPENROUTER,\n+          model: null,\n+        },\n       ];\n-      return models[Math.floor(Math.random() * models.length)];\n-    }\n \n-    aiModel = selectRandomModel() || null;\n-  }\n+      const selectedProviderAndModel =\n+        models[Math.floor(Math.random() * models.length)];",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2140530987",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 503,
        "pr_file": "apps/web/utils/llms/model.ts",
        "discussion_id": "2140530987",
        "commented_code": "@@ -181,56 +176,78 @@ function selectDefaultModel(userAi: UserAIFields) {\n   const aiApiKey = userAi.aiApiKey;\n   let aiProvider: string;\n   let aiModel: string | null = null;\n+  const providerOptions: Record<string, any> = {};\n \n   // If user has not api key set, then use default model\n   // If they do they can use the model of their choice\n   if (aiApiKey) {\n     aiProvider = userAi.aiProvider || defaultProvider;\n-\n-    if (userAi.aiModel) {\n-      aiModel = userAi.aiModel;\n-    }\n+    aiModel = userAi.aiModel || null;\n   } else {\n     aiProvider = defaultProvider;\n+    aiModel = env.DEFAULT_LLM_MODEL || null;\n \n-    function selectRandomModel() {\n-      // TODO: remove hard coding\n-      // to avoid rate limits, we'll select a random model\n+    // Allow custom logic in production with fallbacks that doesn't impact self-hosters\n+    if (aiProvider === Provider.CUSTOM) {\n+      // choose randomly between bedrock sonnet 3.7, sonnet 4, and openrouter\n       const models = [\n-        env.DEFAULT_LLM_MODEL,\n-        // \"anthropic/claude-3.7-sonnet\",\n-        // \"anthropic/claude-sonnet-4\",\n-        \"google/gemini-2.5-pro-preview-03-25\",\n-        \"google/gemini-2.5-pro-preview-05-06\",\n+        {\n+          provider: Provider.ANTHROPIC,\n+          model: Model.CLAUDE_3_7_SONNET_BEDROCK,\n+        },\n+        {\n+          provider: Provider.ANTHROPIC,\n+          model: Model.CLAUDE_4_SONNET_BEDROCK,\n+        },\n+        {\n+          provider: Provider.OPENROUTER,\n+          model: null,\n+        },\n       ];\n-      return models[Math.floor(Math.random() * models.length)];\n-    }\n \n-    aiModel = selectRandomModel() || null;\n-  }\n+      const selectedProviderAndModel =\n+        models[Math.floor(Math.random() * models.length)];\n ",
        "comment_created_at": "2025-06-11T15:47:49+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Random-selection logic is recreating identical arrays every call**\n\n`models` and `selectRandomModel()` are re-declared on every invocation.  \nHoisting them to module scope (or at least outside the hot path) will:\n\n1. Reduce per-call allocations.\n2. Make it simpler to audit / unit-test the fallback matrix.\n\n```diff\n-      const models = [\n+      // defined once at module level\n+      const CUSTOM_FALLBACKS = [\n         { provider: Provider.ANTHROPIC, model: Model.CLAUDE_3_7_SONNET_BEDROCK },\n         { provider: Provider.ANTHROPIC, model: Model.CLAUDE_4_SONNET_BEDROCK },\n         { provider: Provider.OPENROUTER, model: null },\n       ];\n-      const selectedProviderAndModel =\n-        models[Math.floor(Math.random() * models.length)];\n+      const selectedProviderAndModel =\n+        CUSTOM_FALLBACKS[Math.floor(Math.random() * CUSTOM_FALLBACKS.length)];\n```\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/llms/model.ts around lines 190 to 210, the array 'models' and\nthe random selection logic are recreated on every function call, causing\nunnecessary allocations. Move the 'models' array declaration and the random\nselection function outside the function or hot path to module scope so they are\ninitialized once. This reduces per-call overhead and makes the fallback options\neasier to audit and unit test.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2079898170",
    "pr_number": 425,
    "pr_file": "apps/web/app/(app)/premium/config.ts",
    "created_at": "2025-05-08T14:58:59+00:00",
    "commented_code": "[env.NEXT_PUBLIC_BUSINESS_MONTHLY_VARIANT_ID]: PremiumTier.BUSINESS_MONTHLY,\n   [env.NEXT_PUBLIC_BUSINESS_ANNUALLY_VARIANT_ID]: PremiumTier.BUSINESS_ANNUALLY,\n   [env.NEXT_PUBLIC_COPILOT_MONTHLY_VARIANT_ID]: PremiumTier.COPILOT_MONTHLY,\n-  [env.NEXT_PUBLIC_LIFETIME_VARIANT_ID]: PremiumTier.LIFETIME,\n };\n \n-const tierToVariantId: Record<PremiumTier, number> = {\n+// --- Stripe Configuration --- //\n+\n+const STRIPE_PRICE_ID_CONFIG: Record<\n+  PremiumTier,\n+  {\n+    // active price id\n+    priceId?: string;\n+    // Allow handling of old price ids\n+    oldPriceIds?: string[];\n+  }\n+> = {\n+  [PremiumTier.BASIC_MONTHLY]: {},\n+  [PremiumTier.BASIC_ANNUALLY]: {},\n+  [PremiumTier.PRO_MONTHLY]: {},\n+  [PremiumTier.PRO_ANNUALLY]: {},\n+  [PremiumTier.BUSINESS_MONTHLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_MONTHLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_ANNUALLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_ANNUALLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_PLUS_MONTHLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_PLUS_MONTHLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_PLUS_ANNUALLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_PLUS_ANNUALLY_PRICE_ID,\n+  },\n+  [PremiumTier.COPILOT_MONTHLY]: {},\n+  [PremiumTier.LIFETIME]: {},\n+};\n+\n+export function getStripeSubscriptionTier({\n+  priceId,\n+}: {\n+  priceId: string;\n+}): PremiumTier | null {\n+  const entries = Object.entries(STRIPE_PRICE_ID_CONFIG);\n+\n+  for (const [tier, config] of entries) {\n+    if (config.priceId === priceId || config.oldPriceIds?.includes(priceId)) {\n+      return tier as PremiumTier;\n+    }\n+  }\n+  return null;\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2079898170",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 425,
        "pr_file": "apps/web/app/(app)/premium/config.ts",
        "discussion_id": "2079898170",
        "commented_code": "@@ -56,18 +51,75 @@ const variantIdToTier: Record<number, PremiumTier> = {\n   [env.NEXT_PUBLIC_BUSINESS_MONTHLY_VARIANT_ID]: PremiumTier.BUSINESS_MONTHLY,\n   [env.NEXT_PUBLIC_BUSINESS_ANNUALLY_VARIANT_ID]: PremiumTier.BUSINESS_ANNUALLY,\n   [env.NEXT_PUBLIC_COPILOT_MONTHLY_VARIANT_ID]: PremiumTier.COPILOT_MONTHLY,\n-  [env.NEXT_PUBLIC_LIFETIME_VARIANT_ID]: PremiumTier.LIFETIME,\n };\n \n-const tierToVariantId: Record<PremiumTier, number> = {\n+// --- Stripe Configuration --- //\n+\n+const STRIPE_PRICE_ID_CONFIG: Record<\n+  PremiumTier,\n+  {\n+    // active price id\n+    priceId?: string;\n+    // Allow handling of old price ids\n+    oldPriceIds?: string[];\n+  }\n+> = {\n+  [PremiumTier.BASIC_MONTHLY]: {},\n+  [PremiumTier.BASIC_ANNUALLY]: {},\n+  [PremiumTier.PRO_MONTHLY]: {},\n+  [PremiumTier.PRO_ANNUALLY]: {},\n+  [PremiumTier.BUSINESS_MONTHLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_MONTHLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_ANNUALLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_ANNUALLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_PLUS_MONTHLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_PLUS_MONTHLY_PRICE_ID,\n+  },\n+  [PremiumTier.BUSINESS_PLUS_ANNUALLY]: {\n+    priceId: env.NEXT_PUBLIC_STRIPE_BUSINESS_PLUS_ANNUALLY_PRICE_ID,\n+  },\n+  [PremiumTier.COPILOT_MONTHLY]: {},\n+  [PremiumTier.LIFETIME]: {},\n+};\n+\n+export function getStripeSubscriptionTier({\n+  priceId,\n+}: {\n+  priceId: string;\n+}): PremiumTier | null {\n+  const entries = Object.entries(STRIPE_PRICE_ID_CONFIG);\n+\n+  for (const [tier, config] of entries) {\n+    if (config.priceId === priceId || config.oldPriceIds?.includes(priceId)) {\n+      return tier as PremiumTier;\n+    }\n+  }\n+  return null;\n+}",
        "comment_created_at": "2025-05-08T14:58:59+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**`getStripeSubscriptionTier` complexity is O(n) \u2013 cache map once**\n\nThe function does a linear search every time it is called.  \nAs usage grows (webhooks, middleware) this could become a hot-path.\n\nCache a `priceId \u2192 tier` map once at module load:\n\n```ts\nconst PRICE_ID_TO_TIER = Object.entries(STRIPE_PRICE_ID_CONFIG).reduce(\n  (acc, [tier, cfg]) => {\n    if (cfg.priceId) acc[cfg.priceId] = tier as PremiumTier;\n    cfg.oldPriceIds?.forEach((id) => (acc[id] = tier as PremiumTier));\n    return acc;\n  },\n  {} as Record<string, PremiumTier>,\n);\n\nexport function getStripeSubscriptionTier({ priceId }: { priceId: string }) {\n  return PRICE_ID_TO_TIER[priceId] ?? null;\n}\n```\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]