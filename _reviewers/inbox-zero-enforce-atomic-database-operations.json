[
  {
    "discussion_id": "2144212931",
    "pr_number": 478,
    "pr_file": "apps/web/app/api/resend/digest/route.ts",
    "created_at": "2025-06-13T05:06:03+00:00",
    "commented_code": "+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2144239023",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/app/api/resend/digest/route.ts",
        "discussion_id": "2144212931",
        "commented_code": "@@ -0,0 +1,266 @@\n+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
        "comment_created_at": "2025-06-13T05:34:51+00:00",
        "comment_author": "edulelis",
        "comment_body": "can't fix",
        "pr_file_module": null
      }
    ]
  }
]