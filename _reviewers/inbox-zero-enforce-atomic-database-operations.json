[
  {
    "discussion_id": "2141634346",
    "pr_number": 478,
    "pr_file": "apps/web/app/api/ai/digest/route.ts",
    "created_at": "2025-06-12T03:46:13+00:00",
    "commented_code": "+import { NextResponse } from \"next/server\";\n+import { digestBody } from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import prisma from \"@/utils/prisma\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getRuleNameByExecutedAction } from \"@/utils/actions/rule\";\n+import { aiSummarizeEmailForDigest } from \"@/utils/ai/digest/summarize-email-for-digest\";\n+import { getEmailAccountWithAi } from \"@/utils/user/get\";\n+\n+export async function POST(request: Request) {\n+  const body = digestBody.parse(await request.json());\n+  const { emailAccountId, coldEmailId, actionId, message } = body;\n+\n+  const logger = createScopedLogger(\"digest\").with({\n+    emailAccountId,\n+    messageId: message.id,\n+  });\n+\n+  try {\n+    // First, find the oldest unsent digest or create a new one if none exist\n+    const oldestUnsentDigest = await prisma.digest.findFirst({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      orderBy: {\n+        createdAt: \"asc\",\n+      },\n+    });\n+\n+    const digest =\n+      oldestUnsentDigest ||\n+      (await prisma.digest.create({\n+        data: {\n+          emailAccountId,\n+          status: DigestStatus.PENDING,\n+        },\n+      }));\n+\n+    // Then, find or create the DigestItem\n+    const existingDigestItem = await prisma.digestItem.findFirst({\n+      where: {\n+        digestId: digest.id,\n+        messageId: message.id,\n+        threadId: message.threadId,\n+      },\n+    });",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2141634346",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/app/api/ai/digest/route.ts",
        "discussion_id": "2141634346",
        "commented_code": "@@ -0,0 +1,94 @@\n+import { NextResponse } from \"next/server\";\n+import { digestBody } from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import prisma from \"@/utils/prisma\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getRuleNameByExecutedAction } from \"@/utils/actions/rule\";\n+import { aiSummarizeEmailForDigest } from \"@/utils/ai/digest/summarize-email-for-digest\";\n+import { getEmailAccountWithAi } from \"@/utils/user/get\";\n+\n+export async function POST(request: Request) {\n+  const body = digestBody.parse(await request.json());\n+  const { emailAccountId, coldEmailId, actionId, message } = body;\n+\n+  const logger = createScopedLogger(\"digest\").with({\n+    emailAccountId,\n+    messageId: message.id,\n+  });\n+\n+  try {\n+    // First, find the oldest unsent digest or create a new one if none exist\n+    const oldestUnsentDigest = await prisma.digest.findFirst({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      orderBy: {\n+        createdAt: \"asc\",\n+      },\n+    });\n+\n+    const digest =\n+      oldestUnsentDigest ||\n+      (await prisma.digest.create({\n+        data: {\n+          emailAccountId,\n+          status: DigestStatus.PENDING,\n+        },\n+      }));\n+\n+    // Then, find or create the DigestItem\n+    const existingDigestItem = await prisma.digestItem.findFirst({\n+      where: {\n+        digestId: digest.id,\n+        messageId: message.id,\n+        threadId: message.threadId,\n+      },\n+    });",
        "comment_created_at": "2025-06-12T03:46:13+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n_\u26a0\ufe0f Potential issue_\n\n**Duplicate \u201cfind-or-create digest\u201d logic + race condition**  \nThe handler re-implements the same logic that exists in `utils/digest/index.ts`, including the non-atomic \u201cfind oldest unsent \u2192 maybe create new\u201d flow. Two issues arise:\n\n1. Concurrent requests can still generate multiple digests.  \n2. Code duplication increases maintenance cost and risk of divergence.\n\nProposed fix:\n\n1. Move the handler to a thin wrapper that validates the body and then calls `upsertDigest`.  \n2. Inside `upsertDigest`, wrap the query sequence in `prisma.$transaction` (see earlier comment).\n\nThis removes the race window and centralises the behaviour.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/app/api/ai/digest/route.ts between lines 20 and 48, the code\nduplicates the \"find or create digest\" logic already present in\nutils/digest/index.ts and performs a non-atomic find-then-create sequence that\ncan cause race conditions. To fix this, refactor the handler to only validate\nthe request body and then call the existing upsertDigest function. Inside\nupsertDigest, ensure the find-or-create logic is wrapped in a\nprisma.$transaction to make it atomic and prevent concurrent requests from\ncreating multiple digests. This will centralize the logic and eliminate the race\ncondition.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commit 6c4609c",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2144212931",
    "pr_number": 478,
    "pr_file": "apps/web/app/api/resend/digest/route.ts",
    "created_at": "2025-06-13T05:06:03+00:00",
    "commented_code": "+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2144212931",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/app/api/resend/digest/route.ts",
        "discussion_id": "2144212931",
        "commented_code": "@@ -0,0 +1,266 @@\n+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
        "comment_created_at": "2025-06-13T05:06:03+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Potential double-send race due to \u201cfind-then-update\u201d pattern**\n\nTwo concurrent workers can both:\n\n1. `findMany` the same `PENDING` rows before either transaction commits  \n2. each mark the rows as `PROCESSING` inside their own transaction  \n3. happily process & email **twice**\n\nA safer pattern is a single `UPDATE \u2026 WHERE status = PENDING \u2026 RETURNING id` (or Prisma\u2019s `updateMany` + `select`) so only one worker claims a row. Alternatively, wrap the `findMany` in `SELECT \u2026 FOR UPDATE SKIP LOCKED` but Prisma lacks first-class support for that.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/app/api/resend/digest/route.ts between lines 63 and 105, the current\ncode uses a find-then-update pattern that can cause a race condition where\nmultiple workers process the same pending digests. To fix this, replace the\nseparate findMany and updateMany calls with a single atomic updateMany call that\nupdates digests with status PENDING to PROCESSING and returns the updated rows,\nensuring only one worker claims each digest. This prevents double processing by\nmaking the claim and status update in one step.\n```\n\n</details>\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
        "pr_file_module": null
      },
      {
        "comment_id": "2144239023",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/app/api/resend/digest/route.ts",
        "discussion_id": "2144212931",
        "commented_code": "@@ -0,0 +1,266 @@\n+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
        "comment_created_at": "2025-06-13T05:34:51+00:00",
        "comment_author": "edulelis",
        "comment_body": "can't fix",
        "pr_file_module": null
      },
      {
        "comment_id": "2144239299",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/app/api/resend/digest/route.ts",
        "discussion_id": "2144212931",
        "commented_code": "@@ -0,0 +1,266 @@\n+import { NextResponse } from \"next/server\";\n+import { sendDigestEmail } from \"@inboxzero/resend\";\n+import { withEmailAccount, withError } from \"@/utils/middleware\";\n+import { env } from \"@/env\";\n+import { hasCronSecret } from \"@/utils/cron\";\n+import { captureException } from \"@/utils/error\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createUnsubscribeToken } from \"@/utils/unsubscribe\";\n+import { camelCase } from \"lodash\";\n+import { calculateNextFrequencyDate } from \"@/utils/frequency\";\n+import { getGmailAndAccessTokenForEmail } from \"@/utils/account\";\n+import { getMessagesBatch, getMessagesLargeBatch } from \"@/utils/gmail/message\";\n+import {\n+  digestCategorySchema,\n+  sendDigestEmailBody,\n+  type Digest,\n+  digestSummarySchema,\n+  DigestEmailSummarySchema,\n+} from \"./validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import { extractNameFromEmail } from \"../../../../utils/email\";\n+import { RuleName } from \"@/utils/rule/consts\";\n+import { getEmailAccountWithAiAndTokens } from \"@/utils/user/get\";\n+import { getGmailClientWithRefresh } from \"@/utils/gmail/client\";\n+\n+export const maxDuration = 60;\n+\n+const logger = createScopedLogger(\"resend/digest\");\n+\n+type SendEmailResult = {\n+  success: boolean;\n+  message: string;\n+};\n+\n+async function sendEmail({\n+  emailAccountId,\n+  force,\n+}: {\n+  emailAccountId: string;\n+  force?: boolean;\n+}): Promise<SendEmailResult> {\n+  const loggerOptions = { emailAccountId, force };\n+  logger.info(\"Sending digest email\", loggerOptions);\n+\n+  const emailAccount = await getEmailAccountWithAiAndTokens({ emailAccountId });\n+\n+  if (!emailAccount) {\n+    throw new Error(\"Email account not found\");\n+  }\n+\n+  if (!emailAccount.tokens.access_token) {\n+    throw new Error(\"No access token available\");\n+  }\n+\n+  const gmail = await getGmailClientWithRefresh({\n+    accessToken: emailAccount.tokens.access_token,\n+    refreshToken: emailAccount.tokens.refresh_token,\n+    expiresAt: emailAccount.tokens.expires_at,\n+    emailAccountId,\n+  });\n+\n+  const digests = await prisma.$transaction(async (tx) => {\n+    const pendingDigests = await tx.digest.findMany({\n+      where: {\n+        emailAccountId,\n+        status: DigestStatus.PENDING,\n+      },\n+      include: {\n+        items: {\n+          include: {\n+            action: {\n+              include: {\n+                executedRule: {\n+                  include: {\n+                    rule: {\n+                      select: {\n+                        name: true,\n+                      },\n+                    },\n+                  },\n+                },\n+              },\n+            },\n+          },\n+        },\n+      },\n+    });\n+\n+    if (pendingDigests.length) {\n+      // Mark all found digests as processing\n+      await tx.digest.updateMany({\n+        where: {\n+          id: {\n+            in: pendingDigests.map((d) => d.id),\n+          },\n+        },\n+        data: {\n+          status: DigestStatus.PROCESSING,\n+        },\n+      });\n+    }\n+\n+    return pendingDigests;\n+  });",
        "comment_created_at": "2025-06-13T05:35:09+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "@edulelis Understood\u2014thanks for letting me know. We can leave the current logic as-is. If at some point you\u2019d like to revisit this race-condition concern, just let me know and I can open a follow-up issue to track it. Otherwise, I\u2019ll consider the discussion resolved.  \n  \n(\\_/)\n( \u2022_\u2022)\n/>\ud83d\udc94\n\n\n<!-- <agentComponentType>chat-answer</agentComponentType> -->\n\n<!-- <rawResChunk><answer>@edulelis Understood\u2014thanks for letting me know. We can leave the current logic as-is. If at some point you\u2019d like to revisit this race-condition concern, just let me know and I can open a follow-up issue to track it. Otherwise, I\u2019ll consider the discussion resolved.  \n  \n(\\_/)\n( \u2022_\u2022)\n/>\ud83d\udc94</answer></rawResChunk> -->\n\n<!-- This is an auto-generated reply by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142901881",
    "pr_number": 494,
    "pr_file": "apps/web/utils/referral/referral-code.ts",
    "created_at": "2025-06-12T14:19:40+00:00",
    "commented_code": "+import { randomBytes } from \"node:crypto\";\n+import prisma from \"@/utils/prisma\";\n+import { SafeError } from \"@/utils/error\";\n+\n+/**\n+ * Generate a random alphanumeric string of specified length\n+ */\n+function generateRandomString(length: number): string {\n+  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n+  const bytes = randomBytes(length);\n+  return Array.from(bytes)\n+    .map((byte) => chars[byte % chars.length])\n+    .join(\"\");\n+}\n+\n+/**\n+ * Generate a unique referral code for a user\n+ * Format: 6 random alphanumeric characters\n+ */\n+export async function generateReferralCode(): Promise<string> {\n+  let code = \"\";\n+  let isUnique = false;\n+  let attempts = 0;\n+  const maxAttempts = 5;\n+\n+  // Try to generate a unique code\n+  while (!isUnique && attempts < maxAttempts) {\n+    code = generateRandomString(6);\n+\n+    // Check if code already exists\n+    const existingUser = await prisma.user.findUnique({\n+      where: { referralCode: code },\n+    });\n+\n+    if (!existingUser) {\n+      isUnique = true;\n+    }\n+    attempts++;\n+  }\n+\n+  if (!isUnique) {\n+    throw new SafeError(\"Unable to generate unique referral code\");\n+  }\n+\n+  return code;\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2142901881",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 494,
        "pr_file": "apps/web/utils/referral/referral-code.ts",
        "discussion_id": "2142901881",
        "commented_code": "@@ -0,0 +1,159 @@\n+import { randomBytes } from \"node:crypto\";\n+import prisma from \"@/utils/prisma\";\n+import { SafeError } from \"@/utils/error\";\n+\n+/**\n+ * Generate a random alphanumeric string of specified length\n+ */\n+function generateRandomString(length: number): string {\n+  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n+  const bytes = randomBytes(length);\n+  return Array.from(bytes)\n+    .map((byte) => chars[byte % chars.length])\n+    .join(\"\");\n+}\n+\n+/**\n+ * Generate a unique referral code for a user\n+ * Format: 6 random alphanumeric characters\n+ */\n+export async function generateReferralCode(): Promise<string> {\n+  let code = \"\";\n+  let isUnique = false;\n+  let attempts = 0;\n+  const maxAttempts = 5;\n+\n+  // Try to generate a unique code\n+  while (!isUnique && attempts < maxAttempts) {\n+    code = generateRandomString(6);\n+\n+    // Check if code already exists\n+    const existingUser = await prisma.user.findUnique({\n+      where: { referralCode: code },\n+    });\n+\n+    if (!existingUser) {\n+      isUnique = true;\n+    }\n+    attempts++;\n+  }\n+\n+  if (!isUnique) {\n+    throw new SafeError(\"Unable to generate unique referral code\");\n+  }\n+\n+  return code;\n+}",
        "comment_created_at": "2025-06-12T14:19:40+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Race condition between uniqueness check and user update**\n\nTwo concurrent requests can:\n\n1. both pass the `findUnique` check (lines 31-37),\n2. both return the same `code`,\n3. both attempt `prisma.user.update` (lines 70-73) \u2192 unique-constraint violation.\n\nHandle uniqueness at the DB layer and retry only on the specific Prisma `P2002` error instead of a best-effort pre-check.\n\n```diff\n-// Try to generate a unique code\n-while (!isUnique && attempts < maxAttempts) {\n-  code = generateRandomString(6);\n-  ...\n-}\n-...\n-// Update the user with the new code\n-await prisma.user.update({\n-  where: { id: userId },\n-  data: { referralCode: code },\n-});\n+while (attempts < maxAttempts) {\n+  code = generateRandomString(6);\n+  try {\n+    await prisma.user.update({\n+      where: { id: userId },\n+      data: { referralCode: code },\n+    });\n+    return { code }; // success\n+  } catch (err: any) {\n+    if (err.code !== \"P2002\") throw err; // unexpected\n+    attempts++;                           // collision \u2013 retry\n+  }\n+}\n+\n+throw new SafeError(\"Unable to generate unique referral code\");\n```\n\n\n\nAlso applies to: 66-73\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/referral/referral-code.ts around lines 27 to 46, the current\ncode checks for referral code uniqueness with a pre-check query, which can cause\nrace conditions when concurrent requests generate the same code. To fix this,\nremove the pre-check and instead attempt to update the user with the generated\ncode directly, catching the Prisma P2002 unique constraint error to retry code\ngeneration. Apply the same pattern to lines 66 to 73 to ensure uniqueness is\nenforced atomically at the database layer with proper retry logic on unique\nconstraint violations.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commits de21702 to 47f7649",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136306233",
    "pr_number": 497,
    "pr_file": "apps/web/utils/rule/rule-history.ts",
    "created_at": "2025-06-09T19:03:25+00:00",
    "commented_code": "+import prisma from \"@/utils/prisma\";\n+import type { RuleWithRelations } from \"@/utils/ai/rule/create-prompt-from-rule\";\n+\n+export type RuleHistoryTrigger =\n+  | \"ai_update\" // AI updates existing rule from prompt changes\n+  | \"manual_update\" // User manually edits existing rule\n+  | \"ai_creation\" // AI creates rule from parsing prompts\n+  | \"manual_creation\" // User manually creates new rule\n+  | \"system_creation\" // System automatically creates rule (e.g., reply tracker)\n+  | \"system_update\"; // System automatically updates rule\n+\n+/**\n+ * Creates a complete snapshot of a rule in the RuleHistory table\n+ */\n+export async function createRuleHistory({\n+  rule,\n+  triggerType,\n+}: {\n+  rule: RuleWithRelations;\n+  triggerType: RuleHistoryTrigger;\n+}) {\n+  // Get the current version number for this rule\n+  const lastHistory = await prisma.ruleHistory.findFirst({\n+    where: { ruleId: rule.id },\n+    orderBy: { version: \"desc\" },\n+    select: { version: true },\n+  });\n+\n+  const nextVersion = (lastHistory?.version ?? 0) + 1;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2136306233",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 497,
        "pr_file": "apps/web/utils/rule/rule-history.ts",
        "discussion_id": "2136306233",
        "commented_code": "@@ -0,0 +1,73 @@\n+import prisma from \"@/utils/prisma\";\n+import type { RuleWithRelations } from \"@/utils/ai/rule/create-prompt-from-rule\";\n+\n+export type RuleHistoryTrigger =\n+  | \"ai_update\" // AI updates existing rule from prompt changes\n+  | \"manual_update\" // User manually edits existing rule\n+  | \"ai_creation\" // AI creates rule from parsing prompts\n+  | \"manual_creation\" // User manually creates new rule\n+  | \"system_creation\" // System automatically creates rule (e.g., reply tracker)\n+  | \"system_update\"; // System automatically updates rule\n+\n+/**\n+ * Creates a complete snapshot of a rule in the RuleHistory table\n+ */\n+export async function createRuleHistory({\n+  rule,\n+  triggerType,\n+}: {\n+  rule: RuleWithRelations;\n+  triggerType: RuleHistoryTrigger;\n+}) {\n+  // Get the current version number for this rule\n+  const lastHistory = await prisma.ruleHistory.findFirst({\n+    where: { ruleId: rule.id },\n+    orderBy: { version: \"desc\" },\n+    select: { version: true },\n+  });\n+\n+  const nextVersion = (lastHistory?.version ?? 0) + 1;",
        "comment_created_at": "2025-06-09T19:03:25+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Consider potential race conditions in version incrementing.**\n\nThe current version incrementing logic could face race conditions if multiple history entries are created simultaneously for the same rule. Consider using a database-level constraint or atomic operation.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Verify if there are any unique constraints on version field\nast-grep --pattern 'unique([ruleId, version])'\n```\n\nLength of output: 48\n\n---\n\nLet\u2019s check your Prisma schema for a composite unique constraint on RuleHistory:\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Find the RuleHistory model and show its definition\nrg -A5 \"model RuleHistory\" --glob \"*.prisma\"\n```\n\nLength of output: 456\n\n---\n\n\n\n</details>\n\n**Enforce uniqueness on (ruleId, version) to prevent race\u2010condition duplicates**\n\nTo guarantee that two simultaneous inserts can\u2019t end up with the same version, add a composite unique constraint in your Prisma schema and handle any conflicts at write time:\n\n\u2022 In `apps/web/prisma/schema.prisma` under the `RuleHistory` model, append:  \n```prisma\nmodel RuleHistory {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n  ruleId    String\n  rule      Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)\n  version   Int\n\n  @@unique([ruleId, version])\n}\n```  \n\u2022 After updating the schema, run `prisma migrate dev` (or your workflow) to apply the new index.  \n\u2022 In your version\u2010increment code, wrap the fetch + insert in a transaction or catch unique\u2010constraint errors to retry if needed:\n\n```ts\nawait prisma.$transaction(async tx => {\n  const last = await tx.ruleHistory.findFirst({\n    where: { ruleId: rule.id },\n    orderBy: { version: 'desc' },\n    select: { version: true },\n  });\n  const nextVersion = (last?.version ?? 0) + 1;\n  return tx.ruleHistory.create({ data: { ruleId: rule.id, version: nextVersion /* \u2026 */ } });\n}).catch(e => {\n  if (e.code === 'P2002') {\n    // unique constraint violation \u2192 retry or handle appropriately\n  }\n  throw e;\n});\n```  \nThis ensures at-the-DB level that duplicate versions can\u2019t be written, even under concurrent loads.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/rule/rule-history.ts around lines 23 to 29, the current\nversion increment logic can cause race conditions when multiple inserts happen\nconcurrently. To fix this, add a composite unique constraint on (ruleId,\nversion) in the RuleHistory model within apps/web/prisma/schema.prisma, then run\nprisma migrate to apply it. Next, wrap the version fetch and insert operations\ninside a prisma transaction and catch unique constraint errors (code P2002) to\nretry or handle conflicts, ensuring no duplicate versions are created under\nconcurrent writes.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2055861414",
    "pr_number": 412,
    "pr_file": "apps/web/utils/actions/rule.ts",
    "created_at": "2025-04-23T11:39:51+00:00",
    "commented_code": "data: { rulesPrompt: updatedPrompt },\n       });\n \n-      revalidatePath(`/automation/rule/${ruleId}`);\n+      revalidatePath(`/automation/rule/${id}`);\n       revalidatePath(\"/automation\");\n     } catch (error) {\n       if (isNotFoundError(error)) return;\n       throw error;\n     }\n-  },\n-);\n-\n-export const getRuleExamplesAction = withActionInstrumentation(\n-  \"getRuleExamples\",\n-  async (unsafeData: RulesExamplesBody) => {\n-    const session = await auth();\n-    if (!session?.user.email) return { error: \"Not logged in\" };\n-\n-    const { success, error, data } = rulesExamplesBody.safeParse(unsafeData);\n-    if (!success) return { error: error.message };\n+  });\n \n-    const gmail = getGmailClient(session);\n+export const getRuleExamplesAction = actionClient\n+  .metadata({ name: \"getRuleExamples\" })\n+  .schema(rulesExamplesBody)\n+  .action(async ({ ctx: { email }, parsedInput: { rulesPrompt } }) => {\n+    const gmail = await getGmailClientForEmail({ email });\n \n-    const user = await getAiUser({ email: session.user.email });\n+    const user = await getAiUser({ email });\n     if (!user) return { error: \"User not found\" };\n \n-    const { matches } = await aiFindExampleMatches(\n-      user,\n-      gmail,\n-      data.rulesPrompt,\n-    );\n+    const { matches } = await aiFindExampleMatches(user, gmail, rulesPrompt);\n \n     return { matches };\n-  },\n-);\n-\n-export const createRulesOnboardingAction = withActionInstrumentation(\n-  \"createRulesOnboarding\",\n-  async (options: CreateRulesOnboardingBody) => {\n-    const session = await auth();\n-    const email = session?.user.email;\n-    if (!email) return { error: \"Not logged in\" };\n-    const userId = session?.user.id;\n-\n-    const { data, error } = createRulesOnboardingBody.safeParse(options);\n-    if (error) return { error: error.message };\n-\n-    const user = await prisma.emailAccount.findUnique({\n-      where: { email },\n-      select: { rulesPrompt: true },\n-    });\n-    if (!user) return { error: \"User not found\" };\n-\n-    const promises: Promise<any>[] = [];\n-\n-    const isSet = (value: string): value is \"label\" | \"label_archive\" =>\n-      value !== \"none\";\n-\n-    // cold email blocker\n-    if (isSet(data.coldEmail)) {\n-      const promise = prisma.emailAccount.update({\n+  });\n+\n+export const createRulesOnboardingAction = actionClient\n+  .metadata({ name: \"createRulesOnboarding\" })\n+  .schema(createRulesOnboardingBody)\n+  .action(\n+    async ({\n+      ctx: { email },\n+      parsedInput: {\n+        newsletter,\n+        coldEmail,\n+        toReply,\n+        marketing,\n+        calendar,\n+        receipt,\n+        notification,\n+      },\n+    }) => {\n+      const user = await prisma.emailAccount.findUnique({\n         where: { email },\n-        data: {\n-          coldEmailBlocker:\n-            data.coldEmail === \"label\"\n-              ? ColdEmailSetting.LABEL\n-              : ColdEmailSetting.ARCHIVE_AND_LABEL,\n-        },\n+        select: { rulesPrompt: true },\n       });\n-      promises.push(promise);\n-    }\n+      if (!user) return { error: \"User not found\" };\n \n-    const rules: string[] = [];\n-\n-    // reply tracker\n-    if (isSet(data.toReply)) {\n-      const promise = enableReplyTracker({ email }).then((res) => {\n-        if (res?.alreadyEnabled) return;\n-\n-        // Load previous emails needing replies in background\n-        // This can take a while\n-        fetch(\n-          `${env.NEXT_PUBLIC_BASE_URL}/api/reply-tracker/process-previous`,\n-          {\n-            method: \"POST\",\n-            headers: {\n-              \"Content-Type\": \"application/json\",\n-              [INTERNAL_API_KEY_HEADER]: env.INTERNAL_API_KEY,\n-            },\n-            body: JSON.stringify({ email } satisfies ProcessPreviousBody),\n-          },\n-        );\n-      });\n-      promises.push(promise);\n-    }\n+      const promises: Promise<any>[] = [];\n \n-    // regular categories\n-    async function createRule(\n-      name: string,\n-      instructions: string,\n-      promptFileInstructions: string,\n-      runOnThreads: boolean,\n-      categoryAction: \"label\" | \"label_archive\",\n-      label: string,\n-      systemType: SystemType,\n-      userId: string,\n-    ) {\n-      const existingRule = await prisma.rule.findUnique({\n-        where: { userId_systemType: { userId, systemType } },\n-      });\n+      const isSet = (value: string): value is \"label\" | \"label_archive\" =>\n+        value !== \"none\";\n \n-      if (existingRule) {\n-        const promise = prisma.rule\n-          .update({\n-            where: { id: existingRule.id },\n-            data: {\n-              instructions,\n-              actions: {\n-                deleteMany: {},\n-                createMany: {\n-                  data: [\n-                    { type: ActionType.LABEL, label },\n-                    ...(categoryAction === \"label_archive\"\n-                      ? [{ type: ActionType.ARCHIVE }]\n-                      : []),\n-                  ],\n-                },\n+      // cold email blocker\n+      if (isSet(coldEmail)) {\n+        const promise = prisma.emailAccount.update({\n+          where: { email },\n+          data: {\n+            coldEmailBlocker:\n+              coldEmail === \"label\"\n+                ? ColdEmailSetting.LABEL\n+                : ColdEmailSetting.ARCHIVE_AND_LABEL,\n+          },\n+        });\n+        promises.push(promise);\n+      }\n+\n+      const rules: string[] = [];\n+\n+      // reply tracker\n+      if (isSet(toReply)) {\n+        const promise = enableReplyTracker({ email }).then((res) => {\n+          if (res?.alreadyEnabled) return;\n+\n+          // Load previous emails needing replies in background\n+          // This can take a while\n+          fetch(\n+            `${env.NEXT_PUBLIC_BASE_URL}/api/reply-tracker/process-previous`,\n+            {\n+              method: \"POST\",\n+              headers: {\n+                \"Content-Type\": \"application/json\",\n+                [INTERNAL_API_KEY_HEADER]: env.INTERNAL_API_KEY,\n               },\n+              body: JSON.stringify({ email } satisfies ProcessPreviousBody),\n             },\n-          })\n-          // NOTE: doesn't update without this line\n-          .then(() => {})\n-          .catch((error) => {\n-            logger.error(\"Error updating rule\", { error });\n-            throw error;\n-          });\n+          );\n+        });\n         promises.push(promise);\n+      }\n \n-        // TODO: prompt file update\n-      } else {\n-        const promise = prisma.rule\n-          .create({\n-            data: {\n-              userId,\n-              name,\n-              instructions,\n-              systemType,\n-              automate: true,\n-              runOnThreads,\n-              actions: {\n-                createMany: {\n-                  data: [\n-                    { type: ActionType.LABEL, label: \"Newsletter\" },\n-                    ...(categoryAction === \"label_archive\"\n-                      ? [{ type: ActionType.ARCHIVE }]\n-                      : []),\n-                  ],\n+      // regular categories\n+      async function createRule(\n+        name: string,\n+        instructions: string,\n+        promptFileInstructions: string,\n+        runOnThreads: boolean,\n+        categoryAction: \"label\" | \"label_archive\",\n+        label: string,\n+        systemType: SystemType,\n+        emailAccountId: string,\n+      ) {\n+        const existingRule = await prisma.rule.findUnique({\n+          where: { emailAccountId_systemType: { emailAccountId, systemType } },\n+        });\n+\n+        if (existingRule) {\n+          const promise = prisma.rule\n+            .update({\n+              where: { id: existingRule.id },\n+              data: {\n+                instructions,\n+                actions: {\n+                  deleteMany: {},\n+                  createMany: {\n+                    data: [\n+                      { type: ActionType.LABEL, label },\n+                      ...(categoryAction === \"label_archive\"\n+                        ? [{ type: ActionType.ARCHIVE }]\n+                        : []),\n+                    ],\n+                  },\n                 },\n               },\n+            })\n+            // NOTE: doesn't update without this line\n+            .then(() => {})\n+            .catch((error) => {\n+              logger.error(\"Error updating rule\", { error });\n+              throw error;\n+            });\n+          promises.push(promise);\n+\n+          // TODO: prompt file update\n+        } else {\n+          const promise = prisma.rule\n+            .create({\n+              data: {\n+                emailAccountId,\n+                name,\n+                instructions,\n+                systemType,\n+                automate: true,\n+                runOnThreads,\n+                actions: {\n+                  createMany: {\n+                    data: [\n+                      { type: ActionType.LABEL, label: \"Newsletter\" },\n+                      ...(categoryAction === \"label_archive\"\n+                        ? [{ type: ActionType.ARCHIVE }]\n+                        : []),\n+                    ],\n+                  },\n+                },\n+              },\n+            })\n+            .then(() => {})\n+            .catch((error) => {\n+              if (isDuplicateError(error, \"name\")) return;\n+              logger.error(\"Error creating rule\", { error });\n+              throw error;\n+            });\n+          promises.push(promise);\n+\n+          rules.push(\n+            `${promptFileInstructions}${\n+              categoryAction === \"label_archive\" ? \" and archive them\" : \"\"\n+            }.`,\n+          );\n+        }\n+      }\n+\n+      async function deleteRule(\n+        systemType: SystemType,\n+        emailAccountId: string,\n+      ) {\n+        const promise = async () => {\n+          const rule = await prisma.rule.findUnique({\n+            where: {\n+              emailAccountId_systemType: { emailAccountId, systemType },\n             },\n-          })\n-          .then(() => {})\n-          .catch((error) => {\n-            if (isDuplicateError(error, \"name\")) return;\n-            logger.error(\"Error creating rule\", { error });\n-            throw error;\n           });\n-        promises.push(promise);\n+          if (!rule) return;\n+          await prisma.rule.delete({ where: { id: rule.id } });\n+        };\n+        promises.push(promise());\n+      }\n \n-        rules.push(\n-          `${promptFileInstructions}${\n-            categoryAction === \"label_archive\" ? \" and archive them\" : \"\"\n-          }.`,\n+      // newsletter\n+      if (isSet(newsletter)) {\n+        createRule(\n+          RuleName.Newsletter,\n+          \"Newsletters: Regular content from publications, blogs, or services I've subscribed to\",\n+          \"Label all newsletters as 'Newsletter'\",\n+          false,\n+          newsletter,\n+          \"Newsletter\",\n+          SystemType.NEWSLETTER,\n+          email,\n         );\n+      } else {\n+        deleteRule(SystemType.NEWSLETTER, email);\n       }\n-    }\n \n-    async function deleteRule(systemType: SystemType, userId: string) {\n-      const promise = async () => {\n-        const rule = await prisma.rule.findUnique({\n-          where: { userId_systemType: { userId, systemType } },\n-        });\n-        if (!rule) return;\n-        await prisma.rule.delete({ where: { id: rule.id } });\n-      };\n-      promises.push(promise());\n-    }\n-\n-    // newsletter\n-    if (isSet(data.newsletter)) {\n-      createRule(\n-        RuleName.Newsletter,\n-        \"Newsletters: Regular content from publications, blogs, or services I've subscribed to\",\n-        \"Label all newsletters as 'Newsletter'\",\n-        false,\n-        data.newsletter,\n-        \"Newsletter\",\n-        SystemType.NEWSLETTER,\n-        userId,\n-      );\n-    } else {\n-      deleteRule(SystemType.NEWSLETTER, userId);\n-    }\n-\n-    // marketing\n-    if (isSet(data.marketing)) {\n-      createRule(\n-        RuleName.Marketing,\n-        \"Marketing: Promotional emails about products, services, sales, or offers\",\n-        \"Label all marketing emails as 'Marketing'\",\n-        false,\n-        data.marketing,\n-        \"Marketing\",\n-        SystemType.MARKETING,\n-        userId,\n-      );\n-    } else {\n-      deleteRule(SystemType.MARKETING, userId);\n-    }\n+      // marketing\n+      if (isSet(marketing)) {\n+        createRule(\n+          RuleName.Marketing,\n+          \"Marketing: Promotional emails about products, services, sales, or offers\",\n+          \"Label all marketing emails as 'Marketing'\",\n+          false,\n+          marketing,\n+          \"Marketing\",\n+          SystemType.MARKETING,\n+          email,\n+        );\n+      } else {\n+        deleteRule(SystemType.MARKETING, email);\n+      }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2055861414",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 412,
        "pr_file": "apps/web/utils/actions/rule.ts",
        "discussion_id": "2055861414",
        "commented_code": "@@ -394,279 +381,278 @@\n         data: { rulesPrompt: updatedPrompt },\n       });\n \n-      revalidatePath(`/automation/rule/${ruleId}`);\n+      revalidatePath(`/automation/rule/${id}`);\n       revalidatePath(\"/automation\");\n     } catch (error) {\n       if (isNotFoundError(error)) return;\n       throw error;\n     }\n-  },\n-);\n-\n-export const getRuleExamplesAction = withActionInstrumentation(\n-  \"getRuleExamples\",\n-  async (unsafeData: RulesExamplesBody) => {\n-    const session = await auth();\n-    if (!session?.user.email) return { error: \"Not logged in\" };\n-\n-    const { success, error, data } = rulesExamplesBody.safeParse(unsafeData);\n-    if (!success) return { error: error.message };\n+  });\n \n-    const gmail = getGmailClient(session);\n+export const getRuleExamplesAction = actionClient\n+  .metadata({ name: \"getRuleExamples\" })\n+  .schema(rulesExamplesBody)\n+  .action(async ({ ctx: { email }, parsedInput: { rulesPrompt } }) => {\n+    const gmail = await getGmailClientForEmail({ email });\n \n-    const user = await getAiUser({ email: session.user.email });\n+    const user = await getAiUser({ email });\n     if (!user) return { error: \"User not found\" };\n \n-    const { matches } = await aiFindExampleMatches(\n-      user,\n-      gmail,\n-      data.rulesPrompt,\n-    );\n+    const { matches } = await aiFindExampleMatches(user, gmail, rulesPrompt);\n \n     return { matches };\n-  },\n-);\n-\n-export const createRulesOnboardingAction = withActionInstrumentation(\n-  \"createRulesOnboarding\",\n-  async (options: CreateRulesOnboardingBody) => {\n-    const session = await auth();\n-    const email = session?.user.email;\n-    if (!email) return { error: \"Not logged in\" };\n-    const userId = session?.user.id;\n-\n-    const { data, error } = createRulesOnboardingBody.safeParse(options);\n-    if (error) return { error: error.message };\n-\n-    const user = await prisma.emailAccount.findUnique({\n-      where: { email },\n-      select: { rulesPrompt: true },\n-    });\n-    if (!user) return { error: \"User not found\" };\n-\n-    const promises: Promise<any>[] = [];\n-\n-    const isSet = (value: string): value is \"label\" | \"label_archive\" =>\n-      value !== \"none\";\n-\n-    // cold email blocker\n-    if (isSet(data.coldEmail)) {\n-      const promise = prisma.emailAccount.update({\n+  });\n+\n+export const createRulesOnboardingAction = actionClient\n+  .metadata({ name: \"createRulesOnboarding\" })\n+  .schema(createRulesOnboardingBody)\n+  .action(\n+    async ({\n+      ctx: { email },\n+      parsedInput: {\n+        newsletter,\n+        coldEmail,\n+        toReply,\n+        marketing,\n+        calendar,\n+        receipt,\n+        notification,\n+      },\n+    }) => {\n+      const user = await prisma.emailAccount.findUnique({\n         where: { email },\n-        data: {\n-          coldEmailBlocker:\n-            data.coldEmail === \"label\"\n-              ? ColdEmailSetting.LABEL\n-              : ColdEmailSetting.ARCHIVE_AND_LABEL,\n-        },\n+        select: { rulesPrompt: true },\n       });\n-      promises.push(promise);\n-    }\n+      if (!user) return { error: \"User not found\" };\n \n-    const rules: string[] = [];\n-\n-    // reply tracker\n-    if (isSet(data.toReply)) {\n-      const promise = enableReplyTracker({ email }).then((res) => {\n-        if (res?.alreadyEnabled) return;\n-\n-        // Load previous emails needing replies in background\n-        // This can take a while\n-        fetch(\n-          `${env.NEXT_PUBLIC_BASE_URL}/api/reply-tracker/process-previous`,\n-          {\n-            method: \"POST\",\n-            headers: {\n-              \"Content-Type\": \"application/json\",\n-              [INTERNAL_API_KEY_HEADER]: env.INTERNAL_API_KEY,\n-            },\n-            body: JSON.stringify({ email } satisfies ProcessPreviousBody),\n-          },\n-        );\n-      });\n-      promises.push(promise);\n-    }\n+      const promises: Promise<any>[] = [];\n \n-    // regular categories\n-    async function createRule(\n-      name: string,\n-      instructions: string,\n-      promptFileInstructions: string,\n-      runOnThreads: boolean,\n-      categoryAction: \"label\" | \"label_archive\",\n-      label: string,\n-      systemType: SystemType,\n-      userId: string,\n-    ) {\n-      const existingRule = await prisma.rule.findUnique({\n-        where: { userId_systemType: { userId, systemType } },\n-      });\n+      const isSet = (value: string): value is \"label\" | \"label_archive\" =>\n+        value !== \"none\";\n \n-      if (existingRule) {\n-        const promise = prisma.rule\n-          .update({\n-            where: { id: existingRule.id },\n-            data: {\n-              instructions,\n-              actions: {\n-                deleteMany: {},\n-                createMany: {\n-                  data: [\n-                    { type: ActionType.LABEL, label },\n-                    ...(categoryAction === \"label_archive\"\n-                      ? [{ type: ActionType.ARCHIVE }]\n-                      : []),\n-                  ],\n-                },\n+      // cold email blocker\n+      if (isSet(coldEmail)) {\n+        const promise = prisma.emailAccount.update({\n+          where: { email },\n+          data: {\n+            coldEmailBlocker:\n+              coldEmail === \"label\"\n+                ? ColdEmailSetting.LABEL\n+                : ColdEmailSetting.ARCHIVE_AND_LABEL,\n+          },\n+        });\n+        promises.push(promise);\n+      }\n+\n+      const rules: string[] = [];\n+\n+      // reply tracker\n+      if (isSet(toReply)) {\n+        const promise = enableReplyTracker({ email }).then((res) => {\n+          if (res?.alreadyEnabled) return;\n+\n+          // Load previous emails needing replies in background\n+          // This can take a while\n+          fetch(\n+            `${env.NEXT_PUBLIC_BASE_URL}/api/reply-tracker/process-previous`,\n+            {\n+              method: \"POST\",\n+              headers: {\n+                \"Content-Type\": \"application/json\",\n+                [INTERNAL_API_KEY_HEADER]: env.INTERNAL_API_KEY,\n               },\n+              body: JSON.stringify({ email } satisfies ProcessPreviousBody),\n             },\n-          })\n-          // NOTE: doesn't update without this line\n-          .then(() => {})\n-          .catch((error) => {\n-            logger.error(\"Error updating rule\", { error });\n-            throw error;\n-          });\n+          );\n+        });\n         promises.push(promise);\n+      }\n \n-        // TODO: prompt file update\n-      } else {\n-        const promise = prisma.rule\n-          .create({\n-            data: {\n-              userId,\n-              name,\n-              instructions,\n-              systemType,\n-              automate: true,\n-              runOnThreads,\n-              actions: {\n-                createMany: {\n-                  data: [\n-                    { type: ActionType.LABEL, label: \"Newsletter\" },\n-                    ...(categoryAction === \"label_archive\"\n-                      ? [{ type: ActionType.ARCHIVE }]\n-                      : []),\n-                  ],\n+      // regular categories\n+      async function createRule(\n+        name: string,\n+        instructions: string,\n+        promptFileInstructions: string,\n+        runOnThreads: boolean,\n+        categoryAction: \"label\" | \"label_archive\",\n+        label: string,\n+        systemType: SystemType,\n+        emailAccountId: string,\n+      ) {\n+        const existingRule = await prisma.rule.findUnique({\n+          where: { emailAccountId_systemType: { emailAccountId, systemType } },\n+        });\n+\n+        if (existingRule) {\n+          const promise = prisma.rule\n+            .update({\n+              where: { id: existingRule.id },\n+              data: {\n+                instructions,\n+                actions: {\n+                  deleteMany: {},\n+                  createMany: {\n+                    data: [\n+                      { type: ActionType.LABEL, label },\n+                      ...(categoryAction === \"label_archive\"\n+                        ? [{ type: ActionType.ARCHIVE }]\n+                        : []),\n+                    ],\n+                  },\n                 },\n               },\n+            })\n+            // NOTE: doesn't update without this line\n+            .then(() => {})\n+            .catch((error) => {\n+              logger.error(\"Error updating rule\", { error });\n+              throw error;\n+            });\n+          promises.push(promise);\n+\n+          // TODO: prompt file update\n+        } else {\n+          const promise = prisma.rule\n+            .create({\n+              data: {\n+                emailAccountId,\n+                name,\n+                instructions,\n+                systemType,\n+                automate: true,\n+                runOnThreads,\n+                actions: {\n+                  createMany: {\n+                    data: [\n+                      { type: ActionType.LABEL, label: \"Newsletter\" },\n+                      ...(categoryAction === \"label_archive\"\n+                        ? [{ type: ActionType.ARCHIVE }]\n+                        : []),\n+                    ],\n+                  },\n+                },\n+              },\n+            })\n+            .then(() => {})\n+            .catch((error) => {\n+              if (isDuplicateError(error, \"name\")) return;\n+              logger.error(\"Error creating rule\", { error });\n+              throw error;\n+            });\n+          promises.push(promise);\n+\n+          rules.push(\n+            `${promptFileInstructions}${\n+              categoryAction === \"label_archive\" ? \" and archive them\" : \"\"\n+            }.`,\n+          );\n+        }\n+      }\n+\n+      async function deleteRule(\n+        systemType: SystemType,\n+        emailAccountId: string,\n+      ) {\n+        const promise = async () => {\n+          const rule = await prisma.rule.findUnique({\n+            where: {\n+              emailAccountId_systemType: { emailAccountId, systemType },\n             },\n-          })\n-          .then(() => {})\n-          .catch((error) => {\n-            if (isDuplicateError(error, \"name\")) return;\n-            logger.error(\"Error creating rule\", { error });\n-            throw error;\n           });\n-        promises.push(promise);\n+          if (!rule) return;\n+          await prisma.rule.delete({ where: { id: rule.id } });\n+        };\n+        promises.push(promise());\n+      }\n \n-        rules.push(\n-          `${promptFileInstructions}${\n-            categoryAction === \"label_archive\" ? \" and archive them\" : \"\"\n-          }.`,\n+      // newsletter\n+      if (isSet(newsletter)) {\n+        createRule(\n+          RuleName.Newsletter,\n+          \"Newsletters: Regular content from publications, blogs, or services I've subscribed to\",\n+          \"Label all newsletters as 'Newsletter'\",\n+          false,\n+          newsletter,\n+          \"Newsletter\",\n+          SystemType.NEWSLETTER,\n+          email,\n         );\n+      } else {\n+        deleteRule(SystemType.NEWSLETTER, email);\n       }\n-    }\n \n-    async function deleteRule(systemType: SystemType, userId: string) {\n-      const promise = async () => {\n-        const rule = await prisma.rule.findUnique({\n-          where: { userId_systemType: { userId, systemType } },\n-        });\n-        if (!rule) return;\n-        await prisma.rule.delete({ where: { id: rule.id } });\n-      };\n-      promises.push(promise());\n-    }\n-\n-    // newsletter\n-    if (isSet(data.newsletter)) {\n-      createRule(\n-        RuleName.Newsletter,\n-        \"Newsletters: Regular content from publications, blogs, or services I've subscribed to\",\n-        \"Label all newsletters as 'Newsletter'\",\n-        false,\n-        data.newsletter,\n-        \"Newsletter\",\n-        SystemType.NEWSLETTER,\n-        userId,\n-      );\n-    } else {\n-      deleteRule(SystemType.NEWSLETTER, userId);\n-    }\n-\n-    // marketing\n-    if (isSet(data.marketing)) {\n-      createRule(\n-        RuleName.Marketing,\n-        \"Marketing: Promotional emails about products, services, sales, or offers\",\n-        \"Label all marketing emails as 'Marketing'\",\n-        false,\n-        data.marketing,\n-        \"Marketing\",\n-        SystemType.MARKETING,\n-        userId,\n-      );\n-    } else {\n-      deleteRule(SystemType.MARKETING, userId);\n-    }\n+      // marketing\n+      if (isSet(marketing)) {\n+        createRule(\n+          RuleName.Marketing,\n+          \"Marketing: Promotional emails about products, services, sales, or offers\",\n+          \"Label all marketing emails as 'Marketing'\",\n+          false,\n+          marketing,\n+          \"Marketing\",\n+          SystemType.MARKETING,\n+          email,\n+        );\n+      } else {\n+        deleteRule(SystemType.MARKETING, email);\n+      }\n ",
        "comment_created_at": "2025-04-23T11:39:51+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**`createRule(...)` & `deleteRule(...)` are async but never awaited**\n\nCalls such as `createRule(/* \u2026 */)` execute in the background; their internal\nPrisma operations are added to `promises` *after* the first await inside the\nfunction. `Promise.allSettled(promises)` may therefore resolve before those\noperations are enqueued, leading to lost updates.\n\nEither:\n\n1. Push the function promise itself:\n\n```diff\n-if (isSet(newsletter)) {\n-  createRule(/* \u2026 */);\n+if (isSet(newsletter)) {\n+  promises.push(createRule(/* \u2026 */));\n```\n\n2. Or `await` the helper directly.\n\nFailing to do so can leave onboarding in an inconsistent state.\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1986321506",
    "pr_number": 370,
    "pr_file": "apps/web/app/(app)/clean/use-email-stream.ts",
    "created_at": "2025-03-09T13:17:19+00:00",
    "commented_code": "+\"use client\";\n+\n+import keyBy from \"lodash/keyBy\";\n+import { useState, useEffect, useRef, useCallback, useMemo } from \"react\";\n+import type { CleanThread } from \"@/utils/redis/clean.types\";\n+\n+export function useEmailStream(\n+  initialPaused = false,\n+  initialThreads: CleanThread[] = [],\n+) {\n+  // Initialize emailsMap with sorted threads and proper dates\n+  const [emailsMap, setEmailsMap] = useState<Record<string, CleanThread>>(() =>\n+    createEmailMap(initialThreads),\n+  );\n+\n+  // Initialize emailOrder sorted by date (newest first)\n+  const [emailOrder, setEmailOrder] = useState<string[]>(() =>\n+    getSortedThreadIds(initialThreads),\n+  );\n+\n+  const [isPaused, setIsPaused] = useState(initialPaused);\n+  const eventSourceRef = useRef<EventSource | null>(null);\n+  const maxEmails = 1000; // Maximum emails to keep in the buffer\n+\n+  const connectToSSE = useCallback(() => {\n+    try {\n+      if (isPaused) {\n+        console.log(\"SSE paused - closing connection if exists\");\n+        if (eventSourceRef.current) {\n+          eventSourceRef.current.close();\n+          eventSourceRef.current = null;\n+        }\n+        return;\n+      }\n+\n+      if (eventSourceRef.current) {\n+        console.log(\"SSE connection already exists\");\n+        return;\n+      }\n+\n+      console.log(\"Connecting to SSE...\");\n+\n+      const eventSource = new EventSource(\"/api/email-stream\");\n+      eventSourceRef.current = eventSource;\n+\n+      console.log(\"SSE connection created\");\n+\n+      eventSource.onopen = () => {\n+        console.log(\"SSE connection opened\");\n+      };\n+\n+      // Handle thread events\n+      eventSource.addEventListener(\"thread\", (event) => {\n+        try {\n+          const threadData: CleanThread = JSON.parse(event.data);\n+          const thread = {\n+            ...threadData,\n+            date: new Date(threadData.date),\n+          };\n+\n+          setEmailsMap((prev) => {\n+            // If we're at the limit and this is a new email, remove the oldest one\n+            if (\n+              Object.keys(prev).length >= maxEmails &&\n+              !prev[thread.threadId]\n+            ) {\n+              const newMap = { ...prev };\n+              delete newMap[emailOrder[emailOrder.length - 1]];\n+              return {\n+                ...newMap,\n+                [thread.threadId]: thread,\n+              };\n+            }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1986321506",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 370,
        "pr_file": "apps/web/app/(app)/clean/use-email-stream.ts",
        "discussion_id": "1986321506",
        "commented_code": "@@ -0,0 +1,157 @@\n+\"use client\";\n+\n+import keyBy from \"lodash/keyBy\";\n+import { useState, useEffect, useRef, useCallback, useMemo } from \"react\";\n+import type { CleanThread } from \"@/utils/redis/clean.types\";\n+\n+export function useEmailStream(\n+  initialPaused = false,\n+  initialThreads: CleanThread[] = [],\n+) {\n+  // Initialize emailsMap with sorted threads and proper dates\n+  const [emailsMap, setEmailsMap] = useState<Record<string, CleanThread>>(() =>\n+    createEmailMap(initialThreads),\n+  );\n+\n+  // Initialize emailOrder sorted by date (newest first)\n+  const [emailOrder, setEmailOrder] = useState<string[]>(() =>\n+    getSortedThreadIds(initialThreads),\n+  );\n+\n+  const [isPaused, setIsPaused] = useState(initialPaused);\n+  const eventSourceRef = useRef<EventSource | null>(null);\n+  const maxEmails = 1000; // Maximum emails to keep in the buffer\n+\n+  const connectToSSE = useCallback(() => {\n+    try {\n+      if (isPaused) {\n+        console.log(\"SSE paused - closing connection if exists\");\n+        if (eventSourceRef.current) {\n+          eventSourceRef.current.close();\n+          eventSourceRef.current = null;\n+        }\n+        return;\n+      }\n+\n+      if (eventSourceRef.current) {\n+        console.log(\"SSE connection already exists\");\n+        return;\n+      }\n+\n+      console.log(\"Connecting to SSE...\");\n+\n+      const eventSource = new EventSource(\"/api/email-stream\");\n+      eventSourceRef.current = eventSource;\n+\n+      console.log(\"SSE connection created\");\n+\n+      eventSource.onopen = () => {\n+        console.log(\"SSE connection opened\");\n+      };\n+\n+      // Handle thread events\n+      eventSource.addEventListener(\"thread\", (event) => {\n+        try {\n+          const threadData: CleanThread = JSON.parse(event.data);\n+          const thread = {\n+            ...threadData,\n+            date: new Date(threadData.date),\n+          };\n+\n+          setEmailsMap((prev) => {\n+            // If we're at the limit and this is a new email, remove the oldest one\n+            if (\n+              Object.keys(prev).length >= maxEmails &&\n+              !prev[thread.threadId]\n+            ) {\n+              const newMap = { ...prev };\n+              delete newMap[emailOrder[emailOrder.length - 1]];\n+              return {\n+                ...newMap,\n+                [thread.threadId]: thread,\n+              };\n+            }",
        "comment_created_at": "2025-03-09T13:17:19+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Avoid stale references for `emailOrder`.**  \nWithin the `thread` event listener, you remove the oldest entry if the email limit is reached. However, relying on the closure-captured `emailOrder` might cause stale references if `emailOrder` changes after the callback is registered. An alternative is to reference the updated state or use functional state updates for both `emailsMap` and `emailOrder` to guarantee your updates remain in sync.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]