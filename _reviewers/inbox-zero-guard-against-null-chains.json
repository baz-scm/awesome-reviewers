[
  {
    "discussion_id": "2051699093",
    "pr_number": 410,
    "pr_file": "apps/web/utils/reply-tracker/enable.ts",
    "created_at": "2025-04-20T11:18:17+00:00",
    "commented_code": "import { createScopedLogger } from \"@/utils/logger\";\n import { RuleName } from \"@/utils/rule/consts\";\n \n-export async function enableReplyTracker(userId: string) {\n-  const logger = createScopedLogger(\"reply-tracker/enable\").with({ userId });\n-\n-  // If enabled already skip\n-  const existingRuleAction = await prisma.rule.findFirst({\n-    where: { userId, actions: { some: { type: ActionType.TRACK_THREAD } } },\n-  });\n-\n-  if (existingRuleAction) return { success: true, alreadyEnabled: true };\n+export async function enableReplyTracker({ email }: { email: string }) {\n+  const logger = createScopedLogger(\"reply-tracker/enable\").with({ email });\n \n   // Find existing reply required rule, make it track replies\n-  const user = await prisma.user.findUnique({\n-    where: { id: userId },\n+  const emailAccount = await prisma.emailAccount.findUnique({\n+    where: { email },\n     select: {\n-      id: true,\n+      userId: true,\n       email: true,\n       aiProvider: true,\n       aiModel: true,\n       aiApiKey: true,\n       about: true,\n       rulesPrompt: true,\n-      rules: {\n-        where: {\n-          systemType: SystemType.TO_REPLY,\n-        },\n+      user: {\n         select: {\n-          id: true,\n-          systemType: true,\n-          actions: {\n+          rules: {\n+            where: {\n+              systemType: SystemType.TO_REPLY,\n+            },\n             select: {\n               id: true,\n-              type: true,\n-              label: true,\n+              systemType: true,\n+              actions: {\n+                select: {\n+                  id: true,\n+                  type: true,\n+                  label: true,\n+                },\n+              },\n             },\n           },\n         },\n       },\n     },\n   });\n \n-  if (!user) return { error: \"User not found\" };\n+  // If enabled already skip\n+  if (!emailAccount) return { error: \"Email account not found\" };\n \n-  const rule = user.rules.find((r) => r.systemType === SystemType.TO_REPLY);\n+  const rule = emailAccount.user.rules.find(\n+    (r) => r.systemType === SystemType.TO_REPLY,\n+  );\n+\n+  if (rule?.actions.find((a) => a.type === ActionType.TRACK_THREAD)) {\n+    return { success: true, alreadyEnabled: true };\n+  }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2051699093",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 410,
        "pr_file": "apps/web/utils/reply-tracker/enable.ts",
        "discussion_id": "2051699093",
        "commented_code": "@@ -8,49 +8,53 @@ import {\n import { createScopedLogger } from \"@/utils/logger\";\n import { RuleName } from \"@/utils/rule/consts\";\n \n-export async function enableReplyTracker(userId: string) {\n-  const logger = createScopedLogger(\"reply-tracker/enable\").with({ userId });\n-\n-  // If enabled already skip\n-  const existingRuleAction = await prisma.rule.findFirst({\n-    where: { userId, actions: { some: { type: ActionType.TRACK_THREAD } } },\n-  });\n-\n-  if (existingRuleAction) return { success: true, alreadyEnabled: true };\n+export async function enableReplyTracker({ email }: { email: string }) {\n+  const logger = createScopedLogger(\"reply-tracker/enable\").with({ email });\n \n   // Find existing reply required rule, make it track replies\n-  const user = await prisma.user.findUnique({\n-    where: { id: userId },\n+  const emailAccount = await prisma.emailAccount.findUnique({\n+    where: { email },\n     select: {\n-      id: true,\n+      userId: true,\n       email: true,\n       aiProvider: true,\n       aiModel: true,\n       aiApiKey: true,\n       about: true,\n       rulesPrompt: true,\n-      rules: {\n-        where: {\n-          systemType: SystemType.TO_REPLY,\n-        },\n+      user: {\n         select: {\n-          id: true,\n-          systemType: true,\n-          actions: {\n+          rules: {\n+            where: {\n+              systemType: SystemType.TO_REPLY,\n+            },\n             select: {\n               id: true,\n-              type: true,\n-              label: true,\n+              systemType: true,\n+              actions: {\n+                select: {\n+                  id: true,\n+                  type: true,\n+                  label: true,\n+                },\n+              },\n             },\n           },\n         },\n       },\n     },\n   });\n \n-  if (!user) return { error: \"User not found\" };\n+  // If enabled already skip\n+  if (!emailAccount) return { error: \"Email account not found\" };\n \n-  const rule = user.rules.find((r) => r.systemType === SystemType.TO_REPLY);\n+  const rule = emailAccount.user.rules.find(\n+    (r) => r.systemType === SystemType.TO_REPLY,\n+  );\n+\n+  if (rule?.actions.find((a) => a.type === ActionType.TRACK_THREAD)) {\n+    return { success: true, alreadyEnabled: true };\n+  }",
        "comment_created_at": "2025-04-20T11:18:17+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Possible runtime crash when `emailAccount.user` is `null`.**\n\n`emailAccount.user` is optional in the `select`, yet `.rules` is accessed unguarded.  \nFor email accounts that are not linked to a `User` record (e.g., orphaned rows or future decoupling), this will throw.\n\n```diff\n-const rule = emailAccount.user.rules.find(\n-  (r) => r.systemType === SystemType.TO_REPLY,\n-);\n+if (!emailAccount.user) {\n+  logger.error(\"Email account has no linked user\", { email });\n+  return { error: \"User not found\" };\n+}\n+\n+const rule = emailAccount.user.rules.find(\n+  (r) => r.systemType === SystemType.TO_REPLY,\n+);\n```\n\nAdd the guard (and adjust return type) before dereferencing.  \n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  if (!emailAccount.user) {\n    logger.error(\"Email account has no linked user\", { email });\n    return { error: \"User not found\" };\n  }\n\n  const rule = emailAccount.user.rules.find(\n    (r) => r.systemType === SystemType.TO_REPLY,\n  );\n\n  if (rule?.actions.find((a) => a.type === ActionType.TRACK_THREAD)) {\n    return { success: true, alreadyEnabled: true };\n  }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2051830608",
    "pr_number": 412,
    "pr_file": "apps/web/app/api/resend/summary/route.ts",
    "created_at": "2025-04-20T23:20:29+00:00",
    "commented_code": "messagesCount: messageIds.length,\n   });\n \n-  const messages = user.accounts?.[0]?.access_token\n-    ? await getMessagesBatch(messageIds, user.accounts[0].access_token)\n+  const messages = user.account.access_token\n+    ? await getMessagesBatch(messageIds, user.account.access_token)\n     : [];",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2051830608",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 412,
        "pr_file": "apps/web/app/api/resend/summary/route.ts",
        "discussion_id": "2051830608",
        "commented_code": "@@ -163,8 +162,8 @@ async function sendEmail({ email, force }: { email: string; force?: boolean }) {\n     messagesCount: messageIds.length,\n   });\n \n-  const messages = user.accounts?.[0]?.access_token\n-    ? await getMessagesBatch(messageIds, user.accounts[0].access_token)\n+  const messages = user.account.access_token\n+    ? await getMessagesBatch(messageIds, user.account.access_token)\n     : [];",
        "comment_created_at": "2025-04-20T23:20:29+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Potential\u00a0`TypeError` when `account` is `null`**\n\n`user.account` can be `null` (e.g. Gmail disconnected).  \nAccessing `user.account.access_token` before the ternary guard will crash.\n\n```diff\n-const messages = user.account.access_token\n-  ? await getMessagesBatch(messageIds, user.account.access_token)\n-  : [];\n+const accessToken = user.account?.access_token;\n+const messages = accessToken\n+  ? await getMessagesBatch(messageIds, accessToken)\n+  : [];\n```\n\n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  const accessToken = user.account?.access_token;\n  const messages = accessToken\n    ? await getMessagesBatch(messageIds, accessToken)\n    : [];\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1918202565",
    "pr_number": 309,
    "pr_file": "apps/web/utils/actions/rule.ts",
    "created_at": "2025-01-16T10:24:43+00:00",
    "commented_code": "return { matches };\n   },\n );\n+\n+async function updatePromptFileOnUpdate(\n+  userId: string,\n+  currentRule: RuleWithRelations,\n+  updatedRule: RuleWithRelations,\n+) {\n+  const user = await prisma.user.findUnique({\n+    where: { id: userId },\n+    select: {\n+      email: true,\n+      aiModel: true,\n+      aiProvider: true,\n+      aiApiKey: true,\n+      rulesPrompt: true,\n+    },\n+  });\n+  if (!user) return { error: \"User not found\" };\n+\n+  const updatedPrompt = await generatePromptOnUpdateRule({\n+    user,\n+    existingPrompt: user.rulesPrompt || \"\",\n+    currentRule,\n+    updatedRule,\n+  });\n+\n+  await prisma.user.update({\n+    where: { id: userId },\n+    data: { rulesPrompt: updatedPrompt },\n+  });\n+}\n+\n+async function updateUserPrompt(userId: string, rulePrompt: string) {\n+  const user = await prisma.user.findUnique({\n+    where: { id: userId },\n+    select: { rulesPrompt: true },\n+  });\n+\n+  const updatedPrompt = `${user?.rulesPrompt || \"\"}\n\n* ${rulePrompt}.`.trim();\n+\n+  await prisma.user.update({\n+    where: { id: userId },\n+    data: { rulesPrompt: updatedPrompt },\n+  });\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1918202565",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 309,
        "pr_file": "apps/web/utils/actions/rule.ts",
        "discussion_id": "1918202565",
        "commented_code": "@@ -256,3 +340,47 @@\n     return { matches };\n   },\n );\n+\n+async function updatePromptFileOnUpdate(\n+  userId: string,\n+  currentRule: RuleWithRelations,\n+  updatedRule: RuleWithRelations,\n+) {\n+  const user = await prisma.user.findUnique({\n+    where: { id: userId },\n+    select: {\n+      email: true,\n+      aiModel: true,\n+      aiProvider: true,\n+      aiApiKey: true,\n+      rulesPrompt: true,\n+    },\n+  });\n+  if (!user) return { error: \"User not found\" };\n+\n+  const updatedPrompt = await generatePromptOnUpdateRule({\n+    user,\n+    existingPrompt: user.rulesPrompt || \"\",\n+    currentRule,\n+    updatedRule,\n+  });\n+\n+  await prisma.user.update({\n+    where: { id: userId },\n+    data: { rulesPrompt: updatedPrompt },\n+  });\n+}\n+\n+async function updateUserPrompt(userId: string, rulePrompt: string) {\n+  const user = await prisma.user.findUnique({\n+    where: { id: userId },\n+    select: { rulesPrompt: true },\n+  });\n+\n+  const updatedPrompt = `${user?.rulesPrompt || \"\"}\\n\\n* ${rulePrompt}.`.trim();\n+\n+  await prisma.user.update({\n+    where: { id: userId },\n+    data: { rulesPrompt: updatedPrompt },\n+  });\n+}",
        "comment_created_at": "2025-01-16T10:24:43+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Check for User Existence in `updateUserPrompt`**\n\nIn `updateUserPrompt`, if the user is not found, attempting to access `user?.rulesPrompt` may result in undefined behavior.\n\n\n\nAdd a check:\n\n```typescript\nif (!user) throw new Error(\"User not found\");\n```\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]