[
  {
    "discussion_id": "2127878688",
    "pr_number": 478,
    "pr_file": "apps/web/utils/ai/digest/summarize-email-for-digest.ts",
    "created_at": "2025-06-05T03:43:29+00:00",
    "commented_code": "+import { z } from \"zod\";\n+import { chatCompletionObject } from \"@/utils/llms\";\n+import type { EmailAccountWithAI } from \"@/utils/llms/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { EmailForLLM } from \"@/utils/types\";\n+import { stringifyEmailSimple } from \"@/utils/stringify-email\";\n+\n+const logger = createScopedLogger(\"summarize-email\");\n+\n+const schema = z.object({\n+  summary: z.string().nullish().describe(\"The summary of the email.\"),\n+});\n+export type AICheckResult = z.infer<typeof schema>;\n+\n+export async function aiSummarizeEmailForDigest({\n+  emailAccount,\n+  messageToSummarize,\n+}: {\n+  emailAccount: EmailAccountWithAI;\n+  messageToSummarize: EmailForLLM;\n+}): Promise<AICheckResult> {\n+  // If messageToSummarize somehow is null/undefined, default to null.\n+  if (!messageToSummarize) return { summary: null };\n+\n+  const userMessageForPrompt = messageToSummarize;\n+\n+  const system = \"You are an AI assistant that summarizes emails for a digest.\";\n+\n+  const prompt = `\n+\n+Summarize the following email for inclusion in a daily digest email.\n+\t\u2022\tUse a concise, professional format that is easy to scan.\n+\t\u2022\tChoose the most appropriate output style:\n+\t\u2022\tUse bullet points for general summaries with 2 ~ 4 key items.\n+\t\u2022\tUse an HTML table (with width=\"100%\") if the email includes any monetary values (e.g., $, \u20ac, \u00a3, R$).\n+\t\u2022\tUse a plain text paragraph if neither bullet points nor a table makes sense.\n+\t\u2022\tHighlight critical information using <strong> tags \u2014 such as amounts, dates, deadlines, quantities, order numbers, or payment methods.\n+\t\u2022\tDo not highlight labels or descriptions \u2014 only highlight the actual values.\n+\t\u2022\tEnsure tables are minimalist and email-friendly, with:\n+\t\u2022\tLeft-aligned header rows\n+\t\u2022\tNo unnecessary borders or visual clutter\n+\t\u2022\tOnly useful columns included (omit any unhelpful headers)\n+\t\u2022\tAlign the last column and its content to the right (especially for numeric or monetary values)\n+\t\u2022\tLimit each summary to the essentials: no more than 4 bullet points or 5 table rows.\n+\t\u2022\tOutput must be clean, valid HTML, ready for direct use in an email client.\n+\n+When summarizing receipts, invoices, or purchase confirmations:\n+\t\u2022\tAlways use a table layout, and include key fields like item, amount, date, and payment method.\n+\n+\n+<message>\n+${stringifyEmailSimple(userMessageForPrompt)}\n+</message>\n+`.trim();\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const aiResponse = await chatCompletionObject({\n+    userAi: emailAccount.user,\n+    system,\n+    prompt,\n+    schema,\n+    userEmail: emailAccount.email,\n+    usageLabel: \"Summarize email\",\n+  });\n+\n+  logger.trace(\"Result\", { response: aiResponse.object });\n+\n+  return aiResponse.object as AICheckResult;\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2127878688",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/ai/digest/summarize-email-for-digest.ts",
        "discussion_id": "2127878688",
        "commented_code": "@@ -0,0 +1,70 @@\n+import { z } from \"zod\";\n+import { chatCompletionObject } from \"@/utils/llms\";\n+import type { EmailAccountWithAI } from \"@/utils/llms/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { EmailForLLM } from \"@/utils/types\";\n+import { stringifyEmailSimple } from \"@/utils/stringify-email\";\n+\n+const logger = createScopedLogger(\"summarize-email\");\n+\n+const schema = z.object({\n+  summary: z.string().nullish().describe(\"The summary of the email.\"),\n+});\n+export type AICheckResult = z.infer<typeof schema>;\n+\n+export async function aiSummarizeEmailForDigest({\n+  emailAccount,\n+  messageToSummarize,\n+}: {\n+  emailAccount: EmailAccountWithAI;\n+  messageToSummarize: EmailForLLM;\n+}): Promise<AICheckResult> {\n+  // If messageToSummarize somehow is null/undefined, default to null.\n+  if (!messageToSummarize) return { summary: null };\n+\n+  const userMessageForPrompt = messageToSummarize;\n+\n+  const system = \"You are an AI assistant that summarizes emails for a digest.\";\n+\n+  const prompt = `\n+\n+Summarize the following email for inclusion in a daily digest email.\n+\t\u2022\tUse a concise, professional format that is easy to scan.\n+\t\u2022\tChoose the most appropriate output style:\n+\t\u2022\tUse bullet points for general summaries with 2 ~ 4 key items.\n+\t\u2022\tUse an HTML table (with width=\"100%\") if the email includes any monetary values (e.g., $, \u20ac, \u00a3, R$).\n+\t\u2022\tUse a plain text paragraph if neither bullet points nor a table makes sense.\n+\t\u2022\tHighlight critical information using <strong> tags \u2014 such as amounts, dates, deadlines, quantities, order numbers, or payment methods.\n+\t\u2022\tDo not highlight labels or descriptions \u2014 only highlight the actual values.\n+\t\u2022\tEnsure tables are minimalist and email-friendly, with:\n+\t\u2022\tLeft-aligned header rows\n+\t\u2022\tNo unnecessary borders or visual clutter\n+\t\u2022\tOnly useful columns included (omit any unhelpful headers)\n+\t\u2022\tAlign the last column and its content to the right (especially for numeric or monetary values)\n+\t\u2022\tLimit each summary to the essentials: no more than 4 bullet points or 5 table rows.\n+\t\u2022\tOutput must be clean, valid HTML, ready for direct use in an email client.\n+\n+When summarizing receipts, invoices, or purchase confirmations:\n+\t\u2022\tAlways use a table layout, and include key fields like item, amount, date, and payment method.\n+\n+\n+<message>\n+${stringifyEmailSimple(userMessageForPrompt)}\n+</message>\n+`.trim();\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const aiResponse = await chatCompletionObject({\n+    userAi: emailAccount.user,\n+    system,\n+    prompt,\n+    schema,\n+    userEmail: emailAccount.email,\n+    usageLabel: \"Summarize email\",\n+  });\n+\n+  logger.trace(\"Result\", { response: aiResponse.object });\n+\n+  return aiResponse.object as AICheckResult;\n+}",
        "comment_created_at": "2025-06-05T03:43:29+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Consider adding error handling for AI chat completion.**\n\nWhile the function has good logging, it should handle potential failures from the AI service more gracefully.\n\n\nApply this diff to add error handling:\n\n```diff\n-  const aiResponse = await chatCompletionObject({\n-    userAi: emailAccount.user,\n-    system,\n-    prompt,\n-    schema,\n-    userEmail: emailAccount.email,\n-    usageLabel: \"Summarize email\",\n-  });\n-\n-  logger.trace(\"Result\", { response: aiResponse.object });\n-\n-  return aiResponse.object as AICheckResult;\n+  try {\n+    const aiResponse = await chatCompletionObject({\n+      userAi: emailAccount.user,\n+      system,\n+      prompt,\n+      schema,\n+      userEmail: emailAccount.email,\n+      usageLabel: \"Summarize email\",\n+    });\n+\n+    logger.trace(\"Result\", { response: aiResponse.object });\n+\n+    return aiResponse.object as AICheckResult;\n+  } catch (error) {\n+    logger.error(\"Failed to summarize email\", { error });\n+    return { summary: null };\n+  }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  try {\n    const aiResponse = await chatCompletionObject({\n      userAi: emailAccount.user,\n      system,\n      prompt,\n      schema,\n      userEmail: emailAccount.email,\n      usageLabel: \"Summarize email\",\n    });\n\n    logger.trace(\"Result\", { response: aiResponse.object });\n\n    return aiResponse.object as AICheckResult;\n  } catch (error) {\n    logger.error(\"Failed to summarize email\", { error });\n    return { summary: null };\n  }\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/ai/digest/summarize-email-for-digest.ts around lines 58 to 70,\nthe call to chatCompletionObject lacks error handling, which could cause\nunhandled exceptions if the AI service fails. Wrap the await call in a try-catch\nblock to catch any errors, log the error details using logger.error, and handle\nthe failure gracefully, such as returning a default value or rethrowing a custom\nerror to maintain stability.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2049265525",
    "pr_number": 408,
    "pr_file": "apps/web/utils/ai/knowledge/writing-style.ts",
    "created_at": "2025-04-17T16:08:26+00:00",
    "commented_code": "+import { z } from \"zod\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { chatCompletionObject } from \"@/utils/llms\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { EmailForLLM } from \"@/utils/types\";\n+import { truncate } from \"@/utils/string\";\n+import { removeExcessiveWhitespace } from \"@/utils/string\";\n+\n+const logger = createScopedLogger(\"writing-style-analyzer\");\n+\n+export const schema = z.object({\n+  typicalLength: z.string(),\n+  formality: z.string(),\n+  commonGreeting: z.string(),\n+  notableTraits: z.array(z.string()),\n+  examples: z.array(z.string()),\n+});\n+\n+export async function aiAnalyzeWritingStyle(options: {\n+  emails: EmailForLLM[];\n+  user: UserEmailWithAI;\n+}) {\n+  const { emails, user } = options;\n+\n+  if (!emails.length) {\n+    logger.warn(\"No emails provided for writing style analysis\");\n+    return null;\n+  }\n+\n+  const system = `You are a writing style analyst specializing in email communication patterns.\n+\n+Analyze the user's writing style based on their previously sent emails. Examine the collection of emails to identify patterns in their communication style and create a personalized style guide with the following elements:\n+\n+- Typical Length: Determine the average length of their emails (e.g., number of sentences or paragraphs).\n+\n+- Formality: Assess whether their writing style is formal, informal, or mixed, with specific examples of indicators.\n+\n+- Common Greeting: Identify their standard opening greeting pattern, if any. Also note if the user often skips a greeting and gets straight to the point.\n+Example output:\n+\"Hey,\" or none (sometimes just starts with content or a single word).\"\n+Explicitly mention if the user often skips a greeting.\n+\n+- Notable Traits: List distinctive writing characteristics such as punctuation habits, question usage, paragraph structure, or language preferences. Include traits such as:\n+  - Frequent use of contractions\n+  - Beginning sentences with conjunctions\n+  - Concise direct responses\n+  - Use of exclamation points\n+  - Minimal closings\n+  - Omitting subjects\n+  - Using abbreviations\n+  - Including personal context\n+  - Addressing multiple points with line breaks\n+  - Using parenthetical asides\n+  - Consider the use of emoticons.\n+\n+- Examples: Include 2-3 representative examples of the user's actual writing style, including sentences or short paragraphs extracted from their emails that best showcase their typical writing patterns.\n+\n+Provide this analysis in a structured format that serves as a personalized email style guide for the user.`;\n+\n+  const prompt = `Here are the emails I've sent previously. Please analyze my writing style:\n+<emails>\n+${emails\n+  .map(\n+    (e) => `<email>\n+  <to>${e.to}</to>\n+  <body>${truncate(removeExcessiveWhitespace(e.content), 1000)}</body>\n+</email>`,\n+  )\n+  .join(\"\n\")}\n+</emails>\n+\n+${\n+  user.about\n+    ? `Some additional information about the user:\n+<user_info>${user.about}</user_info>`\n+    : \"\"\n+}`;\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const result = await chatCompletionObject({\n+    userAi: user,\n+    system,\n+    prompt,\n+    schema,\n+    userEmail: user.email,\n+    usageLabel: \"Writing Style Analysis\",\n+  });\n+\n+  logger.trace(\"Output\", { result });\n+\n+  return result.object;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2049265525",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 408,
        "pr_file": "apps/web/utils/ai/knowledge/writing-style.ts",
        "discussion_id": "2049265525",
        "commented_code": "@@ -0,0 +1,93 @@\n+import { z } from \"zod\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { chatCompletionObject } from \"@/utils/llms\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { EmailForLLM } from \"@/utils/types\";\n+import { truncate } from \"@/utils/string\";\n+import { removeExcessiveWhitespace } from \"@/utils/string\";\n+\n+const logger = createScopedLogger(\"writing-style-analyzer\");\n+\n+export const schema = z.object({\n+  typicalLength: z.string(),\n+  formality: z.string(),\n+  commonGreeting: z.string(),\n+  notableTraits: z.array(z.string()),\n+  examples: z.array(z.string()),\n+});\n+\n+export async function aiAnalyzeWritingStyle(options: {\n+  emails: EmailForLLM[];\n+  user: UserEmailWithAI;\n+}) {\n+  const { emails, user } = options;\n+\n+  if (!emails.length) {\n+    logger.warn(\"No emails provided for writing style analysis\");\n+    return null;\n+  }\n+\n+  const system = `You are a writing style analyst specializing in email communication patterns.\n+\n+Analyze the user's writing style based on their previously sent emails. Examine the collection of emails to identify patterns in their communication style and create a personalized style guide with the following elements:\n+\n+- Typical Length: Determine the average length of their emails (e.g., number of sentences or paragraphs).\n+\n+- Formality: Assess whether their writing style is formal, informal, or mixed, with specific examples of indicators.\n+\n+- Common Greeting: Identify their standard opening greeting pattern, if any. Also note if the user often skips a greeting and gets straight to the point.\n+Example output:\n+\"Hey,\" or none (sometimes just starts with content or a single word).\"\n+Explicitly mention if the user often skips a greeting.\n+\n+- Notable Traits: List distinctive writing characteristics such as punctuation habits, question usage, paragraph structure, or language preferences. Include traits such as:\n+  - Frequent use of contractions\n+  - Beginning sentences with conjunctions\n+  - Concise direct responses\n+  - Use of exclamation points\n+  - Minimal closings\n+  - Omitting subjects\n+  - Using abbreviations\n+  - Including personal context\n+  - Addressing multiple points with line breaks\n+  - Using parenthetical asides\n+  - Consider the use of emoticons.\n+\n+- Examples: Include 2-3 representative examples of the user's actual writing style, including sentences or short paragraphs extracted from their emails that best showcase their typical writing patterns.\n+\n+Provide this analysis in a structured format that serves as a personalized email style guide for the user.`;\n+\n+  const prompt = `Here are the emails I've sent previously. Please analyze my writing style:\n+<emails>\n+${emails\n+  .map(\n+    (e) => `<email>\n+  <to>${e.to}</to>\n+  <body>${truncate(removeExcessiveWhitespace(e.content), 1000)}</body>\n+</email>`,\n+  )\n+  .join(\"\\n\")}\n+</emails>\n+\n+${\n+  user.about\n+    ? `Some additional information about the user:\n+<user_info>${user.about}</user_info>`\n+    : \"\"\n+}`;\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const result = await chatCompletionObject({\n+    userAi: user,\n+    system,\n+    prompt,\n+    schema,\n+    userEmail: user.email,\n+    usageLabel: \"Writing Style Analysis\",\n+  });\n+\n+  logger.trace(\"Output\", { result });\n+\n+  return result.object;",
        "comment_created_at": "2025-04-17T16:08:26+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Consider adding error handling for AI completion failures.**\n\nThe function doesn't handle potential errors from the `chatCompletionObject` call. If the AI service fails, this could result in unhandled exceptions.\n\n\n```diff\n- const result = await chatCompletionObject({\n+ try {\n+   const result = await chatCompletionObject({\n     userAi: user,\n     system,\n     prompt,\n     schema,\n     userEmail: user.email,\n     usageLabel: \"Writing Style Analysis\",\n   });\n+   \n+   logger.trace(\"Output\", { result });\n+   \n+   return result.object;\n+ } catch (error) {\n+   logger.error(\"Error analyzing writing style\", { error });\n+   return null;\n+ }\n-\n- logger.trace(\"Output\", { result });\n-\n- return result.object;\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  try {\n    const result = await chatCompletionObject({\n      userAi: user,\n      system,\n      prompt,\n      schema,\n      userEmail: user.email,\n      usageLabel: \"Writing Style Analysis\",\n    });\n    \n    logger.trace(\"Output\", { result });\n    \n    return result.object;\n  } catch (error) {\n    logger.error(\"Error analyzing writing style\", { error });\n    return null;\n  }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1949004296",
    "pr_number": 330,
    "pr_file": "apps/web/utils/actions/generate-reply.ts",
    "created_at": "2025-02-10T12:53:08+00:00",
    "commented_code": "+\"use server\";\n+\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import {\n+  generateReplySchema,\n+  type GenerateReplySchema,\n+} from \"@/utils/actions/generate-reply.validation\";\n+import { withActionInstrumentation } from \"@/utils/actions/middleware\";\n+import { aiGenerateNudge } from \"@/utils/ai/reply/generate-nudge\";\n+import { aiGenerateReply } from \"@/utils/ai/reply/generate-reply\";\n+import { emailToContent } from \"@/utils/mail\";\n+import { getReply, saveReply } from \"@/utils/redis/reply\";\n+import { getAiUserByEmail } from \"@/utils/user/get\";\n+\n+export const generateNudgeAction = withActionInstrumentation(\n+  \"generateNudge\",\n+  async (unsafeData: GenerateReplySchema) => {\n+    const session = await auth();\n+    if (!session?.user.email) return { error: \"Not authenticated\" };\n+\n+    const user = await getAiUserByEmail({ email: session.user.email });\n+\n+    if (!user) return { error: \"User not found\" };\n+\n+    const { data, error } = generateReplySchema.safeParse(unsafeData);\n+    if (error) return { error: error.message };\n+\n+    const lastMessage = data.messages.at(-1);\n+\n+    if (!lastMessage) return { error: \"No message provided\" };\n+\n+    const messages = data.messages.map((msg) => ({\n+      ...msg,\n+      date: new Date(msg.date),\n+      content: emailToContent({\n+        textPlain: msg.textPlain,\n+        textHtml: msg.textHtml,\n+        snippet: \"\",\n+      }),\n+    }));\n+\n+    const text = await aiGenerateNudge({ messages, user });\n+",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1949004296",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 330,
        "pr_file": "apps/web/utils/actions/generate-reply.ts",
        "discussion_id": "1949004296",
        "commented_code": "@@ -0,0 +1,92 @@\n+\"use server\";\n+\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import {\n+  generateReplySchema,\n+  type GenerateReplySchema,\n+} from \"@/utils/actions/generate-reply.validation\";\n+import { withActionInstrumentation } from \"@/utils/actions/middleware\";\n+import { aiGenerateNudge } from \"@/utils/ai/reply/generate-nudge\";\n+import { aiGenerateReply } from \"@/utils/ai/reply/generate-reply\";\n+import { emailToContent } from \"@/utils/mail\";\n+import { getReply, saveReply } from \"@/utils/redis/reply\";\n+import { getAiUserByEmail } from \"@/utils/user/get\";\n+\n+export const generateNudgeAction = withActionInstrumentation(\n+  \"generateNudge\",\n+  async (unsafeData: GenerateReplySchema) => {\n+    const session = await auth();\n+    if (!session?.user.email) return { error: \"Not authenticated\" };\n+\n+    const user = await getAiUserByEmail({ email: session.user.email });\n+\n+    if (!user) return { error: \"User not found\" };\n+\n+    const { data, error } = generateReplySchema.safeParse(unsafeData);\n+    if (error) return { error: error.message };\n+\n+    const lastMessage = data.messages.at(-1);\n+\n+    if (!lastMessage) return { error: \"No message provided\" };\n+\n+    const messages = data.messages.map((msg) => ({\n+      ...msg,\n+      date: new Date(msg.date),\n+      content: emailToContent({\n+        textPlain: msg.textPlain,\n+        textHtml: msg.textHtml,\n+        snippet: \"\",\n+      }),\n+    }));\n+\n+    const text = await aiGenerateNudge({ messages, user });\n+",
        "comment_created_at": "2025-02-10T12:53:08+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Add error handling for AI generation calls.**\n\nThe AI generation calls (`aiGenerateNudge` and `aiGenerateReply`) should be wrapped in try-catch blocks to handle potential failures gracefully.\n\nApply this diff to add error handling:\n\n```diff\n-    const text = await aiGenerateNudge({ messages, user });\n-    return { text };\n+    try {\n+      const text = await aiGenerateNudge({ messages, user });\n+      return { text };\n+    } catch (error) {\n+      console.error(\"Failed to generate nudge:\", error);\n+      return { error: \"Failed to generate nudge. Please try again.\" };\n+    }\n\n-    const text = await aiGenerateReply({ messages, user });\n+    try {\n+      const text = await aiGenerateReply({ messages, user });\n+    } catch (error) {\n+      console.error(\"Failed to generate reply:\", error);\n+      return { error: \"Failed to generate reply. Please try again.\" };\n+    }\n```\n\n\nAlso applies to: 82-83\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861459273",
    "pr_number": 263,
    "pr_file": "apps/web/utils/actions/ai-rule.ts",
    "created_at": "2024-11-28T03:20:45+00:00",
    "commented_code": "!diff.editedRules.length &&\n         !diff.removedRules.length\n       ) {\n-        console.log(\"No changes detected in rules, returning early\");\n+        logger.info(\"No changes detected in rules, returning early\");\n         return { createdRules: 0, editedRules: 0, removedRules: 0 };\n       }\n \n       if (diff.addedRules.length) {\n-        console.log(\"Processing added rules\");\n+        logger.info(\"Processing added rules\");\n         addedRules = await aiPromptToRules({\n           user: { ...user, email: user.email },\n           promptFile: diff.addedRules.join(\"\n\n\"),\n           isEditing: false,\n         });\n-        console.log(`${addedRules?.length || 0} rules to be added`);\n+        logger.info(`${addedRules?.length || 0} rules to be added`);",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1861459273",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 263,
        "pr_file": "apps/web/utils/actions/ai-rule.ts",
        "discussion_id": "1861459273",
        "commented_code": "@@ -571,26 +584,26 @@ export const saveRulesPromptAction = withActionInstrumentation(\n         !diff.editedRules.length &&\n         !diff.removedRules.length\n       ) {\n-        console.log(\"No changes detected in rules, returning early\");\n+        logger.info(\"No changes detected in rules, returning early\");\n         return { createdRules: 0, editedRules: 0, removedRules: 0 };\n       }\n \n       if (diff.addedRules.length) {\n-        console.log(\"Processing added rules\");\n+        logger.info(\"Processing added rules\");\n         addedRules = await aiPromptToRules({\n           user: { ...user, email: user.email },\n           promptFile: diff.addedRules.join(\"\\n\\n\"),\n           isEditing: false,\n         });\n-        console.log(`${addedRules?.length || 0} rules to be added`);\n+        logger.info(`${addedRules?.length || 0} rules to be added`);",
        "comment_created_at": "2024-11-28T03:20:45+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Add error handling for AI operations**\n\nThe AI operations (aiPromptToRules) lack proper error handling. Consider wrapping these calls in try-catch blocks and handling potential AI-related errors gracefully.\n\n```diff\n+try {\n   logger.info(\"Processing added rules\");\n   addedRules = await aiPromptToRules({\n     user: { ...user, email: user.email },\n     promptFile: diff.addedRules.join(\"\\n\\n\"),\n     isEditing: false,\n   });\n   logger.info(`${addedRules?.length || 0} rules to be added`);\n+} catch (error) {\n+  logger.error(\"Error processing rules with AI\", {\n+    error: error instanceof Error ? error.message : error,\n+  });\n+  return { error: \"Failed to process rules with AI\" };\n+}\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n        try {\n          logger.info(\"Processing added rules\");\n          addedRules = await aiPromptToRules({\n            user: { ...user, email: user.email },\n            promptFile: diff.addedRules.join(\"\\n\\n\"),\n            isEditing: false,\n          });\n          logger.info(`${addedRules?.length || 0} rules to be added`);\n        } catch (error) {\n          logger.error(\"Error processing rules with AI\", {\n            error: error instanceof Error ? error.message : error,\n          });\n          return { error: \"Failed to process rules with AI\" };\n        }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]