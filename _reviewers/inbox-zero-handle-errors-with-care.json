[
  {
    "discussion_id": "1948918007",
    "pr_number": 330,
    "pr_file": "apps/web/app/api/ai/reply/nudge/route.ts",
    "created_at": "2025-02-10T11:49:57+00:00",
    "commented_code": "+import { z } from \"zod\";\n+import { NextResponse } from \"next/server\";\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import { withError } from \"@/utils/middleware\";\n+import { aiGenerateNudge } from \"@/utils/ai/reply/generate-nudge\";\n+import { getAiUserByEmail } from \"@/utils/user/get\";\n+import { emailToContent } from \"@/utils/mail\";\n+\n+const messageSchema = z\n+  .object({\n+    id: z.string(),\n+    from: z.string(),\n+    to: z.string(),\n+    subject: z.string(),\n+    textPlain: z.string().optional(),\n+    textHtml: z.string().optional(),\n+    date: z.string(),\n+  })\n+  .refine((data) => data.textPlain || data.textHtml, {\n+    message: \"At least one of textPlain or textHtml is required\",\n+  });\n+\n+const generateReplyBody = z.object({\n+  messages: z.array(messageSchema),\n+});\n+\n+export type GenerateReplyBody = z.infer<typeof generateReplyBody>;\n+\n+export const POST = withError(async (request: Request) => {\n+  const session = await auth();\n+  if (!session?.user.email)\n+    return NextResponse.json({ error: \"Not authenticated\" });\n+\n+  const user = await getAiUserByEmail({ email: session.user.email });\n+\n+  if (!user) return NextResponse.json({ error: \"User not found\" });\n+",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1948918007",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 330,
        "pr_file": "apps/web/app/api/ai/reply/nudge/route.ts",
        "discussion_id": "1948918007",
        "commented_code": "@@ -0,0 +1,59 @@\n+import { z } from \"zod\";\n+import { NextResponse } from \"next/server\";\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import { withError } from \"@/utils/middleware\";\n+import { aiGenerateNudge } from \"@/utils/ai/reply/generate-nudge\";\n+import { getAiUserByEmail } from \"@/utils/user/get\";\n+import { emailToContent } from \"@/utils/mail\";\n+\n+const messageSchema = z\n+  .object({\n+    id: z.string(),\n+    from: z.string(),\n+    to: z.string(),\n+    subject: z.string(),\n+    textPlain: z.string().optional(),\n+    textHtml: z.string().optional(),\n+    date: z.string(),\n+  })\n+  .refine((data) => data.textPlain || data.textHtml, {\n+    message: \"At least one of textPlain or textHtml is required\",\n+  });\n+\n+const generateReplyBody = z.object({\n+  messages: z.array(messageSchema),\n+});\n+\n+export type GenerateReplyBody = z.infer<typeof generateReplyBody>;\n+\n+export const POST = withError(async (request: Request) => {\n+  const session = await auth();\n+  if (!session?.user.email)\n+    return NextResponse.json({ error: \"Not authenticated\" });\n+\n+  const user = await getAiUserByEmail({ email: session.user.email });\n+\n+  if (!user) return NextResponse.json({ error: \"User not found\" });\n+",
        "comment_created_at": "2025-02-10T11:49:57+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Add proper error handling for database operations.**\n\nThe `getAiUserByEmail` call should be wrapped in a try-catch block to handle potential database errors.\n\n```diff\n+  try {\n     const user = await getAiUserByEmail({ email: session.user.email });\n     if (!user) return NextResponse.json(\n       { error: \"User not found\" },\n       { status: 404 }\n     );\n+  } catch (error) {\n+    logger.error(\"Database error\", { error });\n+    return NextResponse.json(\n+      { error: \"Internal server error\" },\n+      { status: 500 }\n+    );\n+  }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  try {\n    const user = await getAiUserByEmail({ email: session.user.email });\n    if (!user)\n      return NextResponse.json(\n        { error: \"User not found\" },\n        { status: 404 }\n      );\n  } catch (error) {\n    logger.error(\"Database error\", { error });\n    return NextResponse.json(\n      { error: \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945525285",
    "pr_number": 324,
    "pr_file": "apps/web/utils/gmail/mail.ts",
    "created_at": "2025-02-06T21:50:28+00:00",
    "commented_code": "// https://developers.google.com/gmail/api/guides/sending\n // https://www.labnol.org/google-api-service-account-220405\n-export async function sendEmail(\n+export async function sendEmailWithHtml(\n   gmail: gmail_v1.Gmail,\n   body: SendEmailBody,\n   from?: string,\n ) {\n-  const raw = await createRawMailMessage(body, from);\n+  let messageText: string;\n+\n+  try {\n+    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n+  } catch (error) {\n+    logger.error(\"Error converting email html to text\", { error });\n+    messageText = body.messageHtml;\n+    // throw error;\n+  }\n \n+  const raw = await createRawMailMessage({ ...body, messageText }, from);\n   const result = await gmail.users.messages.send({\n     userId: \"me\",\n     requestBody: {\n       threadId: body.replyToEmail ? body.replyToEmail.threadId : undefined,\n       raw,\n     },\n   });\n-\n   return result;\n }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1945525285",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 324,
        "pr_file": "apps/web/utils/gmail/mail.ts",
        "discussion_id": "1945525285",
        "commented_code": "@@ -84,24 +96,41 @@ const createRawMailMessage = async (\n \n // https://developers.google.com/gmail/api/guides/sending\n // https://www.labnol.org/google-api-service-account-220405\n-export async function sendEmail(\n+export async function sendEmailWithHtml(\n   gmail: gmail_v1.Gmail,\n   body: SendEmailBody,\n   from?: string,\n ) {\n-  const raw = await createRawMailMessage(body, from);\n+  let messageText: string;\n+\n+  try {\n+    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n+  } catch (error) {\n+    logger.error(\"Error converting email html to text\", { error });\n+    messageText = body.messageHtml;\n+    // throw error;\n+  }\n \n+  const raw = await createRawMailMessage({ ...body, messageText }, from);\n   const result = await gmail.users.messages.send({\n     userId: \"me\",\n     requestBody: {\n       threadId: body.replyToEmail ? body.replyToEmail.threadId : undefined,\n       raw,\n     },\n   });\n-\n   return result;\n }",
        "comment_created_at": "2025-02-06T21:50:28+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Improve error handling in HTML to text conversion.**\n\nThe function swallows the error and falls back to using HTML as text, which could result in poor user experience.\n\nConsider this approach:\n\n```diff\n-  try {\n-    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n-  } catch (error) {\n-    logger.error(\"Error converting email html to text\", { error });\n-    messageText = body.messageHtml;\n-    // throw error;\n-  }\n+  try {\n+    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n+  } catch (error) {\n+    logger.error(\"Error converting email html to text\", { error });\n+    // Strip HTML tags as a fallback\n+    messageText = body.messageHtml.replace(/<[^>]*>/g, '');\n+  }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n// https://developers.google.com/gmail/api/guides/sending\n// https://www.labnol.org/google-api-service-account-220405\nexport async function sendEmailWithHtml(\n  gmail: gmail_v1.Gmail,\n  body: SendEmailBody,\n  from?: string,\n) {\n  let messageText: string;\n\n  try {\n    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n  } catch (error) {\n    logger.error(\"Error converting email html to text\", { error });\n    // Strip HTML tags as a fallback\n    messageText = body.messageHtml.replace(/<[^>]*>/g, '');\n  }\n\n  const raw = await createRawMailMessage({ ...body, messageText }, from);\n  const result = await gmail.users.messages.send({\n    userId: \"me\",\n    requestBody: {\n      threadId: body.replyToEmail ? body.replyToEmail.threadId : undefined,\n      raw,\n    },\n  });\n  return result;\n}\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1942990862",
    "pr_number": 323,
    "pr_file": "apps/web/utils/reply-tracker/check-previous-emails.ts",
    "created_at": "2025-02-05T13:56:10+00:00",
    "commented_code": "+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import groupBy from \"lodash/groupBy\";\n+import { getMessages } from \"@/utils/gmail/message\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { getThreadMessages } from \"@/utils/gmail/thread\";\n+import { GmailLabel } from \"@/utils/gmail/label\";\n+import { handleOutboundReply } from \"@/utils/reply-tracker/outbound\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { User } from \"@prisma/client\";\n+\n+const logger = createScopedLogger(\"reply-tracker/check-previous-emails\");\n+\n+export async function processPreviousSentEmails(\n+  gmail: gmail_v1.Gmail,\n+  user: Pick<User, \"id\" | \"about\"> & UserEmailWithAI,\n+  maxResults = 20,\n+) {\n+  // Get last sent messages\n+  const result = await getMessages(gmail, { query: \"in:sent\", maxResults });\n+\n+  if (!result.messages) {\n+    logger.info(\"No sent messages found\");\n+    return;\n+  }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1942990862",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 323,
        "pr_file": "apps/web/utils/reply-tracker/check-previous-emails.ts",
        "discussion_id": "1942990862",
        "commented_code": "@@ -0,0 +1,63 @@\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import groupBy from \"lodash/groupBy\";\n+import { getMessages } from \"@/utils/gmail/message\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { getThreadMessages } from \"@/utils/gmail/thread\";\n+import { GmailLabel } from \"@/utils/gmail/label\";\n+import { handleOutboundReply } from \"@/utils/reply-tracker/outbound\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { User } from \"@prisma/client\";\n+\n+const logger = createScopedLogger(\"reply-tracker/check-previous-emails\");\n+\n+export async function processPreviousSentEmails(\n+  gmail: gmail_v1.Gmail,\n+  user: Pick<User, \"id\" | \"about\"> & UserEmailWithAI,\n+  maxResults = 20,\n+) {\n+  // Get last sent messages\n+  const result = await getMessages(gmail, { query: \"in:sent\", maxResults });\n+\n+  if (!result.messages) {\n+    logger.info(\"No sent messages found\");\n+    return;\n+  }",
        "comment_created_at": "2025-02-05T13:56:10+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Consider adding error handling for Gmail API calls.**\n\nThe Gmail API call could fail, but there's no explicit error handling.\n\n```diff\n-  const result = await getMessages(gmail, { query: \"in:sent\", maxResults });\n+  try {\n+    const result = await getMessages(gmail, { query: \"in:sent\", maxResults });\n+    if (!result.messages) {\n+      logger.info(\"No sent messages found\");\n+      return;\n+    }\n+  } catch (error) {\n+    logger.error(\"Failed to fetch sent messages\", { error });\n+    return;\n+  }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  // Get last sent messages\n  try {\n    const result = await getMessages(gmail, { query: \"in:sent\", maxResults });\n    if (!result.messages) {\n      logger.info(\"No sent messages found\");\n      return;\n    }\n  } catch (error) {\n    logger.error(\"Failed to fetch sent messages\", { error });\n    return;\n  }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1942990871",
    "pr_number": 323,
    "pr_file": "apps/web/utils/actions/reply-tracking.ts",
    "created_at": "2025-02-05T13:56:11+00:00",
    "commented_code": "revalidatePath(\"/reply-tracker\");\n \n+    // Reply tracker has now been enabled\n+    // Now run it over the previous 20 sent emails\n+    const gmail = getGmailClient({ accessToken: session.accessToken });\n+    await processPreviousSentEmails(gmail, user);\n+\n+    revalidatePath(\"/reply-tracker\");",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1942990871",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 323,
        "pr_file": "apps/web/utils/actions/reply-tracking.ts",
        "discussion_id": "1942990871",
        "commented_code": "@@ -151,6 +155,13 @@ export const enableReplyTrackerAction = withActionInstrumentation(\n \n     revalidatePath(\"/reply-tracker\");\n \n+    // Reply tracker has now been enabled\n+    // Now run it over the previous 20 sent emails\n+    const gmail = getGmailClient({ accessToken: session.accessToken });\n+    await processPreviousSentEmails(gmail, user);\n+\n+    revalidatePath(\"/reply-tracker\");",
        "comment_created_at": "2025-02-05T13:56:11+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Consider handling Gmail client initialization failures.**\n\nThe Gmail client initialization and email processing could fail, but there's no error handling.\n\n```diff\n-    const gmail = getGmailClient({ accessToken: session.accessToken });\n-    await processPreviousSentEmails(gmail, user);\n+    try {\n+      const gmail = getGmailClient({ accessToken: session.accessToken });\n+      await processPreviousSentEmails(gmail, user);\n+    } catch (error) {\n+      logger.error(\"Failed to process previous emails\", { error });\n+      // Don't return error as the reply tracker is already enabled\n+    }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n    // Reply tracker has now been enabled\n    // Now run it over the previous 20 sent emails\n    try {\n      const gmail = getGmailClient({ accessToken: session.accessToken });\n      await processPreviousSentEmails(gmail, user);\n    } catch (error) {\n      logger.error(\"Failed to process previous emails\", { error });\n      // Don't return error as the reply tracker is already enabled\n    }\n\n    revalidatePath(\"/reply-tracker\");\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1941515566",
    "pr_number": 321,
    "pr_file": "apps/web/app/api/unsubscribe/route.ts",
    "created_at": "2025-02-04T16:31:59+00:00",
    "commented_code": "+import { z } from \"zod\";\n+import { NextResponse } from \"next/server\";\n+import { withError } from \"@/utils/middleware\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { Frequency } from \"@prisma/client\";\n+\n+const logger = createScopedLogger(\"unsubscribe\");\n+\n+const unsubscribeBody = z.object({ token: z.string() });\n+\n+export const POST = withError(async (request: Request) => {\n+  const json = await request.json();\n+  const { token } = unsubscribeBody.parse(json);\n+\n+  // Find and validate token\n+  const emailToken = await prisma.emailToken.findUnique({\n+    where: { token },\n+    include: { user: true },\n+  });\n+\n+  if (!emailToken) {\n+    return NextResponse.json({ error: \"Invalid token\" }, { status: 400 });\n+  }\n+\n+  if (emailToken.expiresAt < new Date()) {\n+    return NextResponse.json({ error: \"Token expired\" }, { status: 400 });\n+  }\n+\n+  // Update user preferences\n+\n+  const [userUpdate, tokenDelete] = await Promise.allSettled([\n+    prisma.user.update({\n+      where: { id: emailToken.userId },\n+      data: {\n+        summaryEmailFrequency: Frequency.NEVER,\n+        statsEmailFrequency: Frequency.NEVER,\n+      },\n+    }),\n+\n+    // Delete the used token\n+    prisma.emailToken.delete({ where: { id: emailToken.id } }),\n+  ]);\n+\n+  if (userUpdate.status === \"rejected\") {\n+    logger.error(\"Error updating user preferences\", {\n+      email: emailToken.user.email,\n+      error: userUpdate.reason,\n+    });\n+  }\n+\n+  if (tokenDelete.status === \"rejected\") {\n+    logger.error(\"Error deleting token\", {\n+      email: emailToken.user.email,\n+      tokenId: emailToken.id,\n+      error: tokenDelete.reason,\n+    });\n+  }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1941515566",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 321,
        "pr_file": "apps/web/app/api/unsubscribe/route.ts",
        "discussion_id": "1941515566",
        "commented_code": "@@ -0,0 +1,66 @@\n+import { z } from \"zod\";\n+import { NextResponse } from \"next/server\";\n+import { withError } from \"@/utils/middleware\";\n+import prisma from \"@/utils/prisma\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { Frequency } from \"@prisma/client\";\n+\n+const logger = createScopedLogger(\"unsubscribe\");\n+\n+const unsubscribeBody = z.object({ token: z.string() });\n+\n+export const POST = withError(async (request: Request) => {\n+  const json = await request.json();\n+  const { token } = unsubscribeBody.parse(json);\n+\n+  // Find and validate token\n+  const emailToken = await prisma.emailToken.findUnique({\n+    where: { token },\n+    include: { user: true },\n+  });\n+\n+  if (!emailToken) {\n+    return NextResponse.json({ error: \"Invalid token\" }, { status: 400 });\n+  }\n+\n+  if (emailToken.expiresAt < new Date()) {\n+    return NextResponse.json({ error: \"Token expired\" }, { status: 400 });\n+  }\n+\n+  // Update user preferences\n+\n+  const [userUpdate, tokenDelete] = await Promise.allSettled([\n+    prisma.user.update({\n+      where: { id: emailToken.userId },\n+      data: {\n+        summaryEmailFrequency: Frequency.NEVER,\n+        statsEmailFrequency: Frequency.NEVER,\n+      },\n+    }),\n+\n+    // Delete the used token\n+    prisma.emailToken.delete({ where: { id: emailToken.id } }),\n+  ]);\n+\n+  if (userUpdate.status === \"rejected\") {\n+    logger.error(\"Error updating user preferences\", {\n+      email: emailToken.user.email,\n+      error: userUpdate.reason,\n+    });\n+  }\n+\n+  if (tokenDelete.status === \"rejected\") {\n+    logger.error(\"Error deleting token\", {\n+      email: emailToken.user.email,\n+      tokenId: emailToken.id,\n+      error: tokenDelete.reason,\n+    });\n+  }",
        "comment_created_at": "2025-02-04T16:31:59+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Revisit silent failures for key operations.**\n\nAlthough failures are logged, the endpoint still returns a success response even if updating user preferences or deleting the token fails. Consider returning an appropriate error status or partial-success response to let clients handle any discrepancies gracefully.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1940283441",
    "pr_number": 320,
    "pr_file": "apps/web/utils/reply-tracker/outbound.ts",
    "created_at": "2025-02-03T23:52:14+00:00",
    "commented_code": "+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { aiCheckIfNeedsReply } from \"@/utils/ai/reply/check-if-needs-reply\";\n+import prisma from \"@/utils/prisma\";\n+import { getThreadMessages } from \"@/utils/gmail/thread\";\n+import { ThreadTrackerType, type User } from \"@prisma/client\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { getEmailForLLM } from \"@/utils/ai/choose-rule/get-email-from-message\";\n+import {\n+  labelAwaitingReply,\n+  removeNeedsReplyLabel,\n+  getReplyTrackingLabels,\n+} from \"@/utils/reply-tracker/label\";\n+import { internalDateToDate } from \"@/utils/date\";\n+\n+const logger = createScopedLogger(\"outbound-reply\");\n+\n+export async function handleOutboundReply(\n+  user: Pick<User, \"id\" | \"about\"> & UserEmailWithAI,\n+  message: ParsedMessage,\n+  gmail: gmail_v1.Gmail,\n+) {\n+  const userId = user.id;\n+\n+  const { awaitingReplyLabelId, needsReplyLabelId } =\n+    await getReplyTrackingLabels(gmail);\n+\n+  // When we send a reply, resolve any existing \"NEEDS_REPLY\" trackers\n+  await resolveReplyTrackers(\n+    gmail,\n+    userId,\n+    message.threadId,\n+    needsReplyLabelId,\n+  );\n+",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1940283441",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 320,
        "pr_file": "apps/web/utils/reply-tracker/outbound.ts",
        "discussion_id": "1940283441",
        "commented_code": "@@ -0,0 +1,138 @@\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import type { UserEmailWithAI } from \"@/utils/llms/types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { aiCheckIfNeedsReply } from \"@/utils/ai/reply/check-if-needs-reply\";\n+import prisma from \"@/utils/prisma\";\n+import { getThreadMessages } from \"@/utils/gmail/thread\";\n+import { ThreadTrackerType, type User } from \"@prisma/client\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { getEmailForLLM } from \"@/utils/ai/choose-rule/get-email-from-message\";\n+import {\n+  labelAwaitingReply,\n+  removeNeedsReplyLabel,\n+  getReplyTrackingLabels,\n+} from \"@/utils/reply-tracker/label\";\n+import { internalDateToDate } from \"@/utils/date\";\n+\n+const logger = createScopedLogger(\"outbound-reply\");\n+\n+export async function handleOutboundReply(\n+  user: Pick<User, \"id\" | \"about\"> & UserEmailWithAI,\n+  message: ParsedMessage,\n+  gmail: gmail_v1.Gmail,\n+) {\n+  const userId = user.id;\n+\n+  const { awaitingReplyLabelId, needsReplyLabelId } =\n+    await getReplyTrackingLabels(gmail);\n+\n+  // When we send a reply, resolve any existing \"NEEDS_REPLY\" trackers\n+  await resolveReplyTrackers(\n+    gmail,\n+    userId,\n+    message.threadId,\n+    needsReplyLabelId,\n+  );\n+",
        "comment_created_at": "2025-02-03T23:52:14+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Consider Transactional Updates or Error Handling Around `resolveReplyTrackers`**\n\nCurrently, the code resolves existing \"NEEDS_REPLY\" trackers before performing further logic (e.g., AI checks, creating new trackers). If an error occurs afterward, the state might end up partially updated. To ensure atomic or consistent updates, you could consider wrapping these steps in a transaction or introducing fallback/error handling logic.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1940283446",
    "pr_number": 320,
    "pr_file": "apps/web/utils/reply-tracker/inbound.ts",
    "created_at": "2025-02-03T23:52:14+00:00",
    "commented_code": "+import prisma from \"@/utils/prisma\";\n+import { ThreadTrackerType } from \"@prisma/client\";\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import {\n+  labelNeedsReply,\n+  removeAwaitingReplyLabel,\n+  getReplyTrackingLabels,\n+} from \"@/utils/reply-tracker/label\";\n+\n+export async function markNeedsReply(\n+  userId: string,\n+  threadId: string,\n+  messageId: string,\n+  sentAt: Date,\n+  gmail: gmail_v1.Gmail,\n+) {\n+  const { awaitingReplyLabelId, needsReplyLabelId } =\n+    await getReplyTrackingLabels(gmail);\n+\n+  // Resolve existing AWAITING trackers\n+  const updateDbPromise = prisma.threadTracker.updateMany({\n+    where: {\n+      userId,\n+      threadId,\n+      type: ThreadTrackerType.AWAITING,\n+    },\n+    data: {\n+      resolved: true,\n+    },\n+  });\n+\n+  // Create new NEEDS_REPLY tracker\n+  const upsertDbPromise = prisma.threadTracker.upsert({\n+    where: {\n+      userId_threadId_messageId: {\n+        userId,\n+        threadId,\n+        messageId,\n+      },\n+    },\n+    update: {},\n+    create: {\n+      userId,\n+      threadId,\n+      messageId,\n+      type: ThreadTrackerType.NEEDS_REPLY,\n+      sentAt,\n+    },\n+  });\n+\n+  const removeLabelPromise = removeAwaitingReplyLabel(\n+    gmail,\n+    threadId,\n+    awaitingReplyLabelId,\n+  );\n+  const newLabelPromise = labelNeedsReply(gmail, messageId, needsReplyLabelId);\n+\n+  await Promise.allSettled([\n+    updateDbPromise,\n+    upsertDbPromise,\n+    removeLabelPromise,\n+    newLabelPromise,\n+  ]);",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1940283446",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 320,
        "pr_file": "apps/web/utils/reply-tracker/inbound.ts",
        "discussion_id": "1940283446",
        "commented_code": "@@ -0,0 +1,64 @@\n+import prisma from \"@/utils/prisma\";\n+import { ThreadTrackerType } from \"@prisma/client\";\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import {\n+  labelNeedsReply,\n+  removeAwaitingReplyLabel,\n+  getReplyTrackingLabels,\n+} from \"@/utils/reply-tracker/label\";\n+\n+export async function markNeedsReply(\n+  userId: string,\n+  threadId: string,\n+  messageId: string,\n+  sentAt: Date,\n+  gmail: gmail_v1.Gmail,\n+) {\n+  const { awaitingReplyLabelId, needsReplyLabelId } =\n+    await getReplyTrackingLabels(gmail);\n+\n+  // Resolve existing AWAITING trackers\n+  const updateDbPromise = prisma.threadTracker.updateMany({\n+    where: {\n+      userId,\n+      threadId,\n+      type: ThreadTrackerType.AWAITING,\n+    },\n+    data: {\n+      resolved: true,\n+    },\n+  });\n+\n+  // Create new NEEDS_REPLY tracker\n+  const upsertDbPromise = prisma.threadTracker.upsert({\n+    where: {\n+      userId_threadId_messageId: {\n+        userId,\n+        threadId,\n+        messageId,\n+      },\n+    },\n+    update: {},\n+    create: {\n+      userId,\n+      threadId,\n+      messageId,\n+      type: ThreadTrackerType.NEEDS_REPLY,\n+      sentAt,\n+    },\n+  });\n+\n+  const removeLabelPromise = removeAwaitingReplyLabel(\n+    gmail,\n+    threadId,\n+    awaitingReplyLabelId,\n+  );\n+  const newLabelPromise = labelNeedsReply(gmail, messageId, needsReplyLabelId);\n+\n+  await Promise.allSettled([\n+    updateDbPromise,\n+    upsertDbPromise,\n+    removeLabelPromise,\n+    newLabelPromise,\n+  ]);",
        "comment_created_at": "2025-02-03T23:52:14+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Add error handling for individual promise failures.**\n\nUsing `Promise.allSettled` is good for handling concurrent operations, but the results should be checked for failures.\n\nApply this diff to add error handling:\n\n```diff\n-  await Promise.allSettled([\n+  const results = await Promise.allSettled([\n     updateDbPromise,\n     upsertDbPromise,\n     removeLabelPromise,\n     newLabelPromise,\n   ]);\n+  \n+  // Check for failures\n+  const failures = results.filter(\n+    (result): result is PromiseRejectedResult => result.status === \"rejected\"\n+  );\n+  \n+  if (failures.length > 0) {\n+    console.error(\"Some operations failed:\", failures);\n+    // Optionally throw or handle errors\n+  }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n  const results = await Promise.allSettled([\n    updateDbPromise,\n    upsertDbPromise,\n    removeLabelPromise,\n    newLabelPromise,\n  ]);\n  \n  // Check for failures\n  const failures = results.filter(\n    (result): result is PromiseRejectedResult => result.status === \"rejected\"\n  );\n  \n  if (failures.length > 0) {\n    console.error(\"Some operations failed:\", failures);\n    // Optionally throw or handle errors\n  }\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1940283451",
    "pr_number": 320,
    "pr_file": "apps/web/utils/reply-tracker/label.ts",
    "created_at": "2025-02-03T23:52:14+00:00",
    "commented_code": "+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import {\n+  labelMessage,\n+  labelThread,\n+  getOrCreateLabels,\n+} from \"@/utils/gmail/label\";\n+\n+export const NEEDS_REPLY_LABEL_NAME = \"To Reply\";\n+const AWAITING_REPLY_LABEL_NAME = \"Awaiting Reply\";\n+\n+export async function labelAwaitingReply(\n+  gmail: gmail_v1.Gmail,\n+  messageId: string,\n+  awaitingReplyLabelId: string,\n+) {\n+  await labelMessage({\n+    gmail,\n+    messageId,\n+    addLabelIds: [awaitingReplyLabelId],\n+  });\n+}\n+\n+export async function removeAwaitingReplyLabel(\n+  gmail: gmail_v1.Gmail,\n+  threadId: string,\n+  awaitingReplyLabelId: string,\n+) {\n+  await labelThread({\n+    gmail,\n+    threadId,\n+    removeLabelIds: [awaitingReplyLabelId],\n+  });\n+}\n+\n+export async function labelNeedsReply(\n+  gmail: gmail_v1.Gmail,\n+  messageId: string,\n+  needsReplyLabelId: string,\n+) {\n+  await labelMessage({\n+    gmail,\n+    messageId,\n+    addLabelIds: [needsReplyLabelId],\n+  });\n+}\n+\n+export async function removeNeedsReplyLabel(\n+  gmail: gmail_v1.Gmail,\n+  threadId: string,\n+  needsReplyLabelId: string,\n+) {\n+  await labelThread({\n+    gmail,\n+    threadId,\n+    removeLabelIds: [needsReplyLabelId],\n+  });\n+}\n+\n+export async function getReplyTrackingLabels(gmail: gmail_v1.Gmail): Promise<{\n+  awaitingReplyLabelId: string;\n+  needsReplyLabelId: string;\n+}> {\n+  const [awaitingReplyLabel, needsReplyLabel] = await getOrCreateLabels({\n+    gmail,\n+    names: [AWAITING_REPLY_LABEL_NAME, NEEDS_REPLY_LABEL_NAME],\n+  });\n+\n+  return {\n+    awaitingReplyLabelId: awaitingReplyLabel.id || \"\",\n+    needsReplyLabelId: needsReplyLabel.id || \"\",\n+  };\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1940283451",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 320,
        "pr_file": "apps/web/utils/reply-tracker/label.ts",
        "discussion_id": "1940283451",
        "commented_code": "@@ -0,0 +1,72 @@\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import {\n+  labelMessage,\n+  labelThread,\n+  getOrCreateLabels,\n+} from \"@/utils/gmail/label\";\n+\n+export const NEEDS_REPLY_LABEL_NAME = \"To Reply\";\n+const AWAITING_REPLY_LABEL_NAME = \"Awaiting Reply\";\n+\n+export async function labelAwaitingReply(\n+  gmail: gmail_v1.Gmail,\n+  messageId: string,\n+  awaitingReplyLabelId: string,\n+) {\n+  await labelMessage({\n+    gmail,\n+    messageId,\n+    addLabelIds: [awaitingReplyLabelId],\n+  });\n+}\n+\n+export async function removeAwaitingReplyLabel(\n+  gmail: gmail_v1.Gmail,\n+  threadId: string,\n+  awaitingReplyLabelId: string,\n+) {\n+  await labelThread({\n+    gmail,\n+    threadId,\n+    removeLabelIds: [awaitingReplyLabelId],\n+  });\n+}\n+\n+export async function labelNeedsReply(\n+  gmail: gmail_v1.Gmail,\n+  messageId: string,\n+  needsReplyLabelId: string,\n+) {\n+  await labelMessage({\n+    gmail,\n+    messageId,\n+    addLabelIds: [needsReplyLabelId],\n+  });\n+}\n+\n+export async function removeNeedsReplyLabel(\n+  gmail: gmail_v1.Gmail,\n+  threadId: string,\n+  needsReplyLabelId: string,\n+) {\n+  await labelThread({\n+    gmail,\n+    threadId,\n+    removeLabelIds: [needsReplyLabelId],\n+  });\n+}\n+\n+export async function getReplyTrackingLabels(gmail: gmail_v1.Gmail): Promise<{\n+  awaitingReplyLabelId: string;\n+  needsReplyLabelId: string;\n+}> {\n+  const [awaitingReplyLabel, needsReplyLabel] = await getOrCreateLabels({\n+    gmail,\n+    names: [AWAITING_REPLY_LABEL_NAME, NEEDS_REPLY_LABEL_NAME],\n+  });\n+\n+  return {\n+    awaitingReplyLabelId: awaitingReplyLabel.id || \"\",\n+    needsReplyLabelId: needsReplyLabel.id || \"\",\n+  };\n+}",
        "comment_created_at": "2025-02-03T23:52:14+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Consider throwing an error for missing label IDs.**\n\nCurrently, the function returns empty strings when label IDs are missing. This could lead to silent failures when these IDs are used in other functions.\n\nConsider this alternative implementation:\n\n```diff\n export async function getReplyTrackingLabels(gmail: gmail_v1.Gmail): Promise<{\n   awaitingReplyLabelId: string;\n   needsReplyLabelId: string;\n }> {\n   const [awaitingReplyLabel, needsReplyLabel] = await getOrCreateLabels({\n     gmail,\n     names: [AWAITING_REPLY_LABEL_NAME, NEEDS_REPLY_LABEL_NAME],\n   });\n\n+  if (!awaitingReplyLabel.id || !needsReplyLabel.id) {\n+    throw new Error(\"Failed to get or create reply tracking labels\");\n+  }\n\n   return {\n-    awaitingReplyLabelId: awaitingReplyLabel.id || \"\",\n-    needsReplyLabelId: needsReplyLabel.id || \"\",\n+    awaitingReplyLabelId: awaitingReplyLabel.id,\n+    needsReplyLabelId: needsReplyLabel.id,\n   };\n }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\nexport async function getReplyTrackingLabels(gmail: gmail_v1.Gmail): Promise<{\n  awaitingReplyLabelId: string;\n  needsReplyLabelId: string;\n}> {\n  const [awaitingReplyLabel, needsReplyLabel] = await getOrCreateLabels({\n    gmail,\n    names: [AWAITING_REPLY_LABEL_NAME, NEEDS_REPLY_LABEL_NAME],\n  });\n\n  if (!awaitingReplyLabel.id || !needsReplyLabel.id) {\n    throw new Error(\"Failed to get or create reply tracking labels\");\n  }\n\n  return {\n    awaitingReplyLabelId: awaitingReplyLabel.id,\n    needsReplyLabelId: needsReplyLabel.id,\n  };\n}\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1940283456",
    "pr_number": 320,
    "pr_file": "apps/web/app/api/google/threads/batch/route.ts",
    "created_at": "2025-02-03T23:52:15+00:00",
    "commented_code": "+import { NextResponse, type NextRequest } from \"next/server\";\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import { z } from \"zod\";\n+import { withError } from \"@/utils/middleware\";\n+import { getThreadsBatch } from \"@/utils/gmail/thread\";\n+import { parseMessages } from \"@/utils/mail\";\n+import { isDefined, type ThreadWithPayloadMessages } from \"@/utils/types\";\n+\n+const requestSchema = z.object({ threadIds: z.array(z.string()) });\n+\n+export type ThreadsBatchResponse = Awaited<ReturnType<typeof getThreads>>;\n+\n+async function getThreads(threadIds: string[], accessToken: string) {\n+  const threads = await getThreadsBatch(threadIds, accessToken);\n+\n+  const threadsWithMessages = await Promise.all(\n+    threads.map(async (thread) => {\n+      const id = thread.id;\n+      if (!id) return;\n+      const messages = parseMessages(thread as ThreadWithPayloadMessages);\n+\n+      return {\n+        id,\n+        messages,\n+      };\n+    }) || [],\n+  );\n+\n+  return {\n+    threads: threadsWithMessages.filter(isDefined),\n+  };\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1940283456",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 320,
        "pr_file": "apps/web/app/api/google/threads/batch/route.ts",
        "discussion_id": "1940283456",
        "commented_code": "@@ -0,0 +1,58 @@\n+import { NextResponse, type NextRequest } from \"next/server\";\n+import { auth } from \"@/app/api/auth/[...nextauth]/auth\";\n+import { z } from \"zod\";\n+import { withError } from \"@/utils/middleware\";\n+import { getThreadsBatch } from \"@/utils/gmail/thread\";\n+import { parseMessages } from \"@/utils/mail\";\n+import { isDefined, type ThreadWithPayloadMessages } from \"@/utils/types\";\n+\n+const requestSchema = z.object({ threadIds: z.array(z.string()) });\n+\n+export type ThreadsBatchResponse = Awaited<ReturnType<typeof getThreads>>;\n+\n+async function getThreads(threadIds: string[], accessToken: string) {\n+  const threads = await getThreadsBatch(threadIds, accessToken);\n+\n+  const threadsWithMessages = await Promise.all(\n+    threads.map(async (thread) => {\n+      const id = thread.id;\n+      if (!id) return;\n+      const messages = parseMessages(thread as ThreadWithPayloadMessages);\n+\n+      return {\n+        id,\n+        messages,\n+      };\n+    }) || [],\n+  );\n+\n+  return {\n+    threads: threadsWithMessages.filter(isDefined),\n+  };\n+}",
        "comment_created_at": "2025-02-03T23:52:15+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Add error handling and remove unnecessary fallback.**\n\nThe function has a few issues that could be improved:\n1. No error handling for failed thread fetches\n2. Unnecessary empty array fallback in Promise.all\n\nConsider this alternative implementation:\n\n```diff\n async function getThreads(threadIds: string[], accessToken: string) {\n   const threads = await getThreadsBatch(threadIds, accessToken);\n\n   const threadsWithMessages = await Promise.all(\n     threads.map(async (thread) => {\n       const id = thread.id;\n-      if (!id) return;\n+      if (!id) throw new Error(`Thread missing ID: ${JSON.stringify(thread)}`);\n+\n+      try {\n         const messages = parseMessages(thread as ThreadWithPayloadMessages);\n+        return { id, messages };\n+      } catch (error) {\n+        console.error(`Failed to parse messages for thread ${id}:`, error);\n+        throw error;\n+      }\n-      return {\n-        id,\n-        messages,\n-      };\n-    }) || [],\n+    }),\n   );\n\n   return {\n     threads: threadsWithMessages.filter(isDefined),\n   };\n }\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\nasync function getThreads(threadIds: string[], accessToken: string) {\n  const threads = await getThreadsBatch(threadIds, accessToken);\n\n  const threadsWithMessages = await Promise.all(\n    threads.map(async (thread) => {\n      const id = thread.id;\n      if (!id) throw new Error(`Thread missing ID: ${JSON.stringify(thread)}`);\n\n      try {\n        const messages = parseMessages(thread as ThreadWithPayloadMessages);\n        return { id, messages };\n      } catch (error) {\n        console.error(`Failed to parse messages for thread ${id}:`, error);\n        throw error;\n      }\n    }),\n  );\n\n  return {\n    threads: threadsWithMessages.filter(isDefined),\n  };\n}\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861344832",
    "pr_number": 263,
    "pr_file": "apps/web/app/api/google/webhook/process-history.ts",
    "created_at": "2024-11-27T23:34:35+00:00",
    "commented_code": "return NextResponse.json({ ok: true });\n   } catch (error) {\n     captureException(error, { extra: { decodedData } }, email);\n-    logger.error(\"Error processing webhook\", error, decodedData);\n+    logger.error(\n+      \"Error processing webhook\",\n+      (error as any)?.message,\n+      decodedData,\n+    );",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1861344832",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 263,
        "pr_file": "apps/web/app/api/google/webhook/process-history.ts",
        "discussion_id": "1861344832",
        "commented_code": "@@ -204,7 +204,11 @@ export async function processHistoryForUser(\n     return NextResponse.json({ ok: true });\n   } catch (error) {\n     captureException(error, { extra: { decodedData } }, email);\n-    logger.error(\"Error processing webhook\", error, decodedData);\n+    logger.error(\n+      \"Error processing webhook\",\n+      (error as any)?.message,\n+      decodedData,\n+    );",
        "comment_created_at": "2024-11-27T23:34:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:hammer_and_wrench: Refactor suggestion_\n\n**Consider preserving more error details for debugging**\n\nWhile logging only the error message helps reduce noise, it might make debugging more difficult in production. Consider these improvements:\n\n1. Preserve the error stack trace for debugging\n2. Use a type-safe approach for error handling\n\nApply this diff to improve error handling:\n\n```diff\n    logger.error(\n      \"Error processing webhook\",\n-     (error as any)?.message,\n+     error instanceof Error ? {\n+       message: error.message,\n+       stack: error.stack,\n+       name: error.name\n+     } : String(error),\n      decodedData,\n    );\n```\n\nThis approach:\n- Safely handles both Error objects and unknown error types\n- Preserves stack traces for better debugging\n- Maintains type safety without using `any`\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n    logger.error(\n      \"Error processing webhook\",\n      error instanceof Error ? {\n        message: error.message,\n        stack: error.stack,\n        name: error.name\n      } : String(error),\n      decodedData,\n    );\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n---\n\n_:warning: Potential issue_\n\n**Review PII exposure in error logs**\n\nThe error logging includes `decodedData` which contains user email addresses. Consider redacting or masking sensitive information in logs to prevent PII exposure.\n\nApply this diff to implement PII redaction:\n\n```diff\n+function redactPII(data: any) {\n+  if (!data) return data;\n+  const redacted = { ...data };\n+  if (redacted.emailAddress) {\n+    redacted.emailAddress = redacted.emailAddress.replace(\n+      /(.{2}).*(@.*)/,\n+      '$1***$2'\n+    );\n+  }\n+  return redacted;\n+}\n\n    logger.error(\n      \"Error processing webhook\",\n      (error as any)?.message,\n-     decodedData,\n+     redactPII(decodedData),\n    );\n```\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]