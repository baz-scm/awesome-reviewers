[
  {
    "discussion_id": "2182626201",
    "pr_number": 537,
    "pr_file": "apps/web/utils/outlook/message.ts",
    "created_at": "2025-07-03T12:10:35+00:00",
    "commented_code": "+import type { Client } from \"@microsoft/microsoft-graph-client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import { OutlookLabel } from \"./label\";\n+\n+const logger = createScopedLogger(\"outlook/message\");\n+\n+// Cache for folder IDs\n+let folderIdCache: Record<string, string> | null = null;\n+\n+// Well-known folder names in Outlook that are consistent across all languages\n+const WELL_KNOWN_FOLDERS = {\n+  inbox: \"inbox\",\n+  sentitems: \"sentitems\",\n+  drafts: \"drafts\",\n+  archive: \"archive\",\n+  deleteditems: \"deleteditems\",\n+  junkemail: \"junkemail\",\n+} as const;\n+\n+async function getFolderIds(client: OutlookClient) {\n+  if (folderIdCache) return folderIdCache;\n+\n+  // First get the well-known folders\n+  const wellKnownFolders = await Promise.all(\n+    Object.entries(WELL_KNOWN_FOLDERS).map(async ([key, folderName]) => {\n+      try {\n+        const response = await client\n+          .getClient()\n+          .api(`/me/mailFolders/${folderName}`)\n+          .select(\"id\")\n+          .get();\n+        return [key, response.id];\n+      } catch (error) {\n+        logger.warn(`Failed to get well-known folder: ${folderName}`, {\n+          error,\n+        });\n+        return [key, null];\n+      }\n+    }),\n+  );\n+\n+  folderIdCache = wellKnownFolders.reduce(\n+    (acc, [key, id]) => {\n+      if (id) acc[key] = id;\n+      return acc;\n+    },\n+    {} as Record<string, string>,\n+  );\n+\n+  logger.info(\"Fetched Outlook folder IDs\", { folders: folderIdCache });\n+  return folderIdCache;\n+}\n+\n+function getOutlookLabels(\n+  message: Message,\n+  folderIds: Record<string, string>,\n+): string[] {\n+  const labels: string[] = [];\n+\n+  logger.info(\"Processing message labels\", {\n+    messageId: message.id,\n+    parentFolderId: message.parentFolderId,\n+    folderName: message.parentFolderId\n+      ? Object.entries(folderIds).find(\n+          ([_, id]) => id === message.parentFolderId,\n+        )?.[0]\n+      : undefined,\n+    isDraft: message.isDraft,\n+    categories: message.categories,\n+  });\n+\n+  // Check if message is a draft\n+  if (message.isDraft) {\n+    labels.push(OutlookLabel.DRAFT);\n+  }\n+\n+  // Map folder ID to label\n+  if (message.parentFolderId) {\n+    const folderKey = Object.entries(folderIds).find(\n+      ([_, id]) => id === message.parentFolderId,\n+    )?.[0];\n+    if (folderKey === \"inbox\") {\n+      labels.push(OutlookLabel.INBOX);\n+    } else if (folderKey === \"sentitems\") {\n+      labels.push(OutlookLabel.SENT);\n+    } else if (folderKey === \"drafts\") {\n+      labels.push(OutlookLabel.DRAFT);\n+    } else if (folderKey === \"junkemail\") {\n+      labels.push(OutlookLabel.SPAM);\n+    } else if (folderKey === \"deleteditems\") {\n+      labels.push(OutlookLabel.TRASH);\n+    }\n+  }\n+\n+  // Add category labels\n+  if (message.categories) {\n+    labels.push(...message.categories);\n+  }\n+\n+  logger.info(\"Final labels for message\", {\n+    messageId: message.id,\n+    labels,\n+  });\n+\n+  return labels;\n+}\n+\n+export async function queryBatchMessages(\n+  client: OutlookClient,\n+  {\n+    query,\n+    maxResults = 20,\n+    pageToken,\n+  }: {\n+    query?: string;\n+    maxResults?: number;\n+    pageToken?: string;\n+  },\n+) {\n+  if (maxResults > 20) {\n+    throw new Error(\n+      \"Max results must be 20 or Microsoft Graph API will rate limit us.\",\n+    );\n+  }\n+\n+  // Get folder IDs first\n+  const folderIds = await getFolderIds(client);\n+\n+  logger.info(\"Building Outlook request\", {\n+    maxResults,\n+    hasQuery: !!query,\n+    pageToken,\n+  });\n+\n+  // Build the base request\n+  let request = client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,from,sender,toRecipients,receivedDateTime,isDraft,body,categories,parentFolderId\",\n+    )\n+    .top(maxResults);\n+\n+  let nextPageToken: string | undefined;\n+\n+  if (query?.trim()) {\n+    // Search path - use search and skipToken\n+    request = request.search(query.trim());\n+\n+    if (pageToken) {\n+      request = request.skipToken(pageToken);\n+    }\n+\n+    const response = await request.get();\n+    // Filter results to only include inbox messages (since we can't use filter with search)\n+    const inboxMessages = response.value.filter(\n+      (message: Message) =>\n+        message.parentFolderId === folderIds.inbox && !message.isDraft,\n+    );\n+    const messages = await convertMessages(inboxMessages, folderIds);\n+\n+    // For search, get next page token from @odata.nextLink\n+    nextPageToken = response[\"@odata.nextLink\"]\n+      ? new URL(response[\"@odata.nextLink\"]).searchParams.get(\"$skiptoken\") ||\n+        undefined\n+      : undefined;\n+\n+    logger.info(\"Search results\", {\n+      messageCount: messages.length,\n+      hasNextPageToken: !!nextPageToken,\n+    });\n+\n+    return { messages, nextPageToken };\n+  } else {\n+    // Non-search path - use filter, skip and orderBy\n+    request = request\n+      .filter(\"parentFolderId eq '\" + folderIds.inbox + \"'\")\n+      .skip(pageToken ? parseInt(pageToken, 10) : 0)\n+      .orderby(\"receivedDateTime DESC\");\n+\n+    const response = await request.get();\n+    const messages = await convertMessages(response.value, folderIds);\n+\n+    // For non-search, calculate next page token based on message count\n+    const hasMore = messages.length === maxResults;\n+    nextPageToken = hasMore\n+      ? (pageToken\n+          ? parseInt(pageToken, 10) + maxResults\n+          : maxResults\n+        ).toString()\n+      : undefined;\n+\n+    logger.info(\"Non-search results\", {\n+      messageCount: messages.length,\n+      skip: pageToken ? parseInt(pageToken, 10) : 0,\n+      hasMore,\n+      nextPageToken,\n+    });\n+\n+    return { messages, nextPageToken };\n+  }\n+}\n+\n+// Helper function to convert messages\n+async function convertMessages(\n+  messages: Message[],\n+  folderIds: Record<string, string>,\n+): Promise<ParsedMessage[]> {\n+  return messages.map((message: Message) => {\n+    const labelIds = getOutlookLabels(message, folderIds);\n+\n+    logger.info(\"Converting message to ParsedMessage\", {\n+      messageId: message.id,\n+      labelIds,\n+    });\n+\n+    return {\n+      id: message.id || \"\",\n+      threadId: message.conversationId || \"\",\n+      snippet: message.bodyPreview || \"\",\n+      textPlain: message.body?.content || \"\",\n+      textHtml: message.body?.content || \"\",\n+      headers: {\n+        from: message.from?.emailAddress?.address || \"\",\n+        to: message.toRecipients?.[0]?.emailAddress?.address || \"\",\n+        subject: message.subject || \"\",\n+        date: message.receivedDateTime || new Date().toISOString(),\n+      },\n+      labelIds,\n+      internalDate: message.receivedDateTime || new Date().toISOString(),\n+      historyId: \"\",\n+      inline: [],\n+    };\n+  });\n+}\n+\n+export async function getMessage(\n+  messageId: string,\n+  client: OutlookClient,\n+): Promise<ParsedMessage> {\n+  const message = await client\n+    .getClient()\n+    .api(`/me/messages/${messageId}`)\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,from,sender,toRecipients,receivedDateTime,isDraft,body,categories,parentFolderId\",\n+    )\n+    .get();\n+\n+  return {\n+    id: message.id || \"\",\n+    threadId: message.conversationId || \"\",\n+    snippet: message.bodyPreview || \"\",\n+    textPlain: message.body?.content || \"\",\n+    textHtml: message.body?.content || \"\",\n+    headers: {\n+      from: message.from?.emailAddress?.address || \"\",\n+      to: message.toRecipients?.[0]?.emailAddress?.address || \"\",\n+      subject: message.subject || \"\",\n+      date: message.receivedDateTime || new Date().toISOString(),\n+    },\n+    labelIds: getOutlookLabels(message, {}),\n+    internalDate: message.receivedDateTime || new Date().toISOString(),\n+    historyId: \"\",\n+    inline: [],\n+  };\n+}\n+\n+export async function getMessages(\n+  client: OutlookClient,\n+  options: {\n+    query?: string;\n+    maxResults?: number;\n+    pageToken?: string;\n+  },\n+) {\n+  const top = options.maxResults || 20;\n+  let request = client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .top(top)\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,body,from,toRecipients,receivedDateTime,categories,parentFolderId\",\n+    );\n+\n+  if (options.query) {\n+    request = request.filter(`contains(subject, '${options.query}')`);\n+  }\n+\n+  const response = await request.get();\n+\n+  return {\n+    messages: response.value,\n+    nextPageToken: response[\"@odata.nextLink\"],\n+  };\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2182626201",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 537,
        "pr_file": "apps/web/utils/outlook/message.ts",
        "discussion_id": "2182626201",
        "commented_code": "@@ -0,0 +1,317 @@\n+import type { Client } from \"@microsoft/microsoft-graph-client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import { OutlookLabel } from \"./label\";\n+\n+const logger = createScopedLogger(\"outlook/message\");\n+\n+// Cache for folder IDs\n+let folderIdCache: Record<string, string> | null = null;\n+\n+// Well-known folder names in Outlook that are consistent across all languages\n+const WELL_KNOWN_FOLDERS = {\n+  inbox: \"inbox\",\n+  sentitems: \"sentitems\",\n+  drafts: \"drafts\",\n+  archive: \"archive\",\n+  deleteditems: \"deleteditems\",\n+  junkemail: \"junkemail\",\n+} as const;\n+\n+async function getFolderIds(client: OutlookClient) {\n+  if (folderIdCache) return folderIdCache;\n+\n+  // First get the well-known folders\n+  const wellKnownFolders = await Promise.all(\n+    Object.entries(WELL_KNOWN_FOLDERS).map(async ([key, folderName]) => {\n+      try {\n+        const response = await client\n+          .getClient()\n+          .api(`/me/mailFolders/${folderName}`)\n+          .select(\"id\")\n+          .get();\n+        return [key, response.id];\n+      } catch (error) {\n+        logger.warn(`Failed to get well-known folder: ${folderName}`, {\n+          error,\n+        });\n+        return [key, null];\n+      }\n+    }),\n+  );\n+\n+  folderIdCache = wellKnownFolders.reduce(\n+    (acc, [key, id]) => {\n+      if (id) acc[key] = id;\n+      return acc;\n+    },\n+    {} as Record<string, string>,\n+  );\n+\n+  logger.info(\"Fetched Outlook folder IDs\", { folders: folderIdCache });\n+  return folderIdCache;\n+}\n+\n+function getOutlookLabels(\n+  message: Message,\n+  folderIds: Record<string, string>,\n+): string[] {\n+  const labels: string[] = [];\n+\n+  logger.info(\"Processing message labels\", {\n+    messageId: message.id,\n+    parentFolderId: message.parentFolderId,\n+    folderName: message.parentFolderId\n+      ? Object.entries(folderIds).find(\n+          ([_, id]) => id === message.parentFolderId,\n+        )?.[0]\n+      : undefined,\n+    isDraft: message.isDraft,\n+    categories: message.categories,\n+  });\n+\n+  // Check if message is a draft\n+  if (message.isDraft) {\n+    labels.push(OutlookLabel.DRAFT);\n+  }\n+\n+  // Map folder ID to label\n+  if (message.parentFolderId) {\n+    const folderKey = Object.entries(folderIds).find(\n+      ([_, id]) => id === message.parentFolderId,\n+    )?.[0];\n+    if (folderKey === \"inbox\") {\n+      labels.push(OutlookLabel.INBOX);\n+    } else if (folderKey === \"sentitems\") {\n+      labels.push(OutlookLabel.SENT);\n+    } else if (folderKey === \"drafts\") {\n+      labels.push(OutlookLabel.DRAFT);\n+    } else if (folderKey === \"junkemail\") {\n+      labels.push(OutlookLabel.SPAM);\n+    } else if (folderKey === \"deleteditems\") {\n+      labels.push(OutlookLabel.TRASH);\n+    }\n+  }\n+\n+  // Add category labels\n+  if (message.categories) {\n+    labels.push(...message.categories);\n+  }\n+\n+  logger.info(\"Final labels for message\", {\n+    messageId: message.id,\n+    labels,\n+  });\n+\n+  return labels;\n+}\n+\n+export async function queryBatchMessages(\n+  client: OutlookClient,\n+  {\n+    query,\n+    maxResults = 20,\n+    pageToken,\n+  }: {\n+    query?: string;\n+    maxResults?: number;\n+    pageToken?: string;\n+  },\n+) {\n+  if (maxResults > 20) {\n+    throw new Error(\n+      \"Max results must be 20 or Microsoft Graph API will rate limit us.\",\n+    );\n+  }\n+\n+  // Get folder IDs first\n+  const folderIds = await getFolderIds(client);\n+\n+  logger.info(\"Building Outlook request\", {\n+    maxResults,\n+    hasQuery: !!query,\n+    pageToken,\n+  });\n+\n+  // Build the base request\n+  let request = client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,from,sender,toRecipients,receivedDateTime,isDraft,body,categories,parentFolderId\",\n+    )\n+    .top(maxResults);\n+\n+  let nextPageToken: string | undefined;\n+\n+  if (query?.trim()) {\n+    // Search path - use search and skipToken\n+    request = request.search(query.trim());\n+\n+    if (pageToken) {\n+      request = request.skipToken(pageToken);\n+    }\n+\n+    const response = await request.get();\n+    // Filter results to only include inbox messages (since we can't use filter with search)\n+    const inboxMessages = response.value.filter(\n+      (message: Message) =>\n+        message.parentFolderId === folderIds.inbox && !message.isDraft,\n+    );\n+    const messages = await convertMessages(inboxMessages, folderIds);\n+\n+    // For search, get next page token from @odata.nextLink\n+    nextPageToken = response[\"@odata.nextLink\"]\n+      ? new URL(response[\"@odata.nextLink\"]).searchParams.get(\"$skiptoken\") ||\n+        undefined\n+      : undefined;\n+\n+    logger.info(\"Search results\", {\n+      messageCount: messages.length,\n+      hasNextPageToken: !!nextPageToken,\n+    });\n+\n+    return { messages, nextPageToken };\n+  } else {\n+    // Non-search path - use filter, skip and orderBy\n+    request = request\n+      .filter(\"parentFolderId eq '\" + folderIds.inbox + \"'\")\n+      .skip(pageToken ? parseInt(pageToken, 10) : 0)\n+      .orderby(\"receivedDateTime DESC\");\n+\n+    const response = await request.get();\n+    const messages = await convertMessages(response.value, folderIds);\n+\n+    // For non-search, calculate next page token based on message count\n+    const hasMore = messages.length === maxResults;\n+    nextPageToken = hasMore\n+      ? (pageToken\n+          ? parseInt(pageToken, 10) + maxResults\n+          : maxResults\n+        ).toString()\n+      : undefined;\n+\n+    logger.info(\"Non-search results\", {\n+      messageCount: messages.length,\n+      skip: pageToken ? parseInt(pageToken, 10) : 0,\n+      hasMore,\n+      nextPageToken,\n+    });\n+\n+    return { messages, nextPageToken };\n+  }\n+}\n+\n+// Helper function to convert messages\n+async function convertMessages(\n+  messages: Message[],\n+  folderIds: Record<string, string>,\n+): Promise<ParsedMessage[]> {\n+  return messages.map((message: Message) => {\n+    const labelIds = getOutlookLabels(message, folderIds);\n+\n+    logger.info(\"Converting message to ParsedMessage\", {\n+      messageId: message.id,\n+      labelIds,\n+    });\n+\n+    return {\n+      id: message.id || \"\",\n+      threadId: message.conversationId || \"\",\n+      snippet: message.bodyPreview || \"\",\n+      textPlain: message.body?.content || \"\",\n+      textHtml: message.body?.content || \"\",\n+      headers: {\n+        from: message.from?.emailAddress?.address || \"\",\n+        to: message.toRecipients?.[0]?.emailAddress?.address || \"\",\n+        subject: message.subject || \"\",\n+        date: message.receivedDateTime || new Date().toISOString(),\n+      },\n+      labelIds,\n+      internalDate: message.receivedDateTime || new Date().toISOString(),\n+      historyId: \"\",\n+      inline: [],\n+    };\n+  });\n+}\n+\n+export async function getMessage(\n+  messageId: string,\n+  client: OutlookClient,\n+): Promise<ParsedMessage> {\n+  const message = await client\n+    .getClient()\n+    .api(`/me/messages/${messageId}`)\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,from,sender,toRecipients,receivedDateTime,isDraft,body,categories,parentFolderId\",\n+    )\n+    .get();\n+\n+  return {\n+    id: message.id || \"\",\n+    threadId: message.conversationId || \"\",\n+    snippet: message.bodyPreview || \"\",\n+    textPlain: message.body?.content || \"\",\n+    textHtml: message.body?.content || \"\",\n+    headers: {\n+      from: message.from?.emailAddress?.address || \"\",\n+      to: message.toRecipients?.[0]?.emailAddress?.address || \"\",\n+      subject: message.subject || \"\",\n+      date: message.receivedDateTime || new Date().toISOString(),\n+    },\n+    labelIds: getOutlookLabels(message, {}),\n+    internalDate: message.receivedDateTime || new Date().toISOString(),\n+    historyId: \"\",\n+    inline: [],\n+  };\n+}\n+\n+export async function getMessages(\n+  client: OutlookClient,\n+  options: {\n+    query?: string;\n+    maxResults?: number;\n+    pageToken?: string;\n+  },\n+) {\n+  const top = options.maxResults || 20;\n+  let request = client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .top(top)\n+    .select(\n+      \"id,conversationId,subject,bodyPreview,body,from,toRecipients,receivedDateTime,categories,parentFolderId\",\n+    );\n+\n+  if (options.query) {\n+    request = request.filter(`contains(subject, '${options.query}')`);\n+  }\n+\n+  const response = await request.get();\n+\n+  return {\n+    messages: response.value,\n+    nextPageToken: response[\"@odata.nextLink\"],\n+  };\n+}",
        "comment_created_at": "2025-07-03T12:10:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Critical: Potential injection vulnerability in filter query.**\n\nThe `query` parameter is directly interpolated into the filter string without proper escaping, which could lead to injection attacks.\n\n\n```diff\n   if (options.query) {\n-    request = request.filter(`contains(subject, '${options.query}')`);\n+    // Escape single quotes in the query to prevent injection\n+    const escapedQuery = options.query.replace(/'/g, \"''\");\n+    request = request.filter(`contains(subject, '${escapedQuery}')`);\n   }\n```\n\nConsider using parameterized queries or a query builder if the Microsoft Graph SDK supports it.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\nexport async function getMessages(\n  client: OutlookClient,\n  options: {\n    query?: string;\n    maxResults?: number;\n    pageToken?: string;\n  },\n) {\n  const top = options.maxResults || 20;\n  let request = client\n    .getClient()\n    .api(\"/me/messages\")\n    .top(top)\n    .select(\n      \"id,conversationId,subject,bodyPreview,body,from,toRecipients,receivedDateTime,categories,parentFolderId\",\n    );\n\n  if (options.query) {\n    // Escape single quotes in the query to prevent injection\n    const escapedQuery = options.query.replace(/'/g, \"''\");\n    request = request.filter(`contains(subject, '${escapedQuery}')`);\n  }\n\n  const response = await request.get();\n\n  return {\n    messages: response.value,\n    nextPageToken: response[\"@odata.nextLink\"],\n  };\n}\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/outlook/message.ts around lines 271 to 298, the filter query\ndirectly interpolates the user-provided query string without escaping, creating\na potential injection vulnerability. To fix this, sanitize or escape the query\nstring before including it in the filter expression, or use a parameterized\nquery method if supported by the Microsoft Graph SDK to safely construct the\nfilter. This will prevent injection attacks by ensuring the query input cannot\nbreak the filter syntax.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n<!-- fingerprinting:phantom:medusa:lion -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182626231",
    "pr_number": 537,
    "pr_file": "apps/web/utils/outlook/thread.ts",
    "created_at": "2025-07-03T12:10:35+00:00",
    "commented_code": "+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+\n+const logger = createScopedLogger(\"outlook/thread\");\n+\n+export async function getThread(\n+  threadId: string,\n+  client: OutlookClient,\n+): Promise<Message[]> {\n+  const messages = await client\n+    .getClient()\n+    .api(`/me/messages`)\n+    .filter(`conversationId eq '${threadId}'`)\n+    .orderby(\"receivedDateTime desc\")\n+    .get();\n+\n+  return messages.value;\n+}\n+\n+export async function getThreads(\n+  query: string,\n+  client: OutlookClient,\n+  maxResults = 100,\n+): Promise<{\n+  nextPageToken?: string | null;\n+  threads: { id: string; snippet: string }[];\n+}> {\n+  const response = await client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .filter(query ? `contains(subject, '${query}')` : \"\")\n+    .top(maxResults)\n+    .select(\"id,conversationId,subject,bodyPreview\")\n+    .get();\n+\n+  // Group messages by conversationId to create thread-like structure\n+  const threadMap = new Map<string, { id: string; snippet: string }>();\n+  for (const message of response.value) {\n+    if (message.conversationId && !threadMap.has(message.conversationId)) {\n+      threadMap.set(message.conversationId, {\n+        id: message.conversationId,\n+        snippet: message.bodyPreview || \"\",\n+      });\n+    }\n+  }\n+\n+  return {\n+    threads: Array.from(threadMap.values()),\n+    nextPageToken: response[\"@odata.nextLink\"],\n+  };\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2182626231",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 537,
        "pr_file": "apps/web/utils/outlook/thread.ts",
        "discussion_id": "2182626231",
        "commented_code": "@@ -0,0 +1,174 @@\n+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+\n+const logger = createScopedLogger(\"outlook/thread\");\n+\n+export async function getThread(\n+  threadId: string,\n+  client: OutlookClient,\n+): Promise<Message[]> {\n+  const messages = await client\n+    .getClient()\n+    .api(`/me/messages`)\n+    .filter(`conversationId eq '${threadId}'`)\n+    .orderby(\"receivedDateTime desc\")\n+    .get();\n+\n+  return messages.value;\n+}\n+\n+export async function getThreads(\n+  query: string,\n+  client: OutlookClient,\n+  maxResults = 100,\n+): Promise<{\n+  nextPageToken?: string | null;\n+  threads: { id: string; snippet: string }[];\n+}> {\n+  const response = await client\n+    .getClient()\n+    .api(\"/me/messages\")\n+    .filter(query ? `contains(subject, '${query}')` : \"\")\n+    .top(maxResults)\n+    .select(\"id,conversationId,subject,bodyPreview\")\n+    .get();\n+\n+  // Group messages by conversationId to create thread-like structure\n+  const threadMap = new Map<string, { id: string; snippet: string }>();\n+  for (const message of response.value) {\n+    if (message.conversationId && !threadMap.has(message.conversationId)) {\n+      threadMap.set(message.conversationId, {\n+        id: message.conversationId,\n+        snippet: message.bodyPreview || \"\",\n+      });\n+    }\n+  }\n+\n+  return {\n+    threads: Array.from(threadMap.values()),\n+    nextPageToken: response[\"@odata.nextLink\"],\n+  };\n+}",
        "comment_created_at": "2025-07-03T12:10:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Critical: Multiple injection vulnerabilities in filter queries.**\n\nSeveral functions have injection vulnerabilities where parameters are directly interpolated into filter strings without escaping:\n\n\nIn `getThreads` and `getThreadsWithNextPageToken`:\n```diff\n-    request = request.filter(`contains(subject, '${query}')`);\n+    const escapedQuery = query.replace(/'/g, \"''\");\n+    request = request.filter(`contains(subject, '${escapedQuery}')`);\n```\n\nIn `getThreadsFromSender` and `getThreadsFromSenderWithSubject`:\n```diff\n-    .filter(`from/emailAddress/address eq '${sender}'`)\n+    .filter(`from/emailAddress/address eq '${sender.replace(/'/g, \"''\")}'`)\n```\n\n**Always escape single quotes in OData filter parameters to prevent injection attacks.**\n\n\nAlso applies to: 55-93, 95-120, 122-151\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/outlook/thread.ts around lines 22 to 53, the filter query\ndirectly interpolates the query string into the OData filter without escaping\nsingle quotes, causing injection vulnerabilities. To fix this, sanitize the\nquery parameter by escaping any single quotes before including it in the filter\nstring. Replace occurrences of unescaped query interpolation with a properly\nescaped version to prevent injection attacks.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n<!-- fingerprinting:phantom:medusa:lion -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182626235",
    "pr_number": 537,
    "pr_file": "apps/web/utils/outlook/thread.ts",
    "created_at": "2025-07-03T12:10:35+00:00",
    "commented_code": "+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+\n+const logger = createScopedLogger(\"outlook/thread\");\n+\n+export async function getThread(\n+  threadId: string,\n+  client: OutlookClient,\n+): Promise<Message[]> {\n+  const messages = await client\n+    .getClient()\n+    .api(`/me/messages`)\n+    .filter(`conversationId eq '${threadId}'`)\n+    .orderby(\"receivedDateTime desc\")\n+    .get();\n+\n+  return messages.value;\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2182626235",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 537,
        "pr_file": "apps/web/utils/outlook/thread.ts",
        "discussion_id": "2182626235",
        "commented_code": "@@ -0,0 +1,174 @@\n+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+\n+const logger = createScopedLogger(\"outlook/thread\");\n+\n+export async function getThread(\n+  threadId: string,\n+  client: OutlookClient,\n+): Promise<Message[]> {\n+  const messages = await client\n+    .getClient()\n+    .api(`/me/messages`)\n+    .filter(`conversationId eq '${threadId}'`)\n+    .orderby(\"receivedDateTime desc\")\n+    .get();\n+\n+  return messages.value;\n+}",
        "comment_created_at": "2025-07-03T12:10:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Fix injection vulnerability and template literal.**\n\nThe `threadId` parameter is directly interpolated without escaping. Also, remove unnecessary template literal.\n\n\n```diff\n   const messages = await client\n     .getClient()\n-    .api(`/me/messages`)\n+    .api(\"/me/messages\")\n-    .filter(`conversationId eq '${threadId}'`)\n+    .filter(`conversationId eq '${threadId.replace(/'/g, \"''\")}'`)\n     .orderby(\"receivedDateTime desc\")\n     .get();\n```\n\n<details>\n<summary>\ud83e\uddf0 Tools</summary>\n\n<details>\n<summary>\ud83e\ude9b Biome (1.9.4)</summary>\n\n[error] 14-14: Do not use template literals if interpolation and special-character handling are not needed.\n\nUnsafe fix: Replace with string literal\n\n\n(lint/style/noUnusedTemplateLiteral)\n\n</details>\n\n</details>\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/outlook/thread.ts around lines 8 to 20, the threadId parameter\nis directly interpolated into the filter string, causing a potential injection\nvulnerability, and the template literal is unnecessary. Fix this by properly\nescaping or encoding the threadId value before including it in the filter, and\nreplace the template literal with a safer string concatenation or parameterized\napproach to avoid injection risks.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n<!-- fingerprinting:phantom:medusa:lion -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182643588",
    "pr_number": 537,
    "pr_file": "apps/web/utils/outlook/mail.ts",
    "created_at": "2025-07-03T12:19:46+00:00",
    "commented_code": "+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { Attachment } from \"nodemailer/lib/mailer\";\n+import { convertEmailHtmlToText } from \"@/utils/mail\";\n+import type { SendEmailBody } from \"@/utils/gmail/mail\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import type { EmailForAction } from \"@/utils/ai/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createReplyContent } from \"@/utils/gmail/reply\";\n+import {\n+  forwardEmailHtml,\n+  forwardEmailSubject,\n+  forwardEmailText,\n+} from \"@/utils/gmail/forward\";\n+\n+const logger = createScopedLogger(\"outlook/mail\");\n+\n+interface OutlookMessageRequest {\n+  subject: string;\n+  body: {\n+    contentType: string;\n+    content: string;\n+  };\n+  toRecipients: { emailAddress: { address: string } }[];\n+  ccRecipients?: { emailAddress: { address: string } }[];\n+  bccRecipients?: { emailAddress: { address: string } }[];\n+  replyTo?: { emailAddress: { address: string } }[];\n+  conversationId?: string;\n+  isDraft?: boolean;\n+}\n+\n+export async function sendEmailWithHtml(\n+  client: OutlookClient,\n+  body: SendEmailBody,\n+) {\n+  let messageText: string;\n+\n+  try {\n+    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n+  } catch (error) {\n+    logger.error(\"Error converting email html to text\", { error });\n+    // Strip HTML tags as a fallback\n+    messageText = body.messageHtml.replace(/<[^>]*>/g, \"\");\n+  }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2182643588",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 537,
        "pr_file": "apps/web/utils/outlook/mail.ts",
        "discussion_id": "2182643588",
        "commented_code": "@@ -0,0 +1,241 @@\n+import type { OutlookClient } from \"@/utils/outlook/client\";\n+import type { Message } from \"@microsoft/microsoft-graph-types\";\n+import type { Attachment } from \"nodemailer/lib/mailer\";\n+import { convertEmailHtmlToText } from \"@/utils/mail\";\n+import type { SendEmailBody } from \"@/utils/gmail/mail\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import type { EmailForAction } from \"@/utils/ai/types\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import { createReplyContent } from \"@/utils/gmail/reply\";\n+import {\n+  forwardEmailHtml,\n+  forwardEmailSubject,\n+  forwardEmailText,\n+} from \"@/utils/gmail/forward\";\n+\n+const logger = createScopedLogger(\"outlook/mail\");\n+\n+interface OutlookMessageRequest {\n+  subject: string;\n+  body: {\n+    contentType: string;\n+    content: string;\n+  };\n+  toRecipients: { emailAddress: { address: string } }[];\n+  ccRecipients?: { emailAddress: { address: string } }[];\n+  bccRecipients?: { emailAddress: { address: string } }[];\n+  replyTo?: { emailAddress: { address: string } }[];\n+  conversationId?: string;\n+  isDraft?: boolean;\n+}\n+\n+export async function sendEmailWithHtml(\n+  client: OutlookClient,\n+  body: SendEmailBody,\n+) {\n+  let messageText: string;\n+\n+  try {\n+    messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n+  } catch (error) {\n+    logger.error(\"Error converting email html to text\", { error });\n+    // Strip HTML tags as a fallback\n+    messageText = body.messageHtml.replace(/<[^>]*>/g, \"\");\n+  }",
        "comment_created_at": "2025-07-03T12:19:46+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Potential HTML injection vulnerability in fallback sanitization.**\n\nThe fallback HTML stripping using regex on line 43 is incomplete and could allow malicious content. Consider using a proper HTML sanitization library for the fallback case.\n\n\nInstead of the simple regex, use a proper sanitization approach:\n\n```diff\n   try {\n     messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n   } catch (error) {\n     logger.error(\"Error converting email html to text\", { error });\n-    // Strip HTML tags as a fallback\n-    messageText = body.messageHtml.replace(/<[^>]*>/g, \"\");\n+    // Use a more robust HTML stripping approach\n+    messageText = body.messageHtml\n+      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n+      .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, \"\")\n+      .replace(/<[^>]+>/g, \"\")\n+      .replace(/\\s+/g, \" \")\n+      .trim();\n   }\n```\n\nAlternatively, consider using a library like `sanitize-html` or `DOMPurify` for proper HTML sanitization.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Locate convertEmailHtmlToText definition and usage\nrg -n \"convertEmailHtmlToText\" -A5 .\n# Check for html-to-text library usage\nrg -n \"html-to-text\" -A5 .\n# Check if any sanitization libraries are already present\nrg -n \"sanitize-html\" -A5 .\nrg -n \"dompurify\" -A5 .\n```\n\nLength of output: 8881\n\n---\n\n}\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Inspect how createReplyContent incorporates messageText\nrg -n \"export function createReplyContent\" -A50 apps/web/utils/gmail/reply.ts\n```\n\nLength of output: 79\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Locate createReplyContent definition across the repo\nrg -n \"createReplyContent\" -A10 .\n# List files in the gmail utilities directory to verify file names\nfind apps/web/utils/gmail -maxdepth 1 -type f\n```\n\nLength of output: 10367\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Extract the full createReplyContent implementation for review\nrg -n \"export const createReplyContent\" -A200 apps/web/utils/gmail/reply.ts\n```\n\nLength of output: 2606\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Locate createRawMailMessage in the Gmail mail utility\nrg -n \"createRawMailMessage\" -A30 apps/web/utils/gmail/mail.ts\n```\n\nLength of output: 4400\n\n---\n\n\n\n</details>\n\n**Improve fallback HTML sanitization**\n\nThe current regex-based stripper can leave behind script content or malformed markup, which may be rendered or misinterpreted downstream. Instead of a manual regex, use a dedicated sanitization library to strip all tags and attributes safely.\n\nLocations to update:\n- apps/web/utils/outlook/mail.ts (line 43)\n- apps/web/utils/gmail/mail.ts (line 111)\n\nSuggested diff for each:\n\n```diff\n   try {\n     messageText = convertEmailHtmlToText({ htmlText: body.messageHtml });\n   } catch (error) {\n     logger.error(\"Error converting email html to text\", { error });\n-    // Strip HTML tags as a fallback\n-    messageText = body.messageHtml.replace(/<[^>]*>/g, \"\");\n+    // Use a robust HTML sanitizer for fallback\n+    // 1) Install a sanitizer: `npm install sanitize-html`\n+    // 2) Import at top of file:\n+    //    import sanitizeHtml from \"sanitize-html\";\n+    // 3) Sanitize:\n+    messageText = sanitizeHtml(body.messageHtml, {\n+      allowedTags: [],\n+      allowedAttributes: {},\n+    });\n   }\n```\n\nIf you prefer DOMPurify (already installed), you can replace the fallback with:\n\n```ts\nimport createDOMPurify from \"isomorphic-dompurify\";\nconst DOMPurify = createDOMPurify();\n\nmessageText = DOMPurify.sanitize(body.messageHtml, {\n  ALLOWED_TAGS: [],\n  ALLOWED_ATTR: [],\n});\n```\n\n<details>\n<summary>\ud83e\uddf0 Tools</summary>\n\n<details>\n<summary>\ud83e\ude9b GitHub Check: CodeQL</summary>\n\n[failure] 43-43: Incomplete multi-character sanitization\nThis string may still contain [<script](1), which may cause an HTML element injection vulnerability.\n\n</details>\n\n</details>\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/outlook/mail.ts around lines 39 to 44, replace the fallback\nHTML stripping regex with a safer sanitization method using the DOMPurify\nlibrary. Import createDOMPurify from \"isomorphic-dompurify\", initialize it, and\nthen use DOMPurify.sanitize on body.messageHtml with ALLOWED_TAGS and\nALLOWED_ATTR set to empty arrays to fully strip all HTML tags and attributes\nsafely. This will prevent leftover script content or malformed markup in the\nfallback text.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n<!-- fingerprinting:phantom:medusa:lion -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154926769",
    "pr_number": 511,
    "pr_file": "apps/web/utils/outlook/forward.ts",
    "created_at": "2025-06-18T15:32:35+00:00",
    "commented_code": "+import { formatEmailDate } from \"@/utils/gmail/reply\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+\n+export const forwardEmailSubject = (subject: string) => {\n+  return `Fwd: ${subject}`;\n+};\n+\n+export const forwardEmailHtml = ({\n+  content,\n+  message,\n+}: {\n+  content: string;\n+  message: ParsedMessage;\n+}) => {\n+  const quotedDate = formatEmailDate(new Date(message.headers.date));\n+\n+  return `<div dir=\"ltr\">${content}<br><br>\n+<div class=\"gmail_quote gmail_quote_container\">\n+  <div dir=\"ltr\" class=\"gmail_attr\">---------- Forwarded message ----------<br>\n+From: ${formatFromEmailWithName(message.headers.from)}<br>\n+Date: ${quotedDate}<br>\n+Subject: ${message.headers.subject}<br>\n+To: ${formatToEmailWithName(message.headers.to)}<br>\n+</div><br><br>\n+${message.textHtml}\n+</div></div>`.trim();",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2154926769",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 511,
        "pr_file": "apps/web/utils/outlook/forward.ts",
        "discussion_id": "2154926769",
        "commented_code": "@@ -0,0 +1,65 @@\n+import { formatEmailDate } from \"@/utils/gmail/reply\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+\n+export const forwardEmailSubject = (subject: string) => {\n+  return `Fwd: ${subject}`;\n+};\n+\n+export const forwardEmailHtml = ({\n+  content,\n+  message,\n+}: {\n+  content: string;\n+  message: ParsedMessage;\n+}) => {\n+  const quotedDate = formatEmailDate(new Date(message.headers.date));\n+\n+  return `<div dir=\"ltr\">${content}<br><br>\n+<div class=\"gmail_quote gmail_quote_container\">\n+  <div dir=\"ltr\" class=\"gmail_attr\">---------- Forwarded message ----------<br>\n+From: ${formatFromEmailWithName(message.headers.from)}<br>\n+Date: ${quotedDate}<br>\n+Subject: ${message.headers.subject}<br>\n+To: ${formatToEmailWithName(message.headers.to)}<br>\n+</div><br><br>\n+${message.textHtml}\n+</div></div>`.trim();",
        "comment_created_at": "2025-06-18T15:32:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Potential XSS \u2013 unescaped header values injected into HTML**\n\n`subject`, `from`, `to`, and even `content` are inserted raw into the HTML block.  \nIf any value contains `<script>` or similar, the composed forward can introduce XSS.\n\nEscape/sanitize all user-supplied strings before interpolation (e.g. `he.encode` or a small utility).\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/outlook/forward.ts around lines 17 to 26, user-supplied header\nvalues such as subject, from, to, and content are directly injected into the\nHTML string without escaping, which risks XSS attacks. To fix this, sanitize or\nescape all these values before interpolation using a utility like he.encode or a\nsimilar HTML-escaping function to ensure any HTML special characters are safely\nencoded.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1944513862",
    "pr_number": 324,
    "pr_file": "apps/web/utils/parse/extract-reply.client.ts",
    "created_at": "2025-02-06T10:51:29+00:00",
    "commented_code": "+export function extractEmailReply(html: string): {\n+  latestReply: string;\n+  originalThread: string;\n+} {\n+  const parser = new DOMParser();\n+  const doc = parser.parseFromString(html, \"text/html\");\n+\n+  // Find the first gmail_quote container\n+  const quoteContainer = doc.querySelector(\n+    \".gmail_quote_container, .gmail_quote\",\n+  );\n+\n+  if (quoteContainer) {\n+    // Try to get nested reply first (case 1)\n+    let firstDiv = doc.querySelector('div[dir=\"ltr\"] > div[dir=\"ltr\"]');\n+\n+    // If not found, get the first direct reply (case 2)\n+    if (!firstDiv) {\n+      firstDiv = doc.querySelector('div[dir=\"ltr\"]:not(.gmail_attr)');\n+    }\n+\n+    const latestReplyHtml = firstDiv?.innerHTML || \"\";\n+\n+    return {\n+      latestReply: `<div dir=\"ltr\">${latestReplyHtml}</div>`,\n+      originalThread: quoteContainer.outerHTML,\n+    };",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1944513862",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 324,
        "pr_file": "apps/web/utils/parse/extract-reply.client.ts",
        "discussion_id": "1944513862",
        "commented_code": "@@ -0,0 +1,31 @@\n+export function extractEmailReply(html: string): {\n+  latestReply: string;\n+  originalThread: string;\n+} {\n+  const parser = new DOMParser();\n+  const doc = parser.parseFromString(html, \"text/html\");\n+\n+  // Find the first gmail_quote container\n+  const quoteContainer = doc.querySelector(\n+    \".gmail_quote_container, .gmail_quote\",\n+  );\n+\n+  if (quoteContainer) {\n+    // Try to get nested reply first (case 1)\n+    let firstDiv = doc.querySelector('div[dir=\"ltr\"] > div[dir=\"ltr\"]');\n+\n+    // If not found, get the first direct reply (case 2)\n+    if (!firstDiv) {\n+      firstDiv = doc.querySelector('div[dir=\"ltr\"]:not(.gmail_attr)');\n+    }\n+\n+    const latestReplyHtml = firstDiv?.innerHTML || \"\";\n+\n+    return {\n+      latestReply: `<div dir=\"ltr\">${latestReplyHtml}</div>`,\n+      originalThread: quoteContainer.outerHTML,\n+    };",
        "comment_created_at": "2025-02-06T10:51:29+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Sanitize HTML content to prevent XSS vulnerabilities.**\n\nDirect use of innerHTML/outerHTML could expose the application to XSS attacks.\n\nConsider using DOMPurify or a similar library to sanitize the HTML content:\n\n```diff\n+import DOMPurify from 'dompurify';\n+\n const latestReplyHtml = firstDiv?.innerHTML || \"\";\n \n return {\n-  latestReply: `<div dir=\"ltr\">${latestReplyHtml}</div>`,\n-  originalThread: quoteContainer.outerHTML,\n+  latestReply: DOMPurify.sanitize(`<div dir=\"ltr\">${latestReplyHtml}</div>`),\n+  originalThread: DOMPurify.sanitize(quoteContainer.outerHTML),\n };\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\nimport DOMPurify from 'dompurify';\n\nconst latestReplyHtml = firstDiv?.innerHTML || \"\";\n\nreturn {\n  latestReply: DOMPurify.sanitize(`<div dir=\"ltr\">${latestReplyHtml}</div>`),\n  originalThread: DOMPurify.sanitize(quoteContainer.outerHTML),\n};\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945525282",
    "pr_number": 324,
    "pr_file": "apps/web/utils/gmail/reply.ts",
    "created_at": "2025-02-06T21:50:28+00:00",
    "commented_code": "+import type { ParsedMessage } from \"@/utils/types\";\n+\n+export const createReplyContent = ({\n+  textContent,\n+  htmlContent,\n+  message,\n+}: {\n+  textContent?: string;\n+  htmlContent?: string;\n+  message: Pick<ParsedMessage, \"headers\" | \"textPlain\" | \"textHtml\">;\n+}): {\n+  html: string;\n+  text: string;\n+} => {\n+  const quotedDate = formatEmailDate(new Date(message.headers.date));\n+  const quotedHeader = `On ${quotedDate}, ${message.headers.from} wrote:`;\n+\n+  // Detect text direction from original message\n+  const textDirection = detectTextDirection(message.textPlain || \"\");\n+  const dirAttribute = `dir=\"${textDirection}\"`;\n+\n+  // Format plain text version with proper quoting\n+  const quotedContent = message.textPlain\n+    ?.split(\"\n\")\n+    .map((line) => `> ${line}`)\n+    .join(\"\n\");\n+  const plainText = `${textContent}\n\n${quotedHeader}\n\n${quotedContent}`;\n+\n+  // Get the message content, preserving any existing quotes\n+  const messageContent =\n+    message.textHtml || message.textPlain?.replace(/\n/g, \"<br>\") || \"\";\n+\n+  // Use htmlContent if provided, otherwise convert textContent to HTML\n+  const contentHtml = htmlContent || textContent?.replace(/\n/g, \"<br>\") || \"\";\n+\n+  // Format HTML version with Gmail-style quote formatting\n+  const html = `<div ${dirAttribute}>${contentHtml}</div>\n+<br>\n+<div class=\"gmail_quote gmail_quote_container\">\n+  <div dir=\"ltr\" class=\"gmail_attr\">${quotedHeader}<br></div>\n+  <blockquote class=\"gmail_quote\" \n+    style=\"margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex\">\n+    ${messageContent}\n+  </blockquote>\n+</div>`.trim();\n+\n+  return {\n+    text: plainText,\n+    html,\n+  };\n+};",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1945525282",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 324,
        "pr_file": "apps/web/utils/gmail/reply.ts",
        "discussion_id": "1945525282",
        "commented_code": "@@ -0,0 +1,70 @@\n+import type { ParsedMessage } from \"@/utils/types\";\n+\n+export const createReplyContent = ({\n+  textContent,\n+  htmlContent,\n+  message,\n+}: {\n+  textContent?: string;\n+  htmlContent?: string;\n+  message: Pick<ParsedMessage, \"headers\" | \"textPlain\" | \"textHtml\">;\n+}): {\n+  html: string;\n+  text: string;\n+} => {\n+  const quotedDate = formatEmailDate(new Date(message.headers.date));\n+  const quotedHeader = `On ${quotedDate}, ${message.headers.from} wrote:`;\n+\n+  // Detect text direction from original message\n+  const textDirection = detectTextDirection(message.textPlain || \"\");\n+  const dirAttribute = `dir=\"${textDirection}\"`;\n+\n+  // Format plain text version with proper quoting\n+  const quotedContent = message.textPlain\n+    ?.split(\"\\n\")\n+    .map((line) => `> ${line}`)\n+    .join(\"\\n\");\n+  const plainText = `${textContent}\\n\\n${quotedHeader}\\n\\n${quotedContent}`;\n+\n+  // Get the message content, preserving any existing quotes\n+  const messageContent =\n+    message.textHtml || message.textPlain?.replace(/\\n/g, \"<br>\") || \"\";\n+\n+  // Use htmlContent if provided, otherwise convert textContent to HTML\n+  const contentHtml = htmlContent || textContent?.replace(/\\n/g, \"<br>\") || \"\";\n+\n+  // Format HTML version with Gmail-style quote formatting\n+  const html = `<div ${dirAttribute}>${contentHtml}</div>\n+<br>\n+<div class=\"gmail_quote gmail_quote_container\">\n+  <div dir=\"ltr\" class=\"gmail_attr\">${quotedHeader}<br></div>\n+  <blockquote class=\"gmail_quote\" \n+    style=\"margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex\">\n+    ${messageContent}\n+  </blockquote>\n+</div>`.trim();\n+\n+  return {\n+    text: plainText,\n+    html,\n+  };\n+};",
        "comment_created_at": "2025-02-06T21:50:28+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:bulb: Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Consider adding sanitization for user-provided content.**\n\nThe `createReplyContent` function directly injects user-provided content into HTML without sanitization.\n\nLet's verify if there's any XSS protection in place:\n\n\n\n\nConsider using DOMPurify or a similar library to sanitize HTML content before injecting it into the template.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Search for HTML sanitization in the codebase\nrg -i 'sanitize|xss|dompurify|escape'\n```\n\nLength of output: 4868\n\n---\n\n\n\n</details>\n\n**Potential XSS Vulnerability \u2014 Missing Sanitization of User-Provided Content**\n\nThe current implementation in apps/web/utils/gmail/reply.ts directly injects user-provided textContent and htmlContent into the HTML output without any sanitization. Our search for common sanitization patterns (e.g., DOMPurify, sanitize, escape) indicates that no such mechanism is applied in this file. This leaves the reply function vulnerable to XSS attacks if an attacker controls parts of these inputs.\n\n\u2022 The function concatenates user content directly into the HTML template.  \n\u2022 No sanitization or escaping is performed on textContent or htmlContent before insertion.  \n\u2022 Although other parts of the codebase implement sanitization (e.g., in sanitizeActionFields), it is absent in reply.ts.\n\nPlease consider incorporating a robust sanitization library, such as DOMPurify, to clean the user-provided content before building the final HTML.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921626780",
    "pr_number": 313,
    "pr_file": "apps/web/utils/ai/assistant/process-user-request.ts",
    "created_at": "2025-01-19T20:24:38+00:00",
    "commented_code": "+import { InvalidToolArgumentsError, tool } from \"ai\";\n+import { z } from \"zod\";\n+import { chatCompletionTools, withRetry } from \"@/utils/llms\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { User } from \"@prisma/client\";\n+import type { UserAIFields } from \"@/utils/llms/types\";\n+import {\n+  createPromptFromRule,\n+  type RuleWithRelations,\n+} from \"@/utils/ai/rule/create-prompt-from-rule\";\n+import { aiRuleFix } from \"@/utils/ai/rule/rule-fix\";\n+\n+const logger = createScopedLogger(\"AssistantCommand\");\n+\n+const fixRuleSchema = z.object({\n+  explanation: z\n+    .string()\n+    .optional()\n+    .describe(\n+      \"The explanation for why the rule is incorrect. Leave blank if you don't know why.\",\n+    ),\n+});\n+\n+const replySchema = z.object({\n+  content: z.string().describe(\"The content of the reply to the user\"),\n+});\n+\n+export async function processUserRequest({\n+  user,\n+  messageContent,\n+  rules,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+  messageContent: string;\n+  rules: RuleWithRelations[];\n+}) {\n+  const system = `You are an email management assistant that helps users manage their email rules.\n+You can fix rules based on the user's request.\n+Always confirm your actions with clear, concise responses.\n+\n+You can also reply to the user with information or questions.\n+When you've completed your actions, you should reply to the user with a confirmation message.\n+\n+If the user asks you to do an action which you can't do, you should reply to the user with a message saying you can't do that.`;\n+\n+  const prompt = `<current_user_rules>\n+${rules\n+  .map(\n+    (rule) => `<rule>\n+  <rule_id>${rule.id}</rule_id>\n+  <rule_instructions>${createPromptFromRule(rule)}</rule_instructions>\n+</rule>`,\n+  )\n+  .join(\"\n\")}\n+</current_user_rules>\n+\n+<user_request>\n+${messageContent}\n+</user_request>`;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1921626780",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 313,
        "pr_file": "apps/web/utils/ai/assistant/process-user-request.ts",
        "discussion_id": "1921626780",
        "commented_code": "@@ -0,0 +1,108 @@\n+import { InvalidToolArgumentsError, tool } from \"ai\";\n+import { z } from \"zod\";\n+import { chatCompletionTools, withRetry } from \"@/utils/llms\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { User } from \"@prisma/client\";\n+import type { UserAIFields } from \"@/utils/llms/types\";\n+import {\n+  createPromptFromRule,\n+  type RuleWithRelations,\n+} from \"@/utils/ai/rule/create-prompt-from-rule\";\n+import { aiRuleFix } from \"@/utils/ai/rule/rule-fix\";\n+\n+const logger = createScopedLogger(\"AssistantCommand\");\n+\n+const fixRuleSchema = z.object({\n+  explanation: z\n+    .string()\n+    .optional()\n+    .describe(\n+      \"The explanation for why the rule is incorrect. Leave blank if you don't know why.\",\n+    ),\n+});\n+\n+const replySchema = z.object({\n+  content: z.string().describe(\"The content of the reply to the user\"),\n+});\n+\n+export async function processUserRequest({\n+  user,\n+  messageContent,\n+  rules,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+  messageContent: string;\n+  rules: RuleWithRelations[];\n+}) {\n+  const system = `You are an email management assistant that helps users manage their email rules.\n+You can fix rules based on the user's request.\n+Always confirm your actions with clear, concise responses.\n+\n+You can also reply to the user with information or questions.\n+When you've completed your actions, you should reply to the user with a confirmation message.\n+\n+If the user asks you to do an action which you can't do, you should reply to the user with a message saying you can't do that.`;\n+\n+  const prompt = `<current_user_rules>\n+${rules\n+  .map(\n+    (rule) => `<rule>\n+  <rule_id>${rule.id}</rule_id>\n+  <rule_instructions>${createPromptFromRule(rule)}</rule_instructions>\n+</rule>`,\n+  )\n+  .join(\"\\n\")}\n+</current_user_rules>\n+\n+<user_request>\n+${messageContent}\n+</user_request>`;",
        "comment_created_at": "2025-01-19T20:24:38+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Risk of prompt injection via user-provided `messageContent`**\n\nThe `messageContent` is directly interpolated into the `prompt`, which could expose the system to prompt injection attacks. Malicious users could manipulate the assistant's behavior by crafting specially formatted input. Consider sanitizing `messageContent` or implementing safety measures to mitigate this risk.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1925435746",
    "pr_number": 313,
    "pr_file": "apps/web/utils/ai/assistant/fix-rules.ts",
    "created_at": "2025-01-22T14:38:41+00:00",
    "commented_code": "+import { InvalidToolArgumentsError, tool } from \"ai\";\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import { z } from \"zod\";\n+import { chatCompletionTools, withRetry } from \"@/utils/llms\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { User } from \"@prisma/client\";\n+import type { UserAIFields } from \"@/utils/llms/types\";\n+import type { RuleWithRelations } from \"@/utils/ai/rule/create-prompt-from-rule\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { getEmailFromMessage } from \"@/utils/ai/choose-rule/get-email-from-message\";\n+import {\n+  createRuleSchema,\n+  getCreateRuleSchemaWithCategories,\n+} from \"@/utils/ai/rule/create-rule-schema\";\n+\n+const logger = createScopedLogger(\"ai-fix-rules\");\n+\n+const getChangeCategoryTool = (categories: [string, ...string[]]) =>\n+  tool({\n+    description: \"Change the category of a sender\",\n+    parameters: z.object({\n+      sender: z.string().describe(\"The sender to change\"),\n+      category: z\n+        .enum([...categories, \"none\"])\n+        .describe(\"The name of the category to assign\"),\n+    }),\n+    execute: async ({ sender, category }) => {\n+      logger.info(\"Change Category\", { sender, category });\n+      return { success: true };\n+    },\n+  });\n+\n+export async function processUserRequest({\n+  user,\n+  rules,\n+  userRequestEmail,\n+  originalEmail,\n+  matchedRule,\n+  gmail,\n+  categories,\n+  senderCategory,\n+}: {\n+  user: Pick<User, \"id\" | \"email\" | \"about\"> & UserAIFields;\n+  rules: RuleWithRelations[];\n+  userRequestEmail: ParsedMessage;\n+  originalEmail: ParsedMessage;\n+  matchedRule: RuleWithRelations | null;\n+  gmail: gmail_v1.Gmail;\n+  categories: [string, ...string[]] | null;\n+  senderCategory: string | null;\n+}) {\n+  const userRequestEmailForLLM = getEmailFromMessage(userRequestEmail);\n+  const originalEmailForLLM = getEmailFromMessage(originalEmail);\n+\n+  const system = `You are an email management assistant that helps users manage their email rules.\n+You can fix rules by adjusting their conditions, including:\n+- AI instructions\n+- Static conditions (from, to, subject, body)\n+- Static group conditions (from, subject)\n+- Category assignments\n+\n+Prefer to fix rules by editing them directly, rather than creating new ones.\n+\n+When fixing a rule, explain what changes you're making and why. Always confirm your actions with clear, concise responses.\n+\n+Rule matching logic:\n+- All static conditions (from, to, subject, body) use AND logic - meaning all conditions must match\n+- Top level conditions (static, group, category, AI instructions) can use either AND or OR logic, controlled by the conditionalOperator setting\n+\n+Group conditions:\n+- When a group exists, prefer to add/remove group items over changing AI instructions\n+- Only add subject patterns to groups if they are recurring across multiple emails (e.g., \"Monthly Statement\", \"Order Confirmation\")\n+\n+When fixing a rule, prefer minimal changes that solve the problem:\n+- Only add AI instructions if simpler conditions won't suffice\n+- Make the smallest change that will fix the issue`;\n+\n+  const prompt = `<matched_rule>\n+${matchedRule ? ruleToXML(matchedRule) : \"No rule matched\"}\n+</matched_rule>\n+\n+${\n+  !matchedRule\n+    ? `<user_rules>\n+${rules.map((rule) => ruleToXML(rule)).join(\"\n\")}\n+</user_rules>`\n+    : \"\"\n+}\n+\n+<user_request>\n+${userRequestEmailForLLM.content}\n+</user_request>\n+\n+${\n+  user.about\n+    ? `<user_about>\n+  ${user.about}\n+</user_about>`\n+    : \"\"\n+}\n+\n+<original_email>\n+${originalEmailForLLM.content}\n+</original_email>\n+\n+${\n+  categories?.length\n+    ? `<sender_category>\n+${senderCategory}\n+</sender_category>`\n+    : \"\"\n+}`;\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const result = await withRetry(\n+    () =>\n+      chatCompletionTools({\n+        userAi: user,\n+        prompt,\n+        system,\n+        tools: {\n+          edit_rule: tool({\n+            description: \"Fix a rule by adjusting its conditions\",\n+            parameters: z.object({\n+              ruleName: z\n+                .string()\n+                .optional()\n+                .describe(\"The exact name of the rule to fix\"),\n+              explanation: z\n+                .string()\n+                .describe(\"Explanation of the changes being made to the rule\"),\n+              condition: createRuleSchema.shape.condition,\n+            }),\n+            execute: async ({ ruleName, explanation, condition }) => {\n+              logger.trace(\"Edit Rule\", { ruleName, explanation, condition });\n+\n+              const rule = ruleName\n+                ? rules.find((r) => r.name === ruleName)\n+                : matchedRule;\n+\n+              if (!rule) {\n+                logger.error(\"Rule not found\", { ruleName });\n+                return { error: \"Rule not found\" };\n+              }\n+\n+              // // Update rule in database\n+              // const updates: Partial<RuleWithRelations> = {};\n+\n+              // if (condition.aiInstructions) {\n+              //   updates.instructions = condition.aiInstructions;\n+              // }\n+\n+              // if (condition.static) {\n+              //   Object.assign(updates, condition.static);\n+              // }\n+\n+              // if (condition.conditionalOperator) {\n+              //   updates.conditionalOperator = condition.conditionalOperator;\n+              // }\n+\n+              // if (condition.categories) {\n+              //   if (condition.categories.categoryFilters?.length) {\n+              //     const categories = await prisma.category.findMany({\n+              //       where: {\n+              //         name: { in: condition.categories.categoryFilters },\n+              //         userId: user.id,\n+              //       },\n+              //     });\n+\n+              //     if (categories.length) {\n+              //       updates.categoryFilters = {\n+              //         set: categories.map((cat) => ({ id: cat.id })),\n+              //       };\n+              //     }\n+              //   }\n+\n+              //   if (condition.categories.categoryFilterType) {\n+              //     updates.categoryFilterType =\n+              //       condition.categories.categoryFilterType;\n+              //   }\n+              // }\n+\n+              // await prisma.rule.update({\n+              //   where: { id: rule.id },\n+              //   data: updates,\n+              // });\n+\n+              // // Update user's prompt file if AI instructions changed\n+              // if (condition.aiInstructions) {\n+              //   await updateRuleAction({\n+              //     userId: user.id,\n+              //     ruleId: rule.id,\n+              //     instructions: condition.aiInstructions,\n+              //   });\n+              // }\n+\n+              // // Send confirmation email\n+              // await replyToEmail(\n+              //   gmail,\n+              //   originalEmail,\n+              //   `I've updated the rule \"${rule.name}\". ${explanation}`,\n+              // );\n+\n+              return { success: true };\n+            },\n+          }),\n+          create_rule: tool({\n+            description: \"Create a new rule\",\n+            parameters: categories\n+              ? getCreateRuleSchemaWithCategories(categories)\n+              : createRuleSchema,\n+            execute: async ({ name, condition, actions }) => {\n+              logger.info(\"Create Rule\", { name, condition, actions });\n+              return { success: true };\n+            },\n+          }),\n+          ...(categories\n+            ? {\n+                change_sender_category: getChangeCategoryTool(categories),\n+              }\n+            : {}),\n+          add_to_group: tool({\n+            description: \"Add a group item\",\n+            parameters: z.object({\n+              type: z\n+                .enum([\"from\", \"to\", \"subject\"])\n+                .describe(\"The type of the group item to add\"),\n+              value: z\n+                .string()\n+                .describe(\n+                  \"The value of the group item to add. eg '@company.com', 'matt@company.com', 'Receipt from'\",\n+                ),\n+            }),\n+            execute: async ({ type, value }) => {\n+              logger.info(\"Add To Group\", { type, value });\n+              return { success: true };\n+            },\n+          }),\n+          remove_from_group: tool({\n+            description: \"Remove a group item \",\n+            parameters: z.object({\n+              type: z\n+                .enum([\"from\", \"to\", \"subject\"])\n+                .describe(\"The type of the group item to remove\"),\n+              value: z\n+                .string()\n+                .describe(\"The value of the group item to remove\"),\n+            }),\n+            execute: async ({ type, value }) => {\n+              logger.info(\"Remove From Group\", { type, value });\n+              return { success: true };\n+            },\n+          }),\n+          // list_rules: tool({\n+          //   description: \"List all rules\",\n+          //   parameters: z.object({}),\n+          //   execute: async () => {\n+          //     logger.info(\"List Rules\");\n+          //     return rules.map((rule) => ruleToXML(rule)).join(\"\n\");\n+          //   },\n+          // }),\n+          reply: tool({\n+            description: \"Send an email reply to the user\",\n+            parameters: z.object({\n+              content: z\n+                .string()\n+                .describe(\n+                  \"The reply content. Do not send multiple replies in a row.\",\n+                ),\n+            }),\n+            // no execute function - invoking it will terminate the agent\n+          }),\n+        },\n+        maxSteps: 5,\n+        label: \"Fix Rule\",\n+        userEmail: user.email || \"\",\n+      }),\n+    {\n+      retryIf: (error: unknown) => InvalidToolArgumentsError.isInstance(error),\n+      maxRetries: 3,\n+      delayMs: 1000,\n+    },\n+  );\n+\n+  logger.trace(\"Tool Calls\", {\n+    toolCalls: result.steps.flatMap((step) => step.toolCalls),\n+  });\n+\n+  return result;\n+}\n+\n+function ruleToXML(rule: RuleWithRelations) {\n+  return `<rule>\n+  <rule_name>${rule.name}</rule_name>\n+  <conditions>\n+    <conditional_operator>${rule.conditionalOperator}</conditional_operator>\n+    ${rule.instructions ? `<ai_instructions>${rule.instructions}</ai_instructions>` : \"\"}\n+    ${\n+      hasStaticConditions(rule)\n+        ? `<static_conditions>\n+      ${rule.from ? `<from>${rule.from}</from>` : \"\"}\n+      ${rule.to ? `<to>${rule.to}</to>` : \"\"}\n+      ${rule.subject ? `<subject>${rule.subject}</subject>` : \"\"}\n+      ${rule.body ? `<body>${rule.body}</body>` : \"\"}\n+    </static_conditions>`\n+        : \"\"\n+    }\n+    ${\n+      rule.group\n+        ? `<group_condition>\n+      <group>${rule.group.name}</group>\n+      <group_items>\n+        ${\n+          rule.groupItems\n+            ? rule.groupItems\n+                .map(\n+                  (item) =>\n+                    `<item>\n+  <type>${item.type}</type>\n+  <value>${item.value}</value>\n+</item>`,\n+                )\n+                .join(\"\n      \")\n+            : \"No group items\"\n+        }\n+      </group_items>\n+    </group_condition>`\n+        : \"\"\n+    }\n+    ${\n+      hasCategoryConditions(rule)\n+        ? `<category_conditions>\n+      ${rule.categoryFilterType ? `<filter_type>${rule.categoryFilterType}</filter_type>` : \"\"}\n+      ${rule.categoryFilters?.map((category) => `<category>${category.name}</category>`).join(\"\n      \")}\n+    </category_conditions>`\n+        : \"\"\n+    }\n+  </conditions>\n+</rule>`;\n+}",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1925435746",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 313,
        "pr_file": "apps/web/utils/ai/assistant/fix-rules.ts",
        "discussion_id": "1925435746",
        "commented_code": "@@ -0,0 +1,349 @@\n+import { InvalidToolArgumentsError, tool } from \"ai\";\n+import type { gmail_v1 } from \"@googleapis/gmail\";\n+import { z } from \"zod\";\n+import { chatCompletionTools, withRetry } from \"@/utils/llms\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import type { User } from \"@prisma/client\";\n+import type { UserAIFields } from \"@/utils/llms/types\";\n+import type { RuleWithRelations } from \"@/utils/ai/rule/create-prompt-from-rule\";\n+import type { ParsedMessage } from \"@/utils/types\";\n+import { getEmailFromMessage } from \"@/utils/ai/choose-rule/get-email-from-message\";\n+import {\n+  createRuleSchema,\n+  getCreateRuleSchemaWithCategories,\n+} from \"@/utils/ai/rule/create-rule-schema\";\n+\n+const logger = createScopedLogger(\"ai-fix-rules\");\n+\n+const getChangeCategoryTool = (categories: [string, ...string[]]) =>\n+  tool({\n+    description: \"Change the category of a sender\",\n+    parameters: z.object({\n+      sender: z.string().describe(\"The sender to change\"),\n+      category: z\n+        .enum([...categories, \"none\"])\n+        .describe(\"The name of the category to assign\"),\n+    }),\n+    execute: async ({ sender, category }) => {\n+      logger.info(\"Change Category\", { sender, category });\n+      return { success: true };\n+    },\n+  });\n+\n+export async function processUserRequest({\n+  user,\n+  rules,\n+  userRequestEmail,\n+  originalEmail,\n+  matchedRule,\n+  gmail,\n+  categories,\n+  senderCategory,\n+}: {\n+  user: Pick<User, \"id\" | \"email\" | \"about\"> & UserAIFields;\n+  rules: RuleWithRelations[];\n+  userRequestEmail: ParsedMessage;\n+  originalEmail: ParsedMessage;\n+  matchedRule: RuleWithRelations | null;\n+  gmail: gmail_v1.Gmail;\n+  categories: [string, ...string[]] | null;\n+  senderCategory: string | null;\n+}) {\n+  const userRequestEmailForLLM = getEmailFromMessage(userRequestEmail);\n+  const originalEmailForLLM = getEmailFromMessage(originalEmail);\n+\n+  const system = `You are an email management assistant that helps users manage their email rules.\n+You can fix rules by adjusting their conditions, including:\n+- AI instructions\n+- Static conditions (from, to, subject, body)\n+- Static group conditions (from, subject)\n+- Category assignments\n+\n+Prefer to fix rules by editing them directly, rather than creating new ones.\n+\n+When fixing a rule, explain what changes you're making and why. Always confirm your actions with clear, concise responses.\n+\n+Rule matching logic:\n+- All static conditions (from, to, subject, body) use AND logic - meaning all conditions must match\n+- Top level conditions (static, group, category, AI instructions) can use either AND or OR logic, controlled by the conditionalOperator setting\n+\n+Group conditions:\n+- When a group exists, prefer to add/remove group items over changing AI instructions\n+- Only add subject patterns to groups if they are recurring across multiple emails (e.g., \"Monthly Statement\", \"Order Confirmation\")\n+\n+When fixing a rule, prefer minimal changes that solve the problem:\n+- Only add AI instructions if simpler conditions won't suffice\n+- Make the smallest change that will fix the issue`;\n+\n+  const prompt = `<matched_rule>\n+${matchedRule ? ruleToXML(matchedRule) : \"No rule matched\"}\n+</matched_rule>\n+\n+${\n+  !matchedRule\n+    ? `<user_rules>\n+${rules.map((rule) => ruleToXML(rule)).join(\"\\n\")}\n+</user_rules>`\n+    : \"\"\n+}\n+\n+<user_request>\n+${userRequestEmailForLLM.content}\n+</user_request>\n+\n+${\n+  user.about\n+    ? `<user_about>\n+  ${user.about}\n+</user_about>`\n+    : \"\"\n+}\n+\n+<original_email>\n+${originalEmailForLLM.content}\n+</original_email>\n+\n+${\n+  categories?.length\n+    ? `<sender_category>\n+${senderCategory}\n+</sender_category>`\n+    : \"\"\n+}`;\n+\n+  logger.trace(\"Input\", { system, prompt });\n+\n+  const result = await withRetry(\n+    () =>\n+      chatCompletionTools({\n+        userAi: user,\n+        prompt,\n+        system,\n+        tools: {\n+          edit_rule: tool({\n+            description: \"Fix a rule by adjusting its conditions\",\n+            parameters: z.object({\n+              ruleName: z\n+                .string()\n+                .optional()\n+                .describe(\"The exact name of the rule to fix\"),\n+              explanation: z\n+                .string()\n+                .describe(\"Explanation of the changes being made to the rule\"),\n+              condition: createRuleSchema.shape.condition,\n+            }),\n+            execute: async ({ ruleName, explanation, condition }) => {\n+              logger.trace(\"Edit Rule\", { ruleName, explanation, condition });\n+\n+              const rule = ruleName\n+                ? rules.find((r) => r.name === ruleName)\n+                : matchedRule;\n+\n+              if (!rule) {\n+                logger.error(\"Rule not found\", { ruleName });\n+                return { error: \"Rule not found\" };\n+              }\n+\n+              // // Update rule in database\n+              // const updates: Partial<RuleWithRelations> = {};\n+\n+              // if (condition.aiInstructions) {\n+              //   updates.instructions = condition.aiInstructions;\n+              // }\n+\n+              // if (condition.static) {\n+              //   Object.assign(updates, condition.static);\n+              // }\n+\n+              // if (condition.conditionalOperator) {\n+              //   updates.conditionalOperator = condition.conditionalOperator;\n+              // }\n+\n+              // if (condition.categories) {\n+              //   if (condition.categories.categoryFilters?.length) {\n+              //     const categories = await prisma.category.findMany({\n+              //       where: {\n+              //         name: { in: condition.categories.categoryFilters },\n+              //         userId: user.id,\n+              //       },\n+              //     });\n+\n+              //     if (categories.length) {\n+              //       updates.categoryFilters = {\n+              //         set: categories.map((cat) => ({ id: cat.id })),\n+              //       };\n+              //     }\n+              //   }\n+\n+              //   if (condition.categories.categoryFilterType) {\n+              //     updates.categoryFilterType =\n+              //       condition.categories.categoryFilterType;\n+              //   }\n+              // }\n+\n+              // await prisma.rule.update({\n+              //   where: { id: rule.id },\n+              //   data: updates,\n+              // });\n+\n+              // // Update user's prompt file if AI instructions changed\n+              // if (condition.aiInstructions) {\n+              //   await updateRuleAction({\n+              //     userId: user.id,\n+              //     ruleId: rule.id,\n+              //     instructions: condition.aiInstructions,\n+              //   });\n+              // }\n+\n+              // // Send confirmation email\n+              // await replyToEmail(\n+              //   gmail,\n+              //   originalEmail,\n+              //   `I've updated the rule \"${rule.name}\". ${explanation}`,\n+              // );\n+\n+              return { success: true };\n+            },\n+          }),\n+          create_rule: tool({\n+            description: \"Create a new rule\",\n+            parameters: categories\n+              ? getCreateRuleSchemaWithCategories(categories)\n+              : createRuleSchema,\n+            execute: async ({ name, condition, actions }) => {\n+              logger.info(\"Create Rule\", { name, condition, actions });\n+              return { success: true };\n+            },\n+          }),\n+          ...(categories\n+            ? {\n+                change_sender_category: getChangeCategoryTool(categories),\n+              }\n+            : {}),\n+          add_to_group: tool({\n+            description: \"Add a group item\",\n+            parameters: z.object({\n+              type: z\n+                .enum([\"from\", \"to\", \"subject\"])\n+                .describe(\"The type of the group item to add\"),\n+              value: z\n+                .string()\n+                .describe(\n+                  \"The value of the group item to add. eg '@company.com', 'matt@company.com', 'Receipt from'\",\n+                ),\n+            }),\n+            execute: async ({ type, value }) => {\n+              logger.info(\"Add To Group\", { type, value });\n+              return { success: true };\n+            },\n+          }),\n+          remove_from_group: tool({\n+            description: \"Remove a group item \",\n+            parameters: z.object({\n+              type: z\n+                .enum([\"from\", \"to\", \"subject\"])\n+                .describe(\"The type of the group item to remove\"),\n+              value: z\n+                .string()\n+                .describe(\"The value of the group item to remove\"),\n+            }),\n+            execute: async ({ type, value }) => {\n+              logger.info(\"Remove From Group\", { type, value });\n+              return { success: true };\n+            },\n+          }),\n+          // list_rules: tool({\n+          //   description: \"List all rules\",\n+          //   parameters: z.object({}),\n+          //   execute: async () => {\n+          //     logger.info(\"List Rules\");\n+          //     return rules.map((rule) => ruleToXML(rule)).join(\"\\n\");\n+          //   },\n+          // }),\n+          reply: tool({\n+            description: \"Send an email reply to the user\",\n+            parameters: z.object({\n+              content: z\n+                .string()\n+                .describe(\n+                  \"The reply content. Do not send multiple replies in a row.\",\n+                ),\n+            }),\n+            // no execute function - invoking it will terminate the agent\n+          }),\n+        },\n+        maxSteps: 5,\n+        label: \"Fix Rule\",\n+        userEmail: user.email || \"\",\n+      }),\n+    {\n+      retryIf: (error: unknown) => InvalidToolArgumentsError.isInstance(error),\n+      maxRetries: 3,\n+      delayMs: 1000,\n+    },\n+  );\n+\n+  logger.trace(\"Tool Calls\", {\n+    toolCalls: result.steps.flatMap((step) => step.toolCalls),\n+  });\n+\n+  return result;\n+}\n+\n+function ruleToXML(rule: RuleWithRelations) {\n+  return `<rule>\n+  <rule_name>${rule.name}</rule_name>\n+  <conditions>\n+    <conditional_operator>${rule.conditionalOperator}</conditional_operator>\n+    ${rule.instructions ? `<ai_instructions>${rule.instructions}</ai_instructions>` : \"\"}\n+    ${\n+      hasStaticConditions(rule)\n+        ? `<static_conditions>\n+      ${rule.from ? `<from>${rule.from}</from>` : \"\"}\n+      ${rule.to ? `<to>${rule.to}</to>` : \"\"}\n+      ${rule.subject ? `<subject>${rule.subject}</subject>` : \"\"}\n+      ${rule.body ? `<body>${rule.body}</body>` : \"\"}\n+    </static_conditions>`\n+        : \"\"\n+    }\n+    ${\n+      rule.group\n+        ? `<group_condition>\n+      <group>${rule.group.name}</group>\n+      <group_items>\n+        ${\n+          rule.groupItems\n+            ? rule.groupItems\n+                .map(\n+                  (item) =>\n+                    `<item>\n+  <type>${item.type}</type>\n+  <value>${item.value}</value>\n+</item>`,\n+                )\n+                .join(\"\\n      \")\n+            : \"No group items\"\n+        }\n+      </group_items>\n+    </group_condition>`\n+        : \"\"\n+    }\n+    ${\n+      hasCategoryConditions(rule)\n+        ? `<category_conditions>\n+      ${rule.categoryFilterType ? `<filter_type>${rule.categoryFilterType}</filter_type>` : \"\"}\n+      ${rule.categoryFilters?.map((category) => `<category>${category.name}</category>`).join(\"\\n      \")}\n+    </category_conditions>`\n+        : \"\"\n+    }\n+  </conditions>\n+</rule>`;\n+}",
        "comment_created_at": "2025-01-22T14:38:41+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Properly Escape Special Characters in `ruleToXML` Function**\n\nThe `ruleToXML` function constructs XML by directly embedding rule properties into strings. If any of these properties contain special XML characters (such as `<`, `>`, `&`), it could result in malformed XML or expose the system to XML injection attacks. It is important to escape or encode these special characters to ensure the XML is well-formed and secure.\n\n\n\nConsider using a utility function or library to escape special characters. For example:\n\n```diff\n+import { escape } from 'lodash';\n\nfunction ruleToXML(rule: RuleWithRelations) {\n  return `<rule>\n    <rule_name>${escape(rule.name)}</rule_name>\n    <conditions>\n      <conditional_operator>${escape(rule.conditionalOperator)}</conditional_operator>\n      ${rule.instructions ? `<ai_instructions>${escape(rule.instructions)}</ai_instructions>` : \"\"}\n      ${hasStaticConditions(rule) ? `<static_conditions>\n        ${rule.from ? `<from>${escape(rule.from)}</from>` : \"\"}\n        ${rule.to ? `<to>${escape(rule.to)}</to>` : \"\"}\n        ${rule.subject ? `<subject>${escape(rule.subject)}</subject>` : \"\"}\n        ${rule.body ? `<body>${escape(rule.body)}</body>` : \"\"}\n      </static_conditions>` : \"\"}\n      ${rule.group ? `<group_condition>\n        <group>${escape(rule.group.name)}</group>\n        <group_items>\n          ${rule.groupItems ? rule.groupItems.map((item) =>\n            `<item>\n              <type>${escape(item.type)}</type>\n              <value>${escape(item.value)}</value>\n            </item>`).join(\"\\n      \") : \"No group items\"}\n        </group_items>\n      </group_condition>` : \"\"}\n      ${hasCategoryConditions(rule) ? `<category_conditions>\n        ${\n          rule.categoryFilterType\n            ? `<filter_type>${escape(rule.categoryFilterType)}</filter_type>`\n            : \"\"\n        }\n        ${\n          rule.categoryFilters\n            ?.map((category) => `<category>${escape(category.name)}</category>`)\n            .join(\"\\n      \")\n        }\n      </category_conditions>` : \"\"}\n    </conditions>\n  </rule>`;\n}\n```\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\nimport { escape } from 'lodash';\n\nfunction ruleToXML(rule: RuleWithRelations) {\n  return `<rule>\n  <rule_name>${escape(rule.name)}</rule_name>\n  <conditions>\n    <conditional_operator>${escape(rule.conditionalOperator)}</conditional_operator>\n    ${rule.instructions ? `<ai_instructions>${escape(rule.instructions)}</ai_instructions>` : \"\"}\n    ${\n      hasStaticConditions(rule)\n        ? `<static_conditions>\n      ${rule.from ? `<from>${escape(rule.from)}</from>` : \"\"}\n      ${rule.to ? `<to>${escape(rule.to)}</to>` : \"\"}\n      ${rule.subject ? `<subject>${escape(rule.subject)}</subject>` : \"\"}\n      ${rule.body ? `<body>${escape(rule.body)}</body>` : \"\"}\n    </static_conditions>`\n        : \"\"\n    }\n    ${\n      rule.group\n        ? `<group_condition>\n      <group>${escape(rule.group.name)}</group>\n      <group_items>\n        ${\n          rule.groupItems\n            ? rule.groupItems\n                .map(\n                  (item) =>\n                    `<item>\n  <type>${escape(item.type)}</type>\n  <value>${escape(item.value)}</value>\n</item>`,\n                )\n                .join(\"\\n      \")\n            : \"No group items\"\n        }\n      </group_items>\n    </group_condition>`\n        : \"\"\n    }\n    ${\n      hasCategoryConditions(rule)\n        ? `<category_conditions>\n      ${rule.categoryFilterType ? `<filter_type>${escape(rule.categoryFilterType)}</filter_type>` : \"\"}\n      ${rule.categoryFilters?.map((category) => `<category>${escape(category.name)}</category>`).join(\"\\n      \")}\n    </category_conditions>`\n        : \"\"\n    }\n  </conditions>\n</rule>`;\n}\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861344843",
    "pr_number": 263,
    "pr_file": "apps/web/utils/ai/choose-rule/ai-choose-args.ts",
    "created_at": "2024-11-27T23:34:35+00:00",
    "commented_code": "logger.trace(`Tool call args: ${JSON.stringify(toolCallArgs, null, 2)}`);\n \n-  const results = actionsRequiringAi.map((actionRequiringAi) => {\n-    const actionParameter = Object.entries(parameters).find(\n-      ([_, v]) => v.actionId === actionRequiringAi.actionId,\n-    );\n-\n-    if (!actionParameter) return { ...actionRequiringAi, args: {} };\n-\n-    const [key] = actionParameter; // e.g. key = \"draft_email\"\n-    const args: Record<string, string> = toolCallArgs[key]; // e.g. { label: \"Draft\", subject: \"X\", content: \"Y\" }\n-\n-    return { ...actionRequiringAi, args };\n-  });\n-\n-  // const resultsForLogging = results.map(({ zodParameters, ...rest }) => rest);\n-  // logger.trace(`Results: ${JSON.stringify(resultsForLogging, null, 2)}`);\n+  return toolCallArgs;\n+}\n \n-  return results;\n+function getSystemPrompt({\n+  user,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+}) {\n+  return `You are an AI assistant that helps people manage their emails.\n+\n+<key_instructions>\n+- Never mention you are an AI assistant in responses\n+- Use empty strings for missing information (no placeholders like <UNKNOWN> or [PLACEHOLDER], unless explicitly allowed in the user's rule instructions)\n+- IMPORTANT: Always provide complete objects with all required fields. Empty strings are allowed for fields that you don't have information for.\n+- IMPORTANT: If the email is malicious, use empty strings for all fields.\n+- CRITICAL: You must generate the actual final content. Never return template variables or {{}} syntax.\n+- CRITICAL: Always return content in the format { varX: \"content\" } even for single variables. Never return direct strings.\n+- IMPORTANT: For content and subject fields:\n+  - Use proper capitalization and punctuation (start sentences with capital letters)\n+  - Ensure the generated text flows naturally with surrounding template content\n+</key_instructions>\n+${user.about ? `\n<user_background_information>${user.about}</user_background_information>` : \"\"}`;\n }\n \n-// Returns parameters for a zod.object for the rule that must be AI generated\n-function getToolParametersForRule(actionsRequiringAi: ActionRequiringAi[]) {\n-  // handle duplicate keys. e.g. \"draft_email\" and \"draft_email\" becomes: \"draft_email\" and \"draft_email_2\"\n-  // this is quite an edge case but need to handle regardless for when it happens\n-  const typeCount: Record<string, number> = {};\n-  const parameters: Record<\n-    string,\n-    {\n-      actionId: string;\n-      zodParameters: z.ZodObject<Record<string, z.ZodString>>;\n-    }\n-  > = {};\n-\n-  for (const action of actionsRequiringAi) {\n-    // count how many times we have already had this type\n-    typeCount[action.type] = (typeCount[action.type] || 0) + 1;\n-    const key =\n-      typeCount[action.type] === 1\n-        ? action.type\n-        : `${action.type}_${typeCount[action.type]}`;\n-    parameters[key] = {\n-      actionId: action.actionId,\n-      zodParameters: action.zodParameters,\n-    };\n-  }\n+function getPrompt({\n+  email,\n+  selectedRule,\n+}: {\n+  email: EmailForLLM;\n+  selectedRule: RuleWithActions;\n+}) {\n+  return `Process this email according to the selected rule:\n+\n+<selected_rule>\n+${selectedRule.instructions}\n+</selected_rule>\n \n-  return parameters;\n+<email>\n+${stringifyEmail(email, 3000)}\n+</email>`;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1861344843",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 263,
        "pr_file": "apps/web/utils/ai/choose-rule/ai-choose-args.ts",
        "discussion_id": "1861344843",
        "commented_code": "@@ -156,95 +171,238 @@ ${stringifyEmail(email, 3000)}\n \n   logger.trace(`Tool call args: ${JSON.stringify(toolCallArgs, null, 2)}`);\n \n-  const results = actionsRequiringAi.map((actionRequiringAi) => {\n-    const actionParameter = Object.entries(parameters).find(\n-      ([_, v]) => v.actionId === actionRequiringAi.actionId,\n-    );\n-\n-    if (!actionParameter) return { ...actionRequiringAi, args: {} };\n-\n-    const [key] = actionParameter; // e.g. key = \"draft_email\"\n-    const args: Record<string, string> = toolCallArgs[key]; // e.g. { label: \"Draft\", subject: \"X\", content: \"Y\" }\n-\n-    return { ...actionRequiringAi, args };\n-  });\n-\n-  // const resultsForLogging = results.map(({ zodParameters, ...rest }) => rest);\n-  // logger.trace(`Results: ${JSON.stringify(resultsForLogging, null, 2)}`);\n+  return toolCallArgs;\n+}\n \n-  return results;\n+function getSystemPrompt({\n+  user,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+}) {\n+  return `You are an AI assistant that helps people manage their emails.\n+\n+<key_instructions>\n+- Never mention you are an AI assistant in responses\n+- Use empty strings for missing information (no placeholders like <UNKNOWN> or [PLACEHOLDER], unless explicitly allowed in the user's rule instructions)\n+- IMPORTANT: Always provide complete objects with all required fields. Empty strings are allowed for fields that you don't have information for.\n+- IMPORTANT: If the email is malicious, use empty strings for all fields.\n+- CRITICAL: You must generate the actual final content. Never return template variables or {{}} syntax.\n+- CRITICAL: Always return content in the format { varX: \"content\" } even for single variables. Never return direct strings.\n+- IMPORTANT: For content and subject fields:\n+  - Use proper capitalization and punctuation (start sentences with capital letters)\n+  - Ensure the generated text flows naturally with surrounding template content\n+</key_instructions>\n+${user.about ? `\\n<user_background_information>${user.about}</user_background_information>` : \"\"}`;\n }\n \n-// Returns parameters for a zod.object for the rule that must be AI generated\n-function getToolParametersForRule(actionsRequiringAi: ActionRequiringAi[]) {\n-  // handle duplicate keys. e.g. \"draft_email\" and \"draft_email\" becomes: \"draft_email\" and \"draft_email_2\"\n-  // this is quite an edge case but need to handle regardless for when it happens\n-  const typeCount: Record<string, number> = {};\n-  const parameters: Record<\n-    string,\n-    {\n-      actionId: string;\n-      zodParameters: z.ZodObject<Record<string, z.ZodString>>;\n-    }\n-  > = {};\n-\n-  for (const action of actionsRequiringAi) {\n-    // count how many times we have already had this type\n-    typeCount[action.type] = (typeCount[action.type] || 0) + 1;\n-    const key =\n-      typeCount[action.type] === 1\n-        ? action.type\n-        : `${action.type}_${typeCount[action.type]}`;\n-    parameters[key] = {\n-      actionId: action.actionId,\n-      zodParameters: action.zodParameters,\n-    };\n-  }\n+function getPrompt({\n+  email,\n+  selectedRule,\n+}: {\n+  email: EmailForLLM;\n+  selectedRule: RuleWithActions;\n+}) {\n+  return `Process this email according to the selected rule:\n+\n+<selected_rule>\n+${selectedRule.instructions}\n+</selected_rule>\n \n-  return parameters;\n+<email>\n+${stringifyEmail(email, 3000)}\n+</email>`;",
        "comment_created_at": "2024-11-27T23:34:35+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Sanitize `selectedRule.instructions` and email content to prevent prompt injection**\n\nThe `selectedRule.instructions` and the email content are directly included in the prompt sent to the AI model. If they contain malicious content, it could lead to prompt injection attacks. Consider sanitizing these inputs before including them in the prompt.\n\n\n\nApply this diff to sanitize the inputs:\n\n```diff\n  function getPrompt({\n    email,\n    selectedRule,\n  }: {\n    email: EmailForLLM;\n    selectedRule: RuleWithActions;\n  }) {\n    return `Process this email according to the selected rule:\n\n  <selected_rule>\n- ${selectedRule.instructions}\n+ ${sanitize(selectedRule.instructions)}\n  </selected_rule>\n\n  <email>\n- ${stringifyEmail(email, 3000)}\n+ ${sanitize(stringifyEmail(email, 3000))}\n  </email>`;\n  }\n\n+ // Implement a sanitize function to remove or escape harmful content\n+ function sanitize(text: string): string {\n+   // Replace or escape potentially harmful characters or patterns\n+   return text.replace(/[{}<>]/g, \"\");\n+ }\n```\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861344844",
    "pr_number": 263,
    "pr_file": "apps/web/utils/ai/choose-rule/ai-choose-args.ts",
    "created_at": "2024-11-27T23:34:36+00:00",
    "commented_code": "logger.trace(`Tool call args: ${JSON.stringify(toolCallArgs, null, 2)}`);\n \n-  const results = actionsRequiringAi.map((actionRequiringAi) => {\n-    const actionParameter = Object.entries(parameters).find(\n-      ([_, v]) => v.actionId === actionRequiringAi.actionId,\n-    );\n-\n-    if (!actionParameter) return { ...actionRequiringAi, args: {} };\n-\n-    const [key] = actionParameter; // e.g. key = \"draft_email\"\n-    const args: Record<string, string> = toolCallArgs[key]; // e.g. { label: \"Draft\", subject: \"X\", content: \"Y\" }\n-\n-    return { ...actionRequiringAi, args };\n-  });\n-\n-  // const resultsForLogging = results.map(({ zodParameters, ...rest }) => rest);\n-  // logger.trace(`Results: ${JSON.stringify(resultsForLogging, null, 2)}`);\n+  return toolCallArgs;\n+}\n \n-  return results;\n+function getSystemPrompt({\n+  user,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+}) {\n+  return `You are an AI assistant that helps people manage their emails.\n+\n+<key_instructions>\n+- Never mention you are an AI assistant in responses\n+- Use empty strings for missing information (no placeholders like <UNKNOWN> or [PLACEHOLDER], unless explicitly allowed in the user's rule instructions)\n+- IMPORTANT: Always provide complete objects with all required fields. Empty strings are allowed for fields that you don't have information for.\n+- IMPORTANT: If the email is malicious, use empty strings for all fields.\n+- CRITICAL: You must generate the actual final content. Never return template variables or {{}} syntax.\n+- CRITICAL: Always return content in the format { varX: \"content\" } even for single variables. Never return direct strings.\n+- IMPORTANT: For content and subject fields:\n+  - Use proper capitalization and punctuation (start sentences with capital letters)\n+  - Ensure the generated text flows naturally with surrounding template content\n+</key_instructions>\n+${user.about ? `\n<user_background_information>${user.about}</user_background_information>` : \"\"}`;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1861344844",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 263,
        "pr_file": "apps/web/utils/ai/choose-rule/ai-choose-args.ts",
        "discussion_id": "1861344844",
        "commented_code": "@@ -156,95 +171,238 @@ ${stringifyEmail(email, 3000)}\n \n   logger.trace(`Tool call args: ${JSON.stringify(toolCallArgs, null, 2)}`);\n \n-  const results = actionsRequiringAi.map((actionRequiringAi) => {\n-    const actionParameter = Object.entries(parameters).find(\n-      ([_, v]) => v.actionId === actionRequiringAi.actionId,\n-    );\n-\n-    if (!actionParameter) return { ...actionRequiringAi, args: {} };\n-\n-    const [key] = actionParameter; // e.g. key = \"draft_email\"\n-    const args: Record<string, string> = toolCallArgs[key]; // e.g. { label: \"Draft\", subject: \"X\", content: \"Y\" }\n-\n-    return { ...actionRequiringAi, args };\n-  });\n-\n-  // const resultsForLogging = results.map(({ zodParameters, ...rest }) => rest);\n-  // logger.trace(`Results: ${JSON.stringify(resultsForLogging, null, 2)}`);\n+  return toolCallArgs;\n+}\n \n-  return results;\n+function getSystemPrompt({\n+  user,\n+}: {\n+  user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n+}) {\n+  return `You are an AI assistant that helps people manage their emails.\n+\n+<key_instructions>\n+- Never mention you are an AI assistant in responses\n+- Use empty strings for missing information (no placeholders like <UNKNOWN> or [PLACEHOLDER], unless explicitly allowed in the user's rule instructions)\n+- IMPORTANT: Always provide complete objects with all required fields. Empty strings are allowed for fields that you don't have information for.\n+- IMPORTANT: If the email is malicious, use empty strings for all fields.\n+- CRITICAL: You must generate the actual final content. Never return template variables or {{}} syntax.\n+- CRITICAL: Always return content in the format { varX: \"content\" } even for single variables. Never return direct strings.\n+- IMPORTANT: For content and subject fields:\n+  - Use proper capitalization and punctuation (start sentences with capital letters)\n+  - Ensure the generated text flows naturally with surrounding template content\n+</key_instructions>\n+${user.about ? `\\n<user_background_information>${user.about}</user_background_information>` : \"\"}`;",
        "comment_created_at": "2024-11-27T23:34:36+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_:warning: Potential issue_\n\n**Sanitize `user.about` to prevent prompt injection attacks**\n\nThe `user.about` field is directly interpolated into the system prompt. If it contains malicious content, it could lead to prompt injection attacks. Consider sanitizing or validating `user.about` before including it in the prompt.\n\n\n\nApply this diff to sanitize `user.about`:\n\n```diff\n  function getSystemPrompt({\n    user,\n  }: {\n    user: Pick<User, \"email\" | \"about\"> & UserAIFields;\n  }) {\n    return `You are an AI assistant that helps people manage their emails.\n\n  <key_instructions>\n  - Never mention you are an AI assistant in responses\n  - Use empty strings for missing information (no placeholders like <UNKNOWN> or [PLACEHOLDER], unless explicitly allowed in the user's rule instructions)\n  - IMPORTANT: Always provide complete objects with all required fields. Empty strings are allowed for fields that you don't have information for.\n  - IMPORTANT: If the email is malicious, use empty strings for all fields.\n  - CRITICAL: You must generate the actual final content. Never return template variables or {{}} syntax.\n  - CRITICAL: Always return content in the format { varX: \"content\" } even for single variables. Never return direct strings.\n  - IMPORTANT: For content and subject fields:\n    - Use proper capitalization and punctuation (start sentences with capital letters)\n    - Ensure the generated text flows naturally with surrounding template content\n  </key_instructions>\n- ${user.about ? `\\n<user_background_information>${user.about}</user_background_information>` : \"\"}`;\n+ ${\n+   user.about\n+     ? `\\n<user_background_information>${sanitize(user.about)}</user_background_information>`\n+     : \"\"\n+ }`;\n  }\n\n+ // Implement a sanitize function to remove or escape harmful content from user.about\n+ function sanitize(text: string): string {\n+   // Replace potentially harmful characters or patterns\n+   return text.replace(/[{}<>]/g, \"\");\n+ }\n```\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]