[
  {
    "discussion_id": "2141711794",
    "pr_number": 478,
    "pr_file": "apps/web/utils/frequency.ts",
    "created_at": "2025-06-12T04:54:04+00:00",
    "commented_code": "+import { Frequency } from \"@prisma/client\";\n+import { addDays, setHours, setMinutes } from \"date-fns\";\n+\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+export function calculateNextDigestDate(frequency: {\n+  intervalDays: number | null;\n+  daysOfWeek: number | null;\n+  timeOfDay: Date | null;\n+}) {\n+  const now = new Date();\n+  const targetTime = frequency.timeOfDay || setHours(setMinutes(now, 0), 11); // Default to 11 AM\n+\n+  // Set the target time for today\n+  const todayWithTargetTime = setHours(\n+    setMinutes(now, targetTime.getMinutes()),\n+    targetTime.getHours(),\n+  );\n+\n+  // If we're past today's target time, start from tomorrow\n+  const startDate = now > todayWithTargetTime ? addDays(now, 1) : now;",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2141711794",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/frequency.ts",
        "discussion_id": "2141711794",
        "commented_code": "@@ -0,0 +1,82 @@\n+import { Frequency } from \"@prisma/client\";\n+import { addDays, setHours, setMinutes } from \"date-fns\";\n+\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+export function calculateNextDigestDate(frequency: {\n+  intervalDays: number | null;\n+  daysOfWeek: number | null;\n+  timeOfDay: Date | null;\n+}) {\n+  const now = new Date();\n+  const targetTime = frequency.timeOfDay || setHours(setMinutes(now, 0), 11); // Default to 11 AM\n+\n+  // Set the target time for today\n+  const todayWithTargetTime = setHours(\n+    setMinutes(now, targetTime.getMinutes()),\n+    targetTime.getHours(),\n+  );\n+\n+  // If we're past today's target time, start from tomorrow\n+  const startDate = now > todayWithTargetTime ? addDays(now, 1) : now;",
        "comment_created_at": "2025-06-12T04:54:04+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Seconds / milliseconds leak into scheduled dates**\n\n`setHours(setMinutes(now, 0), 11)` resets minutes but keeps whatever seconds & milliseconds were on `now`, causing non-deterministic firing (e.g., `11:00:37.123`). Same occurs later with `setHours/setMinutes(startDate \u2026)`.\n\n```diff\n-const targetTime = frequency.timeOfDay || setHours(setMinutes(now, 0), 11);\n+const targetTime =\n+  frequency.timeOfDay ??\n+  setMilliseconds(setSeconds(setMinutes(now, 0), 0), 0) |> (d => setHours(d, 11));\n```\n\nDo the same when constructing return values to ensure you always schedule exactly at `HH:MM:00.000`.  \n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/frequency.ts around lines 20 to 29, the code sets target times\nusing setHours and setMinutes but does not reset seconds and milliseconds,\ncausing scheduled dates to include leftover seconds and milliseconds from the\ncurrent time. To fix this, after setting hours and minutes, also reset seconds\nand milliseconds to zero using appropriate functions or methods so that all\nscheduled times are exactly at HH:MM:00.000, ensuring deterministic scheduling.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commit 460f29d",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141761835",
    "pr_number": 478,
    "pr_file": "apps/web/utils/frequency.ts",
    "created_at": "2025-06-12T05:44:16+00:00",
    "commented_code": "+import type { UserFrequency } from \"@prisma/client\";\n+import { addDays } from \"date-fns\";\n+\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+export function calculateNextFrequencyDate(\n+  frequency: Pick<\n+    UserFrequency,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      const slotDate = addDays(intervalStart, Math.round(i * slotLength));\n+      setTime(slotDate);",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2141761835",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/frequency.ts",
        "discussion_id": "2141761835",
        "commented_code": "@@ -0,0 +1,87 @@\n+import type { UserFrequency } from \"@prisma/client\";\n+import { addDays } from \"date-fns\";\n+\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+export function calculateNextFrequencyDate(\n+  frequency: Pick<\n+    UserFrequency,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      const slotDate = addDays(intervalStart, Math.round(i * slotLength));\n+      setTime(slotDate);",
        "comment_created_at": "2025-06-12T05:44:16+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Fractional slot rounding can collapse occurrences**\n\n`slotLength = intervalDays / occurrences` can be non-integer. Using `Math.round(i * slotLength)` may generate identical offsets (e.g. `intervalDays=2`, `occurrences=3` \u21d2 offsets 0, 1, 2).  \nDuplicates break \u201c3\u00d7 per interval\u201d expectation and drift from equal spacing.\n\nCompute offsets with floating-point math and compare full Date-objects instead of rounding to days, or restrict to divisors of `intervalDays`.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/frequency.ts around lines 37 to 47, the calculation of slot\ndates uses Math.round on fractional slot lengths, which can cause duplicate\ndates and break the expected number of occurrences. To fix this, avoid rounding\nthe product of i and slotLength; instead, calculate the exact offset in days as\na floating-point number and add it to the interval start using a function that\nsupports fractional days or time. This ensures each slot is uniquely spaced and\npreserves the correct number of occurrences.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2150137218",
    "pr_number": 478,
    "pr_file": "apps/web/utils/frequency.ts",
    "created_at": "2025-06-16T14:19:38+00:00",
    "commented_code": "+import type { Schedule } from \"@prisma/client\";\n+import { addDays, addMilliseconds } from \"date-fns\";\n+\n+/**\n+ * Bitmask representation of days of the week.\n+ * Each bit represents a day, from Sunday (most significant) to Saturday (least significant).\n+ * Example: 0b1000000 (64) represents Sunday, 0b0100000 (32) represents Monday, etc.\n+ *\n+ * To combine multiple days, use the bitwise OR operator (|):\n+ * SUNDAY | WEDNESDAY = 0b1000000 | 0b0001000 = 0b1001000\n+ */\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+/**\n+ * Converts a JavaScript day of week (0-6, Sunday-Saturday) to its corresponding bitmask.\n+ * @param jsDay - JavaScript day of week (0 = Sunday, 6 = Saturday)\n+ * @returns The bitmask for the given day\n+ */\n+const maskFor = (jsDay: number) => 1 << (6 - jsDay);\n+\n+/**\n+ * Calculates the next occurrence date based on schedule settings.\n+ *\n+ * @param schedule - The schedule configuration\n+ * @param schedule.daysOfWeek - Bitmask of days of the week (see DAYS constant)\n+ * @param schedule.intervalDays - Number of days between occurrences\n+ * @param schedule.timeOfDay - Time of day for the occurrence (if unset, defaults to midnight)\n+ * @param schedule.occurrences - Number of occurrences within the interval\n+ * @param fromDate - The reference date to calculate from (defaults to current date)\n+ * @returns The next occurrence date, or null if no valid pattern is found\n+ */\n+export function calculateNextScheduleDate(\n+  frequency: Pick<\n+    Schedule,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    } else {\n+      // Reset to midnight when no specific time is set\n+      date.setHours(0, 0, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      // Calculate exact offset in milliseconds (slotLength * 24 * 60 * 60 * 1000)\n+      const offsetMs = i * slotLength * 24 * 60 * 60 * 1000;\n+      const slotDate = addMilliseconds(intervalStart, offsetMs);\n+      setTime(slotDate);\n+      if (slotDate >= fromDate) {\n+        return slotDate;\n+      }\n+    }\n+    // If all slots for this interval are in the past, return the first slot of the next interval\n+    const nextIntervalStart = addDays(intervalStart, intervalDays);\n+    setTime(nextIntervalStart);\n+    return nextIntervalStart;\n+  }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2150137218",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/frequency.ts",
        "discussion_id": "2150137218",
        "commented_code": "@@ -0,0 +1,128 @@\n+import type { Schedule } from \"@prisma/client\";\n+import { addDays, addMilliseconds } from \"date-fns\";\n+\n+/**\n+ * Bitmask representation of days of the week.\n+ * Each bit represents a day, from Sunday (most significant) to Saturday (least significant).\n+ * Example: 0b1000000 (64) represents Sunday, 0b0100000 (32) represents Monday, etc.\n+ *\n+ * To combine multiple days, use the bitwise OR operator (|):\n+ * SUNDAY | WEDNESDAY = 0b1000000 | 0b0001000 = 0b1001000\n+ */\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+/**\n+ * Converts a JavaScript day of week (0-6, Sunday-Saturday) to its corresponding bitmask.\n+ * @param jsDay - JavaScript day of week (0 = Sunday, 6 = Saturday)\n+ * @returns The bitmask for the given day\n+ */\n+const maskFor = (jsDay: number) => 1 << (6 - jsDay);\n+\n+/**\n+ * Calculates the next occurrence date based on schedule settings.\n+ *\n+ * @param schedule - The schedule configuration\n+ * @param schedule.daysOfWeek - Bitmask of days of the week (see DAYS constant)\n+ * @param schedule.intervalDays - Number of days between occurrences\n+ * @param schedule.timeOfDay - Time of day for the occurrence (if unset, defaults to midnight)\n+ * @param schedule.occurrences - Number of occurrences within the interval\n+ * @param fromDate - The reference date to calculate from (defaults to current date)\n+ * @returns The next occurrence date, or null if no valid pattern is found\n+ */\n+export function calculateNextScheduleDate(\n+  frequency: Pick<\n+    Schedule,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    } else {\n+      // Reset to midnight when no specific time is set\n+      date.setHours(0, 0, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      // Calculate exact offset in milliseconds (slotLength * 24 * 60 * 60 * 1000)\n+      const offsetMs = i * slotLength * 24 * 60 * 60 * 1000;\n+      const slotDate = addMilliseconds(intervalStart, offsetMs);\n+      setTime(slotDate);\n+      if (slotDate >= fromDate) {\n+        return slotDate;\n+      }\n+    }\n+    // If all slots for this interval are in the past, return the first slot of the next interval\n+    const nextIntervalStart = addDays(intervalStart, intervalDays);\n+    setTime(nextIntervalStart);\n+    return nextIntervalStart;\n+  }",
        "comment_created_at": "2025-06-16T14:19:38+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Fractional-day slot length can drift because the fractional hours are later overwritten**  \n`offsetMs` may include a fractional part (e.g. 8 h for 2.33 days). `setTime()` then stomps the hours/minutes, effectively shifting each slot by `(timeOfDay-midnight) \u2212 fractionalHours`. Over successive intervals this accumulates drift.\n\nTwo options:\n\n1. Round the slot offset to whole days before adding milliseconds;  \n2. Compute the slot date by starting from `intervalStart` + `i * slotLength` **days**, then *only* adjust date parts that aren\u2019t later overwritten.\n\n```diff\n-const offsetMs = i * slotLength * 24 * 60 * 60 * 1000;\n-const slotDate = addMilliseconds(intervalStart, offsetMs);\n+const wholeDays = Math.floor(i * slotLength);\n+const slotDate = addDays(intervalStart, wholeDays);\n```\n\nThis preserves equal spacing while avoiding hidden hour shifts.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  // For interval days pattern (e.g., every 7 days)\n  if (intervalDays) {\n    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n    const slotLength = intervalDays / occ;\n\n    // Find the start of the current interval\n    const intervalStart = new Date(fromDate);\n    intervalStart.setHours(0, 0, 0, 0);\n\n    // Find the next slot\n    for (let i = 0; i < occ; i++) {\n      const wholeDays = Math.floor(i * slotLength);\n      const slotDate = addDays(intervalStart, wholeDays);\n      setTime(slotDate);\n      if (slotDate >= fromDate) {\n        return slotDate;\n      }\n    }\n    // If all slots for this interval are in the past, return the first slot of the next interval\n    const nextIntervalStart = addDays(intervalStart, intervalDays);\n    setTime(nextIntervalStart);\n    return nextIntervalStart;\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/frequency.ts lines 64 to 87, the calculation of slotDate uses\noffsetMs which can have fractional days, but setTime() overwrites the time\nportion causing drift in slot spacing. To fix this, either round the slot offset\nto whole days before converting to milliseconds or compute the slotDate by\nadding i * slotLength days to intervalStart without fractional parts, then\nadjust only the date components that won't be overwritten by setTime(). This\nensures consistent spacing without time shifts.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2150143401",
    "pr_number": 478,
    "pr_file": "apps/web/utils/frequency.ts",
    "created_at": "2025-06-16T14:22:30+00:00",
    "commented_code": "+import type { Schedule } from \"@prisma/client\";\n+import { addDays, addMilliseconds } from \"date-fns\";\n+\n+/**\n+ * Bitmask representation of days of the week.\n+ * Each bit represents a day, from Sunday (most significant) to Saturday (least significant).\n+ * Example: 0b1000000 (64) represents Sunday, 0b0100000 (32) represents Monday, etc.\n+ *\n+ * To combine multiple days, use the bitwise OR operator (|):\n+ * SUNDAY | WEDNESDAY = 0b1000000 | 0b0001000 = 0b1001000\n+ */\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+/**\n+ * Converts a JavaScript day of week (0-6, Sunday-Saturday) to its corresponding bitmask.\n+ * @param jsDay - JavaScript day of week (0 = Sunday, 6 = Saturday)\n+ * @returns The bitmask for the given day\n+ */\n+const maskFor = (jsDay: number) => 1 << (6 - jsDay);\n+\n+/**\n+ * Calculates the next occurrence date based on schedule settings.\n+ *\n+ * @param schedule - The schedule configuration\n+ * @param schedule.daysOfWeek - Bitmask of days of the week (see DAYS constant)\n+ * @param schedule.intervalDays - Number of days between occurrences\n+ * @param schedule.timeOfDay - Time of day for the occurrence (if unset, defaults to midnight)\n+ * @param schedule.occurrences - Number of occurrences within the interval\n+ * @param fromDate - The reference date to calculate from (defaults to current date)\n+ * @returns The next occurrence date, or null if no valid pattern is found\n+ */\n+export function calculateNextScheduleDate(\n+  frequency: Pick<\n+    Schedule,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    } else {\n+      // Reset to midnight when no specific time is set\n+      date.setHours(0, 0, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      // Calculate exact offset in milliseconds (slotLength * 24 * 60 * 60 * 1000)\n+      const offsetMs = i * slotLength * 24 * 60 * 60 * 1000;\n+      const slotDate = addMilliseconds(intervalStart, offsetMs);\n+      setTime(slotDate);\n+      if (slotDate >= fromDate) {\n+        return slotDate;\n+      }\n+    }\n+    // If all slots for this interval are in the past, return the first slot of the next interval\n+    const nextIntervalStart = addDays(intervalStart, intervalDays);\n+    setTime(nextIntervalStart);\n+    return nextIntervalStart;\n+  }\n+\n+  // For weekly pattern with specific days\n+  if (daysOfWeek) {\n+    const currentDayOfWeek = fromDate.getDay();\n+\n+    // Find the next day that matches the pattern, starting from today\n+    let daysToAdd = 0;\n+    while (daysToAdd <= 7) {\n+      const nextDayOfWeek = (currentDayOfWeek + daysToAdd) % 7;\n+      const nextDayMask = maskFor(nextDayOfWeek);\n+\n+      if (daysOfWeek & nextDayMask) {\n+        const nextDate = addDays(fromDate, daysToAdd);\n+\n+        // If timeOfDay is set, set the time\n+        if (timeOfDay) {\n+          const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+          const [hours, minutes] = timeStr.split(\":\").map(Number);\n+          nextDate.setHours(hours, minutes, 0, 0);\n+\n+          // If this is today (daysToAdd === 0) and the time has already passed,\n+          // continue to the next day\n+          if (daysToAdd === 0 && nextDate <= fromDate) {\n+            daysToAdd++;\n+            continue;\n+          }\n+          return nextDate;\n+        }\n+\n+        // Reset time to 00:00:00 when timeOfDay is not set to prevent time drift\n+        nextDate.setHours(0, 0, 0, 0);\n+        return nextDate;\n+      }",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2150143401",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/frequency.ts",
        "discussion_id": "2150143401",
        "commented_code": "@@ -0,0 +1,128 @@\n+import type { Schedule } from \"@prisma/client\";\n+import { addDays, addMilliseconds } from \"date-fns\";\n+\n+/**\n+ * Bitmask representation of days of the week.\n+ * Each bit represents a day, from Sunday (most significant) to Saturday (least significant).\n+ * Example: 0b1000000 (64) represents Sunday, 0b0100000 (32) represents Monday, etc.\n+ *\n+ * To combine multiple days, use the bitwise OR operator (|):\n+ * SUNDAY | WEDNESDAY = 0b1000000 | 0b0001000 = 0b1001000\n+ */\n+export const DAYS = {\n+  SUNDAY: 0b1000000, // 64\n+  MONDAY: 0b0100000, // 32\n+  TUESDAY: 0b0010000, // 16\n+  WEDNESDAY: 0b0001000, // 8\n+  THURSDAY: 0b0000100, // 4\n+  FRIDAY: 0b0000010, // 2\n+  SATURDAY: 0b0000001, // 1\n+};\n+\n+/**\n+ * Converts a JavaScript day of week (0-6, Sunday-Saturday) to its corresponding bitmask.\n+ * @param jsDay - JavaScript day of week (0 = Sunday, 6 = Saturday)\n+ * @returns The bitmask for the given day\n+ */\n+const maskFor = (jsDay: number) => 1 << (6 - jsDay);\n+\n+/**\n+ * Calculates the next occurrence date based on schedule settings.\n+ *\n+ * @param schedule - The schedule configuration\n+ * @param schedule.daysOfWeek - Bitmask of days of the week (see DAYS constant)\n+ * @param schedule.intervalDays - Number of days between occurrences\n+ * @param schedule.timeOfDay - Time of day for the occurrence (if unset, defaults to midnight)\n+ * @param schedule.occurrences - Number of occurrences within the interval\n+ * @param fromDate - The reference date to calculate from (defaults to current date)\n+ * @returns The next occurrence date, or null if no valid pattern is found\n+ */\n+export function calculateNextScheduleDate(\n+  frequency: Pick<\n+    Schedule,\n+    \"intervalDays\" | \"daysOfWeek\" | \"timeOfDay\" | \"occurrences\"\n+  >,\n+  fromDate: Date = new Date(),\n+): Date | null {\n+  if (!frequency) return null;\n+\n+  const { intervalDays, daysOfWeek, timeOfDay, occurrences } = frequency;\n+\n+  // Helper to set the time of day\n+  function setTime(date: Date) {\n+    if (timeOfDay) {\n+      const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+      const [hours, minutes] = timeStr.split(\":\").map(Number);\n+      date.setHours(hours, minutes, 0, 0);\n+    } else {\n+      // Reset to midnight when no specific time is set\n+      date.setHours(0, 0, 0, 0);\n+    }\n+    return date;\n+  }\n+\n+  // For interval days pattern (e.g., every 7 days)\n+  if (intervalDays) {\n+    const occ = occurrences && occurrences > 1 ? occurrences : 1;\n+    const slotLength = intervalDays / occ;\n+\n+    // Find the start of the current interval\n+    const intervalStart = new Date(fromDate);\n+    intervalStart.setHours(0, 0, 0, 0);\n+\n+    // Find the next slot\n+    for (let i = 0; i < occ; i++) {\n+      // Calculate exact offset in milliseconds (slotLength * 24 * 60 * 60 * 1000)\n+      const offsetMs = i * slotLength * 24 * 60 * 60 * 1000;\n+      const slotDate = addMilliseconds(intervalStart, offsetMs);\n+      setTime(slotDate);\n+      if (slotDate >= fromDate) {\n+        return slotDate;\n+      }\n+    }\n+    // If all slots for this interval are in the past, return the first slot of the next interval\n+    const nextIntervalStart = addDays(intervalStart, intervalDays);\n+    setTime(nextIntervalStart);\n+    return nextIntervalStart;\n+  }\n+\n+  // For weekly pattern with specific days\n+  if (daysOfWeek) {\n+    const currentDayOfWeek = fromDate.getDay();\n+\n+    // Find the next day that matches the pattern, starting from today\n+    let daysToAdd = 0;\n+    while (daysToAdd <= 7) {\n+      const nextDayOfWeek = (currentDayOfWeek + daysToAdd) % 7;\n+      const nextDayMask = maskFor(nextDayOfWeek);\n+\n+      if (daysOfWeek & nextDayMask) {\n+        const nextDate = addDays(fromDate, daysToAdd);\n+\n+        // If timeOfDay is set, set the time\n+        if (timeOfDay) {\n+          const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n+          const [hours, minutes] = timeStr.split(\":\").map(Number);\n+          nextDate.setHours(hours, minutes, 0, 0);\n+\n+          // If this is today (daysToAdd === 0) and the time has already passed,\n+          // continue to the next day\n+          if (daysToAdd === 0 && nextDate <= fromDate) {\n+            daysToAdd++;\n+            continue;\n+          }\n+          return nextDate;\n+        }\n+\n+        // Reset time to 00:00:00 when timeOfDay is not set to prevent time drift\n+        nextDate.setHours(0, 0, 0, 0);\n+        return nextDate;\n+      }",
        "comment_created_at": "2025-06-16T14:22:30+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**`timeOfDay == null` path can return a date **before** `fromDate`**  \nWhen `timeOfDay` is undefined and today\u2019s weekday matches the mask, the function returns `today 00:00:00`, even if `fromDate` is already later today.  \nThat schedules an occurrence in the past and can cause the caller to loop forever or fire immediately.\n\n```diff\n-        // Reset time to 00:00:00 when timeOfDay is not set to prevent time drift\n-        nextDate.setHours(0, 0, 0, 0);\n-        return nextDate;\n+        // Reset time to 00:00:00 when timeOfDay is not set to prevent time drift\n+        nextDate.setHours(0, 0, 0, 0);\n+        // If this is today and midnight has already passed, skip to next valid day\n+        if (daysToAdd === 0 && nextDate < fromDate) {\n+          daysToAdd++;\n+          continue;\n+        }\n+        return nextDate;\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    let daysToAdd = 0;\n    while (daysToAdd <= 7) {\n      const nextDayOfWeek = (currentDayOfWeek + daysToAdd) % 7;\n      const nextDayMask = maskFor(nextDayOfWeek);\n\n      if (daysOfWeek & nextDayMask) {\n        const nextDate = addDays(fromDate, daysToAdd);\n\n        // If timeOfDay is set, set the time\n        if (timeOfDay) {\n          const timeStr = timeOfDay.toTimeString().split(\" \")[0];\n          const [hours, minutes] = timeStr.split(\":\").map(Number);\n          nextDate.setHours(hours, minutes, 0, 0);\n\n          // If this is today (daysToAdd === 0) and the time has already passed,\n          // continue to the next day\n          if (daysToAdd === 0 && nextDate <= fromDate) {\n            daysToAdd++;\n            continue;\n          }\n          return nextDate;\n        }\n\n        // Reset time to 00:00:00 when timeOfDay is not set to prevent time drift\n        nextDate.setHours(0, 0, 0, 0);\n        // If this is today and midnight has already passed, skip to next valid day\n        if (daysToAdd === 0 && nextDate < fromDate) {\n          daysToAdd++;\n          continue;\n        }\n        return nextDate;\n      }\n\n      daysToAdd++;\n    }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn apps/web/utils/frequency.ts around lines 94 to 120, when timeOfDay is not\nset, the function can return a date at today 00:00:00 even if fromDate is later\nthe same day, causing scheduling in the past. To fix this, add a check when\ndaysToAdd is 0 and timeOfDay is undefined: if the computed nextDate at midnight\nis less than or equal to fromDate, increment daysToAdd and continue the loop to\nfind the next valid future date.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1991346460",
    "pr_number": 370,
    "pr_file": "apps/web/utils/parse/calender-event.ts",
    "created_at": "2025-03-12T12:02:48+00:00",
    "commented_code": "+import type { ParsedMessage } from \"@/utils/types\";\n+\n+interface CalendarEventInfo {\n+  isCalendarEvent: boolean;\n+  eventDate?: Date | null;\n+  eventDateString?: string;\n+  recurringEvent?: boolean;\n+  startDate?: Date | null;\n+  endDate?: Date | null;\n+  eventTitle?: string;\n+  organizer?: string;\n+}\n+\n+export type CalendarEventStatus = {\n+  isEvent: boolean;\n+  timing?: \"past\" | \"future\";\n+};\n+\n+/**\n+ * Checks if an email is a calendar event and extracts event date information\n+ * @param email The email to analyze\n+ * @returns Information about the calendar event\n+ */\n+export function analyzeCalendarEvent(email: ParsedMessage): CalendarEventInfo {\n+  const result: CalendarEventInfo = {\n+    isCalendarEvent: false,\n+  };\n+\n+  // Check subject for calendar event indicators\n+  const subject = email.headers.subject || \"\";\n+  const calendarKeywords = [\n+    \"invitation\",\n+    \"calendar\",\n+    \"event\",\n+    \"meeting\",\n+    \"appointment\",\n+    \"scheduled\",\n+    \"invite\",\n+    \"calendar event\",\n+    \"reminder\",\n+  ];\n+\n+  // Check if subject contains calendar keywords\n+  const hasCalendarSubject = calendarKeywords.some((keyword) =>\n+    subject.toLowerCase().includes(keyword.toLowerCase()),\n+  );\n+\n+  // Check body for calendar event indicators\n+  const body = email.textHtml || \"\";\n+\n+  // Check for iCalendar data\n+  const hasiCalData =\n+    body.includes(\"BEGIN:VCALENDAR\") ||\n+    body.includes(\"BEGIN:VEVENT\") ||\n+    body.includes(\"method=REQUEST\");\n+\n+  // Check for Google Calendar links\n+  const hasGoogleCalendarLinks = body.includes(\n+    \"calendar.google.com/calendar/event\",\n+  );\n+\n+  // Check for \"RSVP\" indicators\n+  const hasRSVP =\n+    body.includes(\"RSVP\") ||\n+    (body.includes(\"Yes\") && body.includes(\"No\") && body.includes(\"Maybe\"));\n+\n+  // Check for calendar providers\n+  const hasCalendarProviders =\n+    body.includes(\"Google Calendar\") ||\n+    body.includes(\"Outlook Calendar\") ||\n+    body.includes(\"Apple Calendar\");\n+\n+  // Determine if it's a calendar event based on checks\n+  result.isCalendarEvent =\n+    hasCalendarSubject ||\n+    hasiCalData ||\n+    hasGoogleCalendarLinks ||\n+    hasRSVP ||\n+    hasCalendarProviders;\n+\n+  if (result.isCalendarEvent) {\n+    // Extract event title\n+    if (\n+      subject.includes(\"Updated invitation:\") ||\n+      subject.includes(\"invitation:\") ||\n+      subject.includes(\"invite:\")\n+    ) {\n+      let title = subject\n+        .replace(\"Updated invitation:\", \"\")\n+        .replace(\"invitation:\", \"\")\n+        .replace(\"invite:\", \"\")\n+        .trim();\n+\n+      // If there's schedule information after \"@\", take only the event name\n+      if (title.includes(\"@\")) {\n+        title = title.split(\"@\")[0].trim();\n+      }\n+\n+      result.eventTitle = title;\n+    } else {\n+      result.eventTitle = subject;\n+    }\n+\n+    // Extract organizer\n+    const organizerMatch =\n+      body.match(\n+        /Organiser[\\s\\S]*?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i,\n+      ) ||\n+      body.match(\n+        /Organizer[\\s\\S]*?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i,\n+      );\n+    result.organizer = organizerMatch?.[1];\n+\n+    // Look for date patterns in the body\n+    result.recurringEvent =\n+      body.includes(\"Weekly\") ||\n+      body.includes(\"RRULE:FREQ=\") ||\n+      body.includes(\"recurring\");\n+\n+    // Extract dates from common patterns in email body\n+    const datePatterns = [\n+      // Pattern for full date with time: \"Monday 10 Feb to Monday 3 Mar\"\n+      /(?:from|on)\\s+(?:Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)?)\\s+(\\d{1,2})\\s+(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)/i,\n+\n+      // Pattern for ISO date in iCalendar data: DTSTART, DTEND, etc.\n+      /DTSTART(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+\n+      // Pattern for datetime strings\n+      /(\\d{1,2})\\s+(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\s+(\\d{4})\\s+at\\s+(\\d{1,2}):(\\d{2})/i,\n+    ];\n+\n+    // Try to find date using the patterns\n+    let dateMatch = null;\n+    for (const pattern of datePatterns) {\n+      const match = body.match(pattern);\n+      if (match) {\n+        dateMatch = match;\n+        break;\n+      }\n+    }\n+\n+    // Process iCalendar dates if present\n+    const dtStartMatch = body.match(\n+      /DTSTART(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+    );\n+    if (dtStartMatch) {\n+      const [_, year, month, day, hour, minute, second] = dtStartMatch;\n+      result.startDate = new Date(\n+        Number.parseInt(year),\n+        Number.parseInt(month) - 1, // JavaScript months are 0-indexed\n+        Number.parseInt(day),\n+        Number.parseInt(hour),\n+        Number.parseInt(minute),\n+        Number.parseInt(second),\n+      );\n+\n+      // Also look for end date\n+      const dtEndMatch = body.match(\n+        /DTEND(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+      );\n+      if (dtEndMatch) {\n+        const [_, yearEnd, monthEnd, dayEnd, hourEnd, minuteEnd, secondEnd] =\n+          dtEndMatch;\n+        result.endDate = new Date(\n+          Number.parseInt(yearEnd),\n+          Number.parseInt(monthEnd) - 1,\n+          Number.parseInt(dayEnd),\n+          Number.parseInt(hourEnd),\n+          Number.parseInt(minuteEnd),\n+          Number.parseInt(secondEnd),\n+        );\n+      }\n+\n+      // Set the event date\n+      result.eventDate = result.startDate;\n+      result.eventDateString = result.eventDate.toLocaleString();\n+    }\n+    // If we didn't find an iCalendar date but found text description of date\n+    else if (dateMatch) {\n+      // For text patterns like \"Monday 10 Feb\"\n+      const monthNames = [\n+        \"january\",\n+        \"february\",\n+        \"march\",\n+        \"april\",\n+        \"may\",\n+        \"june\",\n+        \"july\",\n+        \"august\",\n+        \"september\",\n+        \"october\",\n+        \"november\",\n+        \"december\",\n+        \"jan\",\n+        \"feb\",\n+        \"mar\",\n+        \"apr\",\n+        \"may\",\n+        \"jun\",\n+        \"jul\",\n+        \"aug\",\n+        \"sep\",\n+        \"oct\",\n+        \"nov\",\n+        \"dec\",\n+      ];\n+\n+      // This is a simplistic approach - for production code, you'd want more robust parsing\n+      const day = dateMatch[1];\n+      const monthText = dateMatch[2].toLowerCase();\n+\n+      // Determine month number (0-11)\n+      let month = monthNames.indexOf(monthText) % 12;\n+      if (month === -1) month = 0; // Default to January if not found\n+",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "1991346460",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 370,
        "pr_file": "apps/web/utils/parse/calender-event.ts",
        "discussion_id": "1991346460",
        "commented_code": "@@ -0,0 +1,290 @@\n+import type { ParsedMessage } from \"@/utils/types\";\n+\n+interface CalendarEventInfo {\n+  isCalendarEvent: boolean;\n+  eventDate?: Date | null;\n+  eventDateString?: string;\n+  recurringEvent?: boolean;\n+  startDate?: Date | null;\n+  endDate?: Date | null;\n+  eventTitle?: string;\n+  organizer?: string;\n+}\n+\n+export type CalendarEventStatus = {\n+  isEvent: boolean;\n+  timing?: \"past\" | \"future\";\n+};\n+\n+/**\n+ * Checks if an email is a calendar event and extracts event date information\n+ * @param email The email to analyze\n+ * @returns Information about the calendar event\n+ */\n+export function analyzeCalendarEvent(email: ParsedMessage): CalendarEventInfo {\n+  const result: CalendarEventInfo = {\n+    isCalendarEvent: false,\n+  };\n+\n+  // Check subject for calendar event indicators\n+  const subject = email.headers.subject || \"\";\n+  const calendarKeywords = [\n+    \"invitation\",\n+    \"calendar\",\n+    \"event\",\n+    \"meeting\",\n+    \"appointment\",\n+    \"scheduled\",\n+    \"invite\",\n+    \"calendar event\",\n+    \"reminder\",\n+  ];\n+\n+  // Check if subject contains calendar keywords\n+  const hasCalendarSubject = calendarKeywords.some((keyword) =>\n+    subject.toLowerCase().includes(keyword.toLowerCase()),\n+  );\n+\n+  // Check body for calendar event indicators\n+  const body = email.textHtml || \"\";\n+\n+  // Check for iCalendar data\n+  const hasiCalData =\n+    body.includes(\"BEGIN:VCALENDAR\") ||\n+    body.includes(\"BEGIN:VEVENT\") ||\n+    body.includes(\"method=REQUEST\");\n+\n+  // Check for Google Calendar links\n+  const hasGoogleCalendarLinks = body.includes(\n+    \"calendar.google.com/calendar/event\",\n+  );\n+\n+  // Check for \"RSVP\" indicators\n+  const hasRSVP =\n+    body.includes(\"RSVP\") ||\n+    (body.includes(\"Yes\") && body.includes(\"No\") && body.includes(\"Maybe\"));\n+\n+  // Check for calendar providers\n+  const hasCalendarProviders =\n+    body.includes(\"Google Calendar\") ||\n+    body.includes(\"Outlook Calendar\") ||\n+    body.includes(\"Apple Calendar\");\n+\n+  // Determine if it's a calendar event based on checks\n+  result.isCalendarEvent =\n+    hasCalendarSubject ||\n+    hasiCalData ||\n+    hasGoogleCalendarLinks ||\n+    hasRSVP ||\n+    hasCalendarProviders;\n+\n+  if (result.isCalendarEvent) {\n+    // Extract event title\n+    if (\n+      subject.includes(\"Updated invitation:\") ||\n+      subject.includes(\"invitation:\") ||\n+      subject.includes(\"invite:\")\n+    ) {\n+      let title = subject\n+        .replace(\"Updated invitation:\", \"\")\n+        .replace(\"invitation:\", \"\")\n+        .replace(\"invite:\", \"\")\n+        .trim();\n+\n+      // If there's schedule information after \"@\", take only the event name\n+      if (title.includes(\"@\")) {\n+        title = title.split(\"@\")[0].trim();\n+      }\n+\n+      result.eventTitle = title;\n+    } else {\n+      result.eventTitle = subject;\n+    }\n+\n+    // Extract organizer\n+    const organizerMatch =\n+      body.match(\n+        /Organiser[\\s\\S]*?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i,\n+      ) ||\n+      body.match(\n+        /Organizer[\\s\\S]*?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/i,\n+      );\n+    result.organizer = organizerMatch?.[1];\n+\n+    // Look for date patterns in the body\n+    result.recurringEvent =\n+      body.includes(\"Weekly\") ||\n+      body.includes(\"RRULE:FREQ=\") ||\n+      body.includes(\"recurring\");\n+\n+    // Extract dates from common patterns in email body\n+    const datePatterns = [\n+      // Pattern for full date with time: \"Monday 10 Feb to Monday 3 Mar\"\n+      /(?:from|on)\\s+(?:Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)?)\\s+(\\d{1,2})\\s+(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)/i,\n+\n+      // Pattern for ISO date in iCalendar data: DTSTART, DTEND, etc.\n+      /DTSTART(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+\n+      // Pattern for datetime strings\n+      /(\\d{1,2})\\s+(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\\s+(\\d{4})\\s+at\\s+(\\d{1,2}):(\\d{2})/i,\n+    ];\n+\n+    // Try to find date using the patterns\n+    let dateMatch = null;\n+    for (const pattern of datePatterns) {\n+      const match = body.match(pattern);\n+      if (match) {\n+        dateMatch = match;\n+        break;\n+      }\n+    }\n+\n+    // Process iCalendar dates if present\n+    const dtStartMatch = body.match(\n+      /DTSTART(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+    );\n+    if (dtStartMatch) {\n+      const [_, year, month, day, hour, minute, second] = dtStartMatch;\n+      result.startDate = new Date(\n+        Number.parseInt(year),\n+        Number.parseInt(month) - 1, // JavaScript months are 0-indexed\n+        Number.parseInt(day),\n+        Number.parseInt(hour),\n+        Number.parseInt(minute),\n+        Number.parseInt(second),\n+      );\n+\n+      // Also look for end date\n+      const dtEndMatch = body.match(\n+        /DTEND(?:;TZID=[^:]+)?:(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})/i,\n+      );\n+      if (dtEndMatch) {\n+        const [_, yearEnd, monthEnd, dayEnd, hourEnd, minuteEnd, secondEnd] =\n+          dtEndMatch;\n+        result.endDate = new Date(\n+          Number.parseInt(yearEnd),\n+          Number.parseInt(monthEnd) - 1,\n+          Number.parseInt(dayEnd),\n+          Number.parseInt(hourEnd),\n+          Number.parseInt(minuteEnd),\n+          Number.parseInt(secondEnd),\n+        );\n+      }\n+\n+      // Set the event date\n+      result.eventDate = result.startDate;\n+      result.eventDateString = result.eventDate.toLocaleString();\n+    }\n+    // If we didn't find an iCalendar date but found text description of date\n+    else if (dateMatch) {\n+      // For text patterns like \"Monday 10 Feb\"\n+      const monthNames = [\n+        \"january\",\n+        \"february\",\n+        \"march\",\n+        \"april\",\n+        \"may\",\n+        \"june\",\n+        \"july\",\n+        \"august\",\n+        \"september\",\n+        \"october\",\n+        \"november\",\n+        \"december\",\n+        \"jan\",\n+        \"feb\",\n+        \"mar\",\n+        \"apr\",\n+        \"may\",\n+        \"jun\",\n+        \"jul\",\n+        \"aug\",\n+        \"sep\",\n+        \"oct\",\n+        \"nov\",\n+        \"dec\",\n+      ];\n+\n+      // This is a simplistic approach - for production code, you'd want more robust parsing\n+      const day = dateMatch[1];\n+      const monthText = dateMatch[2].toLowerCase();\n+\n+      // Determine month number (0-11)\n+      let month = monthNames.indexOf(monthText) % 12;\n+      if (month === -1) month = 0; // Default to January if not found\n+",
        "comment_created_at": "2025-03-12T12:02:48+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Fix potential bug in month calculation.**\n\nThe modulo operation could lead to incorrect month determination.\n\n\n```diff\n- let month = monthNames.indexOf(monthText) % 12;\n- if (month === -1) month = 0; // Default to January if not found\n+ let month = monthNames.indexOf(monthText);\n+ if (month >= 12) month -= 12; // Adjust for short month names (index 12-23)\n+ if (month === -1) month = 0; // Default to January if not found\n```\n\nThe current logic applies modulo 12 to the index, but this approach doesn't properly handle the case when the month isn't found (returns -1), resulting in month = -1 % 12 = -1, which then gets corrected to 0. A more direct approach would be clearer.\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n      // Determine month number (0-11)\n      let month = monthNames.indexOf(monthText);\n      if (month >= 12) month -= 12; // Adjust for short month names (index 12-23)\n      if (month === -1) month = 0; // Default to January if not found\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]