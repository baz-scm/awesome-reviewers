[
  {
    "discussion_id": "2141672661",
    "pr_number": 478,
    "pr_file": "apps/web/utils/digest/index.ts",
    "created_at": "2025-06-12T04:07:17+00:00",
    "commented_code": "+import { env } from \"@/env\";\n+import { publishToQstashQueue } from \"@/utils/upstash\";\n+import { getCronSecretHeader } from \"@/utils/cron\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import prisma from \"@/utils/prisma\";\n+import type { DigestBody } from \"@/app/api/ai/digest/validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import type { DigestEmailSummarySchema } from \"@/app/api/resend/digest/validation\";\n+import type { EmailForAction } from \"@/utils/ai/types\";\n+\n+const logger = createScopedLogger(\"digest\");\n+\n+export async function enqueueDigestItem({\n+  email,\n+  emailAccountId,\n+  actionId,\n+  coldEmailId,\n+}: {\n+  email: EmailForAction;\n+  emailAccountId: string;\n+  actionId?: string;\n+  coldEmailId?: string;\n+}) {\n+  const url = `${env.NEXT_PUBLIC_BASE_URL}/api/ai/digest`;\n+  try {\n+    await publishToQstashQueue<DigestBody>({\n+      queueName: \"digest-item-summarize\",\n+      parallelism: 3, // Allow up to 3 concurrent jobs from this queue\n+      url,\n+      body: {\n+        emailAccountId,\n+        actionId,\n+        coldEmailId,\n+        message: {\n+          id: email.id,\n+          threadId: email.threadId,\n+          from: email.headers.from,\n+          to: email.headers.to,\n+          subject: email.headers.subject,\n+          content: email.textPlain || \"\",\n+        },\n+      },\n+      headers: getCronSecretHeader(),\n+    });\n+  } catch (error) {\n+    logger.error(\"Failed to publish to Qstash\", {\n+      emailAccountId,\n+      error,\n+    });\n+  }\n+}\n+\n+async function findOldestUnsentDigest(emailAccountId: string) {\n+  return prisma.digest.findFirst({\n+    where: {\n+      emailAccountId,\n+      status: DigestStatus.PENDING,\n+    },\n+    orderBy: {\n+      createdAt: \"asc\",\n+    },\n+  });\n+}\n+\n+export async function upsertDigest({\n+  messageId,\n+  threadId,\n+  emailAccountId,\n+  actionId,\n+  coldEmailId,\n+  content,\n+}: {\n+  messageId: string;\n+  threadId: string;\n+  emailAccountId: string;\n+  actionId?: string;\n+  coldEmailId?: string;\n+  content: DigestEmailSummarySchema;\n+}) {\n+  const logger = createScopedLogger(\"upsert-digest\").with({\n+    messageId,\n+    threadId,\n+    emailAccountId,\n+    actionId,\n+    coldEmailId,\n+  });\n+\n+  try {\n+    await prisma.$transaction(async (tx) => {\n+      // Find or create the digest atomically\n+      const digest =\n+        (await tx.digest.findFirst({\n+          where: {\n+            emailAccountId,\n+            status: DigestStatus.PENDING,\n+          },\n+          orderBy: {\n+            createdAt: \"asc\",\n+          },\n+        })) ||\n+        (await tx.digest.create({\n+          data: {\n+            emailAccountId,\n+            status: DigestStatus.PENDING,\n+          },\n+        }));",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2141678988",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/digest/index.ts",
        "discussion_id": "2141672661",
        "commented_code": "@@ -0,0 +1,147 @@\n+import { env } from \"@/env\";\n+import { publishToQstashQueue } from \"@/utils/upstash\";\n+import { getCronSecretHeader } from \"@/utils/cron\";\n+import { createScopedLogger } from \"@/utils/logger\";\n+import prisma from \"@/utils/prisma\";\n+import type { DigestBody } from \"@/app/api/ai/digest/validation\";\n+import { DigestStatus } from \"@prisma/client\";\n+import type { DigestEmailSummarySchema } from \"@/app/api/resend/digest/validation\";\n+import type { EmailForAction } from \"@/utils/ai/types\";\n+\n+const logger = createScopedLogger(\"digest\");\n+\n+export async function enqueueDigestItem({\n+  email,\n+  emailAccountId,\n+  actionId,\n+  coldEmailId,\n+}: {\n+  email: EmailForAction;\n+  emailAccountId: string;\n+  actionId?: string;\n+  coldEmailId?: string;\n+}) {\n+  const url = `${env.NEXT_PUBLIC_BASE_URL}/api/ai/digest`;\n+  try {\n+    await publishToQstashQueue<DigestBody>({\n+      queueName: \"digest-item-summarize\",\n+      parallelism: 3, // Allow up to 3 concurrent jobs from this queue\n+      url,\n+      body: {\n+        emailAccountId,\n+        actionId,\n+        coldEmailId,\n+        message: {\n+          id: email.id,\n+          threadId: email.threadId,\n+          from: email.headers.from,\n+          to: email.headers.to,\n+          subject: email.headers.subject,\n+          content: email.textPlain || \"\",\n+        },\n+      },\n+      headers: getCronSecretHeader(),\n+    });\n+  } catch (error) {\n+    logger.error(\"Failed to publish to Qstash\", {\n+      emailAccountId,\n+      error,\n+    });\n+  }\n+}\n+\n+async function findOldestUnsentDigest(emailAccountId: string) {\n+  return prisma.digest.findFirst({\n+    where: {\n+      emailAccountId,\n+      status: DigestStatus.PENDING,\n+    },\n+    orderBy: {\n+      createdAt: \"asc\",\n+    },\n+  });\n+}\n+\n+export async function upsertDigest({\n+  messageId,\n+  threadId,\n+  emailAccountId,\n+  actionId,\n+  coldEmailId,\n+  content,\n+}: {\n+  messageId: string;\n+  threadId: string;\n+  emailAccountId: string;\n+  actionId?: string;\n+  coldEmailId?: string;\n+  content: DigestEmailSummarySchema;\n+}) {\n+  const logger = createScopedLogger(\"upsert-digest\").with({\n+    messageId,\n+    threadId,\n+    emailAccountId,\n+    actionId,\n+    coldEmailId,\n+  });\n+\n+  try {\n+    await prisma.$transaction(async (tx) => {\n+      // Find or create the digest atomically\n+      const digest =\n+        (await tx.digest.findFirst({\n+          where: {\n+            emailAccountId,\n+            status: DigestStatus.PENDING,\n+          },\n+          orderBy: {\n+            createdAt: \"asc\",\n+          },\n+        })) ||\n+        (await tx.digest.create({\n+          data: {\n+            emailAccountId,\n+            status: DigestStatus.PENDING,\n+          },\n+        }));",
        "comment_created_at": "2025-06-12T04:14:21+00:00",
        "comment_author": "edulelis",
        "comment_body": "Unsupported by Prisma",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2147632316",
    "pr_number": 478,
    "pr_file": "apps/web/utils/actions/settings.ts",
    "created_at": "2025-06-15T11:35:48+00:00",
    "commented_code": "ctx: { userId },\n       parsedInput: { aiProvider, aiModel, aiApiKey },\n     }) => {\n-      await prisma.user.update({\n-        where: { id: userId },\n-        data:\n-          aiProvider === DEFAULT_PROVIDER\n-            ? { aiProvider: null, aiModel: null, aiApiKey: null }\n-            : { aiProvider, aiModel, aiApiKey },\n-      });\n+      try {\n+        await prisma.user.update({\n+          where: { id: userId },\n+          data: {\n+            aiProvider: aiProvider || DEFAULT_PROVIDER,\n+            aiModel,\n+            aiApiKey,\n+          },\n+        });\n+\n+        return { success: true };\n+      } catch (error) {\n+        return { serverError: \"Failed to update settings\" };\n+      }\n+    },\n+  );\n+\n+export const updateDigestFrequencyAction = actionClient\n+  .metadata({ name: \"updateDigestFrequency\" })\n+  .schema(saveDigestFrequencyBody)\n+  .action(\n+    async ({ ctx: { emailAccountId }, parsedInput: { userFrequency } }) => {\n+      try {\n+        const emailAccount = await prisma.emailAccount.findUnique({\n+          where: { id: emailAccountId },\n+          include: { digestFrequency: true },\n+        });\n+\n+        if (!emailAccount) {\n+          return { serverError: \"Email account not found\" };\n+        }\n+\n+        await prisma.$transaction(async (tx) => {",
    "repo_full_name": "elie222/inbox-zero",
    "discussion_comments": [
      {
        "comment_id": "2147632316",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/actions/settings.ts",
        "discussion_id": "2147632316",
        "commented_code": "@@ -34,12 +37,86 @@ export const updateAiSettingsAction = actionClientUser\n       ctx: { userId },\n       parsedInput: { aiProvider, aiModel, aiApiKey },\n     }) => {\n-      await prisma.user.update({\n-        where: { id: userId },\n-        data:\n-          aiProvider === DEFAULT_PROVIDER\n-            ? { aiProvider: null, aiModel: null, aiApiKey: null }\n-            : { aiProvider, aiModel, aiApiKey },\n-      });\n+      try {\n+        await prisma.user.update({\n+          where: { id: userId },\n+          data: {\n+            aiProvider: aiProvider || DEFAULT_PROVIDER,\n+            aiModel,\n+            aiApiKey,\n+          },\n+        });\n+\n+        return { success: true };\n+      } catch (error) {\n+        return { serverError: \"Failed to update settings\" };\n+      }\n+    },\n+  );\n+\n+export const updateDigestFrequencyAction = actionClient\n+  .metadata({ name: \"updateDigestFrequency\" })\n+  .schema(saveDigestFrequencyBody)\n+  .action(\n+    async ({ ctx: { emailAccountId }, parsedInput: { userFrequency } }) => {\n+      try {\n+        const emailAccount = await prisma.emailAccount.findUnique({\n+          where: { id: emailAccountId },\n+          include: { digestFrequency: true },\n+        });\n+\n+        if (!emailAccount) {\n+          return { serverError: \"Email account not found\" };\n+        }\n+\n+        await prisma.$transaction(async (tx) => {",
        "comment_created_at": "2025-06-15T11:35:48+00:00",
        "comment_author": "elie222",
        "comment_body": "i prefer not to use this form of transaction unless absolutely needed. prefer to use array instead:\r\n\r\n```\r\n$transaction([...])\r\n```\r\n\r\n1. Warning against them here: https://www.prisma.io/docs/orm/prisma-client/queries/transactions#interactive-transactions\r\n2. Will force us to use Websockets if we want to use this: https://neon.com/docs/serverless/serverless-driver\r\n\r\nIn general we can almost always use non-interactive transactions so I'd default to that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2150052278",
        "repo_full_name": "elie222/inbox-zero",
        "pr_number": 478,
        "pr_file": "apps/web/utils/actions/settings.ts",
        "discussion_id": "2147632316",
        "commented_code": "@@ -34,12 +37,86 @@ export const updateAiSettingsAction = actionClientUser\n       ctx: { userId },\n       parsedInput: { aiProvider, aiModel, aiApiKey },\n     }) => {\n-      await prisma.user.update({\n-        where: { id: userId },\n-        data:\n-          aiProvider === DEFAULT_PROVIDER\n-            ? { aiProvider: null, aiModel: null, aiApiKey: null }\n-            : { aiProvider, aiModel, aiApiKey },\n-      });\n+      try {\n+        await prisma.user.update({\n+          where: { id: userId },\n+          data: {\n+            aiProvider: aiProvider || DEFAULT_PROVIDER,\n+            aiModel,\n+            aiApiKey,\n+          },\n+        });\n+\n+        return { success: true };\n+      } catch (error) {\n+        return { serverError: \"Failed to update settings\" };\n+      }\n+    },\n+  );\n+\n+export const updateDigestFrequencyAction = actionClient\n+  .metadata({ name: \"updateDigestFrequency\" })\n+  .schema(saveDigestFrequencyBody)\n+  .action(\n+    async ({ ctx: { emailAccountId }, parsedInput: { userFrequency } }) => {\n+      try {\n+        const emailAccount = await prisma.emailAccount.findUnique({\n+          where: { id: emailAccountId },\n+          include: { digestFrequency: true },\n+        });\n+\n+        if (!emailAccount) {\n+          return { serverError: \"Email account not found\" };\n+        }\n+\n+        await prisma.$transaction(async (tx) => {",
        "comment_created_at": "2025-06-16T13:45:05+00:00",
        "comment_author": "edulelis",
        "comment_body": "Most of these are not a must, so I removed them.\r\nThese were CodeRabbit suggestions.",
        "pr_file_module": null
      }
    ]
  }
]