[
  {
    "discussion_id": "1922550584",
    "pr_number": 25856,
    "pr_file": "influxdb3_wal/wal.md",
    "created_at": "2025-01-20T15:14:03+00:00",
    "commented_code": "+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```",
    "repo_full_name": "influxdata/influxdb",
    "discussion_comments": [
      {
        "comment_id": "1922550584",
        "repo_full_name": "influxdata/influxdb",
        "pr_number": 25856,
        "pr_file": "influxdb3_wal/wal.md",
        "discussion_id": "1922550584",
        "commented_code": "@@ -0,0 +1,214 @@\n+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```",
        "comment_created_at": "2025-01-20T15:14:03+00:00",
        "comment_author": "hiltontj",
        "comment_body": "A useful addition to this diagram would be to show the entry point for writes from user, i.e., where do writes go from the user (`wal buffer`?), via an arrow. Otherwise, it is not clear on the order of operations. If you could connect the numbers from the steps described below to locations / arrows on the diagram, that would be helpful.",
        "pr_file_module": null
      },
      {
        "comment_id": "1922654576",
        "repo_full_name": "influxdata/influxdb",
        "pr_number": 25856,
        "pr_file": "influxdb3_wal/wal.md",
        "discussion_id": "1922550584",
        "commented_code": "@@ -0,0 +1,214 @@\n+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```",
        "comment_created_at": "2025-01-20T16:39:22+00:00",
        "comment_author": "praveen-influx",
        "comment_body": "Good point - I'll try to link the steps to the diagram and add the incoming writes as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1929007544",
    "pr_number": 25856,
    "pr_file": "influxdb3_wal/wal.md",
    "created_at": "2025-01-24T17:16:54+00:00",
    "commented_code": "+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```\n+\n+\n+#### Steps\n+\n+1. When _writes_ comes in, they go into a write batch in wal buffer. These batches are held per database and the batches keep track of min\n+   and max times within each batch. These batches further hold per table chunks. This chunk is created by taking incoming rows and pinning\n+   them to a period. It is done by `t - (t % gen_1_duration)`. If `gen_1_duration` is 10 mins, then all of the rows will be divided into\n+   10 min chunks. As an example if there are rows for 10.29 and 10.35 then they both go into 2 separate chunks (10.20 and 10.30). And this\n+   10.20 and 10.30 are used later as the key in queryable buffer.\n+2. Every flush interval, the wal buffer is flushed and all batches are written to to wal file (converts to wal content and gets min/max",
    "repo_full_name": "influxdata/influxdb",
    "discussion_comments": [
      {
        "comment_id": "1929007544",
        "repo_full_name": "influxdata/influxdb",
        "pr_number": 25856,
        "pr_file": "influxdb3_wal/wal.md",
        "discussion_id": "1929007544",
        "commented_code": "@@ -0,0 +1,214 @@\n+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```\n+\n+\n+#### Steps\n+\n+1. When _writes_ comes in, they go into a write batch in wal buffer. These batches are held per database and the batches keep track of min\n+   and max times within each batch. These batches further hold per table chunks. This chunk is created by taking incoming rows and pinning\n+   them to a period. It is done by `t - (t % gen_1_duration)`. If `gen_1_duration` is 10 mins, then all of the rows will be divided into\n+   10 min chunks. As an example if there are rows for 10.29 and 10.35 then they both go into 2 separate chunks (10.20 and 10.30). And this\n+   10.20 and 10.30 are used later as the key in queryable buffer.\n+2. Every flush interval, the wal buffer is flushed and all batches are written to to wal file (converts to wal content and gets min/max",
        "comment_created_at": "2025-01-24T17:16:54+00:00",
        "comment_author": "pauldix",
        "comment_body": "You should also mention that the write request that came in had a oneshot channel created that gets called back on after the flush and the placement of that data into the queryable buffer, with then returns a success to the client.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1929011595",
    "pr_number": 25856,
    "pr_file": "influxdb3_wal/wal.md",
    "created_at": "2025-01-24T17:20:13+00:00",
    "commented_code": "+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```\n+\n+\n+#### Steps\n+\n+1. When _writes_ comes in, they go into a write batch in wal buffer. These batches are held per database and the batches keep track of min\n+   and max times within each batch. These batches further hold per table chunks. This chunk is created by taking incoming rows and pinning\n+   them to a period. It is done by `t - (t % gen_1_duration)`. If `gen_1_duration` is 10 mins, then all of the rows will be divided into\n+   10 min chunks. As an example if there are rows for 10.29 and 10.35 then they both go into 2 separate chunks (10.20 and 10.30). And this\n+   10.20 and 10.30 are used later as the key in queryable buffer.\n+2. Every flush interval, the wal buffer is flushed and all batches are written to to wal file (converts to wal content and gets min/max\n+   times from all batches) and every time wal file contents are written, we add wal period to snapshot tracker that tracks min/max times across\n+   batches that went into single wal file\n+3. Then snapshot tracker is checked to see if there are enough wal periods to trigger snapshot. There are different conditions checked, the\n+   common scenarios are,\n+     - wal periods > (1.5 * snapshot size). e.g default settings will lead to snapshot size = 600, if we have 900 wal periods trigger snapshot\n+     - force snapshot, irrespective of sizes go ahead and run snapshot\n+\n+   If going ahead with force snapshotting, pick all the wal periods in the tracker and find the max time from most recent wal period. This will be\n+   used as the `end_time_marker` to evict data from query buffer. Because forcing a snapshot can be triggered when wal buffer is empty (even though\n+   queryable buffer is full), we need to add `Noop` (a no-op WalOp) to the wal file to hold the snapshot details in wal file.\n+\n+   ```\n+\n+                                          Snapshot (all, emptying wal periods in tracker)\n+               ▲                           ▲\n+               │◄───wal in snapshot───────►│\n+               ┌──────┬──────┬──────┬──────┤\n+               │  0   │  1   │  2   │  3   │\n+               │      │      │      │      │\n+           ────┴──────┴──────┴──────┴──────┴─────► (time)\n+\n+   ```\n+\n+   If it is a normal snapshot, then leave one wal period (`3` in eg below) and pick the last one (`2` in eg below) max time used as `end_time_marker`",
    "repo_full_name": "influxdata/influxdb",
    "discussion_comments": [
      {
        "comment_id": "1929011595",
        "repo_full_name": "influxdata/influxdb",
        "pr_number": 25856,
        "pr_file": "influxdb3_wal/wal.md",
        "discussion_id": "1929011595",
        "commented_code": "@@ -0,0 +1,214 @@\n+# WAL (write-ahead-log) and Snapshot process\n+\n+All writes get buffered into a wal buffer and then every flush interval all the contents are flushed to disk at which point the writes become durable and\n+the clients are sent the confirmation that their writes are successful. At each flush interval there is also a check to see if queryable buffer need to\n+evict data to disk, this process is called snapshotting. The rest of this doc discusses all the moving parts in wal flush and snapshotting.\n+\n+\n+## Overview\n+\n+```\n+\n+\n+\n+                                 ┌────────────┐           ┌────────────┐\n+                                 │flush buffer│──────────►│ wal buffer │\n+                                 └────────────┘           └────────────┘\n+                                    ▲\n+                                    │\n+                (takes everything from wal buffer and writes to wal file)\n+                                    │\n+                                    │   (actual background_wal_flush uses wal trait - which wal obj store impls)\n+                                    │        ┌──────────────(background create)───────────────────────────┐\n+                                    │        │                                                            ▼\n+                              ┌─────┴──────┐ │                                                        ┌────────┐\n+                        ┌────►│wal objstore├─┴──(remove wal,need each wal file num / drop semaphore)─►│wal file│\n+                        │     └─────┬──────┘                                                          └────────┘\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │           │\n+                        │   (notifies wal\n+                        │    and snapshot optionally & snapshot semaphore taken)    ┌─────────────┐\n+                        │           │                              ┌───────────────►│update buffer│ (whatever wal flushed into chunks)\n+                        │           ▼                              │                └─────────────┘\n+                        │     ┌────────────┐                       │                ┌─────────────┐\n+                        │     │query buffer├───────────────────────┼───────────────►│parquet file │\n+                        │     └─────┬──────┘                       │                └─────────────┘\n+                        │           │                              │\n+                        │   (run snapshot)                         │                ┌─────────────┐\n+                        └───────────┘                              ├───────────────►│snapshot file│ (holds last wal seq number)\n+                                                                   │                └─────────────┘\n+                                                                   │                ┌────────────┐\n+                                                                   └───────────────►│clear buffer│ (whatever snapshotted is removed)\n+                                                                                    └────────────┘\n+```\n+\n+\n+#### Steps\n+\n+1. When _writes_ comes in, they go into a write batch in wal buffer. These batches are held per database and the batches keep track of min\n+   and max times within each batch. These batches further hold per table chunks. This chunk is created by taking incoming rows and pinning\n+   them to a period. It is done by `t - (t % gen_1_duration)`. If `gen_1_duration` is 10 mins, then all of the rows will be divided into\n+   10 min chunks. As an example if there are rows for 10.29 and 10.35 then they both go into 2 separate chunks (10.20 and 10.30). And this\n+   10.20 and 10.30 are used later as the key in queryable buffer.\n+2. Every flush interval, the wal buffer is flushed and all batches are written to to wal file (converts to wal content and gets min/max\n+   times from all batches) and every time wal file contents are written, we add wal period to snapshot tracker that tracks min/max times across\n+   batches that went into single wal file\n+3. Then snapshot tracker is checked to see if there are enough wal periods to trigger snapshot. There are different conditions checked, the\n+   common scenarios are,\n+     - wal periods > (1.5 * snapshot size). e.g default settings will lead to snapshot size = 600, if we have 900 wal periods trigger snapshot\n+     - force snapshot, irrespective of sizes go ahead and run snapshot\n+\n+   If going ahead with force snapshotting, pick all the wal periods in the tracker and find the max time from most recent wal period. This will be\n+   used as the `end_time_marker` to evict data from query buffer. Because forcing a snapshot can be triggered when wal buffer is empty (even though\n+   queryable buffer is full), we need to add `Noop` (a no-op WalOp) to the wal file to hold the snapshot details in wal file.\n+\n+   ```\n+\n+                                          Snapshot (all, emptying wal periods in tracker)\n+               ▲                           ▲\n+               │◄───wal in snapshot───────►│\n+               ┌──────┬──────┬──────┬──────┤\n+               │  0   │  1   │  2   │  3   │\n+               │      │      │      │      │\n+           ────┴──────┴──────┴──────┴──────┴─────► (time)\n+\n+   ```\n+\n+   If it is a normal snapshot, then leave one wal period (`3` in eg below) and pick the last one (`2` in eg below) max time used as `end_time_marker`",
        "comment_created_at": "2025-01-24T17:20:13+00:00",
        "comment_author": "pauldix",
        "comment_body": "This isn't strictly true. What the WAL periods are looking for is that data written into the oldest WAL files have time stamps that fall into chunks that are no longer receiving writes. So if we have the default 10m gen1 chunks and we're always writing data with a time of \"now\" then we would only snapshot after we have the 10m chunk time go cold. If we have lagged collection, by say 1m, we won't snapshot until after that 10m wall clock time has passed + 1m, but we would only snapshot the wal files from before that time. So we'd likely leave behind 60 wal files, which is by design.",
        "pr_file_module": null
      }
    ]
  }
]