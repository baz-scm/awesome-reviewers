[
  {
    "discussion_id": "2288894057",
    "pr_number": 57295,
    "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
    "created_at": "2025-08-20T17:52:03+00:00",
    "commented_code": "}\n \n type shadowServiceInfo struct {\n-\tkey        types.NamespacedName\n-\tselector   map[string]string\n-\tpoolName   string\n-\tpoolUID    types.UID\n-\ttargetPort int32\n+\tkey      types.NamespacedName\n+\tselector map[string]string\n+\tpoolName string\n+\tpoolUID  types.UID\n+\t// targetPorts is the port number on the pods selected by the selector.\n+\t// Currently, inference extension only supports a single target port.\n+\ttargetPorts []targetPort\n+}\n+\n+type targetPort struct {\n+\tport int32",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2288894057",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288894057",
        "commented_code": "@@ -63,11 +63,17 @@ func getSupportedControllers() sets.Set[gatewayv1.GatewayController] {\n }\n \n type shadowServiceInfo struct {\n-\tkey        types.NamespacedName\n-\tselector   map[string]string\n-\tpoolName   string\n-\tpoolUID    types.UID\n-\ttargetPort int32\n+\tkey      types.NamespacedName\n+\tselector map[string]string\n+\tpoolName string\n+\tpoolUID  types.UID\n+\t// targetPorts is the port number on the pods selected by the selector.\n+\t// Currently, inference extension only supports a single target port.\n+\ttargetPorts []targetPort\n+}\n+\n+type targetPort struct {\n+\tport int32",
        "comment_created_at": "2025-08-20T17:52:03+00:00",
        "comment_author": "LiorLieberman",
        "comment_body": "so according to kubernetes-sigs/gateway-api-inference-extension#1400 -- should this be a pointer?\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2302146917",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288894057",
        "commented_code": "@@ -63,11 +63,17 @@ func getSupportedControllers() sets.Set[gatewayv1.GatewayController] {\n }\n \n type shadowServiceInfo struct {\n-\tkey        types.NamespacedName\n-\tselector   map[string]string\n-\tpoolName   string\n-\tpoolUID    types.UID\n-\ttargetPort int32\n+\tkey      types.NamespacedName\n+\tselector map[string]string\n+\tpoolName string\n+\tpoolUID  types.UID\n+\t// targetPorts is the port number on the pods selected by the selector.\n+\t// Currently, inference extension only supports a single target port.\n+\ttargetPorts []targetPort\n+}\n+\n+type targetPort struct {\n+\tport int32",
        "comment_created_at": "2025-08-26T21:07:05+00:00",
        "comment_author": "danehans",
        "comment_body": "@LiorLieberman we settled on making `TargetPorts` and `Port.Number` required ([xref](https://github.com/kubernetes-sigs/gateway-api-inference-extension/blob/v1.0.0-rc.1/api/v1/inferencepool_types.go)):\r\n```go\r\ntype InferencePoolSpec struct {\r\n\t...\r\n\t// TargetPorts defines a list of ports that are exposed by this InferencePool.\r\n\t// Currently, the list may only include a single port definition.\r\n\t//\r\n\t// +kubebuilder:validation:MinItems=1\r\n\t// +kubebuilder:validation:MaxItems=1\r\n\t// +listType=atomic\r\n\t// +required\r\n\tTargetPorts []Port `json:\"targetPorts,omitempty\"`\r\n\t...\r\n}\r\n\r\ntype Port struct {\r\n\t// Number defines the port number to access the selected model server Pods.\r\n\t// The number must be in the range 1 to 65535.\r\n\t//\r\n\t// +required\r\n\tNumber PortNumber `json:\"number,omitempty\"`\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2302216004",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288894057",
        "commented_code": "@@ -63,11 +63,17 @@ func getSupportedControllers() sets.Set[gatewayv1.GatewayController] {\n }\n \n type shadowServiceInfo struct {\n-\tkey        types.NamespacedName\n-\tselector   map[string]string\n-\tpoolName   string\n-\tpoolUID    types.UID\n-\ttargetPort int32\n+\tkey      types.NamespacedName\n+\tselector map[string]string\n+\tpoolName string\n+\tpoolUID  types.UID\n+\t// targetPorts is the port number on the pods selected by the selector.\n+\t// Currently, inference extension only supports a single target port.\n+\ttargetPorts []targetPort\n+}\n+\n+type targetPort struct {\n+\tport int32",
        "comment_created_at": "2025-08-26T21:47:43+00:00",
        "comment_author": "LiorLieberman",
        "comment_body": "I may conflate two things, \r\n\r\nI meant the EndpointPickerRef port -- is a pointer. \r\n\r\nAre we handling this correctly? https://github.com/kubernetes-sigs/gateway-api-inference-extension/blob/v1.0.0-rc.1/api/v1/inferencepool_types.go#L128-L134",
        "pr_file_module": null
      },
      {
        "comment_id": "2302268413",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288894057",
        "commented_code": "@@ -63,11 +63,17 @@ func getSupportedControllers() sets.Set[gatewayv1.GatewayController] {\n }\n \n type shadowServiceInfo struct {\n-\tkey        types.NamespacedName\n-\tselector   map[string]string\n-\tpoolName   string\n-\tpoolUID    types.UID\n-\ttargetPort int32\n+\tkey      types.NamespacedName\n+\tselector map[string]string\n+\tpoolName string\n+\tpoolUID  types.UID\n+\t// targetPorts is the port number on the pods selected by the selector.\n+\t// Currently, inference extension only supports a single target port.\n+\ttargetPorts []targetPort\n+}\n+\n+type targetPort struct {\n+\tport int32",
        "comment_created_at": "2025-08-26T22:21:05+00:00",
        "comment_author": "danehans",
        "comment_body": "Thanks for the clarification. `TargetPorts` is required but `PortNumber` is optional (defaults to `9002` when unspecified). For example, the following code handles `PortNumber` per the v1.0.0-rc.1 API spec:\r\n\r\n```go\r\nfunc createInferencePoolObject(pool *inferencev1.InferencePool, gatewayParents sets.Set[types.NamespacedName]) *InferencePool {\r\n\t// Build extension reference info\r\n\textRef := extRefInfo{\r\n\t\tname: string(pool.Spec.EndpointPickerRef.Name),\r\n\t}\r\n\r\n\textRef.port = 9002 // Default port for the inference extension\r\n\tif pool.Spec.EndpointPickerRef.PortNumber != nil {\r\n\t\textRef.port = int32(*pool.Spec.EndpointPickerRef.PortNumber)\r\n\t}\r\n```\r\n\r\nI have audited the code for `PortNumber` and `TargetPorts` against the v1.0.0-rc.1 API spec and I don't see any misalignment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288895121",
    "pr_number": 57295,
    "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
    "created_at": "2025-08-20T17:52:31+00:00",
    "commented_code": "// calculateInferencePoolStatus calculates the complete status for an InferencePool\n func calculateInferencePoolStatus(\n-\tpool *inferencev1alpha2.InferencePool,\n+\tpool *inferencev1.InferencePool,\n \tgatewayParents sets.Set[types.NamespacedName],\n \tservices krt.Collection[*corev1.Service],\n \tgateways krt.Collection[*gateway.Gateway],\n \trouteList []*gateway.HTTPRoute,\n-) *inferencev1alpha2.InferencePoolStatus {\n+) *inferencev1.InferencePoolStatus {\n \t// Calculate status for each gateway parent\n \texistingParents := pool.Status.DeepCopy().Parents\n-\tfinalParents := []inferencev1alpha2.PoolStatus{}\n+\tfinalParents := []inferencev1.PoolStatus{}\n \n \t// Add existing parents from other controllers (not managed by us)\n \tfor _, existingParent := range existingParents {\n \t\tgtwName := string(existingParent.GatewayRef.Name)\n \t\tgtwNamespace := pool.Namespace\n-\t\tif existingParent.GatewayRef.Namespace != nil {\n-\t\t\tgtwNamespace = string(*existingParent.GatewayRef.Namespace)\n+\t\tif existingParent.GatewayRef.Namespace != \"\" {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2288895121",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288895121",
        "commented_code": "@@ -170,22 +180,22 @@ func createInferencePoolObject(pool *inferencev1alpha2.InferencePool, gatewayPar\n \n // calculateInferencePoolStatus calculates the complete status for an InferencePool\n func calculateInferencePoolStatus(\n-\tpool *inferencev1alpha2.InferencePool,\n+\tpool *inferencev1.InferencePool,\n \tgatewayParents sets.Set[types.NamespacedName],\n \tservices krt.Collection[*corev1.Service],\n \tgateways krt.Collection[*gateway.Gateway],\n \trouteList []*gateway.HTTPRoute,\n-) *inferencev1alpha2.InferencePoolStatus {\n+) *inferencev1.InferencePoolStatus {\n \t// Calculate status for each gateway parent\n \texistingParents := pool.Status.DeepCopy().Parents\n-\tfinalParents := []inferencev1alpha2.PoolStatus{}\n+\tfinalParents := []inferencev1.PoolStatus{}\n \n \t// Add existing parents from other controllers (not managed by us)\n \tfor _, existingParent := range existingParents {\n \t\tgtwName := string(existingParent.GatewayRef.Name)\n \t\tgtwNamespace := pool.Namespace\n-\t\tif existingParent.GatewayRef.Namespace != nil {\n-\t\t\tgtwNamespace = string(*existingParent.GatewayRef.Namespace)\n+\t\tif existingParent.GatewayRef.Namespace != \"\" {",
        "comment_created_at": "2025-08-20T17:52:31+00:00",
        "comment_author": "LiorLieberman",
        "comment_body": "reviewing this changes, I also noticed there were breaking changes in the parentRefs(https://github.com/kubernetes-sigs/gateway-api-inference-extension/commit/bc242de9b9f92c24ff07132e43783dab3decb976#r164325868), mind adding this to the PR description for posterity? \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2288895452",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288895121",
        "commented_code": "@@ -170,22 +180,22 @@ func createInferencePoolObject(pool *inferencev1alpha2.InferencePool, gatewayPar\n \n // calculateInferencePoolStatus calculates the complete status for an InferencePool\n func calculateInferencePoolStatus(\n-\tpool *inferencev1alpha2.InferencePool,\n+\tpool *inferencev1.InferencePool,\n \tgatewayParents sets.Set[types.NamespacedName],\n \tservices krt.Collection[*corev1.Service],\n \tgateways krt.Collection[*gateway.Gateway],\n \trouteList []*gateway.HTTPRoute,\n-) *inferencev1alpha2.InferencePoolStatus {\n+) *inferencev1.InferencePoolStatus {\n \t// Calculate status for each gateway parent\n \texistingParents := pool.Status.DeepCopy().Parents\n-\tfinalParents := []inferencev1alpha2.PoolStatus{}\n+\tfinalParents := []inferencev1.PoolStatus{}\n \n \t// Add existing parents from other controllers (not managed by us)\n \tfor _, existingParent := range existingParents {\n \t\tgtwName := string(existingParent.GatewayRef.Name)\n \t\tgtwNamespace := pool.Namespace\n-\t\tif existingParent.GatewayRef.Namespace != nil {\n-\t\t\tgtwNamespace = string(*existingParent.GatewayRef.Namespace)\n+\t\tif existingParent.GatewayRef.Namespace != \"\" {",
        "comment_created_at": "2025-08-20T17:52:39+00:00",
        "comment_author": "LiorLieberman",
        "comment_body": "Lazy to read the whole code again - are we now following https://github.com/kubernetes-sigs/gateway-api-inference-extension/blob/main/api/v1/inferencepool_types.go#L281-L283 ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2302179486",
        "repo_full_name": "istio/istio",
        "pr_number": 57295,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2288895121",
        "commented_code": "@@ -170,22 +180,22 @@ func createInferencePoolObject(pool *inferencev1alpha2.InferencePool, gatewayPar\n \n // calculateInferencePoolStatus calculates the complete status for an InferencePool\n func calculateInferencePoolStatus(\n-\tpool *inferencev1alpha2.InferencePool,\n+\tpool *inferencev1.InferencePool,\n \tgatewayParents sets.Set[types.NamespacedName],\n \tservices krt.Collection[*corev1.Service],\n \tgateways krt.Collection[*gateway.Gateway],\n \trouteList []*gateway.HTTPRoute,\n-) *inferencev1alpha2.InferencePoolStatus {\n+) *inferencev1.InferencePoolStatus {\n \t// Calculate status for each gateway parent\n \texistingParents := pool.Status.DeepCopy().Parents\n-\tfinalParents := []inferencev1alpha2.PoolStatus{}\n+\tfinalParents := []inferencev1.PoolStatus{}\n \n \t// Add existing parents from other controllers (not managed by us)\n \tfor _, existingParent := range existingParents {\n \t\tgtwName := string(existingParent.GatewayRef.Name)\n \t\tgtwNamespace := pool.Namespace\n-\t\tif existingParent.GatewayRef.Namespace != nil {\n-\t\t\tgtwNamespace = string(*existingParent.GatewayRef.Namespace)\n+\t\tif existingParent.GatewayRef.Namespace != \"\" {",
        "comment_created_at": "2025-08-26T21:26:13+00:00",
        "comment_author": "danehans",
        "comment_body": "> reviewing this changes, I also noticed there were breaking changes in the parentRefs(https://github.com/kubernetes-sigs/gateway-api-inference-extension/commit/bc242de9b9f92c24ff07132e43783dab3decb976#r164325868), mind adding this to the PR description for posterity?\r\n\r\nDone\r\n\r\n> Lazy to read the whole code again - are we now following https://github.com/kubernetes-sigs/gateway-api-inference-extension/blob/main/api/v1/inferencepool_types.go#L281-L283 \r\n\r\nYes, with the v1.0.0-rc1 API, we no longer need to check `Kind` for `nil` and `\"\"`, just the latter.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2243910473",
    "pr_number": 56549,
    "pr_file": "pilot/pkg/security/model/authentication.go",
    "created_at": "2025-07-30T21:37:09+00:00",
    "commented_code": "// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2243910473",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-30T21:37:09+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I am worried about this. First, let me say I think our existing API is quite problematic which is not your fault of course -- but something that is widely used and that we need to keep compatibility with its behavior.\r\n\r\nToday, a user can put `credentialName: blah-cacert` and it will be treated as an opaque string. Now, the behavior is changed and we are implicitly deriving that they mean to use this as-is.",
        "pr_file_module": null
      },
      {
        "comment_id": "2243916417",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-30T21:41:33+00:00",
        "comment_author": "howardjohn",
        "comment_body": "overloading the string content like `cacert://` wouldn't work well since we already used (abused) that to have a meaning about the type.\r\n\r\nIt does seem like a new field `caCertCredentialName` may really be appropriate. WDYT @keithmattix ",
        "pr_file_module": null
      },
      {
        "comment_id": "2243990097",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-30T22:37:44+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Yeah +1 to making a new field. I didn't notice the change in semantic",
        "pr_file_module": null
      },
      {
        "comment_id": "2244044313",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-30T23:23:43+00:00",
        "comment_author": "kinolaev",
        "comment_body": "What if instead of adding a field we'll check `configmap://` prefix in addition to `-cacert` suffix? This uri type haven't been mentioned in the docs until now, and I hope nobody keeps keys in a ConfigMap) So I believe this behaviour change will affect nobody.\n\nIt would be enough for \"Core\" level GWAPI FrontendTLSValidation support, because the spec says: \"A single CA certificate reference to a Kubernetes ConfigMap\nhas \"Core\" support\".\n\nInitially I've proposed to use `credentialNames` instead of a new field based on this discussion https://github.com/istio/istio/pull/46518#issuecomment-1700585874.\n\nAre you sure that you want a new field?",
        "pr_file_module": null
      },
      {
        "comment_id": "2245881669",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-31T16:40:45+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Yeah I think Gateway API conformance is a more compelling reason to take on the cost of a new field. Prefixing it with caCert removes ambiguity as well and we could actually explicitly log if there's a private key in the configmap (hopefully not!!)",
        "pr_file_module": null
      },
      {
        "comment_id": "2246004706",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-31T17:38:18+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Yeah I am good with the new field as well. So that puts a bit more work for this! Thanks for working through this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2246318544",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-31T20:30:34+00:00",
        "comment_author": "kinolaev",
        "comment_body": "For now I have only one question: how to turn a `caCertCredentialName` without URI prefix into resource name? For example, should `someca` be interpreted as:\r\n1. `kubernetes://someca` (same way as with `credentialName`) or\r\n2. `configmap://namespace-of-gateway/someca-cacert`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2246406641",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-31T21:25:56+00:00",
        "comment_author": "keithmattix",
        "comment_body": "I would think the same semantics as credentialName",
        "pr_file_module": null
      },
      {
        "comment_id": "2246552071",
        "repo_full_name": "istio/istio",
        "pr_number": 56549,
        "pr_file": "pilot/pkg/security/model/authentication.go",
        "discussion_id": "2243910473",
        "commented_code": "@@ -251,13 +251,24 @@ func ApplyCredentialSDSToServerCommonTLSContext(tlsContext *tls.CommonTlsContext\n \t// create SDS config for gateway/sidecar to fetch key/cert from agent.\n \tcaCert := tlsOpts.CredentialName + SdsCaSuffix\n \tif len(tlsOpts.CredentialNames) > 0 {\n+\t\thasCacert := false\n \t\t// Handle multiple certificates for RSA and ECDSA\n-\t\ttlsContext.TlsCertificateSdsSecretConfigs = make([]*tls.SdsSecretConfig, len(tlsOpts.CredentialNames))\n-\t\tfor i, name := range tlsOpts.CredentialNames {\n-\t\t\ttlsContext.TlsCertificateSdsSecretConfigs[i] = ConstructSdsSecretConfigForCredential(name, credentialSocketExist, push)\n+\t\ttlsContext.TlsCertificateSdsSecretConfigs = []*tls.SdsSecretConfig{}\n+\t\tfor _, name := range tlsOpts.CredentialNames {\n+\t\t\tif strings.HasSuffix(name, SdsCaSuffix) {",
        "comment_created_at": "2025-07-31T23:14:31+00:00",
        "comment_author": "kinolaev",
        "comment_body": "PR rebased and cacert is moved to `caCertCredentialName`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2092267240",
    "pr_number": 56042,
    "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/services.go",
    "created_at": "2025-05-16T03:41:42+00:00",
    "commented_code": "},\n \t\t\tMode: workloadapi.LoadBalancing_STRICT,\n \t\t}\n+\t} else {\n+\t\t// Check traffic distribution.\n+\t\ttrafficDistribution := kube.GetTrafficDistribution(svc.Spec.TrafficDistribution, svc.Annotations)\n+\t\tif trafficDistribution == model.TrafficDistributionPreferSameZone {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2092267240",
        "repo_full_name": "istio/istio",
        "pr_number": 56042,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/services.go",
        "discussion_id": "2092267240",
        "commented_code": "@@ -240,7 +233,16 @@ func (a *index) constructService(ctx krt.HandlerContext, svc *v1.Service, w *Way\n \t\t\t},\n \t\t\tMode: workloadapi.LoadBalancing_STRICT,\n \t\t}\n+\t} else {\n+\t\t// Check traffic distribution.\n+\t\ttrafficDistribution := kube.GetTrafficDistribution(svc.Spec.TrafficDistribution, svc.Annotations)\n+\t\tif trafficDistribution == model.TrafficDistributionPreferSameZone {",
        "comment_created_at": "2025-05-16T03:41:42+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "prefer close too?",
        "pr_file_module": null
      },
      {
        "comment_id": "2093220121",
        "repo_full_name": "istio/istio",
        "pr_number": 56042,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/services.go",
        "discussion_id": "2092267240",
        "commented_code": "@@ -240,7 +233,16 @@ func (a *index) constructService(ctx krt.HandlerContext, svc *v1.Service, w *Way\n \t\t\t},\n \t\t\tMode: workloadapi.LoadBalancing_STRICT,\n \t\t}\n+\t} else {\n+\t\t// Check traffic distribution.\n+\t\ttrafficDistribution := kube.GetTrafficDistribution(svc.Spec.TrafficDistribution, svc.Annotations)\n+\t\tif trafficDistribution == model.TrafficDistributionPreferSameZone {",
        "comment_created_at": "2025-05-16T14:59:35+00:00",
        "comment_author": "Stevenjin8",
        "comment_body": "model.TrafficDistributionPreferClose doesn't exist since in the kubernetes api, its an alias for TrafficDistributionPreferSameZone\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "963937818",
    "pr_number": 40647,
    "pr_file": "pkg/wasm/imagefetcher.go",
    "created_at": "2022-09-06T16:33:48+00:00",
    "commented_code": "return nil, fmt.Errorf(\"could not fetch layers: %v\", err)\n \t}\n \n-\t// The image must be single-layered.\n-\tif len(layers) != 1 {\n-\t\treturn nil, fmt.Errorf(\"number of layers must be 1 but got %d\", len(layers))\n+\t// The image must have at least one layer.",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "963937818",
        "repo_full_name": "istio/istio",
        "pr_number": 40647,
        "pr_file": "pkg/wasm/imagefetcher.go",
        "discussion_id": "963937818",
        "commented_code": "@@ -171,12 +172,12 @@ func extractDockerImage(img v1.Image) ([]byte, error) {\n \t\treturn nil, fmt.Errorf(\"could not fetch layers: %v\", err)\n \t}\n \n-\t// The image must be single-layered.\n-\tif len(layers) != 1 {\n-\t\treturn nil, fmt.Errorf(\"number of layers must be 1 but got %d\", len(layers))\n+\t// The image must have at least one layer.",
        "comment_created_at": "2022-09-06T16:33:48+00:00",
        "comment_author": "ingwonsong",
        "comment_body": "This change needs to be applied to `extractOCIStandardImage`, too, because the spec also mention about OCI standard image format.",
        "pr_file_module": null
      },
      {
        "comment_id": "964250503",
        "repo_full_name": "istio/istio",
        "pr_number": 40647,
        "pr_file": "pkg/wasm/imagefetcher.go",
        "discussion_id": "963937818",
        "commented_code": "@@ -171,12 +172,12 @@ func extractDockerImage(img v1.Image) ([]byte, error) {\n \t\treturn nil, fmt.Errorf(\"could not fetch layers: %v\", err)\n \t}\n \n-\t// The image must be single-layered.\n-\tif len(layers) != 1 {\n-\t\treturn nil, fmt.Errorf(\"number of layers must be 1 but got %d\", len(layers))\n+\t// The image must have at least one layer.",
        "comment_created_at": "2022-09-06T23:20:11+00:00",
        "comment_author": "mathetake",
        "comment_body": "yeah true. https://github.com/istio/istio/blob/36a89eb800ec7aef49462329f283c5425f488f08/pkg/wasm/imagefetcher.go#L213-L216 these lines should  also be fixed. @jcchavezs ",
        "pr_file_module": null
      },
      {
        "comment_id": "967041953",
        "repo_full_name": "istio/istio",
        "pr_number": 40647,
        "pr_file": "pkg/wasm/imagefetcher.go",
        "discussion_id": "963937818",
        "commented_code": "@@ -171,12 +172,12 @@ func extractDockerImage(img v1.Image) ([]byte, error) {\n \t\treturn nil, fmt.Errorf(\"could not fetch layers: %v\", err)\n \t}\n \n-\t// The image must be single-layered.\n-\tif len(layers) != 1 {\n-\t\treturn nil, fmt.Errorf(\"number of layers must be 1 but got %d\", len(layers))\n+\t// The image must have at least one layer.",
        "comment_created_at": "2022-09-09T12:56:49+00:00",
        "comment_author": "jcchavezs",
        "comment_body": "Right. I forgot that one.",
        "pr_file_module": null
      }
    ]
  }
]