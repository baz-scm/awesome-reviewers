[
  {
    "discussion_id": "1048031202",
    "pr_number": 42372,
    "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
    "created_at": "2022-12-14T05:30:02+00:00",
    "commented_code": "+\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <linux/if_ether.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+#ifndef memcpy\n+#define memcpy(dest, src, n) __builtin_memcpy((dest), (src), (n))\n+#endif\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+\n+#ifdef DEBUG\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = \"[Debug]: \" fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#else\n+#define dbg(fmt, ...)\n+#endif\n+\n+struct bpf_elf_map ztunnel_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_ARRAY,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct ztunnel_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = 1,\n+};\n+\n+struct bpf_elf_map app_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_HASH,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct app_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = APP_INFO_MAP_SIZE,\n+};\n+\n+\n+static __inline struct ztunnel_info * get_ztunnel_info()\n+{\n+    uint32_t key = 0;\n+    return map_lookup_elem(&ztunnel_info, &key);\n+}\n+\n+static __inline struct app_info * get_app_info_from_ipv4(uint32_t ipv4)\n+{\n+    return map_lookup_elem(&app_info, &ipv4);\n+}\n+\n+__section(\"ztunnelingress\")\n+int ztunnel_ingress(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    struct bpf_sock_tuple *tuple;\n+    size_t tuple_len;\n+    struct bpf_sock *sk;\n+    int skip_mark = 0;\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+\n+    if (data + sizeof(*eth) > data_end)\n+        return TC_ACT_OK;\n+\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    tuple = (struct bpf_sock_tuple *)&iph->saddr;\n+    tuple_len = sizeof(tuple->ipv4);\n+    if ((void *)tuple + sizeof(tuple->ipv4) > (void *)(long)skb->data_end) {\n+        return TC_ACT_SHOT;\n+    }\n+\n+    if (skb->cb[4] == outbound_cb) {\n+        // We mark all app egress pkt as outbound and redirect here.\n+        // We need identify if it's a actual *outbound* or just a reponse to\n+        // the proxy\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_OUTBOUND_MARK;\n+            dbg(\"mark outbound packet: %u\n\", skb->mark);\n+            dbg(\"got packet with out cb %x\", skb->cb[4]);\n+        }\n+    } else if (skb->cb[4] == inbound_cb) {\n+\n+        // For original source case, app will overwrite\n+        // the smac and redirect here.\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN  \n+                && sk->src_port != ZTUNNEL_INBOUND_PORT \n+                && sk->src_port != ZTUNNEL_INBOUND_PLAINTEXT_PORT) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_INBOUND_MARK;\n+            dbg(\"mark inbound packet: %u\n\", skb->mark);\n+            dbg(\"got outbound packet with in cb %x\", skb->cb[4]);\n+        }\n+    }\n+\n+    return TC_ACT_OK;\n+}\n+\n+__section(\"outbound\")\n+int outbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"outbound_to_ztunnel unable to retrieve ztunnel_ifindex\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = outbound_cb;\n+    dbg(\"outbound redirect to ztunnel ifidx: %u\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+\n+__section(\"inbound\")\n+int inbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    if (skb->mark == ZTUNNEL_BYPASS_MARK) {\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"inbound_to_ztunnel unable to retrieve ztunnel_ifindex\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = inbound_cb;\n+\n+    dbg(\"inbound redirect to ztunnel ifidx: %u\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+__section(\"ztunnelhostingress\")\n+int ztunnel_to_app(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    skb->mark = ZTUNNEL_BYPASS_MARK;\n+    struct app_info *pi = get_app_info_from_ipv4(iph->daddr);\n+    if (!pi) {\n+        // ip is not in ambient managed mesh\n+        // dbg(\"ztunnelhostingress unable to retrieve pod info: 0x%08x\n\", ntohl(iph->daddr));\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, pi->mac_addr, ETH_ALEN);\n+    dbg(\"ztunnel redirect to app(0x%08x) ifidx: %u\n\",\n+        ntohl(iph->daddr), pi->ifindex);\n+    return bpf_redirect(pi->ifindex, 0);\n+}\n+\n+char __license[] __section(\"license\") = \"GPL\";",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1048031202",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
        "discussion_id": "1048031202",
        "commented_code": "@@ -0,0 +1,273 @@\n+\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <linux/if_ether.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+#ifndef memcpy\n+#define memcpy(dest, src, n) __builtin_memcpy((dest), (src), (n))\n+#endif\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+\n+#ifdef DEBUG\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = \"[Debug]: \" fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#else\n+#define dbg(fmt, ...)\n+#endif\n+\n+struct bpf_elf_map ztunnel_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_ARRAY,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct ztunnel_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = 1,\n+};\n+\n+struct bpf_elf_map app_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_HASH,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct app_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = APP_INFO_MAP_SIZE,\n+};\n+\n+\n+static __inline struct ztunnel_info * get_ztunnel_info()\n+{\n+    uint32_t key = 0;\n+    return map_lookup_elem(&ztunnel_info, &key);\n+}\n+\n+static __inline struct app_info * get_app_info_from_ipv4(uint32_t ipv4)\n+{\n+    return map_lookup_elem(&app_info, &ipv4);\n+}\n+\n+__section(\"ztunnelingress\")\n+int ztunnel_ingress(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    struct bpf_sock_tuple *tuple;\n+    size_t tuple_len;\n+    struct bpf_sock *sk;\n+    int skip_mark = 0;\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+\n+    if (data + sizeof(*eth) > data_end)\n+        return TC_ACT_OK;\n+\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    tuple = (struct bpf_sock_tuple *)&iph->saddr;\n+    tuple_len = sizeof(tuple->ipv4);\n+    if ((void *)tuple + sizeof(tuple->ipv4) > (void *)(long)skb->data_end) {\n+        return TC_ACT_SHOT;\n+    }\n+\n+    if (skb->cb[4] == outbound_cb) {\n+        // We mark all app egress pkt as outbound and redirect here.\n+        // We need identify if it's a actual *outbound* or just a reponse to\n+        // the proxy\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_OUTBOUND_MARK;\n+            dbg(\"mark outbound packet: %u\\n\", skb->mark);\n+            dbg(\"got packet with out cb %x\", skb->cb[4]);\n+        }\n+    } else if (skb->cb[4] == inbound_cb) {\n+\n+        // For original source case, app will overwrite\n+        // the smac and redirect here.\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN  \n+                && sk->src_port != ZTUNNEL_INBOUND_PORT \n+                && sk->src_port != ZTUNNEL_INBOUND_PLAINTEXT_PORT) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_INBOUND_MARK;\n+            dbg(\"mark inbound packet: %u\\n\", skb->mark);\n+            dbg(\"got outbound packet with in cb %x\", skb->cb[4]);\n+        }\n+    }\n+\n+    return TC_ACT_OK;\n+}\n+\n+__section(\"outbound\")\n+int outbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"outbound_to_ztunnel unable to retrieve ztunnel_ifindex\\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = outbound_cb;\n+    dbg(\"outbound redirect to ztunnel ifidx: %u\\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+\n+__section(\"inbound\")\n+int inbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    if (skb->mark == ZTUNNEL_BYPASS_MARK) {\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"inbound_to_ztunnel unable to retrieve ztunnel_ifindex\\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = inbound_cb;\n+\n+    dbg(\"inbound redirect to ztunnel ifidx: %u\\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+__section(\"ztunnelhostingress\")\n+int ztunnel_to_app(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    skb->mark = ZTUNNEL_BYPASS_MARK;\n+    struct app_info *pi = get_app_info_from_ipv4(iph->daddr);\n+    if (!pi) {\n+        // ip is not in ambient managed mesh\n+        // dbg(\"ztunnelhostingress unable to retrieve pod info: 0x%08x\\n\", ntohl(iph->daddr));\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, pi->mac_addr, ETH_ALEN);\n+    dbg(\"ztunnel redirect to app(0x%08x) ifidx: %u\\n\",\n+        ntohl(iph->daddr), pi->ifindex);\n+    return bpf_redirect(pi->ifindex, 0);\n+}\n+\n+char __license[] __section(\"license\") = \"GPL\";",
        "comment_created_at": "2022-12-14T05:30:02+00:00",
        "comment_author": "howardjohn",
        "comment_body": "How feasible is it to make this not depend on any GPL code? Otherwise we are going to need to dimskme investigation on the implications here given GPL is current banned in Istio",
        "pr_file_module": null
      },
      {
        "comment_id": "1072866677",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
        "discussion_id": "1048031202",
        "commented_code": "@@ -0,0 +1,273 @@\n+\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <linux/if_ether.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+#ifndef memcpy\n+#define memcpy(dest, src, n) __builtin_memcpy((dest), (src), (n))\n+#endif\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+\n+#ifdef DEBUG\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = \"[Debug]: \" fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#else\n+#define dbg(fmt, ...)\n+#endif\n+\n+struct bpf_elf_map ztunnel_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_ARRAY,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct ztunnel_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = 1,\n+};\n+\n+struct bpf_elf_map app_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_HASH,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct app_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = APP_INFO_MAP_SIZE,\n+};\n+\n+\n+static __inline struct ztunnel_info * get_ztunnel_info()\n+{\n+    uint32_t key = 0;\n+    return map_lookup_elem(&ztunnel_info, &key);\n+}\n+\n+static __inline struct app_info * get_app_info_from_ipv4(uint32_t ipv4)\n+{\n+    return map_lookup_elem(&app_info, &ipv4);\n+}\n+\n+__section(\"ztunnelingress\")\n+int ztunnel_ingress(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    struct bpf_sock_tuple *tuple;\n+    size_t tuple_len;\n+    struct bpf_sock *sk;\n+    int skip_mark = 0;\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+\n+    if (data + sizeof(*eth) > data_end)\n+        return TC_ACT_OK;\n+\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    tuple = (struct bpf_sock_tuple *)&iph->saddr;\n+    tuple_len = sizeof(tuple->ipv4);\n+    if ((void *)tuple + sizeof(tuple->ipv4) > (void *)(long)skb->data_end) {\n+        return TC_ACT_SHOT;\n+    }\n+\n+    if (skb->cb[4] == outbound_cb) {\n+        // We mark all app egress pkt as outbound and redirect here.\n+        // We need identify if it's a actual *outbound* or just a reponse to\n+        // the proxy\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_OUTBOUND_MARK;\n+            dbg(\"mark outbound packet: %u\\n\", skb->mark);\n+            dbg(\"got packet with out cb %x\", skb->cb[4]);\n+        }\n+    } else if (skb->cb[4] == inbound_cb) {\n+\n+        // For original source case, app will overwrite\n+        // the smac and redirect here.\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);\n+        if (sk) {\n+            if (sk->state != BPF_TCP_LISTEN  \n+                && sk->src_port != ZTUNNEL_INBOUND_PORT \n+                && sk->src_port != ZTUNNEL_INBOUND_PLAINTEXT_PORT) {\n+                skip_mark = 1;\n+            }\n+            // MUST call release to decrease ref_cnt before losing\n+            // sk reference\n+            bpf_sk_release(sk);\n+        }\n+        if (!skip_mark) {\n+            skb->mark = ZTUNNEL_INBOUND_MARK;\n+            dbg(\"mark inbound packet: %u\\n\", skb->mark);\n+            dbg(\"got outbound packet with in cb %x\", skb->cb[4]);\n+        }\n+    }\n+\n+    return TC_ACT_OK;\n+}\n+\n+__section(\"outbound\")\n+int outbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"outbound_to_ztunnel unable to retrieve ztunnel_ifindex\\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = outbound_cb;\n+    dbg(\"outbound redirect to ztunnel ifidx: %u\\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+\n+__section(\"inbound\")\n+int inbound_to_ztunnel(struct __sk_buff *skb)\n+{\n+    if (skb->mark == ZTUNNEL_BYPASS_MARK) {\n+        return TC_ACT_OK;\n+    }\n+\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    struct ztunnel_info *zi = get_ztunnel_info();\n+    if (!zi) {\n+        dbg(\"inbound_to_ztunnel unable to retrieve ztunnel_ifindex\\n\");\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, zi->mac_addr, ETH_ALEN);\n+    skb->cb[4] = inbound_cb;\n+\n+    dbg(\"inbound redirect to ztunnel ifidx: %u\\n\", zi->ifindex);\n+    return bpf_redirect(zi->ifindex, 0);\n+}\n+__section(\"ztunnelhostingress\")\n+int ztunnel_to_app(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct ethhdr  *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+\n+    if (data + sizeof(*eth) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+\n+    // TODO: support ipv6\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    skb->mark = ZTUNNEL_BYPASS_MARK;\n+    struct app_info *pi = get_app_info_from_ipv4(iph->daddr);\n+    if (!pi) {\n+        // ip is not in ambient managed mesh\n+        // dbg(\"ztunnelhostingress unable to retrieve pod info: 0x%08x\\n\", ntohl(iph->daddr));\n+        return TC_ACT_OK;\n+    }\n+\n+    // overwrite dst_mac\n+    memcpy(eth->h_dest, pi->mac_addr, ETH_ALEN);\n+    dbg(\"ztunnel redirect to app(0x%08x) ifidx: %u\\n\",\n+        ntohl(iph->daddr), pi->ifindex);\n+    return bpf_redirect(pi->ifindex, 0);\n+}\n+\n+char __license[] __section(\"license\") = \"GPL\";",
        "comment_created_at": "2023-01-17T21:51:20+00:00",
        "comment_author": "irisdingbj",
        "comment_body": "changed to dual license now",
        "pr_file_module": null
      }
    ]
  }
]