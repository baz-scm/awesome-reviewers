[
  {
    "discussion_id": "2273839995",
    "pr_number": 57334,
    "pr_file": "pilot/pkg/xds/ads.go",
    "created_at": "2025-08-13T15:32:53+00:00",
    "commented_code": "// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),\n \t// but proxy's SidecarScope has been updated(s.computeProxyState -> SetSidecarScope) due to optimizations that skip sidecar scope\n \t// computation.\n-\tif con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion {\n+\tif len(con.proxy.ServiceTargets) == 0 || (con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion) {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2273839995",
        "repo_full_name": "istio/istio",
        "pr_number": 57334,
        "pr_file": "pilot/pkg/xds/ads.go",
        "discussion_id": "2273839995",
        "commented_code": "@@ -173,7 +173,7 @@ func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *C\n \t// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),\n \t// but proxy's SidecarScope has been updated(s.computeProxyState -> SetSidecarScope) due to optimizations that skip sidecar scope\n \t// computation.\n-\tif con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion {\n+\tif len(con.proxy.ServiceTargets) == 0 || (con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion) {",
        "comment_created_at": "2025-08-13T15:32:53+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Hmm, it seems like if we are getting the _wrong pod_ does that mean we could get some services and just the wrong one? Or will it always be empty?\r\n\r\nOne concern here is its valid to have 0 services and now we need to recompute every time which could be pretty expensive?",
        "pr_file_module": null
      },
      {
        "comment_id": "2273867288",
        "repo_full_name": "istio/istio",
        "pr_number": 57334,
        "pr_file": "pilot/pkg/xds/ads.go",
        "discussion_id": "2273839995",
        "commented_code": "@@ -173,7 +173,7 @@ func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *C\n \t// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),\n \t// but proxy's SidecarScope has been updated(s.computeProxyState -> SetSidecarScope) due to optimizations that skip sidecar scope\n \t// computation.\n-\tif con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion {\n+\tif len(con.proxy.ServiceTargets) == 0 || (con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion) {",
        "comment_created_at": "2025-08-13T15:43:09+00:00",
        "comment_author": "ramaraochavali",
        "comment_body": "> Hmm, it seems like if we are getting the wrong pod does that mean we could get some services and just the wrong one? Or will it always be empty?\r\n\r\nIn our case, it was always empty\r\n\r\n> One concern here is its valid to have 0 services and now we need to recompute every time which could be pretty expensive?\r\n\r\nYes. I agree. That is one of the considerations I had in mind. Not sure how to simplify this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2274191931",
        "repo_full_name": "istio/istio",
        "pr_number": 57334,
        "pr_file": "pilot/pkg/xds/ads.go",
        "discussion_id": "2273839995",
        "commented_code": "@@ -173,7 +173,7 @@ func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *C\n \t// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),\n \t// but proxy's SidecarScope has been updated(s.computeProxyState -> SetSidecarScope) due to optimizations that skip sidecar scope\n \t// computation.\n-\tif con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion {\n+\tif len(con.proxy.ServiceTargets) == 0 || (con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion) {",
        "comment_created_at": "2025-08-13T17:40:46+00:00",
        "comment_author": "sschepens",
        "comment_body": "We hit this problem before, the main problem was that proxy Labels were taken from another pod, this causes a lot of undefined behavior, the given proxy could end up matching services it was not meant to match, but that really depends on the selectors this services have.\r\n\r\nI'm not really sure that this fix is correct, ti catches the case where no service have matched this proxy, but other cases could appear.\r\n\r\n@ramaraochavali what I'm not certain is if this happened even with the fix in #56502, what I mean is, we've stopped experiencing this issues with #56502, if that's enough, then why make these changes?",
        "pr_file_module": null
      },
      {
        "comment_id": "2275312884",
        "repo_full_name": "istio/istio",
        "pr_number": 57334,
        "pr_file": "pilot/pkg/xds/ads.go",
        "discussion_id": "2273839995",
        "commented_code": "@@ -173,7 +173,7 @@ func (s *DiscoveryServer) processRequest(req *discovery.DiscoveryRequest, con *C\n \t// It can happen when `processRequest` comes after push context has been updated(s.initPushContext),\n \t// but proxy's SidecarScope has been updated(s.computeProxyState -> SetSidecarScope) due to optimizations that skip sidecar scope\n \t// computation.\n-\tif con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion {\n+\tif len(con.proxy.ServiceTargets) == 0 || (con.proxy.SidecarScope != nil && con.proxy.SidecarScope.Version != request.Push.PushVersion) {",
        "comment_created_at": "2025-08-14T04:20:12+00:00",
        "comment_author": "ramaraochavali",
        "comment_body": "> I'm not really sure that this fix is correct, ti catches the case where no service have matched this proxy, but other cases could appear.\r\n\r\n100% agree. I was also not comfortable with this fix. But just wanted to get others thoughts as well on this. I do not think there is easy way to identify when to recompute service targets - One way is always recompute but that is expensive to do\r\n\r\n> what I'm not certain is if this happened even with the fix in https://github.com/istio/istio/pull/56502, what I mean is, we've stopped experiencing this issues with https://github.com/istio/istio/pull/56502, if that's enough, then why make these changes?\r\n\r\nGood to know that fix helped you. I will remove these changes and leave the metrics part in this PR\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1050536258",
    "pr_number": 42486,
    "pr_file": "pkg/wasm/module_getter.go",
    "created_at": "2022-12-16T09:28:35+00:00",
    "commented_code": "+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package wasm\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\n+\tadminv3 \"github.com/envoyproxy/go-control-plane/envoy/admin/v3\"\n+\tcore \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n+\twasm \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3\"\n+\t\"google.golang.org/protobuf/encoding/protojson\"\n+\n+\t\"istio.io/istio/pkg/util/configdump\"\n+\t\"istio.io/istio/pkg/util/sets\"\n+)\n+\n+type ModuleGetter interface {\n+\tListUsingModules() (sets.String, error)\n+}\n+\n+type LocalModuleGetter struct {\n+\tAdminPort     int32\n+\tLocalHostAddr string\n+}\n+\n+func NewLocalModuleGetter(adminPort int32, localhostAddr string) ModuleGetter {\n+\treturn &LocalModuleGetter{\n+\t\tAdminPort:     adminPort,\n+\t\tLocalHostAddr: localhostAddr,\n+\t}\n+}\n+\n+func (g *LocalModuleGetter) ListUsingModules() (sets.String, error) {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1050536258",
        "repo_full_name": "istio/istio",
        "pr_number": 42486,
        "pr_file": "pkg/wasm/module_getter.go",
        "discussion_id": "1050536258",
        "commented_code": "@@ -0,0 +1,96 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package wasm\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\n+\tadminv3 \"github.com/envoyproxy/go-control-plane/envoy/admin/v3\"\n+\tcore \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n+\twasm \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3\"\n+\t\"google.golang.org/protobuf/encoding/protojson\"\n+\n+\t\"istio.io/istio/pkg/util/configdump\"\n+\t\"istio.io/istio/pkg/util/sets\"\n+)\n+\n+type ModuleGetter interface {\n+\tListUsingModules() (sets.String, error)\n+}\n+\n+type LocalModuleGetter struct {\n+\tAdminPort     int32\n+\tLocalHostAddr string\n+}\n+\n+func NewLocalModuleGetter(adminPort int32, localhostAddr string) ModuleGetter {\n+\treturn &LocalModuleGetter{\n+\t\tAdminPort:     adminPort,\n+\t\tLocalHostAddr: localhostAddr,\n+\t}\n+}\n+\n+func (g *LocalModuleGetter) ListUsingModules() (sets.String, error) {",
        "comment_created_at": "2022-12-16T09:28:35+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "I am concerned about the perf",
        "pr_file_module": null
      },
      {
        "comment_id": "1051233571",
        "repo_full_name": "istio/istio",
        "pr_number": 42486,
        "pr_file": "pkg/wasm/module_getter.go",
        "discussion_id": "1050536258",
        "commented_code": "@@ -0,0 +1,96 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package wasm\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\n+\tadminv3 \"github.com/envoyproxy/go-control-plane/envoy/admin/v3\"\n+\tcore \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n+\twasm \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3\"\n+\t\"google.golang.org/protobuf/encoding/protojson\"\n+\n+\t\"istio.io/istio/pkg/util/configdump\"\n+\t\"istio.io/istio/pkg/util/sets\"\n+)\n+\n+type ModuleGetter interface {\n+\tListUsingModules() (sets.String, error)\n+}\n+\n+type LocalModuleGetter struct {\n+\tAdminPort     int32\n+\tLocalHostAddr string\n+}\n+\n+func NewLocalModuleGetter(adminPort int32, localhostAddr string) ModuleGetter {\n+\treturn &LocalModuleGetter{\n+\t\tAdminPort:     adminPort,\n+\t\tLocalHostAddr: localhostAddr,\n+\t}\n+}\n+\n+func (g *LocalModuleGetter) ListUsingModules() (sets.String, error) {",
        "comment_created_at": "2022-12-16T23:27:04+00:00",
        "comment_author": "howardjohn",
        "comment_body": "+1, I am pretty strongly against using config_dump in anything other than debugging context.\r\n\r\n*if* we did, there is a way to filter it though: https://www.envoyproxy.io/docs/envoy/latest/operations/admin#get--config_dump?mask=",
        "pr_file_module": null
      },
      {
        "comment_id": "1051275542",
        "repo_full_name": "istio/istio",
        "pr_number": 42486,
        "pr_file": "pkg/wasm/module_getter.go",
        "discussion_id": "1050536258",
        "commented_code": "@@ -0,0 +1,96 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package wasm\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\n+\tadminv3 \"github.com/envoyproxy/go-control-plane/envoy/admin/v3\"\n+\tcore \"github.com/envoyproxy/go-control-plane/envoy/config/core/v3\"\n+\twasm \"github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/wasm/v3\"\n+\t\"google.golang.org/protobuf/encoding/protojson\"\n+\n+\t\"istio.io/istio/pkg/util/configdump\"\n+\t\"istio.io/istio/pkg/util/sets\"\n+)\n+\n+type ModuleGetter interface {\n+\tListUsingModules() (sets.String, error)\n+}\n+\n+type LocalModuleGetter struct {\n+\tAdminPort     int32\n+\tLocalHostAddr string\n+}\n+\n+func NewLocalModuleGetter(adminPort int32, localhostAddr string) ModuleGetter {\n+\treturn &LocalModuleGetter{\n+\t\tAdminPort:     adminPort,\n+\t\tLocalHostAddr: localhostAddr,\n+\t}\n+}\n+\n+func (g *LocalModuleGetter) ListUsingModules() (sets.String, error) {",
        "comment_created_at": "2022-12-17T01:12:35+00:00",
        "comment_author": "zirain",
        "comment_body": "I agree with that `config_dump is not an elegant way`, and we need more experiments before introducing `TTL`\r\n\r\nSpeaking of performance issues, interval should not be very short in a real world, but as your said with `mask` will be better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193101122",
    "pr_number": 56497,
    "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
    "created_at": "2025-07-08T17:42:24+00:00",
    "commented_code": "// All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {\n-\tres := slices.Map(a.workloads.List(), modelWorkloadToAddressInfo)\n+\tvar res []model.AddressInfo\n+\tvar localNetwork string\n+\tif ln := a.networks.LocalSystemNamespace.Get(); ln != nil {\n+\t\tlocalNetwork = *ln\n+\t} else {\n+\t\tlog.Warnf(\"Local system namespace is not set, cannot determine local network for ambient index.\" +\n+\t\t\t\" Defaults to an unset network\")\n+\t}\n+\t// Add all workloads\n+\tfor _, wl := range a.workloads.List() {\n+\t\t// If EnableAmbientMultiNetwork is enabled, we only want to add workloads that are local to this cluster\n+\t\t// Non cluster local workloads will be added by the service lookup\n+\t\tif features.EnableAmbientMultiNetwork && wl.Workload.Network != localNetwork {\n+\t\t\tcontinue\n+\t\t}\n+\t\tres = append(res, wl.AsAddress)\n+\t}\n+\t// Add all services\n \tfor _, s := range a.services.List() {\n+\t\tif features.EnableAmbientMultiNetwork && s.Scope == model.Global {\n+\t\t\t// If EnableAmbientMultiNetwork is enabled, we want to add workloads that correspond to global services\n+\t\t\tfor _, wl := range a.workloads.ByServiceKey.Lookup(s.ResourceName()) {\n+\t\t\t\tif wl.Workload.Network != localNetwork {\n+\t\t\t\t\tres = append(res, wl.AsAddress)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tres = append(res, s.AsAddress)\n \t}\n \treturn res\n }\n \n+// AllLocalNetworkGlobalServices returns all known globally scoped services and local\n+// waypoints containing global services. Result is un-ordered\n+func (a *index) AllLocalNetworkGlobalServices(key model.WaypointKey) []model.ServiceInfo {\n+\tvar res []model.ServiceInfo\n+\tfor _, svc := range a.services.List() {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2193101122",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2193101122",
        "commented_code": "@@ -638,13 +646,84 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {\n-\tres := slices.Map(a.workloads.List(), modelWorkloadToAddressInfo)\n+\tvar res []model.AddressInfo\n+\tvar localNetwork string\n+\tif ln := a.networks.LocalSystemNamespace.Get(); ln != nil {\n+\t\tlocalNetwork = *ln\n+\t} else {\n+\t\tlog.Warnf(\"Local system namespace is not set, cannot determine local network for ambient index.\" +\n+\t\t\t\" Defaults to an unset network\")\n+\t}\n+\t// Add all workloads\n+\tfor _, wl := range a.workloads.List() {\n+\t\t// If EnableAmbientMultiNetwork is enabled, we only want to add workloads that are local to this cluster\n+\t\t// Non cluster local workloads will be added by the service lookup\n+\t\tif features.EnableAmbientMultiNetwork && wl.Workload.Network != localNetwork {\n+\t\t\tcontinue\n+\t\t}\n+\t\tres = append(res, wl.AsAddress)\n+\t}\n+\t// Add all services\n \tfor _, s := range a.services.List() {\n+\t\tif features.EnableAmbientMultiNetwork && s.Scope == model.Global {\n+\t\t\t// If EnableAmbientMultiNetwork is enabled, we want to add workloads that correspond to global services\n+\t\t\tfor _, wl := range a.workloads.ByServiceKey.Lookup(s.ResourceName()) {\n+\t\t\t\tif wl.Workload.Network != localNetwork {\n+\t\t\t\t\tres = append(res, wl.AsAddress)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tres = append(res, s.AsAddress)\n \t}\n \treturn res\n }\n \n+// AllLocalNetworkGlobalServices returns all known globally scoped services and local\n+// waypoints containing global services. Result is un-ordered\n+func (a *index) AllLocalNetworkGlobalServices(key model.WaypointKey) []model.ServiceInfo {\n+\tvar res []model.ServiceInfo\n+\tfor _, svc := range a.services.List() {",
        "comment_created_at": "2025-07-08T17:42:24+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Do we really have to loop over every service in the index? Can't we just use ByOwningWaypointHostname and then filter from there?",
        "pr_file_module": null
      },
      {
        "comment_id": "2193169336",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2193101122",
        "commented_code": "@@ -638,13 +646,84 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {\n-\tres := slices.Map(a.workloads.List(), modelWorkloadToAddressInfo)\n+\tvar res []model.AddressInfo\n+\tvar localNetwork string\n+\tif ln := a.networks.LocalSystemNamespace.Get(); ln != nil {\n+\t\tlocalNetwork = *ln\n+\t} else {\n+\t\tlog.Warnf(\"Local system namespace is not set, cannot determine local network for ambient index.\" +\n+\t\t\t\" Defaults to an unset network\")\n+\t}\n+\t// Add all workloads\n+\tfor _, wl := range a.workloads.List() {\n+\t\t// If EnableAmbientMultiNetwork is enabled, we only want to add workloads that are local to this cluster\n+\t\t// Non cluster local workloads will be added by the service lookup\n+\t\tif features.EnableAmbientMultiNetwork && wl.Workload.Network != localNetwork {\n+\t\t\tcontinue\n+\t\t}\n+\t\tres = append(res, wl.AsAddress)\n+\t}\n+\t// Add all services\n \tfor _, s := range a.services.List() {\n+\t\tif features.EnableAmbientMultiNetwork && s.Scope == model.Global {\n+\t\t\t// If EnableAmbientMultiNetwork is enabled, we want to add workloads that correspond to global services\n+\t\t\tfor _, wl := range a.workloads.ByServiceKey.Lookup(s.ResourceName()) {\n+\t\t\t\tif wl.Workload.Network != localNetwork {\n+\t\t\t\t\tres = append(res, wl.AsAddress)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tres = append(res, s.AsAddress)\n \t}\n \treturn res\n }\n \n+// AllLocalNetworkGlobalServices returns all known globally scoped services and local\n+// waypoints containing global services. Result is un-ordered\n+func (a *index) AllLocalNetworkGlobalServices(key model.WaypointKey) []model.ServiceInfo {\n+\tvar res []model.ServiceInfo\n+\tfor _, svc := range a.services.List() {",
        "comment_created_at": "2025-07-08T18:20:23+00:00",
        "comment_author": "jaellio",
        "comment_body": "Does `ByOwningWaypointHostname` work for east west gateways in our case?",
        "pr_file_module": null
      },
      {
        "comment_id": "2193190896",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2193101122",
        "commented_code": "@@ -638,13 +646,84 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {\n-\tres := slices.Map(a.workloads.List(), modelWorkloadToAddressInfo)\n+\tvar res []model.AddressInfo\n+\tvar localNetwork string\n+\tif ln := a.networks.LocalSystemNamespace.Get(); ln != nil {\n+\t\tlocalNetwork = *ln\n+\t} else {\n+\t\tlog.Warnf(\"Local system namespace is not set, cannot determine local network for ambient index.\" +\n+\t\t\t\" Defaults to an unset network\")\n+\t}\n+\t// Add all workloads\n+\tfor _, wl := range a.workloads.List() {\n+\t\t// If EnableAmbientMultiNetwork is enabled, we only want to add workloads that are local to this cluster\n+\t\t// Non cluster local workloads will be added by the service lookup\n+\t\tif features.EnableAmbientMultiNetwork && wl.Workload.Network != localNetwork {\n+\t\t\tcontinue\n+\t\t}\n+\t\tres = append(res, wl.AsAddress)\n+\t}\n+\t// Add all services\n \tfor _, s := range a.services.List() {\n+\t\tif features.EnableAmbientMultiNetwork && s.Scope == model.Global {\n+\t\t\t// If EnableAmbientMultiNetwork is enabled, we want to add workloads that correspond to global services\n+\t\t\tfor _, wl := range a.workloads.ByServiceKey.Lookup(s.ResourceName()) {\n+\t\t\t\tif wl.Workload.Network != localNetwork {\n+\t\t\t\t\tres = append(res, wl.AsAddress)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tres = append(res, s.AsAddress)\n \t}\n \treturn res\n }\n \n+// AllLocalNetworkGlobalServices returns all known globally scoped services and local\n+// waypoints containing global services. Result is un-ordered\n+func (a *index) AllLocalNetworkGlobalServices(key model.WaypointKey) []model.ServiceInfo {\n+\tvar res []model.ServiceInfo\n+\tfor _, svc := range a.services.List() {",
        "comment_created_at": "2025-07-08T18:27:55+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Not sure; worst case we can add a new index too right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2193221303",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2193101122",
        "commented_code": "@@ -638,13 +646,84 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {\n-\tres := slices.Map(a.workloads.List(), modelWorkloadToAddressInfo)\n+\tvar res []model.AddressInfo\n+\tvar localNetwork string\n+\tif ln := a.networks.LocalSystemNamespace.Get(); ln != nil {\n+\t\tlocalNetwork = *ln\n+\t} else {\n+\t\tlog.Warnf(\"Local system namespace is not set, cannot determine local network for ambient index.\" +\n+\t\t\t\" Defaults to an unset network\")\n+\t}\n+\t// Add all workloads\n+\tfor _, wl := range a.workloads.List() {\n+\t\t// If EnableAmbientMultiNetwork is enabled, we only want to add workloads that are local to this cluster\n+\t\t// Non cluster local workloads will be added by the service lookup\n+\t\tif features.EnableAmbientMultiNetwork && wl.Workload.Network != localNetwork {\n+\t\t\tcontinue\n+\t\t}\n+\t\tres = append(res, wl.AsAddress)\n+\t}\n+\t// Add all services\n \tfor _, s := range a.services.List() {\n+\t\tif features.EnableAmbientMultiNetwork && s.Scope == model.Global {\n+\t\t\t// If EnableAmbientMultiNetwork is enabled, we want to add workloads that correspond to global services\n+\t\t\tfor _, wl := range a.workloads.ByServiceKey.Lookup(s.ResourceName()) {\n+\t\t\t\tif wl.Workload.Network != localNetwork {\n+\t\t\t\t\tres = append(res, wl.AsAddress)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tres = append(res, s.AsAddress)\n \t}\n \treturn res\n }\n \n+// AllLocalNetworkGlobalServices returns all known globally scoped services and local\n+// waypoints containing global services. Result is un-ordered\n+func (a *index) AllLocalNetworkGlobalServices(key model.WaypointKey) []model.ServiceInfo {\n+\tvar res []model.ServiceInfo\n+\tfor _, svc := range a.services.List() {",
        "comment_created_at": "2025-07-08T18:47:32+00:00",
        "comment_author": "jaellio",
        "comment_body": "Will add a comment to add a new index or revisit this section for perf improvements in Beta.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1452223985",
    "pr_number": 47273,
    "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
    "created_at": "2024-01-15T10:52:39+00:00",
    "commented_code": "return out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1452223985",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-15T10:52:39+00:00",
        "comment_author": "wulianglongrd",
        "comment_body": "I'm guessing there might be a performance issue here. It might be better to use string builder overall.",
        "pr_file_module": null
      },
      {
        "comment_id": "1454549692",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T04:23:49+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @wulianglongrd, I understand that you mean I need to convert `portNum` into a string before using `fmt.Sprintf`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1454587413",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T04:58:33+00:00",
        "comment_author": "wulianglongrd",
        "comment_body": "```\r\nfunc BenchmarkGetEndpointKey(b *testing.B) {\r\n\tips := []string{\"127.0.0.1\", \"1.2.3.4\"}\r\n\r\n\tb.Run(\"old\", func(b *testing.B) {\r\n\t\tfor i := 0; i < b.N; i++ {\r\n\t\t\tgetEndpointKey(\"foo\", 80, ips)\r\n\t\t}\r\n\t})\r\n\tb.Run(\"new\", func(b *testing.B) {\r\n\t\tfor i := 0; i < b.N; i++ {\r\n\t\t\tgetEndpointKeyV2(\"foo\", 80, ips)\r\n\t\t}\r\n\t})\r\n}\r\n\r\n// This is the current implementation\r\nfunc getEndpointKey(portName string, portNum int32, ips []string) string {\r\n\tvar ipaddrs []string\r\n\tipaddrs = append(ipaddrs, ips...)\r\n\tipString := strings.Join(ipaddrs, \", \") // why is there a blank needed here?\r\n\treturn fmt.Sprintf(\"%s-%s-%d\", ipString, portName, portNum)\r\n}\r\n\r\n// This implementation performs better.\r\nfunc getEndpointKeyV2(portName string, portNum int32, ips []string) string {\r\n\tvar b strings.Builder\r\n\tfor k, ip := range ips {\r\n\t\tif k > 0 {\r\n\t\t\tb.WriteString(\", \")\r\n\t\t}\r\n\t\tb.WriteString(ip)\r\n\t}\r\n\r\n\tb.WriteString(\"-\")\r\n\tb.WriteString(portName)\r\n\tb.WriteString(\"-\")\r\n\tb.WriteString(strconv.Itoa(int(portNum)))\r\n\r\n\treturn b.String()\r\n}\r\n```\r\nbenchmark result:\r\n```\r\n$ go test -run=\"none\" -bench=\"BenchmarkGetEndpointKey\" -test.benchmem . -count=3\r\ngoos: darwin\r\ngoarch: amd64\r\npkg: github.com/wulianglongrd/learning-golang/demo\r\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\r\nBenchmarkGetEndpointKey/old-12         \t 3748388\t       317.4 ns/op\t     120 B/op\t       5 allocs/op\r\nBenchmarkGetEndpointKey/old-12         \t 3886032\t       310.5 ns/op\t     120 B/op\t       5 allocs/op\r\nBenchmarkGetEndpointKey/old-12         \t 3798856\t       311.7 ns/op\t     120 B/op\t       5 allocs/op\r\nBenchmarkGetEndpointKey/new-12         \t15885232\t        75.82 ns/op\t      48 B/op\t       2 allocs/op\r\nBenchmarkGetEndpointKey/new-12         \t15971180\t        74.67 ns/op\t      48 B/op\t       2 allocs/op\r\nBenchmarkGetEndpointKey/new-12         \t16095555\t        75.01 ns/op\t      48 B/op\t       2 allocs/op\r\nPASS\r\nok  \tgithub.com/wulianglongrd/learning-golang/demo\t8.766s\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1454930280",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T08:27:53+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @wulianglongrd, thanks for the performance test. I noticed that there are primary 2 changes:\r\n1. convert int32 into string for `portNum`\r\n2. use strings.Builder to join strings instead `fmt.Sprintf`\r\n\r\nWhich change do you think is the most important for this enhancement, or both of them? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1454939642",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T08:32:18+00:00",
        "comment_author": "wulianglongrd",
        "comment_body": "`fmt.Sprintf` i think",
        "pr_file_module": null
      },
      {
        "comment_id": "1455024914",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T09:10:23+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "If so, I can replace `fmt.Sprintf` with `strings.Join`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1455028475",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T09:12:01+00:00",
        "comment_author": "wulianglongrd",
        "comment_body": "To clarify, I mean the `fmt.Sprintf` function has low performance. It is about 50% lower than concat using `+` (see benchmark #48683 ). However, this is a big PR, these optimizations are probably trivial, and I'm a bit nitpicky and ignore it LGTM.",
        "pr_file_module": null
      },
      {
        "comment_id": "1455041189",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/endpointslice.go",
        "discussion_id": "1452223985",
        "commented_code": "@@ -59,6 +61,14 @@ func newEndpointSliceController(c *Controller) *endpointSliceController {\n \treturn out\n }\n \n+// getEndpointKey generates a unique key for the endpoints based on ip addresses, portName and portNum.\n+func getEndpointKey(portName string, portNum int32, ips []string) string {",
        "comment_created_at": "2024-01-17T09:17:46+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @wulianglongrd, it's okay, I prefer `strings.Join` to concat all string together, please check my newest submission, and thank you so much for your suggestion! ^_^",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1113682838",
    "pr_number": 42372,
    "pr_file": "cni/pkg/ambient/net.go",
    "created_at": "2023-02-21T23:46:45+00:00",
    "commented_code": "}, nil\n }\n \n+func buildEbpfArgsByIP(ip string, isZtunnel, isRemove bool) (*ebpf.RedirectArgs, error) {\n+\tipAddr, err := netip.ParseAddr(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to parse ip(%s): %v\", ip, err)\n+\t}\n+\tveth, err := getVethWithDestinationOf(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get device: %v\", err)\n+\t}\n+\tpeerIndex, err := getPeerIndex(veth)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get veth peerIndex: %v\", err)\n+\t}\n+\n+\tpeerNs, err := getNsNameFromNsID(veth.Attrs().NetNsID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get ns name: %v\", err)\n+\t}\n+\n+\tmac, err := getMacFromNsIdx(peerNs, peerIndex)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &ebpf.RedirectArgs{\n+\t\tIPAddrs:   []netip.Addr{ipAddr},\n+\t\tMacAddr:   mac,\n+\t\tIfindex:   veth.Attrs().Index,\n+\t\tPeerIndex: peerIndex,\n+\t\tPeerNs:    peerNs,\n+\t\tIsZtunnel: isZtunnel,\n+\t\tRemove:    isRemove,\n+\t}, nil\n+}\n+\n+// GetHostIPByRoute get the automatically chosen host ip to the Pod's CIDR\n+func GetHostIPByRoute(kubeClient kubernetes.Interface) (string, error) {\n+\t// We assume per node POD's CIDR is the same block, so the route to the POD\n+\t// from host should be \"same\". Otherwise, there may multiple host IPs will be\n+\t// used as source to dial to PODs.\n+\tpods, err := kubeClient.CoreV1().Pods(metav1.NamespaceAll).List(",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1113682838",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ambient/net.go",
        "discussion_id": "1113682838",
        "commented_code": "@@ -197,6 +202,77 @@ func buildRouteFromPod(pod *corev1.Pod, ip string) ([]string, error) {\n \t}, nil\n }\n \n+func buildEbpfArgsByIP(ip string, isZtunnel, isRemove bool) (*ebpf.RedirectArgs, error) {\n+\tipAddr, err := netip.ParseAddr(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to parse ip(%s): %v\", ip, err)\n+\t}\n+\tveth, err := getVethWithDestinationOf(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get device: %v\", err)\n+\t}\n+\tpeerIndex, err := getPeerIndex(veth)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get veth peerIndex: %v\", err)\n+\t}\n+\n+\tpeerNs, err := getNsNameFromNsID(veth.Attrs().NetNsID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get ns name: %v\", err)\n+\t}\n+\n+\tmac, err := getMacFromNsIdx(peerNs, peerIndex)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &ebpf.RedirectArgs{\n+\t\tIPAddrs:   []netip.Addr{ipAddr},\n+\t\tMacAddr:   mac,\n+\t\tIfindex:   veth.Attrs().Index,\n+\t\tPeerIndex: peerIndex,\n+\t\tPeerNs:    peerNs,\n+\t\tIsZtunnel: isZtunnel,\n+\t\tRemove:    isRemove,\n+\t}, nil\n+}\n+\n+// GetHostIPByRoute get the automatically chosen host ip to the Pod's CIDR\n+func GetHostIPByRoute(kubeClient kubernetes.Interface) (string, error) {\n+\t// We assume per node POD's CIDR is the same block, so the route to the POD\n+\t// from host should be \"same\". Otherwise, there may multiple host IPs will be\n+\t// used as source to dial to PODs.\n+\tpods, err := kubeClient.CoreV1().Pods(metav1.NamespaceAll).List(",
        "comment_created_at": "2023-02-21T23:46:45+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Making unbounded direct List calls to the API server is not scalable. We already have an informer, please use `s.podLister` instead",
        "pr_file_module": null
      },
      {
        "comment_id": "1113745035",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ambient/net.go",
        "discussion_id": "1113682838",
        "commented_code": "@@ -197,6 +202,77 @@ func buildRouteFromPod(pod *corev1.Pod, ip string) ([]string, error) {\n \t}, nil\n }\n \n+func buildEbpfArgsByIP(ip string, isZtunnel, isRemove bool) (*ebpf.RedirectArgs, error) {\n+\tipAddr, err := netip.ParseAddr(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to parse ip(%s): %v\", ip, err)\n+\t}\n+\tveth, err := getVethWithDestinationOf(ip)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get device: %v\", err)\n+\t}\n+\tpeerIndex, err := getPeerIndex(veth)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get veth peerIndex: %v\", err)\n+\t}\n+\n+\tpeerNs, err := getNsNameFromNsID(veth.Attrs().NetNsID)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to get ns name: %v\", err)\n+\t}\n+\n+\tmac, err := getMacFromNsIdx(peerNs, peerIndex)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &ebpf.RedirectArgs{\n+\t\tIPAddrs:   []netip.Addr{ipAddr},\n+\t\tMacAddr:   mac,\n+\t\tIfindex:   veth.Attrs().Index,\n+\t\tPeerIndex: peerIndex,\n+\t\tPeerNs:    peerNs,\n+\t\tIsZtunnel: isZtunnel,\n+\t\tRemove:    isRemove,\n+\t}, nil\n+}\n+\n+// GetHostIPByRoute get the automatically chosen host ip to the Pod's CIDR\n+func GetHostIPByRoute(kubeClient kubernetes.Interface) (string, error) {\n+\t// We assume per node POD's CIDR is the same block, so the route to the POD\n+\t// from host should be \"same\". Otherwise, there may multiple host IPs will be\n+\t// used as source to dial to PODs.\n+\tpods, err := kubeClient.CoreV1().Pods(metav1.NamespaceAll).List(",
        "comment_created_at": "2023-02-22T01:53:29+00:00",
        "comment_author": "PlatformLC",
        "comment_body": "Sure, will use shared Lister instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "865291036",
    "pr_number": 38307,
    "pr_file": "pilot/pkg/model/jwks_resolver.go",
    "created_at": "2022-05-04T20:01:05+00:00",
    "commented_code": "lastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "865291036",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-04T20:01:05+00:00",
        "comment_author": "howardjohn",
        "comment_body": "instead of a new channel, is it possible to just do `r.refreshTicker.Reset(r.refreshInterval)`? Not sure if that can be done in concurrent context though\r\n\r\nReason is I am just slightly worried that this will block in edge cases",
        "pr_file_module": null
      },
      {
        "comment_id": "865337531",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-04T20:28:50+00:00",
        "comment_author": "aryan16",
        "comment_body": "It can be done in concurrent execution, but in that case we need to change `r.refreshInterval` (which is 20 mins rn) to some smaller value to make sure that our ticker executes instantly. If we do that there might be other cases which could go wrong.",
        "pr_file_module": null
      },
      {
        "comment_id": "865337998",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-04T20:29:17+00:00",
        "comment_author": "aryan16",
        "comment_body": "what type of edge cases you're talking about though ?",
        "pr_file_module": null
      },
      {
        "comment_id": "865344892",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-04T20:36:54+00:00",
        "comment_author": "howardjohn",
        "comment_body": "oops, misunderstood ticker. Replace what I said with `r.refreshTicker.C <- time.Now()`.\r\n\r\nThe issue would be if the refreshTicker select block is running and slow (it could be making 100s of http calls). We do the send on jwksuriChannel >5 times, it will block until the refreshTicker part is done.\r\n\r\nAlternatively we can just have the on-demand async calls decoupled entirely from the refreshTicker (and probably just refresh that 1 url, not loop over all of them",
        "pr_file_module": null
      },
      {
        "comment_id": "865345191",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-04T20:37:12+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Actually the single call may be better, otherwise for every new jwks we need to refreshall other jwks - may not scale well",
        "pr_file_module": null
      },
      {
        "comment_id": "866323090",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-05T21:19:56+00:00",
        "comment_author": "yangminzhu",
        "comment_body": "> otherwise for every new jwks we need to refreshall other jwks - may not scale well\r\n\r\nyes, we should address this.\r\n\r\nThe other way could be to update the refresh() logic so that it only fetches the jwks URI that are newly added from here.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "866326959",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-05T21:26:12+00:00",
        "comment_author": "aryan16",
        "comment_body": "I have discussed with him, since we don't have many `jwksuri` in the cache in one single time. I will add a new logic in my follow-up work where we will just try to fetch the pubkey only for the jwksuri which is failing.",
        "pr_file_module": null
      },
      {
        "comment_id": "867235263",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-06T21:48:39+00:00",
        "comment_author": "yangminzhu",
        "comment_body": "Could you just do it in this PR? I'm a bit worried about the performance even if the customer is only using a small number of `jwksUri` because each of the `jwksUri` will trigger a new config push right?",
        "pr_file_module": null
      },
      {
        "comment_id": "867258515",
        "repo_full_name": "istio/istio",
        "pr_number": 38307,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "865291036",
        "commented_code": "@@ -259,20 +264,22 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\tlastRefreshedTime: now,\n \t\tlastUsedTime:      now,\n \t})\n-\n+\tif err != nil {\n+\t\t// fetching the public key in the background\n+\t\tjwksuriChannel <- key",
        "comment_created_at": "2022-05-06T23:01:12+00:00",
        "comment_author": "aryan16",
        "comment_body": "even after we refresh one single `jwksuri`, it is gonna create a new config push and will push the whole cache again. The only drawback which I see in our current solution is that it will try to refresh all the `jwksuri` in the cache. \r\n@howardjohn do we have any option to push one single `jwksuri` -> `pubkey` to envoy ?",
        "pr_file_module": null
      }
    ]
  }
]