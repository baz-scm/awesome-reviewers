[
  {
    "discussion_id": "2191026374",
    "pr_number": 56844,
    "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
    "created_at": "2025-07-07T21:18:30+00:00",
    "commented_code": "opts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2191026374",
        "repo_full_name": "istio/istio",
        "pr_number": 56844,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
        "discussion_id": "2191026374",
        "commented_code": "@@ -336,11 +298,114 @@ func (a *index) buildGlobalCollections(\n \t\topts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
        "comment_created_at": "2025-07-07T21:18:30+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Don't love this; should we just create a small private struct instead? Would remove the splitting logic",
        "pr_file_module": null
      },
      {
        "comment_id": "2191051682",
        "repo_full_name": "istio/istio",
        "pr_number": 56844,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
        "discussion_id": "2191026374",
        "commented_code": "@@ -336,11 +298,114 @@ func (a *index) buildGlobalCollections(\n \t\topts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
        "comment_created_at": "2025-07-07T21:41:12+00:00",
        "comment_author": "Stevenjin8",
        "comment_body": "I don't love it either, but to do `AsCollection`, keys have to be strings (krt/index.go:112). Reading it again, we could use `WithIndexCollectionFromString`, but either way, we need to have splitting/encoding logic.",
        "pr_file_module": null
      },
      {
        "comment_id": "2191078385",
        "repo_full_name": "istio/istio",
        "pr_number": 56844,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
        "discussion_id": "2191026374",
        "commented_code": "@@ -336,11 +298,114 @@ func (a *index) buildGlobalCollections(\n \t\topts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
        "comment_created_at": "2025-07-07T22:06:15+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Ah I see; that makes sense. Would be clearer if we dind't need the index I think",
        "pr_file_module": null
      },
      {
        "comment_id": "2191218641",
        "repo_full_name": "istio/istio",
        "pr_number": 56844,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
        "discussion_id": "2191026374",
        "commented_code": "@@ -336,11 +298,114 @@ func (a *index) buildGlobalCollections(\n \t\topts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
        "comment_created_at": "2025-07-08T00:00:18+00:00",
        "comment_author": "Stevenjin8",
        "comment_body": "Maybe, I was thinking about it from a performance POV. I think this way, if a remote workload changes, then we only recalculate the split horizon workload the service;network of that workload. If we didn't do this grouping, it would be for all split horizon workloads of that service (or network, depending on implementation). Admittedly, the number of networks is small and I'm not sure how much overhead and extra level of indirection adds. we want to perform a \"group by service/network\" operation, and that's what adding an index + `AsCollection` does.",
        "pr_file_module": null
      },
      {
        "comment_id": "2195934067",
        "repo_full_name": "istio/istio",
        "pr_number": 56844,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/multicluster.go",
        "discussion_id": "2191026374",
        "commented_code": "@@ -336,11 +298,114 @@ func (a *index) buildGlobalCollections(\n \t\topts,\n \t)\n \n-\tWorkloadAddressIndex := krt.NewIndex[networkAddress, model.WorkloadInfo](GlobalWorkloads, \"networkAddress\", networkAddressFromWorkload)\n-\tWorkloadServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"service\", func(o model.WorkloadInfo) []string {\n+\tworkloadNetworkServiceIndex := krt.NewIndex[string, model.WorkloadInfo](GlobalWorkloads, \"network;service\", func(o model.WorkloadInfo) []string {\n+\t\tres := make([]string, 0, len(o.Workload.Services))\n+\t\tfor svc := range o.Workload.Services {\n+\t\t\tres = append(res, strings.Join([]string{o.Workload.Network, svc}, \";\"))\n+\t\t}\n+\t\treturn res\n+\t})\n+\n+\tcoalescedWorkloads := krt.NewManyCollection(\n+\t\tworkloadNetworkServiceIndex.AsCollection(),\n+\t\tfunc(ctx krt.HandlerContext, i krt.IndexObject[string, model.WorkloadInfo]) []model.WorkloadInfo {\n+\t\t\tparts := strings.Split(i.Key, \";\")",
        "comment_created_at": "2025-07-09T20:41:08+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Yeah that's a fair point on perf. Agreed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1382286522",
    "pr_number": 47273,
    "pr_file": "pilot/pkg/model/service.go",
    "created_at": "2023-11-03T23:31:46+00:00",
    "commented_code": "if first.Endpoint == nil || second.Endpoint == nil {\n \t\treturn first.Endpoint == second.Endpoint\n \t}\n-\tif first.Endpoint.Address != second.Endpoint.Address {\n+\n+\tif len(first.Endpoint.Addresses) == len(second.Endpoint.Addresses) {\n+\t\tfirtAddrs := first.Endpoint.SortIstioEndpointByAddresses()",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1382286522",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/model/service.go",
        "discussion_id": "1382286522",
        "commented_code": "@@ -386,9 +387,19 @@ func WorkloadInstancesEqual(first, second *WorkloadInstance) bool {\n \tif first.Endpoint == nil || second.Endpoint == nil {\n \t\treturn first.Endpoint == second.Endpoint\n \t}\n-\tif first.Endpoint.Address != second.Endpoint.Address {\n+\n+\tif len(first.Endpoint.Addresses) == len(second.Endpoint.Addresses) {\n+\t\tfirtAddrs := first.Endpoint.SortIstioEndpointByAddresses()",
        "comment_created_at": "2023-11-03T23:31:46+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Mutating the resource in an `Equal` function is unexpected and undesired. Plus you can do this more efficiently - see listEqualUnordered in ads.go.\r\n\r\nHowever, again, I strongly encourage us to treat this as an ordered list NOT an unordered one. Or always sort it during creation. We should not be sorting on each access",
        "pr_file_module": null
      },
      {
        "comment_id": "1383038664",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/model/service.go",
        "discussion_id": "1382286522",
        "commented_code": "@@ -386,9 +387,19 @@ func WorkloadInstancesEqual(first, second *WorkloadInstance) bool {\n \tif first.Endpoint == nil || second.Endpoint == nil {\n \t\treturn first.Endpoint == second.Endpoint\n \t}\n-\tif first.Endpoint.Address != second.Endpoint.Address {\n+\n+\tif len(first.Endpoint.Addresses) == len(second.Endpoint.Addresses) {\n+\t\tfirtAddrs := first.Endpoint.SortIstioEndpointByAddresses()",
        "comment_created_at": "2023-11-06T09:55:18+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @howardjohn, okay, got it. I create a `IsAddrsEqualIstioEndpoint` function for it. And it's okay to treat all the addresses of \r\n each Endpoint as an ordered list, then check the equality by using `IsAddrsEqualIstioEndpoint`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "966808137",
    "pr_number": 40887,
    "pr_file": "pkg/util/sets/string.go",
    "created_at": "2022-09-09T09:04:27+00:00",
    "commented_code": "package sets\n \n-import \"sort\"\n+import (\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n \n-type Set map[string]struct{}\n+type Set[T constraints.Ordered] map[T]struct{}\n \n // NewWithLength returns an empty Set with the given capacity.\n // It's only a hint, not a limitation.\n-func NewWithLength(l int) Set {\n-\treturn make(Set, l)\n+func NewWithLength[T constraints.Ordered](l int) Set[T] {\n+\treturn make(Set[T], l)\n }\n \n // New creates a new Set with the given items.\n-func New(items ...string) Set {\n-\ts := NewWithLength(len(items))\n+func New[T constraints.Ordered](items ...T) Set[T] {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "966808137",
        "repo_full_name": "istio/istio",
        "pr_number": 40887,
        "pr_file": "pkg/util/sets/string.go",
        "discussion_id": "966808137",
        "commented_code": "@@ -14,44 +14,47 @@\n \n package sets\n \n-import \"sort\"\n+import (\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n \n-type Set map[string]struct{}\n+type Set[T constraints.Ordered] map[T]struct{}\n \n // NewWithLength returns an empty Set with the given capacity.\n // It's only a hint, not a limitation.\n-func NewWithLength(l int) Set {\n-\treturn make(Set, l)\n+func NewWithLength[T constraints.Ordered](l int) Set[T] {\n+\treturn make(Set[T], l)\n }\n \n // New creates a new Set with the given items.\n-func New(items ...string) Set {\n-\ts := NewWithLength(len(items))\n+func New[T constraints.Ordered](items ...T) Set[T] {",
        "comment_created_at": "2022-09-09T09:04:27+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "This is making the usage more complex, as a fundamental lib , better ux is more important than dedup.\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "967157163",
        "repo_full_name": "istio/istio",
        "pr_number": 40887,
        "pr_file": "pkg/util/sets/string.go",
        "discussion_id": "966808137",
        "commented_code": "@@ -14,44 +14,47 @@\n \n package sets\n \n-import \"sort\"\n+import (\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n \n-type Set map[string]struct{}\n+type Set[T constraints.Ordered] map[T]struct{}\n \n // NewWithLength returns an empty Set with the given capacity.\n // It's only a hint, not a limitation.\n-func NewWithLength(l int) Set {\n-\treturn make(Set, l)\n+func NewWithLength[T constraints.Ordered](l int) Set[T] {\n+\treturn make(Set[T], l)\n }\n \n // New creates a new Set with the given items.\n-func New(items ...string) Set {\n-\ts := NewWithLength(len(items))\n+func New[T constraints.Ordered](items ...T) Set[T] {",
        "comment_created_at": "2022-09-09T14:46:01+00:00",
        "comment_author": "ramaraochavali",
        "comment_body": "I agree to an extent with this. The usage certainly is more complex compared to earlier.",
        "pr_file_module": null
      },
      {
        "comment_id": "967162613",
        "repo_full_name": "istio/istio",
        "pr_number": 40887,
        "pr_file": "pkg/util/sets/string.go",
        "discussion_id": "966808137",
        "commented_code": "@@ -14,44 +14,47 @@\n \n package sets\n \n-import \"sort\"\n+import (\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n \n-type Set map[string]struct{}\n+type Set[T constraints.Ordered] map[T]struct{}\n \n // NewWithLength returns an empty Set with the given capacity.\n // It's only a hint, not a limitation.\n-func NewWithLength(l int) Set {\n-\treturn make(Set, l)\n+func NewWithLength[T constraints.Ordered](l int) Set[T] {\n+\treturn make(Set[T], l)\n }\n \n // New creates a new Set with the given items.\n-func New(items ...string) Set {\n-\ts := NewWithLength(len(items))\n+func New[T constraints.Ordered](items ...T) Set[T] {",
        "comment_created_at": "2022-09-09T14:49:22+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Its _slightly_ more complex for strings - but there are 100s of places where we _should_ be using Sets throughout the code but do not because it isn't generic.\r\n\r\nIf the concern is `sets.Set` -> `sets.Set[string]` is verbose I can add `type String = Set[string]` and then you can use it like `sets.String`?",
        "pr_file_module": null
      },
      {
        "comment_id": "967168809",
        "repo_full_name": "istio/istio",
        "pr_number": 40887,
        "pr_file": "pkg/util/sets/string.go",
        "discussion_id": "966808137",
        "commented_code": "@@ -14,44 +14,47 @@\n \n package sets\n \n-import \"sort\"\n+import (\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n \n-type Set map[string]struct{}\n+type Set[T constraints.Ordered] map[T]struct{}\n \n // NewWithLength returns an empty Set with the given capacity.\n // It's only a hint, not a limitation.\n-func NewWithLength(l int) Set {\n-\treturn make(Set, l)\n+func NewWithLength[T constraints.Ordered](l int) Set[T] {\n+\treturn make(Set[T], l)\n }\n \n // New creates a new Set with the given items.\n-func New(items ...string) Set {\n-\ts := NewWithLength(len(items))\n+func New[T constraints.Ordered](items ...T) Set[T] {",
        "comment_created_at": "2022-09-09T14:53:36+00:00",
        "comment_author": "ramaraochavali",
        "comment_body": "That seems like a good idea to me for readability.",
        "pr_file_module": null
      }
    ]
  }
]