[
  {
    "discussion_id": "2222685052",
    "pr_number": 57091,
    "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
    "created_at": "2025-07-22T14:16:31+00:00",
    "commented_code": "existingService := ptr.Flatten(servicesCollection.GetKey(pool.shadowService.key.String()))\n \n \t\t// Check if we can manage this service\n-\t\tvar existingLabels map[string]string\n \t\tif existingService != nil {\n-\t\t\texistingLabels = existingService.GetLabels()\n \t\t\tcanManage, _ := c.canManageShadowServiceForInference(existingService)\n \t\t\tif !canManage {\n \t\t\t\tlog.Debugf(\"skipping service %s/%s, already managed by another controller\", key.Namespace, key.Name)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \n-\t\tservice := translateShadowServiceToService(existingLabels, pool.shadowService, pool.extRef)\n+\t\tservice := translateShadowServiceToService(pool.shadowService, pool.extRef)\n \n \t\tvar err error\n \t\tif existingService == nil {\n \t\t\t// Create the service if it doesn't exist\n \t\t\t_, err = svcClient.Create(service)\n \t\t} else {\n-\t\t\t// TODO: Don't overwrite resources: https://github.com/istio/istio/issues/56667\n-\t\t\tservice.ResourceVersion = existingService.ResourceVersion\n-\t\t\t_, err = svcClient.Update(service)\n+\t\t\t// Patch the service if it already exists\n+\t\t\tvar patchBytes []byte\n+\t\t\tpatchBytes, err = c.generateShadowServicePatch(existingService, service)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err = svcClient.Patch(existingService.Name, existingService.Namespace, types.MergePatchType, patchBytes)\n \t\t}\n \n \t\treturn err\n \t}\n }\n \n-// canManage checks if a service should be managed by this controller\n+func (c *Controller) generateShadowServicePatch(existing, desired *corev1.Service) ([]byte, error) {\n+\tupdated := existing.DeepCopy()\n+\n+\t// Merge labels and annotations\n+\tupdated.Annotations = maps.MergeCopy(existing.Annotations, desired.Annotations)",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2222685052",
        "repo_full_name": "istio/istio",
        "pr_number": 57091,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2222685052",
        "commented_code": "@@ -537,33 +539,60 @@ func (c *Controller) reconcileShadowService(\n \t\texistingService := ptr.Flatten(servicesCollection.GetKey(pool.shadowService.key.String()))\n \n \t\t// Check if we can manage this service\n-\t\tvar existingLabels map[string]string\n \t\tif existingService != nil {\n-\t\t\texistingLabels = existingService.GetLabels()\n \t\t\tcanManage, _ := c.canManageShadowServiceForInference(existingService)\n \t\t\tif !canManage {\n \t\t\t\tlog.Debugf(\"skipping service %s/%s, already managed by another controller\", key.Namespace, key.Name)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \n-\t\tservice := translateShadowServiceToService(existingLabels, pool.shadowService, pool.extRef)\n+\t\tservice := translateShadowServiceToService(pool.shadowService, pool.extRef)\n \n \t\tvar err error\n \t\tif existingService == nil {\n \t\t\t// Create the service if it doesn't exist\n \t\t\t_, err = svcClient.Create(service)\n \t\t} else {\n-\t\t\t// TODO: Don't overwrite resources: https://github.com/istio/istio/issues/56667\n-\t\t\tservice.ResourceVersion = existingService.ResourceVersion\n-\t\t\t_, err = svcClient.Update(service)\n+\t\t\t// Patch the service if it already exists\n+\t\t\tvar patchBytes []byte\n+\t\t\tpatchBytes, err = c.generateShadowServicePatch(existingService, service)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err = svcClient.Patch(existingService.Name, existingService.Namespace, types.MergePatchType, patchBytes)\n \t\t}\n \n \t\treturn err\n \t}\n }\n \n-// canManage checks if a service should be managed by this controller\n+func (c *Controller) generateShadowServicePatch(existing, desired *corev1.Service) ([]byte, error) {\n+\tupdated := existing.DeepCopy()\n+\n+\t// Merge labels and annotations\n+\tupdated.Annotations = maps.MergeCopy(existing.Annotations, desired.Annotations)",
        "comment_created_at": "2025-07-22T14:16:31+00:00",
        "comment_author": "howardjohn",
        "comment_body": "If we are doing a patch won't k8s do the merge for us?\r\n\r\nAlso this means we can never remove things IIUC patches correctly (not certain I do)",
        "pr_file_module": null
      },
      {
        "comment_id": "2222839505",
        "repo_full_name": "istio/istio",
        "pr_number": 57091,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2222685052",
        "commented_code": "@@ -537,33 +539,60 @@ func (c *Controller) reconcileShadowService(\n \t\texistingService := ptr.Flatten(servicesCollection.GetKey(pool.shadowService.key.String()))\n \n \t\t// Check if we can manage this service\n-\t\tvar existingLabels map[string]string\n \t\tif existingService != nil {\n-\t\t\texistingLabels = existingService.GetLabels()\n \t\t\tcanManage, _ := c.canManageShadowServiceForInference(existingService)\n \t\t\tif !canManage {\n \t\t\t\tlog.Debugf(\"skipping service %s/%s, already managed by another controller\", key.Namespace, key.Name)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \n-\t\tservice := translateShadowServiceToService(existingLabels, pool.shadowService, pool.extRef)\n+\t\tservice := translateShadowServiceToService(pool.shadowService, pool.extRef)\n \n \t\tvar err error\n \t\tif existingService == nil {\n \t\t\t// Create the service if it doesn't exist\n \t\t\t_, err = svcClient.Create(service)\n \t\t} else {\n-\t\t\t// TODO: Don't overwrite resources: https://github.com/istio/istio/issues/56667\n-\t\t\tservice.ResourceVersion = existingService.ResourceVersion\n-\t\t\t_, err = svcClient.Update(service)\n+\t\t\t// Patch the service if it already exists\n+\t\t\tvar patchBytes []byte\n+\t\t\tpatchBytes, err = c.generateShadowServicePatch(existingService, service)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err = svcClient.Patch(existingService.Name, existingService.Namespace, types.MergePatchType, patchBytes)\n \t\t}\n \n \t\treturn err\n \t}\n }\n \n-// canManage checks if a service should be managed by this controller\n+func (c *Controller) generateShadowServicePatch(existing, desired *corev1.Service) ([]byte, error) {\n+\tupdated := existing.DeepCopy()\n+\n+\t// Merge labels and annotations\n+\tupdated.Annotations = maps.MergeCopy(existing.Annotations, desired.Annotations)",
        "comment_created_at": "2025-07-22T15:01:58+00:00",
        "comment_author": "dgn",
        "comment_body": "Yeah, but the thing is that to generate a good patch, you need full information about what the current resource status is and what it should look like at the end, that's why the merges are required. But your point about SSA is completely correct, I'll look into that, I guess using Patch is bit old-school now",
        "pr_file_module": null
      },
      {
        "comment_id": "2222864152",
        "repo_full_name": "istio/istio",
        "pr_number": 57091,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2222685052",
        "commented_code": "@@ -537,33 +539,60 @@ func (c *Controller) reconcileShadowService(\n \t\texistingService := ptr.Flatten(servicesCollection.GetKey(pool.shadowService.key.String()))\n \n \t\t// Check if we can manage this service\n-\t\tvar existingLabels map[string]string\n \t\tif existingService != nil {\n-\t\t\texistingLabels = existingService.GetLabels()\n \t\t\tcanManage, _ := c.canManageShadowServiceForInference(existingService)\n \t\t\tif !canManage {\n \t\t\t\tlog.Debugf(\"skipping service %s/%s, already managed by another controller\", key.Namespace, key.Name)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \n-\t\tservice := translateShadowServiceToService(existingLabels, pool.shadowService, pool.extRef)\n+\t\tservice := translateShadowServiceToService(pool.shadowService, pool.extRef)\n \n \t\tvar err error\n \t\tif existingService == nil {\n \t\t\t// Create the service if it doesn't exist\n \t\t\t_, err = svcClient.Create(service)\n \t\t} else {\n-\t\t\t// TODO: Don't overwrite resources: https://github.com/istio/istio/issues/56667\n-\t\t\tservice.ResourceVersion = existingService.ResourceVersion\n-\t\t\t_, err = svcClient.Update(service)\n+\t\t\t// Patch the service if it already exists\n+\t\t\tvar patchBytes []byte\n+\t\t\tpatchBytes, err = c.generateShadowServicePatch(existingService, service)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err = svcClient.Patch(existingService.Name, existingService.Namespace, types.MergePatchType, patchBytes)\n \t\t}\n \n \t\treturn err\n \t}\n }\n \n-// canManage checks if a service should be managed by this controller\n+func (c *Controller) generateShadowServicePatch(existing, desired *corev1.Service) ([]byte, error) {\n+\tupdated := existing.DeepCopy()\n+\n+\t// Merge labels and annotations\n+\tupdated.Annotations = maps.MergeCopy(existing.Annotations, desired.Annotations)",
        "comment_created_at": "2025-07-22T15:08:12+00:00",
        "comment_author": "dgn",
        "comment_body": "Actually it might not even be required here I realize; I was worried jsonmerge would generate a `replace` directive for the entire annotations/labels if I don't do this. Not sure if that's the case though. Anyway, it's not required for SSA so we can drop it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223256564",
        "repo_full_name": "istio/istio",
        "pr_number": 57091,
        "pr_file": "pilot/pkg/config/kube/gateway/inferencepool_collection.go",
        "discussion_id": "2222685052",
        "commented_code": "@@ -537,33 +539,60 @@ func (c *Controller) reconcileShadowService(\n \t\texistingService := ptr.Flatten(servicesCollection.GetKey(pool.shadowService.key.String()))\n \n \t\t// Check if we can manage this service\n-\t\tvar existingLabels map[string]string\n \t\tif existingService != nil {\n-\t\t\texistingLabels = existingService.GetLabels()\n \t\t\tcanManage, _ := c.canManageShadowServiceForInference(existingService)\n \t\t\tif !canManage {\n \t\t\t\tlog.Debugf(\"skipping service %s/%s, already managed by another controller\", key.Namespace, key.Name)\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \n-\t\tservice := translateShadowServiceToService(existingLabels, pool.shadowService, pool.extRef)\n+\t\tservice := translateShadowServiceToService(pool.shadowService, pool.extRef)\n \n \t\tvar err error\n \t\tif existingService == nil {\n \t\t\t// Create the service if it doesn't exist\n \t\t\t_, err = svcClient.Create(service)\n \t\t} else {\n-\t\t\t// TODO: Don't overwrite resources: https://github.com/istio/istio/issues/56667\n-\t\t\tservice.ResourceVersion = existingService.ResourceVersion\n-\t\t\t_, err = svcClient.Update(service)\n+\t\t\t// Patch the service if it already exists\n+\t\t\tvar patchBytes []byte\n+\t\t\tpatchBytes, err = c.generateShadowServicePatch(existingService, service)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err = svcClient.Patch(existingService.Name, existingService.Namespace, types.MergePatchType, patchBytes)\n \t\t}\n \n \t\treturn err\n \t}\n }\n \n-// canManage checks if a service should be managed by this controller\n+func (c *Controller) generateShadowServicePatch(existing, desired *corev1.Service) ([]byte, error) {\n+\tupdated := existing.DeepCopy()\n+\n+\t// Merge labels and annotations\n+\tupdated.Annotations = maps.MergeCopy(existing.Annotations, desired.Annotations)",
        "comment_created_at": "2025-07-22T17:05:12+00:00",
        "comment_author": "dgn",
        "comment_body": "Updated the patch to use SSA like the deploymentcontroller. PTAL",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276988653",
    "pr_number": 57347,
    "pr_file": "pilot/pkg/networking/core/cluster_builder.go",
    "created_at": "2025-08-14T15:36:24+00:00",
    "commented_code": "effectiveProxyConfig := cb.proxyMetadata.ProxyConfigOrDefault(cb.req.Push.Mesh.GetDefaultConfig())\n \tpreserveHeaderCase := effectiveProxyConfig.GetProxyHeaders().GetPreserveHttp1HeaderCase().GetValue()\n \n+\tif isExplicitHTTP {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2276988653",
        "repo_full_name": "istio/istio",
        "pr_number": 57347,
        "pr_file": "pilot/pkg/networking/core/cluster_builder.go",
        "discussion_id": "2276988653",
        "commented_code": "@@ -713,6 +733,10 @@ func (cb *ClusterBuilder) setUpstreamProtocol(cluster *clusterWrapper, port *mod\n \teffectiveProxyConfig := cb.proxyMetadata.ProxyConfigOrDefault(cb.req.Push.Mesh.GetDefaultConfig())\n \tpreserveHeaderCase := effectiveProxyConfig.GetProxyHeaders().GetPreserveHttp1HeaderCase().GetValue()\n \n+\tif isExplicitHTTP {",
        "comment_created_at": "2025-08-14T15:36:24+00:00",
        "comment_author": "Stevenjin8",
        "comment_body": "Not super familiar with when the envoyfilter gets applied, but we should probably merge `setHTTP1Options` to also take into account `PreserveHeaderCase` as in the lines below, otherwise values might get unexpectedly overwritten",
        "pr_file_module": null
      },
      {
        "comment_id": "2277099873",
        "repo_full_name": "istio/istio",
        "pr_number": 57347,
        "pr_file": "pilot/pkg/networking/core/cluster_builder.go",
        "discussion_id": "2276988653",
        "commented_code": "@@ -713,6 +733,10 @@ func (cb *ClusterBuilder) setUpstreamProtocol(cluster *clusterWrapper, port *mod\n \teffectiveProxyConfig := cb.proxyMetadata.ProxyConfigOrDefault(cb.req.Push.Mesh.GetDefaultConfig())\n \tpreserveHeaderCase := effectiveProxyConfig.GetProxyHeaders().GetPreserveHttp1HeaderCase().GetValue()\n \n+\tif isExplicitHTTP {",
        "comment_created_at": "2025-08-14T16:21:36+00:00",
        "comment_author": "wtzhang23",
        "comment_body": "Done. I believe all the envoy filters are applied after all the clusters are originally built, with the exception of clusters added by other envoy filters where no further patches are done for them.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1094737080",
    "pr_number": 43099,
    "pr_file": "pkg/bootstrap/config.go",
    "created_at": "2023-02-02T16:02:07+00:00",
    "commented_code": "opts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1094737080",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-02T16:02:07+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Why is dualstack IPv6 only? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1095256078",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T01:29:07+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @howardjohn, it's okay for IPv6 only to add this option properties. But for dual stack, there are 2 situations:\r\n1. [IPv4, IPv6]: it's working to deploy Istio by following the old code to set the DNSLookupFamilyIPv4\r\n2. [IPv6, IPv4]: it's not working\r\nHowever, we can uniform it by adding `LocalhostIPv4`/ `WildcardIPv4` and setting `DNSLookupFamilyIPv6` and  for IPv6 only and Dual Stack. Does it make sense?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1095293450",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T02:22:03+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Why not auto? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1095293775",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T02:22:38+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I think we use different logic in cluster_builder,does it make sense to differ? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1095307001",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T02:51:26+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Yes, auto would be useful.  \r\nBut I have encountered an issue on different orders of IPs. The k8s cluster can be deployed in different ip order:\r\n\r\nIPv4 first - by default\r\n```\r\nkind: Cluster\r\napiVersion: kind.x-k8s.io/v1alpha4\r\nnetworking:\r\n  ipFamily: dual\r\n  podSubnet: \"10.244.0.0/16, 2001:db8:42:0::/56\"\r\n  serviceSubnet: \"10.96.0.0/12, 2001:db8:42:1::/112\"\r\n```\r\n\r\nIPv6 first:\r\n```\r\nkind: Cluster\r\napiVersion: kind.x-k8s.io/v1alpha4\r\nnetworking:\r\n  ipFamily: dual\r\n  podSubnet: \"2001:db8:42:0::/56,10.244.0.0/16\"\r\n  serviceSubnet: \"2001:db8:42:1::/112,10.96.0.0/12\"\r\n```\r\nHowever, for `DNSLookupFamilyIP` policy setting, its order is fixed.",
        "pr_file_module": null
      },
      {
        "comment_id": "1095366302",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T05:23:01+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "> I think we use different logic in cluster_builder,does it make sense to differ?\r\n\r\nThis is helpful, besides the DNSLookupFamilyIP setting, there is a bug for cluster builder for UpstreamBindConfig",
        "pr_file_module": null
      },
      {
        "comment_id": "1095999373",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T16:25:09+00:00",
        "comment_author": "howardjohn",
        "comment_body": "The clusters being generate here may be for external addresses I think, by the way. so we cannot rely only on internal k8s config",
        "pr_file_module": null
      },
      {
        "comment_id": "1096000029",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-03T16:25:48+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Its not clear to me why we use IPv6 only for Dual stack. What if I want to connect to github.com (no IPV6)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1096474666",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-04T03:37:10+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "> The clusters being generate here may be for external addresses I think, by the way. so we cannot rely only on internal k8s config\r\n\r\nHi @howardjohn, the clusters generated like this may be for IPv6 applications access as well.  And we generate the `DNSLookupFamilyIP` configuration based on the IP family policies. I have re-submitted for it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1096475491",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-04T03:45:31+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "> Its not clear to me why we use IPv6 only for Dual stack. What if I want to connect to github.com (no IPV6)?\r\n\r\nHi @howardjohn, according to the newest submitting, there are 3 branches for this:\r\n1. IPv4 only\r\n2. IPv6 only\r\n3. Dual Stack\r\nFor 3, I kept the original logic for option's properties if dual stack is disable. And there also are 2 sub-branches for different IP family order. Does it make sense?\r\nAnd for `What if I want to connect to github.com (no IPV6)?`\r\nFor upstream cluster building, there should be 2 bind config for it if source pods are deployed in Dual Stack cluster, so it should be okay because it has both IPv4 and IPv6 addresses. Hope my understand is correct and helpful to answer your question.",
        "pr_file_module": null
      },
      {
        "comment_id": "1097568720",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-06T15:48:04+00:00",
        "comment_author": "howardjohn",
        "comment_body": "sorry, I still don't get it. This configures the bootstrap clusters. Why do we want that to be different from the dynamic clusters? https://github.com/istio/istio/blob/373fc89518c986c9f48ed3cd891930da6fdc8628/pilot/pkg/networking/core/v1alpha3/cluster_builder.go#L370\r\n\r\nThey are used for the same purpose, by the same proxies. Shouldn't we be consistent?",
        "pr_file_module": null
      },
      {
        "comment_id": "1098053451",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-07T00:26:54+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @howardjohn, they are very similar, however there are some different, I can help to explain: \r\n1. The `DnsLookupFamily` setting in `cluster_builder.go` is for cluster DNS, and this PR is for basically for every pod's sidercar  `DnsLookupFamily`\r\n2. They use different implementation method for the IP family checking, `SupportsIPv4` of proxy is used in `cluster_builder.go` and `AllIPv4`/`AllIPv6` of proxy are used in this PR. So they are semantically different.\r\n\r\nAnd another thing is that there is `UpstreamBindConfig` for helping to smartly pick the right endpoint/pod even the default cluster DNS is IPv4. Does it make sense?",
        "pr_file_module": null
      },
      {
        "comment_id": "1098054375",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-07T00:28:55+00:00",
        "comment_author": "howardjohn",
        "comment_body": "> The DnsLookupFamily setting in cluster_builder.go is for cluster DNS, and this PR is for basically for every pod's sidercar DnsLookupFamily\r\n\r\nIt's the same field in envoy",
        "pr_file_module": null
      },
      {
        "comment_id": "1098076124",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-07T01:13:14+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "> It's the same field in envoy\r\n\r\nYeah, it's just for `STRICT_DNS` cluster, such as `zipkin`. If so, it's okay to make both 2 places are consistent. Thanks John!\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1098097380",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-07T01:58:59+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @howardjohn, re-submitted for cluster's DnsLookupFamily setting",
        "pr_file_module": null
      },
      {
        "comment_id": "1099479758",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-08T00:35:59+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I see the change but cluster_builder logic still doesn't match this file. They are the exact same field in Envoy so I don't see why they should be different",
        "pr_file_module": null
      },
      {
        "comment_id": "1099535077",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1094737080",
        "commented_code": "@@ -118,16 +118,18 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly\n-\tif network.AllIPv6(cfg.Metadata.InstanceIPs) {\n-\t\topts = append(opts,\n-\t\t\toption.Localhost(option.LocalhostIPv6),\n-\t\t\toption.Wildcard(option.WildcardIPv6),\n-\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))\n-\t} else {\n+\tif network.AllIPv4(cfg.Metadata.InstanceIPs) {\n+\t\t// IPv4 only\n \t\topts = append(opts,\n \t\t\toption.Localhost(option.LocalhostIPv4),\n \t\t\toption.Wildcard(option.WildcardIPv4),\n \t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv4))\n+\t} else {\n+\t\t// IPv6 only and Dual Stack\n+\t\topts = append(opts,\n+\t\t\toption.Localhost(option.LocalhostIPv6),\n+\t\t\toption.Wildcard(option.WildcardIPv6),\n+\t\t\toption.DNSLookupFamily(option.DNSLookupFamilyIPv6))",
        "comment_created_at": "2023-02-08T01:39:11+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "Hi @howardjohn, I have updated `DNSLookupFamilyIPv6` from `AUTO` to `V6_ONLY` and added `DNSLookupFamilyIPS` as `ALL` for dual stack case. Re-submitted! Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1095483396",
    "pr_number": 43099,
    "pr_file": "pkg/bootstrap/config.go",
    "created_at": "2023-02-03T08:34:44+00:00",
    "commented_code": "opts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1095483396",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1095483396",
        "commented_code": "@@ -118,16 +119,35 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly",
        "comment_created_at": "2023-02-03T08:34:44+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "I am wondering that dual stack is not well protected under the feature flag  `EnableDualStack`.  I think we should improve\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1095485556",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1095483396",
        "commented_code": "@@ -118,16 +119,35 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly",
        "comment_created_at": "2023-02-03T08:36:48+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "@howardjohn @ramaraochavali Ideally it should not carry ipv6 address at all if the feature disabled.  Same rule should also apply to iptables interception, i haven't see if it was there",
        "pr_file_module": null
      },
      {
        "comment_id": "1095502831",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1095483396",
        "commented_code": "@@ -118,16 +119,35 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly",
        "comment_created_at": "2023-02-03T08:53:25+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "> I am wondering that dual stack is not well protected under the feature flag `EnableDualStack`. I think we should improve\r\n\r\nHi @hzxuzhonghu, yeah, it makes sense, should protect this with feature flag `EnableDualStack` and thanks for the remind!",
        "pr_file_module": null
      },
      {
        "comment_id": "1095521443",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pkg/bootstrap/config.go",
        "discussion_id": "1095483396",
        "commented_code": "@@ -118,16 +119,35 @@ func (cfg Config) toTemplateParams() (map[string]any, error) {\n \topts = append(opts, getNodeMetadataOptions(cfg.Node)...)\n \n \t// Check if nodeIP carries IPv4 or IPv6 and set up proxy accordingly",
        "comment_created_at": "2023-02-03T09:08:08+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "@hzxuzhonghu,  as you said, I added the feature flag to protect the original logic if dual stack is disable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1099478838",
    "pr_number": 43099,
    "pr_file": "pilot/pkg/networking/core/v1alpha3/cluster_builder.go",
    "created_at": "2023-02-08T00:35:03+00:00",
    "commented_code": "ec := NewMutableCluster(c)\n \tswitch discoveryType {\n \tcase cluster.Cluster_STRICT_DNS, cluster.Cluster_LOGICAL_DNS:\n-\t\tif cb.supportsIPv4 {\n+\t\tif networkutil.AllIPv4(cb.proxyIPAddresses) {\n+\t\t\t// IPv4 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V4_ONLY\n-\t\t} else {\n+\t\t} else if networkutil.AllIPv6(cb.proxyIPAddresses) {\n+\t\t\t// IPv6 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V6_ONLY\n+\t\t} else {\n+\t\t\t// Dual Stack\n+\t\t\tif features.EnableDualStack {\n+\t\t\t\t// If dual-stack, it may be [IPv4, IPv6] or [IPv6, IPv4]\n+\t\t\t\t// using Cluster_ALL to enable Happy Eyeballsfor upstream connections\n+\t\t\t\tc.DnsLookupFamily = cluster.Cluster_ALL",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1099478838",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pilot/pkg/networking/core/v1alpha3/cluster_builder.go",
        "discussion_id": "1099478838",
        "commented_code": "@@ -366,10 +367,22 @@ func (cb *ClusterBuilder) buildDefaultCluster(name string, discoveryType cluster\n \tec := NewMutableCluster(c)\n \tswitch discoveryType {\n \tcase cluster.Cluster_STRICT_DNS, cluster.Cluster_LOGICAL_DNS:\n-\t\tif cb.supportsIPv4 {\n+\t\tif networkutil.AllIPv4(cb.proxyIPAddresses) {\n+\t\t\t// IPv4 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V4_ONLY\n-\t\t} else {\n+\t\t} else if networkutil.AllIPv6(cb.proxyIPAddresses) {\n+\t\t\t// IPv6 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V6_ONLY\n+\t\t} else {\n+\t\t\t// Dual Stack\n+\t\t\tif features.EnableDualStack {\n+\t\t\t\t// If dual-stack, it may be [IPv4, IPv6] or [IPv6, IPv4]\n+\t\t\t\t// using Cluster_ALL to enable Happy Eyeballsfor upstream connections\n+\t\t\t\tc.DnsLookupFamily = cluster.Cluster_ALL",
        "comment_created_at": "2023-02-08T00:35:03+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Curious if we want ALL or AUTO. Looks like curl and Golang both default to ALL equivilent so maybe it is a good default. Any opinions @kyessenov @ramaraochavali @jacob-delgado ?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1100167087",
        "repo_full_name": "istio/istio",
        "pr_number": 43099,
        "pr_file": "pilot/pkg/networking/core/v1alpha3/cluster_builder.go",
        "discussion_id": "1099478838",
        "commented_code": "@@ -366,10 +367,22 @@ func (cb *ClusterBuilder) buildDefaultCluster(name string, discoveryType cluster\n \tec := NewMutableCluster(c)\n \tswitch discoveryType {\n \tcase cluster.Cluster_STRICT_DNS, cluster.Cluster_LOGICAL_DNS:\n-\t\tif cb.supportsIPv4 {\n+\t\tif networkutil.AllIPv4(cb.proxyIPAddresses) {\n+\t\t\t// IPv4 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V4_ONLY\n-\t\t} else {\n+\t\t} else if networkutil.AllIPv6(cb.proxyIPAddresses) {\n+\t\t\t// IPv6 only\n \t\t\tc.DnsLookupFamily = cluster.Cluster_V6_ONLY\n+\t\t} else {\n+\t\t\t// Dual Stack\n+\t\t\tif features.EnableDualStack {\n+\t\t\t\t// If dual-stack, it may be [IPv4, IPv6] or [IPv6, IPv4]\n+\t\t\t\t// using Cluster_ALL to enable Happy Eyeballsfor upstream connections\n+\t\t\t\tc.DnsLookupFamily = cluster.Cluster_ALL",
        "comment_created_at": "2023-02-08T13:49:53+00:00",
        "comment_author": "ramaraochavali",
        "comment_body": "I think ALL seems to be a good default.",
        "pr_file_module": null
      }
    ]
  }
]