[
  {
    "discussion_id": "1044063135",
    "pr_number": 42372,
    "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
    "created_at": "2022-12-09T03:39:53+00:00",
    "commented_code": "+// clang  -O2  -Wall -target bpf -c ambient_redirect_kern.c -o ambient_redirect.o\n+// POD_VETH=vethaab06c36\n+// tc qdisc del dev ${POD_VETH} clsact\n+// tc qdisc add dev ${POD_VETH} clsact\n+// tc filter add dev ${POD_VETH} ingress bpf da obj ambient_redirect.o sec outbound\n+// tc filter show dev ${POD_VETH} ingress\n+// tc filter add dev ${POD_VETH} egress bpf da obj ambient_redirect.o sec inbound\n+// tc filter show dev ${POD_VETH} egress\n+// ZTU_VETH=veth526b5785\n+// tc qdisc del dev ${ZTU_VETH} clsact\n+// tc qdisc add dev ${ZTU_VETH} clsact\n+// tc filter add dev ${ZTU_VETH}  ingress bpf da obj ambient_redirect.o sec  ztunnelhostingress\n+// tc filter show dev ${ZTU_VETH}  ingress\n+// NS=cni-4d297635-9c2d-78f0-3f3e-88b94f04cf5c\n+// ip netns exec ${NS} tc qdisc add dev eth0 clsact\n+// ip netns exec ${NS} tc filter add dev eth0 ingress bpf da obj ambient_redirect.o sec ztunnelingress\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+\n+#ifndef printk\n+#define printk(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#endif\n+\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1044063135",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
        "discussion_id": "1044063135",
        "commented_code": "@@ -0,0 +1,319 @@\n+// clang  -O2  -Wall -target bpf -c ambient_redirect_kern.c -o ambient_redirect.o\n+// POD_VETH=vethaab06c36\n+// tc qdisc del dev ${POD_VETH} clsact\n+// tc qdisc add dev ${POD_VETH} clsact\n+// tc filter add dev ${POD_VETH} ingress bpf da obj ambient_redirect.o sec outbound\n+// tc filter show dev ${POD_VETH} ingress\n+// tc filter add dev ${POD_VETH} egress bpf da obj ambient_redirect.o sec inbound\n+// tc filter show dev ${POD_VETH} egress\n+// ZTU_VETH=veth526b5785\n+// tc qdisc del dev ${ZTU_VETH} clsact\n+// tc qdisc add dev ${ZTU_VETH} clsact\n+// tc filter add dev ${ZTU_VETH}  ingress bpf da obj ambient_redirect.o sec  ztunnelhostingress\n+// tc filter show dev ${ZTU_VETH}  ingress\n+// NS=cni-4d297635-9c2d-78f0-3f3e-88b94f04cf5c\n+// ip netns exec ${NS} tc qdisc add dev eth0 clsact\n+// ip netns exec ${NS} tc filter add dev eth0 ingress bpf da obj ambient_redirect.o sec ztunnelingress\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+\n+#ifndef printk\n+#define printk(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#endif\n+\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\",
        "comment_created_at": "2022-12-09T03:39:53+00:00",
        "comment_author": "kebe7jun",
        "comment_body": "The performance of trace_printk is so low that we should consider not calling it if we are in non-debug mode.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1044064313",
    "pr_number": 42372,
    "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
    "created_at": "2022-12-09T03:43:13+00:00",
    "commented_code": "+// clang  -O2  -Wall -target bpf -c ambient_redirect_kern.c -o ambient_redirect.o\n+// POD_VETH=vethaab06c36\n+// tc qdisc del dev ${POD_VETH} clsact\n+// tc qdisc add dev ${POD_VETH} clsact\n+// tc filter add dev ${POD_VETH} ingress bpf da obj ambient_redirect.o sec outbound\n+// tc filter show dev ${POD_VETH} ingress\n+// tc filter add dev ${POD_VETH} egress bpf da obj ambient_redirect.o sec inbound\n+// tc filter show dev ${POD_VETH} egress\n+// ZTU_VETH=veth526b5785\n+// tc qdisc del dev ${ZTU_VETH} clsact\n+// tc qdisc add dev ${ZTU_VETH} clsact\n+// tc filter add dev ${ZTU_VETH}  ingress bpf da obj ambient_redirect.o sec  ztunnelhostingress\n+// tc filter show dev ${ZTU_VETH}  ingress\n+// NS=cni-4d297635-9c2d-78f0-3f3e-88b94f04cf5c\n+// ip netns exec ${NS} tc qdisc add dev eth0 clsact\n+// ip netns exec ${NS} tc filter add dev eth0 ingress bpf da obj ambient_redirect.o sec ztunnelingress\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+\n+#ifndef printk\n+#define printk(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#endif\n+\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+\n+\n+\n+struct bpf_elf_map ztunnel_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_ARRAY,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct ztunnel_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = 1,\n+};\n+\n+struct bpf_elf_map app_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_HASH,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct app_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = APP_INFO_MAP_SIZE,\n+};\n+\n+\n+static __inline struct ztunnel_info * get_ztunnel_info()\n+{\n+    uint32_t key = 0;\n+    return map_lookup_elem(&ztunnel_info, &key);\n+}\n+\n+static __inline struct app_info * get_app_info_from_ipv4(uint32_t ipv4)\n+{\n+    return map_lookup_elem(&app_info, &ipv4);\n+}\n+\n+__section(\"ztunnelingress\")\n+int ztunnel_ingress(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct eth_hdr *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    struct bpf_sock_tuple *tuple;\n+    size_t tuple_len;\n+    struct bpf_sock *sk;\n+    int skip_mark = 0;\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+\n+    if (data + sizeof(*eth) > data_end)\n+        return TC_ACT_OK;\n+\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    tuple = (struct bpf_sock_tuple *)&iph->saddr;\n+    tuple_len = sizeof(tuple->ipv4);\n+    if ((void *)tuple + sizeof(tuple->ipv4) > (void *)(long)skb->data_end) {\n+        return TC_ACT_SHOT;\n+    }\n+\n+    if (skb->cb[4] == outbound_cb) {\n+        // We mark all app egress pkt as outbound and redirect here.\n+        // We need identify if it's a actual *outbound* or just a reponse to\n+        // the proxy\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1044064313",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ebpf/ambient_redirect_kern.c",
        "discussion_id": "1044064313",
        "commented_code": "@@ -0,0 +1,319 @@\n+// clang  -O2  -Wall -target bpf -c ambient_redirect_kern.c -o ambient_redirect.o\n+// POD_VETH=vethaab06c36\n+// tc qdisc del dev ${POD_VETH} clsact\n+// tc qdisc add dev ${POD_VETH} clsact\n+// tc filter add dev ${POD_VETH} ingress bpf da obj ambient_redirect.o sec outbound\n+// tc filter show dev ${POD_VETH} ingress\n+// tc filter add dev ${POD_VETH} egress bpf da obj ambient_redirect.o sec inbound\n+// tc filter show dev ${POD_VETH} egress\n+// ZTU_VETH=veth526b5785\n+// tc qdisc del dev ${ZTU_VETH} clsact\n+// tc qdisc add dev ${ZTU_VETH} clsact\n+// tc filter add dev ${ZTU_VETH}  ingress bpf da obj ambient_redirect.o sec  ztunnelhostingress\n+// tc filter show dev ${ZTU_VETH}  ingress\n+// NS=cni-4d297635-9c2d-78f0-3f3e-88b94f04cf5c\n+// ip netns exec ${NS} tc qdisc add dev eth0 clsact\n+// ip netns exec ${NS} tc filter add dev eth0 ingress bpf da obj ambient_redirect.o sec ztunnelingress\n+\n+#include <linux/bpf.h>\n+#include <linux/pkt_cls.h>\n+#include <netinet/in.h>\n+#include <linux/ip.h>\n+#include <linux/ipv6.h>\n+#include <linux/if_packet.h>\n+#include <linux/if_ether.h>\n+#include <linux/tcp.h>\n+#include <stdint.h>\n+#include <iproute2/bpf_elf.h>\n+#include <bpf/bpf_helpers.h>\n+#include <string.h>\n+#include \"common.h\"\n+\n+\n+#ifndef __section\n+# define __section(NAME)                  \\\n+   __attribute__((section(NAME), used))\n+#endif\n+\n+#ifndef __inline\n+# define __inline                         \\\n+   inline __attribute__((always_inline))\n+#endif\n+\n+\n+#ifndef BPF_FUNC\n+# define BPF_FUNC(NAME, ...)              \\\n+   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n+#endif\n+\n+static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n+static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n+\n+#ifndef printk\n+#define printk(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+#endif\n+\n+#define dbg(fmt, ...)                                      \\\n+    ({                                                         \\\n+        char ____fmt[] = fmt;                                  \\\n+        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n+    })\n+\n+\n+\n+struct bpf_elf_map ztunnel_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_ARRAY,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct ztunnel_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = 1,\n+};\n+\n+struct bpf_elf_map app_info __section(\"maps\") = {\n+    .type           = BPF_MAP_TYPE_HASH,\n+    .size_key       = sizeof(uint32_t),\n+    .size_value     = sizeof(struct app_info),\n+    .pinning        = PIN_GLOBAL_NS,\n+    .max_elem       = APP_INFO_MAP_SIZE,\n+};\n+\n+\n+static __inline struct ztunnel_info * get_ztunnel_info()\n+{\n+    uint32_t key = 0;\n+    return map_lookup_elem(&ztunnel_info, &key);\n+}\n+\n+static __inline struct app_info * get_app_info_from_ipv4(uint32_t ipv4)\n+{\n+    return map_lookup_elem(&app_info, &ipv4);\n+}\n+\n+__section(\"ztunnelingress\")\n+int ztunnel_ingress(struct __sk_buff *skb)\n+{\n+    void *data = (void *)(long)skb->data;\n+    struct eth_hdr *eth = data;\n+    void *data_end = (void *)(long)skb->data_end;\n+    struct bpf_sock_tuple *tuple;\n+    size_t tuple_len;\n+    struct bpf_sock *sk;\n+    int skip_mark = 0;\n+    __u32 outbound_cb = OUTBOUND_CB;\n+    __u32 inbound_cb = INBOUND_CB;\n+\n+\n+    if (data + sizeof(*eth) > data_end)\n+        return TC_ACT_OK;\n+\n+    if (eth->h_proto != htons(ETH_P_IP)) {\n+        return TC_ACT_OK;\n+    }\n+    struct iphdr *iph = data + sizeof(*eth);\n+    if (data + sizeof(*eth) + sizeof(*iph) > data_end) {\n+        return TC_ACT_OK;\n+    }\n+    if (iph->protocol != IPPROTO_TCP) {\n+        return TC_ACT_OK;\n+    }\n+\n+    tuple = (struct bpf_sock_tuple *)&iph->saddr;\n+    tuple_len = sizeof(tuple->ipv4);\n+    if ((void *)tuple + sizeof(tuple->ipv4) > (void *)(long)skb->data_end) {\n+        return TC_ACT_SHOT;\n+    }\n+\n+    if (skb->cb[4] == outbound_cb) {\n+        // We mark all app egress pkt as outbound and redirect here.\n+        // We need identify if it's a actual *outbound* or just a reponse to\n+        // the proxy\n+        sk = bpf_skc_lookup_tcp(skb, tuple, tuple_len, BPF_F_CURRENT_NETNS, 0);",
        "comment_created_at": "2022-12-09T03:43:13+00:00",
        "comment_author": "kebe7jun",
        "comment_body": "Experimentally, the performance of lookup tcp is also very low, especially if each arriving packet is requested once.\r\nConsider using map to handle this part of the logic.",
        "pr_file_module": null
      }
    ]
  }
]