[
  {
    "discussion_id": "2284156493",
    "pr_number": 57245,
    "pr_file": "tests/integration/ambient/baseline_test.go",
    "created_at": "2025-08-19T06:01:40+00:00",
    "commented_code": "}, retry.Timeout(60*time.Second), retry.Delay(2*time.Second)); err != nil {\n \t\tt.Fatalf(\"failed to wait for ztunnel rollout status for: %v\", err)\n \t}\n-\tif _, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(t.AllClusters()[0], i.Settings().SystemNamespace, \"app=ztunnel\")); err != nil {\n+\tif _, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(t.AllClusters()[0], ztunnelNS, \"app=ztunnel\")); err != nil {\n \t\tt.Fatal(err)\n \t}\n }\n \n+// Locate DaemonSet namespace by name\n+func locateDaemonsetNS(t framework.TestContext, dsName string) (string, error) {\n+\tdaemonsets, err := t.Clusters().Default().Kube().AppsV1().DaemonSets(\"\").List(context.TODO(), metav1.ListOptions{})\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to fetch daemonsets list: %v\", err)",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2284156493",
        "repo_full_name": "istio/istio",
        "pr_number": 57245,
        "pr_file": "tests/integration/ambient/baseline_test.go",
        "discussion_id": "2284156493",
        "commented_code": "@@ -3569,11 +3573,27 @@ func restartZtunnel(t framework.TestContext) {\n \t}, retry.Timeout(60*time.Second), retry.Delay(2*time.Second)); err != nil {\n \t\tt.Fatalf(\"failed to wait for ztunnel rollout status for: %v\", err)\n \t}\n-\tif _, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(t.AllClusters()[0], i.Settings().SystemNamespace, \"app=ztunnel\")); err != nil {\n+\tif _, err := kubetest.CheckPodsAreReady(kubetest.NewPodFetch(t.AllClusters()[0], ztunnelNS, \"app=ztunnel\")); err != nil {\n \t\tt.Fatal(err)\n \t}\n }\n \n+// Locate DaemonSet namespace by name\n+func locateDaemonsetNS(t framework.TestContext, dsName string) (string, error) {\n+\tdaemonsets, err := t.Clusters().Default().Kube().AppsV1().DaemonSets(\"\").List(context.TODO(), metav1.ListOptions{})\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to fetch daemonsets list: %v\", err)",
        "comment_created_at": "2025-08-19T06:01:40+00:00",
        "comment_author": "sridhargaddam",
        "comment_body": "It would be better to return an error here instead of using `t.Fatalf`, and let the calling context decide how to handle it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017168729",
    "pr_number": 55696,
    "pr_file": "pilot/pkg/bootstrap/istio_ca.go",
    "created_at": "2025-03-27T17:02:25+00:00",
    "commented_code": "})\n \treturn raServer, err\n }\n+\n+// checkCABundleCompleteness checks if all required CA certificate files exist\n+func checkCABundleCompleteness(signingKeyFile, signingCertFile, rootCertFile string, chainFiles []string) (signingCABundleComplete bool, bundleExists bool) {\n+\tsigningKeyExists := fileExists(signingKeyFile)\n+\tsigningCertExists := fileExists(signingCertFile)\n+\trootCertExists := fileExists(rootCertFile)\n+\tchainFilesExist := hasValidChainFiles(chainFiles)\n+\n+\tbundleExists = signingKeyExists || signingCertExists || rootCertExists || chainFilesExist\n+\tsigningCABundleComplete = signingKeyExists && signingCertExists && rootCertExists && chainFilesExist\n+\n+\treturn signingCABundleComplete, bundleExists\n+}\n+\n+// fileExists checks if a file exists and is accessible\n+func fileExists(filename string) bool {\n+\tif filename == \"\" {\n+\t\treturn false\n+\t}\n+\t_, err := os.Stat(filename)\n+\tif err != nil && !os.IsNotExist(err) {\n+\t\tlog.Warnf(\"Unexpected error checking file %s: %v\", filename, err)\n+\t}\n+\treturn err == nil",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2017168729",
        "repo_full_name": "istio/istio",
        "pr_number": 55696,
        "pr_file": "pilot/pkg/bootstrap/istio_ca.go",
        "discussion_id": "2017168729",
        "commented_code": "@@ -568,3 +589,42 @@ func (s *Server) createIstioRA(opts *caOptions) (ra.RegistrationAuthority, error\n \t})\n \treturn raServer, err\n }\n+\n+// checkCABundleCompleteness checks if all required CA certificate files exist\n+func checkCABundleCompleteness(signingKeyFile, signingCertFile, rootCertFile string, chainFiles []string) (signingCABundleComplete bool, bundleExists bool) {\n+\tsigningKeyExists := fileExists(signingKeyFile)\n+\tsigningCertExists := fileExists(signingCertFile)\n+\trootCertExists := fileExists(rootCertFile)\n+\tchainFilesExist := hasValidChainFiles(chainFiles)\n+\n+\tbundleExists = signingKeyExists || signingCertExists || rootCertExists || chainFilesExist\n+\tsigningCABundleComplete = signingKeyExists && signingCertExists && rootCertExists && chainFilesExist\n+\n+\treturn signingCABundleComplete, bundleExists\n+}\n+\n+// fileExists checks if a file exists and is accessible\n+func fileExists(filename string) bool {\n+\tif filename == \"\" {\n+\t\treturn false\n+\t}\n+\t_, err := os.Stat(filename)\n+\tif err != nil && !os.IsNotExist(err) {\n+\t\tlog.Warnf(\"Unexpected error checking file %s: %v\", filename, err)\n+\t}\n+\treturn err == nil",
        "comment_created_at": "2025-03-27T17:02:25+00:00",
        "comment_author": "jaiveerk",
        "comment_body": "nit - for the sake of keeping the function more flexible in the future, why not return the error and then let the caller determine what to do with it? Like the caller could be responsible for any retry logic, failure, or other error processing if it knows that there's an error vs if the file doesn't actually exist.\r\n\r\nThis would entail having two return values though, both the boolean and the error value. Not super important just a thought.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2064070769",
    "pr_number": 55696,
    "pr_file": "pilot/pkg/bootstrap/istio_ca.go",
    "created_at": "2025-04-28T16:41:33+00:00",
    "commented_code": "})\n \treturn raServer, err\n }\n+\n+// checkCABundleCompleteness checks if all required CA certificate files exist\n+func checkCABundleCompleteness(\n+\tsigningKeyFile, signingCertFile, rootCertFile string,\n+\tchainFiles []string,\n+) (\n+\tsigningCABundleComplete bool,\n+\tbundleExists bool,\n+\terr error,\n+) {\n+\tsigningKeyExists, err := fileExists(signingKeyFile)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\n+\tsigningCertExists, err := fileExists(signingCertFile)\n+\tif err != nil {\n+\t\treturn false, signingKeyExists, err\n+\t}\n+\n+\trootCertExists, err := fileExists(rootCertFile)\n+\tif err != nil {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2064070769",
        "repo_full_name": "istio/istio",
        "pr_number": 55696,
        "pr_file": "pilot/pkg/bootstrap/istio_ca.go",
        "discussion_id": "2064070769",
        "commented_code": "@@ -568,3 +596,71 @@ func (s *Server) createIstioRA(opts *caOptions) (ra.RegistrationAuthority, error\n \t})\n \treturn raServer, err\n }\n+\n+// checkCABundleCompleteness checks if all required CA certificate files exist\n+func checkCABundleCompleteness(\n+\tsigningKeyFile, signingCertFile, rootCertFile string,\n+\tchainFiles []string,\n+) (\n+\tsigningCABundleComplete bool,\n+\tbundleExists bool,\n+\terr error,\n+) {\n+\tsigningKeyExists, err := fileExists(signingKeyFile)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\n+\tsigningCertExists, err := fileExists(signingCertFile)\n+\tif err != nil {\n+\t\treturn false, signingKeyExists, err\n+\t}\n+\n+\trootCertExists, err := fileExists(rootCertFile)\n+\tif err != nil {",
        "comment_created_at": "2025-04-28T16:41:33+00:00",
        "comment_author": "jaellio",
        "comment_body": "The bundle might exist here but `checkCABundleCompleteness` will still return false. chainFilesExists might be `true`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2076408996",
        "repo_full_name": "istio/istio",
        "pr_number": 55696,
        "pr_file": "pilot/pkg/bootstrap/istio_ca.go",
        "discussion_id": "2064070769",
        "commented_code": "@@ -568,3 +596,71 @@ func (s *Server) createIstioRA(opts *caOptions) (ra.RegistrationAuthority, error\n \t})\n \treturn raServer, err\n }\n+\n+// checkCABundleCompleteness checks if all required CA certificate files exist\n+func checkCABundleCompleteness(\n+\tsigningKeyFile, signingCertFile, rootCertFile string,\n+\tchainFiles []string,\n+) (\n+\tsigningCABundleComplete bool,\n+\tbundleExists bool,\n+\terr error,\n+) {\n+\tsigningKeyExists, err := fileExists(signingKeyFile)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\n+\tsigningCertExists, err := fileExists(signingCertFile)\n+\tif err != nil {\n+\t\treturn false, signingKeyExists, err\n+\t}\n+\n+\trootCertExists, err := fileExists(rootCertFile)\n+\tif err != nil {",
        "comment_created_at": "2025-05-06T22:00:30+00:00",
        "comment_author": "jaellio",
        "comment_body": "Spoke with Dama offline - add a comment describing behavior of bundle exists when not all files exist. May return false even when bundle exists, but this is acceptable as long as an error is returned.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1088064381",
    "pr_number": 42372,
    "pr_file": "cni/pkg/ebpf/server/redirectionServer.go",
    "created_at": "2023-01-26T16:19:34+00:00",
    "commented_code": "+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package server\n+\n+//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -target bpf -cflags \"-D__TARGET_ARCH_x86\"  ambient_redirect ../app/ambient_redirect.bpf.c\n+import (\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/cilium/ebpf\"\n+\t\"github.com/florianl/go-tc\"\n+\t\"github.com/florianl/go-tc/core\"\n+\t\"github.com/josharian/native\"\n+\t\"github.com/vishvananda/netns\"\n+\t\"golang.org/x/sys/unix\"\n+\n+\t\"istio.io/pkg/log\"\n+)\n+\n+const (\n+\tFilesystemTypeBPFFS = unix.BPF_FS_MAGIC\n+\tMapsRoot            = \"/sys/fs/bpf\"\n+\tMapsPinpath         = \"/sys/fs/bpf/ambient\"\n+\n+\tQdiscKind            = \"clsact\"\n+\tTcaBpfFlagActDiretct = 1 << 0 // refer to include/uapi/linux/pkt_cls.h TCA_BPF_FLAG_ACT_DIRECT\n+\tTcPrioFilter         = 1      // refer to include/uapi/linux/pkt_sched.h TC_PRIO_FILLER\n+)\n+\n+var isBigEndian = native.IsBigEndian\n+\n+type RedirectServer struct {\n+\tredirectArgsChan           chan *RedirectArgs\n+\tobj                        ambient_redirectObjects\n+\tztunnelHostingressFd       int\n+\tztunnelHostingressProgName string\n+\tztunnelIngressFd           int\n+\tztunnelIngressProgName     string\n+\tinboundFd                  int\n+\tinboundProgName            string\n+\toutboundFd                 int\n+\toutboundProgName           string\n+}\n+\n+func (r *RedirectServer) initBpfObjects() {\n+\tvar options ebpf.CollectionOptions\n+\tif _, err := os.Stat(MapsPinpath); err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\tif err := os.Mkdir(MapsPinpath, os.ModePerm); err != nil {\n+\t\t\t\tlog.Fatalf(\"unable to create ambient bpf mount directory: %v\", err)",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1088064381",
        "repo_full_name": "istio/istio",
        "pr_number": 42372,
        "pr_file": "cni/pkg/ebpf/server/redirectionServer.go",
        "discussion_id": "1088064381",
        "commented_code": "@@ -0,0 +1,542 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package server\n+\n+//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang -target bpf -cflags \"-D__TARGET_ARCH_x86\"  ambient_redirect ../app/ambient_redirect.bpf.c\n+import (\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/cilium/ebpf\"\n+\t\"github.com/florianl/go-tc\"\n+\t\"github.com/florianl/go-tc/core\"\n+\t\"github.com/josharian/native\"\n+\t\"github.com/vishvananda/netns\"\n+\t\"golang.org/x/sys/unix\"\n+\n+\t\"istio.io/pkg/log\"\n+)\n+\n+const (\n+\tFilesystemTypeBPFFS = unix.BPF_FS_MAGIC\n+\tMapsRoot            = \"/sys/fs/bpf\"\n+\tMapsPinpath         = \"/sys/fs/bpf/ambient\"\n+\n+\tQdiscKind            = \"clsact\"\n+\tTcaBpfFlagActDiretct = 1 << 0 // refer to include/uapi/linux/pkt_cls.h TCA_BPF_FLAG_ACT_DIRECT\n+\tTcPrioFilter         = 1      // refer to include/uapi/linux/pkt_sched.h TC_PRIO_FILLER\n+)\n+\n+var isBigEndian = native.IsBigEndian\n+\n+type RedirectServer struct {\n+\tredirectArgsChan           chan *RedirectArgs\n+\tobj                        ambient_redirectObjects\n+\tztunnelHostingressFd       int\n+\tztunnelHostingressProgName string\n+\tztunnelIngressFd           int\n+\tztunnelIngressProgName     string\n+\tinboundFd                  int\n+\tinboundProgName            string\n+\toutboundFd                 int\n+\toutboundProgName           string\n+}\n+\n+func (r *RedirectServer) initBpfObjects() {\n+\tvar options ebpf.CollectionOptions\n+\tif _, err := os.Stat(MapsPinpath); err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\tif err := os.Mkdir(MapsPinpath, os.ModePerm); err != nil {\n+\t\t\t\tlog.Fatalf(\"unable to create ambient bpf mount directory: %v\", err)",
        "comment_created_at": "2023-01-26T16:19:34+00:00",
        "comment_author": "howardjohn",
        "comment_body": "return an error; generally we never want to exit in code, only by returning error up to the top level",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1084368557",
    "pr_number": 42928,
    "pr_file": "pkg/wasm/convert.go",
    "created_at": "2023-01-23T17:52:23+00:00",
    "commented_code": "func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1084368557",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T17:52:23+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I feel fairly uncomfortable with this.. a NACK is a *huge* risk, has the possibility to cause cluster wide outage by blocking all pod startup. Its worth a `return nil, true` to explicitly signal this rather than implicitly NACKing",
        "pr_file_module": null
      },
      {
        "comment_id": "1084368811",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T17:52:38+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Return like this is bad practice in Go in general, IMO, but especially in this case",
        "pr_file_module": null
      },
      {
        "comment_id": "1084372870",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T17:56:53+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Actually i guess in this case since we are proxying its a bit different but still a good policy. \r\n\r\nAlso its not clear - can `convert` return `nil, false`? What happens if so?\r\n\r\nAlso - On NACK, shouldn't we apply the valid configs and just NACK the invalid ones?",
        "pr_file_module": null
      },
      {
        "comment_id": "1084375529",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T17:59:26+00:00",
        "comment_author": "kyessenov",
        "comment_body": "The problem is that a valid xDS causes Envoy crash. The only mechanism to prevent it is NACK in the proxy. A crash is worse than inability to update some (optional) config.",
        "pr_file_module": null
      },
      {
        "comment_id": "1084376520",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T18:00:30+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I am not saying we shouldn't NACK, just that the default being NACK and then unsettting it is confusing/risky. Just a syntax concern; we should explicitly annotate on each return nack or not",
        "pr_file_module": null
      },
      {
        "comment_id": "1084389572",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T18:12:57+00:00",
        "comment_author": "kyessenov",
        "comment_body": "Right, that's why I asked for the coverage report. We should have unit tests for good/bad cases and make sure they are reasonable.",
        "pr_file_module": null
      },
      {
        "comment_id": "1084475371",
        "repo_full_name": "istio/istio",
        "pr_number": 42928,
        "pr_file": "pkg/wasm/convert.go",
        "discussion_id": "1084368557",
        "commented_code": "@@ -74,7 +74,7 @@ func MaybeConvertWasmExtensionConfig(resources []*anypb.Any, cache Cache) bool {\n func convert(resource *anypb.Any, cache Cache) (newExtensionConfig *anypb.Any, sendNack bool) {\n \tec := &core.TypedExtensionConfig{}\n \tnewExtensionConfig = resource\n-\tsendNack = false\n+\tsendNack = true",
        "comment_created_at": "2023-01-23T19:44:47+00:00",
        "comment_author": "ingwonsong",
        "comment_body": "@kyessenov Here is the coverage report. \r\nhttps://storage.googleapis.com/igsong-test-wasms/coverage/istio-wasm-coverage.html#file1",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "839786495",
    "pr_number": 38187,
    "pr_file": "pilot/pkg/model/jwks_resolver.go",
    "created_at": "2022-03-31T16:07:54+00:00",
    "commented_code": "if jwksURI == \"\" {\n \t\t// Fetch the jwks URI if it is not hardcoded on config.\n \t\tjwksURI, err = r.resolveJwksURIUsingOpenID(issuer)\n+\t\tkey.jwksURI = jwksURI",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "839786495",
        "repo_full_name": "istio/istio",
        "pr_number": 38187,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "839786495",
        "commented_code": "@@ -242,16 +245,12 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \tif jwksURI == \"\" {\n \t\t// Fetch the jwks URI if it is not hardcoded on config.\n \t\tjwksURI, err = r.resolveJwksURIUsingOpenID(issuer)\n+\t\tkey.jwksURI = jwksURI",
        "comment_created_at": "2022-03-31T16:07:54+00:00",
        "comment_author": "howardjohn",
        "comment_body": "using the return value (jwksURI) when an `err` was returned is not a great practice IMO. If you are intentionally setting it to `\"\"` on err, then I would make it explicit.",
        "pr_file_module": null
      },
      {
        "comment_id": "839827800",
        "repo_full_name": "istio/istio",
        "pr_number": 38187,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "839786495",
        "commented_code": "@@ -242,16 +245,12 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \tif jwksURI == \"\" {\n \t\t// Fetch the jwks URI if it is not hardcoded on config.\n \t\tjwksURI, err = r.resolveJwksURIUsingOpenID(issuer)\n+\t\tkey.jwksURI = jwksURI",
        "comment_created_at": "2022-03-31T16:52:03+00:00",
        "comment_author": "aryan16",
        "comment_body": "Yeah, I will move it after `err` check. But this is needed because if we get any value from `r.resolveJwksURIUsingOpenID(issuer)`, we would need to update the key as we are adding it in the cache.",
        "pr_file_module": null
      }
    ]
  }
]