[
  {
    "discussion_id": "2282250366",
    "pr_number": 57191,
    "pr_file": "istioctl/pkg/multicluster/remote_secret.go",
    "created_at": "2025-08-18T12:24:25+00:00",
    "commented_code": "// SecretName selects a specific secret from the remote service account, if there are multiple\n \tSecretName string\n+\n+\t// Rotation forces creation of a new service account token secret even if one already exists.\n+\t// This is useful for token rotation scenarios.",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2282250366",
        "repo_full_name": "istio/istio",
        "pr_number": 57191,
        "pr_file": "istioctl/pkg/multicluster/remote_secret.go",
        "discussion_id": "2282250366",
        "commented_code": "@@ -584,6 +596,10 @@ type RemoteSecretOptions struct {\n \n \t// SecretName selects a specific secret from the remote service account, if there are multiple\n \tSecretName string\n+\n+\t// Rotation forces creation of a new service account token secret even if one already exists.\n+\t// This is useful for token rotation scenarios.",
        "comment_created_at": "2025-08-18T12:24:25+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Based on my reading of the PR, this isn't true rotation. The user is still having to run istioctl again. This should probably be named \"allowOverwrite\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162620063",
    "pr_number": 56548,
    "pr_file": "pkg/test/framework/components/echo/check/checkers.go",
    "created_at": "2025-06-23T22:24:16+00:00",
    "commented_code": "})\n }\n \n+// ResponseHosts checks that the response hostnames match the expected values.",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2162620063",
        "repo_full_name": "istio/istio",
        "pr_number": 56548,
        "pr_file": "pkg/test/framework/components/echo/check/checkers.go",
        "discussion_id": "2162620063",
        "commented_code": "@@ -249,6 +250,16 @@ func Hostname(expected string) echo.Checker {\n \t})\n }\n \n+// ResponseHosts checks that the response hostnames match the expected values.",
        "comment_created_at": "2025-06-23T22:24:16+00:00",
        "comment_author": "jaellio",
        "comment_body": "nit: \r\n```suggestion\r\n// ResponseHosts checks that the response hostname matches an expected value.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2169484658",
        "repo_full_name": "istio/istio",
        "pr_number": 56548,
        "pr_file": "pkg/test/framework/components/echo/check/checkers.go",
        "discussion_id": "2162620063",
        "commented_code": "@@ -249,6 +250,16 @@ func Hostname(expected string) echo.Checker {\n \t})\n }\n \n+// ResponseHosts checks that the response hostnames match the expected values.",
        "comment_created_at": "2025-06-26T16:49:42+00:00",
        "comment_author": "Winbobob",
        "comment_body": "This func is specific for multiple hostnames, the `Hostname` func above is for single hostname check.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181050008",
    "pr_number": 56497,
    "pr_file": "pilot/pkg/model/service.go",
    "created_at": "2025-07-02T22:01:17+00:00",
    "commented_code": "Network   string\n \tAddresses []string\n+\n+\tIsGateway bool // true if this is a network gateway proxy, false if it is a regular waypoint proxy",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2181050008",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/model/service.go",
        "discussion_id": "2181050008",
        "commented_code": "@@ -962,6 +962,8 @@ type WaypointKey struct {\n \n \tNetwork   string\n \tAddresses []string\n+\n+\tIsGateway bool // true if this is a network gateway proxy, false if it is a regular waypoint proxy",
        "comment_created_at": "2025-07-02T22:01:17+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Let's be specific and say \"IsNetworkGateway\" since egress gateways are just regular waypoints in ambient",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181055937",
    "pr_number": 56497,
    "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
    "created_at": "2025-07-02T22:06:33+00:00",
    "commented_code": "// All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2181055937",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2181055937",
        "commented_code": "@@ -649,13 +658,42 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {",
        "comment_created_at": "2025-07-02T22:06:33+00:00",
        "comment_author": "keithmattix",
        "comment_body": "Just an observation that the contract for All() is changing here. I think this is probably fine since nothing calling the ambient index should ever see raw remote workloads that I can think of, but maybe we're better off renaming this to AllVisible or something?\n\n/cc @howardjohn in case you have thoughts",
        "pr_file_module": null
      },
      {
        "comment_id": "2181134593",
        "repo_full_name": "istio/istio",
        "pr_number": 56497,
        "pr_file": "pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go",
        "discussion_id": "2181055937",
        "commented_code": "@@ -649,13 +658,42 @@ func (a *index) inRevision(obj any) bool {\n \n // All return all known workloads. Result is un-ordered\n func (a *index) All() []model.AddressInfo {",
        "comment_created_at": "2025-07-02T23:17:03+00:00",
        "comment_author": "jaellio",
        "comment_body": "Just wanted to call out the behavior of `All()` isn't changing when AmbientMultiNetwork is not enabled",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1866568012",
    "pr_number": 53781,
    "pr_file": "pilot/pkg/model/extensions.go",
    "created_at": "2024-12-02T20:30:19+00:00",
    "commented_code": "Class istionetworking.ListenerClass\n \n \t// Service that WasmPlugins can attach to via targetRefs (optional)\n-\tService *Service\n+\tServices []*Service\n+}\n+\n+func (listenerInfo WasmPluginListenerInfo) AddService(service *Service) WasmPluginListenerInfo {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1866568012",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/model/extensions.go",
        "discussion_id": "1866568012",
        "commented_code": "@@ -173,7 +173,15 @@ type WasmPluginListenerInfo struct {\n \tClass istionetworking.ListenerClass\n \n \t// Service that WasmPlugins can attach to via targetRefs (optional)\n-\tService *Service\n+\tServices []*Service\n+}\n+\n+func (listenerInfo WasmPluginListenerInfo) AddService(service *Service) WasmPluginListenerInfo {",
        "comment_created_at": "2024-12-02T20:30:19+00:00",
        "comment_author": "howardjohn",
        "comment_body": "nit: rename `AddService` to something like `WithService`. `Add` makes it sound like it mutates the existing object which it doesn't necessarily?\r\n\r\nI guess sometimes it does which maybe makes it even more confusing",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1369322588",
    "pr_number": 47273,
    "pr_file": "pilot/pkg/model/service.go",
    "created_at": "2023-10-23T22:24:39+00:00",
    "commented_code": "return istioEndpointCmpOpts\n }\n \n+// SortIstioEndpointByAddresses returns the IstioEndpoint address slices sorted by its addresses.\n+func (ep *IstioEndpoint) SortIstioEndpointByAddresses() []string {\n+\tif ep == nil {\n+\t\treturn nil\n+\t}\n+\n+\taddrSlice := ep.Addresses\n+\tsort.Sort(sort.Reverse(sort.StringSlice(addrSlice)))\n+\treturn addrSlice\n+}\n+\n+// GetIstioEndpointKey returns the key of IstioEndpoint based on its addresses\n+func (ep *IstioEndpoint) GetIstioEndpointKey() string {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1369322588",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/model/service.go",
        "discussion_id": "1369322588",
        "commented_code": "@@ -591,6 +602,29 @@ func (ep *IstioEndpoint) CmpOpts() []cmp.Option {\n \treturn istioEndpointCmpOpts\n }\n \n+// SortIstioEndpointByAddresses returns the IstioEndpoint address slices sorted by its addresses.\n+func (ep *IstioEndpoint) SortIstioEndpointByAddresses() []string {\n+\tif ep == nil {\n+\t\treturn nil\n+\t}\n+\n+\taddrSlice := ep.Addresses\n+\tsort.Sort(sort.Reverse(sort.StringSlice(addrSlice)))\n+\treturn addrSlice\n+}\n+\n+// GetIstioEndpointKey returns the key of IstioEndpoint based on its addresses\n+func (ep *IstioEndpoint) GetIstioEndpointKey() string {",
        "comment_created_at": "2023-10-23T22:24:39+00:00",
        "comment_author": "howardjohn",
        "comment_body": "```suggestion\r\nfunc (ep *IstioEndpoint) Key() string {\r\n```\r\n\r\nGet and IstioEndpoint are redundant, we already know we are getting something from an IstioEndpoint",
        "pr_file_module": null
      },
      {
        "comment_id": "1372531497",
        "repo_full_name": "istio/istio",
        "pr_number": 47273,
        "pr_file": "pilot/pkg/model/service.go",
        "discussion_id": "1369322588",
        "commented_code": "@@ -591,6 +602,29 @@ func (ep *IstioEndpoint) CmpOpts() []cmp.Option {\n \treturn istioEndpointCmpOpts\n }\n \n+// SortIstioEndpointByAddresses returns the IstioEndpoint address slices sorted by its addresses.\n+func (ep *IstioEndpoint) SortIstioEndpointByAddresses() []string {\n+\tif ep == nil {\n+\t\treturn nil\n+\t}\n+\n+\taddrSlice := ep.Addresses\n+\tsort.Sort(sort.Reverse(sort.StringSlice(addrSlice)))\n+\treturn addrSlice\n+}\n+\n+// GetIstioEndpointKey returns the key of IstioEndpoint based on its addresses\n+func (ep *IstioEndpoint) GetIstioEndpointKey() string {",
        "comment_created_at": "2023-10-26T03:19:26+00:00",
        "comment_author": "zhlsunshine",
        "comment_body": "sure, done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1090829990",
    "pr_number": 43032,
    "pr_file": "tests/integration/telemetry/common/stats.go",
    "created_at": "2023-01-30T16:05:52+00:00",
    "commented_code": "return err\n \t\t\t\t\t\t}\n \n+\t\t\t\t\t\tif err := ValidateBucket(c, prom, \"a\", expectedBuckets); err != nil {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1090829990",
        "repo_full_name": "istio/istio",
        "pr_number": 43032,
        "pr_file": "tests/integration/telemetry/common/stats.go",
        "discussion_id": "1090829990",
        "commented_code": "@@ -138,6 +144,10 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {\n \t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t}\n \n+\t\t\t\t\t\tif err := ValidateBucket(c, prom, \"a\", expectedBuckets); err != nil {",
        "comment_created_at": "2023-01-30T16:05:52+00:00",
        "comment_author": "howardjohn",
        "comment_body": "nit: `\"a\"` can be clt.Config().Service()? Otherwise its hard to follow what `\"a\"` means",
        "pr_file_module": null
      },
      {
        "comment_id": "1091415679",
        "repo_full_name": "istio/istio",
        "pr_number": 43032,
        "pr_file": "tests/integration/telemetry/common/stats.go",
        "discussion_id": "1090829990",
        "commented_code": "@@ -138,6 +144,10 @@ func TestStatsFilter(t *testing.T, feature features.Feature) {\n \t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t}\n \n+\t\t\t\t\t\tif err := ValidateBucket(c, prom, \"a\", expectedBuckets); err != nil {",
        "comment_created_at": "2023-01-31T03:37:46+00:00",
        "comment_author": "zirain",
        "comment_body": "updated, PTAL.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "955018276",
    "pr_number": 40643,
    "pr_file": "pkg/backoff/retry.go",
    "created_at": "2022-08-25T14:09:25+00:00",
    "commented_code": "+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package backoff\n+\n+import \"time\"\n+\n+// Retry the operation until it does not return error or BackOff stops.\n+// o is guaranteed to be run at least once.\n+// Retry sleeps the goroutine for the duration returned by BackOff after a\n+// failed operation returns.\n+func Retry(operation func() error, b BackOff) error {\n+\tvar err error\n+\tvar next time.Duration\n+\n+\tfor {\n+\t\tif err = operation(); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tnext = b.NextBackOff()\n+\t\tif next == MaxDuration {\n+\t\t\treturn err",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "955018276",
        "repo_full_name": "istio/istio",
        "pr_number": 40643,
        "pr_file": "pkg/backoff/retry.go",
        "discussion_id": "955018276",
        "commented_code": "@@ -0,0 +1,39 @@\n+// Copyright Istio Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package backoff\n+\n+import \"time\"\n+\n+// Retry the operation until it does not return error or BackOff stops.\n+// o is guaranteed to be run at least once.\n+// Retry sleeps the goroutine for the duration returned by BackOff after a\n+// failed operation returns.\n+func Retry(operation func() error, b BackOff) error {\n+\tvar err error\n+\tvar next time.Duration\n+\n+\tfor {\n+\t\tif err = operation(); err == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tnext = b.NextBackOff()\n+\t\tif next == MaxDuration {\n+\t\t\treturn err",
        "comment_created_at": "2022-08-25T14:09:25+00:00",
        "comment_author": "howardjohn",
        "comment_body": "This behavior was unexpected to me, we should either document it or change? Or maybe make the function named something closer to RetryUntilMaxDurationHit to make it clear",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "869718838",
    "pr_number": 38838,
    "pr_file": "pkg/test/framework/components/registryredirector/registryredirector.go",
    "created_at": "2022-05-10T22:12:58+00:00",
    "commented_code": "//  See the License for the specific language governing permissions and\n //  limitations under the License.\n \n-// Package containerregistry provides basic utilities around configuring the fake\n-// container registry server component for integration testing.\n-package containerregistry\n+// Package registryredirector provides basic utilities around configuring the fake\n+// image registry server component for integration testing.\n+package registryredirector",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "869718838",
        "repo_full_name": "istio/istio",
        "pr_number": 38838,
        "pr_file": "pkg/test/framework/components/registryredirector/registryredirector.go",
        "discussion_id": "869718838",
        "commented_code": "@@ -12,43 +12,48 @@\n //  See the License for the specific language governing permissions and\n //  limitations under the License.\n \n-// Package containerregistry provides basic utilities around configuring the fake\n-// container registry server component for integration testing.\n-package containerregistry\n+// Package registryredirector provides basic utilities around configuring the fake\n+// image registry server component for integration testing.\n+package registryredirector",
        "comment_created_at": "2022-05-10T22:12:58+00:00",
        "comment_author": "douglas-reid",
        "comment_body": "is this functioning then as a proxy?  should we call this `registryproxy` instead ?",
        "pr_file_module": null
      },
      {
        "comment_id": "869749514",
        "repo_full_name": "istio/istio",
        "pr_number": 38838,
        "pr_file": "pkg/test/framework/components/registryredirector/registryredirector.go",
        "discussion_id": "869718838",
        "commented_code": "@@ -12,43 +12,48 @@\n //  See the License for the specific language governing permissions and\n //  limitations under the License.\n \n-// Package containerregistry provides basic utilities around configuring the fake\n-// container registry server component for integration testing.\n-package containerregistry\n+// Package registryredirector provides basic utilities around configuring the fake\n+// image registry server component for integration testing.\n+package registryredirector",
        "comment_created_at": "2022-05-10T23:21:28+00:00",
        "comment_author": "ingwonsong",
        "comment_body": "That is the reason why I decided to rename it.\r\n\r\nThis component does not do proxying, but just redirecting to the real registry.\r\n\r\nThe request for getting the docker manifest will be redirected.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "839789257",
    "pr_number": 38187,
    "pr_file": "pilot/pkg/model/jwks_resolver.go",
    "created_at": "2022-03-31T16:10:45+00:00",
    "commented_code": "// BuildLocalJwks builds local Jwks by fetching the Jwt Public Key from the URL passed if it is empty.\n func (r *JwksResolver) BuildLocalJwks(jwksURI, jwtIssuer, jwtPubKey string) *envoy_jwt.JwtProvider_LocalJwks {\n \tif jwtPubKey == \"\" {\n-\t\tvar err error\n+\t\t// var err error\n \n \t\t// jwtKeyResolver should never be nil since the function is only called in Discovery Server request processing\n \t\t// workflow, where the JWT key resolver should have already been initialized on server creation.\n-\t\tjwtPubKey, err = r.GetPublicKey(jwtIssuer, jwksURI)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"Failed to fetch jwt public key from issuer %q, jwks uri %q: %s\", jwtIssuer, jwksURI, err)\n-\t\t\t// This is a temporary workaround to reject a request with JWT token by using a fake jwks when istiod failed to fetch it.\n-\t\t\t// TODO(xulingqing): Find a better way to reject the request without using the fake jwks.\n+\t\t_, _ = r.GetPublicKey(jwtIssuer, jwksURI)",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "839789257",
        "repo_full_name": "istio/istio",
        "pr_number": 38187,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "839789257",
        "commented_code": "@@ -266,17 +265,35 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n // BuildLocalJwks builds local Jwks by fetching the Jwt Public Key from the URL passed if it is empty.\n func (r *JwksResolver) BuildLocalJwks(jwksURI, jwtIssuer, jwtPubKey string) *envoy_jwt.JwtProvider_LocalJwks {\n \tif jwtPubKey == \"\" {\n-\t\tvar err error\n+\t\t// var err error\n \n \t\t// jwtKeyResolver should never be nil since the function is only called in Discovery Server request processing\n \t\t// workflow, where the JWT key resolver should have already been initialized on server creation.\n-\t\tjwtPubKey, err = r.GetPublicKey(jwtIssuer, jwksURI)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"Failed to fetch jwt public key from issuer %q, jwks uri %q: %s\", jwtIssuer, jwksURI, err)\n-\t\t\t// This is a temporary workaround to reject a request with JWT token by using a fake jwks when istiod failed to fetch it.\n-\t\t\t// TODO(xulingqing): Find a better way to reject the request without using the fake jwks.\n+\t\t_, _ = r.GetPublicKey(jwtIssuer, jwksURI)",
        "comment_created_at": "2022-03-31T16:10:45+00:00",
        "comment_author": "howardjohn",
        "comment_body": "Ignoring both return values on a method called \"Get\" seems very confusing. if its purpose is something else, maybe it should be renamed like \"update cache\" or something more appropriate?",
        "pr_file_module": null
      },
      {
        "comment_id": "839828462",
        "repo_full_name": "istio/istio",
        "pr_number": 38187,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "839789257",
        "commented_code": "@@ -266,17 +265,35 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n // BuildLocalJwks builds local Jwks by fetching the Jwt Public Key from the URL passed if it is empty.\n func (r *JwksResolver) BuildLocalJwks(jwksURI, jwtIssuer, jwtPubKey string) *envoy_jwt.JwtProvider_LocalJwks {\n \tif jwtPubKey == \"\" {\n-\t\tvar err error\n+\t\t// var err error\n \n \t\t// jwtKeyResolver should never be nil since the function is only called in Discovery Server request processing\n \t\t// workflow, where the JWT key resolver should have already been initialized on server creation.\n-\t\tjwtPubKey, err = r.GetPublicKey(jwtIssuer, jwksURI)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"Failed to fetch jwt public key from issuer %q, jwks uri %q: %s\", jwtIssuer, jwksURI, err)\n-\t\t\t// This is a temporary workaround to reject a request with JWT token by using a fake jwks when istiod failed to fetch it.\n-\t\t\t// TODO(xulingqing): Find a better way to reject the request without using the fake jwks.\n+\t\t_, _ = r.GetPublicKey(jwtIssuer, jwksURI)",
        "comment_created_at": "2022-03-31T16:52:49+00:00",
        "comment_author": "aryan16",
        "comment_body": "Planning the change this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "845625113",
    "pr_number": 38187,
    "pr_file": "pilot/pkg/model/jwks_resolver.go",
    "created_at": "2022-04-07T23:16:10+00:00",
    "commented_code": "}\n \t\treturn e.pubKey, nil\n \t}\n-\n-\tvar err error\n-\tvar pubKey string\n-\tif jwksURI == \"\" {\n-\t\t// Fetch the jwks URI if it is not hardcoded on config.\n-\t\tjwksURI, err = r.resolveJwksURIUsingOpenID(issuer)\n-\t}\n-\tif err != nil {\n-\t\tlog.Errorf(\"Failed to jwks URI from %q: %v\", issuer, err)\n-\t} else {\n-\t\tvar resp []byte\n-\t\tresp, err = r.getRemoteContentWithRetry(jwksURI, networkFetchRetryCountOnMainFlow)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"Failed to fetch public key from %q: %v\", jwksURI, err)\n-\t\t}\n-\t\tpubKey = string(resp)\n-\t}\n-\n \tr.keyEntries.Store(key, jwtPubKeyEntry{\n-\t\tpubKey:            pubKey,\n+\t\tpubKey:            \"\",",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "845625113",
        "repo_full_name": "istio/istio",
        "pr_number": 38187,
        "pr_file": "pilot/pkg/model/jwks_resolver.go",
        "discussion_id": "845625113",
        "commented_code": "@@ -236,48 +239,33 @@ func (r *JwksResolver) GetPublicKey(issuer string, jwksURI string) (string, erro\n \t\t}\n \t\treturn e.pubKey, nil\n \t}\n-\n-\tvar err error\n-\tvar pubKey string\n-\tif jwksURI == \"\" {\n-\t\t// Fetch the jwks URI if it is not hardcoded on config.\n-\t\tjwksURI, err = r.resolveJwksURIUsingOpenID(issuer)\n-\t}\n-\tif err != nil {\n-\t\tlog.Errorf(\"Failed to jwks URI from %q: %v\", issuer, err)\n-\t} else {\n-\t\tvar resp []byte\n-\t\tresp, err = r.getRemoteContentWithRetry(jwksURI, networkFetchRetryCountOnMainFlow)\n-\t\tif err != nil {\n-\t\t\tlog.Errorf(\"Failed to fetch public key from %q: %v\", jwksURI, err)\n-\t\t}\n-\t\tpubKey = string(resp)\n-\t}\n-\n \tr.keyEntries.Store(key, jwtPubKeyEntry{\n-\t\tpubKey:            pubKey,\n+\t\tpubKey:            \"\",",
        "comment_created_at": "2022-04-07T23:16:10+00:00",
        "comment_author": "yangminzhu",
        "comment_body": "Please also update the comment of `GetPublicKey()`, the function name could also be updated to better reflect the new behavior.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "846602250",
    "pr_number": 38287,
    "pr_file": "tools/bug-report/pkg/cluster/cluster.go",
    "created_at": "2022-04-09T08:45:12+00:00",
    "commented_code": "}\n \t\t}\n \t\tif len(eld.Labels) > 0 {\n-\t\t\tfor kLabel, vLablel := range eld.Labels {\n-\t\t\t\tif evLablel, exists := pod.Labels[kLabel]; exists {\n-\t\t\t\t\tif isExactMatchedOrPatternMatched(vLablel, evLablel) {\n+\t\t\tfor key, val := range eld.Labels {\n+\t\t\t\tif evLablel, exists := pod.Labels[key]; exists {\n+\t\t\t\t\tif isExactMatchedOrPatternMatched(val, evLablel) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif len(eld.Annotations) > 0 {\n-\t\t\tfor kAnnotation, vAnnotation := range eld.Annotations {",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "846602250",
        "repo_full_name": "istio/istio",
        "pr_number": 38287,
        "pr_file": "tools/bug-report/pkg/cluster/cluster.go",
        "discussion_id": "846602250",
        "commented_code": "@@ -69,18 +69,18 @@ func shouldSkip(deployment string, config *config2.BugReportConfig, pod *corev1.\n \t\t\t}\n \t\t}\n \t\tif len(eld.Labels) > 0 {\n-\t\t\tfor kLabel, vLablel := range eld.Labels {\n-\t\t\t\tif evLablel, exists := pod.Labels[kLabel]; exists {\n-\t\t\t\t\tif isExactMatchedOrPatternMatched(vLablel, evLablel) {\n+\t\t\tfor key, val := range eld.Labels {\n+\t\t\t\tif evLablel, exists := pod.Labels[key]; exists {\n+\t\t\t\t\tif isExactMatchedOrPatternMatched(val, evLablel) {\n \t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif len(eld.Annotations) > 0 {\n-\t\t\tfor kAnnotation, vAnnotation := range eld.Annotations {",
        "comment_created_at": "2022-04-09T08:45:12+00:00",
        "comment_author": "zirain",
        "comment_body": "var-naming: don't use leading k in Go names; range var kAnnotation should be annotation",
        "pr_file_module": null
      }
    ]
  }
]