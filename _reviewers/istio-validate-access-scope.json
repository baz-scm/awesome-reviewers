[
  {
    "discussion_id": "2101148981",
    "pr_number": 56371,
    "pr_file": "pilot/pkg/networking/core/cluster_tls.go",
    "created_at": "2025-05-21T20:55:14+00:00",
    "commented_code": "}\n \n // buildIstioMutualTLS returns a `TLSSettings` for ISTIO_MUTUAL mode.\n-func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string) *networking.ClientTLSSettings {\n+func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string, extraTrustDomains []string) *networking.ClientTLSSettings {\n+\tif extraTrustDomains != nil {\n+\t\tsan = sets.SortedList(spiffe.ExpandWithTrustDomains(sets.New(san...), extraTrustDomains))",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "2101148981",
        "repo_full_name": "istio/istio",
        "pr_number": 56371,
        "pr_file": "pilot/pkg/networking/core/cluster_tls.go",
        "discussion_id": "2101148981",
        "commented_code": "@@ -455,7 +460,10 @@ func (cb *ClusterBuilder) buildMutualTLS(serviceAccounts []string, sni string) *\n }\n \n // buildIstioMutualTLS returns a `TLSSettings` for ISTIO_MUTUAL mode.\n-func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string) *networking.ClientTLSSettings {\n+func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string, extraTrustDomains []string) *networking.ClientTLSSettings {\n+\tif extraTrustDomains != nil {\n+\t\tsan = sets.SortedList(spiffe.ExpandWithTrustDomains(sets.New(san...), extraTrustDomains))",
        "comment_created_at": "2025-05-21T20:55:14+00:00",
        "comment_author": "Stevenjin8",
        "comment_body": "Not super familiar with this part of the code and even less with MC istio, so more of a question than anything. Could this create sans for service accounts that do not exist? Or maybe this could generate a san that shouldn't be trusted?",
        "pr_file_module": null
      },
      {
        "comment_id": "2102385588",
        "repo_full_name": "istio/istio",
        "pr_number": 56371,
        "pr_file": "pilot/pkg/networking/core/cluster_tls.go",
        "discussion_id": "2101148981",
        "commented_code": "@@ -455,7 +460,10 @@ func (cb *ClusterBuilder) buildMutualTLS(serviceAccounts []string, sni string) *\n }\n \n // buildIstioMutualTLS returns a `TLSSettings` for ISTIO_MUTUAL mode.\n-func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string) *networking.ClientTLSSettings {\n+func (cb *ClusterBuilder) buildIstioMutualTLS(san []string, sni string, extraTrustDomains []string) *networking.ClientTLSSettings {\n+\tif extraTrustDomains != nil {\n+\t\tsan = sets.SortedList(spiffe.ExpandWithTrustDomains(sets.New(san...), extraTrustDomains))",
        "comment_created_at": "2025-05-22T12:00:20+00:00",
        "comment_author": "jewertow",
        "comment_body": "> Could this create sans for service accounts that do not exist?\r\n\r\nNo, definitely not.\r\n\r\nI will try to explain it in more detail. For the default mTLS, istiod configures pod's spiffe ID in the SAN matcher: `spiffe://<trust-domain>/ns/<namespace>/sa/<service-account>`, where `<namespace>` and `<service-accounts>` come from the watched workloads, and `<trust-domain>` comes from mesh configuration and it's not deduced from workloads. And this change only generates additional spiffe IDs for the trust domains defined in `meshConfig.caCertificates`. The additional spiffe ID may not exist, but its service account always exists.\r\n\r\n> Or maybe this could generate a san that shouldn't be trusted?\r\n\r\nI don't think so.\r\n\r\nFirst of all, the purpose of `meshConfig.caCertificates` is to enable trust between workloads signed by different root certs. Inbound listeners honor client SANs with prefix for the local trust domain and extra trust domains from `meshConfig.caCertificates`, so I don't see any reason why it shouldn't work on the client side.\r\n\r\nIn my opinion, extra trust domains should be trusted by default on the client side, same as it is on the server side - this is inconsistent for now. If someone will want to narrow the set of trusted SPIFFE IDs it could be done with DestinationRule and custom SANs.\r\n\r\nBut it should be enabled by default, because it's very inconvenient if you have multi-primary with Spire and trust domain federation, and you need to create DestinationRule with duplicated SANs just to enable cross-cluster traffic.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829649930",
    "pr_number": 53781,
    "pr_file": "pilot/pkg/xds/ecds.go",
    "created_at": "2024-11-05T16:22:13+00:00",
    "commented_code": "// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
    "repo_full_name": "istio/istio",
    "discussion_comments": [
      {
        "comment_id": "1829649930",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-05T16:22:13+00:00",
        "comment_author": "howardjohn",
        "comment_body": "I am not sure this is secure?\r\n\r\nOne is saying: \"the proxy can access and pull secrets referenced by WasmPlugins that apply to it\"\r\n\r\nThe new code is saying: \"the proxy can access any pull secrets referenced by _any_ WasmPlugin they request, even if the WasmPlugin doesn't apply to them\". i.e. in a different namespace, etc?",
        "pr_file_module": null
      },
      {
        "comment_id": "1830284682",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-06T01:41:02+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "good catch, this can cause secret escalate ",
        "pr_file_module": null
      },
      {
        "comment_id": "1830307962",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-06T02:22:13+00:00",
        "comment_author": "MaYuan-02",
        "comment_body": "I think this depends on \"Does istiod trust the connected xDS client?\"\r\nIf we don't trust xDS client at all, it can use fake labels(bypass WorkloadSelector check) to get a WasmPlugin in http listener. And this can also cause secret escalate.\r\nI'm not sure if such strict validation is necessary here. I'm happy to hear your opinions.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1830641786",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-06T09:13:44+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "I trust you bu also limit what you can do, think about this something like rbac",
        "pr_file_module": null
      },
      {
        "comment_id": "1830658328",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-06T09:24:53+00:00",
        "comment_author": "MaYuan-02",
        "comment_body": "I have two ideas:\r\n\r\nOne is to enhance push.WasmPlugins(proxy) to allow it to obtain the service information of the waypoint proxy, and further filter the corresponding WasmPlugin based on these services.\r\n\r\nThe other is to directly use the SubjectAccessReview to get RBAC permissions for the obtained secret, similar to how secrets are mounted in gateways. This approach might change the current behavior but would be more secure.\r\n\r\nI would like to hear your thoughts on these two ideas\uff01\ud83d\ude0a",
        "pr_file_module": null
      },
      {
        "comment_id": "1832186015",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-07T07:34:59+00:00",
        "comment_author": "hzxuzhonghu",
        "comment_body": "`WasmPluginsByListenerInfo` maybe used to get the wasmplugins",
        "pr_file_module": null
      },
      {
        "comment_id": "1836636228",
        "repo_full_name": "istio/istio",
        "pr_number": 53781,
        "pr_file": "pilot/pkg/xds/ecds.go",
        "discussion_id": "1829649930",
        "commented_code": "@@ -167,13 +167,11 @@ func referencedSecrets(proxy *model.Proxy, push *model.PushContext, resourceName\n \t// TODO: we get the WasmPlugins here to get the secrets reference in order to decide whether ECDS push is needed,\n \t//       and we will get it again at extension config build. Avoid getting it twice if this becomes a problem.\n \twatched := sets.New(resourceNames...)\n-\twasmPlugins := push.WasmPlugins(proxy)\n+\twasmPlugins := push.WasmPluginsByName(proxy, core.ParseExtensionName(resourceNames))",
        "comment_created_at": "2024-11-11T12:59:37+00:00",
        "comment_author": "MaYuan-02",
        "comment_body": "* Refactor WorkloadPolicyMatcher, make it support multi-service. \r\n* In WasmPlugins(proxy *Proxy), if current proxy is a waypoint, query service in ambientIndex.\r\n",
        "pr_file_module": null
      }
    ]
  }
]