[
  {
    "discussion_id": "2432169921",
    "pr_number": 7735,
    "pr_file": "cli/src/complete.rs",
    "created_at": "2025-10-15T11:14:16+00:00",
    "commented_code": ".arg(BOOKMARK_HELP_TEMPLATE)\n             .arg(\"--template\")\n             .arg(\n-                r#\"if(remote && !tracked && remote != \"git\",\n-                    name ++ '@' ++ remote ++ bookmark_help() ++ \"\n\"\n+                r#\"\n+                if(remote != \"git\",\n+                    if(!remote, name) ++ \"\\t\" ++\n+                    if(remote, name ++ \"@\" ++ remote) ++ \"\\t\" ++\n+                    if(tracked, \"tracked\") ++ \"\\t\" ++\n+                    bookmark_help() ++ \"\n\"\n                 )\"#,\n             )\n             .output()\n             .map_err(user_error)?;\n+        let bookmark_table = String::from_utf8_lossy(&bookmark_table.stdout);\n+\n+        let mut possible_bookmarks_to_track = Vec::new();\n+        let mut already_tracked_bookmarks = Vec::new();\n+\n+        for line in bookmark_table.lines() {\n+            let mut iter = line.split('\\t');\n+            let local = iter.next().unwrap_or_default();\n+            let remote = iter.next().unwrap_or_default();\n+            let tracked = iter.next().unwrap_or_default();\n+            let help = iter.next().unwrap_or_default();\n+\n+            if !local.is_empty() {\n+                possible_bookmarks_to_track.extend(\n+                    remotes\n+                        .iter()\n+                        .map(|remote| (format!(\"{local}@{remote}\"), help)),\n+                );\n+            } else if tracked.is_empty() {\n+                possible_bookmarks_to_track.push((remote.to_owned(), help));\n+            } else {\n+                already_tracked_bookmarks.push(remote);\n+            }\n+        }\n+        possible_bookmarks_to_track\n+            .retain(|(bookmark, _help)| !already_tracked_bookmarks.contains(&bookmark.as_str()));",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2432169921",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7735,
        "pr_file": "cli/src/complete.rs",
        "discussion_id": "2432169921",
        "commented_code": "@@ -116,18 +129,47 @@ pub fn untracked_bookmarks() -> Vec<CompletionCandidate> {\n             .arg(BOOKMARK_HELP_TEMPLATE)\n             .arg(\"--template\")\n             .arg(\n-                r#\"if(remote && !tracked && remote != \"git\",\n-                    name ++ '@' ++ remote ++ bookmark_help() ++ \"\\n\"\n+                r#\"\n+                if(remote != \"git\",\n+                    if(!remote, name) ++ \"\\t\" ++\n+                    if(remote, name ++ \"@\" ++ remote) ++ \"\\t\" ++\n+                    if(tracked, \"tracked\") ++ \"\\t\" ++\n+                    bookmark_help() ++ \"\\n\"\n                 )\"#,\n             )\n             .output()\n             .map_err(user_error)?;\n+        let bookmark_table = String::from_utf8_lossy(&bookmark_table.stdout);\n+\n+        let mut possible_bookmarks_to_track = Vec::new();\n+        let mut already_tracked_bookmarks = Vec::new();\n+\n+        for line in bookmark_table.lines() {\n+            let mut iter = line.split('\\t');\n+            let local = iter.next().unwrap_or_default();\n+            let remote = iter.next().unwrap_or_default();\n+            let tracked = iter.next().unwrap_or_default();\n+            let help = iter.next().unwrap_or_default();\n+\n+            if !local.is_empty() {\n+                possible_bookmarks_to_track.extend(\n+                    remotes\n+                        .iter()\n+                        .map(|remote| (format!(\"{local}@{remote}\"), help)),\n+                );\n+            } else if tracked.is_empty() {\n+                possible_bookmarks_to_track.push((remote.to_owned(), help));\n+            } else {\n+                already_tracked_bookmarks.push(remote);\n+            }\n+        }\n+        possible_bookmarks_to_track\n+            .retain(|(bookmark, _help)| !already_tracked_bookmarks.contains(&bookmark.as_str()));",
        "comment_created_at": "2025-10-15T11:14:16+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: I think it's better to use `HashSet` since `already_tracked_bookmarks` can be large.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2356774351",
    "pr_number": 7252,
    "pr_file": "lib/src/default_index/revset_engine.rs",
    "created_at": "2025-09-17T21:00:32+00:00",
    "commented_code": "let candidate_set = self.evaluate(candidates)?;\n                 Ok(Box::new(self.take_latest_revset(&*candidate_set, *count)?))\n             }\n+            ResolvedExpression::HasSize { candidates, count } => {\n+                let set = self.evaluate(candidates)?;\n+                let positions: Vec<_> = set\n+                    .positions()\n+                    .attach(index)\n+                    .take(count.saturating_add(1))\n+                    .try_collect()?;\n+                if positions.len() != *count {\n+                    return Err(RevsetEvaluationError::Other(\n+                        format!(\n+                            \"The revset was expected to have {} elements, but has {} elements\",",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2356774351",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7252,
        "pr_file": "lib/src/default_index/revset_engine.rs",
        "discussion_id": "2356774351",
        "commented_code": "@@ -1047,6 +1047,25 @@ impl EvaluationContext<'_> {\n                 let candidate_set = self.evaluate(candidates)?;\n                 Ok(Box::new(self.take_latest_revset(&*candidate_set, *count)?))\n             }\n+            ResolvedExpression::HasSize { candidates, count } => {\n+                let set = self.evaluate(candidates)?;\n+                let positions: Vec<_> = set\n+                    .positions()\n+                    .attach(index)\n+                    .take(count.saturating_add(1))\n+                    .try_collect()?;\n+                if positions.len() != *count {\n+                    return Err(RevsetEvaluationError::Other(\n+                        format!(\n+                            \"The revset was expected to have {} elements, but has {} elements\",",
        "comment_created_at": "2025-09-17T21:00:32+00:00",
        "comment_author": "scott2000",
        "comment_body": "nit: The current wording might be misleading after `.take()`. For instance, if the revset evaluated to 10 commits but the expected count was 1, I believe this would print \"The revset was expected to have 1 elements, but has 2 elements\", even though it actually has 10 elements. I'm not sure if there's any better way though.",
        "pr_file_module": null
      },
      {
        "comment_id": "2356856231",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7252,
        "pr_file": "lib/src/default_index/revset_engine.rs",
        "discussion_id": "2356774351",
        "commented_code": "@@ -1047,6 +1047,25 @@ impl EvaluationContext<'_> {\n                 let candidate_set = self.evaluate(candidates)?;\n                 Ok(Box::new(self.take_latest_revset(&*candidate_set, *count)?))\n             }\n+            ResolvedExpression::HasSize { candidates, count } => {\n+                let set = self.evaluate(candidates)?;\n+                let positions: Vec<_> = set\n+                    .positions()\n+                    .attach(index)\n+                    .take(count.saturating_add(1))\n+                    .try_collect()?;\n+                if positions.len() != *count {\n+                    return Err(RevsetEvaluationError::Other(\n+                        format!(\n+                            \"The revset was expected to have {} elements, but has {} elements\",",
        "comment_created_at": "2025-09-17T21:43:51+00:00",
        "comment_author": "martinvonz",
        "comment_body": "Good point. There's `set.count_estimate()` we could perhaps use.",
        "pr_file_module": null
      },
      {
        "comment_id": "2356889086",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7252,
        "pr_file": "lib/src/default_index/revset_engine.rs",
        "discussion_id": "2356774351",
        "commented_code": "@@ -1047,6 +1047,25 @@ impl EvaluationContext<'_> {\n                 let candidate_set = self.evaluate(candidates)?;\n                 Ok(Box::new(self.take_latest_revset(&*candidate_set, *count)?))\n             }\n+            ResolvedExpression::HasSize { candidates, count } => {\n+                let set = self.evaluate(candidates)?;\n+                let positions: Vec<_> = set\n+                    .positions()\n+                    .attach(index)\n+                    .take(count.saturating_add(1))\n+                    .try_collect()?;\n+                if positions.len() != *count {\n+                    return Err(RevsetEvaluationError::Other(\n+                        format!(\n+                            \"The revset was expected to have {} elements, but has {} elements\",",
        "comment_created_at": "2025-09-17T22:06:39+00:00",
        "comment_author": "scott2000",
        "comment_body": "> Good point. There's `set.count_estimate()` we could perhaps use.\r\n\r\nI believe currently `.count_estimate()` just evaluates the entire revset, so at that point we might as well just remove `.take()` entirely (since we'd evaluate the entire revset anyway to get the count).\r\n\r\nMaybe we could just conditionally either say the exact number if it's less than the expected count, or say \"at least `${positions.len()}` elements\" if it's greater than the expected count? I'm not sure if that's overcomplicating things though.",
        "pr_file_module": null
      },
      {
        "comment_id": "2356898532",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7252,
        "pr_file": "lib/src/default_index/revset_engine.rs",
        "discussion_id": "2356774351",
        "commented_code": "@@ -1047,6 +1047,25 @@ impl EvaluationContext<'_> {\n                 let candidate_set = self.evaluate(candidates)?;\n                 Ok(Box::new(self.take_latest_revset(&*candidate_set, *count)?))\n             }\n+            ResolvedExpression::HasSize { candidates, count } => {\n+                let set = self.evaluate(candidates)?;\n+                let positions: Vec<_> = set\n+                    .positions()\n+                    .attach(index)\n+                    .take(count.saturating_add(1))\n+                    .try_collect()?;\n+                if positions.len() != *count {\n+                    return Err(RevsetEvaluationError::Other(\n+                        format!(\n+                            \"The revset was expected to have {} elements, but has {} elements\",",
        "comment_created_at": "2025-09-17T22:12:25+00:00",
        "comment_author": "martinvonz",
        "comment_body": "Oh, you're right, the default revset engine does evaluate the entire revset. I was only thinking of Google's revset engine, which is often able to be answer it without evaluating the revset.\r\n\r\nYour suggestion sounds good to me (basically \"expected 5 revisions, got fewer\" or \"expected 5 revisions, got more\").",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460277871",
    "pr_number": 2845,
    "pr_file": "lib/src/footer.rs",
    "created_at": "2024-01-20T07:27:03+00:00",
    "commented_code": "+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//! Parsing footer lines from commit messages.\n+\n+use indexmap::IndexMap;\n+\n+/// Parse the footer lines from a commit message; these are simple key-value\n+/// pairs, separated by a colon, describing extra information in a commit\n+/// message; an example is the following:\n+///\n+/// ```text\n+/// chore: fix bug 1234\n+///\n+/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n+/// tempor incididunt ut labore et dolore magna aliqua.\n+///\n+/// Co-authored-by: Alice <alice@example.com>\n+/// Co-authored-by: Bob <bob@example.com>\n+/// Reviewed-by: Charlie <charlie@example.com>\n+/// Change-Id: I1234567890abcdef1234567890abcdef12345678\n+/// ```\n+///\n+/// In this case, there are four footer lines: two `Co-authored-by` lines, one\n+/// `Reviewed-by` line, and one `Change-Id` line.\n+pub fn get_footer_lines(body: &str) -> Option<IndexMap<String, Vec<String>>> {",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "1460277871",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "lib/src/footer.rs",
        "discussion_id": "1460277871",
        "commented_code": "@@ -0,0 +1,143 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//! Parsing footer lines from commit messages.\n+\n+use indexmap::IndexMap;\n+\n+/// Parse the footer lines from a commit message; these are simple key-value\n+/// pairs, separated by a colon, describing extra information in a commit\n+/// message; an example is the following:\n+///\n+/// ```text\n+/// chore: fix bug 1234\n+///\n+/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n+/// tempor incididunt ut labore et dolore magna aliqua.\n+///\n+/// Co-authored-by: Alice <alice@example.com>\n+/// Co-authored-by: Bob <bob@example.com>\n+/// Reviewed-by: Charlie <charlie@example.com>\n+/// Change-Id: I1234567890abcdef1234567890abcdef12345678\n+/// ```\n+///\n+/// In this case, there are four footer lines: two `Co-authored-by` lines, one\n+/// `Reviewed-by` line, and one `Change-Id` line.\n+pub fn get_footer_lines(body: &str) -> Option<IndexMap<String, Vec<String>>> {",
        "comment_created_at": "2024-01-20T07:27:03+00:00",
        "comment_author": "yuja",
        "comment_body": "might be better to return `(key, value)` pairs to preserve the exact order.",
        "pr_file_module": null
      },
      {
        "comment_id": "1460692542",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "lib/src/footer.rs",
        "discussion_id": "1460277871",
        "commented_code": "@@ -0,0 +1,143 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//! Parsing footer lines from commit messages.\n+\n+use indexmap::IndexMap;\n+\n+/// Parse the footer lines from a commit message; these are simple key-value\n+/// pairs, separated by a colon, describing extra information in a commit\n+/// message; an example is the following:\n+///\n+/// ```text\n+/// chore: fix bug 1234\n+///\n+/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n+/// tempor incididunt ut labore et dolore magna aliqua.\n+///\n+/// Co-authored-by: Alice <alice@example.com>\n+/// Co-authored-by: Bob <bob@example.com>\n+/// Reviewed-by: Charlie <charlie@example.com>\n+/// Change-Id: I1234567890abcdef1234567890abcdef12345678\n+/// ```\n+///\n+/// In this case, there are four footer lines: two `Co-authored-by` lines, one\n+/// `Reviewed-by` line, and one `Change-Id` line.\n+pub fn get_footer_lines(body: &str) -> Option<IndexMap<String, Vec<String>>> {",
        "comment_created_at": "2024-01-20T23:53:25+00:00",
        "comment_author": "thoughtpolice",
        "comment_body": "Doesn't `IndexMap` preserve this? Or was I misreading the documentation?",
        "pr_file_module": null
      },
      {
        "comment_id": "1460705493",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "lib/src/footer.rs",
        "discussion_id": "1460277871",
        "commented_code": "@@ -0,0 +1,143 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//! Parsing footer lines from commit messages.\n+\n+use indexmap::IndexMap;\n+\n+/// Parse the footer lines from a commit message; these are simple key-value\n+/// pairs, separated by a colon, describing extra information in a commit\n+/// message; an example is the following:\n+///\n+/// ```text\n+/// chore: fix bug 1234\n+///\n+/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n+/// tempor incididunt ut labore et dolore magna aliqua.\n+///\n+/// Co-authored-by: Alice <alice@example.com>\n+/// Co-authored-by: Bob <bob@example.com>\n+/// Reviewed-by: Charlie <charlie@example.com>\n+/// Change-Id: I1234567890abcdef1234567890abcdef12345678\n+/// ```\n+///\n+/// In this case, there are four footer lines: two `Co-authored-by` lines, one\n+/// `Reviewed-by` line, and one `Change-Id` line.\n+pub fn get_footer_lines(body: &str) -> Option<IndexMap<String, Vec<String>>> {",
        "comment_created_at": "2024-01-21T02:24:56+00:00",
        "comment_author": "yuja",
        "comment_body": "Something like `(a, x), (b, y), (a, z)` will be reordered. If we're going to use this function to do some text processing, it's best to preserve the original order at all.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1460712451",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "lib/src/footer.rs",
        "discussion_id": "1460277871",
        "commented_code": "@@ -0,0 +1,143 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+//! Parsing footer lines from commit messages.\n+\n+use indexmap::IndexMap;\n+\n+/// Parse the footer lines from a commit message; these are simple key-value\n+/// pairs, separated by a colon, describing extra information in a commit\n+/// message; an example is the following:\n+///\n+/// ```text\n+/// chore: fix bug 1234\n+///\n+/// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n+/// tempor incididunt ut labore et dolore magna aliqua.\n+///\n+/// Co-authored-by: Alice <alice@example.com>\n+/// Co-authored-by: Bob <bob@example.com>\n+/// Reviewed-by: Charlie <charlie@example.com>\n+/// Change-Id: I1234567890abcdef1234567890abcdef12345678\n+/// ```\n+///\n+/// In this case, there are four footer lines: two `Co-authored-by` lines, one\n+/// `Reviewed-by` line, and one `Change-Id` line.\n+pub fn get_footer_lines(body: &str) -> Option<IndexMap<String, Vec<String>>> {",
        "comment_created_at": "2024-01-21T03:51:37+00:00",
        "comment_author": "thoughtpolice",
        "comment_body": "Ah, good catch, I see what you mean. I'm going to end up refactoring this into a more abstract type that hides the representation anyway, I think...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460282350",
    "pr_number": 2845,
    "pr_file": "cli/src/commands/gerrit.rs",
    "created_at": "2024-01-20T07:40:57+00:00",
    "commented_code": "}\n \n     if !remote_exists {\n-        return Err(user_error(&format!(\n+        return Err(user_error(format!(\n             \"The (Gerrit) remote '{}' does not exist\",\n             for_remote\n         )));\n     }\n \n-    for head in base_repo.index().heads(&mut to_mail.iter().map(|c| c.id())) {\n-        println!(\"Pushing to {}@{}: {:?}\", for_branch, for_remote, head);\n+    // immediately error and reject any discardable commits, i.e. the\n+    // the empty wcc\n+    for commit in to_mail.iter() {\n+        if commit.is_discardable() {\n+            return Err(user_error(format!(\n+                \"Refusing to mail in commit {} because it is an empty commit with no \\\n+                 description\n(use 'jj amend' to add a description, or 'jj abandon' to discard it)\",\n+                short_commit_hash(commit.id())\n+            )));\n+        }\n+    }\n+\n+    // the mapping is from old -> [new, is_dry_run]; the dry_run flag is used to\n+    // disambiguate a later case when printing errors, so we know that if a\n+    // commit was mapped to itself, it was because --dry-run was set, and not\n+    // because e.g. it had an existing change id already\n+    let mut old_to_new: IndexMap<Commit, (Commit, bool)> = IndexMap::new();\n+    for commit_id in base_repo\n+        .index()\n+        .topo_order(&mut to_mail.iter().map(|c| c.id()))",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "1460282350",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "cli/src/commands/gerrit.rs",
        "discussion_id": "1460282350",
        "commented_code": "@@ -123,14 +139,261 @@ pub fn cmd_mail(\n     }\n \n     if !remote_exists {\n-        return Err(user_error(&format!(\n+        return Err(user_error(format!(\n             \"The (Gerrit) remote '{}' does not exist\",\n             for_remote\n         )));\n     }\n \n-    for head in base_repo.index().heads(&mut to_mail.iter().map(|c| c.id())) {\n-        println!(\"Pushing to {}@{}: {:?}\", for_branch, for_remote, head);\n+    // immediately error and reject any discardable commits, i.e. the\n+    // the empty wcc\n+    for commit in to_mail.iter() {\n+        if commit.is_discardable() {\n+            return Err(user_error(format!(\n+                \"Refusing to mail in commit {} because it is an empty commit with no \\\n+                 description\\n(use 'jj amend' to add a description, or 'jj abandon' to discard it)\",\n+                short_commit_hash(commit.id())\n+            )));\n+        }\n+    }\n+\n+    // the mapping is from old -> [new, is_dry_run]; the dry_run flag is used to\n+    // disambiguate a later case when printing errors, so we know that if a\n+    // commit was mapped to itself, it was because --dry-run was set, and not\n+    // because e.g. it had an existing change id already\n+    let mut old_to_new: IndexMap<Commit, (Commit, bool)> = IndexMap::new();\n+    for commit_id in base_repo\n+        .index()\n+        .topo_order(&mut to_mail.iter().map(|c| c.id()))",
        "comment_created_at": "2024-01-20T07:40:57+00:00",
        "comment_author": "yuja",
        "comment_body": "Since `to_mail` is reordered here, maybe it's simpler to combine the user-specified revset expressions by `union_all()`, and evaluate them all at once. I do that in `cmd_branch_list()`. The evaluated revset is in reverse topological order.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290787511",
    "pr_number": 7277,
    "pr_file": "cli/src/commands/undo.rs",
    "created_at": "2025-08-21T11:45:03+00:00",
    "commented_code": "ui.warning_default(),\n             \"`jj undo <operation>` is deprecated; use `jj op revert <operation>` instead\"\n         )?;\n+        let args = OperationRevertArgs {\n+            operation: args.operation.clone(),\n+            what: args.what.clone(),\n+        };\n+        return cmd_op_revert_with_tx_description(ui, command, &args, tx_description);\n     }\n+\n     let workspace_command = command.workspace_helper(ui)?;\n-    let bad_op = workspace_command.resolve_single_op(&args.operation)?;\n-    let parent_of_bad_op = match bad_op.parents().at_most_one() {\n-        Ok(Some(parent_of_bad_op)) => parent_of_bad_op?,\n-        Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n-        Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n-    };\n \n-    let args = OperationRevertArgs {\n-        operation: args.operation.clone(),\n-        what: args.what.clone(),\n-    };\n-    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;\n+    let mut op_to_undo = workspace_command.resolve_single_op(&args.operation)?;\n \n-    // Check if the user performed a \"double undo\", i.e. the current `undo` (C)\n-    // reverts an immediately preceding `undo` (B) that is itself an `undo` of the\n-    // operation preceding it (A).\n+    // Growing the \"undo-stack\" works like this:\n+    // - If the operation to undo is a regular one (not an undo-operation), simply\n+    //   undo it.\n+    // - If the operation to undo is an undo-operation itself, try to undo the\n+    //   parent of the operation that was already undone.\n+    // - Repeat the process of following undo-operations to the operations they\n+    //   undid until the first undoable operation is found - then undo it.\n     //\n-    //    C (undo of B)\n-    // @  B (`bad_op` = undo of A)\n-    // \u25cb  A\n+    // This described behavior leads to \"jumping over\" old undo-stacks if the\n+    // current one grows into it. For example, Consider the this op-log example:\n     //\n-    // An exception is made for when the user specified the immediately preceding\n-    // `undo` with an op set. In this situation, the user's intent is clear, so\n-    // a warning is not shown.\n+    // * F \"undo A\" ---+\n+    // |               |\n+    // * E \"undo D\" -+ |\n+    // |             | |\n+    // * D   <-------+ |\n+    // |               |\n+    // * C \"undo B\" -+ |\n+    // |             | |\n+    // * B   <-------+ |\n+    // |               |\n+    // * A   <---------+\n     //\n-    // Note that undoing an older `undo` does not constitute a \"double undo\". For\n-    // example, the current `undo` (D) here reverts an `undo` B that is not the\n-    // immediately preceding operation (C). A warning is not shown in this case.\n+    // It was produced by the following sequence of events:\n+    // - do normal operation A\n+    // - do normal operation B\n+    // - undo B\n+    // - do normal operation D\n+    // - undo D\n+    // - undo A\n     //\n-    //    D (undo of B)\n-    // @  C (unrelated operation)\n-    // \u25cb  B (`bad_op` = undo of A)\n-    // \u25cb  A\n-    if args.operation == \"@\"\n-        && resets_view_of(&bad_op, &parent_of_bad_op)?\n-        && bad_op.metadata().description == tx_description(&parent_of_bad_op)\n+    // Notice that running `undo` after having undone D leads to A being undone\n+    // (as opposed to C). The undo-stack spanning B and C was \"jumped over\".\n+    //\n+    while let Some(id_of_undone_op) = op_to_undo\n+        .metadata()\n+        .description\n+        .strip_prefix(UNDO_OP_DESC_PREFIX)\n     {\n-        writeln!(\n-            ui.warning_default(),\n-            \"The second-last `jj undo` was reverted by the latest `jj undo`. The repo is now in \\\n-             the same state as it was before the second-last `jj undo`.\"\n-        )?;\n-        writeln!(\n-            ui.hint_default(),\n-            \"To undo multiple operations, use `jj op log` to see past states and `jj op restore` \\\n-             to restore one of these states.\"\n-        )?;\n+        let undone_op = workspace_command.resolve_single_op(id_of_undone_op)?;\n+        op_to_undo = match undone_op.parents().at_most_one() {\n+            Ok(Some(parent_of_undone_op)) => parent_of_undone_op?,\n+            Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n+            Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n+        };\n     }\n \n+    let args = OperationRevertArgs {\n+        operation: op_to_undo.id().to_string(),\n+        what: args.what.clone(),\n+    };\n+    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2290787511",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7277,
        "pr_file": "cli/src/commands/undo.rs",
        "discussion_id": "2290787511",
        "commented_code": "@@ -72,56 +60,69 @@ pub fn cmd_undo(ui: &mut Ui, command: &CommandHelper, args: &UndoArgs) -> Result\n             ui.warning_default(),\n             \"`jj undo <operation>` is deprecated; use `jj op revert <operation>` instead\"\n         )?;\n+        let args = OperationRevertArgs {\n+            operation: args.operation.clone(),\n+            what: args.what.clone(),\n+        };\n+        return cmd_op_revert_with_tx_description(ui, command, &args, tx_description);\n     }\n+\n     let workspace_command = command.workspace_helper(ui)?;\n-    let bad_op = workspace_command.resolve_single_op(&args.operation)?;\n-    let parent_of_bad_op = match bad_op.parents().at_most_one() {\n-        Ok(Some(parent_of_bad_op)) => parent_of_bad_op?,\n-        Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n-        Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n-    };\n \n-    let args = OperationRevertArgs {\n-        operation: args.operation.clone(),\n-        what: args.what.clone(),\n-    };\n-    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;\n+    let mut op_to_undo = workspace_command.resolve_single_op(&args.operation)?;\n \n-    // Check if the user performed a \"double undo\", i.e. the current `undo` (C)\n-    // reverts an immediately preceding `undo` (B) that is itself an `undo` of the\n-    // operation preceding it (A).\n+    // Growing the \"undo-stack\" works like this:\n+    // - If the operation to undo is a regular one (not an undo-operation), simply\n+    //   undo it.\n+    // - If the operation to undo is an undo-operation itself, try to undo the\n+    //   parent of the operation that was already undone.\n+    // - Repeat the process of following undo-operations to the operations they\n+    //   undid until the first undoable operation is found - then undo it.\n     //\n-    //    C (undo of B)\n-    // @  B (`bad_op` = undo of A)\n-    // \u25cb  A\n+    // This described behavior leads to \"jumping over\" old undo-stacks if the\n+    // current one grows into it. For example, Consider the this op-log example:\n     //\n-    // An exception is made for when the user specified the immediately preceding\n-    // `undo` with an op set. In this situation, the user's intent is clear, so\n-    // a warning is not shown.\n+    // * F \"undo A\" ---+\n+    // |               |\n+    // * E \"undo D\" -+ |\n+    // |             | |\n+    // * D   <-------+ |\n+    // |               |\n+    // * C \"undo B\" -+ |\n+    // |             | |\n+    // * B   <-------+ |\n+    // |               |\n+    // * A   <---------+\n     //\n-    // Note that undoing an older `undo` does not constitute a \"double undo\". For\n-    // example, the current `undo` (D) here reverts an `undo` B that is not the\n-    // immediately preceding operation (C). A warning is not shown in this case.\n+    // It was produced by the following sequence of events:\n+    // - do normal operation A\n+    // - do normal operation B\n+    // - undo B\n+    // - do normal operation D\n+    // - undo D\n+    // - undo A\n     //\n-    //    D (undo of B)\n-    // @  C (unrelated operation)\n-    // \u25cb  B (`bad_op` = undo of A)\n-    // \u25cb  A\n-    if args.operation == \"@\"\n-        && resets_view_of(&bad_op, &parent_of_bad_op)?\n-        && bad_op.metadata().description == tx_description(&parent_of_bad_op)\n+    // Notice that running `undo` after having undone D leads to A being undone\n+    // (as opposed to C). The undo-stack spanning B and C was \"jumped over\".\n+    //\n+    while let Some(id_of_undone_op) = op_to_undo\n+        .metadata()\n+        .description\n+        .strip_prefix(UNDO_OP_DESC_PREFIX)\n     {\n-        writeln!(\n-            ui.warning_default(),\n-            \"The second-last `jj undo` was reverted by the latest `jj undo`. The repo is now in \\\n-             the same state as it was before the second-last `jj undo`.\"\n-        )?;\n-        writeln!(\n-            ui.hint_default(),\n-            \"To undo multiple operations, use `jj op log` to see past states and `jj op restore` \\\n-             to restore one of these states.\"\n-        )?;\n+        let undone_op = workspace_command.resolve_single_op(id_of_undone_op)?;\n+        op_to_undo = match undone_op.parents().at_most_one() {\n+            Ok(Some(parent_of_undone_op)) => parent_of_undone_op?,\n+            Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n+            Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n+        };\n     }\n \n+    let args = OperationRevertArgs {\n+        operation: op_to_undo.id().to_string(),\n+        what: args.what.clone(),\n+    };\n+    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;",
        "comment_created_at": "2025-08-21T11:45:03+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: I think we can use the \"op restore\" logic here to clarify that we aren't creating new state by merging reverse operation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2291484070",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7277,
        "pr_file": "cli/src/commands/undo.rs",
        "discussion_id": "2290787511",
        "commented_code": "@@ -72,56 +60,69 @@ pub fn cmd_undo(ui: &mut Ui, command: &CommandHelper, args: &UndoArgs) -> Result\n             ui.warning_default(),\n             \"`jj undo <operation>` is deprecated; use `jj op revert <operation>` instead\"\n         )?;\n+        let args = OperationRevertArgs {\n+            operation: args.operation.clone(),\n+            what: args.what.clone(),\n+        };\n+        return cmd_op_revert_with_tx_description(ui, command, &args, tx_description);\n     }\n+\n     let workspace_command = command.workspace_helper(ui)?;\n-    let bad_op = workspace_command.resolve_single_op(&args.operation)?;\n-    let parent_of_bad_op = match bad_op.parents().at_most_one() {\n-        Ok(Some(parent_of_bad_op)) => parent_of_bad_op?,\n-        Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n-        Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n-    };\n \n-    let args = OperationRevertArgs {\n-        operation: args.operation.clone(),\n-        what: args.what.clone(),\n-    };\n-    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;\n+    let mut op_to_undo = workspace_command.resolve_single_op(&args.operation)?;\n \n-    // Check if the user performed a \"double undo\", i.e. the current `undo` (C)\n-    // reverts an immediately preceding `undo` (B) that is itself an `undo` of the\n-    // operation preceding it (A).\n+    // Growing the \"undo-stack\" works like this:\n+    // - If the operation to undo is a regular one (not an undo-operation), simply\n+    //   undo it.\n+    // - If the operation to undo is an undo-operation itself, try to undo the\n+    //   parent of the operation that was already undone.\n+    // - Repeat the process of following undo-operations to the operations they\n+    //   undid until the first undoable operation is found - then undo it.\n     //\n-    //    C (undo of B)\n-    // @  B (`bad_op` = undo of A)\n-    // \u25cb  A\n+    // This described behavior leads to \"jumping over\" old undo-stacks if the\n+    // current one grows into it. For example, Consider the this op-log example:\n     //\n-    // An exception is made for when the user specified the immediately preceding\n-    // `undo` with an op set. In this situation, the user's intent is clear, so\n-    // a warning is not shown.\n+    // * F \"undo A\" ---+\n+    // |               |\n+    // * E \"undo D\" -+ |\n+    // |             | |\n+    // * D   <-------+ |\n+    // |               |\n+    // * C \"undo B\" -+ |\n+    // |             | |\n+    // * B   <-------+ |\n+    // |               |\n+    // * A   <---------+\n     //\n-    // Note that undoing an older `undo` does not constitute a \"double undo\". For\n-    // example, the current `undo` (D) here reverts an `undo` B that is not the\n-    // immediately preceding operation (C). A warning is not shown in this case.\n+    // It was produced by the following sequence of events:\n+    // - do normal operation A\n+    // - do normal operation B\n+    // - undo B\n+    // - do normal operation D\n+    // - undo D\n+    // - undo A\n     //\n-    //    D (undo of B)\n-    // @  C (unrelated operation)\n-    // \u25cb  B (`bad_op` = undo of A)\n-    // \u25cb  A\n-    if args.operation == \"@\"\n-        && resets_view_of(&bad_op, &parent_of_bad_op)?\n-        && bad_op.metadata().description == tx_description(&parent_of_bad_op)\n+    // Notice that running `undo` after having undone D leads to A being undone\n+    // (as opposed to C). The undo-stack spanning B and C was \"jumped over\".\n+    //\n+    while let Some(id_of_undone_op) = op_to_undo\n+        .metadata()\n+        .description\n+        .strip_prefix(UNDO_OP_DESC_PREFIX)\n     {\n-        writeln!(\n-            ui.warning_default(),\n-            \"The second-last `jj undo` was reverted by the latest `jj undo`. The repo is now in \\\n-             the same state as it was before the second-last `jj undo`.\"\n-        )?;\n-        writeln!(\n-            ui.hint_default(),\n-            \"To undo multiple operations, use `jj op log` to see past states and `jj op restore` \\\n-             to restore one of these states.\"\n-        )?;\n+        let undone_op = workspace_command.resolve_single_op(id_of_undone_op)?;\n+        op_to_undo = match undone_op.parents().at_most_one() {\n+            Ok(Some(parent_of_undone_op)) => parent_of_undone_op?,\n+            Ok(None) => return Err(user_error(\"Cannot undo root operation\")),\n+            Err(_) => return Err(user_error(\"Cannot undo a merge operation\")),\n+        };\n     }\n \n+    let args = OperationRevertArgs {\n+        operation: op_to_undo.id().to_string(),\n+        what: args.what.clone(),\n+    };\n+    cmd_op_revert_with_tx_description(ui, command, &args, tx_description)?;",
        "comment_created_at": "2025-08-21T15:52:37+00:00",
        "comment_author": "senekor",
        "comment_body": "Hmm, that makes sense but it messes up the current semantics of operation descriptions. \"undo operation ABC\" only makes sense in the context of ABC being reverted. I will replace the description with \"undo: restore to operation XYZ\" (where XYZ is the parent of ABC). Let me know if you prefer a different description. After all, our users will see this every once in a while. I'll also need to update the ascii graphs in the comments to reflect how undo-operations now point to one operation further in the past.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2266892190",
    "pr_number": 7184,
    "pr_file": "cli/src/commands/touch.rs",
    "created_at": "2025-08-11T14:07:36+00:00",
    "commented_code": "+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::collections::HashMap;\n+\n+use clap_complete::ArgValueCompleter;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::object_id::ObjectId as _;\n+use tracing::instrument;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::cli_util::RevisionArg;\n+use crate::command_error::CommandError;\n+use crate::complete;\n+use crate::ui::Ui;\n+\n+/// Modify the metadata of a revision without changing its content\n+#[derive(clap::Args, Clone, Debug)]\n+pub(crate) struct TouchArgs {\n+    /// The revision(s) to touch (default: @)\n+    #[arg(\n+        value_name = \"REVSETS\",\n+        add = ArgValueCompleter::new(complete::revset_expression_mutable)\n+    )]\n+    revisions_pos: Vec<RevisionArg>,\n+\n+    #[arg(\n+        short = 'r',\n+        hide = true,\n+        value_name = \"REVSETS\",\n+        add = ArgValueCompleter::new(complete::revset_expression_mutable)\n+    )]\n+    revisions_opt: Vec<RevisionArg>,\n+}\n+\n+#[instrument(skip_all)]\n+pub(crate) fn cmd_touch(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &TouchArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+    let commits: Vec<_> = if !args.revisions_pos.is_empty() || !args.revisions_opt.is_empty() {\n+        workspace_command\n+            .parse_union_revsets(ui, &[&*args.revisions_pos, &*args.revisions_opt].concat())?\n+    } else {\n+        workspace_command.parse_revset(ui, &RevisionArg::AT)?\n+    }\n+    .evaluate_to_commit_ids()?\n+    .try_collect()?; // in reverse topological order\n+    if commits.is_empty() {\n+        writeln!(ui.status(), \"No revisions to touch.\")?;\n+        return Ok(());\n+    }\n+    workspace_command.check_rewritable(commits.iter())?;\n+\n+    let mut tx = workspace_command.start_transaction();\n+    let tx_description = match commits.as_slice() {\n+        [] => unreachable!(),\n+        [commit] => format!(\"touch commit {}\", commit.hex()),\n+        [first_commit, remaining_commits @ ..] => {\n+            format!(\n+                \"touch commit {} and {} more\",\n+                first_commit.hex(),\n+                remaining_commits.len()\n+            )\n+        }\n+    };\n+\n+    let mut num_touched = 0;\n+    let mut num_reparented = 0;\n+    let mut touched: HashMap<CommitId, CommitId> = HashMap::new();\n+    // Even though `MutableRepo::rewrite_commit` and\n+    // `MutableRepo::rebase_descendants` can handle rewriting of a commit even\n+    // if it is a descendant of another commit being rewritten, using\n+    // `MutableRepo::transform_descendants` prevents us from rewriting the same\n+    // commit multiple times, and adding additional entries in the predecessor\n+    // chain.\n+    tx.repo_mut()\n+        .transform_descendants(commits.clone(), async |rewriter| {\n+            let old_commit_id = rewriter.old_commit().id().clone();\n+            let mut commit_builder = rewriter.reparent();\n+            let new_parents = commit_builder\n+                .parents()\n+                .iter()\n+                .map(|p| (touched.get(p).unwrap_or(p)))\n+                .cloned()\n+                .collect();\n+            commit_builder = commit_builder.set_parents(new_parents);\n+            if commits.contains(&old_commit_id) {",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2266892190",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7184,
        "pr_file": "cli/src/commands/touch.rs",
        "discussion_id": "2266892190",
        "commented_code": "@@ -0,0 +1,123 @@\n+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::collections::HashMap;\n+\n+use clap_complete::ArgValueCompleter;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::object_id::ObjectId as _;\n+use tracing::instrument;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::cli_util::RevisionArg;\n+use crate::command_error::CommandError;\n+use crate::complete;\n+use crate::ui::Ui;\n+\n+/// Modify the metadata of a revision without changing its content\n+#[derive(clap::Args, Clone, Debug)]\n+pub(crate) struct TouchArgs {\n+    /// The revision(s) to touch (default: @)\n+    #[arg(\n+        value_name = \"REVSETS\",\n+        add = ArgValueCompleter::new(complete::revset_expression_mutable)\n+    )]\n+    revisions_pos: Vec<RevisionArg>,\n+\n+    #[arg(\n+        short = 'r',\n+        hide = true,\n+        value_name = \"REVSETS\",\n+        add = ArgValueCompleter::new(complete::revset_expression_mutable)\n+    )]\n+    revisions_opt: Vec<RevisionArg>,\n+}\n+\n+#[instrument(skip_all)]\n+pub(crate) fn cmd_touch(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &TouchArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+    let commits: Vec<_> = if !args.revisions_pos.is_empty() || !args.revisions_opt.is_empty() {\n+        workspace_command\n+            .parse_union_revsets(ui, &[&*args.revisions_pos, &*args.revisions_opt].concat())?\n+    } else {\n+        workspace_command.parse_revset(ui, &RevisionArg::AT)?\n+    }\n+    .evaluate_to_commit_ids()?\n+    .try_collect()?; // in reverse topological order\n+    if commits.is_empty() {\n+        writeln!(ui.status(), \"No revisions to touch.\")?;\n+        return Ok(());\n+    }\n+    workspace_command.check_rewritable(commits.iter())?;\n+\n+    let mut tx = workspace_command.start_transaction();\n+    let tx_description = match commits.as_slice() {\n+        [] => unreachable!(),\n+        [commit] => format!(\"touch commit {}\", commit.hex()),\n+        [first_commit, remaining_commits @ ..] => {\n+            format!(\n+                \"touch commit {} and {} more\",\n+                first_commit.hex(),\n+                remaining_commits.len()\n+            )\n+        }\n+    };\n+\n+    let mut num_touched = 0;\n+    let mut num_reparented = 0;\n+    let mut touched: HashMap<CommitId, CommitId> = HashMap::new();\n+    // Even though `MutableRepo::rewrite_commit` and\n+    // `MutableRepo::rebase_descendants` can handle rewriting of a commit even\n+    // if it is a descendant of another commit being rewritten, using\n+    // `MutableRepo::transform_descendants` prevents us from rewriting the same\n+    // commit multiple times, and adding additional entries in the predecessor\n+    // chain.\n+    tx.repo_mut()\n+        .transform_descendants(commits.clone(), async |rewriter| {\n+            let old_commit_id = rewriter.old_commit().id().clone();\n+            let mut commit_builder = rewriter.reparent();\n+            let new_parents = commit_builder\n+                .parents()\n+                .iter()\n+                .map(|p| (touched.get(p).unwrap_or(p)))\n+                .cloned()\n+                .collect();\n+            commit_builder = commit_builder.set_parents(new_parents);\n+            if commits.contains(&old_commit_id) {",
        "comment_created_at": "2025-08-11T14:07:36+00:00",
        "comment_author": "martinvonz",
        "comment_body": "nit: Should use a set here (`HashSet` or `IndexSet`, for example)",
        "pr_file_module": null
      }
    ]
  }
]