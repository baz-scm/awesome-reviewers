[
  {
    "discussion_id": "2422056714",
    "pr_number": 7695,
    "pr_file": "lib/src/local_working_copy.rs",
    "created_at": "2025-10-10T20:48:30+00:00",
    "commented_code": "fs::remove_dir(&dir_path).ok();\n             }\n         })?;\n+\n+        if created_dirs.write().await.insert(dir_path.clone()) {",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2422056714",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7695,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2422056714",
        "commented_code": "@@ -578,6 +587,10 @@ fn create_parent_dirs(\n                 fs::remove_dir(&dir_path).ok();\n             }\n         })?;\n+\n+        if created_dirs.write().await.insert(dir_path.clone()) {",
        "comment_created_at": "2025-10-10T20:48:30+00:00",
        "comment_author": "landaire",
        "comment_body": "TODO: this should just be an insert, not a conditional.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2374943194",
    "pr_number": 6990,
    "pr_file": "cli/src/repo_managed_config.rs",
    "created_at": "2025-09-24T08:25:36+00:00",
    "commented_code": "+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::io;\n+use std::path::Path;\n+use std::path::PathBuf;\n+\n+use jj_lib::config::ConfigLayer;\n+use jj_lib::config::ConfigSource;\n+use jj_lib::content_hash::blake2b_hash;\n+use jj_lib::file_util::IoResultExt as _;\n+use jj_lib::file_util::PathError;\n+use jj_lib::hex_util;\n+use jj_lib::repo_path::RepoPathBuf;\n+\n+use crate::command_error::CommandError;\n+use crate::command_error::user_error;\n+use crate::ui::Ui;\n+\n+pub const MANAGED_PATH: &str = \".config/jj/config.toml\";\n+const LAST_APPROVED: &str = \"last_approved\";\n+\n+fn jj_state_dir() -> Option<PathBuf> {\n+    #[cfg(windows)]\n+    if let Ok(x) = std::env::var(\"USERPROFILE\") {\n+        return Some(Path::new(&x).join(\".local/state/jj\"));\n+    }\n+\n+    if let Ok(x) = std::env::var(\"XDG_STATE_HOME\")\n+        && !x.is_empty()\n+    {\n+        Some(Path::new(&x).join(\"jj\"))\n+    } else if let Ok(x) = std::env::var(\"HOME\") {\n+        Some(Path::new(&x).join(\".local/state/jj\"))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Manages the repo-managed config. The file structure for the repo-managed\n+/// config for a repo contained at /path/to/repo is:\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/last_approved:\n+///   hash(config1)\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/hash(config1):\n+///   approved content for config1\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/hash(config2):\n+///   approved content for config2\n+pub struct RepoManagedConfig {\n+    config_dir: PathBuf,\n+    // Canonicalized repo path. It must be canonicalized because we hash this.\n+    repo_path: PathBuf,\n+}\n+\n+impl RepoManagedConfig {\n+    pub fn new(repo_path: &Path) -> Result<Self, CommandError> {\n+        let repo_path = dunce::canonicalize(repo_path)?;",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2374943194",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 6990,
        "pr_file": "cli/src/repo_managed_config.rs",
        "discussion_id": "2374943194",
        "commented_code": "@@ -0,0 +1,192 @@\n+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::io;\n+use std::path::Path;\n+use std::path::PathBuf;\n+\n+use jj_lib::config::ConfigLayer;\n+use jj_lib::config::ConfigSource;\n+use jj_lib::content_hash::blake2b_hash;\n+use jj_lib::file_util::IoResultExt as _;\n+use jj_lib::file_util::PathError;\n+use jj_lib::hex_util;\n+use jj_lib::repo_path::RepoPathBuf;\n+\n+use crate::command_error::CommandError;\n+use crate::command_error::user_error;\n+use crate::ui::Ui;\n+\n+pub const MANAGED_PATH: &str = \".config/jj/config.toml\";\n+const LAST_APPROVED: &str = \"last_approved\";\n+\n+fn jj_state_dir() -> Option<PathBuf> {\n+    #[cfg(windows)]\n+    if let Ok(x) = std::env::var(\"USERPROFILE\") {\n+        return Some(Path::new(&x).join(\".local/state/jj\"));\n+    }\n+\n+    if let Ok(x) = std::env::var(\"XDG_STATE_HOME\")\n+        && !x.is_empty()\n+    {\n+        Some(Path::new(&x).join(\"jj\"))\n+    } else if let Ok(x) = std::env::var(\"HOME\") {\n+        Some(Path::new(&x).join(\".local/state/jj\"))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Manages the repo-managed config. The file structure for the repo-managed\n+/// config for a repo contained at /path/to/repo is:\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/last_approved:\n+///   hash(config1)\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/hash(config1):\n+///   approved content for config1\n+/// ~/.local/state/jj/repos/hash(/path/to/repo)/hash(config2):\n+///   approved content for config2\n+pub struct RepoManagedConfig {\n+    config_dir: PathBuf,\n+    // Canonicalized repo path. It must be canonicalized because we hash this.\n+    repo_path: PathBuf,\n+}\n+\n+impl RepoManagedConfig {\n+    pub fn new(repo_path: &Path) -> Result<Self, CommandError> {\n+        let repo_path = dunce::canonicalize(repo_path)?;",
        "comment_created_at": "2025-09-24T08:25:36+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: I think `repo_path` would be canonicalized by caller. Better to not do path normalization at various places.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2356394893",
    "pr_number": 7252,
    "pr_file": "lib/tests/test_revset.rs",
    "created_at": "2025-09-17T18:35:28+00:00",
    "commented_code": ".collect())\n }\n \n+fn try_evaluate_expression(repo: &dyn Repo, revset_str: &str) -> Result<(), RevsetEvaluationError> {\n+    let settings = testutils::user_settings();\n+    let context = RevsetParseContext {\n+        aliases_map: &RevsetAliasesMap::default(),\n+        local_variables: HashMap::new(),\n+        user_email: settings.user_email(),\n+        date_pattern_context: chrono::Utc::now().fixed_offset().into(),\n+        extensions: &RevsetExtensions::default(),\n+        workspace: None,\n+    };\n+    let expression = parse(&mut RevsetDiagnostics::new(), revset_str, &context).unwrap();\n+    let symbol_resolver = default_symbol_resolver(repo);\n+    let expression = expression\n+        .resolve_user_expression(repo, &symbol_resolver)\n+        .unwrap();\n+    match expression.evaluate(repo) {\n+        Ok(_) => Ok(()),\n+        Err(e) => Err(e),\n+    }",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2356394893",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7252,
        "pr_file": "lib/tests/test_revset.rs",
        "discussion_id": "2356394893",
        "commented_code": "@@ -1030,6 +1031,27 @@ fn try_resolve_commit_ids(\n         .collect())\n }\n \n+fn try_evaluate_expression(repo: &dyn Repo, revset_str: &str) -> Result<(), RevsetEvaluationError> {\n+    let settings = testutils::user_settings();\n+    let context = RevsetParseContext {\n+        aliases_map: &RevsetAliasesMap::default(),\n+        local_variables: HashMap::new(),\n+        user_email: settings.user_email(),\n+        date_pattern_context: chrono::Utc::now().fixed_offset().into(),\n+        extensions: &RevsetExtensions::default(),\n+        workspace: None,\n+    };\n+    let expression = parse(&mut RevsetDiagnostics::new(), revset_str, &context).unwrap();\n+    let symbol_resolver = default_symbol_resolver(repo);\n+    let expression = expression\n+        .resolve_user_expression(repo, &symbol_resolver)\n+        .unwrap();\n+    match expression.evaluate(repo) {\n+        Ok(_) => Ok(()),\n+        Err(e) => Err(e),\n+    }",
        "comment_created_at": "2025-09-17T18:35:28+00:00",
        "comment_author": "martinvonz",
        "comment_body": "nit: `expression.evaluate(repo).map(|_| ())`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460280123",
    "pr_number": 2845,
    "pr_file": "cli/src/commands/gerrit.rs",
    "created_at": "2024-01-20T07:34:00+00:00",
    "commented_code": "+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+\n+use clap::Subcommand;\n+use indexmap::IndexSet;\n+use jj_lib::commit::Commit;\n+use jj_lib::repo::Repo;\n+\n+use crate::cli_util::{\n+    get_git_repo, resolve_multiple_nonempty_revsets, user_error, CommandError, CommandHelper,\n+    RevisionArg,\n+};\n+use crate::ui::Ui;\n+\n+/// Interact with Gerrit Code Review.\n+#[derive(Subcommand, Clone, Debug)]\n+pub enum GerritCommand {\n+    /// \"Mail in\" a revision to Gerrit; this is the primary way to create\n+    /// changes or update changes for code review.\n+    ///\n+    /// This command modifies each commit in the revset to include a `Change-Id`\n+    /// footer in its commit message if one does not already exist. This ID is\n+    /// NOT compatible with jj IDs, and is a Gerrit-specific ID.\n+    ///\n+    /// Note: this command takes a revset as an argument, and will mail in all\n+    /// revisions in the revset to Gerrit appropriately, so you may post trees\n+    /// or ranges of commits to Gerrit for review.\n+    ///\n+    /// Note: this command does not actually send an email or use a Mail\n+    /// Transfer Agent, but rather uploads the revision to Gerrit for review\n+    /// through underlying Git logic. The term \"mail\" is used to disambiguate\n+    /// from the word \"submit\", which is what Gerrit calls \"merging an approved\n+    /// change into a target branch\", and is used to refer to the concept of\n+    /// \"mailing in\" something to be read by someone else.\n+    Mail(MailCommand),\n+}\n+\n+pub fn cmd_gerrit(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    subcommand: &GerritCommand,\n+) -> Result<(), CommandError> {\n+    match subcommand {\n+        GerritCommand::Mail(review) => {\n+            cmd_mail(ui, command, review)?;\n+        }\n+    }\n+    Ok(())",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "1460280123",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "cli/src/commands/gerrit.rs",
        "discussion_id": "1460280123",
        "commented_code": "@@ -0,0 +1,137 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+\n+use clap::Subcommand;\n+use indexmap::IndexSet;\n+use jj_lib::commit::Commit;\n+use jj_lib::repo::Repo;\n+\n+use crate::cli_util::{\n+    get_git_repo, resolve_multiple_nonempty_revsets, user_error, CommandError, CommandHelper,\n+    RevisionArg,\n+};\n+use crate::ui::Ui;\n+\n+/// Interact with Gerrit Code Review.\n+#[derive(Subcommand, Clone, Debug)]\n+pub enum GerritCommand {\n+    /// \"Mail in\" a revision to Gerrit; this is the primary way to create\n+    /// changes or update changes for code review.\n+    ///\n+    /// This command modifies each commit in the revset to include a `Change-Id`\n+    /// footer in its commit message if one does not already exist. This ID is\n+    /// NOT compatible with jj IDs, and is a Gerrit-specific ID.\n+    ///\n+    /// Note: this command takes a revset as an argument, and will mail in all\n+    /// revisions in the revset to Gerrit appropriately, so you may post trees\n+    /// or ranges of commits to Gerrit for review.\n+    ///\n+    /// Note: this command does not actually send an email or use a Mail\n+    /// Transfer Agent, but rather uploads the revision to Gerrit for review\n+    /// through underlying Git logic. The term \"mail\" is used to disambiguate\n+    /// from the word \"submit\", which is what Gerrit calls \"merging an approved\n+    /// change into a target branch\", and is used to refer to the concept of\n+    /// \"mailing in\" something to be read by someone else.\n+    Mail(MailCommand),\n+}\n+\n+pub fn cmd_gerrit(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    subcommand: &GerritCommand,\n+) -> Result<(), CommandError> {\n+    match subcommand {\n+        GerritCommand::Mail(review) => {\n+            cmd_mail(ui, command, review)?;\n+        }\n+    }\n+    Ok(())",
        "comment_created_at": "2024-01-20T07:34:00+00:00",
        "comment_author": "martinvonz",
        "comment_body": "nit: drop this and return the result from `cmd_mail()` directly (drop the `?;`). That's what we do elsewhere.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2329046719",
    "pr_number": 7435,
    "pr_file": "lib/src/fileset.rs",
    "created_at": "2025-09-08T03:20:17+00:00",
    "commented_code": "Self::file_glob_at(dir, pattern, true)\n     }\n \n+    /// Pattern that matches files with the given extension recursively from\n+    /// cwd.\n+    pub fn cwd_extension_glob(\n+        path_converter: &RepoPathUiConverter,\n+        extension: impl AsRef<str>,\n+    ) -> Result<Self, FilePatternParseError> {\n+        let ext_glob = Self::format_extension_glob(extension)?;\n+        Self::cwd_file_glob(path_converter, ext_glob)",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2329046719",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "lib/src/fileset.rs",
        "discussion_id": "2329046719",
        "commented_code": "@@ -159,6 +161,47 @@ impl FilePattern {\n         Self::file_glob_at(dir, pattern, true)\n     }\n \n+    /// Pattern that matches files with the given extension recursively from\n+    /// cwd.\n+    pub fn cwd_extension_glob(\n+        path_converter: &RepoPathUiConverter,\n+        extension: impl AsRef<str>,\n+    ) -> Result<Self, FilePatternParseError> {\n+        let ext_glob = Self::format_extension_glob(extension)?;\n+        Self::cwd_file_glob(path_converter, ext_glob)",
        "comment_created_at": "2025-09-08T03:20:17+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: it's probably better to construct `FileGlob { .. }` without using `cwd_file_glob()`, etc. It doesn't make sense to split machine-generated glob pattern and parse it as a user expression. There should be no syntax error to report.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2311752138",
    "pr_number": 6899,
    "pr_file": "cli/src/template_parser.rs",
    "created_at": "2025-08-30T02:53:19+00:00",
    "commented_code": "})\n }\n \n+/// Unwraps inner value if the given `node` is a string pattern\n+///\n+/// This forces it to be static so that it need not be part of the type system.\n+pub fn expect_string_pattern(node: &'_ ExpressionNode<'_>) -> TemplateParseResult<StringPattern> {",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2311752138",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 6899,
        "pr_file": "cli/src/template_parser.rs",
        "discussion_id": "2311752138",
        "commented_code": "@@ -663,6 +695,23 @@ pub fn expect_string_literal<'a>(node: &'a ExpressionNode<'_>) -> TemplateParseR\n     })\n }\n \n+/// Unwraps inner value if the given `node` is a string pattern\n+///\n+/// This forces it to be static so that it need not be part of the type system.\n+pub fn expect_string_pattern(node: &'_ ExpressionNode<'_>) -> TemplateParseResult<StringPattern> {",
        "comment_created_at": "2025-08-30T02:53:19+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: `&ExpressionNode<'_>` (remove redundant `&'_`)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2289685566",
    "pr_number": 7316,
    "pr_file": "lib/src/fileset.rs",
    "created_at": "2025-08-21T02:04:32+00:00",
    "commented_code": ".take_while(|component| {\n             !component\n                 .trim_end_matches(path::is_separator)",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2289685566",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7316,
        "pr_file": "lib/src/fileset.rs",
        "discussion_id": "2289685566",
        "commented_code": "@@ -257,8 +252,7 @@ fn split_glob_path_i(input: &str) -> (&str, &str) {\n         .take_while(|component| {\n             !component\n                 .trim_end_matches(path::is_separator)",
        "comment_created_at": "2025-08-21T02:04:32+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: you can remove `.trim_end_matches()`. It's not important to strip off path separators.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1925980883",
    "pr_number": 5423,
    "pr_file": "cli/src/commands/bookmark/mod.rs",
    "created_at": "2025-01-22T21:18:17+00:00",
    "commented_code": "true\n     }\n }\n+\n+fn validate_bookmark_names(\n+    command: &CommandHelper,\n+    ui: &mut Ui,\n+    bookmark_names: &[String],\n+    command_name: &str,\n+) -> Result<(), CommandError> {\n+    let helper = command.workspace_helper_no_snapshot(ui)?;\n+\n+    let mut remote_like = Vec::new();\n+    let mut revset_like = Vec::new();\n+\n+    for name in bookmark_names {\n+        match BookMarkKind::parse(name, &helper)? {\n+            BookMarkKind::RemoteLike => remote_like.push(name.as_str()),\n+            BookMarkKind::RevsetLike => revset_like.push(name.as_str()),\n+            BookMarkKind::Normal => {}\n+        }\n+    }\n+\n+    if !remote_like.is_empty() {\n+        let mut writer = ui.warning_with_heading(\"Bookmarks containing '@':\");\n+        for name in &remote_like {\n+            writeln!(writer, \"  {name}\")?;\n+        }\n+        drop(writer);\n+\n+        let mut hint = ui.hint_default();",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "1925980883",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 5423,
        "pr_file": "cli/src/commands/bookmark/mod.rs",
        "discussion_id": "1925980883",
        "commented_code": "@@ -201,3 +203,92 @@ fn is_fast_forward(repo: &dyn Repo, old_target: &RefTarget, new_target_id: &Comm\n         true\n     }\n }\n+\n+fn validate_bookmark_names(\n+    command: &CommandHelper,\n+    ui: &mut Ui,\n+    bookmark_names: &[String],\n+    command_name: &str,\n+) -> Result<(), CommandError> {\n+    let helper = command.workspace_helper_no_snapshot(ui)?;\n+\n+    let mut remote_like = Vec::new();\n+    let mut revset_like = Vec::new();\n+\n+    for name in bookmark_names {\n+        match BookMarkKind::parse(name, &helper)? {\n+            BookMarkKind::RemoteLike => remote_like.push(name.as_str()),\n+            BookMarkKind::RevsetLike => revset_like.push(name.as_str()),\n+            BookMarkKind::Normal => {}\n+        }\n+    }\n+\n+    if !remote_like.is_empty() {\n+        let mut writer = ui.warning_with_heading(\"Bookmarks containing '@':\");\n+        for name in &remote_like {\n+            writeln!(writer, \"  {name}\")?;\n+        }\n+        drop(writer);\n+\n+        let mut hint = ui.hint_default();",
        "comment_created_at": "2025-01-22T21:18:17+00:00",
        "comment_author": "martinvonz",
        "comment_body": "nit: we usually inline these where they're used, so just call `ui.hint_default()` on line 235 etc",
        "pr_file_module": null
      },
      {
        "comment_id": "1929792615",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 5423,
        "pr_file": "cli/src/commands/bookmark/mod.rs",
        "discussion_id": "1925980883",
        "commented_code": "@@ -201,3 +203,92 @@ fn is_fast_forward(repo: &dyn Repo, old_target: &RefTarget, new_target_id: &Comm\n         true\n     }\n }\n+\n+fn validate_bookmark_names(\n+    command: &CommandHelper,\n+    ui: &mut Ui,\n+    bookmark_names: &[String],\n+    command_name: &str,\n+) -> Result<(), CommandError> {\n+    let helper = command.workspace_helper_no_snapshot(ui)?;\n+\n+    let mut remote_like = Vec::new();\n+    let mut revset_like = Vec::new();\n+\n+    for name in bookmark_names {\n+        match BookMarkKind::parse(name, &helper)? {\n+            BookMarkKind::RemoteLike => remote_like.push(name.as_str()),\n+            BookMarkKind::RevsetLike => revset_like.push(name.as_str()),\n+            BookMarkKind::Normal => {}\n+        }\n+    }\n+\n+    if !remote_like.is_empty() {\n+        let mut writer = ui.warning_with_heading(\"Bookmarks containing '@':\");\n+        for name in &remote_like {\n+            writeln!(writer, \"  {name}\")?;\n+        }\n+        drop(writer);\n+\n+        let mut hint = ui.hint_default();",
        "comment_created_at": "2025-01-26T14:48:20+00:00",
        "comment_author": "0xdeafbeef",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280383897",
    "pr_number": 7262,
    "pr_file": "cli/src/template_builder.rs",
    "created_at": "2025-08-16T11:14:15+00:00",
    "commented_code": "Ok(L::Property::wrap_list_template(template))\n         },\n     );\n+    map.insert(\n+        \"any\",\n+        |language, diagnostics, build_ctx, self_property, function| {\n+            let out_property: BoxedTemplateProperty<'a, bool> =",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2280383897",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7262,
        "pr_file": "cli/src/template_builder.rs",
        "discussion_id": "2280383897",
        "commented_code": "@@ -1430,6 +1430,22 @@ where\n             Ok(L::Property::wrap_list_template(template))\n         },\n     );\n+    map.insert(\n+        \"any\",\n+        |language, diagnostics, build_ctx, self_property, function| {\n+            let out_property: BoxedTemplateProperty<'a, bool> =",
        "comment_created_at": "2025-08-16T11:14:15+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: type annotation can be omitted because it's constrained by the function.",
        "pr_file_module": null
      }
    ]
  }
]