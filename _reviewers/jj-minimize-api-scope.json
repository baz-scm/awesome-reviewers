[
  {
    "discussion_id": "2255749862",
    "pr_number": 7164,
    "pr_file": "docs/design/gitattributes.md",
    "created_at": "2025-08-06T03:03:04+00:00",
    "commented_code": "+# Git attributes",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2255749862",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T03:03:04+00:00",
        "comment_author": "martinvonz",
        "comment_body": "I've only skimmed the document but what I'm missing is an overview of how we're going to support gitattributes. Specifically, will it only affect the working copy just like EOL conversion does (I think that's my preference)? I.e., I hope all the code can be in `local_working_copy.rs` (helper elsewhere is fine as long as they're only used from `local_working_copy.rs`). I may very well have missed reasons that that's not possible. If it's not possible to do it in the working copy backend, then where in the architecture will we insert the understanding of gitattributes?",
        "pr_file_module": null
      },
      {
        "comment_id": "2255858731",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T04:53:00+00:00",
        "comment_author": "06393993",
        "comment_body": "> will it only affect the working copy just like EOL conversion does (I think that's my preference)?\n\nFor the only 3 features I know that we want:\n\n* EOL conversion and smudge/clean filter will only interact with the `local_working_copy` module\n* The diff feature needs modification outside the `local_working_copy`. The changes should happen in the `diff_util` module in the `jj-cli` crate for built-in diff tools, and in the `merge_tools::diff_working_copies` crate for external diff tools. The reason for the impossibility is obvious.\n\nThere are other git attributes features that may introduce modification outside `local_working_copy.rs`, e.g., [`merge`](https://git-scm.com/docs/gitattributes#_merge), but we don't consider them in the current design.\n\nI have already added that information to the \"Context and Scope\" section. Thanks for review.",
        "pr_file_module": null
      },
      {
        "comment_id": "2255881360",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T05:13:38+00:00",
        "comment_author": "martinvonz",
        "comment_body": "I read the \"Context and Scope\" section but I don't see how it's explained there.\r\n\r\n> * The diff feature needs modification outside the `local_working_copy`.\r\n\r\nI was hoping that we would simply not support that. It seems too specific to Git for my taste. Or are you suggesting that we support gitattributes when using non-Git backends too? Also when running on a server? How will we find the smudge/clean tools? I guess you explain that somewhere. Sorry, I've only skimmed the doc so far.",
        "pr_file_module": null
      },
      {
        "comment_id": "2255897760",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T05:27:19+00:00",
        "comment_author": "06393993",
        "comment_body": "No they are not included in the docs.\r\n\r\nThe diff features are all about the built-in diff tool and the external diff tool. I am Ok that we don't support it. ilyagr@ suggests that \"For a minor example, jj diff could respect the linguist-generated attribute (or a differently named attribute) and not show generated files by default, like GitHub.\" so I include it.\r\n\r\n> are you suggesting that we support gitattributes when using non-Git backends too?\r\n\r\nI am Ok with supporting gitattributes only for git backends, but on the code side, it should probably not behind the git Cargo feature flag, which may complicate the code. But I am also Ok with it.\r\n\r\n> Also when running on a server?\r\n\r\nI am not sure how diff is relevant to a server. Am I missing anything?\r\n\r\n> How will we find the smudge/clean tools?\r\n\r\nSame as git, defined in the user settings. If you don't define the filter, files should be checked out and checked in as is(Haven't checked the git behavior, but I assume so).",
        "pr_file_module": null
      },
      {
        "comment_id": "2255931701",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T05:52:06+00:00",
        "comment_author": "martinvonz",
        "comment_body": "Oh, I see, the conversion would be done just before displaying to the user. That at least reduces the scope. I'm still quite worried about the scope of this feature. I'm worried i will impact code in lots of different places. Hopefully I'm wrong.\r\n\r\n> I am not sure how diff is relevant to a server. Am I missing anything?\r\n\r\nNo. As long as we don't care about it when merging, I think it won't affect diffing code. I think we will just decide that we don't handle all cases exactly correctly. Git doesn't either, AFAIK.",
        "pr_file_module": null
      },
      {
        "comment_id": "2255939625",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2255749862",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes",
        "comment_created_at": "2025-08-06T05:56:49+00:00",
        "comment_author": "06393993",
        "comment_body": "> I'm worried i will impact code in lots of different places.\r\n\r\nNo, it won't. At least this design doesn't include such changes and doesn't suggest we need such changes for future features. If there is such impact, it will be in a different design and you will be notified then.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2261151413",
    "pr_number": 7164,
    "pr_file": "docs/design/gitattributes.md",
    "created_at": "2025-08-07T18:44:18+00:00",
    "commented_code": "+# Git attributes\n+\n+**Authors**: [Kaiyi Li](mailto:kaiyili@google.com)\n+\n+**Summary**: This design introduces an API internal to `jj-lib` that future git attributes related features could use to query the git attributes information associated with a file.\n+\n+## Context and Scope\n+\n+We are interested in many git attributes related features:\n+\n+* Perform EOL conversion differently for different files: the [`text`](https://git-scm.com/docs/gitattributes#_text) and the [`eol`](https://git-scm.com/docs/gitattributes#_eol) git attributes.\n+* Control the behavior of `jj diff` on binary files or generated files: the [`diff`](https://git-scm.com/docs/gitattributes#_generating_diff_text) and the [`linguist-generated`](https://docs.github.com/en/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github) git attributes.\n+* Smudge and clean [filter](https://git-scm.com/docs/gitattributes#_filter), which paves a straight forward path for [`git-lfs` support](https://github.com/git-lfs/git-lfs/blob/main/docs/spec.md#intercepting-git), and [`git-crypt` support](https://github.com/AGWA/git-crypt?tab=readme-ov-file#using-git-crypt).\n+\n+This design provides the cornerstone of all the previously mentioned features.\n+\n+In this design, we use the same terminology as the [git attributes document](https://git-scm.com/docs/gitattributes#_description). Some regularly used definitions include pattern, state, and `gitattributes` file.\n+\n+### Goals/Requirements\n+\n+* Describe a general API to query the git attributes associated with a path and the initial implementation of this API.\n+* The caller of the API shouldn't have to deal with the following complicated details. The implementation of the API should handle them.\n+    * How to parse the `gitattributes` file.\n+    * Which ancestor folders contain the relevant `gitattributes` file.\n+    * How the `gitattributes` file should be loaded from the `Store` or from the file system.\n+    * When query the attributes associated with a file, how to look up `gitattributes` in all ancestor folders.\n+    * [Macro](`https://git-scm.com/docs/gitattributes#_using_macro_attributes`) resolution.\n+* The query interface should be thread-safe, because `TreeState::snapshot` currently snapshots files in multiple threads concurrently.\n+* The design should make it easy to optimize the performance of the query interface without having to change the caller code too much, and the initial implementation should be reasonably fast, because any feature that makes use of `gitattributes` is likely to query the git attributes of all the changed files whenever `jj` snapshots files from the file system to the `Store` or updates files from the `Store` to the file system.\n+* When `gitattributes` is not used, the design should introduce negligible runtime and memory overhead, if not 0, i.e. if none of git attributes related features is enabled through the user settings.\n+* Include git built-in `gitattribute` macros. Currently there is only [`binary`](https://github.com/git/git/blob/master/attr.c#L639).\n+\n+### Non-Goals\n+\n+* This design doesn't handle the git attributes defined in places other than `gitattributes` files in the repo. This will be deferred to another design which should introduce a separate setting to read those files just like [this issue](https://github.com/jj-vcs/jj/issues/4048). This means that this design won't consider the following git attribute files:\n+    * `$GIT_DIR/info/attributes`\n+    * The file specified by the `core.attributesFile` configuration option.\n+    * `$XDG_CONFIG_HOME/git/attributes`\n+    * `$HOME/.config/git/attributes`\n+    * `$(prefix)/etc/gitattributes`\n+* This design doesn't include the details on how other specific git attributes related features should be implemented. However, how other features could query the git attributes will be discussed to justify some design decisions.\n+\n+## Design\n+\n+We introduce the following major public types:\n+\n+* `GitAttributes`: a singleton shared by all components that need to query the [the state](https://git-scm.com/docs/gitattributes#_description) of given attributes. The query capability is exposed through a single `GitAttributes::search` method.\n+* `FileLoader` a trait that encapsulate the implementation details on how to read `gitattributes` files given paths from the `Store` or the disk. `TreeFileLoader` and `DiskFileLoader` are 2 implementations.\n+* `GitAttributesError` is the general error type.\n+\n+And the following private types:\n+\n+* `GitAttributesNode` is the cache entry for `gitattributes` files associated to a folder.\n+\n+We make the following design decision with the following reasons:\n+\n+* We only read and parse `gitattributes` files when the `gitattributes` of relevant files are queried, because we want to introduce as little overhead as possible if `gitattributes` related features are not enabled.\n+* We share a single `GitAttributes` objects across as many components as possible which is different from the existing `GitIgnoreFile` design, because\n+    * It saves the caller's effort from calling `chain_with_file` and visiting the potential folders on its own. While this is less of an issue for `TreeState::snapshot`, callers like `TreeState::update`(need `gitattributes` to apply the smudge filter) or `DiffRenderer` may currently only have access to a diff stream, which requires extra code to create and maintain the `gitattributes` file tree graph.\n+    * It allows us to introduce a global cache of `gitattributes` files from the caller, so that we don't have to read the same `gitattributes` file twice.\n+    * `GitIgnoreFile` is designed differently to ask the caller to build and maintain the `GitIgnoreFile` tree via the `chain_with_file` interface, and parse the `gitignore` files eagerly, because it helps us to skip entire directories when traversing the file system. `gitattributes` files are different: we don't use them to skip directories, so we don't bother leave the trouble for the callers.\n+* `GitAttributes` should be `Sync` and `Send`. `GitAttributes::search` should be able to be called on different threads concurrently, because when snapshotting, we are [handling different file entries concurrently](https://github.com/jj-vcs/jj/blob/525e795889d3e631069da848a82748fc2d379bc9/lib/src/local_working_copy.rs#L1262-L1269). For example, for EOL conversion, we need to query the `text` and `eol` `gitattributes` concurrently.\n+* We introduce the `FileLoader` trait to handle the task to read the `gitattributes` files instead of just inlining the implementation in `GitAttributes`, because\n+    * It allows us to mock the behavior of the file system and `Store` when testing `GitAttributes`.\n+    * Reading `gitattributes` files itself is complicated, because it needs to handle many corner cases including the file doesn't exist or the path isn't a file; we should not follow symbolic links; the `gitattributes` file has conflicts. It would improve the readability if we move the implementation details in a separate type.\n+\n+```mermaid\n+classDiagram\n+    class GitAttributes {\n+        -node_cache: Mutex~Cache~\n+        +new(tree_file_loader: FileLoader, disk_file_loader: FileLoader) GitAttributes$\n+        +search(path, attribute_names, priority) Result\n+        -get_git_attributes_node(path) GitAttributesNode\n+    }\n+\n+    class GitAttributesNode {\n+        -disk_first: OnceCell~CacheEntry~\n+        -store_first: OnceCell~CacheEntry~\n+        -disk_file_loader: Arc~FileLoader~\n+        -store_file_loader: Arc~FileLoader~\n+        -parent: Option~Arc~GitAttributesNode~~\n+        -path: RepoPathBuf\n+        -get_disk_first() Result\n+        -get_store_first() Result\n+    }\n+\n+    class FileLoader {\n+        <<interface>>\n+        +load(path) Result\n+    }\n+\n+    class TreeFileLoader {\n+        -tree: MergedTree\n+        +new(tree: MergedTree) TreeFileLoader$\n+    }\n+\n+    class DiskFileLoader {\n+        -repo_root: PathBuf\n+        +new(repo_root: PathBuf) DiskFileLoader$\n+    }\n+\n+    class SearchPriority {\n+        <<enumeration>>\n+        Store\n+        Disk\n+    }\n+\n+    class GitAttributesError {\n+        -message: String\n+        -source: Box~Error~\n+    }\n+\n+    GitAttributes \"1\" *-- \"1..*\" GitAttributesNode\n+    GitAttributesNode \"1\" o-- \"0..1\" GitAttributesNode : parent\n+    GitAttributes \"1\" o-- \"2\" FileLoader\n+    TreeFileLoader ..|> FileLoader\n+    DiskFileLoader ..|> FileLoader\n+    GitAttributes ..> SearchPriority\n+    GitAttributes ..> GitAttributesError\n+    GitAttributesNode ..> GitAttributesError\n+    FileLoader ..> GitAttributesError\n+\n+```\n+\n+Under the hood, `GitAttributes` uses [`gix_attributes::Search`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html) to query the attribute. And `GitAttributes` holds a memoization cache of the `gix_attributes::Search` and the [`gix_attributes::search::MetadataCollection`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/search/struct.MetadataCollection.html) for every directory. `MetadataCollection` stores the macro definition and attributes, and the `gix_attributes::Search` type allows the client to chain `gitattributes` files, query the attribute based on the chained files, and resolve the macro definition defined by the given `MetadataCollection`. It is allowed to introduce new git attributes arbitrarily in any `gitattributes` files, so different directories can have different `MetadataCollection`s. When `GitAttributes::search` is called, we try to obtain the `Search` object and the `MetadataCollection` associated to the parent directory of the requested path from the memoization cache, e.g., if the request path is `src/lib.rs`, we find the `Search` object and the `MetadataCollection` object associated to the `src` directory, and use the [`Search::pattern_matching_relative_path`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html#method.pattern_matching_relative_path) method to query the result. `GitAttributes::search` will return an `HashMap<String, gix_attributes::State>` which maps the attribute name to its state. Note that the `GitAttributes::search` method supports querying multiple attributes at the same time, which could save the caller redundant pattern comparisons compared to querying the attributes one by one. If we don't have the path(e.g., `x/y/z`) in our memoization cache, we try to obtain the associated `Search` and `MetadataCollection` objects of the parent path(e.g., `x/y`), and create the `Search` and `MetadataCollection` objects of the current path(e.g., `x/y/z`) by reading the `gitattributes` file, and calling [`Search::add_patterns_buffer`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html#method.add_patterns_buffer). Afterwards, we populate this result to the memoization cache. If the parent entry is also missing, we recursively apply the same approach to populate that entry until we hit the root path. In this way, if we call `GitAttributes::search` multiple times with paths under the same directory, we only read the `gitattributes` files once.\n+\n+This is just a simplistic picture of the `GitAttributes::search` implementation, we will cover the following aspects in details:\n+\n+* Allow the `GitAttributes::search` to specify whether the `gitattributes` file in `Store` should take priority or the one on the disk.\n+* `GitAttributes::search` should be a thread-safe interface, which means `GitAttributes::search` shouldn't take `&mut self`, and `GitAttributes` should be `Sync`. However, `GitAttributes::search` could mutate the memoization cache. How should the lock be designed?\n+* How to handle merge conflicts in `gitattributes` files?\n+* Integration with future features, like EOL conversion and filter(smudge and clean).\n+* Tests.\n+\n+### `GitAttributesError`\n+\n+`GitAttributes` can encounter different errors: `std::io::Error` when reading from `AsyncRead`, `BackendError` when calling the `Store::read_file` function, and `InvalidRepoPathError` when casting `RepoPath` to `PathBuf`, so we need to come up our own error type. We don't consider to allow the caller of `GitAttributes` to distinguish between different errors, so we choose the same definition as `WorkingCopyStateError`.\n+\n+```rust\n+#[derive(Debug, thiserror::Error)]\n+#[error(\"{message}\")]\n+pub(crate) struct GitAttributesError {\n+    message: String,\n+    #[source]\n+    source: Box<dyn std::error::Error + Send + Sync>,\n+}\n+```\n+\n+In the following document, the error type of `Result` is always `GitAttributesError` unless otherwise mentioned.\n+\n+### The `GitAttributes::search` API from the caller side\n+\n+This interface provides the key entry to query the attribute state associated to a path.\n+\n+4 states of a git attributes are defined in the [git document](https://git-scm.com/docs/gitattributes#_description):\n+\n+* [Set](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Set)\n+* [Unset](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Unset)\n+* [Set to a value](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Settoavalue)\n+* [Unspecified](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Unspecified)\n+\n+Detailed definition can be found in the git document, but there is one thing worth noting for the Unspecified state. `.gitattribute` files can use the `!` prefix to set an attribute to the Unspecified state:\n+\n+> Sometimes you would need to override a setting of an attribute for a path to `Unspecified` state. This can be done by listing the name of the attribute prefixed with an exclamation point `!`.\n+\n+We will make use of the [`gix_attributes::State`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/enum.State.html) type to model the state in our implementation.\n+\n+The actual signature of the `GitAttributes::search` method is:\n+\n+```rust\n+pub fn search(\n+    &self,\n+    path: &RepoPath,\n+    attribute_names: impl AsRef<[&str]>,\n+    priority: SearchPriority,\n+) -> Result<HashMap<String, gix_attributes::State>>\n+```",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2261151413",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7164,
        "pr_file": "docs/design/gitattributes.md",
        "discussion_id": "2261151413",
        "commented_code": "@@ -0,0 +1,590 @@\n+# Git attributes\n+\n+**Authors**: [Kaiyi Li](mailto:kaiyili@google.com)\n+\n+**Summary**: This design introduces an API internal to `jj-lib` that future git attributes related features could use to query the git attributes information associated with a file.\n+\n+## Context and Scope\n+\n+We are interested in many git attributes related features:\n+\n+* Perform EOL conversion differently for different files: the [`text`](https://git-scm.com/docs/gitattributes#_text) and the [`eol`](https://git-scm.com/docs/gitattributes#_eol) git attributes.\n+* Control the behavior of `jj diff` on binary files or generated files: the [`diff`](https://git-scm.com/docs/gitattributes#_generating_diff_text) and the [`linguist-generated`](https://docs.github.com/en/repositories/working-with-files/managing-files/customizing-how-changed-files-appear-on-github) git attributes.\n+* Smudge and clean [filter](https://git-scm.com/docs/gitattributes#_filter), which paves a straight forward path for [`git-lfs` support](https://github.com/git-lfs/git-lfs/blob/main/docs/spec.md#intercepting-git), and [`git-crypt` support](https://github.com/AGWA/git-crypt?tab=readme-ov-file#using-git-crypt).\n+\n+This design provides the cornerstone of all the previously mentioned features.\n+\n+In this design, we use the same terminology as the [git attributes document](https://git-scm.com/docs/gitattributes#_description). Some regularly used definitions include pattern, state, and `gitattributes` file.\n+\n+### Goals/Requirements\n+\n+* Describe a general API to query the git attributes associated with a path and the initial implementation of this API.\n+* The caller of the API shouldn't have to deal with the following complicated details. The implementation of the API should handle them.\n+    * How to parse the `gitattributes` file.\n+    * Which ancestor folders contain the relevant `gitattributes` file.\n+    * How the `gitattributes` file should be loaded from the `Store` or from the file system.\n+    * When query the attributes associated with a file, how to look up `gitattributes` in all ancestor folders.\n+    * [Macro](`https://git-scm.com/docs/gitattributes#_using_macro_attributes`) resolution.\n+* The query interface should be thread-safe, because `TreeState::snapshot` currently snapshots files in multiple threads concurrently.\n+* The design should make it easy to optimize the performance of the query interface without having to change the caller code too much, and the initial implementation should be reasonably fast, because any feature that makes use of `gitattributes` is likely to query the git attributes of all the changed files whenever `jj` snapshots files from the file system to the `Store` or updates files from the `Store` to the file system.\n+* When `gitattributes` is not used, the design should introduce negligible runtime and memory overhead, if not 0, i.e. if none of git attributes related features is enabled through the user settings.\n+* Include git built-in `gitattribute` macros. Currently there is only [`binary`](https://github.com/git/git/blob/master/attr.c#L639).\n+\n+### Non-Goals\n+\n+* This design doesn't handle the git attributes defined in places other than `gitattributes` files in the repo. This will be deferred to another design which should introduce a separate setting to read those files just like [this issue](https://github.com/jj-vcs/jj/issues/4048). This means that this design won't consider the following git attribute files:\n+    * `$GIT_DIR/info/attributes`\n+    * The file specified by the `core.attributesFile` configuration option.\n+    * `$XDG_CONFIG_HOME/git/attributes`\n+    * `$HOME/.config/git/attributes`\n+    * `$(prefix)/etc/gitattributes`\n+* This design doesn't include the details on how other specific git attributes related features should be implemented. However, how other features could query the git attributes will be discussed to justify some design decisions.\n+\n+## Design\n+\n+We introduce the following major public types:\n+\n+* `GitAttributes`: a singleton shared by all components that need to query the [the state](https://git-scm.com/docs/gitattributes#_description) of given attributes. The query capability is exposed through a single `GitAttributes::search` method.\n+* `FileLoader` a trait that encapsulate the implementation details on how to read `gitattributes` files given paths from the `Store` or the disk. `TreeFileLoader` and `DiskFileLoader` are 2 implementations.\n+* `GitAttributesError` is the general error type.\n+\n+And the following private types:\n+\n+* `GitAttributesNode` is the cache entry for `gitattributes` files associated to a folder.\n+\n+We make the following design decision with the following reasons:\n+\n+* We only read and parse `gitattributes` files when the `gitattributes` of relevant files are queried, because we want to introduce as little overhead as possible if `gitattributes` related features are not enabled.\n+* We share a single `GitAttributes` objects across as many components as possible which is different from the existing `GitIgnoreFile` design, because\n+    * It saves the caller's effort from calling `chain_with_file` and visiting the potential folders on its own. While this is less of an issue for `TreeState::snapshot`, callers like `TreeState::update`(need `gitattributes` to apply the smudge filter) or `DiffRenderer` may currently only have access to a diff stream, which requires extra code to create and maintain the `gitattributes` file tree graph.\n+    * It allows us to introduce a global cache of `gitattributes` files from the caller, so that we don't have to read the same `gitattributes` file twice.\n+    * `GitIgnoreFile` is designed differently to ask the caller to build and maintain the `GitIgnoreFile` tree via the `chain_with_file` interface, and parse the `gitignore` files eagerly, because it helps us to skip entire directories when traversing the file system. `gitattributes` files are different: we don't use them to skip directories, so we don't bother leave the trouble for the callers.\n+* `GitAttributes` should be `Sync` and `Send`. `GitAttributes::search` should be able to be called on different threads concurrently, because when snapshotting, we are [handling different file entries concurrently](https://github.com/jj-vcs/jj/blob/525e795889d3e631069da848a82748fc2d379bc9/lib/src/local_working_copy.rs#L1262-L1269). For example, for EOL conversion, we need to query the `text` and `eol` `gitattributes` concurrently.\n+* We introduce the `FileLoader` trait to handle the task to read the `gitattributes` files instead of just inlining the implementation in `GitAttributes`, because\n+    * It allows us to mock the behavior of the file system and `Store` when testing `GitAttributes`.\n+    * Reading `gitattributes` files itself is complicated, because it needs to handle many corner cases including the file doesn't exist or the path isn't a file; we should not follow symbolic links; the `gitattributes` file has conflicts. It would improve the readability if we move the implementation details in a separate type.\n+\n+```mermaid\n+classDiagram\n+    class GitAttributes {\n+        -node_cache: Mutex~Cache~\n+        +new(tree_file_loader: FileLoader, disk_file_loader: FileLoader) GitAttributes$\n+        +search(path, attribute_names, priority) Result\n+        -get_git_attributes_node(path) GitAttributesNode\n+    }\n+\n+    class GitAttributesNode {\n+        -disk_first: OnceCell~CacheEntry~\n+        -store_first: OnceCell~CacheEntry~\n+        -disk_file_loader: Arc~FileLoader~\n+        -store_file_loader: Arc~FileLoader~\n+        -parent: Option~Arc~GitAttributesNode~~\n+        -path: RepoPathBuf\n+        -get_disk_first() Result\n+        -get_store_first() Result\n+    }\n+\n+    class FileLoader {\n+        <<interface>>\n+        +load(path) Result\n+    }\n+\n+    class TreeFileLoader {\n+        -tree: MergedTree\n+        +new(tree: MergedTree) TreeFileLoader$\n+    }\n+\n+    class DiskFileLoader {\n+        -repo_root: PathBuf\n+        +new(repo_root: PathBuf) DiskFileLoader$\n+    }\n+\n+    class SearchPriority {\n+        <<enumeration>>\n+        Store\n+        Disk\n+    }\n+\n+    class GitAttributesError {\n+        -message: String\n+        -source: Box~Error~\n+    }\n+\n+    GitAttributes \"1\" *-- \"1..*\" GitAttributesNode\n+    GitAttributesNode \"1\" o-- \"0..1\" GitAttributesNode : parent\n+    GitAttributes \"1\" o-- \"2\" FileLoader\n+    TreeFileLoader ..|> FileLoader\n+    DiskFileLoader ..|> FileLoader\n+    GitAttributes ..> SearchPriority\n+    GitAttributes ..> GitAttributesError\n+    GitAttributesNode ..> GitAttributesError\n+    FileLoader ..> GitAttributesError\n+\n+```\n+\n+Under the hood, `GitAttributes` uses [`gix_attributes::Search`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html) to query the attribute. And `GitAttributes` holds a memoization cache of the `gix_attributes::Search` and the [`gix_attributes::search::MetadataCollection`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/search/struct.MetadataCollection.html) for every directory. `MetadataCollection` stores the macro definition and attributes, and the `gix_attributes::Search` type allows the client to chain `gitattributes` files, query the attribute based on the chained files, and resolve the macro definition defined by the given `MetadataCollection`. It is allowed to introduce new git attributes arbitrarily in any `gitattributes` files, so different directories can have different `MetadataCollection`s. When `GitAttributes::search` is called, we try to obtain the `Search` object and the `MetadataCollection` associated to the parent directory of the requested path from the memoization cache, e.g., if the request path is `src/lib.rs`, we find the `Search` object and the `MetadataCollection` object associated to the `src` directory, and use the [`Search::pattern_matching_relative_path`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html#method.pattern_matching_relative_path) method to query the result. `GitAttributes::search` will return an `HashMap<String, gix_attributes::State>` which maps the attribute name to its state. Note that the `GitAttributes::search` method supports querying multiple attributes at the same time, which could save the caller redundant pattern comparisons compared to querying the attributes one by one. If we don't have the path(e.g., `x/y/z`) in our memoization cache, we try to obtain the associated `Search` and `MetadataCollection` objects of the parent path(e.g., `x/y`), and create the `Search` and `MetadataCollection` objects of the current path(e.g., `x/y/z`) by reading the `gitattributes` file, and calling [`Search::add_patterns_buffer`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/struct.Search.html#method.add_patterns_buffer). Afterwards, we populate this result to the memoization cache. If the parent entry is also missing, we recursively apply the same approach to populate that entry until we hit the root path. In this way, if we call `GitAttributes::search` multiple times with paths under the same directory, we only read the `gitattributes` files once.\n+\n+This is just a simplistic picture of the `GitAttributes::search` implementation, we will cover the following aspects in details:\n+\n+* Allow the `GitAttributes::search` to specify whether the `gitattributes` file in `Store` should take priority or the one on the disk.\n+* `GitAttributes::search` should be a thread-safe interface, which means `GitAttributes::search` shouldn't take `&mut self`, and `GitAttributes` should be `Sync`. However, `GitAttributes::search` could mutate the memoization cache. How should the lock be designed?\n+* How to handle merge conflicts in `gitattributes` files?\n+* Integration with future features, like EOL conversion and filter(smudge and clean).\n+* Tests.\n+\n+### `GitAttributesError`\n+\n+`GitAttributes` can encounter different errors: `std::io::Error` when reading from `AsyncRead`, `BackendError` when calling the `Store::read_file` function, and `InvalidRepoPathError` when casting `RepoPath` to `PathBuf`, so we need to come up our own error type. We don't consider to allow the caller of `GitAttributes` to distinguish between different errors, so we choose the same definition as `WorkingCopyStateError`.\n+\n+```rust\n+#[derive(Debug, thiserror::Error)]\n+#[error(\"{message}\")]\n+pub(crate) struct GitAttributesError {\n+    message: String,\n+    #[source]\n+    source: Box<dyn std::error::Error + Send + Sync>,\n+}\n+```\n+\n+In the following document, the error type of `Result` is always `GitAttributesError` unless otherwise mentioned.\n+\n+### The `GitAttributes::search` API from the caller side\n+\n+This interface provides the key entry to query the attribute state associated to a path.\n+\n+4 states of a git attributes are defined in the [git document](https://git-scm.com/docs/gitattributes#_description):\n+\n+* [Set](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Set)\n+* [Unset](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Unset)\n+* [Set to a value](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Settoavalue)\n+* [Unspecified](https://git-scm.com/docs/gitattributes#Documentation/gitattributes.txt-Unspecified)\n+\n+Detailed definition can be found in the git document, but there is one thing worth noting for the Unspecified state. `.gitattribute` files can use the `!` prefix to set an attribute to the Unspecified state:\n+\n+> Sometimes you would need to override a setting of an attribute for a path to `Unspecified` state. This can be done by listing the name of the attribute prefixed with an exclamation point `!`.\n+\n+We will make use of the [`gix_attributes::State`](https://docs.rs/gix-attributes/0.26.1/gix_attributes/enum.State.html) type to model the state in our implementation.\n+\n+The actual signature of the `GitAttributes::search` method is:\n+\n+```rust\n+pub fn search(\n+    &self,\n+    path: &RepoPath,\n+    attribute_names: impl AsRef<[&str]>,\n+    priority: SearchPriority,\n+) -> Result<HashMap<String, gix_attributes::State>>\n+```",
        "comment_created_at": "2025-08-07T18:44:18+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "nit: I have been wondering about this signature for quite a while since it takes a relatively Git centric approach (which is imo not to bad). To me there simpler variants which map to the features we support. \n\nExamples below\n\n```rust\n// Drops priority and doesn't need a monomorphization\n// this fits the best if we want to support stacking `FileLoaders` see my comment there\npub fn search(\n   &self,\n   path: &RepoPath, \n  attribute_names: &[&str]\n) -> Result<...>\n\n// Make the supported attributes an enum or custom type\npub fn search(\n   &self,\n   path: &RepoPath,\n   attribute_names: &[git_attribute::Attribute]\n   priority: SearchPriority\n) -> Result<...>\n```\n\n\n\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2338494926",
    "pr_number": 7483,
    "pr_file": "docs/design/github_integration.md",
    "created_at": "2025-09-11T04:31:24+00:00",
    "commented_code": "+# GitHub Integration\n+\n+> Native GitHub integration for creating pull requests from bookmarks\n+\n+Author: [Parth Doshi](mailto:contact@parthdoshi.com)\n+\n+## Summary\n+\n+This design proposes basic GitHub integration for jj that allows users to create pull requests directly from revision specifications without relying on external tools for the core workflow. The implementation will shell out to the GitHub CLI (`gh`) for authentication and API access, focusing on revision-based PR creation with support for interactive stacked PR workflows through a TUI interface.",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2338494926",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7483,
        "pr_file": "docs/design/github_integration.md",
        "discussion_id": "2338494926",
        "commented_code": "@@ -0,0 +1,118 @@\n+# GitHub Integration\n+\n+> Native GitHub integration for creating pull requests from bookmarks\n+\n+Author: [Parth Doshi](mailto:contact@parthdoshi.com)\n+\n+## Summary\n+\n+This design proposes basic GitHub integration for jj that allows users to create pull requests directly from revision specifications without relying on external tools for the core workflow. The implementation will shell out to the GitHub CLI (`gh`) for authentication and API access, focusing on revision-based PR creation with support for interactive stacked PR workflows through a TUI interface.",
        "comment_created_at": "2025-09-11T04:31:24+00:00",
        "comment_author": "parthsdoshi",
        "comment_body": "Maybe I should just descope the TUI and instead only focus on the case where a single revision is given as input?\r\n\r\nThen we would find the closest ancestor bookmark that's been pushed to a remote and create a PR against that? (at least as the default)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2326321869",
    "pr_number": 7435,
    "pr_file": "docs/filesets.md",
    "created_at": "2025-09-06T00:59:34+00:00",
    "commented_code": "* `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2326321869",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T00:59:34+00:00",
        "comment_author": "martinvonz",
        "comment_body": "I don't see much reason to support this if it can be achieved already with `glob` and `glob-i`. It's not a lot of code but it still doesn't seem worth it to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326323081",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T01:02:48+00:00",
        "comment_author": "martinvonz",
        "comment_body": "I'm not strongly against it either. I would prefer to wait and hear from others if this is something they would find valuable.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326323453",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T01:03:48+00:00",
        "comment_author": "gechr",
        "comment_body": "Fair enough, removed it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326324244",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T01:05:57+00:00",
        "comment_author": "martinvonz",
        "comment_body": "Sorry, I meant the whole feature (if we have the feature, I think we should also document it)",
        "pr_file_module": null
      },
      {
        "comment_id": "2326334754",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T01:15:07+00:00",
        "comment_author": "scott2000",
        "comment_body": "I think this could be a nice feature to have. I feel like 90% of the time when I use glob patterns it's to select or exclude a file extension, and `'glob:**/*.rs'` feels pretty verbose to type compared to `ext:rs`. But I don't feel strongly about it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326338783",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T01:26:16+00:00",
        "comment_author": "gechr",
        "comment_body": "@martinvonz Aha, misunderstood. Sure, let's wait and see, but yeah I agree with Scott, the majority of my glob usage is to select by extension, so this would be a nice QoL improvement for me.\r\n\r\nLet me know about `ext-i` if we reach a consensus, wasn't sure how useful it was anyway, just included it for parity with `glob`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326376092",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T02:16:08+00:00",
        "comment_author": "yuja",
        "comment_body": "Maybe it's good to add a pattern that only matches filename part (e.g. `name-glob:*.rs`, `name:README.md`, etc.), but I don't feel strongly either. My concern about `ext:` is that it's ambiguous whether `.{substring}` should be considered an extension. `.gitignore` isn't usually considered an extension, for example.",
        "pr_file_module": null
      },
      {
        "comment_id": "2326387125",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T02:35:35+00:00",
        "comment_author": "scott2000",
        "comment_body": "> My concern about `ext:` is that it's ambiguous whether `.{substring}` should be considered an extension. `.gitignore` isn't usually considered an extension, for example.\r\n\r\nThat's a good point, I hadn't considered that. I'm not sure it would matter too much in practice though, since it seems unlikely someone would use `ext:gitignore` in the first place for example.",
        "pr_file_module": null
      },
      {
        "comment_id": "2327525358",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T14:22:08+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "> I don't see much reason to support this if it can be achieved already with `glob` and `glob-i`. It's not a lot of code but it still doesn't seem worth it to me.\r\n\r\nThat's the same reason I brought up in the bug. I still think it provides value though since it is a nicer UX which can get desugared to the respective expression. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2327526702",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T14:23:06+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "the actual FR which this closes is https://github.com/jj-vcs/jj/issues/6229",
        "pr_file_module": null
      },
      {
        "comment_id": "2327593114",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T14:45:42+00:00",
        "comment_author": "gechr",
        "comment_body": "@PhilipMetzger Wasn't aware that issue existed - updated the first commit message to reference it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2327615717",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T14:54:22+00:00",
        "comment_author": "gechr",
        "comment_body": "I had a thought - to make this a little more useful, perhaps `ext` could be case-insensitive by default? Then we don't need `ext-i`. Fundamentally, is there a difference between `*.RS` and `*.rs` when considering extensions? Do we need a distinction?",
        "pr_file_module": null
      },
      {
        "comment_id": "2327626635",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-06T14:58:28+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "> I had a thought - to make this a little more useful, perhaps `ext` could be case-insensitive by default? Then we don't need `ext-i`. Fundamentally, is there a difference between `*.RS` and `*.rs` when considering extensions?\r\n\r\nFilesets need to deal with existing filesystems which makes case-sensitivity a difference in files, see the recent pains from APFS (see https://github.com/jj-vcs/jj/issues/7243) so I don't think that's possible or even a good design. \r\n\r\n> Fundamentally, is there a difference between `*.RS` and `*.rs` when considering extensions?\r\n\r\nTo the compiler not really but different filesystems will see them as different files. \r\n\r\n> Do we need a distinction?\r\n\r\nAs above, its needed. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2328683041",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T13:20:43+00:00",
        "comment_author": "gechr",
        "comment_body": "Since there's a little pushback on accepting this, I had a bit of a think around how to improve the UX here without introducing additional keywords:\r\n\r\n* Make `glob:` the default for filesets\r\n* Change `**` to match files in the root directory, so we can just do `jj diff '**.rs'`\r\n  * Just because `git` does not support this, it does not mean `jj` shouldn't. Practically all other glob implementations I have tested support `**` to match files in the root (bash, fish, zsh, go, rust, python, ruby, node)\r\n\r\nPersonally, I still find `'**.rs'` a little less convenient than simply `ext:rs` because it doesn't require the additional quotes, but I think it's an acceptable alternative over `glob:'**/*.rs'` which I find really clunky for such a common task.\r\n\r\nAdditionally, I had a thought about \"fileset aliases\", which would allow the user to define their own aliases for common fileset operations, like:\r\n\r\n```toml\r\n[fileset-aliases]\r\n'ext(x)' = '\"glob:**/*.\" ++ x'\r\n```\r\n\r\nAnd then we could do `jj diff ext:rs` or `jj diff 'ext(rs)'`.\r\n\r\nAnyway, just a few ideas, good or bad. I'd like to see this land in some form to make my life easier, so thought I'd throw them out there.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328691078",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T13:42:31+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "> Additionally, I had a thought about \"fileset aliases\", which would allow the user to define their own aliases for common fileset operations, like:\r\n> \r\n> ```toml\r\n> [fileset-aliases]\r\n> 'ext(x)' = '\"glob:**/*.\" ++ x'\r\n> ```\r\n> \r\n> And then we could do `jj diff ext:rs` or `jj diff 'ext(rs)'`.\r\n\r\nSee @bryceberger 's https://github.com/jj-vcs/jj/pull/4962 which I also would support.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328694753",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T13:52:05+00:00",
        "comment_author": "gechr",
        "comment_body": "Aha, thanks for the link - maybe I should search more thoroughly before suggesting things!\r\n\r\nThe solution in #4962 doesn't really solve this in a way I'd find helpful, though. That is, it does not support arguments - just predefined symbols; so it'd require me to define X number of aliases for all possible extensions I work with, and then I'd do `jj diff EXT_RS`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328696386",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T13:56:22+00:00",
        "comment_author": "martinvonz",
        "comment_body": "It sounds like this is not an uncommon request so I'm okay with it. I think the last commit which updates the grammar to handle the special case of `ext:` (no extension) is still too much complexity for a rare case, though.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328697739",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T14:00:01+00:00",
        "comment_author": "gechr",
        "comment_body": "Yeah, figured - I tend to agree. Will drop it.\r\n\r\nWDYT about `ext` vs `ext-i`? Should I reintroduce the latter?",
        "pr_file_module": null
      },
      {
        "comment_id": "2328697835",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T14:00:21+00:00",
        "comment_author": "yuja",
        "comment_body": "> * Make `glob:` the default for filesets\r\n\r\nIt's tracked by https://github.com/jj-vcs/jj/issues/6971.\r\n\r\n> * Change `**` to match files in the root directory, so we can just do `jj diff '**.rs'`\r\n\r\n`**` does match files in the root directory. It won't find directories recursively, though. That's the common behavior afaik.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328699009",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T14:03:30+00:00",
        "comment_author": "gechr",
        "comment_body": "@yuja Yeah, sorry. I meant `**.rs` should match both files in the root _and_ recursively. This is how it behaves in bash, fish, zsh, go, rust, python, ruby, node. Git is the odd one out.\r\n\r\nWould you be open to a PR to change this behaviour?",
        "pr_file_module": null
      },
      {
        "comment_id": "2328703795",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T14:17:22+00:00",
        "comment_author": "yuja",
        "comment_body": "> @yuja Yeah, sorry. I meant `**.rs` should match both files in the root _and_ recursively. This is how it behaves in bash, fish, zsh, go, rust, python, ruby, node. Git is the odd one out.\r\n\r\nReally? `ls **.rs` returns `zsh: no matches found: **.rs`. There may be an option to change the behavior, though.\r\n\r\n> Would you be open to a PR to change this behaviour?\r\n\r\nIf the upstream crate `globset` supports that, maybe we could add a matcher prefix for that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2328706178",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7435,
        "pr_file": "docs/filesets.md",
        "discussion_id": "2326321869",
        "commented_code": "@@ -38,6 +38,12 @@ the path [has no special characters](#quoting-file-names).\n * `glob-i:\"pattern\"` or `cwd-glob-i:\"pattern\"`: Like `glob:` but\n   case-insensitive. For example, `glob-i:\"*.TXT\"` will match both `file.txt`\n   and `FILE.TXT`.\n+* `ext:\"extension\"`: Matches files with the specified extension recursively\n+  from the current working directory (equivalent to `glob:\"**/*.extension\"`).\n+  For example, `ext:\"rs\"` will match all `.rs` files. The special case `ext:\"\"`\n+  matches files with no extension (equivalent to `~glob:\"**/*.*\"`).\n+* `ext-i:\"extension\"`: Like `ext:` but case-insensitive. For example,\n+  `ext-i:\"TXT\"` will match both `file.txt` and `FILE.TXT`.",
        "comment_created_at": "2025-09-07T14:23:34+00:00",
        "comment_author": "gechr",
        "comment_body": "Ah, just tested again. I misremembered. It only seems to work for `/`...\r\n\r\n```\r\n$ ls **/b\r\na/b\r\nb\r\n```\r\n\r\ngit:\r\n\r\n```\r\n$ git show --pretty=\"\" --name-only '**/b'\r\na/b\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  }
]