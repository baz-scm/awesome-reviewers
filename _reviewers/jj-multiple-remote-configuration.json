[
  {
    "discussion_id": "2329901375",
    "pr_number": 7439,
    "pr_file": "docs/guides/multiple-remotes.md",
    "created_at": "2025-09-08T11:02:57+00:00",
    "commented_code": "+# Multiple remotes\n+\n+When using multiple [remote repositories], how you configure them in Jujutsu\n+depends on your workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remote repositories]: ../glossary.md#remote\n+\n+## Nomenclature\n+\n+A remote named `origin` is one you have write-access to and is usually where you\n+push changes.\n+\n+A remote named `upstream` is the more well-known repository. You may not be able\n+to push to this repository.\n+\n+The trunk in each repository is assumed to be `main`, so the remote bookmarks\n+are `main@origin` and `main@upstream`.\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+`upstream` is the canonical upstream remote, and `origin` is where you push\n+contributions, most likely so you can open pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2329901375",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7439,
        "pr_file": "docs/guides/multiple-remotes.md",
        "discussion_id": "2329901375",
        "commented_code": "@@ -0,0 +1,113 @@\n+# Multiple remotes\n+\n+When using multiple [remote repositories], how you configure them in Jujutsu\n+depends on your workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remote repositories]: ../glossary.md#remote\n+\n+## Nomenclature\n+\n+A remote named `origin` is one you have write-access to and is usually where you\n+push changes.\n+\n+A remote named `upstream` is the more well-known repository. You may not be able\n+to push to this repository.\n+\n+The trunk in each repository is assumed to be `main`, so the remote bookmarks\n+are `main@origin` and `main@upstream`.\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+`upstream` is the canonical upstream remote, and `origin` is where you push\n+contributions, most likely so you can open pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.",
        "comment_created_at": "2025-09-08T11:02:57+00:00",
        "comment_author": "yuja",
        "comment_body": "Just question. Is it common to keep the fork repository up-to-date? I tend to leave the `main` branch unsynced because I'm not interested in the state of the fork repository, so I usually don't track `main@origin` (and `main@upstream` which I don't have control of.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2329997107",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7439,
        "pr_file": "docs/guides/multiple-remotes.md",
        "discussion_id": "2329901375",
        "commented_code": "@@ -0,0 +1,113 @@\n+# Multiple remotes\n+\n+When using multiple [remote repositories], how you configure them in Jujutsu\n+depends on your workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remote repositories]: ../glossary.md#remote\n+\n+## Nomenclature\n+\n+A remote named `origin` is one you have write-access to and is usually where you\n+push changes.\n+\n+A remote named `upstream` is the more well-known repository. You may not be able\n+to push to this repository.\n+\n+The trunk in each repository is assumed to be `main`, so the remote bookmarks\n+are `main@origin` and `main@upstream`.\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+`upstream` is the canonical upstream remote, and `origin` is where you push\n+contributions, most likely so you can open pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.",
        "comment_created_at": "2025-09-08T11:45:53+00:00",
        "comment_author": "icorbrey",
        "comment_body": "I (personally) treat fork repositories like normal ones and track main, fetching often and rebasing my work on top of it whenever it updates. I'm not sure it's a common workflow, but I haven't had issues with it",
        "pr_file_module": null
      },
      {
        "comment_id": "2330342690",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7439,
        "pr_file": "docs/guides/multiple-remotes.md",
        "discussion_id": "2329901375",
        "commented_code": "@@ -0,0 +1,113 @@\n+# Multiple remotes\n+\n+When using multiple [remote repositories], how you configure them in Jujutsu\n+depends on your workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remote repositories]: ../glossary.md#remote\n+\n+## Nomenclature\n+\n+A remote named `origin` is one you have write-access to and is usually where you\n+push changes.\n+\n+A remote named `upstream` is the more well-known repository. You may not be able\n+to push to this repository.\n+\n+The trunk in each repository is assumed to be `main`, so the remote bookmarks\n+are `main@origin` and `main@upstream`.\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+`upstream` is the canonical upstream remote, and `origin` is where you push\n+contributions, most likely so you can open pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.",
        "comment_created_at": "2025-09-08T13:58:49+00:00",
        "comment_author": "PhilipMetzger",
        "comment_body": "> Is it common to keep the fork repository up-to-date?\r\n\r\nI think that's what the GitHub/forking flow suggests, but I don't care to much about it.  \r\n\r\n> I tend to leave the `main` branch unsynced because I'm not interested in the state of the fork repository, so I usually don't track `main@origin` (and `main@upstream` which I don't have control of.)\r\n\r\nThat also makes perfectly sense to me. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2330762240",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7439,
        "pr_file": "docs/guides/multiple-remotes.md",
        "discussion_id": "2329901375",
        "commented_code": "@@ -0,0 +1,113 @@\n+# Multiple remotes\n+\n+When using multiple [remote repositories], how you configure them in Jujutsu\n+depends on your workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remote repositories]: ../glossary.md#remote\n+\n+## Nomenclature\n+\n+A remote named `origin` is one you have write-access to and is usually where you\n+push changes.\n+\n+A remote named `upstream` is the more well-known repository. You may not be able\n+to push to this repository.\n+\n+The trunk in each repository is assumed to be `main`, so the remote bookmarks\n+are `main@origin` and `main@upstream`.\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+`upstream` is the canonical upstream remote, and `origin` is where you push\n+contributions, most likely so you can open pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.",
        "comment_created_at": "2025-09-08T16:28:46+00:00",
        "comment_author": "jennings",
        "comment_body": "I don't go _out of my way_ to update it because it doesn't make a big difference. But each time I push a bookmark to my fork, if `main` isn't updated it looks like my branch has hundreds of commits in it. So, I track `main@origin` and it just keeps up to date automatically whenever I `jj git push`.\r\n\r\nI could annotate the \"track `main@origin`\" bit as optional, if you think people will get tripped up by it and think this isn't their workflow.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2314661877",
    "pr_number": 7396,
    "pr_file": "docs/gerrit.md",
    "created_at": "2025-09-01T23:43:31+00:00",
    "commented_code": "+# Using Jujutsu with Gerrit Code Review\n+\n+JJ and Gerrit share the same mental model, which makes Gerrit feel like a\n+natural collaboration tool for JJ. JJ tracks a \"change identity\" across\n+rewrites, and Gerrit\u2019s `Change-Id` tracks the same logical change across patch\n+sets. JJ and Gerrit's `Change-Id`s aren\u2019t natively compatible yet, but they\u2019re\n+philosophically aligned. `jj gerrit upload` bridges the gap today by adding a\n+Gerrit-style `Change-Id` while JJ keeps its own notion of change identity on the\n+client. In practice, that means small, clean commits that evolve over\n+time\u2014exactly how Gerrit wants you to work.\n+\n+This guide assumes a basic understanding of Git, Gerrit, and Jujutsu.\n+\n+## Set up a Gerrit remote\n+\n+Jujutsu communicates with Gerrit by pushing commits to a Git remote. If you're\n+starting from an existing Git repository with Gerrit remotes already configured,\n+you can use `jj git init --colocate` to start using JJ in that repo. Otherwise,\n+set up your Gerrit remote.\n+\n+```shell\n+# Option 1: Start JJ in an existing Git repo with Gerrit remotes\n+$ jj git init --colocate",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2314661877",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7396,
        "pr_file": "docs/gerrit.md",
        "discussion_id": "2314661877",
        "commented_code": "@@ -0,0 +1,115 @@\n+# Using Jujutsu with Gerrit Code Review\n+\n+JJ and Gerrit share the same mental model, which makes Gerrit feel like a\n+natural collaboration tool for JJ. JJ tracks a \"change identity\" across\n+rewrites, and Gerrit\u2019s `Change-Id` tracks the same logical change across patch\n+sets. JJ and Gerrit's `Change-Id`s aren\u2019t natively compatible yet, but they\u2019re\n+philosophically aligned. `jj gerrit upload` bridges the gap today by adding a\n+Gerrit-style `Change-Id` while JJ keeps its own notion of change identity on the\n+client. In practice, that means small, clean commits that evolve over\n+time\u2014exactly how Gerrit wants you to work.\n+\n+This guide assumes a basic understanding of Git, Gerrit, and Jujutsu.\n+\n+## Set up a Gerrit remote\n+\n+Jujutsu communicates with Gerrit by pushing commits to a Git remote. If you're\n+starting from an existing Git repository with Gerrit remotes already configured,\n+you can use `jj git init --colocate` to start using JJ in that repo. Otherwise,\n+set up your Gerrit remote.\n+\n+```shell\n+# Option 1: Start JJ in an existing Git repo with Gerrit remotes\n+$ jj git init --colocate",
        "comment_created_at": "2025-09-01T23:43:31+00:00",
        "comment_author": "matts1",
        "comment_body": "Probably should be an option 3: `jj git clone`",
        "pr_file_module": null
      }
    ]
  }
]