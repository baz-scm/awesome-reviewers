[
  {
    "discussion_id": "2312393227",
    "pr_number": 7338,
    "pr_file": "cli/src/commands/git/clone.rs",
    "created_at": "2025-08-31T10:27:25+00:00",
    "commented_code": "ui: &Ui,\n     workspace_command: &mut WorkspaceCommandHelper,\n     remote_name: &RemoteName,\n+    target_branches: Option<&[StringPattern]>,\n     depth: Option<NonZeroU32>,\n     fetch_tags: Option<FetchTagsMode>,\n-) -> Result<Option<RefNameBuf>, CommandError> {\n+) -> Result<(Option<RefNameBuf>, bool), CommandError> {\n     writeln!(\n         ui.status(),\n         r#\"Fetching into new repo in \"{}\"\"#,\n         workspace_command.workspace_root().display()\n     )?;\n     let settings = workspace_command.settings();\n     let git_settings = settings.git_settings()?;\n-    let track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n+    let should_track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n     let mut tx = workspace_command.start_transaction();\n-    let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n-    with_remote_git_callbacks(ui, |cb| {\n-        git_fetch.fetch(\n-            remote_name,\n-            expand_fetch_refspecs(remote_name, vec![StringPattern::everything()])?,\n-            cb,\n-            depth,\n-            match fetch_tags {\n-                // If not explicitly specified on the CLI, override the remote\n-                // configuration and fetch all tags by default since this is\n-                // the Git default behavior.\n-                None => Some(FetchTagsOverride::AllTags),\n+    let (default_branch, import_stats) = {\n+        let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n+\n+        with_remote_git_callbacks(ui, |cb| {\n+            git_fetch.fetch(\n+                remote_name,\n+                expand_fetch_refspecs(\n+                    remote_name,\n+                    target_branches\n+                        .unwrap_or(&[StringPattern::everything()])\n+                        .to_vec(),\n+                )?,",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2312393227",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7338,
        "pr_file": "cli/src/commands/git/clone.rs",
        "discussion_id": "2312393227",
        "commented_code": "@@ -253,59 +278,106 @@ fn fetch_new_remote(\n     ui: &Ui,\n     workspace_command: &mut WorkspaceCommandHelper,\n     remote_name: &RemoteName,\n+    target_branches: Option<&[StringPattern]>,\n     depth: Option<NonZeroU32>,\n     fetch_tags: Option<FetchTagsMode>,\n-) -> Result<Option<RefNameBuf>, CommandError> {\n+) -> Result<(Option<RefNameBuf>, bool), CommandError> {\n     writeln!(\n         ui.status(),\n         r#\"Fetching into new repo in \"{}\"\"#,\n         workspace_command.workspace_root().display()\n     )?;\n     let settings = workspace_command.settings();\n     let git_settings = settings.git_settings()?;\n-    let track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n+    let should_track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n     let mut tx = workspace_command.start_transaction();\n-    let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n-    with_remote_git_callbacks(ui, |cb| {\n-        git_fetch.fetch(\n-            remote_name,\n-            expand_fetch_refspecs(remote_name, vec![StringPattern::everything()])?,\n-            cb,\n-            depth,\n-            match fetch_tags {\n-                // If not explicitly specified on the CLI, override the remote\n-                // configuration and fetch all tags by default since this is\n-                // the Git default behavior.\n-                None => Some(FetchTagsOverride::AllTags),\n+    let (default_branch, import_stats) = {\n+        let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n+\n+        with_remote_git_callbacks(ui, |cb| {\n+            git_fetch.fetch(\n+                remote_name,\n+                expand_fetch_refspecs(\n+                    remote_name,\n+                    target_branches\n+                        .unwrap_or(&[StringPattern::everything()])\n+                        .to_vec(),\n+                )?,",
        "comment_created_at": "2025-08-31T10:27:25+00:00",
        "comment_author": "yuja",
        "comment_body": "Since https://github.com/jj-vcs/jj/pull/7275 gets merged, we can configure the remote to fetch only the specified branches/bookmarks. That seems better since future `jj git fetch` won't fetch other bookmarks. ~Then, we wouldn't have to specify the target branches here.~\r\n\r\nEDIT: we'll need to pass the same refspecs to `fetch()` function.",
        "pr_file_module": null
      },
      {
        "comment_id": "2315882905",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7338,
        "pr_file": "cli/src/commands/git/clone.rs",
        "discussion_id": "2312393227",
        "commented_code": "@@ -253,59 +278,106 @@ fn fetch_new_remote(\n     ui: &Ui,\n     workspace_command: &mut WorkspaceCommandHelper,\n     remote_name: &RemoteName,\n+    target_branches: Option<&[StringPattern]>,\n     depth: Option<NonZeroU32>,\n     fetch_tags: Option<FetchTagsMode>,\n-) -> Result<Option<RefNameBuf>, CommandError> {\n+) -> Result<(Option<RefNameBuf>, bool), CommandError> {\n     writeln!(\n         ui.status(),\n         r#\"Fetching into new repo in \"{}\"\"#,\n         workspace_command.workspace_root().display()\n     )?;\n     let settings = workspace_command.settings();\n     let git_settings = settings.git_settings()?;\n-    let track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n+    let should_track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n     let mut tx = workspace_command.start_transaction();\n-    let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n-    with_remote_git_callbacks(ui, |cb| {\n-        git_fetch.fetch(\n-            remote_name,\n-            expand_fetch_refspecs(remote_name, vec![StringPattern::everything()])?,\n-            cb,\n-            depth,\n-            match fetch_tags {\n-                // If not explicitly specified on the CLI, override the remote\n-                // configuration and fetch all tags by default since this is\n-                // the Git default behavior.\n-                None => Some(FetchTagsOverride::AllTags),\n+    let (default_branch, import_stats) = {\n+        let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n+\n+        with_remote_git_callbacks(ui, |cb| {\n+            git_fetch.fetch(\n+                remote_name,\n+                expand_fetch_refspecs(\n+                    remote_name,\n+                    target_branches\n+                        .unwrap_or(&[StringPattern::everything()])\n+                        .to_vec(),\n+                )?,",
        "comment_created_at": "2025-09-02T12:07:53+00:00",
        "comment_author": "owenbrooks",
        "comment_body": "Just clarifying, there is no change needed here, but we now will have the expected behaviour for future calls to `jj git fetch`, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2315920281",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7338,
        "pr_file": "cli/src/commands/git/clone.rs",
        "discussion_id": "2312393227",
        "commented_code": "@@ -253,59 +278,106 @@ fn fetch_new_remote(\n     ui: &Ui,\n     workspace_command: &mut WorkspaceCommandHelper,\n     remote_name: &RemoteName,\n+    target_branches: Option<&[StringPattern]>,\n     depth: Option<NonZeroU32>,\n     fetch_tags: Option<FetchTagsMode>,\n-) -> Result<Option<RefNameBuf>, CommandError> {\n+) -> Result<(Option<RefNameBuf>, bool), CommandError> {\n     writeln!(\n         ui.status(),\n         r#\"Fetching into new repo in \"{}\"\"#,\n         workspace_command.workspace_root().display()\n     )?;\n     let settings = workspace_command.settings();\n     let git_settings = settings.git_settings()?;\n-    let track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n+    let should_track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n     let mut tx = workspace_command.start_transaction();\n-    let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n-    with_remote_git_callbacks(ui, |cb| {\n-        git_fetch.fetch(\n-            remote_name,\n-            expand_fetch_refspecs(remote_name, vec![StringPattern::everything()])?,\n-            cb,\n-            depth,\n-            match fetch_tags {\n-                // If not explicitly specified on the CLI, override the remote\n-                // configuration and fetch all tags by default since this is\n-                // the Git default behavior.\n-                None => Some(FetchTagsOverride::AllTags),\n+    let (default_branch, import_stats) = {\n+        let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n+\n+        with_remote_git_callbacks(ui, |cb| {\n+            git_fetch.fetch(\n+                remote_name,\n+                expand_fetch_refspecs(\n+                    remote_name,\n+                    target_branches\n+                        .unwrap_or(&[StringPattern::everything()])\n+                        .to_vec(),\n+                )?,",
        "comment_created_at": "2025-09-02T12:23:02+00:00",
        "comment_author": "yuja",
        "comment_body": "We'll probably need to pass the fetch refspecs to `git::add_remote()` to make them persist. Can you add test for `clone --branch && fetch`?\r\n\r\nWe can address this later, but I think it's better to include it in the same release.",
        "pr_file_module": null
      },
      {
        "comment_id": "2422338741",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7338,
        "pr_file": "cli/src/commands/git/clone.rs",
        "discussion_id": "2312393227",
        "commented_code": "@@ -253,59 +278,106 @@ fn fetch_new_remote(\n     ui: &Ui,\n     workspace_command: &mut WorkspaceCommandHelper,\n     remote_name: &RemoteName,\n+    target_branches: Option<&[StringPattern]>,\n     depth: Option<NonZeroU32>,\n     fetch_tags: Option<FetchTagsMode>,\n-) -> Result<Option<RefNameBuf>, CommandError> {\n+) -> Result<(Option<RefNameBuf>, bool), CommandError> {\n     writeln!(\n         ui.status(),\n         r#\"Fetching into new repo in \"{}\"\"#,\n         workspace_command.workspace_root().display()\n     )?;\n     let settings = workspace_command.settings();\n     let git_settings = settings.git_settings()?;\n-    let track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n+    let should_track_default = settings.get_bool(\"git.track-default-bookmark-on-clone\")?;\n     let mut tx = workspace_command.start_transaction();\n-    let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n-    with_remote_git_callbacks(ui, |cb| {\n-        git_fetch.fetch(\n-            remote_name,\n-            expand_fetch_refspecs(remote_name, vec![StringPattern::everything()])?,\n-            cb,\n-            depth,\n-            match fetch_tags {\n-                // If not explicitly specified on the CLI, override the remote\n-                // configuration and fetch all tags by default since this is\n-                // the Git default behavior.\n-                None => Some(FetchTagsOverride::AllTags),\n+    let (default_branch, import_stats) = {\n+        let mut git_fetch = GitFetch::new(tx.repo_mut(), &git_settings)?;\n+\n+        with_remote_git_callbacks(ui, |cb| {\n+            git_fetch.fetch(\n+                remote_name,\n+                expand_fetch_refspecs(\n+                    remote_name,\n+                    target_branches\n+                        .unwrap_or(&[StringPattern::everything()])\n+                        .to_vec(),\n+                )?,",
        "comment_created_at": "2025-10-11T00:57:37+00:00",
        "comment_author": "owenbrooks",
        "comment_body": "I have added this test, and got it to succeed by passing the fetch refspecs in `git::add_remote()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168595473",
    "pr_number": 6826,
    "pr_file": "cli/src/commands/git/sync.rs",
    "created_at": "2025-06-26T09:12:43+00:00",
    "commented_code": "+// Copyright 2020-2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::collections::HashMap;\n+\n+use clap_complete::ArgValueCandidates;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::object_id::ObjectId;\n+use jj_lib::ref_name::RemoteRefSymbolBuf;\n+use jj_lib::repo::Repo as _;\n+use jj_lib::revset::RevsetExpression;\n+use jj_lib::rewrite::RebaseOptions;\n+use jj_lib::str_util::StringPattern;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::command_error::user_error;\n+use crate::command_error::CommandError;\n+use crate::commands::git::fetch::do_git_fetch;\n+use crate::commands::git::fetch::get_default_fetch_remotes;\n+use crate::commands::git::resolve_remote_patterns;\n+use crate::complete;\n+use crate::ui::Ui;\n+\n+/// Fetch from remotes and rebase local changes\n+///\n+/// This command fetches from Git remotes and rebases local commits that were\n+/// descendants of remote-tracking bookmarks onto the new remote heads. This\n+/// provides a workflow similar to `git pull --rebase` but operates on all\n+/// tracked remote bookmarks simultaneously.\n+///\n+/// The rebase operation automatically drops any local commits that have been\n+/// merged upstream.\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct GitSyncArgs {\n+    /// The remotes to sync with\n+    ///\n+    /// This defaults to the `git.fetch` setting. If that is not configured, and\n+    /// if there are multiple remotes, the remote named \"origin\" will be used.\n+    ///\n+    /// By default, the specified remote names match exactly. Use a [string\n+    /// pattern], e.g. `--remote 'glob:*'`, to select remotes using\n+    /// patterns.\n+    ///\n+    /// [string pattern]:\n+    ///     https://jj-vcs.github.io/jj/latest/revsets#string-patterns\n+    #[arg(\n+        long = \"remote\",\n+        short = 'r',\n+        value_name = \"REMOTE\",\n+        value_parser = StringPattern::parse,\n+        add = ArgValueCandidates::new(complete::git_remotes),\n+    )]\n+    remotes: Vec<StringPattern>,\n+\n+    /// Sync only these bookmarks, or bookmarks matching a pattern\n+    ///\n+    /// By default, the specified name matches exactly. Use `glob:` prefix to\n+    /// expand `*` as a glob, e.g. `--branch 'glob:push-*'`. Other wildcard\n+    /// characters such as `?` are *not* supported.\n+    #[arg(\n+        long = \"bookmark\",\n+        short = 'b',\n+        alias = \"branch\",\n+        value_parser = StringPattern::parse,\n+        add = ArgValueCandidates::new(complete::bookmarks),\n+    )]\n+    bookmarks: Vec<StringPattern>,\n+\n+    /// Sync with all remotes\n+    #[arg(long, conflicts_with = \"remotes\")]\n+    all_remotes: bool,\n+}\n+\n+#[tracing::instrument(skip_all)]\n+pub fn cmd_git_sync(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &GitSyncArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+\n+    // Determine which remotes to sync\n+    let remote_patterns = if args.all_remotes {\n+        vec![StringPattern::everything()]\n+    } else if args.remotes.is_empty() {\n+        get_default_fetch_remotes(ui, &workspace_command)?\n+    } else {\n+        args.remotes.clone()\n+    };\n+\n+    let resolved_remotes =\n+        resolve_remote_patterns(ui, workspace_command.repo().store(), &remote_patterns)?;\n+    let remotes = resolved_remotes.iter().map(|r| r.as_ref()).collect_vec();\n+\n+    let mut tx = workspace_command.start_transaction();\n+\n+    // Capture the pre-fetch state of remote tracking bookmarks\n+    let mut pre_fetch_heads: HashMap<RemoteRefSymbolBuf, CommitId> = HashMap::new();\n+\n+    for remote in &remotes {\n+        for (name, remote_ref) in tx.repo().view().remote_bookmarks(remote) {\n+            // Only capture non-conflicted targets\n+            if let Some(commit_id) = remote_ref.target.as_normal() {",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2168595473",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 6826,
        "pr_file": "cli/src/commands/git/sync.rs",
        "discussion_id": "2168595473",
        "commented_code": "@@ -0,0 +1,261 @@\n+// Copyright 2020-2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::collections::HashMap;\n+\n+use clap_complete::ArgValueCandidates;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::object_id::ObjectId;\n+use jj_lib::ref_name::RemoteRefSymbolBuf;\n+use jj_lib::repo::Repo as _;\n+use jj_lib::revset::RevsetExpression;\n+use jj_lib::rewrite::RebaseOptions;\n+use jj_lib::str_util::StringPattern;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::command_error::user_error;\n+use crate::command_error::CommandError;\n+use crate::commands::git::fetch::do_git_fetch;\n+use crate::commands::git::fetch::get_default_fetch_remotes;\n+use crate::commands::git::resolve_remote_patterns;\n+use crate::complete;\n+use crate::ui::Ui;\n+\n+/// Fetch from remotes and rebase local changes\n+///\n+/// This command fetches from Git remotes and rebases local commits that were\n+/// descendants of remote-tracking bookmarks onto the new remote heads. This\n+/// provides a workflow similar to `git pull --rebase` but operates on all\n+/// tracked remote bookmarks simultaneously.\n+///\n+/// The rebase operation automatically drops any local commits that have been\n+/// merged upstream.\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct GitSyncArgs {\n+    /// The remotes to sync with\n+    ///\n+    /// This defaults to the `git.fetch` setting. If that is not configured, and\n+    /// if there are multiple remotes, the remote named \"origin\" will be used.\n+    ///\n+    /// By default, the specified remote names match exactly. Use a [string\n+    /// pattern], e.g. `--remote 'glob:*'`, to select remotes using\n+    /// patterns.\n+    ///\n+    /// [string pattern]:\n+    ///     https://jj-vcs.github.io/jj/latest/revsets#string-patterns\n+    #[arg(\n+        long = \"remote\",\n+        short = 'r',\n+        value_name = \"REMOTE\",\n+        value_parser = StringPattern::parse,\n+        add = ArgValueCandidates::new(complete::git_remotes),\n+    )]\n+    remotes: Vec<StringPattern>,\n+\n+    /// Sync only these bookmarks, or bookmarks matching a pattern\n+    ///\n+    /// By default, the specified name matches exactly. Use `glob:` prefix to\n+    /// expand `*` as a glob, e.g. `--branch 'glob:push-*'`. Other wildcard\n+    /// characters such as `?` are *not* supported.\n+    #[arg(\n+        long = \"bookmark\",\n+        short = 'b',\n+        alias = \"branch\",\n+        value_parser = StringPattern::parse,\n+        add = ArgValueCandidates::new(complete::bookmarks),\n+    )]\n+    bookmarks: Vec<StringPattern>,\n+\n+    /// Sync with all remotes\n+    #[arg(long, conflicts_with = \"remotes\")]\n+    all_remotes: bool,\n+}\n+\n+#[tracing::instrument(skip_all)]\n+pub fn cmd_git_sync(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &GitSyncArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+\n+    // Determine which remotes to sync\n+    let remote_patterns = if args.all_remotes {\n+        vec![StringPattern::everything()]\n+    } else if args.remotes.is_empty() {\n+        get_default_fetch_remotes(ui, &workspace_command)?\n+    } else {\n+        args.remotes.clone()\n+    };\n+\n+    let resolved_remotes =\n+        resolve_remote_patterns(ui, workspace_command.repo().store(), &remote_patterns)?;\n+    let remotes = resolved_remotes.iter().map(|r| r.as_ref()).collect_vec();\n+\n+    let mut tx = workspace_command.start_transaction();\n+\n+    // Capture the pre-fetch state of remote tracking bookmarks\n+    let mut pre_fetch_heads: HashMap<RemoteRefSymbolBuf, CommitId> = HashMap::new();\n+\n+    for remote in &remotes {\n+        for (name, remote_ref) in tx.repo().view().remote_bookmarks(remote) {\n+            // Only capture non-conflicted targets\n+            if let Some(commit_id) = remote_ref.target.as_normal() {",
        "comment_created_at": "2025-06-26T09:12:43+00:00",
        "comment_author": "yuja",
        "comment_body": "I think we need to use the local bookmark tracking the remote. Remote bookmarks often point to hidden commits.",
        "pr_file_module": null
      }
    ]
  }
]