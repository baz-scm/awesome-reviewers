[
  {
    "discussion_id": "2328653765",
    "pr_number": 7439,
    "pr_file": "docs/guides/multiple-remotes.md",
    "created_at": "2025-09-07T11:59:59+00:00",
    "commented_code": "+# Multiple remotes\n+\n+When using multiple [remotes], how you configure them in Jujutsu depends on your\n+workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remotes]: ../glossary.md#remote\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+Suppose you have two remotes:\n+\n+- `upstream` is the canonical upstream remote.\n+- `origin` is a repository you own that you use for contributing upstream,\n+  usually by opening pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.\n+- Push `my-feature` to `origin`, then open a pull request to `upstream`.\n+\n+To support this scenario, you should:\n+\n+- Track `main@upstream` so your local `main` branch is updated whenever you\n+  fetch from `upstream`.\n+- Track `main@origin` so when you `jj git push`, your fork's `main` branch is\n+  updated.\n+- Set `main@upstream` as the `trunk()` revset alias so it is immutable.\n+\n+```shell\n+# Fetch from both remotes by default\n+$ jj config set git.fetch '[\"upstream\", \"origin\"]'\n+\n+# Push only to the fork by default\n+$ jj config set git.push origin\n+\n+# Track both remote bookmarks\n+$ jj bookmark track main@upstream main@origin\n+\n+# The upstream repository defines the trunk\n+$ jj config set 'revset-aliases.\"trunk()\"' main@upstream",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2328653765",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7439,
        "pr_file": "docs/guides/multiple-remotes.md",
        "discussion_id": "2328653765",
        "commented_code": "@@ -0,0 +1,86 @@\n+# Multiple remotes\n+\n+When using multiple [remotes], how you configure them in Jujutsu depends on your\n+workflow and the role each remote plays.\n+\n+The setup varies based on whether you are contributing to an upstream project,\n+or integrating changes from another repository.\n+\n+[remotes]: ../glossary.md#remote\n+\n+## Contributing upstream with a GitHub-style fork\n+\n+This is a GitHub-style fork used to contribute to the upstream repository.\n+Suppose you have two remotes:\n+\n+- `upstream` is the canonical upstream remote.\n+- `origin` is a repository you own that you use for contributing upstream,\n+  usually by opening pull requests.\n+\n+Actions you might take:\n+\n+- Fetch from `upstream` to get the latest changes.\n+- Push `main` to `origin` to keep it up-to-date.\n+- Push `my-feature` to `origin`, then open a pull request to `upstream`.\n+\n+To support this scenario, you should:\n+\n+- Track `main@upstream` so your local `main` branch is updated whenever you\n+  fetch from `upstream`.\n+- Track `main@origin` so when you `jj git push`, your fork's `main` branch is\n+  updated.\n+- Set `main@upstream` as the `trunk()` revset alias so it is immutable.\n+\n+```shell\n+# Fetch from both remotes by default\n+$ jj config set git.fetch '[\"upstream\", \"origin\"]'\n+\n+# Push only to the fork by default\n+$ jj config set git.push origin\n+\n+# Track both remote bookmarks\n+$ jj bookmark track main@upstream main@origin\n+\n+# The upstream repository defines the trunk\n+$ jj config set 'revset-aliases.\"trunk()\"' main@upstream",
        "comment_created_at": "2025-09-07T11:59:59+00:00",
        "comment_author": "AngelEzquerra",
        "comment_body": "Same issue here. This should be `jj config set --repo 'revset-aliases.\"trunk()\"' main@upstream`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2314676357",
    "pr_number": 7396,
    "pr_file": "docs/gerrit.md",
    "created_at": "2025-09-02T00:09:05+00:00",
    "commented_code": "+# Using Jujutsu with Gerrit Code Review\n+\n+JJ and Gerrit share the same mental model, which makes Gerrit feel like a\n+natural collaboration tool for JJ. JJ tracks a \"change identity\" across\n+rewrites, and Gerrit\u2019s `Change-Id` tracks the same logical change across patch\n+sets. JJ and Gerrit's `Change-Id`s aren\u2019t natively compatible yet, but they\u2019re\n+philosophically aligned. `jj gerrit upload` bridges the gap today by adding a\n+Gerrit-style `Change-Id` while JJ keeps its own notion of change identity on the\n+client. In practice, that means small, clean commits that evolve over\n+time\u2014exactly how Gerrit wants you to work.\n+\n+This guide assumes a basic understanding of Git, Gerrit, and Jujutsu.\n+\n+## Set up a Gerrit remote\n+\n+Jujutsu communicates with Gerrit by pushing commits to a Git remote. If you're\n+starting from an existing Git repository with Gerrit remotes already configured,\n+you can use `jj git init --colocate` to start using JJ in that repo. Otherwise,\n+set up your Gerrit remote.\n+\n+```shell\n+# Option 1: Start JJ in an existing Git repo with Gerrit remotes\n+$ jj git init --colocate\n+\n+# Option 2: Add a Gerrit remote to a JJ repo\n+$ jj git remote add gerrit ssh://gerrit.example.com:29418/your/project\n+```\n+\n+You can configure default values in your repository config by appending the\n+below to `.jj/repo/config.toml`, like so:\n+\n+```toml\n+[gerrit]\n+default_remote = \"gerrit\"  # name of the Git remote to push to\n+default_for = \"main\"        # target branch in Gerrit\n+```\n+\n+## Basic workflow\n+\n+`jj gerrit upload` takes one or more revsets, ensures each selected commit has a\n+Gerrit-compatible `Change-Id:` footer (adding one if missing), and pushes the\n+resulting heads to `refs/for/<branch>` on your Gerrit remote.\n+\n+> Note\n+> Gerrit identifies and updates changes by `Change-Id`. When you reupload a\n+> commit with the same `Change-Id`, Gerrit creates a new patch set.\n+\n+### upload a single change\n+\n+```shell\n+# upload the last real commit (@-) for review to main\n+$ jj gerrit upload -r @-\n+```\n+\n+## Selecting revisions (revsets)\n+\n+`jj gerrit upload` accepts one or more `-r/--revisions` arguments. Each argument\n+may expand to multiple commits. Common patterns:\n+\n+- `-r @-`: the last non-empty commit\n+- `-r 'trunk()..@-'`: everything on top of trunk\n+- `-r 'A..B'`: commits reachable from `B` but not `A`\n+\n+See the [revsets](./revsets.md) guide for more.\n+\n+> Warning\n+> The working-copy commit `@` is empty and is rejected. Use `@-` or another\n+> concrete commit.\n+\n+### Preview without pushing\n+\n+Use `--dry-run` to see which commits would be modified and pushed, and where,\n+without changing anything or contacting the remote.\n+\n+```shell\n+$ jj gerrit upload -r 'trunk()..@-' --for main --dry-run\n+```\n+\n+## Target branch and remote selection\n+\n+You must specify the target branch for review with `--for <branch>` or by\n+configuring `[gerrit].default_for`.",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2314676357",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7396,
        "pr_file": "docs/gerrit.md",
        "discussion_id": "2314676357",
        "commented_code": "@@ -0,0 +1,115 @@\n+# Using Jujutsu with Gerrit Code Review\n+\n+JJ and Gerrit share the same mental model, which makes Gerrit feel like a\n+natural collaboration tool for JJ. JJ tracks a \"change identity\" across\n+rewrites, and Gerrit\u2019s `Change-Id` tracks the same logical change across patch\n+sets. JJ and Gerrit's `Change-Id`s aren\u2019t natively compatible yet, but they\u2019re\n+philosophically aligned. `jj gerrit upload` bridges the gap today by adding a\n+Gerrit-style `Change-Id` while JJ keeps its own notion of change identity on the\n+client. In practice, that means small, clean commits that evolve over\n+time\u2014exactly how Gerrit wants you to work.\n+\n+This guide assumes a basic understanding of Git, Gerrit, and Jujutsu.\n+\n+## Set up a Gerrit remote\n+\n+Jujutsu communicates with Gerrit by pushing commits to a Git remote. If you're\n+starting from an existing Git repository with Gerrit remotes already configured,\n+you can use `jj git init --colocate` to start using JJ in that repo. Otherwise,\n+set up your Gerrit remote.\n+\n+```shell\n+# Option 1: Start JJ in an existing Git repo with Gerrit remotes\n+$ jj git init --colocate\n+\n+# Option 2: Add a Gerrit remote to a JJ repo\n+$ jj git remote add gerrit ssh://gerrit.example.com:29418/your/project\n+```\n+\n+You can configure default values in your repository config by appending the\n+below to `.jj/repo/config.toml`, like so:\n+\n+```toml\n+[gerrit]\n+default_remote = \"gerrit\"  # name of the Git remote to push to\n+default_for = \"main\"        # target branch in Gerrit\n+```\n+\n+## Basic workflow\n+\n+`jj gerrit upload` takes one or more revsets, ensures each selected commit has a\n+Gerrit-compatible `Change-Id:` footer (adding one if missing), and pushes the\n+resulting heads to `refs/for/<branch>` on your Gerrit remote.\n+\n+> Note\n+> Gerrit identifies and updates changes by `Change-Id`. When you reupload a\n+> commit with the same `Change-Id`, Gerrit creates a new patch set.\n+\n+### upload a single change\n+\n+```shell\n+# upload the last real commit (@-) for review to main\n+$ jj gerrit upload -r @-\n+```\n+\n+## Selecting revisions (revsets)\n+\n+`jj gerrit upload` accepts one or more `-r/--revisions` arguments. Each argument\n+may expand to multiple commits. Common patterns:\n+\n+- `-r @-`: the last non-empty commit\n+- `-r 'trunk()..@-'`: everything on top of trunk\n+- `-r 'A..B'`: commits reachable from `B` but not `A`\n+\n+See the [revsets](./revsets.md) guide for more.\n+\n+> Warning\n+> The working-copy commit `@` is empty and is rejected. Use `@-` or another\n+> concrete commit.\n+\n+### Preview without pushing\n+\n+Use `--dry-run` to see which commits would be modified and pushed, and where,\n+without changing anything or contacting the remote.\n+\n+```shell\n+$ jj gerrit upload -r 'trunk()..@-' --for main --dry-run\n+```\n+\n+## Target branch and remote selection\n+\n+You must specify the target branch for review with `--for <branch>` or by\n+configuring `[gerrit].default_for`.",
        "comment_created_at": "2025-09-02T00:09:05+00:00",
        "comment_author": "matts1",
        "comment_body": "This is the technical details. From a user's perspective, they simply need to know:\r\n* Please run `jj config set --user gerrit.default_for <branch name>` to set your default branch across all repos\r\n* Please run `jj config set --repo gerrit.default_for <branch name>` to set your default branch for this specific repo.\r\n* Use `--for <branch name>` to override this for one specific occasion.",
        "pr_file_module": null
      }
    ]
  }
]