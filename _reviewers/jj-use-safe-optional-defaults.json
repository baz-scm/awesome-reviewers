[
  {
    "discussion_id": "2435567587",
    "pr_number": 7484,
    "pr_file": "lib/src/local_working_copy.rs",
    "created_at": "2025-10-16T11:34:49+00:00",
    "commented_code": "continue;\n             }\n \n+            let executable = match &after {\n+                MaterializedTreeValue::File(file) => file.executable,\n+                MaterializedTreeValue::FileConflict(file) => file.executable.unwrap_or(false),\n+                _ => false,\n+            };\n+            let get_exec_bit = || {\n+                // We must get the previous exec bit from the file states and\n+                // not the tree value because only the file states store the\n+                // on-disk executable bit.\n+                let get_prev_exec = || self.file_states().get_exec_bit(&path);\n+                ExecBit::new_from_repo(executable, get_prev_exec)\n+            };",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2435567587",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2435567587",
        "commented_code": "@@ -1926,6 +1953,19 @@ impl TreeState {\n                 continue;\n             }\n \n+            let executable = match &after {\n+                MaterializedTreeValue::File(file) => file.executable,\n+                MaterializedTreeValue::FileConflict(file) => file.executable.unwrap_or(false),\n+                _ => false,\n+            };\n+            let get_exec_bit = || {\n+                // We must get the previous exec bit from the file states and\n+                // not the tree value because only the file states store the\n+                // on-disk executable bit.\n+                let get_prev_exec = || self.file_states().get_exec_bit(&path);\n+                ExecBit::new_from_repo(executable, get_prev_exec)\n+            };",
        "comment_created_at": "2025-10-16T11:34:49+00:00",
        "comment_author": "yuja",
        "comment_body": "This might be true on Unix if the policy is `Ignore`, but it wouldn't be on Windows. Because `write_file()` creates new file, the file wouldn't retain the old exec bit. Since `set_executable()` is noop on Windows, I think the created file should be considered non-executable.\r\n\r\nFWIW, I think it's okay to set exec bit to disk even if the policy is `Ignore`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2441033698",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2435567587",
        "commented_code": "@@ -1926,6 +1953,19 @@ impl TreeState {\n                 continue;\n             }\n \n+            let executable = match &after {\n+                MaterializedTreeValue::File(file) => file.executable,\n+                MaterializedTreeValue::FileConflict(file) => file.executable.unwrap_or(false),\n+                _ => false,\n+            };\n+            let get_exec_bit = || {\n+                // We must get the previous exec bit from the file states and\n+                // not the tree value because only the file states store the\n+                // on-disk executable bit.\n+                let get_prev_exec = || self.file_states().get_exec_bit(&path);\n+                ExecBit::new_from_repo(executable, get_prev_exec)\n+            };",
        "comment_created_at": "2025-10-17T19:31:40+00:00",
        "comment_author": "isuffix",
        "comment_body": "Good catch, I'll update to treat as false on Windows and add a comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2302854560",
    "pr_number": 6990,
    "pr_file": "cli/src/commands/config/review_managed.rs",
    "created_at": "2025-08-27T05:17:35+00:00",
    "commented_code": "+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::borrow::Borrow as _;\n+use std::borrow::Cow;\n+\n+use tracing::instrument;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::command_error::CommandError;\n+use crate::command_error::internal_error_with_message;\n+use crate::command_error::user_error;\n+use crate::config::maybe_read_to_string;\n+use crate::merge_tools::make_diff_sections;\n+use crate::ui::Ui;\n+\n+/// Reviews and updates configuration stored in version control.\n+/// You should never need to run this command unless jj tells you to.\n+/// This command needs to be run when the config checked in to the repo is\n+/// changed, and allows you to approve or reject said changes on a line-by-line\n+/// basis.\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct ConfigReviewManagedArgs {\n+    /// Trust the repository's config and skip review of it.\n+    /// Use this when you absolutely trust the repo config (eg. you're the only\n+    /// contributor).\n+    #[arg(long)]\n+    trust: bool,\n+}\n+\n+#[instrument(skip_all)]\n+pub fn cmd_review_managed(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &ConfigReviewManagedArgs,\n+) -> Result<(), CommandError> {\n+    if let Some(paths) = command.config_env().repo_managed_config_paths() {\n+        // Treat an empty file the same as a nonexistent one.\n+        let vcs = maybe_read_to_string(&paths.managed)?.unwrap_or_else(String::new);\n+        let config = maybe_read_to_string(&paths.config)?.unwrap_or_else(String::new);",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2302854560",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 6990,
        "pr_file": "cli/src/commands/config/review_managed.rs",
        "discussion_id": "2302854560",
        "commented_code": "@@ -0,0 +1,127 @@\n+// Copyright 2025 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::borrow::Borrow as _;\n+use std::borrow::Cow;\n+\n+use tracing::instrument;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::command_error::CommandError;\n+use crate::command_error::internal_error_with_message;\n+use crate::command_error::user_error;\n+use crate::config::maybe_read_to_string;\n+use crate::merge_tools::make_diff_sections;\n+use crate::ui::Ui;\n+\n+/// Reviews and updates configuration stored in version control.\n+/// You should never need to run this command unless jj tells you to.\n+/// This command needs to be run when the config checked in to the repo is\n+/// changed, and allows you to approve or reject said changes on a line-by-line\n+/// basis.\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct ConfigReviewManagedArgs {\n+    /// Trust the repository's config and skip review of it.\n+    /// Use this when you absolutely trust the repo config (eg. you're the only\n+    /// contributor).\n+    #[arg(long)]\n+    trust: bool,\n+}\n+\n+#[instrument(skip_all)]\n+pub fn cmd_review_managed(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    args: &ConfigReviewManagedArgs,\n+) -> Result<(), CommandError> {\n+    if let Some(paths) = command.config_env().repo_managed_config_paths() {\n+        // Treat an empty file the same as a nonexistent one.\n+        let vcs = maybe_read_to_string(&paths.managed)?.unwrap_or_else(String::new);\n+        let config = maybe_read_to_string(&paths.config)?.unwrap_or_else(String::new);",
        "comment_created_at": "2025-08-27T05:17:35+00:00",
        "comment_author": "martinvonz",
        "comment_body": "nit: `unwrap_or_default()`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2349638674",
    "pr_number": 7245,
    "pr_file": "cli/src/commands/gerrit/upload.rs",
    "created_at": "2025-09-15T17:15:59+00:00",
    "commented_code": "+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+use std::io::Write as _;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use bstr::BStr;\n+use indexmap::IndexMap;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::commit::Commit;\n+use jj_lib::commit::CommitIteratorExt as _;\n+use jj_lib::git::GitRefUpdate;\n+use jj_lib::git::{self};\n+use jj_lib::object_id::ObjectId as _;\n+use jj_lib::repo::Repo as _;\n+use jj_lib::revset::RevsetExpression;\n+use jj_lib::settings::UserSettings;\n+use jj_lib::store::Store;\n+use jj_lib::trailer::Trailer;\n+use jj_lib::trailer::parse_description_trailers;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::cli_util::RevisionArg;\n+use crate::cli_util::short_commit_hash;\n+use crate::command_error::CommandError;\n+use crate::command_error::internal_error;\n+use crate::command_error::user_error;\n+use crate::command_error::user_error_with_hint;\n+use crate::command_error::user_error_with_message;\n+use crate::git_util::with_remote_git_callbacks;\n+use crate::ui::Ui;\n+\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct UploadArgs {\n+    /// The revset, selecting which revisions are sent in to Gerrit. This can be\n+    /// any arbitrary set of commits.\n+    /// Note that when you push a commit at the head of a stack, all ancestors\n+    /// are pushed too. This means that `jj gerrit upload -r foo` is equivalent\n+    /// to `jj gerrit upload -r 'mutable()::foo`\n+    #[arg(long, short = 'r')]\n+    revisions: Vec<RevisionArg>,\n+\n+    /// The location where your changes are intended to land. This should be\n+    /// an upstream branch.\n+    #[arg(long = \"remote-branch\", short = 'b')]\n+    remote_branch: Option<String>,\n+\n+    /// The Gerrit remote to push to. Can be configured with the `gerrit.remote`\n+    /// repository option as well. This is typically a full SSH URL for your\n+    /// Gerrit instance.\n+    #[arg(long)]\n+    remote: Option<String>,\n+\n+    /// If true, do not actually push the changes to Gerrit.\n+    #[arg(long = \"dry-run\", short = 'n')]\n+    dry_run: bool,\n+}\n+\n+/// calculate push remote. The logic is:\n+/// 1. If the user specifies `--remote`, use that\n+/// 2. If the user has 'gerrit.remote' configured, use that\n+/// 3. If there is a default push remote, use that\n+/// 4. If the user has a remote named 'gerrit', use that\n+/// 5. otherwise, bail out\n+fn calculate_push_remote(\n+    store: &Arc<Store>,\n+    config: &UserSettings,\n+    remote: Option<String>,\n+) -> Result<String, CommandError> {\n+    let git_repo = git::get_git_repo(store)?; // will fail if not a git repo\n+    let remotes = git_repo.remote_names();\n+\n+    // case 1\n+    if let Some(remote) = remote {\n+        if remotes.contains(BStr::new(&remote)) {\n+            return Ok(remote);\n+        }\n+        return Err(user_error(format!(\n+            \"The remote '{remote}' (specified via `--remote`) does not exist\",\n+        )));\n+    }\n+\n+    // case 2\n+    if let Ok(remote) = config.get_string(\"gerrit.default-remote\") {\n+        if remotes.contains(BStr::new(&remote)) {\n+            return Ok(remote);\n+        }\n+        return Err(user_error(format!(\n+            \"The remote '{remote}' (configured via `gerrit.default-remote`) does not exist\",\n+        )));\n+    }\n+\n+    // case 3\n+    if let Some(remote) = git_repo.remote_default_name(gix::remote::Direction::Push) {\n+        return Ok(remote.to_string());\n+    }\n+\n+    // case 4\n+    if remotes.iter().any(|r| **r == \"gerrit\") {\n+        return Ok(\"gerrit\".to_owned());\n+    }\n+\n+    // case 5\n+    Err(user_error(\n+        \"No remote specified, and no 'gerrit' remote was found\",\n+    ))\n+}\n+\n+/// Determine what Gerrit ref and remote to use. The logic is:\n+///\n+/// 1. If the user specifies `--remote-branch branch`, use that\n+/// 2. If the user has 'gerrit.default-remote-branch' configured, use that\n+/// 3. Otherwise, bail out\n+fn calculate_push_ref(\n+    config: &UserSettings,\n+    remote_branch: Option<String>,\n+) -> Result<String, CommandError> {\n+    // case 1\n+    if let Some(remote_branch) = remote_branch {\n+        return Ok(remote_branch);\n+    }\n+\n+    // case 2\n+    if let Ok(branch) = config.get_string(\"gerrit.default-remote-branch\") {\n+        return Ok(branch);\n+    }\n+\n+    // case 3\n+    Err(user_error(\n+        \"No target branch specified via --remote-branch, and no 'gerrit.default-remote-branch' \\\n+         was found\",\n+    ))\n+}\n+\n+pub fn cmd_upload(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    upload: &UploadArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+\n+    let revisions: Vec<_> = workspace_command\n+        .parse_union_revsets(ui, &upload.revisions)?\n+        .evaluate_to_commits()?\n+        .try_collect()?;\n+    if revisions.is_empty() {\n+        writeln!(ui.status(), \"No revisions to upload.\")?;\n+        return Ok(());\n+    }\n+\n+    if revisions\n+        .iter()\n+        .any(|commit| commit.id() == workspace_command.repo().store().root_commit_id())\n+    {\n+        return Err(user_error(\"Cannot upload the virtual 'root()' commit\"));\n+    }\n+\n+    workspace_command.check_rewritable(revisions.iter().ids())?;\n+\n+    // If you have the changes main -> A -> B, and then run `jj gerrit upload -r B`,\n+    // then that uploads both A and B. Thus, we need to ensure that A also\n+    // has a Change-ID.\n+    // We make an assumption here that all immutable commits already have a\n+    // Change-ID.\n+    let to_upload: Vec<Commit> = workspace_command\n+        .attach_revset_evaluator(\n+            // I'm unsure, but this *might* have significant performance\n+            // implications. If so, we can change it to a maximum depth.\n+            Rc::new(RevsetExpression::Difference(\n+                // Unfortunately, DagRange{root: immutable_heads, heads: commits}\n+                // doesn't work if you're, for example, working on top of an\n+                // immutable commit that isn't in immutable_heads().\n+                Rc::new(RevsetExpression::Ancestors {\n+                    heads: RevsetExpression::commits(\n+                        revisions.iter().ids().cloned().collect::<Vec<_>>(),\n+                    ),\n+                    generation: jj_lib::revset::GENERATION_RANGE_FULL,\n+                    parents_range: jj_lib::revset::PARENTS_RANGE_FULL,\n+                }),\n+                workspace_command.env().immutable_expression().clone(),\n+            )),\n+        )\n+        .evaluate_to_commits()?\n+        .try_collect()?;\n+\n+    let mut tx = workspace_command.start_transaction();\n+    let base_repo = tx.base_repo().clone();\n+    let store = base_repo.store();\n+\n+    let old_heads = base_repo\n+        .index()\n+        .heads(&mut revisions.iter().ids())\n+        .map_err(internal_error)?;\n+\n+    let git_settings = command.settings().git_settings()?;\n+    let remote = calculate_push_remote(store, command.settings(), upload.remote.clone())?;\n+    let remote_branch = calculate_push_ref(command.settings(), upload.remote_branch.clone())?;\n+\n+    // immediately error and reject any discardable commits, i.e. the\n+    // the empty wcc\n+    for commit in &to_upload {\n+        if commit.is_discardable(tx.repo_mut())? {\n+            return Err(user_error_with_hint(\n+                format!(\n+                    \"Refusing to upload commit {} because it is an empty commit with no \\\n+                     description\",\n+                    short_commit_hash(commit.id())\n+                ),\n+                \"Perhaps you squashed then ran upload? Maybe you meant to upload the parent \\\n+                 commit instead (eg. @-)\",\n+            ));\n+        }\n+    }\n+\n+    let mut old_to_new: IndexMap<CommitId, Commit> = IndexMap::new();\n+    for commit_id in to_upload.iter().map(|c| c.id()).rev() {\n+        let original_commit = store.get_commit(commit_id).unwrap();\n+        let description = original_commit.description().to_owned();\n+        let trailers = parse_description_trailers(&description);\n+\n+        let change_id_trailers: Vec<&Trailer> = trailers\n+            .iter()\n+            .filter(|trailer| trailer.key == \"Change-Id\")\n+            .collect();\n+\n+        // There shouldn't be multiple change-ID fields. So just error out if\n+        // there is.\n+        if change_id_trailers.len() > 1 {\n+            return Err(user_error(format!(\n+                \"multiple Change-Id footers in commit {}\",\n+                short_commit_hash(commit_id)\n+            )));\n+        }\n+\n+        // The user can choose to explicitly set their own change-ID to\n+        // override the default change-ID based on the jj change-ID.\n+        if let Some(trailer) = change_id_trailers.first() {\n+            // Check the change-id format is correct.\n+            if trailer.value.len() != 41 || !trailer.value.starts_with('I') {\n+                // Intentionally leave the invalid change IDs as-is.\n+                writeln!(\n+                    ui.warning_default(),\n+                    \"warning: invalid Change-Id footer in commit {}\",\n+                    short_commit_hash(original_commit.id()),\n+                )?;\n+            }\n+\n+            // map the old commit to itself\n+            old_to_new.insert(original_commit.id().clone(), original_commit.clone());\n+            continue;\n+        }\n+\n+        // Gerrit change id is 40 chars, jj change id is 32, so we need padding.\n+        // To be consistent with `format_gerrit_change_id_trailer``, we pad with\n+        // 6a6a6964 (hex of \"jjid\").\n+        let gerrit_change_id = format!(\"I6a6a6964{}\", original_commit.change_id().hex());\n+\n+        let new_description = format!(\n+            \"{}{}Change-Id: {}\n\",\n+            description.trim(),\n+            if trailers.is_empty() { \"\n\n\" } else { \"\n\" },\n+            gerrit_change_id\n+        );\n+\n+        let new_parents = original_commit\n+            .parents()\n+            .map(|parent| {\n+                let p = parent.unwrap();\n+                if let Some(rewritten_parent) = old_to_new.get(p.id()) {\n+                    rewritten_parent\n+                } else {\n+                    &p\n+                }",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2349638674",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7245,
        "pr_file": "cli/src/commands/gerrit/upload.rs",
        "discussion_id": "2349638674",
        "commented_code": "@@ -0,0 +1,389 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+use std::io::Write as _;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use bstr::BStr;\n+use indexmap::IndexMap;\n+use itertools::Itertools as _;\n+use jj_lib::backend::CommitId;\n+use jj_lib::commit::Commit;\n+use jj_lib::commit::CommitIteratorExt as _;\n+use jj_lib::git::GitRefUpdate;\n+use jj_lib::git::{self};\n+use jj_lib::object_id::ObjectId as _;\n+use jj_lib::repo::Repo as _;\n+use jj_lib::revset::RevsetExpression;\n+use jj_lib::settings::UserSettings;\n+use jj_lib::store::Store;\n+use jj_lib::trailer::Trailer;\n+use jj_lib::trailer::parse_description_trailers;\n+\n+use crate::cli_util::CommandHelper;\n+use crate::cli_util::RevisionArg;\n+use crate::cli_util::short_commit_hash;\n+use crate::command_error::CommandError;\n+use crate::command_error::internal_error;\n+use crate::command_error::user_error;\n+use crate::command_error::user_error_with_hint;\n+use crate::command_error::user_error_with_message;\n+use crate::git_util::with_remote_git_callbacks;\n+use crate::ui::Ui;\n+\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct UploadArgs {\n+    /// The revset, selecting which revisions are sent in to Gerrit. This can be\n+    /// any arbitrary set of commits.\n+    /// Note that when you push a commit at the head of a stack, all ancestors\n+    /// are pushed too. This means that `jj gerrit upload -r foo` is equivalent\n+    /// to `jj gerrit upload -r 'mutable()::foo`\n+    #[arg(long, short = 'r')]\n+    revisions: Vec<RevisionArg>,\n+\n+    /// The location where your changes are intended to land. This should be\n+    /// an upstream branch.\n+    #[arg(long = \"remote-branch\", short = 'b')]\n+    remote_branch: Option<String>,\n+\n+    /// The Gerrit remote to push to. Can be configured with the `gerrit.remote`\n+    /// repository option as well. This is typically a full SSH URL for your\n+    /// Gerrit instance.\n+    #[arg(long)]\n+    remote: Option<String>,\n+\n+    /// If true, do not actually push the changes to Gerrit.\n+    #[arg(long = \"dry-run\", short = 'n')]\n+    dry_run: bool,\n+}\n+\n+/// calculate push remote. The logic is:\n+/// 1. If the user specifies `--remote`, use that\n+/// 2. If the user has 'gerrit.remote' configured, use that\n+/// 3. If there is a default push remote, use that\n+/// 4. If the user has a remote named 'gerrit', use that\n+/// 5. otherwise, bail out\n+fn calculate_push_remote(\n+    store: &Arc<Store>,\n+    config: &UserSettings,\n+    remote: Option<String>,\n+) -> Result<String, CommandError> {\n+    let git_repo = git::get_git_repo(store)?; // will fail if not a git repo\n+    let remotes = git_repo.remote_names();\n+\n+    // case 1\n+    if let Some(remote) = remote {\n+        if remotes.contains(BStr::new(&remote)) {\n+            return Ok(remote);\n+        }\n+        return Err(user_error(format!(\n+            \"The remote '{remote}' (specified via `--remote`) does not exist\",\n+        )));\n+    }\n+\n+    // case 2\n+    if let Ok(remote) = config.get_string(\"gerrit.default-remote\") {\n+        if remotes.contains(BStr::new(&remote)) {\n+            return Ok(remote);\n+        }\n+        return Err(user_error(format!(\n+            \"The remote '{remote}' (configured via `gerrit.default-remote`) does not exist\",\n+        )));\n+    }\n+\n+    // case 3\n+    if let Some(remote) = git_repo.remote_default_name(gix::remote::Direction::Push) {\n+        return Ok(remote.to_string());\n+    }\n+\n+    // case 4\n+    if remotes.iter().any(|r| **r == \"gerrit\") {\n+        return Ok(\"gerrit\".to_owned());\n+    }\n+\n+    // case 5\n+    Err(user_error(\n+        \"No remote specified, and no 'gerrit' remote was found\",\n+    ))\n+}\n+\n+/// Determine what Gerrit ref and remote to use. The logic is:\n+///\n+/// 1. If the user specifies `--remote-branch branch`, use that\n+/// 2. If the user has 'gerrit.default-remote-branch' configured, use that\n+/// 3. Otherwise, bail out\n+fn calculate_push_ref(\n+    config: &UserSettings,\n+    remote_branch: Option<String>,\n+) -> Result<String, CommandError> {\n+    // case 1\n+    if let Some(remote_branch) = remote_branch {\n+        return Ok(remote_branch);\n+    }\n+\n+    // case 2\n+    if let Ok(branch) = config.get_string(\"gerrit.default-remote-branch\") {\n+        return Ok(branch);\n+    }\n+\n+    // case 3\n+    Err(user_error(\n+        \"No target branch specified via --remote-branch, and no 'gerrit.default-remote-branch' \\\n+         was found\",\n+    ))\n+}\n+\n+pub fn cmd_upload(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    upload: &UploadArgs,\n+) -> Result<(), CommandError> {\n+    let mut workspace_command = command.workspace_helper(ui)?;\n+\n+    let revisions: Vec<_> = workspace_command\n+        .parse_union_revsets(ui, &upload.revisions)?\n+        .evaluate_to_commits()?\n+        .try_collect()?;\n+    if revisions.is_empty() {\n+        writeln!(ui.status(), \"No revisions to upload.\")?;\n+        return Ok(());\n+    }\n+\n+    if revisions\n+        .iter()\n+        .any(|commit| commit.id() == workspace_command.repo().store().root_commit_id())\n+    {\n+        return Err(user_error(\"Cannot upload the virtual 'root()' commit\"));\n+    }\n+\n+    workspace_command.check_rewritable(revisions.iter().ids())?;\n+\n+    // If you have the changes main -> A -> B, and then run `jj gerrit upload -r B`,\n+    // then that uploads both A and B. Thus, we need to ensure that A also\n+    // has a Change-ID.\n+    // We make an assumption here that all immutable commits already have a\n+    // Change-ID.\n+    let to_upload: Vec<Commit> = workspace_command\n+        .attach_revset_evaluator(\n+            // I'm unsure, but this *might* have significant performance\n+            // implications. If so, we can change it to a maximum depth.\n+            Rc::new(RevsetExpression::Difference(\n+                // Unfortunately, DagRange{root: immutable_heads, heads: commits}\n+                // doesn't work if you're, for example, working on top of an\n+                // immutable commit that isn't in immutable_heads().\n+                Rc::new(RevsetExpression::Ancestors {\n+                    heads: RevsetExpression::commits(\n+                        revisions.iter().ids().cloned().collect::<Vec<_>>(),\n+                    ),\n+                    generation: jj_lib::revset::GENERATION_RANGE_FULL,\n+                    parents_range: jj_lib::revset::PARENTS_RANGE_FULL,\n+                }),\n+                workspace_command.env().immutable_expression().clone(),\n+            )),\n+        )\n+        .evaluate_to_commits()?\n+        .try_collect()?;\n+\n+    let mut tx = workspace_command.start_transaction();\n+    let base_repo = tx.base_repo().clone();\n+    let store = base_repo.store();\n+\n+    let old_heads = base_repo\n+        .index()\n+        .heads(&mut revisions.iter().ids())\n+        .map_err(internal_error)?;\n+\n+    let git_settings = command.settings().git_settings()?;\n+    let remote = calculate_push_remote(store, command.settings(), upload.remote.clone())?;\n+    let remote_branch = calculate_push_ref(command.settings(), upload.remote_branch.clone())?;\n+\n+    // immediately error and reject any discardable commits, i.e. the\n+    // the empty wcc\n+    for commit in &to_upload {\n+        if commit.is_discardable(tx.repo_mut())? {\n+            return Err(user_error_with_hint(\n+                format!(\n+                    \"Refusing to upload commit {} because it is an empty commit with no \\\n+                     description\",\n+                    short_commit_hash(commit.id())\n+                ),\n+                \"Perhaps you squashed then ran upload? Maybe you meant to upload the parent \\\n+                 commit instead (eg. @-)\",\n+            ));\n+        }\n+    }\n+\n+    let mut old_to_new: IndexMap<CommitId, Commit> = IndexMap::new();\n+    for commit_id in to_upload.iter().map(|c| c.id()).rev() {\n+        let original_commit = store.get_commit(commit_id).unwrap();\n+        let description = original_commit.description().to_owned();\n+        let trailers = parse_description_trailers(&description);\n+\n+        let change_id_trailers: Vec<&Trailer> = trailers\n+            .iter()\n+            .filter(|trailer| trailer.key == \"Change-Id\")\n+            .collect();\n+\n+        // There shouldn't be multiple change-ID fields. So just error out if\n+        // there is.\n+        if change_id_trailers.len() > 1 {\n+            return Err(user_error(format!(\n+                \"multiple Change-Id footers in commit {}\",\n+                short_commit_hash(commit_id)\n+            )));\n+        }\n+\n+        // The user can choose to explicitly set their own change-ID to\n+        // override the default change-ID based on the jj change-ID.\n+        if let Some(trailer) = change_id_trailers.first() {\n+            // Check the change-id format is correct.\n+            if trailer.value.len() != 41 || !trailer.value.starts_with('I') {\n+                // Intentionally leave the invalid change IDs as-is.\n+                writeln!(\n+                    ui.warning_default(),\n+                    \"warning: invalid Change-Id footer in commit {}\",\n+                    short_commit_hash(original_commit.id()),\n+                )?;\n+            }\n+\n+            // map the old commit to itself\n+            old_to_new.insert(original_commit.id().clone(), original_commit.clone());\n+            continue;\n+        }\n+\n+        // Gerrit change id is 40 chars, jj change id is 32, so we need padding.\n+        // To be consistent with `format_gerrit_change_id_trailer``, we pad with\n+        // 6a6a6964 (hex of \"jjid\").\n+        let gerrit_change_id = format!(\"I6a6a6964{}\", original_commit.change_id().hex());\n+\n+        let new_description = format!(\n+            \"{}{}Change-Id: {}\\n\",\n+            description.trim(),\n+            if trailers.is_empty() { \"\\n\\n\" } else { \"\\n\" },\n+            gerrit_change_id\n+        );\n+\n+        let new_parents = original_commit\n+            .parents()\n+            .map(|parent| {\n+                let p = parent.unwrap();\n+                if let Some(rewritten_parent) = old_to_new.get(p.id()) {\n+                    rewritten_parent\n+                } else {\n+                    &p\n+                }",
        "comment_created_at": "2025-09-15T17:15:59+00:00",
        "comment_author": "martinvonz",
        "comment_body": "Can be written as `old_to_new.get(p.id()).unwrap_or(&p)`?",
        "pr_file_module": null
      }
    ]
  }
]