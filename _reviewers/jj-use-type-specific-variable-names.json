[
  {
    "discussion_id": "2442241108",
    "pr_number": 7742,
    "pr_file": "lib/src/local_working_copy.rs",
    "created_at": "2025-10-18T11:24:49+00:00",
    "commented_code": "}\n         },\n     };\n-    reject_reserved_existing_path(disk_path).inspect_err(|_| {\n-        if new_file_created {\n-            fs::remove_file(disk_path).ok();\n-        }\n-    })?;\n-    if new_file_created {\n+\n+    let new_file_created = new_file.is_some();\n+\n+    if let Some(new_file) = new_file {\n+        reject_reserved_existing_file(new_file, disk_path).inspect_err(|_| {\n+            // We keep the error from `reject_reserved_existing_file`\n+            let _ = fs::remove_file(disk_path);\n+        })?;\n+\n         fs::remove_file(disk_path).map_err(|err| CheckoutError::Other {\n             message: format!(\"Failed to remove temporary file {}\", disk_path.display()),\n             err: err.into(),\n         })?;\n+    } else {\n+        reject_reserved_existing_path(disk_path)?;\n     }\n     Ok(new_file_created)\n }\n \n const RESERVED_DIR_NAMES: &[&str] = &[\".git\", \".jj\"];\n \n+/// Maps the result from constructing a `same_file::Handle` so that\n+/// we get either an `Option<same_file::Handle>` which may be `None`\n+/// if the file doesn't exist, or a `CheckoutError` indicating the\n+/// error encountered when attempting to construct the `Handle`\n+fn same_file_handle_from_path(disk_path: &Path) -> Result<Option<same_file::Handle>, io::Error> {\n+    match same_file::Handle::from_path(disk_path) {\n+        Ok(val) => Ok(Some(val)),",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2442241108",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7742,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2442241108",
        "commented_code": "@@ -640,47 +640,114 @@ fn can_create_new_file(disk_path: &Path) -> Result<bool, CheckoutError> {\n             }\n         },\n     };\n-    reject_reserved_existing_path(disk_path).inspect_err(|_| {\n-        if new_file_created {\n-            fs::remove_file(disk_path).ok();\n-        }\n-    })?;\n-    if new_file_created {\n+\n+    let new_file_created = new_file.is_some();\n+\n+    if let Some(new_file) = new_file {\n+        reject_reserved_existing_file(new_file, disk_path).inspect_err(|_| {\n+            // We keep the error from `reject_reserved_existing_file`\n+            let _ = fs::remove_file(disk_path);\n+        })?;\n+\n         fs::remove_file(disk_path).map_err(|err| CheckoutError::Other {\n             message: format!(\"Failed to remove temporary file {}\", disk_path.display()),\n             err: err.into(),\n         })?;\n+    } else {\n+        reject_reserved_existing_path(disk_path)?;\n     }\n     Ok(new_file_created)\n }\n \n const RESERVED_DIR_NAMES: &[&str] = &[\".git\", \".jj\"];\n \n+/// Maps the result from constructing a `same_file::Handle` so that\n+/// we get either an `Option<same_file::Handle>` which may be `None`\n+/// if the file doesn't exist, or a `CheckoutError` indicating the\n+/// error encountered when attempting to construct the `Handle`\n+fn same_file_handle_from_path(disk_path: &Path) -> Result<Option<same_file::Handle>, io::Error> {\n+    match same_file::Handle::from_path(disk_path) {\n+        Ok(val) => Ok(Some(val)),",
        "comment_created_at": "2025-10-18T11:24:49+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: `val` -> `handle`? `val` sounds like a pure value like fd number.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2343853270",
    "pr_number": 7484,
    "pr_file": "lib/src/local_working_copy.rs",
    "created_at": "2025-09-12T10:59:17+00:00",
    "commented_code": "// TODO: maybe better to preserve the executable bit on all platforms, and\n // ignore conditionally? #3949\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub struct FileExecutableFlag(#[cfg(unix)] bool);\n+pub struct ExecBit(#[cfg(unix)] bool);",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2343853270",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2343853270",
        "commented_code": "@@ -130,10 +130,10 @@ use crate::working_copy::WorkingCopyStateError;\n // TODO: maybe better to preserve the executable bit on all platforms, and\n // ignore conditionally? #3949\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub struct FileExecutableFlag(#[cfg(unix)] bool);\n+pub struct ExecBit(#[cfg(unix)] bool);",
        "comment_created_at": "2025-09-12T10:59:17+00:00",
        "comment_author": "yuja",
        "comment_body": "> working_copy: Rename FileExecutableFlag to ExecBit\r\n\r\nCan you include the intent in the commit message? I think both names are good, so I don't see a strong motivation for the rename.",
        "pr_file_module": null
      },
      {
        "comment_id": "2353482502",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2343853270",
        "commented_code": "@@ -130,10 +130,10 @@ use crate::working_copy::WorkingCopyStateError;\n // TODO: maybe better to preserve the executable bit on all platforms, and\n // ignore conditionally? #3949\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub struct FileExecutableFlag(#[cfg(unix)] bool);\n+pub struct ExecBit(#[cfg(unix)] bool);",
        "comment_created_at": "2025-09-16T19:40:02+00:00",
        "comment_author": "isuffix",
        "comment_body": "I'll update the commit description based on discussion in this thread since I assume you'll have thoughts.\r\n\r\nHere's a draft of my reasons for the renaming:\r\n\r\n1. `ExecBit` is fewer characters and far fewer syllables than `FileExecutableFlag`. This makes code more legible: both easier to mentally parse and quicker to type.\r\n\r\n2. `File` in the name is unnecessary. `ExecBit` is already stored in the `FileType` inside the `FileState`, and the doc comment clarifies that it's the state for a file if you were unsure.\r\n\r\n3. I don't care about the `Flag` vs. `Bit` part of the name. I'd be fine with `ExecFlag`/`exec_flag` instead if you prefer.\r\n\r\n4. Most importantly, this solves the reuse of the `executable` name for variables that are both booleans and `FileExecutableFlag`. Using the same name for variables of different types gets confusing and caused me headaches keeping track of the source of values as they pass through the functions. Besides just renaming the type, this commit also adjusts variable names so we consistently name `ExecBit` variables `exec_bit` and boolean variables `executable`.\r\n\r\nIt would be worthwhile to make a commit just for the final point, but it gives us an excuse to rename the type as well to improve the first two points.",
        "pr_file_module": null
      },
      {
        "comment_id": "2354584301",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2343853270",
        "commented_code": "@@ -130,10 +130,10 @@ use crate::working_copy::WorkingCopyStateError;\n // TODO: maybe better to preserve the executable bit on all platforms, and\n // ignore conditionally? #3949\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub struct FileExecutableFlag(#[cfg(unix)] bool);\n+pub struct ExecBit(#[cfg(unix)] bool);",
        "comment_created_at": "2025-09-17T07:29:56+00:00",
        "comment_author": "yuja",
        "comment_body": "The purpose of the `File` prefix was to clarify that `FileExecutableFlag` is NOT the executable flag stored in the backend `TreeValue`. We shouldn't compare `TreeValue`'s executable flag with `FileExecutableFlag`.\r\n\r\nI don't care much about `Exec` vs `Executable` and `Flag` vs `Bit`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2427350105",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7484,
        "pr_file": "lib/src/local_working_copy.rs",
        "discussion_id": "2343853270",
        "commented_code": "@@ -130,10 +130,10 @@ use crate::working_copy::WorkingCopyStateError;\n // TODO: maybe better to preserve the executable bit on all platforms, and\n // ignore conditionally? #3949\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub struct FileExecutableFlag(#[cfg(unix)] bool);\n+pub struct ExecBit(#[cfg(unix)] bool);",
        "comment_created_at": "2025-10-13T21:20:12+00:00",
        "comment_author": "isuffix",
        "comment_body": "I'm updating the commit message to this. Feel free to unresolve if you would like changes.\r\n\r\n```\r\nworking_copy: Rename `FileExecutableFlag` to `ExecBit` and update variables\r\n\r\nThe main reason for this change is that we now give variables different names\r\nbased on their types. This helps avoid confusion and makes intent clearer.\r\nHowever, the type name `FileExecutableFlag` doesn't have a good shortening\r\n(`file_exec_flag` is annoyingly long), so I also renamed the type to something\r\nshorter, which makes the code more legible: easier to mentally parse and\r\nquicker to type.\r\n\r\nI removed `File` from the name both for length and because it doesn't really\r\nhelp distinguish from the executable field in `TreeValue` (because that field\r\nis nested under `TreeValue::File`). Instead, in the upcoming commits I update\r\ncomments to use the terms 'on-disk' and 'in-repo' to respectively refer to the\r\nexecutable fields in `FileState` and `TreeValue`, which I personally find\r\nbetter at keeping the difference clear.\r\n\r\nI went with `Bit` in the new name just because I'm already changing it and I\r\nprefer `exec_bit` slightly over `exec_flag` as the variable name.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460280571",
    "pr_number": 2845,
    "pr_file": "cli/src/commands/gerrit.rs",
    "created_at": "2024-01-20T07:35:25+00:00",
    "commented_code": "+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+\n+use clap::Subcommand;\n+use indexmap::IndexSet;\n+use jj_lib::commit::Commit;\n+use jj_lib::repo::Repo;\n+\n+use crate::cli_util::{\n+    get_git_repo, resolve_multiple_nonempty_revsets, user_error, CommandError, CommandHelper,\n+    RevisionArg,\n+};\n+use crate::ui::Ui;\n+\n+/// Interact with Gerrit Code Review.\n+#[derive(Subcommand, Clone, Debug)]\n+pub enum GerritCommand {\n+    /// \"Mail in\" a revision to Gerrit; this is the primary way to create\n+    /// changes or update changes for code review.\n+    ///\n+    /// This command modifies each commit in the revset to include a `Change-Id`\n+    /// footer in its commit message if one does not already exist. This ID is\n+    /// NOT compatible with jj IDs, and is a Gerrit-specific ID.\n+    ///\n+    /// Note: this command takes a revset as an argument, and will mail in all\n+    /// revisions in the revset to Gerrit appropriately, so you may post trees\n+    /// or ranges of commits to Gerrit for review.\n+    ///\n+    /// Note: this command does not actually send an email or use a Mail\n+    /// Transfer Agent, but rather uploads the revision to Gerrit for review\n+    /// through underlying Git logic. The term \"mail\" is used to disambiguate\n+    /// from the word \"submit\", which is what Gerrit calls \"merging an approved\n+    /// change into a target branch\", and is used to refer to the concept of\n+    /// \"mailing in\" something to be read by someone else.\n+    Mail(MailCommand),\n+}\n+\n+pub fn cmd_gerrit(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    subcommand: &GerritCommand,\n+) -> Result<(), CommandError> {\n+    match subcommand {\n+        GerritCommand::Mail(review) => {\n+            cmd_mail(ui, command, review)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct MailCommand {\n+    /// The revset, selecting which commits are mailed in to Gerrit. This can be\n+    /// any arbitrary set of commits; they will be modified to include a\n+    /// `Change-Id` footer if one does not already exist, and then mailed off to\n+    /// Gerrit for review.\n+    #[arg(long, short = 'r')]\n+    revision: Vec<RevisionArg>,\n+\n+    /// The origin where your changes will be sent. This MUST be a reference of",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "1460280571",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "cli/src/commands/gerrit.rs",
        "discussion_id": "1460280571",
        "commented_code": "@@ -0,0 +1,137 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+\n+use clap::Subcommand;\n+use indexmap::IndexSet;\n+use jj_lib::commit::Commit;\n+use jj_lib::repo::Repo;\n+\n+use crate::cli_util::{\n+    get_git_repo, resolve_multiple_nonempty_revsets, user_error, CommandError, CommandHelper,\n+    RevisionArg,\n+};\n+use crate::ui::Ui;\n+\n+/// Interact with Gerrit Code Review.\n+#[derive(Subcommand, Clone, Debug)]\n+pub enum GerritCommand {\n+    /// \"Mail in\" a revision to Gerrit; this is the primary way to create\n+    /// changes or update changes for code review.\n+    ///\n+    /// This command modifies each commit in the revset to include a `Change-Id`\n+    /// footer in its commit message if one does not already exist. This ID is\n+    /// NOT compatible with jj IDs, and is a Gerrit-specific ID.\n+    ///\n+    /// Note: this command takes a revset as an argument, and will mail in all\n+    /// revisions in the revset to Gerrit appropriately, so you may post trees\n+    /// or ranges of commits to Gerrit for review.\n+    ///\n+    /// Note: this command does not actually send an email or use a Mail\n+    /// Transfer Agent, but rather uploads the revision to Gerrit for review\n+    /// through underlying Git logic. The term \"mail\" is used to disambiguate\n+    /// from the word \"submit\", which is what Gerrit calls \"merging an approved\n+    /// change into a target branch\", and is used to refer to the concept of\n+    /// \"mailing in\" something to be read by someone else.\n+    Mail(MailCommand),\n+}\n+\n+pub fn cmd_gerrit(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    subcommand: &GerritCommand,\n+) -> Result<(), CommandError> {\n+    match subcommand {\n+        GerritCommand::Mail(review) => {\n+            cmd_mail(ui, command, review)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct MailCommand {\n+    /// The revset, selecting which commits are mailed in to Gerrit. This can be\n+    /// any arbitrary set of commits; they will be modified to include a\n+    /// `Change-Id` footer if one does not already exist, and then mailed off to\n+    /// Gerrit for review.\n+    #[arg(long, short = 'r')]\n+    revision: Vec<RevisionArg>,\n+\n+    /// The origin where your changes will be sent. This MUST be a reference of",
        "comment_created_at": "2024-01-20T07:35:25+00:00",
        "comment_author": "martinvonz",
        "comment_body": "I was going to say that we should replace \"origin\" by \"remote\", but that's not quite right either. How about \"The remote branch to your changes are meant for.\" or something like that (feel free to reword)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1460684532",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 2845,
        "pr_file": "cli/src/commands/gerrit.rs",
        "discussion_id": "1460280571",
        "commented_code": "@@ -0,0 +1,137 @@\n+// Copyright 2024 The Jujutsu Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// https://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+use std::fmt::Debug;\n+\n+use clap::Subcommand;\n+use indexmap::IndexSet;\n+use jj_lib::commit::Commit;\n+use jj_lib::repo::Repo;\n+\n+use crate::cli_util::{\n+    get_git_repo, resolve_multiple_nonempty_revsets, user_error, CommandError, CommandHelper,\n+    RevisionArg,\n+};\n+use crate::ui::Ui;\n+\n+/// Interact with Gerrit Code Review.\n+#[derive(Subcommand, Clone, Debug)]\n+pub enum GerritCommand {\n+    /// \"Mail in\" a revision to Gerrit; this is the primary way to create\n+    /// changes or update changes for code review.\n+    ///\n+    /// This command modifies each commit in the revset to include a `Change-Id`\n+    /// footer in its commit message if one does not already exist. This ID is\n+    /// NOT compatible with jj IDs, and is a Gerrit-specific ID.\n+    ///\n+    /// Note: this command takes a revset as an argument, and will mail in all\n+    /// revisions in the revset to Gerrit appropriately, so you may post trees\n+    /// or ranges of commits to Gerrit for review.\n+    ///\n+    /// Note: this command does not actually send an email or use a Mail\n+    /// Transfer Agent, but rather uploads the revision to Gerrit for review\n+    /// through underlying Git logic. The term \"mail\" is used to disambiguate\n+    /// from the word \"submit\", which is what Gerrit calls \"merging an approved\n+    /// change into a target branch\", and is used to refer to the concept of\n+    /// \"mailing in\" something to be read by someone else.\n+    Mail(MailCommand),\n+}\n+\n+pub fn cmd_gerrit(\n+    ui: &mut Ui,\n+    command: &CommandHelper,\n+    subcommand: &GerritCommand,\n+) -> Result<(), CommandError> {\n+    match subcommand {\n+        GerritCommand::Mail(review) => {\n+            cmd_mail(ui, command, review)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+#[derive(clap::Args, Clone, Debug)]\n+pub struct MailCommand {\n+    /// The revset, selecting which commits are mailed in to Gerrit. This can be\n+    /// any arbitrary set of commits; they will be modified to include a\n+    /// `Change-Id` footer if one does not already exist, and then mailed off to\n+    /// Gerrit for review.\n+    #[arg(long, short = 'r')]\n+    revision: Vec<RevisionArg>,\n+\n+    /// The origin where your changes will be sent. This MUST be a reference of",
        "comment_created_at": "2024-01-20T22:29:39+00:00",
        "comment_author": "thoughtpolice",
        "comment_body": "I made it \"The location where your changes are intended to land.\" Does that make sense?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2352226127",
    "pr_number": 7506,
    "pr_file": "cli/src/commands/git/remote/set_url.rs",
    "created_at": "2025-09-16T12:00:05+00:00",
    "commented_code": "/// The remote's name\n     #[arg(add = ArgValueCandidates::new(complete::git_remotes))]\n     remote: RemoteNameBuf,\n-    /// The desired URL or path for `remote`\n+    /// The desired fetch URL or path for `remote`\n+    ///\n+    /// This is a short form, equivalent to using the explicit --fetch.\n     ///\n     /// Local path will be resolved to absolute form.\n     #[arg(value_hint = clap::ValueHint::Url)]\n-    url: String,\n+    url: Option<String>,\n+\n+    /// The URL to push the remote to",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2352226127",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7506,
        "pr_file": "cli/src/commands/git/remote/set_url.rs",
        "discussion_id": "2352226127",
        "commented_code": "@@ -29,11 +29,25 @@ pub struct GitRemoteSetUrlArgs {\n     /// The remote's name\n     #[arg(add = ArgValueCandidates::new(complete::git_remotes))]\n     remote: RemoteNameBuf,\n-    /// The desired URL or path for `remote`\n+    /// The desired fetch URL or path for `remote`\n+    ///\n+    /// This is a short form, equivalent to using the explicit --fetch.\n     ///\n     /// Local path will be resolved to absolute form.\n     #[arg(value_hint = clap::ValueHint::Url)]\n-    url: String,\n+    url: Option<String>,\n+\n+    /// The URL to push the remote to",
        "comment_created_at": "2025-09-16T12:00:05+00:00",
        "comment_author": "yuja",
        "comment_body": "nit: I'm not pretty sure, but maybe this should say \"The remote URL to push to\"?\r\n\r\n\"The URL to push the remote to\" sounds like \"the remote\" will be pushed to \"the URL\".",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2338309979",
    "pr_number": 7481,
    "pr_file": "cli/src/commands/metaedit.rs",
    "created_at": "2025-09-11T01:52:32+00:00",
    "commented_code": ".transform_descendants(commit_ids, async |rewriter| {\n             if commit_ids_set.contains(rewriter.old_commit().id()) {\n                 let mut has_changes = args.update_committer_timestamp || rewriter.parents_changed();\n+                let old_author = rewriter.old_commit().author().clone();",
    "repo_full_name": "jj-vcs/jj",
    "discussion_comments": [
      {
        "comment_id": "2338309979",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7481,
        "pr_file": "cli/src/commands/metaedit.rs",
        "discussion_id": "2338309979",
        "commented_code": "@@ -153,6 +153,7 @@ pub(crate) fn cmd_metaedit(\n         .transform_descendants(commit_ids, async |rewriter| {\n             if commit_ids_set.contains(rewriter.old_commit().id()) {\n                 let mut has_changes = args.update_committer_timestamp || rewriter.parents_changed();\n+                let old_author = rewriter.old_commit().author().clone();",
        "comment_created_at": "2025-09-11T01:52:32+00:00",
        "comment_author": "yuja",
        "comment_body": "Doesn't it make `jj metaedit` (without `--update-author`) update author if the commit was empty? Author timestamp is renewed if the commit was discardable.\r\n\r\nAnother minor problem is that `jj metaedit` (without `--update-author`) can also rewrite commits if author name/user was previously empty, but that might be okay because empty author name/email is unusual.",
        "pr_file_module": null
      },
      {
        "comment_id": "2339258207",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7481,
        "pr_file": "cli/src/commands/metaedit.rs",
        "discussion_id": "2338309979",
        "commented_code": "@@ -153,6 +153,7 @@ pub(crate) fn cmd_metaedit(\n         .transform_descendants(commit_ids, async |rewriter| {\n             if commit_ids_set.contains(rewriter.old_commit().id()) {\n                 let mut has_changes = args.update_committer_timestamp || rewriter.parents_changed();\n+                let old_author = rewriter.old_commit().author().clone();",
        "comment_created_at": "2025-09-11T07:56:35+00:00",
        "comment_author": "senekor",
        "comment_body": "You're right, I hadn't thought about that. Comparing only `.name` and `.email` seems to fix it. But it also changes the snapshots of some other tests, I have to check if that's not a regression.",
        "pr_file_module": null
      },
      {
        "comment_id": "2339351452",
        "repo_full_name": "jj-vcs/jj",
        "pr_number": 7481,
        "pr_file": "cli/src/commands/metaedit.rs",
        "discussion_id": "2338309979",
        "commented_code": "@@ -153,6 +153,7 @@ pub(crate) fn cmd_metaedit(\n         .transform_descendants(commit_ids, async |rewriter| {\n             if commit_ids_set.contains(rewriter.old_commit().id()) {\n                 let mut has_changes = args.update_committer_timestamp || rewriter.parents_changed();\n+                let old_author = rewriter.old_commit().author().clone();",
        "comment_created_at": "2025-09-11T08:15:01+00:00",
        "comment_author": "senekor",
        "comment_body": "Alright, so there was a regression when I didn't compare the timestamp at all. But comparing the new timestamp to the commit builder timestamp seems to be correct.",
        "pr_file_module": null
      }
    ]
  }
]