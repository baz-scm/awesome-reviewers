[
  {
    "discussion_id": "2216310832",
    "pr_number": 20103,
    "pr_file": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala",
    "created_at": "2025-07-18T15:14:16+00:00",
    "commented_code": "}\n     } finally {\n       consumerSet.foreach(consumer => Utils.closeQuietly(consumer, \"consumer\"))\n-      Utils.closeQuietly(producer, \"producer\")\n+      Utils.closeQuietly(client, \"adminClient\")\n+    }\n+  }\n+\n+  @Test\n+  def testDeleteShareGroupOffsets(): Unit = {\n+    val config = createConfig\n+    client = Admin.create(config)\n+    val testTopicName = \"test_topic\"\n+    val testGroupId = \"test_group_id\"\n+    val testClientId = \"test_client_id\"\n+    val fakeGroupId = \"fake_group_id\"\n+    val fakeTopicName = \"foo\"\n+\n+    try {\n+      prepareTopics(List(testTopicName), 1)\n+      prepareRecords(testTopicName)\n+\n+      val newShareConsumerConfig = new Properties(consumerConfig)\n+      newShareConsumerConfig.setProperty(ConsumerConfig.GROUP_ID_CONFIG, testGroupId)\n+      newShareConsumerConfig.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, testClientId)\n+\n+      Using.resource(createShareConsumer(configOverrides = newShareConsumerConfig)) { consumer =>\n+        consumer.subscribe(util.List.of(testTopicName))\n+        consumer.poll(JDuration.ofMillis(DEFAULT_MAX_WAIT_MS))\n+        consumer.commitSync()\n+\n+        // listGroups is used to list share groups\n+        // Test that we can list the new group.\n+        TestUtils.waitUntilTrue(() => {\n+          client.listGroups.all.get.stream().filter(group =>\n+            group.groupId == testGroupId &&\n+              group.groupState.get == GroupState.STABLE).count() == 1\n+        }, s\"Expected to be able to list $testGroupId\")\n+\n+        // Test offset deletion while consuming\n+        val offsetDeleteResult = client.deleteShareGroupOffsets(testGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+        // Deleting the offset with real group ID should get GroupNotEmptyException\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.all())\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.topicResult(testTopicName))\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.topicResult(fakeTopicName))\n+\n+        // Test the fake group ID\n+        val fakeDeleteResult = client.deleteShareGroupOffsets(fakeGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.all())\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.topicResult(testTopicName))\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.topicResult(fakeTopicName))\n+      }\n+\n+      // Test offset deletion when group is empty\n+      val offsetDeleteResult = client.deleteShareGroupOffsets(testGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+      assertFutureThrows(classOf[UnknownTopicOrPartitionException], offsetDeleteResult.all())\n+      assertNull(offsetDeleteResult.topicResult(testTopicName).get())\n+      assertFutureThrows(classOf[UnknownTopicOrPartitionException], offsetDeleteResult.topicResult(fakeTopicName))\n+    } finally {",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2216310832",
        "repo_full_name": "apache/kafka",
        "pr_number": 20103,
        "pr_file": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala",
        "discussion_id": "2216310832",
        "commented_code": "@@ -2845,7 +2844,178 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n       }\n     } finally {\n       consumerSet.foreach(consumer => Utils.closeQuietly(consumer, \"consumer\"))\n-      Utils.closeQuietly(producer, \"producer\")\n+      Utils.closeQuietly(client, \"adminClient\")\n+    }\n+  }\n+\n+  @Test\n+  def testDeleteShareGroupOffsets(): Unit = {\n+    val config = createConfig\n+    client = Admin.create(config)\n+    val testTopicName = \"test_topic\"\n+    val testGroupId = \"test_group_id\"\n+    val testClientId = \"test_client_id\"\n+    val fakeGroupId = \"fake_group_id\"\n+    val fakeTopicName = \"foo\"\n+\n+    try {\n+      prepareTopics(List(testTopicName), 1)\n+      prepareRecords(testTopicName)\n+\n+      val newShareConsumerConfig = new Properties(consumerConfig)\n+      newShareConsumerConfig.setProperty(ConsumerConfig.GROUP_ID_CONFIG, testGroupId)\n+      newShareConsumerConfig.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, testClientId)\n+\n+      Using.resource(createShareConsumer(configOverrides = newShareConsumerConfig)) { consumer =>\n+        consumer.subscribe(util.List.of(testTopicName))\n+        consumer.poll(JDuration.ofMillis(DEFAULT_MAX_WAIT_MS))\n+        consumer.commitSync()\n+\n+        // listGroups is used to list share groups\n+        // Test that we can list the new group.\n+        TestUtils.waitUntilTrue(() => {\n+          client.listGroups.all.get.stream().filter(group =>\n+            group.groupId == testGroupId &&\n+              group.groupState.get == GroupState.STABLE).count() == 1\n+        }, s\"Expected to be able to list $testGroupId\")\n+\n+        // Test offset deletion while consuming\n+        val offsetDeleteResult = client.deleteShareGroupOffsets(testGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+        // Deleting the offset with real group ID should get GroupNotEmptyException\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.all())\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.topicResult(testTopicName))\n+        assertFutureThrows(classOf[GroupNotEmptyException], offsetDeleteResult.topicResult(fakeTopicName))\n+\n+        // Test the fake group ID\n+        val fakeDeleteResult = client.deleteShareGroupOffsets(fakeGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.all())\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.topicResult(testTopicName))\n+        assertFutureThrows(classOf[GroupIdNotFoundException], fakeDeleteResult.topicResult(fakeTopicName))\n+      }\n+\n+      // Test offset deletion when group is empty\n+      val offsetDeleteResult = client.deleteShareGroupOffsets(testGroupId, util.Set.of(testTopicName, fakeTopicName))\n+\n+      assertFutureThrows(classOf[UnknownTopicOrPartitionException], offsetDeleteResult.all())\n+      assertNull(offsetDeleteResult.topicResult(testTopicName).get())\n+      assertFutureThrows(classOf[UnknownTopicOrPartitionException], offsetDeleteResult.topicResult(fakeTopicName))\n+    } finally {",
        "comment_created_at": "2025-07-18T15:14:16+00:00",
        "comment_author": "AndrewJSchofield",
        "comment_body": "We should be able to see whether offsets were deleted using `listShareGroupOffsets`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2101642100",
    "pr_number": 18929,
    "pr_file": "core/src/main/scala/kafka/server/KafkaApis.scala",
    "created_at": "2025-05-22T05:10:53+00:00",
    "commented_code": "def handleAlterShareGroupOffsetsRequest(request: RequestChannel.Request): CompletableFuture[Unit] = {\n     val alterShareGroupOffsetsRequest = request.body[AlterShareGroupOffsetsRequest]\n+    val groupId = alterShareGroupOffsetsRequest.data.groupId\n+\n     if (!isShareGroupProtocolEnabled) {\n       requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(AbstractResponse.DEFAULT_THROTTLE_TIME, Errors.UNSUPPORTED_VERSION.exception))\n       return CompletableFuture.completedFuture[Unit](())\n+    } else if (!authHelper.authorize(request.context, READ, GROUP, groupId)) {\n+      requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(Errors.GROUP_AUTHORIZATION_FAILED.exception))\n+    } else {\n+      val responseBuilder = new AlterShareGroupOffsetsResponse.Builder()\n+      val authorizedTopicPartitions = new AlterShareGroupOffsetsRequestData.AlterShareGroupOffsetsRequestTopicCollection()\n+\n+      alterShareGroupOffsetsRequest.data.topics.forEach(topic => {\n+        val topicError = {\n+          if (!authHelper.authorize(request.context, READ, TOPIC, topic.topicName())) {\n+            Some(new ApiError(Errors.TOPIC_AUTHORIZATION_FAILED))\n+          } else if (!metadataCache.contains(topic.topicName())) {\n+            Some(new ApiError(Errors.UNKNOWN_TOPIC_OR_PARTITION))\n+          } else {\n+            None\n+          }\n+        }\n+        topicError match {\n+          case Some(error) =>\n+            topic.partitions().forEach(partition => responseBuilder.addPartition(topic.topicName(), partition.partitionIndex(), error.error))\n+          case None =>\n+            authorizedTopicPartitions.add(topic)\n+        }\n+      })\n+\n+      val data = new AlterShareGroupOffsetsRequestData()\n+        .setGroupId(groupId)\n+        .setTopics(authorizedTopicPartitions)\n+      groupCoordinator.alterShareGroupOffsets(\n+        request.context,\n+        groupId,\n+        data\n+      ).handle[Unit] { (response, exception) =>\n+        if (exception != null) {\n+          requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(exception))\n+        } else {\n+          requestHelper.sendMaybeThrottle(request, responseBuilder.merge(response).build())",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2101642100",
        "repo_full_name": "apache/kafka",
        "pr_number": 18929,
        "pr_file": "core/src/main/scala/kafka/server/KafkaApis.scala",
        "discussion_id": "2101642100",
        "commented_code": "@@ -3738,11 +3738,50 @@ class KafkaApis(val requestChannel: RequestChannel,\n \n   def handleAlterShareGroupOffsetsRequest(request: RequestChannel.Request): CompletableFuture[Unit] = {\n     val alterShareGroupOffsetsRequest = request.body[AlterShareGroupOffsetsRequest]\n+    val groupId = alterShareGroupOffsetsRequest.data.groupId\n+\n     if (!isShareGroupProtocolEnabled) {\n       requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(AbstractResponse.DEFAULT_THROTTLE_TIME, Errors.UNSUPPORTED_VERSION.exception))\n       return CompletableFuture.completedFuture[Unit](())\n+    } else if (!authHelper.authorize(request.context, READ, GROUP, groupId)) {\n+      requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(Errors.GROUP_AUTHORIZATION_FAILED.exception))\n+    } else {\n+      val responseBuilder = new AlterShareGroupOffsetsResponse.Builder()\n+      val authorizedTopicPartitions = new AlterShareGroupOffsetsRequestData.AlterShareGroupOffsetsRequestTopicCollection()\n+\n+      alterShareGroupOffsetsRequest.data.topics.forEach(topic => {\n+        val topicError = {\n+          if (!authHelper.authorize(request.context, READ, TOPIC, topic.topicName())) {\n+            Some(new ApiError(Errors.TOPIC_AUTHORIZATION_FAILED))\n+          } else if (!metadataCache.contains(topic.topicName())) {\n+            Some(new ApiError(Errors.UNKNOWN_TOPIC_OR_PARTITION))\n+          } else {\n+            None\n+          }\n+        }\n+        topicError match {\n+          case Some(error) =>\n+            topic.partitions().forEach(partition => responseBuilder.addPartition(topic.topicName(), partition.partitionIndex(), error.error))\n+          case None =>\n+            authorizedTopicPartitions.add(topic)\n+        }\n+      })\n+\n+      val data = new AlterShareGroupOffsetsRequestData()\n+        .setGroupId(groupId)\n+        .setTopics(authorizedTopicPartitions)\n+      groupCoordinator.alterShareGroupOffsets(\n+        request.context,\n+        groupId,\n+        data\n+      ).handle[Unit] { (response, exception) =>\n+        if (exception != null) {\n+          requestHelper.sendMaybeThrottle(request, alterShareGroupOffsetsRequest.getErrorResponse(exception))\n+        } else {\n+          requestHelper.sendMaybeThrottle(request, responseBuilder.merge(response).build())",
        "comment_created_at": "2025-05-22T05:10:53+00:00",
        "comment_author": "AndrewJSchofield",
        "comment_body": "I think there's a problem with the response building here.\r\n\r\nFor topics which have an error, such as `TOPIC_AUTHORIZATION_FAILED` or `UNKNOWN_TOPIC_OR_PARTITION`, not setting the topic ID is correct. However, for topics which work, the response should contain the topic ID. In `GroupMetadataManager.completeAlterShareGroupOffsets`, the topic ID is added to the response data. However, then the call to `responseBuilder.merge` brings together the successful and failed parts of the response, and it does not seem to copy the topic ID into the consolidated response.\r\n\r\nIt looks like there could be more validation of the response contents too.",
        "pr_file_module": null
      }
    ]
  }
]