[
  {
    "discussion_id": "2219109942",
    "pr_number": 20172,
    "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
    "created_at": "2025-07-21T12:47:10+00:00",
    "commented_code": "final TaskId task = it.next();\n             final Member prevMember = localState.activeTaskToPrevMember.get(task);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 2. re-assigning tasks to clients that previously have seen the same task (as standby task)\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n-            final Member prevMember = findMemberWithLeastLoad(prevMembers, task, true);\n+            final ArrayList<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n+            final Member prevMember = findPrevMemberWithLeastLoad(prevMembers, null);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 3. assign any remaining unassigned tasks\n+        PriorityQueue<ProcessState> processByLoad = new PriorityQueue<>(Comparator.comparingDouble(ProcessState::load));\n+        processByLoad.addAll(localState.processIdToState.values());\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> allMembers = localState.processIdToState.entrySet().stream().flatMap(entry -> entry.getValue().memberToTaskCounts().keySet().stream()\n-                .map(memberId -> new Member(entry.getKey(), memberId))).collect(Collectors.toSet());\n-            final Member member = findMemberWithLeastLoad(allMembers, task, false);\n+            ProcessState processWithLeastLoad = processByLoad.poll();",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2219109942",
        "repo_full_name": "apache/kafka",
        "pr_number": 20172,
        "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
        "discussion_id": "2219109942",
        "commented_code": "@@ -171,38 +173,43 @@ private void assignActive(final Set<TaskId> activeTasks) {\n             final TaskId task = it.next();\n             final Member prevMember = localState.activeTaskToPrevMember.get(task);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 2. re-assigning tasks to clients that previously have seen the same task (as standby task)\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n-            final Member prevMember = findMemberWithLeastLoad(prevMembers, task, true);\n+            final ArrayList<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n+            final Member prevMember = findPrevMemberWithLeastLoad(prevMembers, null);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 3. assign any remaining unassigned tasks\n+        PriorityQueue<ProcessState> processByLoad = new PriorityQueue<>(Comparator.comparingDouble(ProcessState::load));\n+        processByLoad.addAll(localState.processIdToState.values());\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> allMembers = localState.processIdToState.entrySet().stream().flatMap(entry -> entry.getValue().memberToTaskCounts().keySet().stream()\n-                .map(memberId -> new Member(entry.getKey(), memberId))).collect(Collectors.toSet());\n-            final Member member = findMemberWithLeastLoad(allMembers, task, false);\n+            ProcessState processWithLeastLoad = processByLoad.poll();",
        "comment_created_at": "2025-07-21T12:47:10+00:00",
        "comment_author": "lucasbru",
        "comment_body": "replace iteration to find least loaded member in `findMemberWithLeastLoad` by polling the priority queue.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219113275",
    "pr_number": 20172,
    "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
    "created_at": "2025-07-21T12:48:20+00:00",
    "commented_code": "final TaskId task = it.next();\n             final Member prevMember = localState.activeTaskToPrevMember.get(task);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 2. re-assigning tasks to clients that previously have seen the same task (as standby task)\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n-            final Member prevMember = findMemberWithLeastLoad(prevMembers, task, true);\n+            final ArrayList<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n+            final Member prevMember = findPrevMemberWithLeastLoad(prevMembers, null);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 3. assign any remaining unassigned tasks\n+        PriorityQueue<ProcessState> processByLoad = new PriorityQueue<>(Comparator.comparingDouble(ProcessState::load));\n+        processByLoad.addAll(localState.processIdToState.values());\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> allMembers = localState.processIdToState.entrySet().stream().flatMap(entry -> entry.getValue().memberToTaskCounts().keySet().stream()\n-                .map(memberId -> new Member(entry.getKey(), memberId))).collect(Collectors.toSet());\n-            final Member member = findMemberWithLeastLoad(allMembers, task, false);\n+            ProcessState processWithLeastLoad = processByLoad.poll();\n+            if (processWithLeastLoad == null) {\n+                throw new TaskAssignorException(\"No process available to assign active task {}.\" + task);\n+            }\n+            String member = memberWithLeastLoad(processWithLeastLoad);\n             if (member == null) {\n-                log.error(\"Unable to assign active task {} to any member.\", task);\n                 throw new TaskAssignorException(\"No member available to assign active task {}.\" + task);\n             }\n-            localState.processIdToState.get(member.processId).addTask(member.memberId, task, true);\n+            processWithLeastLoad.addTask(member, task, true);\n             it.remove();\n-            updateHelpers(member, true);\n-\n+            maybeUpdateTasksPerMember(processWithLeastLoad.activeTaskCount());\n+            processByLoad.add(processWithLeastLoad); // Add it back to the queue after updating its state",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2219113275",
        "repo_full_name": "apache/kafka",
        "pr_number": 20172,
        "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
        "discussion_id": "2219113275",
        "commented_code": "@@ -171,38 +173,43 @@ private void assignActive(final Set<TaskId> activeTasks) {\n             final TaskId task = it.next();\n             final Member prevMember = localState.activeTaskToPrevMember.get(task);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 2. re-assigning tasks to clients that previously have seen the same task (as standby task)\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n-            final Member prevMember = findMemberWithLeastLoad(prevMembers, task, true);\n+            final ArrayList<Member> prevMembers = localState.standbyTaskToPrevMember.get(task);\n+            final Member prevMember = findPrevMemberWithLeastLoad(prevMembers, null);\n             if (prevMember != null && hasUnfulfilledQuota(prevMember)) {\n-                localState.processIdToState.get(prevMember.processId).addTask(prevMember.memberId, task, true);\n-                updateHelpers(prevMember, true);\n+                ProcessState processState = localState.processIdToState.get(prevMember.processId);\n+                processState.addTask(prevMember.memberId, task, true);\n+                maybeUpdateTasksPerMember(processState.activeTaskCount());\n                 it.remove();\n             }\n         }\n \n         // 3. assign any remaining unassigned tasks\n+        PriorityQueue<ProcessState> processByLoad = new PriorityQueue<>(Comparator.comparingDouble(ProcessState::load));\n+        processByLoad.addAll(localState.processIdToState.values());\n         for (Iterator<TaskId> it = activeTasks.iterator(); it.hasNext();) {\n             final TaskId task = it.next();\n-            final Set<Member> allMembers = localState.processIdToState.entrySet().stream().flatMap(entry -> entry.getValue().memberToTaskCounts().keySet().stream()\n-                .map(memberId -> new Member(entry.getKey(), memberId))).collect(Collectors.toSet());\n-            final Member member = findMemberWithLeastLoad(allMembers, task, false);\n+            ProcessState processWithLeastLoad = processByLoad.poll();\n+            if (processWithLeastLoad == null) {\n+                throw new TaskAssignorException(\"No process available to assign active task {}.\" + task);\n+            }\n+            String member = memberWithLeastLoad(processWithLeastLoad);\n             if (member == null) {\n-                log.error(\"Unable to assign active task {} to any member.\", task);\n                 throw new TaskAssignorException(\"No member available to assign active task {}.\" + task);\n             }\n-            localState.processIdToState.get(member.processId).addTask(member.memberId, task, true);\n+            processWithLeastLoad.addTask(member, task, true);\n             it.remove();\n-            updateHelpers(member, true);\n-\n+            maybeUpdateTasksPerMember(processWithLeastLoad.activeTaskCount());\n+            processByLoad.add(processWithLeastLoad); // Add it back to the queue after updating its state",
        "comment_created_at": "2025-07-21T12:48:20+00:00",
        "comment_author": "lucasbru",
        "comment_body": "After we have changed the load, we need to add it back to the priority queue, so that it is inserted at the correct position",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219122060",
    "pr_number": 20172,
    "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
    "created_at": "2025-07-21T12:51:12+00:00",
    "commented_code": "}\n     }\n \n-    private Member findMemberWithLeastLoad(final Set<Member> members, TaskId taskId, final boolean returnSameMember) {\n+    private boolean assignStandbyToMemberWithLeastLoad(PriorityQueue<ProcessState> queue, TaskId taskId) {\n+        ProcessState processWithLeastLoad = queue.poll();\n+        if (processWithLeastLoad == null) {\n+            return false;\n+        }\n+        boolean found = false;\n+        if (!processWithLeastLoad.hasTask(taskId)) {\n+            String memberId = memberWithLeastLoad(processWithLeastLoad);\n+            if (memberId != null) {\n+                processWithLeastLoad.addTask(memberId, taskId, false);\n+                found = true;\n+            }\n+        } else if (!queue.isEmpty()) {\n+            found = assignStandbyToMemberWithLeastLoad(queue, taskId);",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2219122060",
        "repo_full_name": "apache/kafka",
        "pr_number": 20172,
        "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
        "discussion_id": "2219122060",
        "commented_code": "@@ -214,85 +221,125 @@ private void maybeUpdateTasksPerMember(final int activeTasksNo) {\n         }\n     }\n \n-    private Member findMemberWithLeastLoad(final Set<Member> members, TaskId taskId, final boolean returnSameMember) {\n+    private boolean assignStandbyToMemberWithLeastLoad(PriorityQueue<ProcessState> queue, TaskId taskId) {\n+        ProcessState processWithLeastLoad = queue.poll();\n+        if (processWithLeastLoad == null) {\n+            return false;\n+        }\n+        boolean found = false;\n+        if (!processWithLeastLoad.hasTask(taskId)) {\n+            String memberId = memberWithLeastLoad(processWithLeastLoad);\n+            if (memberId != null) {\n+                processWithLeastLoad.addTask(memberId, taskId, false);\n+                found = true;\n+            }\n+        } else if (!queue.isEmpty()) {\n+            found = assignStandbyToMemberWithLeastLoad(queue, taskId);",
        "comment_created_at": "2025-07-21T12:51:12+00:00",
        "comment_author": "lucasbru",
        "comment_body": "We are using recursion here. If the least loaded member already has the task, we recurse to find the next least loaded member. The point is that the least-loaded process is not added back to the queue at this point.\r\n\r\nRecursion is fine here, because we know that we get only `numStandbyTasks + 1` recursions, since only `numStandbyTasks` processes can have the task already. By default, we only allow 2 standby replicas, so we'd get at most 3 recursive calls here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219152532",
    "pr_number": 20172,
    "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
    "created_at": "2025-07-21T13:01:45+00:00",
    "commented_code": "}\n     }\n \n-    private Member findMemberWithLeastLoad(final Set<Member> members, TaskId taskId, final boolean returnSameMember) {\n+    private boolean assignStandbyToMemberWithLeastLoad(PriorityQueue<ProcessState> queue, TaskId taskId) {\n+        ProcessState processWithLeastLoad = queue.poll();\n+        if (processWithLeastLoad == null) {\n+            return false;\n+        }\n+        boolean found = false;\n+        if (!processWithLeastLoad.hasTask(taskId)) {\n+            String memberId = memberWithLeastLoad(processWithLeastLoad);\n+            if (memberId != null) {\n+                processWithLeastLoad.addTask(memberId, taskId, false);\n+                found = true;\n+            }\n+        } else if (!queue.isEmpty()) {\n+            found = assignStandbyToMemberWithLeastLoad(queue, taskId);\n+        }\n+        queue.add(processWithLeastLoad); // Add it back to the queue after updating its state\n+        return found;\n+    }\n+\n+    /**\n+     * Finds the previous member with the least load for a given task.\n+     *\n+     * @param members The list of previous members owning the task.\n+     * @param taskId  The taskId, to check if the previous member already has the task. Can be null, if we assign it\n+     *                for the first time (e.g., during active task assignment).\n+     *\n+     * @return Previous member with the least load that deoes not have the task, or null if no such member exists.\n+     */\n+    private Member findPrevMemberWithLeastLoad(final ArrayList<Member> members, final TaskId taskId) {",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2219152532",
        "repo_full_name": "apache/kafka",
        "pr_number": 20172,
        "pr_file": "group-coordinator/src/main/java/org/apache/kafka/coordinator/group/streams/assignor/StickyTaskAssignor.java",
        "discussion_id": "2219152532",
        "commented_code": "@@ -214,85 +221,125 @@ private void maybeUpdateTasksPerMember(final int activeTasksNo) {\n         }\n     }\n \n-    private Member findMemberWithLeastLoad(final Set<Member> members, TaskId taskId, final boolean returnSameMember) {\n+    private boolean assignStandbyToMemberWithLeastLoad(PriorityQueue<ProcessState> queue, TaskId taskId) {\n+        ProcessState processWithLeastLoad = queue.poll();\n+        if (processWithLeastLoad == null) {\n+            return false;\n+        }\n+        boolean found = false;\n+        if (!processWithLeastLoad.hasTask(taskId)) {\n+            String memberId = memberWithLeastLoad(processWithLeastLoad);\n+            if (memberId != null) {\n+                processWithLeastLoad.addTask(memberId, taskId, false);\n+                found = true;\n+            }\n+        } else if (!queue.isEmpty()) {\n+            found = assignStandbyToMemberWithLeastLoad(queue, taskId);\n+        }\n+        queue.add(processWithLeastLoad); // Add it back to the queue after updating its state\n+        return found;\n+    }\n+\n+    /**\n+     * Finds the previous member with the least load for a given task.\n+     *\n+     * @param members The list of previous members owning the task.\n+     * @param taskId  The taskId, to check if the previous member already has the task. Can be null, if we assign it\n+     *                for the first time (e.g., during active task assignment).\n+     *\n+     * @return Previous member with the least load that deoes not have the task, or null if no such member exists.\n+     */\n+    private Member findPrevMemberWithLeastLoad(final ArrayList<Member> members, final TaskId taskId) {",
        "comment_created_at": "2025-07-21T13:01:45+00:00",
        "comment_author": "lucasbru",
        "comment_body": "`findPrevMemberWithLeastLoad` works very similar to the old `findMemberWithLeastLoad` - that is, it does a linear search among a collection of candidates.\r\n\r\nHowever, since we don't use it anymore to find the least loaded node among all members anymore - we use a priority queue there.\r\n\r\nThis is only used to select the least loaded node among all members that previously owned the task. I replaced the Java Streams based iteration with a loop, since it's more efficient.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2199017407",
    "pr_number": 20021,
    "pr_file": "metadata/src/main/java/org/apache/kafka/image/loader/metrics/MetadataLoaderMetrics.java",
    "created_at": "2025-07-10T23:49:43+00:00",
    "commented_code": "return this.handleLoadSnapshotCount.get();\n     }\n \n+    /**\n+     * Remove the FinalizedLevel metric for features who are no longer part of the\n+     * current features image.\n+     * Note that metadata.version and kraft.version are not included in\n+     * the features image, so they are not removed.\n+     * @param newFinalizedLevels The new finalized feature levels from the features image\n+     */\n+    public void maybeRemoveFinalizedFeatureLevelMetrics(Map<String, Short> newFinalizedLevels) {\n+        finalizedFeatureLevels.keySet().stream().filter(",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2199017407",
        "repo_full_name": "apache/kafka",
        "pr_number": 20021,
        "pr_file": "metadata/src/main/java/org/apache/kafka/image/loader/metrics/MetadataLoaderMetrics.java",
        "discussion_id": "2199017407",
        "commented_code": "@@ -142,16 +176,85 @@ public long handleLoadSnapshotCount() {\n         return this.handleLoadSnapshotCount.get();\n     }\n \n+    /**\n+     * Remove the FinalizedLevel metric for features who are no longer part of the\n+     * current features image.\n+     * Note that metadata.version and kraft.version are not included in\n+     * the features image, so they are not removed.\n+     * @param newFinalizedLevels The new finalized feature levels from the features image\n+     */\n+    public void maybeRemoveFinalizedFeatureLevelMetrics(Map<String, Short> newFinalizedLevels) {\n+        finalizedFeatureLevels.keySet().stream().filter(",
        "comment_created_at": "2025-07-10T23:49:43+00:00",
        "comment_author": "chia7712",
        "comment_body": "Perhaps we could leverage `iterator` to avoid iterating through all items twice.\r\n```java\r\n        var iter = finalizedFeatureLevels.keySet().iterator();\r\n        while (iter.hasNext()) {\r\n            var featureName = iter.next();\r\n            if (newFinalizedLevels.containsKey(featureName) ||\r\n                featureName.equals(MetadataVersion.FEATURE_NAME) ||\r\n                featureName.equals(KRaftVersion.FEATURE_NAME)) {\r\n                continue;\r\n            }\r\n            removeFinalizedFeatureLevelMetric(featureName);\r\n            iter.remove();\r\n        }\r\n```",
        "pr_file_module": null
      }
    ]
  }
]