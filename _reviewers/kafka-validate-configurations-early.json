[
  {
    "discussion_id": "2223756688",
    "pr_number": 20185,
    "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
    "created_at": "2025-07-22T20:25:39+00:00",
    "commented_code": "setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2223756688",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-22T20:25:39+00:00",
        "comment_author": "junrao",
        "comment_body": "This is not very accurate. If the internal config unstable.feature.versions.enable is set, we actually allow non-production MVs. All callers of `MetadataVersion.fromVersionString` are either on the server side or from the tools and should have access to the unstable.feature.versions.enable. Perhaps it's better to change `MetadataVersion.fromVersionString` to take an enableUnstableFeature flag.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2224215359",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-23T03:03:45+00:00",
        "comment_author": "DL1231",
        "comment_body": "Good catch! Thanks for the review.\r\nSee the discussion:\r\n https://github.com/apache/kafka/pull/18845#discussion_r1950706791\r\n`MetadataVersion.fromVersionString` is just used to convert `String` to `MetadataVersion`. Perhaps the config `unstable.feature.versions.enable` shoule be considered when outputting error message. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "2224225489",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-23T03:14:23+00:00",
        "comment_author": "frankvicky",
        "comment_body": "> Perhaps it's better to change MetadataVersion.fromVersionString to take an enableUnstableFeature flag.\r\n\r\nMake sense.\r\nThe patch follows the pattern from `FeatureCommand`.\r\nAfter adding a flag to `MetadataVersion.fromVersionString`, we should also update `FeatureCommand`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2226282647",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-23T17:58:47+00:00",
        "comment_author": "junrao",
        "comment_body": "Yes, if we improve `MetadataVersion.fromVersionString()`, we could fix the inconsistent error message in all tools and the server responses. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2227061123",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-24T01:08:19+00:00",
        "comment_author": "DL1231",
        "comment_body": "Filed [KAFKA-19544](https://issues.apache.org/jira/browse/KAFKA-19544) to track this issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227425142",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-24T05:47:54+00:00",
        "comment_author": "chia7712",
        "comment_body": "It would be cool if `FeatureCommand` and `StorageTool` could leverage the exception from `fromVersionString`. After fixing KAFKA-19545, the `MetadataVersion.fromVersionString` will be used only by tools only, so it could throw `TerseFailure` instead of `IllegalArgumentException`, which could then be directly reused by tools.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227462480",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-24T05:57:54+00:00",
        "comment_author": "chia7712",
        "comment_body": "umm, `TerseFailure` is in core module, which can't be accessed by tool module. Also, `StorageTool` is still in core module, so `StorageTool` and `FeatureCommand` can't share the same `terse` exception for now. I guess another simple solution is they could just reuse the exception message thrown by `fromVersionString` :)\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2235304915",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-28T08:28:08+00:00",
        "comment_author": "DL1231",
        "comment_body": "`KafkaConfig.unstableFeatureVersionsEnabled` resides in the core module and is inaccessible to the tool module. Additionally, since `UNSTABLE_FEATURE_VERSIONS_ENABLE_CONFIG` is an internal configuration, it cannot be retrieved by the `describeConfigs` API. Consequently, `FeatureCommand` is unable to access the value of the configuration `unstable.feature.versions.enable`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2237138917",
        "repo_full_name": "apache/kafka",
        "pr_number": 20185,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2223756688",
        "commented_code": "@@ -128,9 +128,21 @@ object StorageTool extends Logging {\n       setIgnoreFormatted(namespace.getBoolean(\"ignore_formatted\")).\n       setControllerListenerName(config.controllerListenerNames.get(0)).\n       setMetadataLogDirectory(config.metadataLogDir)\n-    Option(namespace.getString(\"release_version\")).foreach(\n-      releaseVersion => formatter.\n-        setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion)))\n+\n+    def metadataVersionsToString(first: MetadataVersion, last: MetadataVersion): String = {\n+      val versions = MetadataVersion.VERSIONS.slice(first.ordinal, last.ordinal + 1)\n+      versions.map(_.toString).mkString(\", \")\n+    }\n+    Option(namespace.getString(\"release_version\")).foreach(releaseVersion => {\n+      try {\n+        formatter.setReleaseVersion(MetadataVersion.fromVersionString(releaseVersion))\n+      } catch {\n+        case _: Throwable =>\n+          throw new TerseFailure(s\"Unknown metadata.version $releaseVersion. Supported metadata.version are \" +\n+            s\"${metadataVersionsToString(MetadataVersion.MINIMUM_VERSION, MetadataVersion.latestProduction())}\")",
        "comment_created_at": "2025-07-28T16:16:25+00:00",
        "comment_author": "junrao",
        "comment_body": "Ok. The tool is designed mainly for production usage. So, perhaps we could just leave it as it is.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198351281",
    "pr_number": 20136,
    "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
    "created_at": "2025-07-10T17:55:08+00:00",
    "commented_code": "featureNamesAndLevels(_).foreachEntry {\n         (k, v) => formatter.setFeatureLevel(k, v)\n       })\n+    if (!config.quorumConfig.voters().isEmpty &&\n+      (namespace.getString(\"initial_controllers\") != null || namespace.getBoolean(\"standalone\"))) {",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2198351281",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2198351281",
        "commented_code": "@@ -135,6 +135,15 @@ object StorageTool extends Logging {\n       featureNamesAndLevels(_).foreachEntry {\n         (k, v) => formatter.setFeatureLevel(k, v)\n       })\n+    if (!config.quorumConfig.voters().isEmpty &&\n+      (namespace.getString(\"initial_controllers\") != null || namespace.getBoolean(\"standalone\"))) {",
        "comment_created_at": "2025-07-10T17:55:08+00:00",
        "comment_author": "ahuang98",
        "comment_body": "store value of initial_controllers and standalone in vars given that you may need to reference them again later in the function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198353721",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2198351281",
        "commented_code": "@@ -135,6 +135,15 @@ object StorageTool extends Logging {\n       featureNamesAndLevels(_).foreachEntry {\n         (k, v) => formatter.setFeatureLevel(k, v)\n       })\n+    if (!config.quorumConfig.voters().isEmpty &&\n+      (namespace.getString(\"initial_controllers\") != null || namespace.getBoolean(\"standalone\"))) {",
        "comment_created_at": "2025-07-10T17:56:34+00:00",
        "comment_author": "ahuang98",
        "comment_body": "or, thoughts on moving this check to be with the existing config validations under L155?",
        "pr_file_module": null
      },
      {
        "comment_id": "2200806228",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/main/scala/kafka/tools/StorageTool.scala",
        "discussion_id": "2198351281",
        "commented_code": "@@ -135,6 +135,15 @@ object StorageTool extends Logging {\n       featureNamesAndLevels(_).foreachEntry {\n         (k, v) => formatter.setFeatureLevel(k, v)\n       })\n+    if (!config.quorumConfig.voters().isEmpty &&\n+      (namespace.getString(\"initial_controllers\") != null || namespace.getBoolean(\"standalone\"))) {",
        "comment_created_at": "2025-07-11T13:52:54+00:00",
        "comment_author": "kevin-wu24",
        "comment_body": "> or, thoughts on moving this check to be with the existing config validations under L155?\r\n\r\nI put this before L155 because at that point we have already made calls to modify formatter state if one of `--standalone` or `--initial-controllers` is set. Basically I think it is cleaner to fail first if the set up is invalid.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198358846",
    "pr_number": 20136,
    "pr_file": "core/src/test/scala/unit/kafka/tools/StorageToolTest.scala",
    "created_at": "2025-07-10T17:59:11+00:00",
    "commented_code": "val availableDirs = Seq(TestUtils.tempDir())\n     val properties = new Properties()\n     properties.putAll(defaultStaticQuorumProperties)\n+    properties.remove(\"controller.quorum.voters\")\n+    properties.put(\"controller.quorum.bootstrap.servers\", \"localhost:9093\")",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2198358846",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/test/scala/unit/kafka/tools/StorageToolTest.scala",
        "discussion_id": "2198358846",
        "commented_code": "@@ -376,6 +376,8 @@ Found problem:\n     val availableDirs = Seq(TestUtils.tempDir())\n     val properties = new Properties()\n     properties.putAll(defaultStaticQuorumProperties)\n+    properties.remove(\"controller.quorum.voters\")\n+    properties.put(\"controller.quorum.bootstrap.servers\", \"localhost:9093\")",
        "comment_created_at": "2025-07-10T17:59:11+00:00",
        "comment_author": "ahuang98",
        "comment_body": "hm, why do this instead of just using `defaultDynamicQuorumProperties`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198390326",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/test/scala/unit/kafka/tools/StorageToolTest.scala",
        "discussion_id": "2198358846",
        "commented_code": "@@ -376,6 +376,8 @@ Found problem:\n     val availableDirs = Seq(TestUtils.tempDir())\n     val properties = new Properties()\n     properties.putAll(defaultStaticQuorumProperties)\n+    properties.remove(\"controller.quorum.voters\")\n+    properties.put(\"controller.quorum.bootstrap.servers\", \"localhost:9093\")",
        "comment_created_at": "2025-07-10T18:15:20+00:00",
        "comment_author": "kevin-wu24",
        "comment_body": "`defaultDynamicQuorumProperties` is for a controller. `defaultStaticQuorumProperties` is a broker.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198753693",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/test/scala/unit/kafka/tools/StorageToolTest.scala",
        "discussion_id": "2198358846",
        "commented_code": "@@ -376,6 +376,8 @@ Found problem:\n     val availableDirs = Seq(TestUtils.tempDir())\n     val properties = new Properties()\n     properties.putAll(defaultStaticQuorumProperties)\n+    properties.remove(\"controller.quorum.voters\")\n+    properties.put(\"controller.quorum.bootstrap.servers\", \"localhost:9093\")",
        "comment_created_at": "2025-07-10T21:10:57+00:00",
        "comment_author": "ahuang98",
        "comment_body": "any reason we can't create one version for the broker? or just define all the properties from scratch given there are only 4. feels funny that we are doing a put(staticProperties) then replacing the property that makes it static in the first place",
        "pr_file_module": null
      },
      {
        "comment_id": "2200807511",
        "repo_full_name": "apache/kafka",
        "pr_number": 20136,
        "pr_file": "core/src/test/scala/unit/kafka/tools/StorageToolTest.scala",
        "discussion_id": "2198358846",
        "commented_code": "@@ -376,6 +376,8 @@ Found problem:\n     val availableDirs = Seq(TestUtils.tempDir())\n     val properties = new Properties()\n     properties.putAll(defaultStaticQuorumProperties)\n+    properties.remove(\"controller.quorum.voters\")\n+    properties.put(\"controller.quorum.bootstrap.servers\", \"localhost:9093\")",
        "comment_created_at": "2025-07-11T13:53:34+00:00",
        "comment_author": "kevin-wu24",
        "comment_body": "Yeah I think I'll just define the properties from scratch.",
        "pr_file_module": null
      }
    ]
  }
]