[
  {
    "discussion_id": "2221826208",
    "pr_number": 20168,
    "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
    "created_at": "2025-07-22T09:03:51+00:00",
    "commented_code": "return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2221826208",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-22T09:03:51+00:00",
        "comment_author": "chia7712",
        "comment_body": "if there is a topic having three partitions, and the `t-2` partition is offline, then if `partitionsToReset` is `t-0,t-1`, `filterNoneLeaderPartitions` will return `t-2`, causing the tool to fail. Is it expected?",
        "pr_file_module": null
      },
      {
        "comment_id": "2222305652",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-22T12:03:28+00:00",
        "comment_author": "AndrewJSchofield",
        "comment_body": "I think it's fair enough.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227295797",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-24T04:22:01+00:00",
        "comment_author": "chia7712",
        "comment_body": "```\r\nchia7712@chia7712-ubuntu:~/project/kafka$ ./bin/kafka-consumer-groups.sh \\\r\n  --bootstrap-server 172.20.10.2:20001 \\\r\n  --reset-offsets \\\r\n  --to-earliest \\\r\n  --execute \\\r\n  --group perf-consumer-19460 \\\r\n  --topic chia:1\r\n\r\nError: Executing consumer group command failed due to The partitions \"chia-2\" have no leader\r\norg.apache.kafka.common.errors.LeaderNotAvailableException: The partitions \"chia-2\" have no leader\r\n```\r\n\r\nIt is indeed a bug that unrelated topic partitions could fail the tool.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227310093",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-24T04:31:08+00:00",
        "comment_author": "chia7712",
        "comment_body": "`filterNoneLeaderPartitions` needs to get fixed since it could return unrelated topic partitions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227735419",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-24T07:51:06+00:00",
        "comment_author": "AndrewJSchofield",
        "comment_body": "Yes, that's a very good point. Thanks for finding it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227748431",
        "repo_full_name": "apache/kafka",
        "pr_number": 20168,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2221826208",
        "commented_code": "@@ -1024,6 +1029,38 @@ private Map<TopicPartition, OffsetAndMetadata> prepareOffsetsToReset(String grou\n             return null;\n         }\n \n+        private void checkAllTopicPartitionsValid(Collection<TopicPartition> partitionsToReset) {\n+            // check the partitions exist\n+            List<TopicPartition> partitionsNotExistList = filterNonExistentPartitions(partitionsToReset);\n+            if (!partitionsNotExistList.isEmpty()) {\n+                String partitionStr = partitionsNotExistList.stream().map(TopicPartition::toString).collect(Collectors.joining(\",\"));\n+                throw new UnknownTopicOrPartitionException(\"The partitions \\\"\" + partitionStr + \"\\\" do not exist\");\n+            }\n+\n+            // check the partitions have leader\n+            List<TopicPartition> partitionsWithoutLeader = filterNoneLeaderPartitions(partitionsToReset);",
        "comment_created_at": "2025-07-24T07:56:39+00:00",
        "comment_author": "TaiJuWu",
        "comment_body": "file https://github.com/apache/kafka/pull/20235 to fix it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190774522",
    "pr_number": 20064,
    "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
    "created_at": "2025-07-07T18:22:50+00:00",
    "commented_code": "consumerIdOpt, hostOpt, clientIdOpt, logEndOffsetOpt, leaderEpoch);\n             };\n \n-            return offsetsUtils.getLogEndOffsets(topicPartitions).entrySet().stream().map(logEndOffsetResult -> {\n+            Set<TopicPartition> nonLeaderTopicPartitions = filterNoneLeaderPartitions(topicPartitions);\n+\n+            // prepare data for partitions with leaders\n+            topicPartitions.removeAll(nonLeaderTopicPartitions);",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "2190774522",
        "repo_full_name": "apache/kafka",
        "pr_number": 20064,
        "pr_file": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ConsumerGroupCommand.java",
        "discussion_id": "2190774522",
        "commented_code": "@@ -619,7 +619,11 @@ private Collection<PartitionAssignmentState> describePartitions(\n                     consumerIdOpt, hostOpt, clientIdOpt, logEndOffsetOpt, leaderEpoch);\n             };\n \n-            return offsetsUtils.getLogEndOffsets(topicPartitions).entrySet().stream().map(logEndOffsetResult -> {\n+            Set<TopicPartition> nonLeaderTopicPartitions = filterNoneLeaderPartitions(topicPartitions);\n+\n+            // prepare data for partitions with leaders\n+            topicPartitions.removeAll(nonLeaderTopicPartitions);",
        "comment_created_at": "2025-07-07T18:22:50+00:00",
        "comment_author": "chia7712",
        "comment_body": "we don't need to modify the input `topicPartitions` if `filterNoneLeaderPartitions` returns the partitions having leaders.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1580107316",
    "pr_number": 15647,
    "pr_file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractFetch.java",
    "created_at": "2024-04-25T20:47:22+00:00",
    "commented_code": "if (partitionData.currentLeader().leaderId() != -1 && partitionData.currentLeader().leaderEpoch() != -1) {\n                         partitionsWithUpdatedLeaderInfo.put(partition, new Metadata.LeaderIdAndEpoch(\n                             Optional.of(partitionData.currentLeader().leaderId()), Optional.of(partitionData.currentLeader().leaderEpoch())));\n+                    } else {\n+                        requestMetadataUpdate(metadata, subscriptions, partition);\n+                        subscriptions.awaitUpdate(partition);",
    "repo_full_name": "apache/kafka",
    "discussion_comments": [
      {
        "comment_id": "1580107316",
        "repo_full_name": "apache/kafka",
        "pr_number": 15647,
        "pr_file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractFetch.java",
        "discussion_id": "1580107316",
        "commented_code": "@@ -200,6 +200,9 @@ protected void handleFetchSuccess(final Node fetchTarget,\n                     if (partitionData.currentLeader().leaderId() != -1 && partitionData.currentLeader().leaderEpoch() != -1) {\n                         partitionsWithUpdatedLeaderInfo.put(partition, new Metadata.LeaderIdAndEpoch(\n                             Optional.of(partitionData.currentLeader().leaderId()), Optional.of(partitionData.currentLeader().leaderEpoch())));\n+                    } else {\n+                        requestMetadataUpdate(metadata, subscriptions, partition);\n+                        subscriptions.awaitUpdate(partition);",
        "comment_created_at": "2024-04-25T20:47:22+00:00",
        "comment_author": "kirktrue",
        "comment_body": "With this change, we first request a metadata update, then flag our partition as awaiting the metadata update whenever we encounter a `NOT_LEADER_OR_FOLLOWER` or `FENCED_LEADER_EPOCH`. However, in the `FetchCollector.handleInitializeErrors()` method, we only only request the metadata update, but _don't_ flag the partition. Is that seeming inconsistency intentional?",
        "pr_file_module": null
      },
      {
        "comment_id": "1580499797",
        "repo_full_name": "apache/kafka",
        "pr_number": 15647,
        "pr_file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractFetch.java",
        "discussion_id": "1580107316",
        "commented_code": "@@ -200,6 +200,9 @@ protected void handleFetchSuccess(final Node fetchTarget,\n                     if (partitionData.currentLeader().leaderId() != -1 && partitionData.currentLeader().leaderEpoch() != -1) {\n                         partitionsWithUpdatedLeaderInfo.put(partition, new Metadata.LeaderIdAndEpoch(\n                             Optional.of(partitionData.currentLeader().leaderId()), Optional.of(partitionData.currentLeader().leaderEpoch())));\n+                    } else {\n+                        requestMetadataUpdate(metadata, subscriptions, partition);\n+                        subscriptions.awaitUpdate(partition);",
        "comment_created_at": "2024-04-26T05:34:57+00:00",
        "comment_author": "appchemist",
        "comment_body": "If the FetchStates is `FETCHING` as per KIP-951, the `FetchCollector.handleInitializeErrors()` method is called.\r\nI thought that in this case, it should not be changed to `AWAIT_UPDATE`.\r\nAdditionally, if it's `AWAIT_UPDATE`, it will be filtered out by the following code inside the `FetchCollector.initialize()` method and will not go through `FetchCollector.handleInitializeErrors()`.\r\n\r\n```\r\nif (!subscriptions.hasValidPosition(tp)) {\r\n   // this can happen when a rebalance happened while fetch is still in-flight\r\n   log.debug(\"Ignoring fetched records for partition {} since it no longer has valid position\", tp);\r\n   return null;\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1580504115",
        "repo_full_name": "apache/kafka",
        "pr_number": 15647,
        "pr_file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractFetch.java",
        "discussion_id": "1580107316",
        "commented_code": "@@ -200,6 +200,9 @@ protected void handleFetchSuccess(final Node fetchTarget,\n                     if (partitionData.currentLeader().leaderId() != -1 && partitionData.currentLeader().leaderEpoch() != -1) {\n                         partitionsWithUpdatedLeaderInfo.put(partition, new Metadata.LeaderIdAndEpoch(\n                             Optional.of(partitionData.currentLeader().leaderId()), Optional.of(partitionData.currentLeader().leaderEpoch())));\n+                    } else {\n+                        requestMetadataUpdate(metadata, subscriptions, partition);\n+                        subscriptions.awaitUpdate(partition);",
        "comment_created_at": "2024-04-26T05:42:21+00:00",
        "comment_author": "appchemist",
        "comment_body": "As another alternative, it could change the status to `AWAIT_UPDATE` in `FetchCollector.handleInitializeErrors()` only when it doesn't include leader info\r\nUpon further thought, it seems possible to differentiate based on the following conditions.\r\n```\r\ncompletedFetch.partitionData.currentLeader().leaderId() != -1 && completedFetch.partitionData.currentLeader().leaderEpoch() != -1\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1580565165",
        "repo_full_name": "apache/kafka",
        "pr_number": 15647,
        "pr_file": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractFetch.java",
        "discussion_id": "1580107316",
        "commented_code": "@@ -200,6 +200,9 @@ protected void handleFetchSuccess(final Node fetchTarget,\n                     if (partitionData.currentLeader().leaderId() != -1 && partitionData.currentLeader().leaderEpoch() != -1) {\n                         partitionsWithUpdatedLeaderInfo.put(partition, new Metadata.LeaderIdAndEpoch(\n                             Optional.of(partitionData.currentLeader().leaderId()), Optional.of(partitionData.currentLeader().leaderEpoch())));\n+                    } else {\n+                        requestMetadataUpdate(metadata, subscriptions, partition);\n+                        subscriptions.awaitUpdate(partition);",
        "comment_created_at": "2024-04-26T07:02:09+00:00",
        "comment_author": "appchemist",
        "comment_body": "changed",
        "pr_file_module": null
      }
    ]
  }
]