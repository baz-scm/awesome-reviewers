[
  {
    "discussion_id": "2293148154",
    "pr_number": 2066,
    "pr_file": "src/api/providers/kilocode/fetchWithTimeout.ts",
    "created_at": "2025-08-22T09:01:38+00:00",
    "commented_code": "export function fetchWithTimeout(timeoutMs: number, headers?: Record<string, string>): typeof fetch {\n \tconst agent = new undici.Agent({ headersTimeout: timeoutMs, bodyTimeout: timeoutMs })\n-\treturn async (input, init) => {\n-\t\tconst mergedHeaders = {\n-\t\t\t...headers, // Persistent headers from function parameter\n-\t\t\t...(init?.headers || {}), // Request-specific headers (can override persistent ones)\n+\treturn (input, init) => {\n+\t\tconst requestInit: undici.RequestInit = {\n+\t\t\t...(init as undici.RequestInit),\n+\t\t\tdispatcher: agent,\n \t\t}\n-\t\tconst response = (await undici.fetch(\n-\t\t\tinput as undici.RequestInfo,\n-\t\t\t{\n-\t\t\t\t...init,\n-\t\t\t\theaders: mergedHeaders,\n-\t\t\t\tdispatcher: agent,\n-\t\t\t} as undici.RequestInit,\n-\t\t)) as unknown as Response\n-\t\treturn response\n+\n+\t\tif (headers) {\n+\t\t\trequestInit.headers = {\n+\t\t\t\t...(init?.headers || {}),\n+\t\t\t\t...headers,",
    "repo_full_name": "Kilo-Org/kilocode",
    "discussion_comments": [
      {
        "comment_id": "2293148154",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 2066,
        "pr_file": "src/api/providers/kilocode/fetchWithTimeout.ts",
        "discussion_id": "2293148154",
        "commented_code": "@@ -2,19 +2,19 @@ import * as undici from \"undici\"\n \n export function fetchWithTimeout(timeoutMs: number, headers?: Record<string, string>): typeof fetch {\n \tconst agent = new undici.Agent({ headersTimeout: timeoutMs, bodyTimeout: timeoutMs })\n-\treturn async (input, init) => {\n-\t\tconst mergedHeaders = {\n-\t\t\t...headers, // Persistent headers from function parameter\n-\t\t\t...(init?.headers || {}), // Request-specific headers (can override persistent ones)\n+\treturn (input, init) => {\n+\t\tconst requestInit: undici.RequestInit = {\n+\t\t\t...(init as undici.RequestInit),\n+\t\t\tdispatcher: agent,\n \t\t}\n-\t\tconst response = (await undici.fetch(\n-\t\t\tinput as undici.RequestInfo,\n-\t\t\t{\n-\t\t\t\t...init,\n-\t\t\t\theaders: mergedHeaders,\n-\t\t\t\tdispatcher: agent,\n-\t\t\t} as undici.RequestInit,\n-\t\t)) as unknown as Response\n-\t\treturn response\n+\n+\t\tif (headers) {\n+\t\t\trequestInit.headers = {\n+\t\t\t\t...(init?.headers || {}),\n+\t\t\t\t...headers,",
        "comment_created_at": "2025-08-22T09:01:38+00:00",
        "comment_author": "chrarnoldus",
        "comment_body": "Why was the order changed? (i.e. persistent headers now overwrite request-specific ones)",
        "pr_file_module": null
      },
      {
        "comment_id": "2294097246",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 2066,
        "pr_file": "src/api/providers/kilocode/fetchWithTimeout.ts",
        "discussion_id": "2293148154",
        "commented_code": "@@ -2,19 +2,19 @@ import * as undici from \"undici\"\n \n export function fetchWithTimeout(timeoutMs: number, headers?: Record<string, string>): typeof fetch {\n \tconst agent = new undici.Agent({ headersTimeout: timeoutMs, bodyTimeout: timeoutMs })\n-\treturn async (input, init) => {\n-\t\tconst mergedHeaders = {\n-\t\t\t...headers, // Persistent headers from function parameter\n-\t\t\t...(init?.headers || {}), // Request-specific headers (can override persistent ones)\n+\treturn (input, init) => {\n+\t\tconst requestInit: undici.RequestInit = {\n+\t\t\t...(init as undici.RequestInit),\n+\t\t\tdispatcher: agent,\n \t\t}\n-\t\tconst response = (await undici.fetch(\n-\t\t\tinput as undici.RequestInfo,\n-\t\t\t{\n-\t\t\t\t...init,\n-\t\t\t\theaders: mergedHeaders,\n-\t\t\t\tdispatcher: agent,\n-\t\t\t} as undici.RequestInit,\n-\t\t)) as unknown as Response\n-\t\treturn response\n+\n+\t\tif (headers) {\n+\t\t\trequestInit.headers = {\n+\t\t\t\t...(init?.headers || {}),\n+\t\t\t\t...headers,",
        "comment_created_at": "2025-08-22T15:50:14+00:00",
        "comment_author": "mcowger",
        "comment_body": "I made this choice because of an assumption that if the provider made the effort to set a persistent header, that it shouldn't be overridden.  But I could be convinced otherwise.   Happy to swap or you are of course welcome to force push.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284511123",
    "pr_number": 2015,
    "pr_file": "src/api/providers/kilocode-ollama.ts",
    "created_at": "2025-08-19T08:22:53+00:00",
    "commented_code": "private ensureClient(): Ollama {\n \t\tif (!this.client) {\n \t\t\ttry {\n+\t\t\t\tconst headers = this.options.ollamaApiKey\n+\t\t\t\t\t? { Authorization: this.options.ollamaApiKey } //Yes, this is weird, its not a Bearer token\n+\t\t\t\t\t: undefined\n+\n \t\t\t\tthis.client = new Ollama({\n \t\t\t\t\thost: this.options.ollamaBaseUrl || \"http://localhost:11434\",\n-\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS),\n+\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS, headers),\n+\t\t\t\t\theaders: headers,",
    "repo_full_name": "Kilo-Org/kilocode",
    "discussion_comments": [
      {
        "comment_id": "2284511123",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 2015,
        "pr_file": "src/api/providers/kilocode-ollama.ts",
        "discussion_id": "2284511123",
        "commented_code": "@@ -140,9 +141,14 @@ export class KilocodeOllamaHandler extends BaseProvider {\n \tprivate ensureClient(): Ollama {\n \t\tif (!this.client) {\n \t\t\ttry {\n+\t\t\t\tconst headers = this.options.ollamaApiKey\n+\t\t\t\t\t? { Authorization: this.options.ollamaApiKey } //Yes, this is weird, its not a Bearer token\n+\t\t\t\t\t: undefined\n+\n \t\t\t\tthis.client = new Ollama({\n \t\t\t\t\thost: this.options.ollamaBaseUrl || \"http://localhost:11434\",\n-\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS),\n+\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS, headers),\n+\t\t\t\t\theaders: headers,",
        "comment_created_at": "2025-08-19T08:22:53+00:00",
        "comment_author": "chrarnoldus",
        "comment_body": "Why are the headers set twice?",
        "pr_file_module": null
      },
      {
        "comment_id": "2285441930",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 2015,
        "pr_file": "src/api/providers/kilocode-ollama.ts",
        "discussion_id": "2284511123",
        "commented_code": "@@ -140,9 +141,14 @@ export class KilocodeOllamaHandler extends BaseProvider {\n \tprivate ensureClient(): Ollama {\n \t\tif (!this.client) {\n \t\t\ttry {\n+\t\t\t\tconst headers = this.options.ollamaApiKey\n+\t\t\t\t\t? { Authorization: this.options.ollamaApiKey } //Yes, this is weird, its not a Bearer token\n+\t\t\t\t\t: undefined\n+\n \t\t\t\tthis.client = new Ollama({\n \t\t\t\t\thost: this.options.ollamaBaseUrl || \"http://localhost:11434\",\n-\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS),\n+\t\t\t\t\tfetch: fetchWithTimeout(OLLAMA_TIMEOUT_MS, headers),\n+\t\t\t\t\theaders: headers,",
        "comment_created_at": "2025-08-19T14:21:43+00:00",
        "comment_author": "mcowger",
        "comment_body": "Recent versions of the ollama client started allowing for headers, but they don't pass into an overridden fetch function.  \n\nSo, to make sure they are available in all needed contexts, I've set them in both possible locations.  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1995715349",
    "pr_number": 43,
    "pr_file": "src/api/providers/kilocode.ts",
    "created_at": "2025-03-14T14:46:22+00:00",
    "commented_code": "})\n \t}\n \n-\tasync *createMessage(systemPrompt: string, messages: Anthropic.Messages.MessageParam[]): ApiStream {\n+\tprivate getIdempotencyKey(taskId: string, checkpointNumber: number): string {\n+\t\t// Create a deterministic idempotency key based on task_id and checkpoint number\n+\t\treturn `${taskId}-${checkpointNumber}`\n+\t}\n+\n+\tasync *createMessage(\n+\t\tsystemPrompt: string,\n+\t\tmessages: Anthropic.Messages.MessageParam[],\n+\t\ttaskId?: string,\n+\t\tcheckpointNumber?: number,\n+\t): ApiStream {\n \t\tlet stream: AnthropicStream<Anthropic.Messages.RawMessageStreamEvent>\n \t\tconst cacheControl: CacheControlEphemeral = { type: \"ephemeral\" }\n-\t\tlet { id: modelId, maxTokens, thinking, temperature, virtualId } = this.getModel()\n+\t\tconst { id: modelId, maxTokens, thinking, temperature, virtualId } = this.getModel()\n \n-\t\tconst userMsgIndices = messages.reduce(\n-\t\t\t(acc, msg, index) => (msg.role === \"user\" ? [...acc, index] : acc),\n-\t\t\t[] as number[],\n-\t\t)\n+\t\t// Use a for loop instead of reduce with spread to avoid linting error\n+\t\tconst userMsgIndices: number[] = []\n+\t\tfor (let i = 0; i < messages.length; i++) {\n+\t\t\tif (messages[i].role === \"user\") {\n+\t\t\t\tuserMsgIndices.push(i)\n+\t\t\t}\n+\t\t}\n \n \t\tconst lastUserMsgIndex = userMsgIndices[userMsgIndices.length - 1] ?? -1\n \t\tconst secondLastMsgUserIndex = userMsgIndices[userMsgIndices.length - 2] ?? -1\n \n+\t\t// Prepare request options with headers\n+\t\tconst requestOptions: { headers: Record<string, string> } = (() => {\n+\t\t\tconst betas: string[] = []\n+\n+\t\t\t// Check for models that support prompt caching\n+\t\t\tswitch (modelId) {\n+\t\t\t\tcase \"claude-3-7-sonnet-20250219\":\n+\t\t\t\tcase \"claude-3-5-sonnet-20241022\":\n+\t\t\t\tcase \"claude-3-5-haiku-20241022\":\n+\t\t\t\tcase \"claude-3-opus-20240229\":\n+\t\t\t\tcase \"claude-3-haiku-20240307\":\n+\t\t\t\t\tbetas.push(\"prompt-caching-2024-07-31\")\n+\t\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tconst headers: Record<string, string> = {}\n+\n+\t\t\t// Add beta features if any\n+\t\t\tif (betas.length > 0) {\n+\t\t\t\theaders[\"anthropic-beta\"] = betas.join(\",\")\n+\t\t\t}\n+\n+\t\t\t// Add idempotency key if task_id and checkpoint number are provided\n+\t\t\tif (taskId && checkpointNumber !== undefined) {\n+\t\t\t\theaders[\"idempotency-key\"] = this.getIdempotencyKey(taskId, checkpointNumber)\n+\t\t\t}",
    "repo_full_name": "Kilo-Org/kilocode",
    "discussion_comments": [
      {
        "comment_id": "1995715349",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 43,
        "pr_file": "src/api/providers/kilocode.ts",
        "discussion_id": "1995715349",
        "commented_code": "@@ -20,19 +20,62 @@ export class KiloCodeHandler extends BaseProvider implements SingleCompletionHan\n \t\t})\n \t}\n \n-\tasync *createMessage(systemPrompt: string, messages: Anthropic.Messages.MessageParam[]): ApiStream {\n+\tprivate getIdempotencyKey(taskId: string, checkpointNumber: number): string {\n+\t\t// Create a deterministic idempotency key based on task_id and checkpoint number\n+\t\treturn `${taskId}-${checkpointNumber}`\n+\t}\n+\n+\tasync *createMessage(\n+\t\tsystemPrompt: string,\n+\t\tmessages: Anthropic.Messages.MessageParam[],\n+\t\ttaskId?: string,\n+\t\tcheckpointNumber?: number,\n+\t): ApiStream {\n \t\tlet stream: AnthropicStream<Anthropic.Messages.RawMessageStreamEvent>\n \t\tconst cacheControl: CacheControlEphemeral = { type: \"ephemeral\" }\n-\t\tlet { id: modelId, maxTokens, thinking, temperature, virtualId } = this.getModel()\n+\t\tconst { id: modelId, maxTokens, thinking, temperature, virtualId } = this.getModel()\n \n-\t\tconst userMsgIndices = messages.reduce(\n-\t\t\t(acc, msg, index) => (msg.role === \"user\" ? [...acc, index] : acc),\n-\t\t\t[] as number[],\n-\t\t)\n+\t\t// Use a for loop instead of reduce with spread to avoid linting error\n+\t\tconst userMsgIndices: number[] = []\n+\t\tfor (let i = 0; i < messages.length; i++) {\n+\t\t\tif (messages[i].role === \"user\") {\n+\t\t\t\tuserMsgIndices.push(i)\n+\t\t\t}\n+\t\t}\n \n \t\tconst lastUserMsgIndex = userMsgIndices[userMsgIndices.length - 1] ?? -1\n \t\tconst secondLastMsgUserIndex = userMsgIndices[userMsgIndices.length - 2] ?? -1\n \n+\t\t// Prepare request options with headers\n+\t\tconst requestOptions: { headers: Record<string, string> } = (() => {\n+\t\t\tconst betas: string[] = []\n+\n+\t\t\t// Check for models that support prompt caching\n+\t\t\tswitch (modelId) {\n+\t\t\t\tcase \"claude-3-7-sonnet-20250219\":\n+\t\t\t\tcase \"claude-3-5-sonnet-20241022\":\n+\t\t\t\tcase \"claude-3-5-haiku-20241022\":\n+\t\t\t\tcase \"claude-3-opus-20240229\":\n+\t\t\t\tcase \"claude-3-haiku-20240307\":\n+\t\t\t\t\tbetas.push(\"prompt-caching-2024-07-31\")\n+\t\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tconst headers: Record<string, string> = {}\n+\n+\t\t\t// Add beta features if any\n+\t\t\tif (betas.length > 0) {\n+\t\t\t\theaders[\"anthropic-beta\"] = betas.join(\",\")\n+\t\t\t}\n+\n+\t\t\t// Add idempotency key if task_id and checkpoint number are provided\n+\t\t\tif (taskId && checkpointNumber !== undefined) {\n+\t\t\t\theaders[\"idempotency-key\"] = this.getIdempotencyKey(taskId, checkpointNumber)\n+\t\t\t}",
        "comment_created_at": "2025-03-14T14:46:22+00:00",
        "comment_author": "kevinvandijk",
        "comment_body": "This is the AI way of doing it, the more efficient (preventing multiple object mutations) and readable way (imho) to do it would be like this:\r\n```typescript\r\nconst headers = {\r\n  'anthropic-beta': betas.length > 0 ? betas.join(\",\") : undefined,\r\n  'idempotency-key': taskId && checkpointNumber !== undefined ? this.getIdempotencyKey(taskId, checkpointNumber),\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]