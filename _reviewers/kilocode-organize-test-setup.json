[
  {
    "discussion_id": "2166357911",
    "pr_number": 832,
    "pr_file": "webview-ui/src/utils/vscode.ts",
    "created_at": "2025-06-25T10:15:30+00:00",
    "commented_code": "// Exports class singleton to prevent multiple invocations of acquireVsCodeApi.\n export const vscode = new VSCodeAPIWrapper()\n+\n+// kilocode_change start\n+// Make vscode API available globally for testing purposes",
    "repo_full_name": "Kilo-Org/kilocode",
    "discussion_comments": [
      {
        "comment_id": "2166357911",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 832,
        "pr_file": "webview-ui/src/utils/vscode.ts",
        "discussion_id": "2166357911",
        "commented_code": "@@ -78,3 +78,10 @@ class VSCodeAPIWrapper {\n \n // Exports class singleton to prevent multiple invocations of acquireVsCodeApi.\n export const vscode = new VSCodeAPIWrapper()\n+\n+// kilocode_change start\n+// Make vscode API available globally for testing purposes",
        "comment_created_at": "2025-06-25T10:15:30+00:00",
        "comment_author": "chrarnoldus",
        "comment_body": "Why is this necessary?",
        "pr_file_module": null
      },
      {
        "comment_id": "2167642876",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 832,
        "pr_file": "webview-ui/src/utils/vscode.ts",
        "discussion_id": "2166357911",
        "commented_code": "@@ -78,3 +78,10 @@ class VSCodeAPIWrapper {\n \n // Exports class singleton to prevent multiple invocations of acquireVsCodeApi.\n export const vscode = new VSCodeAPIWrapper()\n+\n+// kilocode_change start\n+// Make vscode API available globally for testing purposes",
        "comment_created_at": "2025-06-25T21:11:51+00:00",
        "comment_author": "hassoncs",
        "comment_body": "I added a better comment on the Roo side PR. In short to make setting up providers easier\r\n\r\n```\r\n// Make vscode available globally - this allows the playwright tests\r\n// to post messages directly so we can setup provider credentials\r\n//  without having to go through the Settings UI in every test.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181009870",
    "pr_number": 956,
    "pr_file": "src/services/autocomplete/__tests__/AutocompleteProvider.test.ts",
    "created_at": "2025-07-02T21:31:29+00:00",
    "commented_code": "expect(provider.hasAcceptedFirstLine).toBe(false)\n \t})\n })\n+\n+describe(\"AutocompleteProvider whitespace handling\", () => {\n+\tlet mockContext: any\n+\tlet mockProvider: any\n+\tlet provideInlineCompletionItems: any\n+\n+\tbeforeEach(() => {\n+\t\tvi.clearAllMocks()\n+\n+\t\tmockContext = {\n+\t\t\tsubscriptions: [],\n+\t\t}\n+\n+\t\t// Set up experiment flag to enable autocomplete\n+\t\tvi.mocked(ContextProxy.instance.getGlobalState).mockReturnValue({\n+\t\t\tautocomplete: true,\n+\t\t})\n+\n+\t\t// Capture the provider when it's registered\n+\t\tvi.mocked(vscode.languages.registerInlineCompletionItemProvider).mockImplementation((selector, provider) => {\n+\t\t\tmockProvider = provider\n+\t\t\tprovideInlineCompletionItems = provider.provideInlineCompletionItems\n+\t\t\treturn { dispose: vi.fn() }\n+\t\t})\n+\t})\n+\n+\tafterEach(() => {\n+\t\tvi.clearAllTimers()\n+\t})\n+\n+\tit(\"should not provide completions when cursor is in whitespace at start of line\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))\n+\n+\t\t// Mock document and position for whitespace at start of line\n+\t\tconst mockDocument = {\n+\t\t\tlineAt: vi.fn().mockReturnValue({\n+\t\t\t\ttext: \"    \", // Line with only whitespace\n+\t\t\t}),\n+\t\t\tgetText: vi.fn().mockReturnValue(\"\"),\n+\t\t}\n+\n+\t\tconst mockPosition = new vscode.Position(0, 2) // Cursor at position 2 in whitespace\n+\n+\t\tconst mockToken = {\n+\t\t\tisCancellationRequested: false,\n+\t\t}\n+\n+\t\t// Call the provider\n+\t\tconst result = await provideInlineCompletionItems(mockDocument, mockPosition, {}, mockToken)\n+\n+\t\t// Should return null when in whitespace at start of line\n+\t\texpect(result).toBeNull()\n+\t})\n+\n+\tit(\"verifies whitespace check logic works correctly\", () => {\n+\t\t// This test verifies that our whitespace check logic works correctly\n+\t\t// by directly testing the condition we added\n+\n+\t\t// Case 1: Whitespace at start of line (should skip autocomplete)\n+\t\tconst lineWithOnlyWhitespace = \"    \"\n+\t\tconst positionInWhitespace = 2\n+\t\texpect(lineWithOnlyWhitespace.substring(0, positionInWhitespace).trim()).toBe(\"\")\n+\n+\t\t// Case 2: Text after whitespace (should not skip autocomplete)\n+\t\tconst lineWithText = \"    const foo\"\n+\t\tconst positionAfterText = 13\n+\t\texpect(lineWithText.substring(0, positionAfterText).trim()).not.toBe(\"\")\n+\t})\n+\n+\tit(\"should not provide completions when cursor is at start of empty line\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))\n+\n+\t\t// Mock document and position for empty line\n+\t\tconst mockDocument = {\n+\t\t\tlineAt: vi.fn().mockReturnValue({\n+\t\t\t\ttext: \"\", // Empty line\n+\t\t\t}),\n+\t\t\tgetText: vi.fn().mockReturnValue(\"\"),\n+\t\t}\n+\n+\t\tconst mockPosition = new vscode.Position(0, 0) // Cursor at start of empty line\n+\n+\t\tconst mockToken = {\n+\t\t\tisCancellationRequested: false,\n+\t\t}\n+\n+\t\t// Call the provider\n+\t\tconst result = await provideInlineCompletionItems(mockDocument, mockPosition, {}, mockToken)\n+\n+\t\t// Should return null when at start of empty line\n+\t\texpect(result).toBeNull()\n+\t})\n+\n+\tit(\"verifies whitespace check logic allows completions at end of whitespace-only line\", () => {\n+\t\t// This test directly verifies the condition we modified in AutocompleteProvider.ts\n+\n+\t\t// Case 1: Whitespace at start of line but NOT at the end (should skip autocomplete)\n+\t\tconst lineWithOnlyWhitespace = \"    \"\n+\t\tconst positionInWhitespace = 2 // Cursor in the middle of whitespace\n+\t\tconst textBeforeCursor1 = lineWithOnlyWhitespace.substring(0, positionInWhitespace)\n+\n+\t\t// Verify our condition would skip autocomplete\n+\t\texpect(textBeforeCursor1.trim() === \"\" && positionInWhitespace !== lineWithOnlyWhitespace.length).toBe(true)\n+\n+\t\t// Case 2: Whitespace-only line with cursor at the end (should NOT skip autocomplete)\n+\t\tconst positionAtEnd = 4 // Cursor at the end of whitespace\n+\t\tconst textBeforeCursor2 = lineWithOnlyWhitespace.substring(0, positionAtEnd)\n+\n+\t\t// Verify our condition would NOT skip autocomplete\n+\t\texpect(textBeforeCursor2.trim() === \"\" && positionAtEnd !== lineWithOnlyWhitespace.length).toBe(false)\n+\t})\n+\n+\tit(\"should not provide completions when pressing tab in indentation\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))",
    "repo_full_name": "Kilo-Org/kilocode",
    "discussion_comments": [
      {
        "comment_id": "2181009870",
        "repo_full_name": "Kilo-Org/kilocode",
        "pr_number": 956,
        "pr_file": "src/services/autocomplete/__tests__/AutocompleteProvider.test.ts",
        "discussion_id": "2181009870",
        "commented_code": "@@ -197,3 +303,151 @@ describe(\"Two-stage completion acceptance\", () => {\n \t\texpect(provider.hasAcceptedFirstLine).toBe(false)\n \t})\n })\n+\n+describe(\"AutocompleteProvider whitespace handling\", () => {\n+\tlet mockContext: any\n+\tlet mockProvider: any\n+\tlet provideInlineCompletionItems: any\n+\n+\tbeforeEach(() => {\n+\t\tvi.clearAllMocks()\n+\n+\t\tmockContext = {\n+\t\t\tsubscriptions: [],\n+\t\t}\n+\n+\t\t// Set up experiment flag to enable autocomplete\n+\t\tvi.mocked(ContextProxy.instance.getGlobalState).mockReturnValue({\n+\t\t\tautocomplete: true,\n+\t\t})\n+\n+\t\t// Capture the provider when it's registered\n+\t\tvi.mocked(vscode.languages.registerInlineCompletionItemProvider).mockImplementation((selector, provider) => {\n+\t\t\tmockProvider = provider\n+\t\t\tprovideInlineCompletionItems = provider.provideInlineCompletionItems\n+\t\t\treturn { dispose: vi.fn() }\n+\t\t})\n+\t})\n+\n+\tafterEach(() => {\n+\t\tvi.clearAllTimers()\n+\t})\n+\n+\tit(\"should not provide completions when cursor is in whitespace at start of line\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))\n+\n+\t\t// Mock document and position for whitespace at start of line\n+\t\tconst mockDocument = {\n+\t\t\tlineAt: vi.fn().mockReturnValue({\n+\t\t\t\ttext: \"    \", // Line with only whitespace\n+\t\t\t}),\n+\t\t\tgetText: vi.fn().mockReturnValue(\"\"),\n+\t\t}\n+\n+\t\tconst mockPosition = new vscode.Position(0, 2) // Cursor at position 2 in whitespace\n+\n+\t\tconst mockToken = {\n+\t\t\tisCancellationRequested: false,\n+\t\t}\n+\n+\t\t// Call the provider\n+\t\tconst result = await provideInlineCompletionItems(mockDocument, mockPosition, {}, mockToken)\n+\n+\t\t// Should return null when in whitespace at start of line\n+\t\texpect(result).toBeNull()\n+\t})\n+\n+\tit(\"verifies whitespace check logic works correctly\", () => {\n+\t\t// This test verifies that our whitespace check logic works correctly\n+\t\t// by directly testing the condition we added\n+\n+\t\t// Case 1: Whitespace at start of line (should skip autocomplete)\n+\t\tconst lineWithOnlyWhitespace = \"    \"\n+\t\tconst positionInWhitespace = 2\n+\t\texpect(lineWithOnlyWhitespace.substring(0, positionInWhitespace).trim()).toBe(\"\")\n+\n+\t\t// Case 2: Text after whitespace (should not skip autocomplete)\n+\t\tconst lineWithText = \"    const foo\"\n+\t\tconst positionAfterText = 13\n+\t\texpect(lineWithText.substring(0, positionAfterText).trim()).not.toBe(\"\")\n+\t})\n+\n+\tit(\"should not provide completions when cursor is at start of empty line\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))\n+\n+\t\t// Mock document and position for empty line\n+\t\tconst mockDocument = {\n+\t\t\tlineAt: vi.fn().mockReturnValue({\n+\t\t\t\ttext: \"\", // Empty line\n+\t\t\t}),\n+\t\t\tgetText: vi.fn().mockReturnValue(\"\"),\n+\t\t}\n+\n+\t\tconst mockPosition = new vscode.Position(0, 0) // Cursor at start of empty line\n+\n+\t\tconst mockToken = {\n+\t\t\tisCancellationRequested: false,\n+\t\t}\n+\n+\t\t// Call the provider\n+\t\tconst result = await provideInlineCompletionItems(mockDocument, mockPosition, {}, mockToken)\n+\n+\t\t// Should return null when at start of empty line\n+\t\texpect(result).toBeNull()\n+\t})\n+\n+\tit(\"verifies whitespace check logic allows completions at end of whitespace-only line\", () => {\n+\t\t// This test directly verifies the condition we modified in AutocompleteProvider.ts\n+\n+\t\t// Case 1: Whitespace at start of line but NOT at the end (should skip autocomplete)\n+\t\tconst lineWithOnlyWhitespace = \"    \"\n+\t\tconst positionInWhitespace = 2 // Cursor in the middle of whitespace\n+\t\tconst textBeforeCursor1 = lineWithOnlyWhitespace.substring(0, positionInWhitespace)\n+\n+\t\t// Verify our condition would skip autocomplete\n+\t\texpect(textBeforeCursor1.trim() === \"\" && positionInWhitespace !== lineWithOnlyWhitespace.length).toBe(true)\n+\n+\t\t// Case 2: Whitespace-only line with cursor at the end (should NOT skip autocomplete)\n+\t\tconst positionAtEnd = 4 // Cursor at the end of whitespace\n+\t\tconst textBeforeCursor2 = lineWithOnlyWhitespace.substring(0, positionAtEnd)\n+\n+\t\t// Verify our condition would NOT skip autocomplete\n+\t\texpect(textBeforeCursor2.trim() === \"\" && positionAtEnd !== lineWithOnlyWhitespace.length).toBe(false)\n+\t})\n+\n+\tit(\"should not provide completions when pressing tab in indentation\", async () => {\n+\t\t// Register autocomplete\n+\t\tregisterAutocomplete(mockContext)\n+\n+\t\t// Wait for the provider to be registered\n+\t\tawait new Promise((resolve) => setTimeout(resolve, 10))",
        "comment_created_at": "2025-07-02T21:31:29+00:00",
        "comment_author": "hassoncs",
        "comment_body": "#nit can we move these lines into the beforeEach? they seem to happen in most tests! or maybe put the autocomplete specific ones in a describe?",
        "pr_file_module": null
      }
    ]
  }
]