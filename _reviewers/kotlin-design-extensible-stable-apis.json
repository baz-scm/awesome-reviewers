[
  {
    "discussion_id": "1438374793",
    "pr_number": 5234,
    "pr_file": "plugins/jvm-abi-gen/src/org/jetbrains/kotlin/jvm/abi/JvmAbiCommandLineProcessor.kt",
    "created_at": "2023-12-29T18:59:12+00:00",
    "commented_code": "\"sites of inline functions.\",\n                false,\n            )\n\n        val REMOVE_PRIVATE_CLASSES_OPTION: CliOption =\n            CliOption(\n                \"removePrivateClasses\",\n                \"true/false\",\n                \"Remove private or effectively private classes from ABI. False by default. Note that if private class is being used \" +",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1438374793",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5234,
        "pr_file": "plugins/jvm-abi-gen/src/org/jetbrains/kotlin/jvm/abi/JvmAbiCommandLineProcessor.kt",
        "discussion_id": "1438374793",
        "commented_code": "@@ -32,18 +32,28 @@ class JvmAbiCommandLineProcessor : CommandLineProcessor {\n                         \"sites of inline functions.\",\n                 false,\n             )\n+\n+        val REMOVE_PRIVATE_CLASSES_OPTION: CliOption =\n+            CliOption(\n+                \"removePrivateClasses\",\n+                \"true/false\",\n+                \"Remove private or effectively private classes from ABI. False by default. Note that if private class is being used \" +",
        "comment_created_at": "2023-12-29T18:59:12+00:00",
        "comment_author": "artem-zinnatullin",
        "comment_body": "```suggestion\r\n                \"Remove private or effectively private classes from ABI. False by default due to backwards compatibility. If enabled — private classes will no longer be available from Java.\"\r\n```\r\n\r\nSomething like this maybe? Ideally it should be clear that setting the option to `true` is highly desirable for stable ABI and it is false by default only due to being potentially breaking for rare Java use cases.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1470548786",
    "pr_number": 5234,
    "pr_file": "plugins/jvm-abi-gen/src/org/jetbrains/kotlin/jvm/abi/JvmAbiOutputExtension.kt",
    "created_at": "2024-01-30T03:31:48+00:00",
    "commented_code": "private val keptMethods = mutableListOf<MethodNode>()\n                            private val innerClassInfos = mutableMapOf<String, InnerClassInfo>()\n\n                            override fun visit(\n                                version: Int,\n                                access: Int,\n                                name: String?,\n                                signature: String?,\n                                superName: String?,\n                                interfaces: Array<out String>?,\n                            ) {\n                                val prunedAccess = if (prune) access or Opcodes.ACC_PUBLIC else access",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1470548786",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5234,
        "pr_file": "plugins/jvm-abi-gen/src/org/jetbrains/kotlin/jvm/abi/JvmAbiOutputExtension.kt",
        "discussion_id": "1470548786",
        "commented_code": "@@ -92,15 +92,27 @@ class JvmAbiOutputExtension(\n                             private val keptMethods = mutableListOf<MethodNode>()\n                             private val innerClassInfos = mutableMapOf<String, InnerClassInfo>()\n \n+                            override fun visit(\n+                                version: Int,\n+                                access: Int,\n+                                name: String?,\n+                                signature: String?,\n+                                superName: String?,\n+                                interfaces: Array<out String>?,\n+                            ) {\n+                                val prunedAccess = if (prune) access or Opcodes.ACC_PUBLIC else access",
        "comment_created_at": "2024-01-30T03:31:48+00:00",
        "comment_author": "Tagakov",
        "comment_body": "Same as in `@Metadata`. Not sure if I should fallback to package-private here instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "1471244812",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5234,
        "pr_file": "plugins/jvm-abi-gen/src/org/jetbrains/kotlin/jvm/abi/JvmAbiOutputExtension.kt",
        "discussion_id": "1470548786",
        "commented_code": "@@ -92,15 +92,27 @@ class JvmAbiOutputExtension(\n                             private val keptMethods = mutableListOf<MethodNode>()\n                             private val innerClassInfos = mutableMapOf<String, InnerClassInfo>()\n \n+                            override fun visit(\n+                                version: Int,\n+                                access: Int,\n+                                name: String?,\n+                                signature: String?,\n+                                superName: String?,\n+                                interfaces: Array<out String>?,\n+                            ) {\n+                                val prunedAccess = if (prune) access or Opcodes.ACC_PUBLIC else access",
        "comment_created_at": "2024-01-30T13:46:30+00:00",
        "comment_author": "madsager",
        "comment_body": "My 2 cents: I don't think we should ever change the visibility of any element that ends up in the ABI jar. That makes compilation against the ABI jar and the full jar inconsistent.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1190998608",
    "pr_number": 5131,
    "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
    "created_at": "2023-05-11T11:00:21+00:00",
    "commented_code": "}\n\n    /**\n     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n     * result is the aggregation of all resolvers running.\n     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n     * and the result will be merged.\n     *\n     * However, only the resolvers in the highest resolution result will run e.g.\n     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n     * Otherwise, all [Default] resolvers will run.\n     * By 'default' resolvers are registered using [Priority.normal].\n     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n     * from the Kotlin Gradle plugin.\n     */\n    @ExternalKotlinTargetApi\n    enum class DependencyResolutionLevel {\n        Default, Overwrite\n    class Priority(val value: Int) : Comparable<Priority> {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1190998608",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5131,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
        "discussion_id": "1190998608",
        "commented_code": "@@ -149,31 +152,67 @@ interface IdeMultiplatformImport {\n     }\n \n     /**\n-     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n-     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n-     * result is the aggregation of all resolvers running.\n+     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n+     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n+     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n+     * and the result will be merged.\n      *\n-     * However, only the resolvers in the highest resolution result will run e.g.\n-     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n-     * Otherwise, all [Default] resolvers will run.\n+     * By 'default' resolvers are registered using [Priority.normal].\n+     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n+     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n+     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n+     * from the Kotlin Gradle plugin.\n      */\n     @ExternalKotlinTargetApi\n-    enum class DependencyResolutionLevel {\n-        Default, Overwrite\n+    class Priority(val value: Int) : Comparable<Priority> {",
        "comment_created_at": "2023-05-11T11:00:21+00:00",
        "comment_author": "AmrAfifiy",
        "comment_body": "Is there a reason why this is very fine grained rather than just an enum? I understand the need for having the four phases mentioned below, but why do you want to give such flexibility?",
        "pr_file_module": null
      },
      {
        "comment_id": "1191213754",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5131,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
        "discussion_id": "1190998608",
        "commented_code": "@@ -149,31 +152,67 @@ interface IdeMultiplatformImport {\n     }\n \n     /**\n-     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n-     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n-     * result is the aggregation of all resolvers running.\n+     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n+     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n+     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n+     * and the result will be merged.\n      *\n-     * However, only the resolvers in the highest resolution result will run e.g.\n-     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n-     * Otherwise, all [Default] resolvers will run.\n+     * By 'default' resolvers are registered using [Priority.normal].\n+     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n+     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n+     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n+     * from the Kotlin Gradle plugin.\n      */\n     @ExternalKotlinTargetApi\n-    enum class DependencyResolutionLevel {\n-        Default, Overwrite\n+    class Priority(val value: Int) : Comparable<Priority> {",
        "comment_created_at": "2023-05-11T13:59:29+00:00",
        "comment_author": "sellmair",
        "comment_body": "Yes! There are two reasons for this change (maybe three)\r\n\r\n1): You see that KGP already also overwrites some resolvers with a constraint and the Level.Overwrite. Such overwrites therefore cannot again be overwritten by you folks\r\n\r\n2): The API was not intuitive enough. Everybody who stumbled over it had to ask for how it works. I really hope that Priority is just simpler to understand \r\n\r\n3): Enums in public API are much more complicated. How could we have added a value safely? This could have been a rather complicated process! \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1191432325",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5131,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
        "discussion_id": "1190998608",
        "commented_code": "@@ -149,31 +152,67 @@ interface IdeMultiplatformImport {\n     }\n \n     /**\n-     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n-     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n-     * result is the aggregation of all resolvers running.\n+     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n+     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n+     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n+     * and the result will be merged.\n      *\n-     * However, only the resolvers in the highest resolution result will run e.g.\n-     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n-     * Otherwise, all [Default] resolvers will run.\n+     * By 'default' resolvers are registered using [Priority.normal].\n+     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n+     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n+     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n+     * from the Kotlin Gradle plugin.\n      */\n     @ExternalKotlinTargetApi\n-    enum class DependencyResolutionLevel {\n-        Default, Overwrite\n+    class Priority(val value: Int) : Comparable<Priority> {",
        "comment_created_at": "2023-05-11T16:29:39+00:00",
        "comment_author": "AmrAfifiy",
        "comment_body": "I'm worried about that there is no way for a target to know if its resolvers end up running or not. Also if a plugin wants to match the highest priority that currently exists and just contribute to the resolution without completely overriding it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1191453535",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5131,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
        "discussion_id": "1190998608",
        "commented_code": "@@ -149,31 +152,67 @@ interface IdeMultiplatformImport {\n     }\n \n     /**\n-     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n-     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n-     * result is the aggregation of all resolvers running.\n+     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n+     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n+     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n+     * and the result will be merged.\n      *\n-     * However, only the resolvers in the highest resolution result will run e.g.\n-     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n-     * Otherwise, all [Default] resolvers will run.\n+     * By 'default' resolvers are registered using [Priority.normal].\n+     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n+     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n+     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n+     * from the Kotlin Gradle plugin.\n      */\n     @ExternalKotlinTargetApi\n-    enum class DependencyResolutionLevel {\n-        Default, Overwrite\n+    class Priority(val value: Int) : Comparable<Priority> {",
        "comment_created_at": "2023-05-11T16:50:05+00:00",
        "comment_author": "sellmair",
        "comment_body": "Those are good thoughts. \r\nHowever, I think it will get very complex if you want to make the API support more advanced semantics. \r\nThe previous version seemed already insufficient to handle potential edge cases between AGP and KGP. The new API might be tricky when AGP and some unknown vendor (or build author) tries to contribute some resolvers. \r\n\r\nHowever, the new API, whilst rather low level, seems flexible enough to handle known use cases and to evolve!\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1191454163",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5131,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/plugin/ide/IdeMultiplatformImport.kt",
        "discussion_id": "1190998608",
        "commented_code": "@@ -149,31 +152,67 @@ interface IdeMultiplatformImport {\n     }\n \n     /**\n-     * Any [IdeDependencyResolver] has to be registered specifying a certain resolution level.\n-     * Generally, all resolvers registered in a given resolution level will work collaboratively, meaning the dependency resolution\n-     * result is the aggregation of all resolvers running.\n+     * Indicating the 'priority' of a given [IdeDependencyResolver] or [IdeAdditionalArtifactResolver]:\n+     * When resolving dependencies, only the highest priority resolver will be selected and executed.\n+     * If there are multiple resolvers with the same [Priority] registered, then all of them will be executed\n+     * and the result will be merged.\n      *\n-     * However, only the resolvers in the highest resolution result will run e.g.\n-     * If resolvers with level [Overwrite] are found, then only those will contribute to the dependency resolution.\n-     * Otherwise, all [Default] resolvers will run.\n+     * By 'default' resolvers are registered using [Priority.normal].\n+     * The Kotlin Gradle Plugin is not expected to register resolvers outside the [normal] or [high] priorities\n+     * External Kotlin Target maintainers _(such as Google)_ can therefore use [veryHigh] to overwrite all resolvers\n+     * from the Kotlin Gradle plugin or [low] to only register a resolver if there is nothing available by default\n+     * from the Kotlin Gradle plugin.\n      */\n     @ExternalKotlinTargetApi\n-    enum class DependencyResolutionLevel {\n-        Default, Overwrite\n+    class Priority(val value: Int) : Comparable<Priority> {",
        "comment_created_at": "2023-05-11T16:50:45+00:00",
        "comment_author": "sellmair",
        "comment_body": "If we know about uses cases where its hard for a third party to sync with AGP and KGP, then we could start designing new APIs to make this cases easier! \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1172544836",
    "pr_number": 5121,
    "pr_file": "libraries/tools/kotlin-gradle-plugin/build.gradle.kts",
    "created_at": "2023-04-20T12:53:02+00:00",
    "commented_code": "languageSettings.optIn(\"org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi\")\n}\n\napiValidation {\n    publicMarkers.add(\"org.jetbrains.kotlin.gradle.ExternalKotlinTargetApi\")",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1172544836",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5121,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/build.gradle.kts",
        "discussion_id": "1172544836",
        "commented_code": "@@ -26,6 +27,12 @@ kotlin.sourceSets.all {\n     languageSettings.optIn(\"org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi\")\n }\n \n+apiValidation {\n+    publicMarkers.add(\"org.jetbrains.kotlin.gradle.ExternalKotlinTargetApi\")",
        "comment_created_at": "2023-04-20T12:53:02+00:00",
        "comment_author": "AmrAfifiy",
        "comment_body": "are all APIs annotated with @ExternalKotlinTargetApi end up in kotlin-gradle-plugin-api artifact?",
        "pr_file_module": null
      },
      {
        "comment_id": "1173565747",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5121,
        "pr_file": "libraries/tools/kotlin-gradle-plugin/build.gradle.kts",
        "discussion_id": "1172544836",
        "commented_code": "@@ -26,6 +27,12 @@ kotlin.sourceSets.all {\n     languageSettings.optIn(\"org.jetbrains.kotlin.compiler.plugin.ExperimentalCompilerApi\")\n }\n \n+apiValidation {\n+    publicMarkers.add(\"org.jetbrains.kotlin.gradle.ExternalKotlinTargetApi\")",
        "comment_created_at": "2023-04-21T09:39:08+00:00",
        "comment_author": "sellmair",
        "comment_body": "No, those apis will be part of the `kotlin-gradle-plugin` artifact as those APIs are required to call into internal APIs of the implementation. So: `kotlin-gradle-plugin-api` already has binary compatibility validation, `kotlin-gradle-plugin` has not, but APIs marked with this annotation will have to be kept stable!\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "454254122",
    "pr_number": 3544,
    "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
    "created_at": "2020-07-14T10:19:21+00:00",
    "commented_code": "/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.script.experimental.dependencies\n\nfun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n    value(name.key)\n\nfun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n    flag(name.key)\n\noperator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n    put(key.key, value)\n}\n\n\nenum class DependenciesResolverOptionsName {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "454254122",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3544,
        "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
        "discussion_id": "454254122",
        "commented_code": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.dependencies\n+\n+fun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n+    value(name.key)\n+\n+fun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n+    flag(name.key)\n+\n+operator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n+    put(key.key, value)\n+}\n+\n+\n+enum class DependenciesResolverOptionsName {",
        "comment_created_at": "2020-07-14T10:19:21+00:00",
        "comment_author": "nerdsupremacist",
        "comment_body": "These options seem very specific to the individual dependencies resolvers. Perhaps it would be more appropriate to prefix this with a `Maven*` or `Ivy*` respectively.\r\n\r\nThis API is not implemented by many other resolvers that I know of. But what I want to avoid is someone implementing a dependencies resolver and thinking they:\r\n1. have to support these exact options\r\n1. are only allowed to support these exact options\r\n\r\n@ligee what do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "454392948",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3544,
        "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
        "discussion_id": "454254122",
        "commented_code": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.dependencies\n+\n+fun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n+    value(name.key)\n+\n+fun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n+    flag(name.key)\n+\n+operator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n+    put(key.key, value)\n+}\n+\n+\n+enum class DependenciesResolverOptionsName {",
        "comment_created_at": "2020-07-14T14:21:38+00:00",
        "comment_author": "ligee",
        "comment_body": "Thanks, @nerdsupremacist, I think the concern is valid.\r\nBut we can probably get away right now simply by moving it into the `impl` package, signalling that it is a mere implementation detail now.\r\n@ileasile, what do you think about this?",
        "pr_file_module": null
      },
      {
        "comment_id": "454436629",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3544,
        "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
        "discussion_id": "454254122",
        "commented_code": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.dependencies\n+\n+fun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n+    value(name.key)\n+\n+fun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n+    flag(name.key)\n+\n+operator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n+    put(key.key, value)\n+}\n+\n+\n+enum class DependenciesResolverOptionsName {",
        "comment_created_at": "2020-07-14T15:18:59+00:00",
        "comment_author": "ileasile",
        "comment_body": "I see these options names only as a convenient and safe way to access \"text\" properties. Maybe it's worth adding somewhere in comments that these options are not mandatory? Also, I'm OK with moving it into the `impl` package.",
        "pr_file_module": null
      },
      {
        "comment_id": "454566489",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3544,
        "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
        "discussion_id": "454254122",
        "commented_code": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.dependencies\n+\n+fun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n+    value(name.key)\n+\n+fun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n+    flag(name.key)\n+\n+operator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n+    put(key.key, value)\n+}\n+\n+\n+enum class DependenciesResolverOptionsName {",
        "comment_created_at": "2020-07-14T18:41:52+00:00",
        "comment_author": "ligee",
        "comment_body": "I understand your intention here, but we don't want to expose it as a generic API. So, please move it to the `impl`.",
        "pr_file_module": null
      },
      {
        "comment_id": "454632609",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3544,
        "pr_file": "libraries/scripting/dependencies/src/kotlin/script/experimental/dependencies/resolverNamedOptions.kt",
        "discussion_id": "454254122",
        "commented_code": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.dependencies\n+\n+fun ExternalDependenciesResolver.Options.value(name: DependenciesResolverOptionsName) =\n+    value(name.key)\n+\n+fun ExternalDependenciesResolver.Options.flag(name: DependenciesResolverOptionsName) =\n+    flag(name.key)\n+\n+operator fun MutableMap<String, String>.set(key: DependenciesResolverOptionsName, value: String) {\n+    put(key.key, value)\n+}\n+\n+\n+enum class DependenciesResolverOptionsName {",
        "comment_created_at": "2020-07-14T20:43:00+00:00",
        "comment_author": "ileasile",
        "comment_body": "Sure. Done ✔️ ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "429148358",
    "pr_number": 3415,
    "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/TransformerHelpers.kt",
    "created_at": "2020-05-22T09:42:26+00:00",
    "commented_code": "/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.jetbrains.kotlinx.atomicfu.compiler.extensions\n\nimport org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\nimport org.jetbrains.kotlin.descriptors.ClassConstructorDescriptor\nimport org.jetbrains.kotlin.descriptors.ClassDescriptor\nimport org.jetbrains.kotlin.descriptors.FunctionDescriptor\nimport org.jetbrains.kotlin.incremental.components.NoLookupLocation\nimport org.jetbrains.kotlin.ir.UNDEFINED_OFFSET\nimport org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder\nimport org.jetbrains.kotlin.ir.declarations.*\nimport org.jetbrains.kotlin.ir.expressions.*\nimport org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl\nimport org.jetbrains.kotlin.ir.expressions.impl.IrGetFieldImpl\nimport org.jetbrains.kotlin.ir.expressions.impl.IrSetFieldImpl\nimport org.jetbrains.kotlin.ir.symbols.*\nimport org.jetbrains.kotlin.ir.types.*\nimport org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeImpl\nimport org.jetbrains.kotlin.ir.types.impl.makeTypeProjection\nimport org.jetbrains.kotlin.name.FqName\nimport org.jetbrains.kotlin.name.Name\nimport org.jetbrains.kotlin.resolve.scopes.MemberScope\nimport org.jetbrains.kotlin.types.Variance\nimport kotlin.random.Random\n\ninterface TransformerHelpers {\n\n    val context: IrPluginContext\n\n    fun buildCall(\n        target: IrFunctionSymbol,\n        type: IrType? = null,\n        origin: IrStatementOrigin,\n        typeArguments: List<IrType>? = null,\n        valueArguments: List<IrExpression?>? = null\n    ): IrCall =\n        IrCallImpl(\n            UNDEFINED_OFFSET,\n            UNDEFINED_OFFSET,\n            type ?: target.owner.returnType,\n            target,\n            target.descriptor.typeParametersCount,\n            origin\n        ).apply {\n            typeArguments?.let {\n                assert(typeArguments.size == typeArgumentsCount)\n                it.withIndex().forEach { (i, t) -> putTypeArgument(i, t) }\n            }\n            valueArguments?.let {\n                assert(valueArguments.size == valueArgumentsCount)\n                it.withIndex().forEach { (i, arg) -> putValueArgument(i, arg) }\n            }\n        }\n\n    fun buildSetField(\n        symbol: IrFieldSymbol,\n        receiver: IrExpression?,\n        value: IrExpression,\n        superQualifierSymbol: IrClassSymbol? = null\n    ) =\n        IrSetFieldImpl(\n            UNDEFINED_OFFSET,\n            UNDEFINED_OFFSET,\n            symbol,\n            receiver,\n            value,\n            value.type,\n            IrStatementOrigin.INVOKE,\n            superQualifierSymbol\n        )\n\n    fun buildGetField(symbol: IrFieldSymbol, receiver: IrExpression?, superQualifierSymbol: IrClassSymbol? = null, type: IrType? = null) =\n        IrGetFieldImpl(\n            UNDEFINED_OFFSET,\n            UNDEFINED_OFFSET,\n            symbol,\n            type ?: symbol.owner.type,\n            receiver,\n            IrStatementOrigin.GET_PROPERTY,\n            superQualifierSymbol\n        )\n\n    fun buildFunctionSimpleType(typeParameters: List<IrType>): IrSimpleType {\n        val parametersCount = typeParameters.size - 1\n        val classDesc = context.irBuiltIns.builtIns.getFunction(parametersCount)\n        val symbol = context.symbolTable.referenceClass(classDesc)\n        return IrSimpleTypeImpl(\n            classifier = symbol,\n            hasQuestionMark = false,\n            arguments = typeParameters.map { it.toTypeArgument() },\n            annotations = emptyList()\n        )\n    }\n\n    fun getterName(name: String) = \"<get-$name>${Random.nextInt()}\"\n    fun setterName(name: String) = \"<set-$name>${Random.nextInt()}\"\n    fun Name.getFieldName() = \"<get-(\\\\w+)>\".toRegex().find(asString())?.groupValues?.get(1)\n\n    private fun IrType.toTypeArgument(): IrTypeArgument {\n        return makeTypeProjection(this, Variance.INVARIANT)\n    }\n\n    fun IrCall.getValueArguments() = (0 until valueArgumentsCount).map { i ->\n        getValueArgument(i)\n    }\n\n    fun IrValueParameter.capture() = JsIrBuilder.buildGetValue(symbol)\n\n    fun referencePackageFunction(",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "429148358",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3415,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/TransformerHelpers.kt",
        "discussion_id": "429148358",
        "commented_code": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.descriptors.ClassConstructorDescriptor\n+import org.jetbrains.kotlin.descriptors.ClassDescriptor\n+import org.jetbrains.kotlin.descriptors.FunctionDescriptor\n+import org.jetbrains.kotlin.incremental.components.NoLookupLocation\n+import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl\n+import org.jetbrains.kotlin.ir.expressions.impl.IrGetFieldImpl\n+import org.jetbrains.kotlin.ir.expressions.impl.IrSetFieldImpl\n+import org.jetbrains.kotlin.ir.symbols.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeImpl\n+import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection\n+import org.jetbrains.kotlin.name.FqName\n+import org.jetbrains.kotlin.name.Name\n+import org.jetbrains.kotlin.resolve.scopes.MemberScope\n+import org.jetbrains.kotlin.types.Variance\n+import kotlin.random.Random\n+\n+interface TransformerHelpers {\n+\n+    val context: IrPluginContext\n+\n+    fun buildCall(\n+        target: IrFunctionSymbol,\n+        type: IrType? = null,\n+        origin: IrStatementOrigin,\n+        typeArguments: List<IrType>? = null,\n+        valueArguments: List<IrExpression?>? = null\n+    ): IrCall =\n+        IrCallImpl(\n+            UNDEFINED_OFFSET,\n+            UNDEFINED_OFFSET,\n+            type ?: target.owner.returnType,\n+            target,\n+            target.descriptor.typeParametersCount,\n+            origin\n+        ).apply {\n+            typeArguments?.let {\n+                assert(typeArguments.size == typeArgumentsCount)\n+                it.withIndex().forEach { (i, t) -> putTypeArgument(i, t) }\n+            }\n+            valueArguments?.let {\n+                assert(valueArguments.size == valueArgumentsCount)\n+                it.withIndex().forEach { (i, arg) -> putValueArgument(i, arg) }\n+            }\n+        }\n+\n+    fun buildSetField(\n+        symbol: IrFieldSymbol,\n+        receiver: IrExpression?,\n+        value: IrExpression,\n+        superQualifierSymbol: IrClassSymbol? = null\n+    ) =\n+        IrSetFieldImpl(\n+            UNDEFINED_OFFSET,\n+            UNDEFINED_OFFSET,\n+            symbol,\n+            receiver,\n+            value,\n+            value.type,\n+            IrStatementOrigin.INVOKE,\n+            superQualifierSymbol\n+        )\n+\n+    fun buildGetField(symbol: IrFieldSymbol, receiver: IrExpression?, superQualifierSymbol: IrClassSymbol? = null, type: IrType? = null) =\n+        IrGetFieldImpl(\n+            UNDEFINED_OFFSET,\n+            UNDEFINED_OFFSET,\n+            symbol,\n+            type ?: symbol.owner.type,\n+            receiver,\n+            IrStatementOrigin.GET_PROPERTY,\n+            superQualifierSymbol\n+        )\n+\n+    fun buildFunctionSimpleType(typeParameters: List<IrType>): IrSimpleType {\n+        val parametersCount = typeParameters.size - 1\n+        val classDesc = context.irBuiltIns.builtIns.getFunction(parametersCount)\n+        val symbol = context.symbolTable.referenceClass(classDesc)\n+        return IrSimpleTypeImpl(\n+            classifier = symbol,\n+            hasQuestionMark = false,\n+            arguments = typeParameters.map { it.toTypeArgument() },\n+            annotations = emptyList()\n+        )\n+    }\n+\n+    fun getterName(name: String) = \"<get-$name>${Random.nextInt()}\"\n+    fun setterName(name: String) = \"<set-$name>${Random.nextInt()}\"\n+    fun Name.getFieldName() = \"<get-(\\\\w+)>\".toRegex().find(asString())?.groupValues?.get(1)\n+\n+    private fun IrType.toTypeArgument(): IrTypeArgument {\n+        return makeTypeProjection(this, Variance.INVARIANT)\n+    }\n+\n+    fun IrCall.getValueArguments() = (0 until valueArgumentsCount).map { i ->\n+        getValueArgument(i)\n+    }\n+\n+    fun IrValueParameter.capture() = JsIrBuilder.buildGetValue(symbol)\n+\n+    fun referencePackageFunction(",
        "comment_created_at": "2020-05-22T09:42:26+00:00",
        "comment_author": "romanart",
        "comment_body": "Are the following methods reference external symbol? If so, please use corresponding `IrPluginContext` API",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "429178285",
    "pr_number": 3415,
    "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformerJsIr.kt",
    "created_at": "2020-05-22T10:51:39+00:00",
    "commented_code": "/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.jetbrains.kotlinx.atomicfu.compiler.extensions\n\nimport org.jetbrains.kotlin.backend.common.deepCopyWithVariables\nimport org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\nimport org.jetbrains.kotlin.builtins.PrimitiveType\nimport org.jetbrains.kotlin.descriptors.*\nimport org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\nimport org.jetbrains.kotlin.ir.*\nimport org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\nimport org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildFunction\nimport org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildBlockBody\nimport org.jetbrains.kotlin.ir.declarations.*\nimport org.jetbrains.kotlin.ir.declarations.impl.*\nimport org.jetbrains.kotlin.ir.expressions.*\nimport org.jetbrains.kotlin.ir.expressions.impl.*\nimport org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol\nimport org.jetbrains.kotlin.ir.symbols.IrSymbol\nimport org.jetbrains.kotlin.ir.symbols.impl.*\nimport org.jetbrains.kotlin.ir.types.*\nimport org.jetbrains.kotlin.ir.util.*\nimport org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\nimport java.lang.IllegalStateException\n\nprivate const val AFU_PKG = \"kotlinx/atomicfu\"\nprivate const val LOCKS = \"locks\"\nprivate const val ATOMIC_CONSTRUCTOR = \"atomic\"\nprivate const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\nprivate const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\nprivate const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\nprivate const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\nprivate const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\nprivate const val GETTER = \"atomicfu\\$getter\"\nprivate const val SETTER = \"atomicfu\\$setter\"\nprivate const val GET = \"get\"\nprivate const val SET = \"set\"\n\nprivate fun String.prettyStr() = replace('/', '.')\n\nclass AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n\n    private val irBuiltIns = context.irBuiltIns\n\n    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n        \"AtomicInt\" to irBuiltIns.intType,\n        \"AtomicLong\" to irBuiltIns.longType,\n        \"AtomicRef\" to irBuiltIns.anyType,\n        \"AtomicBoolean\" to irBuiltIns.booleanType\n    )\n\n    private val AFU_ARRAY_CLASSES: Map<String, ClassDescriptor> = mapOf(\n        \"AtomicIntArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.INT),\n        \"AtomicLongArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.LONG),\n        \"AtomicBooleanArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.BOOLEAN),\n        \"AtomicArray\" to context.builtIns.array\n    )\n\n    override fun visitFile(irFile: IrFile): IrFile {\n        irFile.declarations.map { declaration ->\n            declaration.transformAtomicInlineDeclaration()\n        }\n        return super.visitFile(irFile)\n    }\n\n    override fun visitClass(irClass: IrClass): IrStatement {\n        irClass.declarations.map { declaration ->\n            declaration.transformAtomicInlineDeclaration()\n        }\n        return super.visitClass(irClass)\n    }\n\n    override fun visitProperty(property: IrProperty): IrStatement {\n        if (property.backingField != null) {\n            val backingField = property.backingField!!\n            if (backingField.initializer != null) {\n                val initializer = backingField.initializer!!.expression.transformAtomicValueInitializer()\n                property.backingField!!.initializer = IrExpressionBodyImpl(initializer)\n            }\n        }\n        return super.visitProperty(property)\n    }\n\n    override fun visitBlockBody(body: IrBlockBody): IrBody {\n        body.statements.forEachIndexed { i, stmt ->\n            if (stmt is IrCall) {\n                body.statements[i] = stmt.transformAtomicFunctionCall()\n            }\n        }\n        return super.visitBlockBody(body)\n    }\n\n    override fun visitBlock(block: IrBlock): IrExpression {\n        block.statements.forEachIndexed { i, stmt ->\n            if (stmt is IrCall) {\n                block.statements[i] = stmt.transformAtomicFunctionCall()\n            }\n        }\n        return super.visitBlock(block)\n    }\n\n    override fun visitReturn(returnExpr: IrReturn): IrExpression {\n        returnExpr.value = returnExpr.value.transformAtomicFunctionCall()\n        return super.visitReturn(returnExpr)\n    }\n\n    override fun visitTypeOperator(typeOp: IrTypeOperatorCall): IrExpression {\n        typeOp.argument = typeOp.argument.transformAtomicFunctionCall()\n        return super.visitTypeOperator(typeOp)\n    }\n\n    override fun visitSetVariable(setVar: IrSetVariable): IrExpression {\n        setVar.value = setVar.value.transformAtomicFunctionCall()\n        return super.visitSetVariable(setVar)\n    }\n\n    override fun visitSetField(setField: IrSetField): IrExpression {\n        setField.value = setField.value.transformAtomicFunctionCall()\n        return super.visitSetField(setField)\n    }\n\n    override fun visitVariable(declaration: IrVariable): IrStatement {\n        declaration.initializer = declaration.initializer?.transformAtomicFunctionCall()\n        return super.visitVariable(declaration)\n    }\n\n    override fun visitBranch(branch: IrBranch): IrBranch {\n        branch.apply {\n            condition = condition.transformAtomicFunctionCall()\n            result = result.transformAtomicFunctionCall()\n        }\n        return super.visitBranch(branch)\n    }\n\n    override fun visitElseBranch(branch: IrElseBranch): IrElseBranch {\n        branch.apply {\n            condition = condition.transformAtomicFunctionCall()\n            result = result.transformAtomicFunctionCall()\n        }\n        return super.visitElseBranch(branch)\n    }\n\n    private fun IrExpression.transformAtomicValueInitializer() =\n        when {\n            type.isAtomicValueType() -> getPureTypeValue()\n            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n            type.isReentrantLockType() -> buildConstNull()\n            else -> this\n        }\n\n    private fun IrDeclaration.transformAtomicInlineDeclaration() {\n        if (this is IrFunction &&\n            isInline &&\n            extensionReceiverParameter != null &&\n            extensionReceiverParameter!!.type.isAtomicValueType()\n        ) {\n            val type = extensionReceiverParameter!!.type\n            val valueType = type.atomicToValueType()\n            val getterType = buildFunctionSimpleType(listOf(irBuiltIns.unitType, valueType))\n            val setterType = buildFunctionSimpleType(listOf(valueType, irBuiltIns.unitType))\n            val valueParametersCount = valueParameters.size\n            val extendedValueParameters = mutableListOf<IrValueParameter>().apply {\n                addAll(valueParameters)\n                add(buildValueParameter(GETTER, valueParametersCount, getterType))\n                add(buildValueParameter(SETTER, valueParametersCount + 1, setterType))\n            }\n            this as IrSimpleFunction\n            (descriptor as FunctionDescriptorImpl).initialize(",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "429178285",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3415,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformerJsIr.kt",
        "discussion_id": "429178285",
        "commented_code": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.deepCopyWithVariables\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.builtins.PrimitiveType\n+import org.jetbrains.kotlin.descriptors.*\n+import org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildFunction\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildBlockBody\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.declarations.impl.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol\n+import org.jetbrains.kotlin.ir.symbols.IrSymbol\n+import org.jetbrains.kotlin.ir.symbols.impl.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\n+import java.lang.IllegalStateException\n+\n+private const val AFU_PKG = \"kotlinx/atomicfu\"\n+private const val LOCKS = \"locks\"\n+private const val ATOMIC_CONSTRUCTOR = \"atomic\"\n+private const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\n+private const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\n+private const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\n+private const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\n+private const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\n+private const val GETTER = \"atomicfu\\$getter\"\n+private const val SETTER = \"atomicfu\\$setter\"\n+private const val GET = \"get\"\n+private const val SET = \"set\"\n+\n+private fun String.prettyStr() = replace('/', '.')\n+\n+class AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n+\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicRef\" to irBuiltIns.anyType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType\n+    )\n+\n+    private val AFU_ARRAY_CLASSES: Map<String, ClassDescriptor> = mapOf(\n+        \"AtomicIntArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.INT),\n+        \"AtomicLongArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.LONG),\n+        \"AtomicBooleanArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.BOOLEAN),\n+        \"AtomicArray\" to context.builtIns.array\n+    )\n+\n+    override fun visitFile(irFile: IrFile): IrFile {\n+        irFile.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitFile(irFile)\n+    }\n+\n+    override fun visitClass(irClass: IrClass): IrStatement {\n+        irClass.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitClass(irClass)\n+    }\n+\n+    override fun visitProperty(property: IrProperty): IrStatement {\n+        if (property.backingField != null) {\n+            val backingField = property.backingField!!\n+            if (backingField.initializer != null) {\n+                val initializer = backingField.initializer!!.expression.transformAtomicValueInitializer()\n+                property.backingField!!.initializer = IrExpressionBodyImpl(initializer)\n+            }\n+        }\n+        return super.visitProperty(property)\n+    }\n+\n+    override fun visitBlockBody(body: IrBlockBody): IrBody {\n+        body.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                body.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlockBody(body)\n+    }\n+\n+    override fun visitBlock(block: IrBlock): IrExpression {\n+        block.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                block.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlock(block)\n+    }\n+\n+    override fun visitReturn(returnExpr: IrReturn): IrExpression {\n+        returnExpr.value = returnExpr.value.transformAtomicFunctionCall()\n+        return super.visitReturn(returnExpr)\n+    }\n+\n+    override fun visitTypeOperator(typeOp: IrTypeOperatorCall): IrExpression {\n+        typeOp.argument = typeOp.argument.transformAtomicFunctionCall()\n+        return super.visitTypeOperator(typeOp)\n+    }\n+\n+    override fun visitSetVariable(setVar: IrSetVariable): IrExpression {\n+        setVar.value = setVar.value.transformAtomicFunctionCall()\n+        return super.visitSetVariable(setVar)\n+    }\n+\n+    override fun visitSetField(setField: IrSetField): IrExpression {\n+        setField.value = setField.value.transformAtomicFunctionCall()\n+        return super.visitSetField(setField)\n+    }\n+\n+    override fun visitVariable(declaration: IrVariable): IrStatement {\n+        declaration.initializer = declaration.initializer?.transformAtomicFunctionCall()\n+        return super.visitVariable(declaration)\n+    }\n+\n+    override fun visitBranch(branch: IrBranch): IrBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitBranch(branch)\n+    }\n+\n+    override fun visitElseBranch(branch: IrElseBranch): IrElseBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitElseBranch(branch)\n+    }\n+\n+    private fun IrExpression.transformAtomicValueInitializer() =\n+        when {\n+            type.isAtomicValueType() -> getPureTypeValue()\n+            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n+            type.isReentrantLockType() -> buildConstNull()\n+            else -> this\n+        }\n+\n+    private fun IrDeclaration.transformAtomicInlineDeclaration() {\n+        if (this is IrFunction &&\n+            isInline &&\n+            extensionReceiverParameter != null &&\n+            extensionReceiverParameter!!.type.isAtomicValueType()\n+        ) {\n+            val type = extensionReceiverParameter!!.type\n+            val valueType = type.atomicToValueType()\n+            val getterType = buildFunctionSimpleType(listOf(irBuiltIns.unitType, valueType))\n+            val setterType = buildFunctionSimpleType(listOf(valueType, irBuiltIns.unitType))\n+            val valueParametersCount = valueParameters.size\n+            val extendedValueParameters = mutableListOf<IrValueParameter>().apply {\n+                addAll(valueParameters)\n+                add(buildValueParameter(GETTER, valueParametersCount, getterType))\n+                add(buildValueParameter(SETTER, valueParametersCount + 1, setterType))\n+            }\n+            this as IrSimpleFunction\n+            (descriptor as FunctionDescriptorImpl).initialize(",
        "comment_created_at": "2020-05-22T10:51:39+00:00",
        "comment_author": "romanart",
        "comment_body": "Please avoid using of `DeclarationDescriptor` API",
        "pr_file_module": null
      },
      {
        "comment_id": "433370829",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3415,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformerJsIr.kt",
        "discussion_id": "429178285",
        "commented_code": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.deepCopyWithVariables\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.builtins.PrimitiveType\n+import org.jetbrains.kotlin.descriptors.*\n+import org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildFunction\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildBlockBody\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.declarations.impl.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol\n+import org.jetbrains.kotlin.ir.symbols.IrSymbol\n+import org.jetbrains.kotlin.ir.symbols.impl.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\n+import java.lang.IllegalStateException\n+\n+private const val AFU_PKG = \"kotlinx/atomicfu\"\n+private const val LOCKS = \"locks\"\n+private const val ATOMIC_CONSTRUCTOR = \"atomic\"\n+private const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\n+private const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\n+private const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\n+private const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\n+private const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\n+private const val GETTER = \"atomicfu\\$getter\"\n+private const val SETTER = \"atomicfu\\$setter\"\n+private const val GET = \"get\"\n+private const val SET = \"set\"\n+\n+private fun String.prettyStr() = replace('/', '.')\n+\n+class AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n+\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicRef\" to irBuiltIns.anyType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType\n+    )\n+\n+    private val AFU_ARRAY_CLASSES: Map<String, ClassDescriptor> = mapOf(\n+        \"AtomicIntArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.INT),\n+        \"AtomicLongArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.LONG),\n+        \"AtomicBooleanArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.BOOLEAN),\n+        \"AtomicArray\" to context.builtIns.array\n+    )\n+\n+    override fun visitFile(irFile: IrFile): IrFile {\n+        irFile.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitFile(irFile)\n+    }\n+\n+    override fun visitClass(irClass: IrClass): IrStatement {\n+        irClass.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitClass(irClass)\n+    }\n+\n+    override fun visitProperty(property: IrProperty): IrStatement {\n+        if (property.backingField != null) {\n+            val backingField = property.backingField!!\n+            if (backingField.initializer != null) {\n+                val initializer = backingField.initializer!!.expression.transformAtomicValueInitializer()\n+                property.backingField!!.initializer = IrExpressionBodyImpl(initializer)\n+            }\n+        }\n+        return super.visitProperty(property)\n+    }\n+\n+    override fun visitBlockBody(body: IrBlockBody): IrBody {\n+        body.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                body.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlockBody(body)\n+    }\n+\n+    override fun visitBlock(block: IrBlock): IrExpression {\n+        block.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                block.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlock(block)\n+    }\n+\n+    override fun visitReturn(returnExpr: IrReturn): IrExpression {\n+        returnExpr.value = returnExpr.value.transformAtomicFunctionCall()\n+        return super.visitReturn(returnExpr)\n+    }\n+\n+    override fun visitTypeOperator(typeOp: IrTypeOperatorCall): IrExpression {\n+        typeOp.argument = typeOp.argument.transformAtomicFunctionCall()\n+        return super.visitTypeOperator(typeOp)\n+    }\n+\n+    override fun visitSetVariable(setVar: IrSetVariable): IrExpression {\n+        setVar.value = setVar.value.transformAtomicFunctionCall()\n+        return super.visitSetVariable(setVar)\n+    }\n+\n+    override fun visitSetField(setField: IrSetField): IrExpression {\n+        setField.value = setField.value.transformAtomicFunctionCall()\n+        return super.visitSetField(setField)\n+    }\n+\n+    override fun visitVariable(declaration: IrVariable): IrStatement {\n+        declaration.initializer = declaration.initializer?.transformAtomicFunctionCall()\n+        return super.visitVariable(declaration)\n+    }\n+\n+    override fun visitBranch(branch: IrBranch): IrBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitBranch(branch)\n+    }\n+\n+    override fun visitElseBranch(branch: IrElseBranch): IrElseBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitElseBranch(branch)\n+    }\n+\n+    private fun IrExpression.transformAtomicValueInitializer() =\n+        when {\n+            type.isAtomicValueType() -> getPureTypeValue()\n+            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n+            type.isReentrantLockType() -> buildConstNull()\n+            else -> this\n+        }\n+\n+    private fun IrDeclaration.transformAtomicInlineDeclaration() {\n+        if (this is IrFunction &&\n+            isInline &&\n+            extensionReceiverParameter != null &&\n+            extensionReceiverParameter!!.type.isAtomicValueType()\n+        ) {\n+            val type = extensionReceiverParameter!!.type\n+            val valueType = type.atomicToValueType()\n+            val getterType = buildFunctionSimpleType(listOf(irBuiltIns.unitType, valueType))\n+            val setterType = buildFunctionSimpleType(listOf(valueType, irBuiltIns.unitType))\n+            val valueParametersCount = valueParameters.size\n+            val extendedValueParameters = mutableListOf<IrValueParameter>().apply {\n+                addAll(valueParameters)\n+                add(buildValueParameter(GETTER, valueParametersCount, getterType))\n+                add(buildValueParameter(SETTER, valueParametersCount + 1, setterType))\n+            }\n+            this as IrSimpleFunction\n+            (descriptor as FunctionDescriptorImpl).initialize(",
        "comment_created_at": "2020-06-01T17:11:41+00:00",
        "comment_author": "SokolovaMaria",
        "comment_body": "Could you please tell me, how can I avoid using DeclarationDescriptor API here? \r\n\r\nThe problem is that if I just change the parameters of the owner `IrFunction`  (`extensionReceiver` and `valueParameters`) then `ManglerChecker` fails at the comparison of the actual `Ir` signature and the one declared in the `Descriptor`.",
        "pr_file_module": null
      },
      {
        "comment_id": "433414477",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3415,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformerJsIr.kt",
        "discussion_id": "429178285",
        "commented_code": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.deepCopyWithVariables\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.builtins.PrimitiveType\n+import org.jetbrains.kotlin.descriptors.*\n+import org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildFunction\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildBlockBody\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.declarations.impl.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol\n+import org.jetbrains.kotlin.ir.symbols.IrSymbol\n+import org.jetbrains.kotlin.ir.symbols.impl.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\n+import java.lang.IllegalStateException\n+\n+private const val AFU_PKG = \"kotlinx/atomicfu\"\n+private const val LOCKS = \"locks\"\n+private const val ATOMIC_CONSTRUCTOR = \"atomic\"\n+private const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\n+private const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\n+private const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\n+private const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\n+private const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\n+private const val GETTER = \"atomicfu\\$getter\"\n+private const val SETTER = \"atomicfu\\$setter\"\n+private const val GET = \"get\"\n+private const val SET = \"set\"\n+\n+private fun String.prettyStr() = replace('/', '.')\n+\n+class AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n+\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicRef\" to irBuiltIns.anyType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType\n+    )\n+\n+    private val AFU_ARRAY_CLASSES: Map<String, ClassDescriptor> = mapOf(\n+        \"AtomicIntArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.INT),\n+        \"AtomicLongArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.LONG),\n+        \"AtomicBooleanArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.BOOLEAN),\n+        \"AtomicArray\" to context.builtIns.array\n+    )\n+\n+    override fun visitFile(irFile: IrFile): IrFile {\n+        irFile.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitFile(irFile)\n+    }\n+\n+    override fun visitClass(irClass: IrClass): IrStatement {\n+        irClass.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitClass(irClass)\n+    }\n+\n+    override fun visitProperty(property: IrProperty): IrStatement {\n+        if (property.backingField != null) {\n+            val backingField = property.backingField!!\n+            if (backingField.initializer != null) {\n+                val initializer = backingField.initializer!!.expression.transformAtomicValueInitializer()\n+                property.backingField!!.initializer = IrExpressionBodyImpl(initializer)\n+            }\n+        }\n+        return super.visitProperty(property)\n+    }\n+\n+    override fun visitBlockBody(body: IrBlockBody): IrBody {\n+        body.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                body.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlockBody(body)\n+    }\n+\n+    override fun visitBlock(block: IrBlock): IrExpression {\n+        block.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                block.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlock(block)\n+    }\n+\n+    override fun visitReturn(returnExpr: IrReturn): IrExpression {\n+        returnExpr.value = returnExpr.value.transformAtomicFunctionCall()\n+        return super.visitReturn(returnExpr)\n+    }\n+\n+    override fun visitTypeOperator(typeOp: IrTypeOperatorCall): IrExpression {\n+        typeOp.argument = typeOp.argument.transformAtomicFunctionCall()\n+        return super.visitTypeOperator(typeOp)\n+    }\n+\n+    override fun visitSetVariable(setVar: IrSetVariable): IrExpression {\n+        setVar.value = setVar.value.transformAtomicFunctionCall()\n+        return super.visitSetVariable(setVar)\n+    }\n+\n+    override fun visitSetField(setField: IrSetField): IrExpression {\n+        setField.value = setField.value.transformAtomicFunctionCall()\n+        return super.visitSetField(setField)\n+    }\n+\n+    override fun visitVariable(declaration: IrVariable): IrStatement {\n+        declaration.initializer = declaration.initializer?.transformAtomicFunctionCall()\n+        return super.visitVariable(declaration)\n+    }\n+\n+    override fun visitBranch(branch: IrBranch): IrBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitBranch(branch)\n+    }\n+\n+    override fun visitElseBranch(branch: IrElseBranch): IrElseBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitElseBranch(branch)\n+    }\n+\n+    private fun IrExpression.transformAtomicValueInitializer() =\n+        when {\n+            type.isAtomicValueType() -> getPureTypeValue()\n+            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n+            type.isReentrantLockType() -> buildConstNull()\n+            else -> this\n+        }\n+\n+    private fun IrDeclaration.transformAtomicInlineDeclaration() {\n+        if (this is IrFunction &&\n+            isInline &&\n+            extensionReceiverParameter != null &&\n+            extensionReceiverParameter!!.type.isAtomicValueType()\n+        ) {\n+            val type = extensionReceiverParameter!!.type\n+            val valueType = type.atomicToValueType()\n+            val getterType = buildFunctionSimpleType(listOf(irBuiltIns.unitType, valueType))\n+            val setterType = buildFunctionSimpleType(listOf(valueType, irBuiltIns.unitType))\n+            val valueParametersCount = valueParameters.size\n+            val extendedValueParameters = mutableListOf<IrValueParameter>().apply {\n+                addAll(valueParameters)\n+                add(buildValueParameter(GETTER, valueParametersCount, getterType))\n+                add(buildValueParameter(SETTER, valueParametersCount + 1, setterType))\n+            }\n+            this as IrSimpleFunction\n+            (descriptor as FunctionDescriptorImpl).initialize(",
        "comment_created_at": "2020-06-01T18:33:53+00:00",
        "comment_author": "romanart",
        "comment_body": "What kind of failure do you see? I bet it could be easily fixed if you use wrapped descriptor",
        "pr_file_module": null
      },
      {
        "comment_id": "435628343",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3415,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformerJsIr.kt",
        "discussion_id": "429178285",
        "commented_code": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.deepCopyWithVariables\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.builtins.PrimitiveType\n+import org.jetbrains.kotlin.descriptors.*\n+import org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildFunction\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildBlockBody\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.declarations.impl.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol\n+import org.jetbrains.kotlin.ir.symbols.IrSymbol\n+import org.jetbrains.kotlin.ir.symbols.impl.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\n+import java.lang.IllegalStateException\n+\n+private const val AFU_PKG = \"kotlinx/atomicfu\"\n+private const val LOCKS = \"locks\"\n+private const val ATOMIC_CONSTRUCTOR = \"atomic\"\n+private const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\n+private const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\n+private const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\n+private const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\n+private const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\n+private const val GETTER = \"atomicfu\\$getter\"\n+private const val SETTER = \"atomicfu\\$setter\"\n+private const val GET = \"get\"\n+private const val SET = \"set\"\n+\n+private fun String.prettyStr() = replace('/', '.')\n+\n+class AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n+\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicRef\" to irBuiltIns.anyType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType\n+    )\n+\n+    private val AFU_ARRAY_CLASSES: Map<String, ClassDescriptor> = mapOf(\n+        \"AtomicIntArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.INT),\n+        \"AtomicLongArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.LONG),\n+        \"AtomicBooleanArray\" to context.builtIns.getPrimitiveArrayClassDescriptor(PrimitiveType.BOOLEAN),\n+        \"AtomicArray\" to context.builtIns.array\n+    )\n+\n+    override fun visitFile(irFile: IrFile): IrFile {\n+        irFile.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitFile(irFile)\n+    }\n+\n+    override fun visitClass(irClass: IrClass): IrStatement {\n+        irClass.declarations.map { declaration ->\n+            declaration.transformAtomicInlineDeclaration()\n+        }\n+        return super.visitClass(irClass)\n+    }\n+\n+    override fun visitProperty(property: IrProperty): IrStatement {\n+        if (property.backingField != null) {\n+            val backingField = property.backingField!!\n+            if (backingField.initializer != null) {\n+                val initializer = backingField.initializer!!.expression.transformAtomicValueInitializer()\n+                property.backingField!!.initializer = IrExpressionBodyImpl(initializer)\n+            }\n+        }\n+        return super.visitProperty(property)\n+    }\n+\n+    override fun visitBlockBody(body: IrBlockBody): IrBody {\n+        body.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                body.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlockBody(body)\n+    }\n+\n+    override fun visitBlock(block: IrBlock): IrExpression {\n+        block.statements.forEachIndexed { i, stmt ->\n+            if (stmt is IrCall) {\n+                block.statements[i] = stmt.transformAtomicFunctionCall()\n+            }\n+        }\n+        return super.visitBlock(block)\n+    }\n+\n+    override fun visitReturn(returnExpr: IrReturn): IrExpression {\n+        returnExpr.value = returnExpr.value.transformAtomicFunctionCall()\n+        return super.visitReturn(returnExpr)\n+    }\n+\n+    override fun visitTypeOperator(typeOp: IrTypeOperatorCall): IrExpression {\n+        typeOp.argument = typeOp.argument.transformAtomicFunctionCall()\n+        return super.visitTypeOperator(typeOp)\n+    }\n+\n+    override fun visitSetVariable(setVar: IrSetVariable): IrExpression {\n+        setVar.value = setVar.value.transformAtomicFunctionCall()\n+        return super.visitSetVariable(setVar)\n+    }\n+\n+    override fun visitSetField(setField: IrSetField): IrExpression {\n+        setField.value = setField.value.transformAtomicFunctionCall()\n+        return super.visitSetField(setField)\n+    }\n+\n+    override fun visitVariable(declaration: IrVariable): IrStatement {\n+        declaration.initializer = declaration.initializer?.transformAtomicFunctionCall()\n+        return super.visitVariable(declaration)\n+    }\n+\n+    override fun visitBranch(branch: IrBranch): IrBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitBranch(branch)\n+    }\n+\n+    override fun visitElseBranch(branch: IrElseBranch): IrElseBranch {\n+        branch.apply {\n+            condition = condition.transformAtomicFunctionCall()\n+            result = result.transformAtomicFunctionCall()\n+        }\n+        return super.visitElseBranch(branch)\n+    }\n+\n+    private fun IrExpression.transformAtomicValueInitializer() =\n+        when {\n+            type.isAtomicValueType() -> getPureTypeValue()\n+            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n+            type.isReentrantLockType() -> buildConstNull()\n+            else -> this\n+        }\n+\n+    private fun IrDeclaration.transformAtomicInlineDeclaration() {\n+        if (this is IrFunction &&\n+            isInline &&\n+            extensionReceiverParameter != null &&\n+            extensionReceiverParameter!!.type.isAtomicValueType()\n+        ) {\n+            val type = extensionReceiverParameter!!.type\n+            val valueType = type.atomicToValueType()\n+            val getterType = buildFunctionSimpleType(listOf(irBuiltIns.unitType, valueType))\n+            val setterType = buildFunctionSimpleType(listOf(valueType, irBuiltIns.unitType))\n+            val valueParametersCount = valueParameters.size\n+            val extendedValueParameters = mutableListOf<IrValueParameter>().apply {\n+                addAll(valueParameters)\n+                add(buildValueParameter(GETTER, valueParametersCount, getterType))\n+                add(buildValueParameter(SETTER, valueParametersCount + 1, setterType))\n+            }\n+            this as IrSimpleFunction\n+            (descriptor as FunctionDescriptorImpl).initialize(",
        "comment_created_at": "2020-06-05T00:30:16+00:00",
        "comment_author": "SokolovaMaria",
        "comment_body": "I fixed this by creating new transformed declarations with `WrappedSimpleFunctionDescriptor` (as I can not just set a new descriptor).",
        "pr_file_module": null
      }
    ]
  }
]