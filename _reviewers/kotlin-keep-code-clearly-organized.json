[
  {
    "discussion_id": "1809231585",
    "pr_number": 5364,
    "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
    "created_at": "2024-10-21T17:37:16+00:00",
    "commented_code": "public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n    screenFloatValue(this) { it.toBigDecimal(mathContext) }\n\n/**\n * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n */\nprivate object ScreenFloatValueRegEx {\n    @JvmField val value = run {\n        val Digits = \"(\\\\p{Digit}+)\"\n        val HexDigits = \"(\\\\p{XDigit}+)\"\n        val Exp = \"[eE][+-]?$Digits\"\n\n        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n\n        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n\n        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n\n        Regex(fpRegex)\n    }\n}\n\nprivate inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n    return try {\n        if (ScreenFloatValueRegEx.value.matches(str))\n        if (isValidFloat(str))\n            parse(str)\n        else\n            null\n    } catch (e: NumberFormatException) {  // overflow\n    } catch (_: NumberFormatException) {  // overflow\n        null\n    }\n}\n\nprivate const val LengthOfNaN = 2 // \"NaN\".length - 1\nprivate const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n\nprivate fun isValidFloat(s: String): Boolean {\n    // A float can have one of two representations:\n    //\n    // 1. Standard:\n    //     - With an integer part only: 1234\n    //     - With integer and fractional parts: 1234.4678\n    //     - With a fractional part only: .4678\n    //\n    //     Optional sign prefix: + or -\n    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // 2. Hexadecimal:\n    //     - With an integer part only: 0x12ab\n    //     - With integer and fractional parts: 0x12ab.CD78\n    //     - With a fractional part only: 0x.CD78\n    //\n    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n    //\n    //     Optional sign prefix: + or -\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // Two special cases:\n    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n    //\n    // Implementation notes:\n    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n    //       a lower case one.\n\n    var start = 0\n    var end = s.length - 1\n\n    // Skip leading spaces\n    while (start <= end && s[start].code <= 0x20) start++\n\n    // Empty/whitespace string\n    if (start > end) return false\n\n    // Skip trailing spaces\n    while (end > start && s[end].code <= 0x20) end--\n\n    // Number starts with a positive or negative sign\n    if (s[start] == '+' || s[start] == '-') start++\n    // If we have nothing after the sign, the string is invalid\n    if (start > end) return false\n\n    var hasIntegerPart: Boolean\n    var hasFractionalPart = false\n    var isHex = false\n\n    // Might be a hex string\n    if (s[start] == '0') {\n        start++\n        // A \"0\" on its own is valid\n        if (start > end) return true\n\n        // Test for [xX] to see if we truly have a hex string\n        if (s[start].code or 0x20 == 'x'.code) {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1809231585",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5364,
        "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
        "discussion_id": "1809231585",
        "commented_code": "@@ -239,35 +239,215 @@ public fun String.toBigDecimalOrNull(): java.math.BigDecimal? =\n public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n     screenFloatValue(this) { it.toBigDecimal(mathContext) }\n \n-/**\n- * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n- */\n-private object ScreenFloatValueRegEx {\n-    @JvmField val value = run {\n-        val Digits = \"(\\\\p{Digit}+)\"\n-        val HexDigits = \"(\\\\p{XDigit}+)\"\n-        val Exp = \"[eE][+-]?$Digits\"\n-\n-        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n-                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n-\n-        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n-                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n-                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n-\n-        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n-\n-        Regex(fpRegex)\n-    }\n-}\n-\n private inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n     return try {\n-        if (ScreenFloatValueRegEx.value.matches(str))\n+        if (isValidFloat(str))\n             parse(str)\n         else\n             null\n-    } catch (e: NumberFormatException) {  // overflow\n+    } catch (_: NumberFormatException) {  // overflow\n         null\n     }\n }\n+\n+private const val LengthOfNaN = 2 // \"NaN\".length - 1\n+private const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n+\n+private fun isValidFloat(s: String): Boolean {\n+    // A float can have one of two representations:\n+    //\n+    // 1. Standard:\n+    //     - With an integer part only: 1234\n+    //     - With integer and fractional parts: 1234.4678\n+    //     - With a fractional part only: .4678\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // 2. Hexadecimal:\n+    //     - With an integer part only: 0x12ab\n+    //     - With integer and fractional parts: 0x12ab.CD78\n+    //     - With a fractional part only: 0x.CD78\n+    //\n+    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // Two special cases:\n+    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n+    //\n+    // Implementation notes:\n+    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n+    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n+    //       a lower case one.\n+\n+    var start = 0\n+    var end = s.length - 1\n+\n+    // Skip leading spaces\n+    while (start <= end && s[start].code <= 0x20) start++\n+\n+    // Empty/whitespace string\n+    if (start > end) return false\n+\n+    // Skip trailing spaces\n+    while (end > start && s[end].code <= 0x20) end--\n+\n+    // Number starts with a positive or negative sign\n+    if (s[start] == '+' || s[start] == '-') start++\n+    // If we have nothing after the sign, the string is invalid\n+    if (start > end) return false\n+\n+    var hasIntegerPart: Boolean\n+    var hasFractionalPart = false\n+    var isHex = false\n+\n+    // Might be a hex string\n+    if (s[start] == '0') {\n+        start++\n+        // A \"0\" on its own is valid\n+        if (start > end) return true\n+\n+        // Test for [xX] to see if we truly have a hex string\n+        if (s[start].code or 0x20 == 'x'.code) {",
        "comment_created_at": "2024-10-21T17:37:16+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "`Char.code or 0x20` deserved its own private function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1809238149",
    "pr_number": 5364,
    "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
    "created_at": "2024-10-21T17:42:44+00:00",
    "commented_code": "public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n    screenFloatValue(this) { it.toBigDecimal(mathContext) }\n\n/**\n * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n */\nprivate object ScreenFloatValueRegEx {\n    @JvmField val value = run {\n        val Digits = \"(\\\\p{Digit}+)\"\n        val HexDigits = \"(\\\\p{XDigit}+)\"\n        val Exp = \"[eE][+-]?$Digits\"\n\n        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n\n        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n\n        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n\n        Regex(fpRegex)\n    }\n}\n\nprivate inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n    return try {\n        if (ScreenFloatValueRegEx.value.matches(str))\n        if (isValidFloat(str))\n            parse(str)\n        else\n            null\n    } catch (e: NumberFormatException) {  // overflow\n    } catch (_: NumberFormatException) {  // overflow\n        null\n    }\n}\n\nprivate const val LengthOfNaN = 2 // \"NaN\".length - 1\nprivate const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n\nprivate fun isValidFloat(s: String): Boolean {\n    // A float can have one of two representations:\n    //\n    // 1. Standard:\n    //     - With an integer part only: 1234\n    //     - With integer and fractional parts: 1234.4678\n    //     - With a fractional part only: .4678\n    //\n    //     Optional sign prefix: + or -\n    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // 2. Hexadecimal:\n    //     - With an integer part only: 0x12ab\n    //     - With integer and fractional parts: 0x12ab.CD78\n    //     - With a fractional part only: 0x.CD78\n    //\n    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n    //\n    //     Optional sign prefix: + or -\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // Two special cases:\n    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n    //\n    // Implementation notes:\n    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n    //       a lower case one.\n\n    var start = 0\n    var end = s.length - 1\n\n    // Skip leading spaces\n    while (start <= end && s[start].code <= 0x20) start++",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1809238149",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5364,
        "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
        "discussion_id": "1809238149",
        "commented_code": "@@ -239,35 +239,215 @@ public fun String.toBigDecimalOrNull(): java.math.BigDecimal? =\n public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n     screenFloatValue(this) { it.toBigDecimal(mathContext) }\n \n-/**\n- * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n- */\n-private object ScreenFloatValueRegEx {\n-    @JvmField val value = run {\n-        val Digits = \"(\\\\p{Digit}+)\"\n-        val HexDigits = \"(\\\\p{XDigit}+)\"\n-        val Exp = \"[eE][+-]?$Digits\"\n-\n-        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n-                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n-\n-        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n-                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n-                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n-\n-        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n-\n-        Regex(fpRegex)\n-    }\n-}\n-\n private inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n     return try {\n-        if (ScreenFloatValueRegEx.value.matches(str))\n+        if (isValidFloat(str))\n             parse(str)\n         else\n             null\n-    } catch (e: NumberFormatException) {  // overflow\n+    } catch (_: NumberFormatException) {  // overflow\n         null\n     }\n }\n+\n+private const val LengthOfNaN = 2 // \"NaN\".length - 1\n+private const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n+\n+private fun isValidFloat(s: String): Boolean {\n+    // A float can have one of two representations:\n+    //\n+    // 1. Standard:\n+    //     - With an integer part only: 1234\n+    //     - With integer and fractional parts: 1234.4678\n+    //     - With a fractional part only: .4678\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // 2. Hexadecimal:\n+    //     - With an integer part only: 0x12ab\n+    //     - With integer and fractional parts: 0x12ab.CD78\n+    //     - With a fractional part only: 0x.CD78\n+    //\n+    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // Two special cases:\n+    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n+    //\n+    // Implementation notes:\n+    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n+    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n+    //       a lower case one.\n+\n+    var start = 0\n+    var end = s.length - 1\n+\n+    // Skip leading spaces\n+    while (start <= end && s[start].code <= 0x20) start++",
        "comment_created_at": "2024-10-21T17:42:44+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "Introduction of something like `inline fun String.advanceWhile(index: Int, endInclusive: Int, predicate: (Char) -> Boolean): Int` will shorten the whole function and will improve its readability:\r\n\r\n- `start = s.advanceWhile(start, end) { it.code <= 20 }`\r\n- `start = s.advanceWhile(start, end) { it.isAsciiDigit() || it.isHexLetter() }`\r\n- `start = s.advanceWhile(start, end) { it.isAsciiDigit() }`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1809255640",
    "pr_number": 5364,
    "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
    "created_at": "2024-10-21T17:57:37+00:00",
    "commented_code": "public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n    screenFloatValue(this) { it.toBigDecimal(mathContext) }\n\n/**\n * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n */\nprivate object ScreenFloatValueRegEx {\n    @JvmField val value = run {\n        val Digits = \"(\\\\p{Digit}+)\"\n        val HexDigits = \"(\\\\p{XDigit}+)\"\n        val Exp = \"[eE][+-]?$Digits\"\n\n        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n\n        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n\n        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n\n        Regex(fpRegex)\n    }\n}\n\nprivate inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n    return try {\n        if (ScreenFloatValueRegEx.value.matches(str))\n        if (isValidFloat(str))\n            parse(str)\n        else\n            null\n    } catch (e: NumberFormatException) {  // overflow\n    } catch (_: NumberFormatException) {  // overflow\n        null\n    }\n}\n\nprivate const val LengthOfNaN = 2 // \"NaN\".length - 1\nprivate const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n\nprivate fun isValidFloat(s: String): Boolean {\n    // A float can have one of two representations:\n    //\n    // 1. Standard:\n    //     - With an integer part only: 1234\n    //     - With integer and fractional parts: 1234.4678\n    //     - With a fractional part only: .4678\n    //\n    //     Optional sign prefix: + or -\n    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // 2. Hexadecimal:\n    //     - With an integer part only: 0x12ab\n    //     - With integer and fractional parts: 0x12ab.CD78\n    //     - With a fractional part only: 0x.CD78\n    //\n    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n    //\n    //     Optional sign prefix: + or -\n    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n    //\n    // Two special cases:\n    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n    //\n    // Implementation notes:\n    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n    //       a lower case one.\n\n    var start = 0\n    var end = s.length - 1\n\n    // Skip leading spaces\n    while (start <= end && s[start].code <= 0x20) start++\n\n    // Empty/whitespace string\n    if (start > end) return false\n\n    // Skip trailing spaces\n    while (end > start && s[end].code <= 0x20) end--\n\n    // Number starts with a positive or negative sign\n    if (s[start] == '+' || s[start] == '-') start++\n    // If we have nothing after the sign, the string is invalid\n    if (start > end) return false\n\n    var hasIntegerPart: Boolean\n    var hasFractionalPart = false\n    var isHex = false\n\n    // Might be a hex string\n    if (s[start] == '0') {\n        start++\n        // A \"0\" on its own is valid\n        if (start > end) return true\n\n        // Test for [xX] to see if we truly have a hex string\n        if (s[start].code or 0x20 == 'x'.code) {\n            start++\n\n            // Look for hex digits after the 0x prefix\n            var checkpoint = start\n            while (start <= end) {\n                val d = s[start]\n                if (d.isAsciiDigit() || d.isHexLetter()) {\n                    start++\n                } else {\n                    break\n                }\n            }\n            // Check if we found 0x*****, otherwise, the hex number might be of the\n            // form 0x.*******\n            hasIntegerPart = checkpoint != start\n\n            // A hex string must have an exponent, the string is invalid if we only found an\n            // integer part\n            if (start > end) return false\n\n            if (s[start] == '.') {\n                start++\n\n                // Look for hex digits for the fractional part\n                checkpoint = start\n                while (start <= end) {\n                    val d = s[start]\n                    if (d.isAsciiDigit() || d.isHexLetter()) {\n                        start++\n                    } else {\n                        break\n                    }\n                }\n\n                // Did we find a fractional part?\n                hasFractionalPart = checkpoint != start\n            }\n\n            // A string must have an integer part, or a fractional part, or both\n            if (!hasIntegerPart && !hasFractionalPart) return false\n\n            // A hex string must have an exponent, the string is invalid if we only found an\n            // integer and/or fractional part\n            if (start > end) return false\n\n            isHex = true\n        } else {\n            // Rewind the 0 we just parsed to make things easier below and try to parse a non-\n            // hexadecimal string representation of a float\n            start--\n        }\n    }\n\n    // Parse a non-hexadecimal representations\n    if (!isHex) {\n        // Look for digits before the decimal separator, if any\n        var checkpoint = start\n        while (start <= end && s[start].isAsciiDigit()) start++\n\n        // If there's no integer part, the float might be of the form .1234\n        hasIntegerPart = checkpoint != start\n\n        // A non-hexadecimal representation only needs an integer part, we can stop here\n        if (start > end) return hasIntegerPart\n\n        if (s[start] == '.') {\n            start++\n\n            // Look for the fractional part\n            checkpoint = start\n            while (start <= end && s[start].isAsciiDigit()) start++\n\n            // Did we find a fractional part?\n            hasFractionalPart = checkpoint != start\n        }\n\n        // A string must have an integer part, or a fractional part, or both\n        if (!hasIntegerPart && !hasFractionalPart) {\n            // Special case non-finite constants\n            val constant = when (end) {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1809255640",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5364,
        "pr_file": "libraries/stdlib/jvm/src/kotlin/text/StringNumberConversionsJVM.kt",
        "discussion_id": "1809255640",
        "commented_code": "@@ -239,35 +239,215 @@ public fun String.toBigDecimalOrNull(): java.math.BigDecimal? =\n public fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal? =\n     screenFloatValue(this) { it.toBigDecimal(mathContext) }\n \n-/**\n- * Recommended floating point number validation RegEx from the javadoc of `java.lang.Double.valueOf(String)`\n- */\n-private object ScreenFloatValueRegEx {\n-    @JvmField val value = run {\n-        val Digits = \"(\\\\p{Digit}+)\"\n-        val HexDigits = \"(\\\\p{XDigit}+)\"\n-        val Exp = \"[eE][+-]?$Digits\"\n-\n-        val HexString = \"(0[xX]$HexDigits(\\\\.)?)|\" + // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n-                \"(0[xX]$HexDigits?(\\\\.)$HexDigits)\"  // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n-\n-        val Number = \"($Digits(\\\\.)?($Digits?)($Exp)?)|\" +  // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n-                \"(\\\\.($Digits)($Exp)?)|\" +                  // . Digits ExponentPart_opt FloatTypeSuffix_opt\n-                \"(($HexString)[pP][+-]?$Digits)\"            // HexSignificand BinaryExponent\n-\n-        val fpRegex = \"[\\\\x00-\\\\x20]*[+-]?(NaN|Infinity|(($Number)[fFdD]?))[\\\\x00-\\\\x20]*\"\n-\n-        Regex(fpRegex)\n-    }\n-}\n-\n private inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T? {\n     return try {\n-        if (ScreenFloatValueRegEx.value.matches(str))\n+        if (isValidFloat(str))\n             parse(str)\n         else\n             null\n-    } catch (e: NumberFormatException) {  // overflow\n+    } catch (_: NumberFormatException) {  // overflow\n         null\n     }\n }\n+\n+private const val LengthOfNaN = 2 // \"NaN\".length - 1\n+private const val LengthOfInfinity = 7 // \"Infinity\".length - 1\n+\n+private fun isValidFloat(s: String): Boolean {\n+    // A float can have one of two representations:\n+    //\n+    // 1. Standard:\n+    //     - With an integer part only: 1234\n+    //     - With integer and fractional parts: 1234.4678\n+    //     - With a fractional part only: .4678\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional signed exponent: e or E, followed by optionally signed digits (+12, -12, 12)\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // 2. Hexadecimal:\n+    //     - With an integer part only: 0x12ab\n+    //     - With integer and fractional parts: 0x12ab.CD78\n+    //     - With a fractional part only: 0x.CD78\n+    //\n+    //     Mandatory signed exponent: p or P, followed by optionally signed digits (+12, -12, 12)\n+    //\n+    //     Optional sign prefix: + or -\n+    //     Optional suffix: f, F, d, or D (for instance 12.34f or .34D)\n+    //\n+    // Two special cases:\n+    //     \"NaN\" and \"Infinity\" strings, can have an optional sign prefix (+ or -)\n+    //\n+    // Implementation notes:\n+    //     - The pattern \"myChar.code or 0x20 == 'x'.code\" is used to perform a case-insensitive\n+    //       comparison of a character. Adding the 0x20 bit turns an upper case ASCII letter into\n+    //       a lower case one.\n+\n+    var start = 0\n+    var end = s.length - 1\n+\n+    // Skip leading spaces\n+    while (start <= end && s[start].code <= 0x20) start++\n+\n+    // Empty/whitespace string\n+    if (start > end) return false\n+\n+    // Skip trailing spaces\n+    while (end > start && s[end].code <= 0x20) end--\n+\n+    // Number starts with a positive or negative sign\n+    if (s[start] == '+' || s[start] == '-') start++\n+    // If we have nothing after the sign, the string is invalid\n+    if (start > end) return false\n+\n+    var hasIntegerPart: Boolean\n+    var hasFractionalPart = false\n+    var isHex = false\n+\n+    // Might be a hex string\n+    if (s[start] == '0') {\n+        start++\n+        // A \"0\" on its own is valid\n+        if (start > end) return true\n+\n+        // Test for [xX] to see if we truly have a hex string\n+        if (s[start].code or 0x20 == 'x'.code) {\n+            start++\n+\n+            // Look for hex digits after the 0x prefix\n+            var checkpoint = start\n+            while (start <= end) {\n+                val d = s[start]\n+                if (d.isAsciiDigit() || d.isHexLetter()) {\n+                    start++\n+                } else {\n+                    break\n+                }\n+            }\n+            // Check if we found 0x*****, otherwise, the hex number might be of the\n+            // form 0x.*******\n+            hasIntegerPart = checkpoint != start\n+\n+            // A hex string must have an exponent, the string is invalid if we only found an\n+            // integer part\n+            if (start > end) return false\n+\n+            if (s[start] == '.') {\n+                start++\n+\n+                // Look for hex digits for the fractional part\n+                checkpoint = start\n+                while (start <= end) {\n+                    val d = s[start]\n+                    if (d.isAsciiDigit() || d.isHexLetter()) {\n+                        start++\n+                    } else {\n+                        break\n+                    }\n+                }\n+\n+                // Did we find a fractional part?\n+                hasFractionalPart = checkpoint != start\n+            }\n+\n+            // A string must have an integer part, or a fractional part, or both\n+            if (!hasIntegerPart && !hasFractionalPart) return false\n+\n+            // A hex string must have an exponent, the string is invalid if we only found an\n+            // integer and/or fractional part\n+            if (start > end) return false\n+\n+            isHex = true\n+        } else {\n+            // Rewind the 0 we just parsed to make things easier below and try to parse a non-\n+            // hexadecimal string representation of a float\n+            start--\n+        }\n+    }\n+\n+    // Parse a non-hexadecimal representations\n+    if (!isHex) {\n+        // Look for digits before the decimal separator, if any\n+        var checkpoint = start\n+        while (start <= end && s[start].isAsciiDigit()) start++\n+\n+        // If there's no integer part, the float might be of the form .1234\n+        hasIntegerPart = checkpoint != start\n+\n+        // A non-hexadecimal representation only needs an integer part, we can stop here\n+        if (start > end) return hasIntegerPart\n+\n+        if (s[start] == '.') {\n+            start++\n+\n+            // Look for the fractional part\n+            checkpoint = start\n+            while (start <= end && s[start].isAsciiDigit()) start++\n+\n+            // Did we find a fractional part?\n+            hasFractionalPart = checkpoint != start\n+        }\n+\n+        // A string must have an integer part, or a fractional part, or both\n+        if (!hasIntegerPart && !hasFractionalPart) {\n+            // Special case non-finite constants\n+            val constant = when (end) {",
        "comment_created_at": "2024-10-21T17:57:37+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "For the sake of readability, I suggest outlining special-case handling to a separate function as well.\r\n`LengthOfXXX` could then be defined inside the function (They are not lengths, so it would be better to make their scope as narrow as possible).\r\n\r\n> For the sake of readability\r\n\r\nDon't get me wrong: the function is well written, there's just too much context to keep in mind while reading the code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1081109610",
    "pr_number": 5050,
    "pr_file": "compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/inline/FunctionInlining.kt",
    "created_at": "2023-01-19T11:02:06+00:00",
    "commented_code": "return@forEach\n                }\n\n                if (argument.isImmutableVariableLoad) {\n                    substituteMap[argument.parameter] =\n                        argument.argumentExpression.transform( // Arguments may reference the previous ones - substitute them.\n                            substitutor,\n                            data = null\n                        )\n                // Arguments may reference the previous ones - substitute them.\n                val variableInitializer = argument.argumentExpression.transform(substitutor, data = null)\n                val parameter = argument.parameter\n\n                fun substituteParameterViaTemporaryVariable() {\n                    val newVariable = createTemporaryVariable(parameter, variableInitializer, callee)\n                    evaluationStatements.add(newVariable)\n                    substituteMap[parameter] = IrGetValueWithoutLocation(newVariable.symbol)\n                }\n\n                if (alwaysCreateTemporaryVariablesForArguments && !parameter.isInlineParameter()) {\n                    substituteParameterViaTemporaryVariable()\n                    return@forEach\n                }\n\n                // Arguments may reference the previous ones - substitute them.\n                val variableInitializer = argument.argumentExpression.transform(substitutor, data = null)\n                if (argument.isImmutableVariableLoad) {\n                    substituteMap[parameter] = variableInitializer\n                    return@forEach\n                }\n\n                val argumentExtracted = !argument.argumentExpression.isPure(false, context = context)",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1081109610",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5050,
        "pr_file": "compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/inline/FunctionInlining.kt",
        "discussion_id": "1081109610",
        "commented_code": "@@ -602,43 +603,61 @@ class FunctionInlining(\n                     return@forEach\n                 }\n \n-                if (argument.isImmutableVariableLoad) {\n-                    substituteMap[argument.parameter] =\n-                        argument.argumentExpression.transform( // Arguments may reference the previous ones - substitute them.\n-                            substitutor,\n-                            data = null\n-                        )\n+                // Arguments may reference the previous ones - substitute them.\n+                val variableInitializer = argument.argumentExpression.transform(substitutor, data = null)\n+                val parameter = argument.parameter\n+\n+                fun substituteParameterViaTemporaryVariable() {\n+                    val newVariable = createTemporaryVariable(parameter, variableInitializer, callee)\n+                    evaluationStatements.add(newVariable)\n+                    substituteMap[parameter] = IrGetValueWithoutLocation(newVariable.symbol)\n+                }\n+\n+                if (alwaysCreateTemporaryVariablesForArguments && !parameter.isInlineParameter()) {\n+                    substituteParameterViaTemporaryVariable()\n                     return@forEach\n                 }\n \n-                // Arguments may reference the previous ones - substitute them.\n-                val variableInitializer = argument.argumentExpression.transform(substitutor, data = null)\n+                if (argument.isImmutableVariableLoad) {\n+                    substituteMap[parameter] = variableInitializer\n+                    return@forEach\n+                }\n \n                 val argumentExtracted = !argument.argumentExpression.isPure(false, context = context)",
        "comment_created_at": "2023-01-19T11:02:06+00:00",
        "comment_author": "kunyavskiy",
        "comment_body": "For now, in fact we have to cases \n1. Directly substitute\n2. Create temporary variable. \n\nFor now logic on when which is happening is distributed all over the function code. It would be nice to collect it in one place. Like add a variable \"shouldInlineArgumentValue\", and just check over it and the end, without returns in the middle of function. \n\nMaybe it can be event extracted to a separate function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "964684049",
    "pr_number": 4933,
    "pr_file": "plugins/value-container-assignment/value-container-assignment.k2/src/org/jetbrains/kotlin/container/assignment/k2/FirValueContainerAssignmentAltererExtension.kt",
    "created_at": "2022-09-07T10:46:41+00:00",
    "commented_code": "/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.jetbrains.kotlin.container.assignment.k2\n\nimport org.jetbrains.kotlin.KtFakeSourceElementKind\nimport org.jetbrains.kotlin.fakeElement\nimport org.jetbrains.kotlin.fir.FirSession\nimport org.jetbrains.kotlin.fir.expressions.*\nimport org.jetbrains.kotlin.fir.expressions.builder.buildFunctionCall\nimport org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression\nimport org.jetbrains.kotlin.fir.extensions.FirAssignExpressionAltererExtension\nimport org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference\nimport org.jetbrains.kotlin.fir.resolvedSymbol\nimport org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\nimport org.jetbrains.kotlin.fir.types.toRegularClassSymbol\nimport org.jetbrains.kotlin.name.Name\n\nclass FirValueContainerAssignmentAltererExtension(\n    session: FirSession\n) : FirAssignExpressionAltererExtension(session) {\n\n    companion object {\n        val ASSIGN_METHOD = Name.identifier(\"assign\")",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "964684049",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4933,
        "pr_file": "plugins/value-container-assignment/value-container-assignment.k2/src/org/jetbrains/kotlin/container/assignment/k2/FirValueContainerAssignmentAltererExtension.kt",
        "discussion_id": "964684049",
        "commented_code": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.container.assignment.k2\n+\n+import org.jetbrains.kotlin.KtFakeSourceElementKind\n+import org.jetbrains.kotlin.fakeElement\n+import org.jetbrains.kotlin.fir.FirSession\n+import org.jetbrains.kotlin.fir.expressions.*\n+import org.jetbrains.kotlin.fir.expressions.builder.buildFunctionCall\n+import org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression\n+import org.jetbrains.kotlin.fir.extensions.FirAssignExpressionAltererExtension\n+import org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference\n+import org.jetbrains.kotlin.fir.resolvedSymbol\n+import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\n+import org.jetbrains.kotlin.fir.types.toRegularClassSymbol\n+import org.jetbrains.kotlin.name.Name\n+\n+class FirValueContainerAssignmentAltererExtension(\n+    session: FirSession\n+) : FirAssignExpressionAltererExtension(session) {\n+\n+    companion object {\n+        val ASSIGN_METHOD = Name.identifier(\"assign\")",
        "comment_created_at": "2022-09-07T10:46:41+00:00",
        "comment_author": "demiurg906",
        "comment_body": "It's worth to exctract this constant into `.common` module",
        "pr_file_module": null
      },
      {
        "comment_id": "966271057",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4933,
        "pr_file": "plugins/value-container-assignment/value-container-assignment.k2/src/org/jetbrains/kotlin/container/assignment/k2/FirValueContainerAssignmentAltererExtension.kt",
        "discussion_id": "964684049",
        "commented_code": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlin.container.assignment.k2\n+\n+import org.jetbrains.kotlin.KtFakeSourceElementKind\n+import org.jetbrains.kotlin.fakeElement\n+import org.jetbrains.kotlin.fir.FirSession\n+import org.jetbrains.kotlin.fir.expressions.*\n+import org.jetbrains.kotlin.fir.expressions.builder.buildFunctionCall\n+import org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression\n+import org.jetbrains.kotlin.fir.extensions.FirAssignExpressionAltererExtension\n+import org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference\n+import org.jetbrains.kotlin.fir.resolvedSymbol\n+import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol\n+import org.jetbrains.kotlin.fir.types.toRegularClassSymbol\n+import org.jetbrains.kotlin.name.Name\n+\n+class FirValueContainerAssignmentAltererExtension(\n+    session: FirSession\n+) : FirAssignExpressionAltererExtension(session) {\n+\n+    companion object {\n+        val ASSIGN_METHOD = Name.identifier(\"assign\")",
        "comment_created_at": "2022-09-08T18:06:03+00:00",
        "comment_author": "asodja",
        "comment_body": "Extracted to .common",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "893088032",
    "pr_number": 4835,
    "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org/jetbrains/kotlinx/atomicfu/compiler/backend/jvm/AtomicfuJvmIrTransformer.kt",
    "created_at": "2022-06-09T05:37:45+00:00",
    "commented_code": "/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.jetbrains.kotlinx.atomicfu.compiler.backend.jvm\n\nimport org.jetbrains.kotlin.backend.common.extensions.*\nimport org.jetbrains.kotlin.backend.jvm.ir.*\nimport org.jetbrains.kotlin.ir.*\nimport org.jetbrains.kotlin.ir.builders.declarations.*\nimport org.jetbrains.kotlin.ir.builders.*\nimport org.jetbrains.kotlin.ir.declarations.*\nimport org.jetbrains.kotlin.ir.declarations.impl.*\nimport org.jetbrains.kotlin.ir.expressions.*\nimport org.jetbrains.kotlin.ir.expressions.impl.*\nimport org.jetbrains.kotlin.ir.symbols.*\nimport org.jetbrains.kotlin.ir.types.*\nimport org.jetbrains.kotlin.ir.util.*\nimport org.jetbrains.kotlin.ir.visitors.*\nimport org.jetbrains.kotlin.name.*\nimport org.jetbrains.kotlin.util.capitalizeDecapitalize.*\nimport org.jetbrains.kotlinx.atomicfu.compiler.backend.*\nimport kotlin.collections.set\n\nprivate const val AFU_PKG = \"kotlinx.atomicfu\"\nprivate const val TRACE_BASE_TYPE = \"TraceBase\"\nprivate const val ATOMIC_VALUE_FACTORY = \"atomic\"\nprivate const val INVOKE = \"invoke\"\nprivate const val APPEND = \"append\"\nprivate const val GET = \"get\"\nprivate const val ATOMICFU = \"atomicfu\"\nprivate const val ATOMIC_ARRAY_RECEIVER_SUFFIX = \"\\$array\"\nprivate const val DISPATCH_RECEIVER = \"${ATOMICFU}\\$dispatchReceiver\"\nprivate const val ATOMIC_HANDLER = \"${ATOMICFU}\\$handler\"\nprivate const val ACTION = \"${ATOMICFU}\\$action\"\nprivate const val INDEX = \"${ATOMICFU}\\$index\"\nprivate const val VOLATILE_WRAPPER_SUFFIX = \"\\$VolatileWrapper\"\nprivate const val LOOP = \"loop\"\nprivate const val UPDATE = \"update\"\n\nclass AtomicfuJvmIrTransformer(\n    private val context: IrPluginContext,\n    private val atomicSymbols: AtomicSymbols\n) {\n    private val irBuiltIns = context.irBuiltIns\n\n    private val AFU_VALUE_TYPES: Map<String, IrType> = mapOf(\n        \"AtomicInt\" to irBuiltIns.intType,\n        \"AtomicLong\" to irBuiltIns.longType,\n        \"AtomicBoolean\" to irBuiltIns.booleanType,\n        \"AtomicRef\" to irBuiltIns.anyNType\n    )\n\n    private val ATOMICFU_INLINE_FUNCTIONS = setOf(\"loop\", \"update\", \"getAndUpdate\", \"updateAndGet\")\n    protected val ATOMIC_VALUE_TYPES = setOf(\"AtomicInt\", \"AtomicLong\", \"AtomicBoolean\", \"AtomicRef\")\n    protected val ATOMIC_ARRAY_TYPES = setOf(\"AtomicIntArray\", \"AtomicLongArray\", \"AtomicBooleanArray\", \"AtomicArray\")\n\n    fun transform(moduleFragment: IrModuleFragment) {\n        transformAtomicFields(moduleFragment)\n        transformAtomicExtensions(moduleFragment)\n        transformAtomicfuDeclarations(moduleFragment)\n        moduleFragment.files.forEach { irFile ->\n            irFile.patchDeclarationParents()\n        }\n    }\n\n    private fun transformAtomicFields(moduleFragment: IrModuleFragment) {\n        moduleFragment.files.forEach { irFile ->\n            irFile.transform(AtomicHandlerTransformer(), null)\n        }\n    }\n\n    private fun transformAtomicExtensions(moduleFragment: IrModuleFragment) {\n        moduleFragment.files.forEach { irFile ->\n            irFile.transform(AtomicExtensionTransformer(), null)\n        }\n    }\n\n    private fun transformAtomicfuDeclarations(moduleFragment: IrModuleFragment) {\n        moduleFragment.files.forEach { irFile ->\n            irFile.transform(AtomicfuTransformer(), null)\n        }\n    }\n\n    private val propertyToAtomicHandler = mutableMapOf<IrProperty, IrProperty>()\n\n    private inner class AtomicHandlerTransformer : IrElementTransformer<IrFunction?> {\n        override fun visitClass(declaration: IrClass, data: IrFunction?): IrStatement {\n            declaration.declarations.filter(::fromKotlinxAtomicfu).forEach {\n                (it as IrProperty).transformAtomicfuProperty(declaration)\n            }\n            return super.visitClass(declaration, data)\n        }\n\n        override fun visitFile(declaration: IrFile, data: IrFunction?): IrFile {\n            declaration.declarations.filter(::fromKotlinxAtomicfu).forEach {\n                (it as IrProperty).transformAtomicfuProperty(declaration)\n            }\n            return super.visitFile(declaration, data)\n        }\n\n        private fun IrProperty.transformAtomicfuProperty(parent: IrDeclarationContainer) {\n            val isTopLevel = parent is IrFile\n            when {\n                isAtomic() -> {\n                    if (isTopLevel) {\n                        val parentClass = generateWrapperClass(this, parent)\n                        transformAtomicProperty(parentClass)\n                        moveFromFileToClass(parent as IrFile, parentClass)\n                    } else {\n                        transformAtomicProperty(parent as IrClass)\n                    }\n                }\n                isDelegatedToAtomic() -> transformDelegatedProperty(parent)\n                isAtomicArray() -> transformAtomicArrayProperty(parent)\n                isTrace() -> parent.declarations.remove(this)\n                else -> {}\n            }\n        }\n\n        private fun IrProperty.moveFromFileToClass(\n            parentFile: IrFile,\n            parentClass: IrClass\n        ) {\n            parentFile.declarations.remove(this)\n            parentClass.declarations.add(this)\n            parent = parentClass\n        }\n\n        private fun IrProperty.transformAtomicProperty(parentClass: IrClass) {\n            // Atomic property transformation:\n            // 1. replace it's backingField with a volatile property of atomic value type\n            // 2. create j.u.c.a.Atomic*FieldUpdater for this volatile property to handle it's value atomically\n            // val a = atomic(0) ->\n            // volatile var a: Int = 0\n            // val a$FU = AtomicIntegerFieldUpdater.newUpdater(parentClass, \"a\")\n            //\n            // Top-level atomic properties transformation:\n            // 1. replace it's backingField with a volatile property of atomic value type\n            // 2. wrap this volatile property into the generated class\n            // 3. create j.u.c.a.Atomic*FieldUpdater for the volatile property to handle it's value atomically\n            // val a = atomic(0) ->\n            // class A$ParentFile$VolatileWrapper { volatile var a: Int = 0 }\n            // val a$FU = AtomicIntegerFieldUpdater.newUpdater(A$ParentFile$VolatileWrapper::class, \"a\")\n            backingField = buildVolatileRawField(this, parentClass)\n            // update property accessors\n            context.addDefaultGetter(this, parentClass)\n            val fieldUpdater = addJucaAFUProperty(this, parentClass)\n            registerAtomicHandler(fieldUpdater)\n        }\n\n        private fun IrProperty.transformAtomicArrayProperty(parent: IrDeclarationContainer) {\n            // Replace atomicfu array classes with the corresponding atomic arrays from j.u.c.a.:\n            // val intArr = atomicArrayOfNulls<Any?>(5) ->\n            // val intArr = AtomicReferenceArray(5)\n            backingField = buildJucaArrayField(this, parent)\n            // update property accessors\n            context.addDefaultGetter(this, parent)\n            registerAtomicHandler(this)\n        }\n\n        private fun IrProperty.transformDelegatedProperty(parentClass: IrDeclarationContainer) {\n            backingField?.let {\n                it.initializer?.let {\n                    val initializer = it.expression as IrCall\n                    if (initializer.isAtomicFactory()) {\n                        // Property delegated to atomic factory invocation:\n                        // 1. replace it's backingField with a volatile property of value type\n                        // 2. transform getter/setter\n                        // var a by atomic(0) ->\n                        // volatile var a: Int = 0\n                        val volatileField = buildVolatileRawField(this, parentClass)\n                        backingField = volatileField\n                        getter?.transformAccessor(volatileField, getter?.dispatchReceiverParameter?.capture())\n                        setter?.transformAccessor(volatileField, setter?.dispatchReceiverParameter?.capture())\n                    } else {\n                        // Property delegated to the atomic property:\n                        // 1. delegate it's accessors to get/set of the backingField of the atomic delegate\n                        // (that is already transformed to a volatile field of value type)\n                        // val _a = atomic(0)\n                        // var a by _a ->\n                        // volatile var _a: Int = 0\n                        // var a by _a\n                        val atomicProperty = initializer.getCorrespondingProperty()\n                        val volatileField = atomicProperty.backingField!!\n                        backingField = null\n                        if (atomicProperty.isTopLevel()) {\n                            atomicSymbols.createBuilder(symbol).run {\n                                val parent = getStaticVolatileWrapperInstance(atomicProperty)\n                                getter?.transformAccessor(volatileField, getProperty(parent, null))\n                                setter?.transformAccessor(volatileField, getProperty(parent, null))\n                            }\n                        } else {\n                            if (this.parent == atomicProperty.parent) {\n                                //class A {\n                                //    val _a = atomic()\n                                //    var a by _a\n                                //}\n                                getter?.transformAccessor(volatileField, getter?.dispatchReceiverParameter?.capture())\n                                setter?.transformAccessor(volatileField, setter?.dispatchReceiverParameter?.capture())\n                            } else {\n                                //class A {\n                                //    val _a = atomic()\n                                //    inner class B {\n                                //        var a by _a\n                                //    }\n                                //}\n                                val thisReceiver = atomicProperty.parentAsClass.thisReceiver\n                                getter?.transformAccessor(volatileField, thisReceiver?.capture())\n                                setter?.transformAccessor(volatileField, thisReceiver?.capture())\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private fun IrFunction.transformAccessor(volatileField: IrField, parent: IrExpression?) {\n            val accessor = this\n            atomicSymbols.createBuilder(symbol).run {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "893088032",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4835,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org/jetbrains/kotlinx/atomicfu/compiler/backend/jvm/AtomicfuJvmIrTransformer.kt",
        "discussion_id": "893088032",
        "commented_code": "@@ -0,0 +1,825 @@\n+/*\n+ * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.backend.jvm\n+\n+import org.jetbrains.kotlin.backend.common.extensions.*\n+import org.jetbrains.kotlin.backend.jvm.ir.*\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.builders.declarations.*\n+import org.jetbrains.kotlin.ir.builders.*\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.declarations.impl.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.symbols.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.*\n+import org.jetbrains.kotlin.name.*\n+import org.jetbrains.kotlin.util.capitalizeDecapitalize.*\n+import org.jetbrains.kotlinx.atomicfu.compiler.backend.*\n+import kotlin.collections.set\n+\n+private const val AFU_PKG = \"kotlinx.atomicfu\"\n+private const val TRACE_BASE_TYPE = \"TraceBase\"\n+private const val ATOMIC_VALUE_FACTORY = \"atomic\"\n+private const val INVOKE = \"invoke\"\n+private const val APPEND = \"append\"\n+private const val GET = \"get\"\n+private const val ATOMICFU = \"atomicfu\"\n+private const val ATOMIC_ARRAY_RECEIVER_SUFFIX = \"\\$array\"\n+private const val DISPATCH_RECEIVER = \"${ATOMICFU}\\$dispatchReceiver\"\n+private const val ATOMIC_HANDLER = \"${ATOMICFU}\\$handler\"\n+private const val ACTION = \"${ATOMICFU}\\$action\"\n+private const val INDEX = \"${ATOMICFU}\\$index\"\n+private const val VOLATILE_WRAPPER_SUFFIX = \"\\$VolatileWrapper\"\n+private const val LOOP = \"loop\"\n+private const val UPDATE = \"update\"\n+\n+class AtomicfuJvmIrTransformer(\n+    private val context: IrPluginContext,\n+    private val atomicSymbols: AtomicSymbols\n+) {\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_VALUE_TYPES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType,\n+        \"AtomicRef\" to irBuiltIns.anyNType\n+    )\n+\n+    private val ATOMICFU_INLINE_FUNCTIONS = setOf(\"loop\", \"update\", \"getAndUpdate\", \"updateAndGet\")\n+    protected val ATOMIC_VALUE_TYPES = setOf(\"AtomicInt\", \"AtomicLong\", \"AtomicBoolean\", \"AtomicRef\")\n+    protected val ATOMIC_ARRAY_TYPES = setOf(\"AtomicIntArray\", \"AtomicLongArray\", \"AtomicBooleanArray\", \"AtomicArray\")\n+\n+    fun transform(moduleFragment: IrModuleFragment) {\n+        transformAtomicFields(moduleFragment)\n+        transformAtomicExtensions(moduleFragment)\n+        transformAtomicfuDeclarations(moduleFragment)\n+        moduleFragment.files.forEach { irFile ->\n+            irFile.patchDeclarationParents()\n+        }\n+    }\n+\n+    private fun transformAtomicFields(moduleFragment: IrModuleFragment) {\n+        moduleFragment.files.forEach { irFile ->\n+            irFile.transform(AtomicHandlerTransformer(), null)\n+        }\n+    }\n+\n+    private fun transformAtomicExtensions(moduleFragment: IrModuleFragment) {\n+        moduleFragment.files.forEach { irFile ->\n+            irFile.transform(AtomicExtensionTransformer(), null)\n+        }\n+    }\n+\n+    private fun transformAtomicfuDeclarations(moduleFragment: IrModuleFragment) {\n+        moduleFragment.files.forEach { irFile ->\n+            irFile.transform(AtomicfuTransformer(), null)\n+        }\n+    }\n+\n+    private val propertyToAtomicHandler = mutableMapOf<IrProperty, IrProperty>()\n+\n+    private inner class AtomicHandlerTransformer : IrElementTransformer<IrFunction?> {\n+        override fun visitClass(declaration: IrClass, data: IrFunction?): IrStatement {\n+            declaration.declarations.filter(::fromKotlinxAtomicfu).forEach {\n+                (it as IrProperty).transformAtomicfuProperty(declaration)\n+            }\n+            return super.visitClass(declaration, data)\n+        }\n+\n+        override fun visitFile(declaration: IrFile, data: IrFunction?): IrFile {\n+            declaration.declarations.filter(::fromKotlinxAtomicfu).forEach {\n+                (it as IrProperty).transformAtomicfuProperty(declaration)\n+            }\n+            return super.visitFile(declaration, data)\n+        }\n+\n+        private fun IrProperty.transformAtomicfuProperty(parent: IrDeclarationContainer) {\n+            val isTopLevel = parent is IrFile\n+            when {\n+                isAtomic() -> {\n+                    if (isTopLevel) {\n+                        val parentClass = generateWrapperClass(this, parent)\n+                        transformAtomicProperty(parentClass)\n+                        moveFromFileToClass(parent as IrFile, parentClass)\n+                    } else {\n+                        transformAtomicProperty(parent as IrClass)\n+                    }\n+                }\n+                isDelegatedToAtomic() -> transformDelegatedProperty(parent)\n+                isAtomicArray() -> transformAtomicArrayProperty(parent)\n+                isTrace() -> parent.declarations.remove(this)\n+                else -> {}\n+            }\n+        }\n+\n+        private fun IrProperty.moveFromFileToClass(\n+            parentFile: IrFile,\n+            parentClass: IrClass\n+        ) {\n+            parentFile.declarations.remove(this)\n+            parentClass.declarations.add(this)\n+            parent = parentClass\n+        }\n+\n+        private fun IrProperty.transformAtomicProperty(parentClass: IrClass) {\n+            // Atomic property transformation:\n+            // 1. replace it's backingField with a volatile property of atomic value type\n+            // 2. create j.u.c.a.Atomic*FieldUpdater for this volatile property to handle it's value atomically\n+            // val a = atomic(0) ->\n+            // volatile var a: Int = 0\n+            // val a$FU = AtomicIntegerFieldUpdater.newUpdater(parentClass, \"a\")\n+            //\n+            // Top-level atomic properties transformation:\n+            // 1. replace it's backingField with a volatile property of atomic value type\n+            // 2. wrap this volatile property into the generated class\n+            // 3. create j.u.c.a.Atomic*FieldUpdater for the volatile property to handle it's value atomically\n+            // val a = atomic(0) ->\n+            // class A$ParentFile$VolatileWrapper { volatile var a: Int = 0 }\n+            // val a$FU = AtomicIntegerFieldUpdater.newUpdater(A$ParentFile$VolatileWrapper::class, \"a\")\n+            backingField = buildVolatileRawField(this, parentClass)\n+            // update property accessors\n+            context.addDefaultGetter(this, parentClass)\n+            val fieldUpdater = addJucaAFUProperty(this, parentClass)\n+            registerAtomicHandler(fieldUpdater)\n+        }\n+\n+        private fun IrProperty.transformAtomicArrayProperty(parent: IrDeclarationContainer) {\n+            // Replace atomicfu array classes with the corresponding atomic arrays from j.u.c.a.:\n+            // val intArr = atomicArrayOfNulls<Any?>(5) ->\n+            // val intArr = AtomicReferenceArray(5)\n+            backingField = buildJucaArrayField(this, parent)\n+            // update property accessors\n+            context.addDefaultGetter(this, parent)\n+            registerAtomicHandler(this)\n+        }\n+\n+        private fun IrProperty.transformDelegatedProperty(parentClass: IrDeclarationContainer) {\n+            backingField?.let {\n+                it.initializer?.let {\n+                    val initializer = it.expression as IrCall\n+                    if (initializer.isAtomicFactory()) {\n+                        // Property delegated to atomic factory invocation:\n+                        // 1. replace it's backingField with a volatile property of value type\n+                        // 2. transform getter/setter\n+                        // var a by atomic(0) ->\n+                        // volatile var a: Int = 0\n+                        val volatileField = buildVolatileRawField(this, parentClass)\n+                        backingField = volatileField\n+                        getter?.transformAccessor(volatileField, getter?.dispatchReceiverParameter?.capture())\n+                        setter?.transformAccessor(volatileField, setter?.dispatchReceiverParameter?.capture())\n+                    } else {\n+                        // Property delegated to the atomic property:\n+                        // 1. delegate it's accessors to get/set of the backingField of the atomic delegate\n+                        // (that is already transformed to a volatile field of value type)\n+                        // val _a = atomic(0)\n+                        // var a by _a ->\n+                        // volatile var _a: Int = 0\n+                        // var a by _a\n+                        val atomicProperty = initializer.getCorrespondingProperty()\n+                        val volatileField = atomicProperty.backingField!!\n+                        backingField = null\n+                        if (atomicProperty.isTopLevel()) {\n+                            atomicSymbols.createBuilder(symbol).run {\n+                                val parent = getStaticVolatileWrapperInstance(atomicProperty)\n+                                getter?.transformAccessor(volatileField, getProperty(parent, null))\n+                                setter?.transformAccessor(volatileField, getProperty(parent, null))\n+                            }\n+                        } else {\n+                            if (this.parent == atomicProperty.parent) {\n+                                //class A {\n+                                //    val _a = atomic()\n+                                //    var a by _a\n+                                //}\n+                                getter?.transformAccessor(volatileField, getter?.dispatchReceiverParameter?.capture())\n+                                setter?.transformAccessor(volatileField, setter?.dispatchReceiverParameter?.capture())\n+                            } else {\n+                                //class A {\n+                                //    val _a = atomic()\n+                                //    inner class B {\n+                                //        var a by _a\n+                                //    }\n+                                //}\n+                                val thisReceiver = atomicProperty.parentAsClass.thisReceiver\n+                                getter?.transformAccessor(volatileField, thisReceiver?.capture())\n+                                setter?.transformAccessor(volatileField, thisReceiver?.capture())\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private fun IrFunction.transformAccessor(volatileField: IrField, parent: IrExpression?) {\n+            val accessor = this\n+            atomicSymbols.createBuilder(symbol).run {",
        "comment_created_at": "2022-06-09T05:37:45+00:00",
        "comment_author": "ilmirus",
        "comment_body": "Generally, we use `with(...createBuilder(symbol))` idiom, when we create IR nodes. This helps us spot the places, where IR is create at a glance.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "786266216",
    "pr_number": 4560,
    "pr_file": "compiler/ir/ir.tree/gen/org/jetbrains/kotlin/ir/expressions/IrGetValue.kt",
    "created_at": "2022-01-17T20:02:16+00:00",
    "commented_code": "/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n//This file was generated automatically\n//DO NOT MODIFY IT MANUALLY\n\npackage org.jetbrains.kotlin.ir.expressions\n\nimport org.jetbrains.kotlin.ir.visitors.IrElementVisitor\n\n/**\n * A leaf IR tree element.\n * @sample org.jetbrains.kotlin.ir.generator.IrTree.getValue\n */\nabstract class IrGetValue : IrValueAccessExpression() {\n    override fun <R, D> accept(visitor: IrElementVisitor<R, D>, data: D): R =\n        visitor.visitGetValue(this, data)\n\n    abstract fun copyWithOffsets(newStartOffset: Int, newEndOffset: Int): IrGetValue",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "786266216",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4560,
        "pr_file": "compiler/ir/ir.tree/gen/org/jetbrains/kotlin/ir/expressions/IrGetValue.kt",
        "discussion_id": "786266216",
        "commented_code": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+//This file was generated automatically\n+//DO NOT MODIFY IT MANUALLY\n+\n+package org.jetbrains.kotlin.ir.expressions\n+\n+import org.jetbrains.kotlin.ir.visitors.IrElementVisitor\n+\n+/**\n+ * A leaf IR tree element.\n+ * @sample org.jetbrains.kotlin.ir.generator.IrTree.getValue\n+ */\n+abstract class IrGetValue : IrValueAccessExpression() {\n+    override fun <R, D> accept(visitor: IrElementVisitor<R, D>, data: D): R =\n+        visitor.visitGetValue(this, data)\n+\n+    abstract fun copyWithOffsets(newStartOffset: Int, newEndOffset: Int): IrGetValue",
        "comment_created_at": "2022-01-17T20:02:16+00:00",
        "comment_author": "bashor",
        "comment_body": "Minor: probably it could be extracted to extension function, same as for IrConst",
        "pr_file_module": null
      }
    ]
  }
]