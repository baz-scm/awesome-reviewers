[
  {
    "discussion_id": "1987917791",
    "pr_number": 5411,
    "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
    "created_at": "2025-03-10T19:44:10+00:00",
    "commented_code": "assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n    }\n\n    @Sample\n    fun lastIndexOf() {\n        fun matchDetails(inputString: String, whatToFind: String, startIndex: Int = 0): String {\n            val matchIndex = inputString.lastIndexOf(whatToFind, startIndex)\n            return \"Searching for '$whatToFind' in '$inputString' starting at position $startIndex: \" +\n                    if (matchIndex >= 0) \"Found at $matchIndex\" else \"Not found\"\n        }\n\n        val inputString = \"Never ever give up\"\n        val toFind = \"ever\"\n\n        assertPrints(matchDetails(inputString, toFind), \"Searching for 'ever' in 'Never ever give up' starting at position 0: Found at 6\")\n        assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n    }\n\n    @Sample\n    fun contains() {\n        val string = \"Kotlin 1.4.0\"\n        assertTrue(string.contains(\"K\"))\n        assertFalse(string.contains(\"k\"))\n\n        assertTrue(string.contains(\"1.4\"))\n        assertFalse(string.contains(\"Z\"))",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1987917791",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5411,
        "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
        "discussion_id": "1987917791",
        "commented_code": "@@ -444,6 +444,33 @@ class Strings {\n         assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n     }\n \n+    @Sample\n+    fun lastIndexOf() {\n+        fun matchDetails(inputString: String, whatToFind: String, startIndex: Int = 0): String {\n+            val matchIndex = inputString.lastIndexOf(whatToFind, startIndex)\n+            return \"Searching for '$whatToFind' in '$inputString' starting at position $startIndex: \" +\n+                    if (matchIndex >= 0) \"Found at $matchIndex\" else \"Not found\"\n+        }\n+\n+        val inputString = \"Never ever give up\"\n+        val toFind = \"ever\"\n+\n+        assertPrints(matchDetails(inputString, toFind), \"Searching for 'ever' in 'Never ever give up' starting at position 0: Found at 6\")\n+        assertPrints(matchDetails(inputString, toFind, 10), \"Searching for 'ever' in 'Never ever give up' starting at position 10: Not found\")\n+    }\n+\n+    @Sample\n+    fun contains() {\n+        val string = \"Kotlin 1.4.0\"\n+        assertTrue(string.contains(\"K\"))\n+        assertFalse(string.contains(\"k\"))\n+\n+        assertTrue(string.contains(\"1.4\"))\n+        assertFalse(string.contains(\"Z\"))",
        "comment_created_at": "2025-03-10T19:44:10+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "I don't think these two examples adds a lot of value, two examples in the beginning of the sample shows the same: `contains` return true when a string contains a corresponding sub-sequences, and false otherwise.\r\n\r\nInstead, it would be nice to show how `contains` handles edge-cases:\r\n- when the receiver is not empty, but the parameter is empty;\r\n- when both the receiver and the parameter are the same char sequence (i.e., \"Kotlin\" in \"Kotlin\")\r\n- when both the receiver and the parameter are empty strings;\r\n- when the receiver is a sub-sequence of the parameter (i.e. \"Kotlin 2.2.0\" in \"Kotlin\").",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "451430040",
    "pr_number": 3516,
    "pr_file": "libraries/scripting/type-providers/src/kotlin/script/experimental/typeProviders/generatedCode/GeneratedCode.kt",
    "created_at": "2020-07-08T10:05:21+00:00",
    "commented_code": "/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.script.experimental.typeProviders.generatedCode\n\nimport kotlin.reflect.KClass\nimport kotlin.script.experimental.typeProviders.generatedCode.impl.*\nimport kotlin.script.experimental.typeProviders.generatedCode.impl.Object\nimport kotlin.script.experimental.typeProviders.generatedCode.impl.writeJoined\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.Generated\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.GeneratedCodeVisitor\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.InternalGeneratedCode\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.visit\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.captureImports\nimport kotlin.script.experimental.typeProviders.generatedCode.internal.write\nimport kotlin.text.StringBuilder\n\n/**\n * Code returned by a Type Provider.\n * [GeneratedCode] is a recursive construction that allows you to build generated code as a combination of multiple types already provided\n *\n * Example:\n *\n * ```kotlin\n * data class MyObject(val name: String, val value: Int) : GeneratedCode {\n *     fun body(): GeneratedCode {\n *          return GeneratedCode.composite {\n *              +makeDataClass(name)\n *                  .withInterface(MyInterface::class)\n *\n *              +makeConstant(\"$nameConstant\", value)\n *          }\n *     }\n * }\n * ```\n *\n * [GeneratedCode] can contain any of the following:\n * - Data classes. See [makeDataClass].\n * - Objects. See [makeObject].\n * - Constants. See [makeConstant].\n * - Packages. See [makePackage].\n * - Extension functions. See [makeExtensionMethod].\n * - etc.\n */\ninterface GeneratedCode {\n    /**\n     * Generate the code that corresponds to your type\n     *\n     * @return An instance of [GeneratedCode].\n     * Important: don't return an infinite recursion in the form of return `this`\n     */\n    fun body(): GeneratedCode\n\n    /**\n     * A builder for a composite of multiple types\n     */\n    class Builder internal constructor() {\n        private val mutableCodeList = mutableListOf<GeneratedCode>()\n\n        /**\n         * Include code in your compound\n         */\n        operator fun GeneratedCode.unaryPlus() {\n            if (this is CompoundGeneratedCode) {\n                mutableCodeList.addAll(codeList)\n            } else {\n                mutableCodeList.add(this)\n            }\n        }\n\n        operator fun String.unaryPlus() {\n            mutableCodeList.add(inlineCode(this))\n        }\n\n        internal fun build(): GeneratedCode {\n            return composite(mutableCodeList)\n        }\n    }\n\n    object Empty : GeneratedCode by EmptyCode()\n\n    companion object {\n        /**\n         * Create a composition of multiple instances of Generated Code\n         */\n        fun composite(init: Builder.() -> Unit) = Builder().apply(init).build()\n\n        /**\n         * Create a composition of multiple instances of Generated Code\n         */\n        fun composite(iterable: Collection<GeneratedCode>): GeneratedCode = if (iterable.count() == 1)\n            iterable.first()\n        else\n            CompoundGeneratedCode(iterable.toList())\n\n        /**\n         * Create a composition of multiple instances of Generated Code\n         */\n        fun composite(vararg code: GeneratedCode) = composite(code.toList())\n    }\n}\n\nprivate data class CompoundGeneratedCode(val codeList: List<GeneratedCode>) : InternalGeneratedCode() {\n    override fun StringBuilder.write(indent: Int) {\n        writeJoined(codeList, \"\\n\\n\", indent)\n    }\n\n    override fun GeneratedCodeVisitor.visit() {\n        for (code in codeList) {\n            visit(code)\n        }\n    }\n}\n\n/**\n * References a member that can be used as a type\n */\ninterface IdentifiableMember {\n    val name: String\n    fun imports(): Set<String> = emptySet()\n\n    companion object {\n        private data class KClassIdentifiable(val kClass: KClass<*>) : IdentifiableMember {\n            override val name: String = kClass.simpleName ?: kClass.qualifiedName!!\n            override fun imports() = setOfNotNull(kClass.qualifiedName)\n        }\n\n        private data class NamedIdentifiable(override val name: String) : IdentifiableMember\n\n        operator fun invoke(kClass: KClass<*>): IdentifiableMember = KClassIdentifiable(kClass)\n        operator fun invoke(name: String): IdentifiableMember = NamedIdentifiable(name)\n    }\n}\n\n/**\n * References an interface that can be implemented\n */\ninterface GeneratedInterface : IdentifiableMember\n\nprivate data class CastedInterfaceMember(private val member: IdentifiableMember) : GeneratedInterface, IdentifiableMember by member\n\nfun IdentifiableMember.asInterface(): GeneratedInterface = CastedInterfaceMember(this)\n\n/**\n * Generated code that is a type that can be used as an Argument\n */\ninterface IdentifiableCode : GeneratedCode, IdentifiableMember\n\n/**\n * Builder for a provided type whose JVM Name can be set\n */\ninterface JVMNameableBuilder {\n    fun jvmName(name: String)\n}\n\n/**\n * Builder for a provided type. It can implement an interface and have some code inside.\n */\ninterface GeneratedTypeBuilder : IdentifiableMember {\n    /**\n     * Implement a generated interface\n     */\n    fun implement(generated: GeneratedInterface)\n\n    /**\n     * Add code to the namespace of the Type\n     */\n    fun inner(code: GeneratedCode)\n}\n\n/**\n * Builder for a provided data class. It can implement interfaces, have code inside and have a number of properties\n */\ninterface DataClassBuilder : JVMNameableBuilder, GeneratedTypeBuilder {\n    fun property(name: String, type: IdentifiableMember, default: GeneratedCode? = null)\n}\n\n/**\n * Builder for a provided object. It can implement interfaces, have code inside and have a number of properties.\n */\ninterface ObjectBuilder : JVMNameableBuilder, GeneratedTypeBuilder\n\n/**\n * Add multiple instances of generated code inside of the type\n */\nfun GeneratedTypeBuilder.inner(init: GeneratedCode.Builder.() -> Unit) {\n    inner(GeneratedCode.composite(init))\n}\n\n/**\n * Implement the interface.\n */\nfun GeneratedTypeBuilder.implement(kClass: KClass<*>) {\n    require(kClass.java.isInterface) { \"Provided type is not an interface\" }\n    implement(IdentifiableMember(kClass).asInterface())\n}\n\n/**\n * Add a companion object to the generated type\n */\nfun GeneratedTypeBuilder.companionObject(name: String? = null, init: ObjectBuilder.() -> Unit) {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "451430040",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3516,
        "pr_file": "libraries/scripting/type-providers/src/kotlin/script/experimental/typeProviders/generatedCode/GeneratedCode.kt",
        "discussion_id": "451430040",
        "commented_code": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.typeProviders.generatedCode\n+\n+import kotlin.reflect.KClass\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.*\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.Object\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.writeJoined\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.Generated\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.GeneratedCodeVisitor\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.InternalGeneratedCode\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visit\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.captureImports\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.write\n+import kotlin.text.StringBuilder\n+\n+/**\n+ * Code returned by a Type Provider.\n+ * [GeneratedCode] is a recursive construction that allows you to build generated code as a combination of multiple types already provided\n+ *\n+ * Example:\n+ *\n+ * ```kotlin\n+ * data class MyObject(val name: String, val value: Int) : GeneratedCode {\n+ *     fun body(): GeneratedCode {\n+ *          return GeneratedCode.composite {\n+ *              +makeDataClass(name)\n+ *                  .withInterface(MyInterface::class)\n+ *\n+ *              +makeConstant(\"$nameConstant\", value)\n+ *          }\n+ *     }\n+ * }\n+ * ```\n+ *\n+ * [GeneratedCode] can contain any of the following:\n+ * - Data classes. See [makeDataClass].\n+ * - Objects. See [makeObject].\n+ * - Constants. See [makeConstant].\n+ * - Packages. See [makePackage].\n+ * - Extension functions. See [makeExtensionMethod].\n+ * - etc.\n+ */\n+interface GeneratedCode {\n+    /**\n+     * Generate the code that corresponds to your type\n+     *\n+     * @return An instance of [GeneratedCode].\n+     * Important: don't return an infinite recursion in the form of return `this`\n+     */\n+    fun body(): GeneratedCode\n+\n+    /**\n+     * A builder for a composite of multiple types\n+     */\n+    class Builder internal constructor() {\n+        private val mutableCodeList = mutableListOf<GeneratedCode>()\n+\n+        /**\n+         * Include code in your compound\n+         */\n+        operator fun GeneratedCode.unaryPlus() {\n+            if (this is CompoundGeneratedCode) {\n+                mutableCodeList.addAll(codeList)\n+            } else {\n+                mutableCodeList.add(this)\n+            }\n+        }\n+\n+        operator fun String.unaryPlus() {\n+            mutableCodeList.add(inlineCode(this))\n+        }\n+\n+        internal fun build(): GeneratedCode {\n+            return composite(mutableCodeList)\n+        }\n+    }\n+\n+    object Empty : GeneratedCode by EmptyCode()\n+\n+    companion object {\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(init: Builder.() -> Unit) = Builder().apply(init).build()\n+\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(iterable: Collection<GeneratedCode>): GeneratedCode = if (iterable.count() == 1)\n+            iterable.first()\n+        else\n+            CompoundGeneratedCode(iterable.toList())\n+\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(vararg code: GeneratedCode) = composite(code.toList())\n+    }\n+}\n+\n+private data class CompoundGeneratedCode(val codeList: List<GeneratedCode>) : InternalGeneratedCode() {\n+    override fun StringBuilder.write(indent: Int) {\n+        writeJoined(codeList, \"\\n\\n\", indent)\n+    }\n+\n+    override fun GeneratedCodeVisitor.visit() {\n+        for (code in codeList) {\n+            visit(code)\n+        }\n+    }\n+}\n+\n+/**\n+ * References a member that can be used as a type\n+ */\n+interface IdentifiableMember {\n+    val name: String\n+    fun imports(): Set<String> = emptySet()\n+\n+    companion object {\n+        private data class KClassIdentifiable(val kClass: KClass<*>) : IdentifiableMember {\n+            override val name: String = kClass.simpleName ?: kClass.qualifiedName!!\n+            override fun imports() = setOfNotNull(kClass.qualifiedName)\n+        }\n+\n+        private data class NamedIdentifiable(override val name: String) : IdentifiableMember\n+\n+        operator fun invoke(kClass: KClass<*>): IdentifiableMember = KClassIdentifiable(kClass)\n+        operator fun invoke(name: String): IdentifiableMember = NamedIdentifiable(name)\n+    }\n+}\n+\n+/**\n+ * References an interface that can be implemented\n+ */\n+interface GeneratedInterface : IdentifiableMember\n+\n+private data class CastedInterfaceMember(private val member: IdentifiableMember) : GeneratedInterface, IdentifiableMember by member\n+\n+fun IdentifiableMember.asInterface(): GeneratedInterface = CastedInterfaceMember(this)\n+\n+/**\n+ * Generated code that is a type that can be used as an Argument\n+ */\n+interface IdentifiableCode : GeneratedCode, IdentifiableMember\n+\n+/**\n+ * Builder for a provided type whose JVM Name can be set\n+ */\n+interface JVMNameableBuilder {\n+    fun jvmName(name: String)\n+}\n+\n+/**\n+ * Builder for a provided type. It can implement an interface and have some code inside.\n+ */\n+interface GeneratedTypeBuilder : IdentifiableMember {\n+    /**\n+     * Implement a generated interface\n+     */\n+    fun implement(generated: GeneratedInterface)\n+\n+    /**\n+     * Add code to the namespace of the Type\n+     */\n+    fun inner(code: GeneratedCode)\n+}\n+\n+/**\n+ * Builder for a provided data class. It can implement interfaces, have code inside and have a number of properties\n+ */\n+interface DataClassBuilder : JVMNameableBuilder, GeneratedTypeBuilder {\n+    fun property(name: String, type: IdentifiableMember, default: GeneratedCode? = null)\n+}\n+\n+/**\n+ * Builder for a provided object. It can implement interfaces, have code inside and have a number of properties.\n+ */\n+interface ObjectBuilder : JVMNameableBuilder, GeneratedTypeBuilder\n+\n+/**\n+ * Add multiple instances of generated code inside of the type\n+ */\n+fun GeneratedTypeBuilder.inner(init: GeneratedCode.Builder.() -> Unit) {\n+    inner(GeneratedCode.composite(init))\n+}\n+\n+/**\n+ * Implement the interface.\n+ */\n+fun GeneratedTypeBuilder.implement(kClass: KClass<*>) {\n+    require(kClass.java.isInterface) { \"Provided type is not an interface\" }\n+    implement(IdentifiableMember(kClass).asInterface())\n+}\n+\n+/**\n+ * Add a companion object to the generated type\n+ */\n+fun GeneratedTypeBuilder.companionObject(name: String? = null, init: ObjectBuilder.() -> Unit) {",
        "comment_created_at": "2020-07-08T10:05:21+00:00",
        "comment_author": "ligee",
        "comment_body": "It would be nice to have tests that use all functions from the DSL, otherwise, they may rot over time and we may discover it too late.",
        "pr_file_module": null
      },
      {
        "comment_id": "480104173",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 3516,
        "pr_file": "libraries/scripting/type-providers/src/kotlin/script/experimental/typeProviders/generatedCode/GeneratedCode.kt",
        "discussion_id": "451430040",
        "commented_code": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package kotlin.script.experimental.typeProviders.generatedCode\n+\n+import kotlin.reflect.KClass\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.*\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.Object\n+import kotlin.script.experimental.typeProviders.generatedCode.impl.writeJoined\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.Generated\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.GeneratedCodeVisitor\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.InternalGeneratedCode\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visit\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.visitor.captureImports\n+import kotlin.script.experimental.typeProviders.generatedCode.internal.write\n+import kotlin.text.StringBuilder\n+\n+/**\n+ * Code returned by a Type Provider.\n+ * [GeneratedCode] is a recursive construction that allows you to build generated code as a combination of multiple types already provided\n+ *\n+ * Example:\n+ *\n+ * ```kotlin\n+ * data class MyObject(val name: String, val value: Int) : GeneratedCode {\n+ *     fun body(): GeneratedCode {\n+ *          return GeneratedCode.composite {\n+ *              +makeDataClass(name)\n+ *                  .withInterface(MyInterface::class)\n+ *\n+ *              +makeConstant(\"$nameConstant\", value)\n+ *          }\n+ *     }\n+ * }\n+ * ```\n+ *\n+ * [GeneratedCode] can contain any of the following:\n+ * - Data classes. See [makeDataClass].\n+ * - Objects. See [makeObject].\n+ * - Constants. See [makeConstant].\n+ * - Packages. See [makePackage].\n+ * - Extension functions. See [makeExtensionMethod].\n+ * - etc.\n+ */\n+interface GeneratedCode {\n+    /**\n+     * Generate the code that corresponds to your type\n+     *\n+     * @return An instance of [GeneratedCode].\n+     * Important: don't return an infinite recursion in the form of return `this`\n+     */\n+    fun body(): GeneratedCode\n+\n+    /**\n+     * A builder for a composite of multiple types\n+     */\n+    class Builder internal constructor() {\n+        private val mutableCodeList = mutableListOf<GeneratedCode>()\n+\n+        /**\n+         * Include code in your compound\n+         */\n+        operator fun GeneratedCode.unaryPlus() {\n+            if (this is CompoundGeneratedCode) {\n+                mutableCodeList.addAll(codeList)\n+            } else {\n+                mutableCodeList.add(this)\n+            }\n+        }\n+\n+        operator fun String.unaryPlus() {\n+            mutableCodeList.add(inlineCode(this))\n+        }\n+\n+        internal fun build(): GeneratedCode {\n+            return composite(mutableCodeList)\n+        }\n+    }\n+\n+    object Empty : GeneratedCode by EmptyCode()\n+\n+    companion object {\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(init: Builder.() -> Unit) = Builder().apply(init).build()\n+\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(iterable: Collection<GeneratedCode>): GeneratedCode = if (iterable.count() == 1)\n+            iterable.first()\n+        else\n+            CompoundGeneratedCode(iterable.toList())\n+\n+        /**\n+         * Create a composition of multiple instances of Generated Code\n+         */\n+        fun composite(vararg code: GeneratedCode) = composite(code.toList())\n+    }\n+}\n+\n+private data class CompoundGeneratedCode(val codeList: List<GeneratedCode>) : InternalGeneratedCode() {\n+    override fun StringBuilder.write(indent: Int) {\n+        writeJoined(codeList, \"\\n\\n\", indent)\n+    }\n+\n+    override fun GeneratedCodeVisitor.visit() {\n+        for (code in codeList) {\n+            visit(code)\n+        }\n+    }\n+}\n+\n+/**\n+ * References a member that can be used as a type\n+ */\n+interface IdentifiableMember {\n+    val name: String\n+    fun imports(): Set<String> = emptySet()\n+\n+    companion object {\n+        private data class KClassIdentifiable(val kClass: KClass<*>) : IdentifiableMember {\n+            override val name: String = kClass.simpleName ?: kClass.qualifiedName!!\n+            override fun imports() = setOfNotNull(kClass.qualifiedName)\n+        }\n+\n+        private data class NamedIdentifiable(override val name: String) : IdentifiableMember\n+\n+        operator fun invoke(kClass: KClass<*>): IdentifiableMember = KClassIdentifiable(kClass)\n+        operator fun invoke(name: String): IdentifiableMember = NamedIdentifiable(name)\n+    }\n+}\n+\n+/**\n+ * References an interface that can be implemented\n+ */\n+interface GeneratedInterface : IdentifiableMember\n+\n+private data class CastedInterfaceMember(private val member: IdentifiableMember) : GeneratedInterface, IdentifiableMember by member\n+\n+fun IdentifiableMember.asInterface(): GeneratedInterface = CastedInterfaceMember(this)\n+\n+/**\n+ * Generated code that is a type that can be used as an Argument\n+ */\n+interface IdentifiableCode : GeneratedCode, IdentifiableMember\n+\n+/**\n+ * Builder for a provided type whose JVM Name can be set\n+ */\n+interface JVMNameableBuilder {\n+    fun jvmName(name: String)\n+}\n+\n+/**\n+ * Builder for a provided type. It can implement an interface and have some code inside.\n+ */\n+interface GeneratedTypeBuilder : IdentifiableMember {\n+    /**\n+     * Implement a generated interface\n+     */\n+    fun implement(generated: GeneratedInterface)\n+\n+    /**\n+     * Add code to the namespace of the Type\n+     */\n+    fun inner(code: GeneratedCode)\n+}\n+\n+/**\n+ * Builder for a provided data class. It can implement interfaces, have code inside and have a number of properties\n+ */\n+interface DataClassBuilder : JVMNameableBuilder, GeneratedTypeBuilder {\n+    fun property(name: String, type: IdentifiableMember, default: GeneratedCode? = null)\n+}\n+\n+/**\n+ * Builder for a provided object. It can implement interfaces, have code inside and have a number of properties.\n+ */\n+interface ObjectBuilder : JVMNameableBuilder, GeneratedTypeBuilder\n+\n+/**\n+ * Add multiple instances of generated code inside of the type\n+ */\n+fun GeneratedTypeBuilder.inner(init: GeneratedCode.Builder.() -> Unit) {\n+    inner(GeneratedCode.composite(init))\n+}\n+\n+/**\n+ * Implement the interface.\n+ */\n+fun GeneratedTypeBuilder.implement(kClass: KClass<*>) {\n+    require(kClass.java.isInterface) { \"Provided type is not an interface\" }\n+    implement(IdentifiableMember(kClass).asInterface())\n+}\n+\n+/**\n+ * Add a companion object to the generated type\n+ */\n+fun GeneratedTypeBuilder.companionObject(name: String? = null, init: ObjectBuilder.() -> Unit) {",
        "comment_created_at": "2020-08-31T12:43:27+00:00",
        "comment_author": "nerdsupremacist",
        "comment_body": "Added a bunch of tests. It should be just shy of 70% coverage now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1881708047",
    "pr_number": 5385,
    "pr_file": "native/native.tests/testData/codegen/cinterop/kt73565.kt",
    "created_at": "2024-12-12T09:32:06+00:00",
    "commented_code": "// TARGET_BACKEND: NATIVE\n@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n\nimport kotlin.test.*\nimport kotlinx.cinterop.*\n\nfun box(): String {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1881708047",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5385,
        "pr_file": "native/native.tests/testData/codegen/cinterop/kt73565.kt",
        "discussion_id": "1881708047",
        "commented_code": "@@ -0,0 +1,53 @@\n+// TARGET_BACKEND: NATIVE\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+\n+import kotlin.test.*\n+import kotlinx.cinterop.*\n+\n+fun box(): String {",
        "comment_created_at": "2024-12-12T09:32:06+00:00",
        "comment_author": "sbogolepov",
        "comment_body": "Please add tests for top-level functions as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1881822457",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5385,
        "pr_file": "native/native.tests/testData/codegen/cinterop/kt73565.kt",
        "discussion_id": "1881708047",
        "commented_code": "@@ -0,0 +1,53 @@\n+// TARGET_BACKEND: NATIVE\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+\n+import kotlin.test.*\n+import kotlinx.cinterop.*\n+\n+fun box(): String {",
        "comment_created_at": "2024-12-12T10:41:58+00:00",
        "comment_author": "KitsuneAlex",
        "comment_body": "Good point, don't know why i didn't think of that, will add.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1870271493",
    "pr_number": 4871,
    "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
    "created_at": "2024-12-04T20:59:23+00:00",
    "commented_code": "assertPrints(textWithoutDigits, \"abcde\")\n    }\n\n    @Sample\n    fun findLast() {\n        val text = \"a1b2c3d4e5\"\n\n        val lastNumberInText = text.findLast { it.isDigit() }\n        val lastUpperCaseInText = text.findLast { it.isUpperCase() }\n\n        assertPrints(lastNumberInText, \"5\")\n        assertPrints(lastUpperCaseInText, \"null\")\n    }",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1870271493",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4871,
        "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
        "discussion_id": "1870271493",
        "commented_code": "@@ -109,6 +109,17 @@ class Strings {\n         assertPrints(textWithoutDigits, \"abcde\")\n     }\n \n+    @Sample\n+    fun findLast() {\n+        val text = \"a1b2c3d4e5\"\n+\n+        val lastNumberInText = text.findLast { it.isDigit() }\n+        val lastUpperCaseInText = text.findLast { it.isUpperCase() }\n+\n+        assertPrints(lastNumberInText, \"5\")\n+        assertPrints(lastUpperCaseInText, \"null\")\n+    }",
        "comment_created_at": "2024-12-04T20:59:23+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "It would be nice to also showcase how the function works when invoked on an empty string: `assertPrints(\"\".findLast { true }, \"null\")`",
        "pr_file_module": null
      },
      {
        "comment_id": "1874614782",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4871,
        "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
        "discussion_id": "1870271493",
        "commented_code": "@@ -109,6 +109,17 @@ class Strings {\n         assertPrints(textWithoutDigits, \"abcde\")\n     }\n \n+    @Sample\n+    fun findLast() {\n+        val text = \"a1b2c3d4e5\"\n+\n+        val lastNumberInText = text.findLast { it.isDigit() }\n+        val lastUpperCaseInText = text.findLast { it.isUpperCase() }\n+\n+        assertPrints(lastNumberInText, \"5\")\n+        assertPrints(lastUpperCaseInText, \"null\")\n+    }",
        "comment_created_at": "2024-12-08T05:00:24+00:00",
        "comment_author": "simonNozaki",
        "comment_body": "Added: https://github.com/JetBrains/kotlin/pull/4871/commits/bce231a8be4dc97e07424b3635b708a11cf25c85\r\n\r\nAnd, as you advised me, I updates all assertions to inline calling.",
        "pr_file_module": null
      },
      {
        "comment_id": "1876523186",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4871,
        "pr_file": "libraries/stdlib/samples/test/samples/text/strings.kt",
        "discussion_id": "1870271493",
        "commented_code": "@@ -109,6 +109,17 @@ class Strings {\n         assertPrints(textWithoutDigits, \"abcde\")\n     }\n \n+    @Sample\n+    fun findLast() {\n+        val text = \"a1b2c3d4e5\"\n+\n+        val lastNumberInText = text.findLast { it.isDigit() }\n+        val lastUpperCaseInText = text.findLast { it.isUpperCase() }\n+\n+        assertPrints(lastNumberInText, \"5\")\n+        assertPrints(lastUpperCaseInText, \"null\")\n+    }",
        "comment_created_at": "2024-12-09T19:00:50+00:00",
        "comment_author": "fzhinkin",
        "comment_body": "Thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1581162687",
    "pr_number": 5281,
    "pr_file": "kotlin-native/backend.native/tests/runtime/program_name/runtime_program_name.kt",
    "created_at": "2024-04-26T15:02:50+00:00",
    "commented_code": "@file:OptIn(kotlin.experimental.ExperimentalNativeApi::class)\n\nimport kotlin.test.*\nimport kotlin.native.Platform\n\nfun main(args: Array<String>) {\n    // Remove path and extension (.kexe or .exe)\n    val programFileName = Platform.programName.substringAfterLast(\"/\").substringBeforeLast(\".\")\n\n    assertEquals(\"program_name\", programFileName)\n}",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1581162687",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5281,
        "pr_file": "kotlin-native/backend.native/tests/runtime/program_name/runtime_program_name.kt",
        "discussion_id": "1581162687",
        "commented_code": "@@ -0,0 +1,11 @@\n+@file:OptIn(kotlin.experimental.ExperimentalNativeApi::class)\n+\n+import kotlin.test.*\n+import kotlin.native.Platform\n+\n+fun main(args: Array<String>) {\n+    // Remove path and extension (.kexe or .exe)\n+    val programFileName = Platform.programName.substringAfterLast(\"/\").substringBeforeLast(\".\")\n+\n+    assertEquals(\"program_name\", programFileName)\n+}",
        "comment_created_at": "2024-04-26T15:02:50+00:00",
        "comment_author": "SvyatoslavScherbina",
        "comment_body": "More tests are necessary. For example, the original issue mentions a nice use case:\r\n> Build multi-call binaries. For example, busybox is a single binary that contains many tools, and decides which tool to run based on how the symbolic link is called: https://busybox.net/downloads/BusyBox.html#usage (that's how it can be so small)\r\n\r\nSo checking a case with symbolic link would also be useful.",
        "pr_file_module": null
      },
      {
        "comment_id": "1584883309",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5281,
        "pr_file": "kotlin-native/backend.native/tests/runtime/program_name/runtime_program_name.kt",
        "discussion_id": "1581162687",
        "commented_code": "@@ -0,0 +1,11 @@\n+@file:OptIn(kotlin.experimental.ExperimentalNativeApi::class)\n+\n+import kotlin.test.*\n+import kotlin.native.Platform\n+\n+fun main(args: Array<String>) {\n+    // Remove path and extension (.kexe or .exe)\n+    val programFileName = Platform.programName.substringAfterLast(\"/\").substringBeforeLast(\".\")\n+\n+    assertEquals(\"program_name\", programFileName)\n+}",
        "comment_created_at": "2024-04-30T13:59:47+00:00",
        "comment_author": "vonox7",
        "comment_body": "I added test for that by calling `execv()` in the C code. This allowed to test even more use-cases (no programName at all), while still covering the use-case of renaming/linking a binary.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1560651387",
    "pr_number": 5270,
    "pr_file": "native/native.tests/testData/codegen/cinterop/objc/kt65260.kt",
    "created_at": "2024-04-11T08:39:21+00:00",
    "commented_code": "/*\n * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n// TARGET_BACKEND: NATIVE\n// DISABLE_NATIVE: isAppleTarget=false\n\n// MODULE: cinterop\n// FILE: conversion.def\nlanguage = Objective-C\nheaders = conversion.h\nheaderFilter = conversion.h\n\n// FILE: conversion.h\n#import <Foundation/Foundation.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\n__attribute__((objc_runtime_name(\"Foo\")))\n@interface A : NSObject\n@end\n\n__attribute__((objc_runtime_name(\"Bar\")))\n@interface B : A\n@end\n\nNS_ASSUME_NONNULL_END\n\n// FILE: conversion.m\n#import \"conversion.h\"\n\n@implementation A\n@end\n\n@implementation B\n@end\n\n// MODULE: lib(cinterop)\n// FILE: lib.kt\n@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\nimport conversion.*\nimport platform.darwin.*\nimport kotlinx.cinterop.*\nimport kotlin.test.*\n\nclass ANativeHeir : A() {\n    companion object\n}\n\nclass BNativeHeir : B() {\n    companion object\n}\n\nfun testExternalObjCMetaClassCast() {\n    try {\n        BNativeHeir as A.Companion\n    } catch (e: Exception) {\n        assertTrue(e is ClassCastException)\n    }",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1560651387",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5270,
        "pr_file": "native/native.tests/testData/codegen/cinterop/objc/kt65260.kt",
        "discussion_id": "1560651387",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+// TARGET_BACKEND: NATIVE\n+// DISABLE_NATIVE: isAppleTarget=false\n+\n+// MODULE: cinterop\n+// FILE: conversion.def\n+language = Objective-C\n+headers = conversion.h\n+headerFilter = conversion.h\n+\n+// FILE: conversion.h\n+#import <Foundation/Foundation.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+__attribute__((objc_runtime_name(\"Foo\")))\n+@interface A : NSObject\n+@end\n+\n+__attribute__((objc_runtime_name(\"Bar\")))\n+@interface B : A\n+@end\n+\n+NS_ASSUME_NONNULL_END\n+\n+// FILE: conversion.m\n+#import \"conversion.h\"\n+\n+@implementation A\n+@end\n+\n+@implementation B\n+@end\n+\n+// MODULE: lib(cinterop)\n+// FILE: lib.kt\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+import conversion.*\n+import platform.darwin.*\n+import kotlinx.cinterop.*\n+import kotlin.test.*\n+\n+class ANativeHeir : A() {\n+    companion object\n+}\n+\n+class BNativeHeir : B() {\n+    companion object\n+}\n+\n+fun testExternalObjCMetaClassCast() {\n+    try {\n+        BNativeHeir as A.Companion\n+    } catch (e: Exception) {\n+        assertTrue(e is ClassCastException)\n+    }",
        "comment_created_at": "2024-04-11T08:39:21+00:00",
        "comment_author": "SvyatoslavScherbina",
        "comment_body": "This test doesn't actually check that the cast fails. It checks that *if it fails, then it fails with ClassCastException*. In other words, if the cast doesn't fail, the test will still pass.",
        "pr_file_module": null
      },
      {
        "comment_id": "1561088794",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5270,
        "pr_file": "native/native.tests/testData/codegen/cinterop/objc/kt65260.kt",
        "discussion_id": "1560651387",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+// TARGET_BACKEND: NATIVE\n+// DISABLE_NATIVE: isAppleTarget=false\n+\n+// MODULE: cinterop\n+// FILE: conversion.def\n+language = Objective-C\n+headers = conversion.h\n+headerFilter = conversion.h\n+\n+// FILE: conversion.h\n+#import <Foundation/Foundation.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+__attribute__((objc_runtime_name(\"Foo\")))\n+@interface A : NSObject\n+@end\n+\n+__attribute__((objc_runtime_name(\"Bar\")))\n+@interface B : A\n+@end\n+\n+NS_ASSUME_NONNULL_END\n+\n+// FILE: conversion.m\n+#import \"conversion.h\"\n+\n+@implementation A\n+@end\n+\n+@implementation B\n+@end\n+\n+// MODULE: lib(cinterop)\n+// FILE: lib.kt\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+import conversion.*\n+import platform.darwin.*\n+import kotlinx.cinterop.*\n+import kotlin.test.*\n+\n+class ANativeHeir : A() {\n+    companion object\n+}\n+\n+class BNativeHeir : B() {\n+    companion object\n+}\n+\n+fun testExternalObjCMetaClassCast() {\n+    try {\n+        BNativeHeir as A.Companion\n+    } catch (e: Exception) {\n+        assertTrue(e is ClassCastException)\n+    }",
        "comment_created_at": "2024-04-11T14:09:39+00:00",
        "comment_author": "edisongz",
        "comment_body": "Actually the cast will always fail, because `BNativeHeir` isn't equal to `A`,\r\n`try-catch` is for test infra runner execute normally.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1608507573",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5270,
        "pr_file": "native/native.tests/testData/codegen/cinterop/objc/kt65260.kt",
        "discussion_id": "1560651387",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+// TARGET_BACKEND: NATIVE\n+// DISABLE_NATIVE: isAppleTarget=false\n+\n+// MODULE: cinterop\n+// FILE: conversion.def\n+language = Objective-C\n+headers = conversion.h\n+headerFilter = conversion.h\n+\n+// FILE: conversion.h\n+#import <Foundation/Foundation.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+__attribute__((objc_runtime_name(\"Foo\")))\n+@interface A : NSObject\n+@end\n+\n+__attribute__((objc_runtime_name(\"Bar\")))\n+@interface B : A\n+@end\n+\n+NS_ASSUME_NONNULL_END\n+\n+// FILE: conversion.m\n+#import \"conversion.h\"\n+\n+@implementation A\n+@end\n+\n+@implementation B\n+@end\n+\n+// MODULE: lib(cinterop)\n+// FILE: lib.kt\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+import conversion.*\n+import platform.darwin.*\n+import kotlinx.cinterop.*\n+import kotlin.test.*\n+\n+class ANativeHeir : A() {\n+    companion object\n+}\n+\n+class BNativeHeir : B() {\n+    companion object\n+}\n+\n+fun testExternalObjCMetaClassCast() {\n+    try {\n+        BNativeHeir as A.Companion\n+    } catch (e: Exception) {\n+        assertTrue(e is ClassCastException)\n+    }",
        "comment_created_at": "2024-05-21T15:12:30+00:00",
        "comment_author": "SvyatoslavScherbina",
        "comment_body": "The purpose of a test is to anticipate and prevent bugs. If the test is inteded to check that the cast fails, then it does that wrong, see my first comment.\r\n\r\nIn other words, consider there is a bug (e.g. a regression) in the compiler, and the cast no longer fails. Well, the test won't report this then.\r\n\r\nPlease either use `assertFailsWith`, or check `BNativeHeir is A.Companion` instead. \r\n\r\nSame in many places below.",
        "pr_file_module": null
      },
      {
        "comment_id": "1608735483",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5270,
        "pr_file": "native/native.tests/testData/codegen/cinterop/objc/kt65260.kt",
        "discussion_id": "1560651387",
        "commented_code": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+// TARGET_BACKEND: NATIVE\n+// DISABLE_NATIVE: isAppleTarget=false\n+\n+// MODULE: cinterop\n+// FILE: conversion.def\n+language = Objective-C\n+headers = conversion.h\n+headerFilter = conversion.h\n+\n+// FILE: conversion.h\n+#import <Foundation/Foundation.h>\n+\n+NS_ASSUME_NONNULL_BEGIN\n+\n+__attribute__((objc_runtime_name(\"Foo\")))\n+@interface A : NSObject\n+@end\n+\n+__attribute__((objc_runtime_name(\"Bar\")))\n+@interface B : A\n+@end\n+\n+NS_ASSUME_NONNULL_END\n+\n+// FILE: conversion.m\n+#import \"conversion.h\"\n+\n+@implementation A\n+@end\n+\n+@implementation B\n+@end\n+\n+// MODULE: lib(cinterop)\n+// FILE: lib.kt\n+@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\n+import conversion.*\n+import platform.darwin.*\n+import kotlinx.cinterop.*\n+import kotlin.test.*\n+\n+class ANativeHeir : A() {\n+    companion object\n+}\n+\n+class BNativeHeir : B() {\n+    companion object\n+}\n+\n+fun testExternalObjCMetaClassCast() {\n+    try {\n+        BNativeHeir as A.Companion\n+    } catch (e: Exception) {\n+        assertTrue(e is ClassCastException)\n+    }",
        "comment_created_at": "2024-05-21T18:06:36+00:00",
        "comment_author": "edisongz",
        "comment_body": "Use `assertFailsWith` instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "964724921",
    "pr_number": 4933,
    "pr_file": "plugins/value-container-assignment/testData/diagnostics/incorrectUsageTest.kt",
    "created_at": "2022-09-07T11:25:20+00:00",
    "commented_code": "// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE, -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n// !RENDER_DIAGNOSTICS_FULL_TEXT\n\nannotation class ValueContainer\n\n@ValueContainer\ndata class StringProperty(var v: String) {\n    fun assign(v: String) {\n        this.v = v\n    }\n    fun assign(v: StringProperty) {\n        this.v = v.get()\n    }\n    fun get(): String = v\n}\n\ndata class Task(val input: StringProperty)\n\nfun test() {\n    run {\n        // Should report error if type doesn't match\n        val task = Task(StringProperty(\"Fail\"))\n        <!VAL_REASSIGNMENT!>task.input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n    }\n\n    run {\n        // Should report error if type doesn't match with apply\n        val task = Task(StringProperty(\"Fail\"))\n        task.apply {\n            <!VAL_REASSIGNMENT!>input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n        }\n    }\n\n    run {\n        // obj[i] = v should not be translated to obj.get(i).assign(v)\n        operator fun Task.get(i: Int) = this.input\n        val task = Task(StringProperty(\"Fail\"))\n        task<!NO_SET_METHOD!><!UNRESOLVED_REFERENCE!>[<!>0<!UNRESOLVED_REFERENCE!>]<!><!> = StringProperty(\"Fail\")",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "964724921",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4933,
        "pr_file": "plugins/value-container-assignment/testData/diagnostics/incorrectUsageTest.kt",
        "discussion_id": "964724921",
        "commented_code": "@@ -0,0 +1,41 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE, -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n+// !RENDER_DIAGNOSTICS_FULL_TEXT\n+\n+annotation class ValueContainer\n+\n+@ValueContainer\n+data class StringProperty(var v: String) {\n+    fun assign(v: String) {\n+        this.v = v\n+    }\n+    fun assign(v: StringProperty) {\n+        this.v = v.get()\n+    }\n+    fun get(): String = v\n+}\n+\n+data class Task(val input: StringProperty)\n+\n+fun test() {\n+    run {\n+        // Should report error if type doesn't match\n+        val task = Task(StringProperty(\"Fail\"))\n+        <!VAL_REASSIGNMENT!>task.input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n+    }\n+\n+    run {\n+        // Should report error if type doesn't match with apply\n+        val task = Task(StringProperty(\"Fail\"))\n+        task.apply {\n+            <!VAL_REASSIGNMENT!>input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n+        }\n+    }\n+\n+    run {\n+        // obj[i] = v should not be translated to obj.get(i).assign(v)\n+        operator fun Task.get(i: Int) = this.input\n+        val task = Task(StringProperty(\"Fail\"))\n+        task<!NO_SET_METHOD!><!UNRESOLVED_REFERENCE!>[<!>0<!UNRESOLVED_REFERENCE!>]<!><!> = StringProperty(\"Fail\")",
        "comment_created_at": "2022-09-07T11:25:20+00:00",
        "comment_author": "demiurg906",
        "comment_body": "Please also add tests for other operators with assignment\n- `a.b += c`\n- `a[b] += c`\n- `a?.b[c] = d`\n- `a?.b[c] += d`\n- etc",
        "pr_file_module": null
      },
      {
        "comment_id": "966271356",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4933,
        "pr_file": "plugins/value-container-assignment/testData/diagnostics/incorrectUsageTest.kt",
        "discussion_id": "964724921",
        "commented_code": "@@ -0,0 +1,41 @@\n+// !DIAGNOSTICS: -UNUSED_PARAMETER,-UNUSED_VARIABLE, -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE\n+// !RENDER_DIAGNOSTICS_FULL_TEXT\n+\n+annotation class ValueContainer\n+\n+@ValueContainer\n+data class StringProperty(var v: String) {\n+    fun assign(v: String) {\n+        this.v = v\n+    }\n+    fun assign(v: StringProperty) {\n+        this.v = v.get()\n+    }\n+    fun get(): String = v\n+}\n+\n+data class Task(val input: StringProperty)\n+\n+fun test() {\n+    run {\n+        // Should report error if type doesn't match\n+        val task = Task(StringProperty(\"Fail\"))\n+        <!VAL_REASSIGNMENT!>task.input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n+    }\n+\n+    run {\n+        // Should report error if type doesn't match with apply\n+        val task = Task(StringProperty(\"Fail\"))\n+        task.apply {\n+            <!VAL_REASSIGNMENT!>input<!> <!NO_APPLICABLE_ASSIGN_METHOD!>=<!> <!CONSTANT_EXPECTED_TYPE_MISMATCH!>42<!>\n+        }\n+    }\n+\n+    run {\n+        // obj[i] = v should not be translated to obj.get(i).assign(v)\n+        operator fun Task.get(i: Int) = this.input\n+        val task = Task(StringProperty(\"Fail\"))\n+        task<!NO_SET_METHOD!><!UNRESOLVED_REFERENCE!>[<!>0<!UNRESOLVED_REFERENCE!>]<!><!> = StringProperty(\"Fail\")",
        "comment_created_at": "2022-09-08T18:06:24+00:00",
        "comment_author": "asodja",
        "comment_body": "Added `otherOperators.kt`  tests for diagnostics and box tests. Let me know if I missed some cases.",
        "pr_file_module": null
      }
    ]
  }
]