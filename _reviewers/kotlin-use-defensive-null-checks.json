[
  {
    "discussion_id": "1717528372",
    "pr_number": 5311,
    "pr_file": "compiler/fir/raw-fir/light-tree2fir/src/org/jetbrains/kotlin/fir/lightTree/converter/LightTreeRawFirExpressionBuilder.kt",
    "created_at": "2024-08-14T20:43:41+00:00",
    "commented_code": "}\n        }\n\n        val result = firExpression ?: buildErrorExpression(null, ConeNotAnnotationContainer(\"???\"))\n        val result = firExpression ?: buildErrorExpression(annotatedExpression.toFirSourceElement(), ConeNotAnnotationContainer(\"???\"))",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1717528372",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5311,
        "pr_file": "compiler/fir/raw-fir/light-tree2fir/src/org/jetbrains/kotlin/fir/lightTree/converter/LightTreeRawFirExpressionBuilder.kt",
        "discussion_id": "1717528372",
        "commented_code": "@@ -498,7 +498,7 @@ class LightTreeRawFirExpressionBuilder(\n             }\n         }\n \n-        val result = firExpression ?: buildErrorExpression(null, ConeNotAnnotationContainer(\"???\"))\n+        val result = firExpression ?: buildErrorExpression(annotatedExpression.toFirSourceElement(), ConeNotAnnotationContainer(\"???\"))",
        "comment_created_at": "2024-08-14T20:43:41+00:00",
        "comment_author": "isuckatcs",
        "comment_body": "This must have a location, otherwise we get a crash in `FirContractChecker`.\r\n\r\n```kotlin\r\nobject FirContractChecker {\r\n    ...\r\n    private fun checkUnresolvedEffects(\r\n        ...\r\n    ) {\r\n        ...\r\n            reporter.reportOn(unresolvedEffect.source, ...)\r\n                                           // ^ source is asserted to be non-null inside reportOn()\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1721465179",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5311,
        "pr_file": "compiler/fir/raw-fir/light-tree2fir/src/org/jetbrains/kotlin/fir/lightTree/converter/LightTreeRawFirExpressionBuilder.kt",
        "discussion_id": "1717528372",
        "commented_code": "@@ -498,7 +498,7 @@ class LightTreeRawFirExpressionBuilder(\n             }\n         }\n \n-        val result = firExpression ?: buildErrorExpression(null, ConeNotAnnotationContainer(\"???\"))\n+        val result = firExpression ?: buildErrorExpression(annotatedExpression.toFirSourceElement(), ConeNotAnnotationContainer(\"???\"))",
        "comment_created_at": "2024-08-19T09:13:38+00:00",
        "comment_author": "demiurg906",
        "comment_body": "Yep, this is a correct fix. Could you please check that the corresponding place in `PsiRawFirBuilder` also correctly sets the source? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1721651171",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5311,
        "pr_file": "compiler/fir/raw-fir/light-tree2fir/src/org/jetbrains/kotlin/fir/lightTree/converter/LightTreeRawFirExpressionBuilder.kt",
        "discussion_id": "1717528372",
        "commented_code": "@@ -498,7 +498,7 @@ class LightTreeRawFirExpressionBuilder(\n             }\n         }\n \n-        val result = firExpression ?: buildErrorExpression(null, ConeNotAnnotationContainer(\"???\"))\n+        val result = firExpression ?: buildErrorExpression(annotatedExpression.toFirSourceElement(), ConeNotAnnotationContainer(\"???\"))",
        "comment_created_at": "2024-08-19T11:34:50+00:00",
        "comment_author": "isuckatcs",
        "comment_body": "Yes, it sets it. In fact I checked that first and that was my leading clue that this one should be set too.\r\n\r\n```kotlin\r\nval result = rawResult as? FirAnnotationContainer\r\n    ?: buildErrorExpression(\r\n        expression.toFirSourceElement(),\r\n        ConeNotAnnotationContainer(rawResult?.render() ?: \"???\")\r\n    )\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1327002233",
    "pr_number": 5184,
    "pr_file": "plugins/parcelize/parcelize-compiler/parcelize.backend/src/org/jetbrains/kotlin/parcelize/AndroidSymbols.kt",
    "created_at": "2023-09-15T08:50:43+00:00",
    "commented_code": "isStatic = true\n    }.symbol\n\n    private val kotlinxCollectionsImmutable = FqName(kotlinxImmutable())\n    private val kotlinCollections = FqName(\"kotlin.collections\")\n    private val kotlinIterable: FqName = kotlinCollections.child(Name.identifier(\"Iterable\"))\n    private val kotlinMap: FqName = kotlinCollections.child(Name.identifier(\"Map\"))\n\n    private fun findKotlinxImmutableCollectionExtensionFunction(\n        receiver: FqName,\n        functionName: String,\n    ): IrSimpleFunctionSymbol {\n        val functionSymbol =\n            pluginContext\n                .referenceFunctions(CallableId(kotlinxCollectionsImmutable, Name.identifier(functionName)))\n                .firstOrNull { it.owner.extensionReceiverParameter!!.type.classFqName == receiver }",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "1327002233",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5184,
        "pr_file": "plugins/parcelize/parcelize-compiler/parcelize.backend/src/org/jetbrains/kotlin/parcelize/AndroidSymbols.kt",
        "discussion_id": "1327002233",
        "commented_code": "@@ -499,6 +502,39 @@ class AndroidSymbols(\n         isStatic = true\n     }.symbol\n \n+    private val kotlinxCollectionsImmutable = FqName(kotlinxImmutable())\n+    private val kotlinCollections = FqName(\"kotlin.collections\")\n+    private val kotlinIterable: FqName = kotlinCollections.child(Name.identifier(\"Iterable\"))\n+    private val kotlinMap: FqName = kotlinCollections.child(Name.identifier(\"Map\"))\n+\n+    private fun findKotlinxImmutableCollectionExtensionFunction(\n+        receiver: FqName,\n+        functionName: String,\n+    ): IrSimpleFunctionSymbol {\n+        val functionSymbol =\n+            pluginContext\n+                .referenceFunctions(CallableId(kotlinxCollectionsImmutable, Name.identifier(functionName)))\n+                .firstOrNull { it.owner.extensionReceiverParameter!!.type.classFqName == receiver }",
        "comment_created_at": "2023-09-15T08:50:43+00:00",
        "comment_author": "madsager",
        "comment_body": "Just to be safe, maybe it would be better to use null safe operations:\r\n\r\n`it.owner.extensionReceiverParameter?.type?.classFqName == receiver`\r\n\r\nThat way, if users put their own code with these package and function names (but where the function is not an extension function) on the classpath they will get the error message below instead of a null pointer exception.",
        "pr_file_module": null
      },
      {
        "comment_id": "1327143301",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 5184,
        "pr_file": "plugins/parcelize/parcelize-compiler/parcelize.backend/src/org/jetbrains/kotlin/parcelize/AndroidSymbols.kt",
        "discussion_id": "1327002233",
        "commented_code": "@@ -499,6 +502,39 @@ class AndroidSymbols(\n         isStatic = true\n     }.symbol\n \n+    private val kotlinxCollectionsImmutable = FqName(kotlinxImmutable())\n+    private val kotlinCollections = FqName(\"kotlin.collections\")\n+    private val kotlinIterable: FqName = kotlinCollections.child(Name.identifier(\"Iterable\"))\n+    private val kotlinMap: FqName = kotlinCollections.child(Name.identifier(\"Map\"))\n+\n+    private fun findKotlinxImmutableCollectionExtensionFunction(\n+        receiver: FqName,\n+        functionName: String,\n+    ): IrSimpleFunctionSymbol {\n+        val functionSymbol =\n+            pluginContext\n+                .referenceFunctions(CallableId(kotlinxCollectionsImmutable, Name.identifier(functionName)))\n+                .firstOrNull { it.owner.extensionReceiverParameter!!.type.classFqName == receiver }",
        "comment_created_at": "2023-09-15T11:08:09+00:00",
        "comment_author": "IlyaGulya",
        "comment_body": "Yeah, sure, I've just forgot about this one, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "713622898",
    "pr_number": 4581,
    "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformer.kt",
    "created_at": "2021-09-22T06:18:07+00:00",
    "commented_code": "/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.jetbrains.kotlinx.atomicfu.compiler.extensions\n\nimport org.jetbrains.kotlin.backend.common.deepCopyWithVariables\nimport org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\nimport org.jetbrains.kotlin.descriptors.DescriptorVisibilities\nimport org.jetbrains.kotlin.ir.*\nimport org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\nimport org.jetbrains.kotlin.ir.expressions.impl.*\nimport org.jetbrains.kotlin.ir.declarations.*\nimport org.jetbrains.kotlin.ir.expressions.*\nimport org.jetbrains.kotlin.ir.symbols.*\nimport org.jetbrains.kotlin.ir.types.*\nimport org.jetbrains.kotlin.ir.util.*\nimport org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\nimport org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid\nimport org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid\nimport org.jetbrains.kotlin.name.*\n\nprivate const val KOTLIN = \"kotlin\"\nprivate const val AFU_PKG = \"kotlinx/atomicfu\"\nprivate const val LOCKS = \"locks\"\nprivate const val ATOMIC_CONSTRUCTOR = \"atomic\"\nprivate const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\nprivate const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\nprivate const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\nprivate const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\nprivate const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\nprivate const val GETTER = \"atomicfu\\$getter\"\nprivate const val SETTER = \"atomicfu\\$setter\"\nprivate const val GET = \"get\"\nprivate const val SET = \"set\"\nprivate const val ATOMICFU_INLINE_FUNCTION = \"\"\"atomicfu_(loop|update|getAndUpdate|updateAndGet)\"\"\"\n\nprivate fun String.prettyStr() = replace('/', '.')\n\nclass AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n\n    private val irBuiltIns = context.irBuiltIns\n\n    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n        \"AtomicInt\" to irBuiltIns.intType,\n        \"AtomicLong\" to irBuiltIns.longType,\n        \"AtomicRef\" to irBuiltIns.anyType,\n        \"AtomicBoolean\" to irBuiltIns.booleanType\n    )\n\n    private val AFU_ARRAY_CLASSES: Map<String, String> = mapOf(\n        \"AtomicIntArray\" to \"IntArray\",\n        \"AtomicLongArray\" to \"LongArray\",\n        \"AtomicBooleanArray\" to \"BooleanArray\",\n        \"AtomicArray\" to \"Array\"\n    )\n\n    override fun visitFile(declaration: IrFile): IrFile {\n        val transformedDeclarations = mutableListOf<IrDeclaration>()\n        declaration.declarations.forEach { irDeclaration ->\n            irDeclaration.transformInlineAtomicExtension()?.let { transformedDeclarations.add(it) }\n        }\n        declaration.declarations.addAll(transformedDeclarations)\n        return super.visitFile(declaration)\n    }\n\n    override fun visitClass(declaration: IrClass): IrStatement {\n        val transformedDeclarations = mutableListOf<IrDeclaration>()\n        declaration.declarations.forEach { irDeclaration ->\n            irDeclaration.transformInlineAtomicExtension()?.let { transformedDeclarations.add(it) }\n        }\n        declaration.declarations.addAll(transformedDeclarations)\n        return super.visitClass(declaration)\n    }\n\n    override fun visitProperty(declaration: IrProperty): IrStatement {\n        if (declaration.backingField != null) {\n            val backingField = declaration.backingField!!\n            if (backingField.initializer != null) {\n                val initializer = backingField.initializer!!.expression.eraseAtomicConstructor(backingField)\n                declaration.backingField!!.initializer = context.irFactory.createExpressionBody(initializer)\n            }\n        }\n        return super.visitProperty(declaration)\n    }\n\n    override fun visitFunction(declaration: IrFunction): IrStatement {\n        transformDeclarationBody(declaration.body, declaration)\n        return super.visitFunction(declaration)\n    }\n\n    override fun visitAnonymousInitializer(declaration: IrAnonymousInitializer): IrStatement {\n        transformDeclarationBody(declaration.body, declaration)\n        return super.visitAnonymousInitializer(declaration)\n    }\n\n    private fun transformDeclarationBody(body: IrBody?, parent: IrDeclaration, lambda: IrFunction? = null) {\n        if (body is IrBlockBody) {\n            body.statements.forEachIndexed { i, stmt ->\n                val transformedStmt = stmt.transformStatement(parent, lambda)\n                body.statements[i] = transformedStmt\n            }\n        }\n    }\n\n    private fun IrExpression.eraseAtomicConstructor(parentDeclaration: IrDeclaration, lambda: IrFunction? = null) =\n        when {\n            type.isAtomicValueType() -> getPureTypeValue().transformAtomicFunctionCall(parentDeclaration, lambda)\n            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n            type.isReentrantLockType() -> buildConstNull()\n            else -> this\n        }\n\n    private fun IrDeclaration.transformInlineAtomicExtension(): IrDeclaration? {\n        // transform the signature of the inline Atomic* extension declaration\n        // inline fun AtomicRef<T>.foo(args) { ... } -> inline fun foo(args, getter: () -> T, setter: (T) -> Unit)\n        if (this is IrFunction &&\n            isInline &&\n            extensionReceiverParameter != null &&\n            extensionReceiverParameter!!.type.isAtomicValueType()\n        ) {\n            val newDeclaration = this.deepCopyWithSymbols(parent)\n            val oldValueParameters = valueParameters.map { it.deepCopyWithSymbols(newDeclaration) }\n            val valueParametersCount = valueParameters.size\n            val receiverValueType = extensionReceiverParameter!!.type.atomicToValueType() // T\n            val getterType = buildGetterType(receiverValueType)\n            val setterType = buildSetterType(receiverValueType)\n            newDeclaration.valueParameters = oldValueParameters + listOf(\n                buildValueParameter(newDeclaration, GETTER, valueParametersCount, getterType),\n                buildValueParameter(newDeclaration, SETTER, valueParametersCount + 1, setterType)\n            )\n            newDeclaration.extensionReceiverParameter = null\n            return newDeclaration\n        }\n        return null\n    }\n\n    private fun IrExpression.getPureTypeValue(): IrExpression {\n        require(this is IrCall && isAtomicFactory()) { \"Illegal initializer for the atomic property $this\" }\n        return getValueArgument(0)!!\n    }\n\n    private fun IrExpression.buildPureTypeArrayConstructor() =\n        when (this) {\n            is IrConstructorCall -> {\n                require(isAtomicArrayConstructor()) { \"Unsupported atomic array constructor $this\" }\n                val arrayConstructorSymbol = type.getArrayConstructorSymbol { it.owner.valueParameters.size == 1 }\n                val size = getValueArgument(0)\n                IrConstructorCallImpl(\n                    UNDEFINED_OFFSET, UNDEFINED_OFFSET,\n                    irBuiltIns.unitType, arrayConstructorSymbol,\n                    0, 0, 1\n                ).apply {\n                    putValueArgument(0, size)\n                }\n            }\n            is IrCall -> {\n                require(isAtomicArrayFactory()) { \"Unsupported atomic array factory function $this\" }\n                val arrayFactorySymbol = referencePackageFunction(\"kotlin\", \"arrayOfNulls\")\n                val arrayElementType = getTypeArgument(0)!!\n                val size = getValueArgument(0)\n                buildCall(\n                    target = arrayFactorySymbol,\n                    type = type,\n                    typeArguments = listOf(arrayElementType),\n                    valueArguments = listOf(size)\n                )\n            }\n            else -> error(\"Illegal type of atomic array initializer\")\n        }\n\n    private fun IrCall.inlineAtomicFunction(atomicType: IrType, accessors: List<IrExpression>): IrCall {\n        val valueArguments = getValueArguments()\n        val functionName = getAtomicFunctionName()\n        val runtimeFunction = getRuntimeFunctionSymbol(functionName, atomicType)\n        return buildCall(\n            target = runtimeFunction,\n            type = type,\n            origin = IrStatementOrigin.INVOKE,\n            typeArguments = if (runtimeFunction.owner.typeParameters.size == 1) listOf(atomicType) else emptyList(),\n            valueArguments = valueArguments + accessors\n        )\n    }\n\n    private fun IrStatement.transformStatement(parentDeclaration: IrDeclaration, lambda: IrFunction? = null) =\n        when (this) {\n            is IrExpression -> transformAtomicFunctionCall(parentDeclaration, lambda)\n            is IrVariable -> {\n                apply { initializer = initializer?.transformAtomicFunctionCall(parentDeclaration, lambda) }\n            }\n            else -> this\n        }\n\n    private fun IrExpression.transformAtomicFunctionCall(parentDeclaration: IrDeclaration, lambda: IrFunction? = null): IrExpression {\n        // erase unchecked cast to the Atomic* type\n        if (this is IrTypeOperatorCall && operator == IrTypeOperator.CAST && typeOperand.isAtomicValueType()) {\n            return argument\n        }\n        if (isAtomicValueInitializer()) {\n            return eraseAtomicConstructor(parentDeclaration, lambda)\n        }\n        when (this) {\n            is IrTypeOperatorCall -> {\n                return apply { argument = argument.transformAtomicFunctionCall(parentDeclaration, lambda) }\n            }\n            is IrStringConcatenationImpl -> {\n                return apply {\n                    arguments.forEachIndexed { i, arg ->\n                        arguments[i] = arg.transformAtomicFunctionCall(parentDeclaration, lambda)\n                    }\n                }\n            }\n            is IrReturn -> {\n                if (parentDeclaration.isTransformedAtomicExtensionFunction() && (parentDeclaration as IrFunction).isInline &&\n                    returnTargetSymbol !== parentDeclaration.symbol) {\n                    return IrReturnImpl(\n                        startOffset,\n                        endOffset,\n                        type,\n                        parentDeclaration.symbol,\n                        value.transformAtomicFunctionCall(parentDeclaration, lambda)\n                    )\n                }\n                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n            }\n            is IrSetValue -> {\n                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n            }\n            is IrSetField -> {\n                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n            }\n            is IrIfThenElseImpl -> {\n                return apply {\n                    branches.forEachIndexed { i, branch ->\n                        branches[i] = branch.apply {\n                            condition = condition.transformAtomicFunctionCall(parentDeclaration, lambda)\n                            result = result.transformAtomicFunctionCall(parentDeclaration, lambda)\n                        }\n                    }\n                }\n            }\n            is IrWhenImpl -> {\n                return apply {\n                    branches.forEachIndexed { i, branch ->\n                        branches[i] = branch.apply {\n                            condition = condition.transformAtomicFunctionCall(parentDeclaration, lambda)\n                            result = result.transformAtomicFunctionCall(parentDeclaration, lambda)\n                        }\n                    }\n                }\n            }\n            is IrTry -> {\n                return apply {\n                    tryResult = tryResult.transformAtomicFunctionCall(parentDeclaration, lambda)\n                    catches.forEach {\n                        it.result = it.result.transformAtomicFunctionCall(parentDeclaration, lambda)\n                    }\n                    finallyExpression = finallyExpression?.transformAtomicFunctionCall(parentDeclaration, lambda)\n                }\n            }\n            is IrBlock -> {\n                return apply {\n                    statements.forEachIndexed { i, stmt ->\n                        statements[i] = stmt.transformStatement(parentDeclaration, lambda)\n                    }\n                }\n            }\n            is IrGetValue -> {\n                if (lambda != null && symbol.owner.parent == lambda) return this\n                if (symbol is IrValueParameterSymbol && parentDeclaration.isTransformedAtomicExtensionFunction()) {\n                    // replace use site of the value parameter with it's copy from the transformed declaration\n                    val index = (symbol.owner as IrValueParameter).index\n                    if (index >= 0) { // index == -1 for `this` parameter\n                        val transformedValueParameter = (parentDeclaration as IrFunction).valueParameters[index]\n                        return buildGetValue(transformedValueParameter.symbol)\n                    }\n                }\n            }\n            is IrCall -> {\n                dispatchReceiver?.let { dispatchReceiver = it.transformAtomicFunctionCall(parentDeclaration, lambda) }\n                extensionReceiver?.let { extensionReceiver = it.transformAtomicFunctionCall(parentDeclaration, lambda) }\n                getValueArguments().forEachIndexed { i, arg ->\n                    putValueArgument(i, arg?.transformAtomicFunctionCall(parentDeclaration, lambda))\n                }\n                val isInline = symbol.owner.isInline\n                val receiver = extensionReceiver ?: dispatchReceiver ?: return this\n                // Invocation of atomic functions on atomic receivers\n                // are substituted with the corresponding inline declarations from `kotlinx-atomicfu-runtime`\n                if (symbol.isKotlinxAtomicfuPackage() && receiver.type.isAtomicValueType()) {\n                    // 1. Receiver is the atomic field:\n                    // a.incrementAndGet() -> atomicfu_incrementAndGet(get_a {..}, set_a {..})\n                    if (receiver is IrCall) { // property accessor <get-field>\n                        val accessors = receiver.getAccessors(lambda ?: parentDeclaration)\n                        return inlineAtomicFunction(receiver.type.atomicToValueType(), accessors).apply {\n                            transformAtomicfuLoopBody(parentDeclaration)\n                        }\n                    }\n                    // 2. Atomic extension receiver `this`, the reciver of the parent function.\n                    // Parent function is the inline Atomic* extension function already transformed with `transformAtomicInlineDeclaration`\n                    // inline fun foo(getter: () -> T, setter: (T) -> Unit) { incrementAndGet() } ->\n                    // inline fun foo(getter: () -> T, setter: (T) -> Unit) { atomicfu_incrementAndGet(getter, setter) }\n                    if (receiver is IrGetValue && parentDeclaration.isTransformedAtomicExtensionFunction()) {\n                        val accessorParameters = (parentDeclaration as IrFunction).valueParameters.takeLast(2).map { it.capture() }\n                        return inlineAtomicFunction(receiver.type.atomicToValueType(), accessorParameters).apply {\n                            transformAtomicfuLoopBody(parentDeclaration)\n                        }\n                    }\n                } else {\n                    // 3. transform invocation of an inline Atomic* extension function call: a.foo()\n                    if (isInline && receiver is IrCall && receiver.type.isAtomicValueType()) {\n                        val accessors = receiver.getAccessors(lambda ?: parentDeclaration)\n                        val dispatch = dispatchReceiver\n                        val args = getValueArguments()\n                        val transformedTarget = symbol.owner.getDeclarationWithAccessorParameters()\n                        return buildCall(\n                            target = transformedTarget.symbol,\n                            type = type,\n                            origin = IrStatementOrigin.INVOKE,\n                            valueArguments = args + accessors\n                        ).apply {\n                            dispatchReceiver = dispatch\n                        }\n                    }\n                }\n            }\n            is IrConstructorCall -> {\n                getValueArguments().forEachIndexed { i, arg ->\n                    putValueArgument(i, arg?.transformAtomicFunctionCall(parentDeclaration, lambda))\n                }\n            }\n        }\n        return this\n    }\n\n    private fun IrCall.transformAtomicfuLoopBody(parent: IrDeclaration) {\n        if (symbol.owner.name.asString().matches(ATOMICFU_INLINE_FUNCTION.toRegex())) {\n            val lambdaLoop = (getValueArgument(0) as IrFunctionExpression).function\n            transformDeclarationBody(lambdaLoop.body, parent, lambdaLoop)\n        }\n    }\n\n    private fun IrFunction.hasReceiverAccessorParameters(): Boolean {\n        if (valueParameters.size < 2) return false\n        val params = valueParameters.takeLast(2)\n        return params[0].name.asString() == GETTER && params[1].name.asString() == SETTER\n    }\n\n    private fun IrDeclaration.isTransformedAtomicExtensionFunction(): Boolean =\n        this is IrFunction && this.hasReceiverAccessorParameters()\n\n    private fun IrFunction.getDeclarationWithAccessorParameters(): IrSimpleFunction {\n        val parent = parent as IrDeclarationContainer\n        val params = valueParameters.map { it.type }\n        val extensionType = extensionReceiverParameter?.type?.atomicToValueType()\n        return try {\n            parent.declarations.single {\n                it is IrSimpleFunction &&\n                it.name == symbol.owner.name &&\n                it.valueParameters.size == params.size + 2 &&\n                it.valueParameters.dropLast(2).withIndex().all { p -> p.value.type.classifierOrNull?.owner == params[p.index].classifierOrNull?.owner } &&\n                it.getGetterReturnType()?.classifierOrNull?.owner == extensionType?.classifierOrNull?.owner\n            } as IrSimpleFunction\n        } catch (e: RuntimeException) {\n            error(\"Exception while looking for the declaration with accessor parameters: ${e.message}\")\n        }\n    }\n\n    private fun IrExpression.isAtomicValueInitializer() =\n        (this is IrCall && (this.isAtomicFactory() || this.isAtomicArrayFactory())) ||\n                (this is IrConstructorCall && this.isAtomicArrayConstructor()) ||\n                type.isReentrantLockType()\n\n    private fun IrCall.isArrayElementGetter() =\n        dispatchReceiver != null &&\n                dispatchReceiver!!.type.isAtomicArrayType() &&\n                symbol.owner.name.asString() == GET\n\n    private fun IrCall.getBackingField(): IrField {\n        val correspondingPropertySymbol = symbol.owner.correspondingPropertySymbol!!\n        return correspondingPropertySymbol.owner.backingField!!\n    }\n\n    private fun IrCall.buildAccessorLambda(\n        isSetter: Boolean,\n        parentDeclaration: IrDeclaration\n    ): IrFunctionExpression {\n        val isArrayElement = isArrayElementGetter()\n        val getterCall = if (isArrayElement) dispatchReceiver as IrCall else this\n        val valueType = type.atomicToValueType()\n        val type = if (isSetter) buildSetterType(valueType) else buildGetterType(valueType)\n        val name = if (isSetter) setterName(getterCall.symbol.owner.name.getFieldName())\n            else getterName(getterCall.symbol.owner.name.getFieldName())\n        val returnType = if (isSetter) context.irBuiltIns.unitType else valueType\n        val accessorFunction = buildFunction(\n            parent = parentDeclaration as IrDeclarationParent,\n            origin = IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR,\n            name = Name.identifier(name),\n            visibility = DescriptorVisibilities.LOCAL,\n            isInline = true,\n            returnType = returnType\n        ).apply {\n            val valueParameter = buildValueParameter(this, name, 0, valueType)\n            this.valueParameters = if (isSetter) listOf(valueParameter) else emptyList()\n            val body = if (isSetter) {\n                if (isArrayElement) {\n                    val setSymbol = referenceFunction(getterCall.type.referenceClass(), SET)\n                    val elementIndex = getValueArgument(0)!!.deepCopyWithVariables()\n                    buildCall(\n                        target = setSymbol,\n                        type = context.irBuiltIns.unitType,\n                        origin = IrStatementOrigin.LAMBDA,\n                        valueArguments = listOf(elementIndex, valueParameter.capture())\n                    ).apply {\n                        dispatchReceiver = getterCall\n                    }\n                } else {\n                    buildSetField(getterCall.getBackingField(), getterCall.dispatchReceiver, valueParameter.capture())\n                }\n            } else {\n                val getField = buildGetField(getterCall.getBackingField(), getterCall.dispatchReceiver)\n                if (isArrayElement) {\n                    val getSymbol = referenceFunction(getterCall.type.referenceClass(), GET)\n                    val elementIndex = getValueArgument(0)!!.deepCopyWithVariables()\n                    buildCall(\n                        target = getSymbol,\n                        type = valueType,\n                        origin = IrStatementOrigin.LAMBDA,\n                        valueArguments = listOf(elementIndex)\n                    ).apply {\n                        dispatchReceiver = getField.deepCopyWithVariables()\n                    }\n                } else {\n                    getField.deepCopyWithVariables()\n                }\n            }\n            this.body = buildBlockBody(listOf(body))\n            origin = IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR\n        }\n        return IrFunctionExpressionImpl(\n            UNDEFINED_OFFSET, UNDEFINED_OFFSET,\n            type,\n            accessorFunction,\n            IrStatementOrigin.LAMBDA\n        )\n    }\n\n    private fun buildSetField(backingField: IrField, ownerClass: IrExpression?, value: IrGetValue): IrSetField {\n        val receiver = if (ownerClass is IrTypeOperatorCall) ownerClass.argument as IrGetValue else ownerClass\n        val fieldSymbol = backingField.symbol\n        return buildSetField(\n            symbol = fieldSymbol,\n            receiver = receiver,\n            value = value\n        )\n    }\n\n    private fun buildGetField(backingField: IrField, ownerClass: IrExpression?): IrGetField {\n        val receiver = if (ownerClass is IrTypeOperatorCall) ownerClass.argument as IrGetValue else ownerClass\n        return buildGetField(\n            symbol = backingField.symbol,\n            receiver = receiver\n        )\n    }\n\n    private fun IrCall.getAccessors(parentDeclaration: IrDeclaration): List<IrExpression> =\n        listOf(buildAccessorLambda(isSetter = false, parentDeclaration = parentDeclaration),\n               buildAccessorLambda(isSetter = true, parentDeclaration = parentDeclaration))\n\n    private fun getRuntimeFunctionSymbol(name: String, type: IrType): IrSimpleFunctionSymbol {\n        val functionName = when (name) {\n            \"value.<get-value>\" -> \"getValue\"\n            \"value.<set-value>\" -> \"setValue\"\n            else -> name\n        }\n        return referencePackageFunction(\"kotlinx.atomicfu\", \"$ATOMICFU_RUNTIME_FUNCTION_PREDICATE$functionName\") {\n            val typeArg = it.owner.getGetterReturnType()\n            !(typeArg as IrType).isPrimitiveType() || typeArg == type\n        }\n    }\n\n    private fun IrFunction.getGetterReturnType() = (valueParameters[valueParameters.lastIndex - 1].type as IrSimpleType).arguments.first().typeOrNull\n\n    private fun IrCall.isAtomicFactory(): Boolean {\n        val name = symbol.owner.name\n        return !name.isSpecial && name.identifier == ATOMIC_CONSTRUCTOR\n    }\n\n    private fun IrCall.isAtomicArrayFactory(): Boolean {\n        val name = symbol.owner.name\n        return !name.isSpecial && name.identifier == ATOMIC_ARRAY_FACTORY_FUNCTION\n    }\n\n    private fun IrConstructorCall.isAtomicArrayConstructor() = (type as IrSimpleType).isAtomicArrayType()\n\n    private fun IrSymbol.isKotlinxAtomicfuPackage() =\n        this.isPublicApi && signature?.packageFqName()?.asString() == AFU_PKG.prettyStr()\n\n    private fun IrType.isAtomicValueType() = belongsTo(ATOMICFU_VALUE_TYPE)\n    private fun IrType.isAtomicArrayType() = belongsTo(ATOMIC_ARRAY_TYPE)\n    private fun IrType.isReentrantLockType() = belongsTo(\"$AFU_PKG/$LOCKS\", REENTRANT_LOCK_TYPE)\n\n    private fun IrType.belongsTo(typeName: String) = belongsTo(AFU_PKG, typeName)\n\n    private fun IrType.belongsTo(packageName: String, typeName: String): Boolean {",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "713622898",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4581,
        "pr_file": "plugins/atomicfu/atomicfu-compiler/src/org.jetbrains.kotlinx.atomicfu.compiler/extensions/AtomicFUTransformer.kt",
        "discussion_id": "713622898",
        "commented_code": "@@ -0,0 +1,595 @@\n+/*\n+ * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n+ */\n+\n+package org.jetbrains.kotlinx.atomicfu.compiler.extensions\n+\n+import org.jetbrains.kotlin.backend.common.deepCopyWithVariables\n+import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext\n+import org.jetbrains.kotlin.descriptors.DescriptorVisibilities\n+import org.jetbrains.kotlin.ir.*\n+import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder.buildValueParameter\n+import org.jetbrains.kotlin.ir.expressions.impl.*\n+import org.jetbrains.kotlin.ir.declarations.*\n+import org.jetbrains.kotlin.ir.expressions.*\n+import org.jetbrains.kotlin.ir.symbols.*\n+import org.jetbrains.kotlin.ir.types.*\n+import org.jetbrains.kotlin.ir.util.*\n+import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid\n+import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid\n+import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid\n+import org.jetbrains.kotlin.name.*\n+\n+private const val KOTLIN = \"kotlin\"\n+private const val AFU_PKG = \"kotlinx/atomicfu\"\n+private const val LOCKS = \"locks\"\n+private const val ATOMIC_CONSTRUCTOR = \"atomic\"\n+private const val ATOMICFU_VALUE_TYPE = \"\"\"Atomic(Int|Long|Boolean|Ref)\"\"\"\n+private const val ATOMIC_ARRAY_TYPE = \"\"\"Atomic(Int|Long|Boolean|)Array\"\"\"\n+private const val ATOMIC_ARRAY_FACTORY_FUNCTION = \"atomicArrayOfNulls\"\n+private const val ATOMICFU_RUNTIME_FUNCTION_PREDICATE = \"atomicfu_\"\n+private const val REENTRANT_LOCK_TYPE = \"ReentrantLock\"\n+private const val GETTER = \"atomicfu\\$getter\"\n+private const val SETTER = \"atomicfu\\$setter\"\n+private const val GET = \"get\"\n+private const val SET = \"set\"\n+private const val ATOMICFU_INLINE_FUNCTION = \"\"\"atomicfu_(loop|update|getAndUpdate|updateAndGet)\"\"\"\n+\n+private fun String.prettyStr() = replace('/', '.')\n+\n+class AtomicFUTransformer(override val context: IrPluginContext) : IrElementTransformerVoid(), TransformerHelpers {\n+\n+    private val irBuiltIns = context.irBuiltIns\n+\n+    private val AFU_CLASSES: Map<String, IrType> = mapOf(\n+        \"AtomicInt\" to irBuiltIns.intType,\n+        \"AtomicLong\" to irBuiltIns.longType,\n+        \"AtomicRef\" to irBuiltIns.anyType,\n+        \"AtomicBoolean\" to irBuiltIns.booleanType\n+    )\n+\n+    private val AFU_ARRAY_CLASSES: Map<String, String> = mapOf(\n+        \"AtomicIntArray\" to \"IntArray\",\n+        \"AtomicLongArray\" to \"LongArray\",\n+        \"AtomicBooleanArray\" to \"BooleanArray\",\n+        \"AtomicArray\" to \"Array\"\n+    )\n+\n+    override fun visitFile(declaration: IrFile): IrFile {\n+        val transformedDeclarations = mutableListOf<IrDeclaration>()\n+        declaration.declarations.forEach { irDeclaration ->\n+            irDeclaration.transformInlineAtomicExtension()?.let { transformedDeclarations.add(it) }\n+        }\n+        declaration.declarations.addAll(transformedDeclarations)\n+        return super.visitFile(declaration)\n+    }\n+\n+    override fun visitClass(declaration: IrClass): IrStatement {\n+        val transformedDeclarations = mutableListOf<IrDeclaration>()\n+        declaration.declarations.forEach { irDeclaration ->\n+            irDeclaration.transformInlineAtomicExtension()?.let { transformedDeclarations.add(it) }\n+        }\n+        declaration.declarations.addAll(transformedDeclarations)\n+        return super.visitClass(declaration)\n+    }\n+\n+    override fun visitProperty(declaration: IrProperty): IrStatement {\n+        if (declaration.backingField != null) {\n+            val backingField = declaration.backingField!!\n+            if (backingField.initializer != null) {\n+                val initializer = backingField.initializer!!.expression.eraseAtomicConstructor(backingField)\n+                declaration.backingField!!.initializer = context.irFactory.createExpressionBody(initializer)\n+            }\n+        }\n+        return super.visitProperty(declaration)\n+    }\n+\n+    override fun visitFunction(declaration: IrFunction): IrStatement {\n+        transformDeclarationBody(declaration.body, declaration)\n+        return super.visitFunction(declaration)\n+    }\n+\n+    override fun visitAnonymousInitializer(declaration: IrAnonymousInitializer): IrStatement {\n+        transformDeclarationBody(declaration.body, declaration)\n+        return super.visitAnonymousInitializer(declaration)\n+    }\n+\n+    private fun transformDeclarationBody(body: IrBody?, parent: IrDeclaration, lambda: IrFunction? = null) {\n+        if (body is IrBlockBody) {\n+            body.statements.forEachIndexed { i, stmt ->\n+                val transformedStmt = stmt.transformStatement(parent, lambda)\n+                body.statements[i] = transformedStmt\n+            }\n+        }\n+    }\n+\n+    private fun IrExpression.eraseAtomicConstructor(parentDeclaration: IrDeclaration, lambda: IrFunction? = null) =\n+        when {\n+            type.isAtomicValueType() -> getPureTypeValue().transformAtomicFunctionCall(parentDeclaration, lambda)\n+            type.isAtomicArrayType() -> buildPureTypeArrayConstructor()\n+            type.isReentrantLockType() -> buildConstNull()\n+            else -> this\n+        }\n+\n+    private fun IrDeclaration.transformInlineAtomicExtension(): IrDeclaration? {\n+        // transform the signature of the inline Atomic* extension declaration\n+        // inline fun AtomicRef<T>.foo(args) { ... } -> inline fun foo(args, getter: () -> T, setter: (T) -> Unit)\n+        if (this is IrFunction &&\n+            isInline &&\n+            extensionReceiverParameter != null &&\n+            extensionReceiverParameter!!.type.isAtomicValueType()\n+        ) {\n+            val newDeclaration = this.deepCopyWithSymbols(parent)\n+            val oldValueParameters = valueParameters.map { it.deepCopyWithSymbols(newDeclaration) }\n+            val valueParametersCount = valueParameters.size\n+            val receiverValueType = extensionReceiverParameter!!.type.atomicToValueType() // T\n+            val getterType = buildGetterType(receiverValueType)\n+            val setterType = buildSetterType(receiverValueType)\n+            newDeclaration.valueParameters = oldValueParameters + listOf(\n+                buildValueParameter(newDeclaration, GETTER, valueParametersCount, getterType),\n+                buildValueParameter(newDeclaration, SETTER, valueParametersCount + 1, setterType)\n+            )\n+            newDeclaration.extensionReceiverParameter = null\n+            return newDeclaration\n+        }\n+        return null\n+    }\n+\n+    private fun IrExpression.getPureTypeValue(): IrExpression {\n+        require(this is IrCall && isAtomicFactory()) { \"Illegal initializer for the atomic property $this\" }\n+        return getValueArgument(0)!!\n+    }\n+\n+    private fun IrExpression.buildPureTypeArrayConstructor() =\n+        when (this) {\n+            is IrConstructorCall -> {\n+                require(isAtomicArrayConstructor()) { \"Unsupported atomic array constructor $this\" }\n+                val arrayConstructorSymbol = type.getArrayConstructorSymbol { it.owner.valueParameters.size == 1 }\n+                val size = getValueArgument(0)\n+                IrConstructorCallImpl(\n+                    UNDEFINED_OFFSET, UNDEFINED_OFFSET,\n+                    irBuiltIns.unitType, arrayConstructorSymbol,\n+                    0, 0, 1\n+                ).apply {\n+                    putValueArgument(0, size)\n+                }\n+            }\n+            is IrCall -> {\n+                require(isAtomicArrayFactory()) { \"Unsupported atomic array factory function $this\" }\n+                val arrayFactorySymbol = referencePackageFunction(\"kotlin\", \"arrayOfNulls\")\n+                val arrayElementType = getTypeArgument(0)!!\n+                val size = getValueArgument(0)\n+                buildCall(\n+                    target = arrayFactorySymbol,\n+                    type = type,\n+                    typeArguments = listOf(arrayElementType),\n+                    valueArguments = listOf(size)\n+                )\n+            }\n+            else -> error(\"Illegal type of atomic array initializer\")\n+        }\n+\n+    private fun IrCall.inlineAtomicFunction(atomicType: IrType, accessors: List<IrExpression>): IrCall {\n+        val valueArguments = getValueArguments()\n+        val functionName = getAtomicFunctionName()\n+        val runtimeFunction = getRuntimeFunctionSymbol(functionName, atomicType)\n+        return buildCall(\n+            target = runtimeFunction,\n+            type = type,\n+            origin = IrStatementOrigin.INVOKE,\n+            typeArguments = if (runtimeFunction.owner.typeParameters.size == 1) listOf(atomicType) else emptyList(),\n+            valueArguments = valueArguments + accessors\n+        )\n+    }\n+\n+    private fun IrStatement.transformStatement(parentDeclaration: IrDeclaration, lambda: IrFunction? = null) =\n+        when (this) {\n+            is IrExpression -> transformAtomicFunctionCall(parentDeclaration, lambda)\n+            is IrVariable -> {\n+                apply { initializer = initializer?.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+            }\n+            else -> this\n+        }\n+\n+    private fun IrExpression.transformAtomicFunctionCall(parentDeclaration: IrDeclaration, lambda: IrFunction? = null): IrExpression {\n+        // erase unchecked cast to the Atomic* type\n+        if (this is IrTypeOperatorCall && operator == IrTypeOperator.CAST && typeOperand.isAtomicValueType()) {\n+            return argument\n+        }\n+        if (isAtomicValueInitializer()) {\n+            return eraseAtomicConstructor(parentDeclaration, lambda)\n+        }\n+        when (this) {\n+            is IrTypeOperatorCall -> {\n+                return apply { argument = argument.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+            }\n+            is IrStringConcatenationImpl -> {\n+                return apply {\n+                    arguments.forEachIndexed { i, arg ->\n+                        arguments[i] = arg.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                    }\n+                }\n+            }\n+            is IrReturn -> {\n+                if (parentDeclaration.isTransformedAtomicExtensionFunction() && (parentDeclaration as IrFunction).isInline &&\n+                    returnTargetSymbol !== parentDeclaration.symbol) {\n+                    return IrReturnImpl(\n+                        startOffset,\n+                        endOffset,\n+                        type,\n+                        parentDeclaration.symbol,\n+                        value.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                    )\n+                }\n+                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+            }\n+            is IrSetValue -> {\n+                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+            }\n+            is IrSetField -> {\n+                return apply { value = value.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+            }\n+            is IrIfThenElseImpl -> {\n+                return apply {\n+                    branches.forEachIndexed { i, branch ->\n+                        branches[i] = branch.apply {\n+                            condition = condition.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                            result = result.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                        }\n+                    }\n+                }\n+            }\n+            is IrWhenImpl -> {\n+                return apply {\n+                    branches.forEachIndexed { i, branch ->\n+                        branches[i] = branch.apply {\n+                            condition = condition.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                            result = result.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                        }\n+                    }\n+                }\n+            }\n+            is IrTry -> {\n+                return apply {\n+                    tryResult = tryResult.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                    catches.forEach {\n+                        it.result = it.result.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                    }\n+                    finallyExpression = finallyExpression?.transformAtomicFunctionCall(parentDeclaration, lambda)\n+                }\n+            }\n+            is IrBlock -> {\n+                return apply {\n+                    statements.forEachIndexed { i, stmt ->\n+                        statements[i] = stmt.transformStatement(parentDeclaration, lambda)\n+                    }\n+                }\n+            }\n+            is IrGetValue -> {\n+                if (lambda != null && symbol.owner.parent == lambda) return this\n+                if (symbol is IrValueParameterSymbol && parentDeclaration.isTransformedAtomicExtensionFunction()) {\n+                    // replace use site of the value parameter with it's copy from the transformed declaration\n+                    val index = (symbol.owner as IrValueParameter).index\n+                    if (index >= 0) { // index == -1 for `this` parameter\n+                        val transformedValueParameter = (parentDeclaration as IrFunction).valueParameters[index]\n+                        return buildGetValue(transformedValueParameter.symbol)\n+                    }\n+                }\n+            }\n+            is IrCall -> {\n+                dispatchReceiver?.let { dispatchReceiver = it.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+                extensionReceiver?.let { extensionReceiver = it.transformAtomicFunctionCall(parentDeclaration, lambda) }\n+                getValueArguments().forEachIndexed { i, arg ->\n+                    putValueArgument(i, arg?.transformAtomicFunctionCall(parentDeclaration, lambda))\n+                }\n+                val isInline = symbol.owner.isInline\n+                val receiver = extensionReceiver ?: dispatchReceiver ?: return this\n+                // Invocation of atomic functions on atomic receivers\n+                // are substituted with the corresponding inline declarations from `kotlinx-atomicfu-runtime`\n+                if (symbol.isKotlinxAtomicfuPackage() && receiver.type.isAtomicValueType()) {\n+                    // 1. Receiver is the atomic field:\n+                    // a.incrementAndGet() -> atomicfu_incrementAndGet(get_a {..}, set_a {..})\n+                    if (receiver is IrCall) { // property accessor <get-field>\n+                        val accessors = receiver.getAccessors(lambda ?: parentDeclaration)\n+                        return inlineAtomicFunction(receiver.type.atomicToValueType(), accessors).apply {\n+                            transformAtomicfuLoopBody(parentDeclaration)\n+                        }\n+                    }\n+                    // 2. Atomic extension receiver `this`, the reciver of the parent function.\n+                    // Parent function is the inline Atomic* extension function already transformed with `transformAtomicInlineDeclaration`\n+                    // inline fun foo(getter: () -> T, setter: (T) -> Unit) { incrementAndGet() } ->\n+                    // inline fun foo(getter: () -> T, setter: (T) -> Unit) { atomicfu_incrementAndGet(getter, setter) }\n+                    if (receiver is IrGetValue && parentDeclaration.isTransformedAtomicExtensionFunction()) {\n+                        val accessorParameters = (parentDeclaration as IrFunction).valueParameters.takeLast(2).map { it.capture() }\n+                        return inlineAtomicFunction(receiver.type.atomicToValueType(), accessorParameters).apply {\n+                            transformAtomicfuLoopBody(parentDeclaration)\n+                        }\n+                    }\n+                } else {\n+                    // 3. transform invocation of an inline Atomic* extension function call: a.foo()\n+                    if (isInline && receiver is IrCall && receiver.type.isAtomicValueType()) {\n+                        val accessors = receiver.getAccessors(lambda ?: parentDeclaration)\n+                        val dispatch = dispatchReceiver\n+                        val args = getValueArguments()\n+                        val transformedTarget = symbol.owner.getDeclarationWithAccessorParameters()\n+                        return buildCall(\n+                            target = transformedTarget.symbol,\n+                            type = type,\n+                            origin = IrStatementOrigin.INVOKE,\n+                            valueArguments = args + accessors\n+                        ).apply {\n+                            dispatchReceiver = dispatch\n+                        }\n+                    }\n+                }\n+            }\n+            is IrConstructorCall -> {\n+                getValueArguments().forEachIndexed { i, arg ->\n+                    putValueArgument(i, arg?.transformAtomicFunctionCall(parentDeclaration, lambda))\n+                }\n+            }\n+        }\n+        return this\n+    }\n+\n+    private fun IrCall.transformAtomicfuLoopBody(parent: IrDeclaration) {\n+        if (symbol.owner.name.asString().matches(ATOMICFU_INLINE_FUNCTION.toRegex())) {\n+            val lambdaLoop = (getValueArgument(0) as IrFunctionExpression).function\n+            transformDeclarationBody(lambdaLoop.body, parent, lambdaLoop)\n+        }\n+    }\n+\n+    private fun IrFunction.hasReceiverAccessorParameters(): Boolean {\n+        if (valueParameters.size < 2) return false\n+        val params = valueParameters.takeLast(2)\n+        return params[0].name.asString() == GETTER && params[1].name.asString() == SETTER\n+    }\n+\n+    private fun IrDeclaration.isTransformedAtomicExtensionFunction(): Boolean =\n+        this is IrFunction && this.hasReceiverAccessorParameters()\n+\n+    private fun IrFunction.getDeclarationWithAccessorParameters(): IrSimpleFunction {\n+        val parent = parent as IrDeclarationContainer\n+        val params = valueParameters.map { it.type }\n+        val extensionType = extensionReceiverParameter?.type?.atomicToValueType()\n+        return try {\n+            parent.declarations.single {\n+                it is IrSimpleFunction &&\n+                it.name == symbol.owner.name &&\n+                it.valueParameters.size == params.size + 2 &&\n+                it.valueParameters.dropLast(2).withIndex().all { p -> p.value.type.classifierOrNull?.owner == params[p.index].classifierOrNull?.owner } &&\n+                it.getGetterReturnType()?.classifierOrNull?.owner == extensionType?.classifierOrNull?.owner\n+            } as IrSimpleFunction\n+        } catch (e: RuntimeException) {\n+            error(\"Exception while looking for the declaration with accessor parameters: ${e.message}\")\n+        }\n+    }\n+\n+    private fun IrExpression.isAtomicValueInitializer() =\n+        (this is IrCall && (this.isAtomicFactory() || this.isAtomicArrayFactory())) ||\n+                (this is IrConstructorCall && this.isAtomicArrayConstructor()) ||\n+                type.isReentrantLockType()\n+\n+    private fun IrCall.isArrayElementGetter() =\n+        dispatchReceiver != null &&\n+                dispatchReceiver!!.type.isAtomicArrayType() &&\n+                symbol.owner.name.asString() == GET\n+\n+    private fun IrCall.getBackingField(): IrField {\n+        val correspondingPropertySymbol = symbol.owner.correspondingPropertySymbol!!\n+        return correspondingPropertySymbol.owner.backingField!!\n+    }\n+\n+    private fun IrCall.buildAccessorLambda(\n+        isSetter: Boolean,\n+        parentDeclaration: IrDeclaration\n+    ): IrFunctionExpression {\n+        val isArrayElement = isArrayElementGetter()\n+        val getterCall = if (isArrayElement) dispatchReceiver as IrCall else this\n+        val valueType = type.atomicToValueType()\n+        val type = if (isSetter) buildSetterType(valueType) else buildGetterType(valueType)\n+        val name = if (isSetter) setterName(getterCall.symbol.owner.name.getFieldName())\n+            else getterName(getterCall.symbol.owner.name.getFieldName())\n+        val returnType = if (isSetter) context.irBuiltIns.unitType else valueType\n+        val accessorFunction = buildFunction(\n+            parent = parentDeclaration as IrDeclarationParent,\n+            origin = IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR,\n+            name = Name.identifier(name),\n+            visibility = DescriptorVisibilities.LOCAL,\n+            isInline = true,\n+            returnType = returnType\n+        ).apply {\n+            val valueParameter = buildValueParameter(this, name, 0, valueType)\n+            this.valueParameters = if (isSetter) listOf(valueParameter) else emptyList()\n+            val body = if (isSetter) {\n+                if (isArrayElement) {\n+                    val setSymbol = referenceFunction(getterCall.type.referenceClass(), SET)\n+                    val elementIndex = getValueArgument(0)!!.deepCopyWithVariables()\n+                    buildCall(\n+                        target = setSymbol,\n+                        type = context.irBuiltIns.unitType,\n+                        origin = IrStatementOrigin.LAMBDA,\n+                        valueArguments = listOf(elementIndex, valueParameter.capture())\n+                    ).apply {\n+                        dispatchReceiver = getterCall\n+                    }\n+                } else {\n+                    buildSetField(getterCall.getBackingField(), getterCall.dispatchReceiver, valueParameter.capture())\n+                }\n+            } else {\n+                val getField = buildGetField(getterCall.getBackingField(), getterCall.dispatchReceiver)\n+                if (isArrayElement) {\n+                    val getSymbol = referenceFunction(getterCall.type.referenceClass(), GET)\n+                    val elementIndex = getValueArgument(0)!!.deepCopyWithVariables()\n+                    buildCall(\n+                        target = getSymbol,\n+                        type = valueType,\n+                        origin = IrStatementOrigin.LAMBDA,\n+                        valueArguments = listOf(elementIndex)\n+                    ).apply {\n+                        dispatchReceiver = getField.deepCopyWithVariables()\n+                    }\n+                } else {\n+                    getField.deepCopyWithVariables()\n+                }\n+            }\n+            this.body = buildBlockBody(listOf(body))\n+            origin = IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR\n+        }\n+        return IrFunctionExpressionImpl(\n+            UNDEFINED_OFFSET, UNDEFINED_OFFSET,\n+            type,\n+            accessorFunction,\n+            IrStatementOrigin.LAMBDA\n+        )\n+    }\n+\n+    private fun buildSetField(backingField: IrField, ownerClass: IrExpression?, value: IrGetValue): IrSetField {\n+        val receiver = if (ownerClass is IrTypeOperatorCall) ownerClass.argument as IrGetValue else ownerClass\n+        val fieldSymbol = backingField.symbol\n+        return buildSetField(\n+            symbol = fieldSymbol,\n+            receiver = receiver,\n+            value = value\n+        )\n+    }\n+\n+    private fun buildGetField(backingField: IrField, ownerClass: IrExpression?): IrGetField {\n+        val receiver = if (ownerClass is IrTypeOperatorCall) ownerClass.argument as IrGetValue else ownerClass\n+        return buildGetField(\n+            symbol = backingField.symbol,\n+            receiver = receiver\n+        )\n+    }\n+\n+    private fun IrCall.getAccessors(parentDeclaration: IrDeclaration): List<IrExpression> =\n+        listOf(buildAccessorLambda(isSetter = false, parentDeclaration = parentDeclaration),\n+               buildAccessorLambda(isSetter = true, parentDeclaration = parentDeclaration))\n+\n+    private fun getRuntimeFunctionSymbol(name: String, type: IrType): IrSimpleFunctionSymbol {\n+        val functionName = when (name) {\n+            \"value.<get-value>\" -> \"getValue\"\n+            \"value.<set-value>\" -> \"setValue\"\n+            else -> name\n+        }\n+        return referencePackageFunction(\"kotlinx.atomicfu\", \"$ATOMICFU_RUNTIME_FUNCTION_PREDICATE$functionName\") {\n+            val typeArg = it.owner.getGetterReturnType()\n+            !(typeArg as IrType).isPrimitiveType() || typeArg == type\n+        }\n+    }\n+\n+    private fun IrFunction.getGetterReturnType() = (valueParameters[valueParameters.lastIndex - 1].type as IrSimpleType).arguments.first().typeOrNull\n+\n+    private fun IrCall.isAtomicFactory(): Boolean {\n+        val name = symbol.owner.name\n+        return !name.isSpecial && name.identifier == ATOMIC_CONSTRUCTOR\n+    }\n+\n+    private fun IrCall.isAtomicArrayFactory(): Boolean {\n+        val name = symbol.owner.name\n+        return !name.isSpecial && name.identifier == ATOMIC_ARRAY_FACTORY_FUNCTION\n+    }\n+\n+    private fun IrConstructorCall.isAtomicArrayConstructor() = (type as IrSimpleType).isAtomicArrayType()\n+\n+    private fun IrSymbol.isKotlinxAtomicfuPackage() =\n+        this.isPublicApi && signature?.packageFqName()?.asString() == AFU_PKG.prettyStr()\n+\n+    private fun IrType.isAtomicValueType() = belongsTo(ATOMICFU_VALUE_TYPE)\n+    private fun IrType.isAtomicArrayType() = belongsTo(ATOMIC_ARRAY_TYPE)\n+    private fun IrType.isReentrantLockType() = belongsTo(\"$AFU_PKG/$LOCKS\", REENTRANT_LOCK_TYPE)\n+\n+    private fun IrType.belongsTo(typeName: String) = belongsTo(AFU_PKG, typeName)\n+\n+    private fun IrType.belongsTo(packageName: String, typeName: String): Boolean {",
        "comment_created_at": "2021-09-22T06:18:07+00:00",
        "comment_author": "romanart",
        "comment_body": "```\r\n        return classOrNull?.let { \r\n            it.signature?.asPublic()?.let { sig -> \r\n                sig.packageFqName == packageName && sig.declarationFqName.matches(typeNameReg)\r\n            }\r\n        } ?: false\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "630924715",
    "pr_number": 4363,
    "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
    "created_at": "2021-05-12T10:37:02+00:00",
    "commented_code": "val processedClasspathElements = mutableSetOf<URL>()\n    fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n        when (classLoader) {\n            null -> res\n            null, baseClassLoader -> res",
    "repo_full_name": "JetBrains/kotlin",
    "discussion_comments": [
      {
        "comment_id": "630924715",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4363,
        "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
        "discussion_id": "630924715",
        "commented_code": "@@ -139,17 +140,17 @@ private fun CompiledScript.makeClassLoaderFromDependencies(baseClassLoader: Clas\n     val processedClasspathElements = mutableSetOf<URL>()\n     fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n         when (classLoader) {\n-            null -> res\n+            null, baseClassLoader -> res",
        "comment_created_at": "2021-05-12T10:37:02+00:00",
        "comment_author": "ligee",
        "comment_body": "I would still process the `null` case, e.g. generating an error if we've got null.",
        "pr_file_module": null
      },
      {
        "comment_id": "630928510",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4363,
        "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
        "discussion_id": "630924715",
        "commented_code": "@@ -139,17 +140,17 @@ private fun CompiledScript.makeClassLoaderFromDependencies(baseClassLoader: Clas\n     val processedClasspathElements = mutableSetOf<URL>()\n     fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n         when (classLoader) {\n-            null -> res\n+            null, baseClassLoader -> res",
        "comment_created_at": "2021-05-12T10:43:07+00:00",
        "comment_author": "ligee",
        "comment_body": "But it should be after `baseClassLoader` check, since it could be `null`, and it is a valid situation.",
        "pr_file_module": null
      },
      {
        "comment_id": "630949276",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4363,
        "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
        "discussion_id": "630924715",
        "commented_code": "@@ -139,17 +140,17 @@ private fun CompiledScript.makeClassLoaderFromDependencies(baseClassLoader: Clas\n     val processedClasspathElements = mutableSetOf<URL>()\n     fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n         when (classLoader) {\n-            null -> res\n+            null, baseClassLoader -> res",
        "comment_created_at": "2021-05-12T11:17:27+00:00",
        "comment_author": "ileasile",
        "comment_body": "@ligee I'm not sure that fallbackClassloader of DualClassLoader should necessarily have base classloader as a parent. Is it really so?",
        "pr_file_module": null
      },
      {
        "comment_id": "630952983",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4363,
        "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
        "discussion_id": "630924715",
        "commented_code": "@@ -139,17 +140,17 @@ private fun CompiledScript.makeClassLoaderFromDependencies(baseClassLoader: Clas\n     val processedClasspathElements = mutableSetOf<URL>()\n     fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n         when (classLoader) {\n-            null -> res\n+            null, baseClassLoader -> res",
        "comment_created_at": "2021-05-12T11:23:39+00:00",
        "comment_author": "ileasile",
        "comment_body": "As I can see from usages, it is always a thread context classloader that is a base classloader at the same time, so there is no appropriate test",
        "pr_file_module": null
      },
      {
        "comment_id": "630967327",
        "repo_full_name": "JetBrains/kotlin",
        "pr_number": 4363,
        "pr_file": "libraries/scripting/jvm/src/kotlin/script/experimental/jvm/impl/KJvmCompiledScript.kt",
        "discussion_id": "630924715",
        "commented_code": "@@ -139,17 +140,17 @@ private fun CompiledScript.makeClassLoaderFromDependencies(baseClassLoader: Clas\n     val processedClasspathElements = mutableSetOf<URL>()\n     fun recursiveClassPath(res: Sequence<URL>, classLoader: ClassLoader?): Sequence<URL> =\n         when (classLoader) {\n-            null -> res\n+            null, baseClassLoader -> res",
        "comment_created_at": "2021-05-12T11:47:21+00:00",
        "comment_author": "ligee",
        "comment_body": "I'd say it should convert to the baseClassLoader, but since it is possible to replace it, it is safer to leave the code as you wrote it.\r\nAbout the tests - there are some tests with baseClassLoader set to null, and that's probably it.",
        "pr_file_module": null
      }
    ]
  }
]