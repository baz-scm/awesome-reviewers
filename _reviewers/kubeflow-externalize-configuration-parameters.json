[
  {
    "discussion_id": "1373281958",
    "pr_number": 7371,
    "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
    "created_at": "2023-10-26T14:33:23+00:00",
    "commented_code": "# Profile Controller Custom Resources\n\n**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n\n## Goal\n\nFirst and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\ncomponents. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\ngoal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\ncreate the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n\nBy creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\nreconciliation. There is auditability over who create a resource and a source of truth.\n\nAdditionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\nsub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\nregenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\nextended to trigger an external hook that may clean up resources in other systems.\n\n## Proposal\n\nThe proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\nsub-resources to facilitate each purpose\n\n## Resources\n\n`profile.yaml`\n\n```yaml\napiVersion: kubeflow.org/v2\nkind: Profile\nmetadata:\n  name: ml\nspec:\n  resourceQuotaSpec:\n    hard:\n      cpu: \"2\"\n      memory: 2Gi\n      requests.nvidia.com/gpu: \"1\"\n      persistentvolumeclaims: \"1\"\n      requests.storage: \"5Gi\"\n```\n\nA slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\na `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\ninstance `kf-ml`)\n\n`service_account.yaml`\n\n```yaml\napiVersion: kubeflow.org/v2\nkind: ServiceAccount\nmetadata:\n  name: omri-sa\n  namespace: kubeflow-ml\nspec:\n  role: edit\n```\n\nThis will create a `omri-sa` service account in the `kubeflow-ml` namespace with `edit` role. Internally, this will\ncreate:\n\n- ServiceAccount\n- Secret (for the service account)\n- Role (To get a token)\n- RoleBinding (For the token role)\n- ClusterRoleBinding (For the Kubeflow role)\n\n`user_permission.yaml`\n\n```yaml\napiVersion: kubeflow.org/v2\nkind: Permission",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1373281958",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7371,
        "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
        "discussion_id": "1373281958",
        "commented_code": "@@ -0,0 +1,110 @@\n+# Profile Controller Custom Resources\n+\n+**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n+\n+## Goal\n+\n+First and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\n+components. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\n+goal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\n+create the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n+\n+By creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\n+reconciliation. There is auditability over who create a resource and a source of truth.\n+\n+Additionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\n+sub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\n+regenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\n+extended to trigger an external hook that may clean up resources in other systems.\n+\n+## Proposal\n+\n+The proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\n+sub-resources to facilitate each purpose\n+\n+## Resources\n+\n+`profile.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Profile\n+metadata:\n+  name: ml\n+spec:\n+  resourceQuotaSpec:\n+    hard:\n+      cpu: \"2\"\n+      memory: 2Gi\n+      requests.nvidia.com/gpu: \"1\"\n+      persistentvolumeclaims: \"1\"\n+      requests.storage: \"5Gi\"\n+```\n+\n+A slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\n+a `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\n+instance `kf-ml`)\n+\n+`service_account.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: ServiceAccount\n+metadata:\n+  name: omri-sa\n+  namespace: kubeflow-ml\n+spec:\n+  role: edit\n+```\n+\n+This will create a `omri-sa` service account in the `kubeflow-ml` namespace with `edit` role. Internally, this will\n+create:\n+\n+- ServiceAccount\n+- Secret (for the service account)\n+- Role (To get a token)\n+- RoleBinding (For the token role)\n+- ClusterRoleBinding (For the Kubeflow role)\n+\n+`user_permission.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Permission",
        "comment_created_at": "2023-10-26T14:33:23+00:00",
        "comment_author": "kimwnasptd",
        "comment_body": "Also, ultimately we could use these CRs then to list who the contributors in the namespace are from the CentralDashboard?",
        "pr_file_module": null
      },
      {
        "comment_id": "1373319340",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7371,
        "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
        "discussion_id": "1373281958",
        "commented_code": "@@ -0,0 +1,110 @@\n+# Profile Controller Custom Resources\n+\n+**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n+\n+## Goal\n+\n+First and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\n+components. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\n+goal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\n+create the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n+\n+By creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\n+reconciliation. There is auditability over who create a resource and a source of truth.\n+\n+Additionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\n+sub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\n+regenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\n+extended to trigger an external hook that may clean up resources in other systems.\n+\n+## Proposal\n+\n+The proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\n+sub-resources to facilitate each purpose\n+\n+## Resources\n+\n+`profile.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Profile\n+metadata:\n+  name: ml\n+spec:\n+  resourceQuotaSpec:\n+    hard:\n+      cpu: \"2\"\n+      memory: 2Gi\n+      requests.nvidia.com/gpu: \"1\"\n+      persistentvolumeclaims: \"1\"\n+      requests.storage: \"5Gi\"\n+```\n+\n+A slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\n+a `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\n+instance `kf-ml`)\n+\n+`service_account.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: ServiceAccount\n+metadata:\n+  name: omri-sa\n+  namespace: kubeflow-ml\n+spec:\n+  role: edit\n+```\n+\n+This will create a `omri-sa` service account in the `kubeflow-ml` namespace with `edit` role. Internally, this will\n+create:\n+\n+- ServiceAccount\n+- Secret (for the service account)\n+- Role (To get a token)\n+- RoleBinding (For the token role)\n+- ClusterRoleBinding (For the Kubeflow role)\n+\n+`user_permission.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Permission",
        "comment_created_at": "2023-10-26T14:57:54+00:00",
        "comment_author": "omrishiv",
        "comment_body": "That would be a really nice extension. Maybe a facility to use the UI to ultimately create these, if the admin allows it. One other thing we haven't talked about is the `admin` role, which today, I have a Kyverno policy I manually apply to each admin to create `Permission`s in each `kubeflow-` namespace. I would love to see if we can handle this properly without kyverno. The admin role could create this policy as a first step, but it would be nice to be properly handled internally. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1373376622",
    "pr_number": 7371,
    "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
    "created_at": "2023-10-26T15:38:54+00:00",
    "commented_code": "# Profile Controller Custom Resources\n\n**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n\n## Goal\n\nFirst and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\ncomponents. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\ngoal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\ncreate the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n\nBy creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\nreconciliation. There is auditability over who create a resource and a source of truth.\n\nAdditionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\nsub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\nregenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\nextended to trigger an external hook that may clean up resources in other systems.\n\n## Proposal\n\nThe proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\nsub-resources to facilitate each purpose\n\n## Resources\n\n`profile.yaml`\n\n```yaml\napiVersion: kubeflow.org/v2\nkind: Profile\nmetadata:\n  name: ml\nspec:\n  resourceQuotaSpec:\n    hard:\n      cpu: \"2\"\n      memory: 2Gi\n      requests.nvidia.com/gpu: \"1\"\n      persistentvolumeclaims: \"1\"\n      requests.storage: \"5Gi\"\n```\n\nA slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\na `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\ninstance `kf-ml`)",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1373376622",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7371,
        "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
        "discussion_id": "1373376622",
        "commented_code": "@@ -0,0 +1,110 @@\n+# Profile Controller Custom Resources\n+\n+**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n+\n+## Goal\n+\n+First and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\n+components. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\n+goal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\n+create the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n+\n+By creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\n+reconciliation. There is auditability over who create a resource and a source of truth.\n+\n+Additionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\n+sub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\n+regenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\n+extended to trigger an external hook that may clean up resources in other systems.\n+\n+## Proposal\n+\n+The proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\n+sub-resources to facilitate each purpose\n+\n+## Resources\n+\n+`profile.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Profile\n+metadata:\n+  name: ml\n+spec:\n+  resourceQuotaSpec:\n+    hard:\n+      cpu: \"2\"\n+      memory: 2Gi\n+      requests.nvidia.com/gpu: \"1\"\n+      persistentvolumeclaims: \"1\"\n+      requests.storage: \"5Gi\"\n+```\n+\n+A slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\n+a `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\n+instance `kf-ml`)\n+",
        "comment_created_at": "2023-10-26T15:38:54+00:00",
        "comment_author": "TobiasGoerke",
        "comment_body": "While we're extending the profile CRD: what do you think about adding an option for a LimitRange besides the ResourceQuota?",
        "pr_file_module": null
      },
      {
        "comment_id": "1373610658",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7371,
        "pr_file": "components/proposals/20231023-profile-controller-custom-resources.md",
        "discussion_id": "1373376622",
        "commented_code": "@@ -0,0 +1,110 @@\n+# Profile Controller Custom Resources\n+\n+**Authors**: Omri Shiv ([@OmriShiv](https://github.com/OmriShiv))\n+\n+## Goal\n+\n+First and foremost, the goal of creating these custom resources is to ease the burden of creating common Kubeflow\n+components. Users should not need to manually create `RoleBinding`s, Istio `AuthorizationPolicy`s, and others when the\n+goal is to give a user access to a namespace. By creating higher level resources, one small, purposeful resource can\n+create the Kubernetes objects needed to support the task. This purpose enables some sub-goals:\n+\n+By creating simple custom resources, these files can be checked into a GitOps system for automated deploying and\n+reconciliation. There is auditability over who create a resource and a source of truth.\n+\n+Additionally, this facilitates a security goal of allowing much easier clean up of resources. By adding ownership to the\n+sub-resources, deleting the parents object will cascade delete the created resources. It can also serve the task of\n+regenerating secrets in the event that a user has left the company and secrets need to be rotated. This can also be\n+extended to trigger an external hook that may clean up resources in other systems.\n+\n+## Proposal\n+\n+The proposed solution is to add a small set of Custom Resources (described below) to enable the creation of the needed\n+sub-resources to facilitate each purpose\n+\n+## Resources\n+\n+`profile.yaml`\n+\n+```yaml\n+apiVersion: kubeflow.org/v2\n+kind: Profile\n+metadata:\n+  name: ml\n+spec:\n+  resourceQuotaSpec:\n+    hard:\n+      cpu: \"2\"\n+      memory: 2Gi\n+      requests.nvidia.com/gpu: \"1\"\n+      persistentvolumeclaims: \"1\"\n+      requests.storage: \"5Gi\"\n+```\n+\n+A slightly simplified version of the current Kubeflow Profile. `resourceQuotaSpec` is optional. This will create\n+a `kubeflow-ml` profile, but should be able to look up the Kubeflow namespace `prefix` and adjust based on that (for\n+instance `kf-ml`)\n+",
        "comment_created_at": "2023-10-26T18:32:42+00:00",
        "comment_author": "omrishiv",
        "comment_body": "This is a great addition. We currently do it using Kyverno, but would be nice to be handled internally",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1185621732",
    "pr_number": 7123,
    "pr_file": "conformance/1.7/README.md",
    "created_at": "2023-05-05T00:34:25+00:00",
    "commented_code": "# Kubeflow conformance program (WIP)\n\nBefore running the conformance tests, you need to configure kubectl default context to point to the k8s cluster that is hosting Kubeflow.\n\nTODO: Make the kubeflow namespace configurable.",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1185621732",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7123,
        "pr_file": "conformance/1.7/README.md",
        "discussion_id": "1185621732",
        "commented_code": "@@ -0,0 +1,27 @@\n+# Kubeflow conformance program (WIP)\n+\n+Before running the conformance tests, you need to configure kubectl default context to point to the k8s cluster that is hosting Kubeflow.\n+\n+TODO: Make the kubeflow namespace configurable.",
        "comment_created_at": "2023-05-05T00:34:25+00:00",
        "comment_author": "gkcalat",
        "comment_body": "NIT: move this out of `README.md`. `Makefile`, maybe?",
        "pr_file_module": null
      },
      {
        "comment_id": "1186507328",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7123,
        "pr_file": "conformance/1.7/README.md",
        "discussion_id": "1185621732",
        "commented_code": "@@ -0,0 +1,27 @@\n+# Kubeflow conformance program (WIP)\n+\n+Before running the conformance tests, you need to configure kubectl default context to point to the k8s cluster that is hosting Kubeflow.\n+\n+TODO: Make the kubeflow namespace configurable.",
        "comment_created_at": "2023-05-05T21:18:38+00:00",
        "comment_author": "james-jwu",
        "comment_body": "Removed. The KF service namespace was made configurable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "596656576",
    "pr_number": 5694,
    "pr_file": "components/example-notebook-servers/README.md",
    "created_at": "2021-03-18T08:49:21+00:00",
    "commented_code": "# Example Notebook Servers\n\n**DISCLAIMER:** The Notebooks Working Group provides these Dockerfiles and\ntheir images as examples only, they are not tested with our CI/CD pipelines\nand are not certified to work in every situation. As such, issues related to\nthese images will be dealt with in a best efforts approach. The Notebooks\nWorking Group will work on officially supporting some of these Notebook\nServer images in the near future. If you do encounter a problem in one of\nthese images, contributions and issue reports are greatly appreciated.\n\n## Introduction\n\nThis directory contains Dockerfiles that are intended to show users how to\ncreate images for various types of Notebook Servers that can run on Kubeflow.\nThere is a common base images that starts from Ubuntu 20.04, adds some\ndependencies and common utilities from APT, installs `kubectl`, creates the\nuser account for the downstream images and adds the\n[S6-overlay](https://github.com/just-containers/s6-overlay) for the init system.\nFrom this base image, images for Jupyter, RStudio and Visual Studio Code\n(through [code-server]([https://github.com/cdr/code-server)) are created.\nFrom the Jupyter image, images are created that show users how to install\nTensorFlow and PyTorch both with and without support for NVIDIA GPUs.\nIn turn, these images are extended with an opinionated set of common tools\nand packages to help new users to quickly get started with Kubeflow.\n\n**Lineage of the provided example Notebook Server Images:**\n\n![Flow Chart of example Notebook Servers](./kubeflow-example-notebook-servers.png)\n\n## Creating custom Notebook Server images\n\nBecause the needs of users varies greatly, the provided images were created to\nbe easily extended by using the [S6-overlay](https://github.com/just-containers/s6-overlay)\ninit system and including [Conda](https://github.com/conda-forge/miniforge).\n\n### Installing packages\n\nThe most common customization to Notebook Server images will be to install\na selection of packages specific that will be needed in the Notebook Server.\nUsers can install packages in a running Notebook Server using `pip install ...`\nor `conda install ...`. However, packages installed in this manner will not\npersist if the Notebook Server is stopped or the Pod is restarted.\nWhile it is possible to install Python packages in the user's home directory\nby using `pip install --user ...`, this can cause unexpected behaviour if the\nworkspace volume is later used in a different Notebook Server, as the packages\npresent in the home directory might be used rather than the ones present in the\nNotebook Server's image. For this reason it is recommended to create custom",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "596656576",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5694,
        "pr_file": "components/example-notebook-servers/README.md",
        "discussion_id": "596656576",
        "commented_code": "@@ -0,0 +1,139 @@\n+# Example Notebook Servers\n+\n+**DISCLAIMER:** The Notebooks Working Group provides these Dockerfiles and\n+their images as examples only, they are not tested with our CI/CD pipelines\n+and are not certified to work in every situation. As such, issues related to\n+these images will be dealt with in a best efforts approach. The Notebooks\n+Working Group will work on officially supporting some of these Notebook\n+Server images in the near future. If you do encounter a problem in one of\n+these images, contributions and issue reports are greatly appreciated.\n+\n+## Introduction\n+\n+This directory contains Dockerfiles that are intended to show users how to\n+create images for various types of Notebook Servers that can run on Kubeflow.\n+There is a common base images that starts from Ubuntu 20.04, adds some\n+dependencies and common utilities from APT, installs `kubectl`, creates the\n+user account for the downstream images and adds the\n+[S6-overlay](https://github.com/just-containers/s6-overlay) for the init system.\n+From this base image, images for Jupyter, RStudio and Visual Studio Code\n+(through [code-server]([https://github.com/cdr/code-server)) are created.\n+From the Jupyter image, images are created that show users how to install\n+TensorFlow and PyTorch both with and without support for NVIDIA GPUs.\n+In turn, these images are extended with an opinionated set of common tools\n+and packages to help new users to quickly get started with Kubeflow.\n+\n+**Lineage of the provided example Notebook Server Images:**\n+\n+![Flow Chart of example Notebook Servers](./kubeflow-example-notebook-servers.png)\n+\n+## Creating custom Notebook Server images\n+\n+Because the needs of users varies greatly, the provided images were created to\n+be easily extended by using the [S6-overlay](https://github.com/just-containers/s6-overlay)\n+init system and including [Conda](https://github.com/conda-forge/miniforge).\n+\n+### Installing packages\n+\n+The most common customization to Notebook Server images will be to install\n+a selection of packages specific that will be needed in the Notebook Server.\n+Users can install packages in a running Notebook Server using `pip install ...`\n+or `conda install ...`. However, packages installed in this manner will not\n+persist if the Notebook Server is stopped or the Pod is restarted.\n+While it is possible to install Python packages in the user's home directory\n+by using `pip install --user ...`, this can cause unexpected behaviour if the\n+workspace volume is later used in a different Notebook Server, as the packages\n+present in the home directory might be used rather than the ones present in the\n+Notebook Server's image. For this reason it is recommended to create custom",
        "comment_created_at": "2021-03-18T08:49:21+00:00",
        "comment_author": "StefanoFioravanzo",
        "comment_body": "I am not sure the discussion about the lifecycle of packages and PVCs is relevant to this document. I would remove it",
        "pr_file_module": null
      },
      {
        "comment_id": "596686760",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5694,
        "pr_file": "components/example-notebook-servers/README.md",
        "discussion_id": "596656576",
        "commented_code": "@@ -0,0 +1,139 @@\n+# Example Notebook Servers\n+\n+**DISCLAIMER:** The Notebooks Working Group provides these Dockerfiles and\n+their images as examples only, they are not tested with our CI/CD pipelines\n+and are not certified to work in every situation. As such, issues related to\n+these images will be dealt with in a best efforts approach. The Notebooks\n+Working Group will work on officially supporting some of these Notebook\n+Server images in the near future. If you do encounter a problem in one of\n+these images, contributions and issue reports are greatly appreciated.\n+\n+## Introduction\n+\n+This directory contains Dockerfiles that are intended to show users how to\n+create images for various types of Notebook Servers that can run on Kubeflow.\n+There is a common base images that starts from Ubuntu 20.04, adds some\n+dependencies and common utilities from APT, installs `kubectl`, creates the\n+user account for the downstream images and adds the\n+[S6-overlay](https://github.com/just-containers/s6-overlay) for the init system.\n+From this base image, images for Jupyter, RStudio and Visual Studio Code\n+(through [code-server]([https://github.com/cdr/code-server)) are created.\n+From the Jupyter image, images are created that show users how to install\n+TensorFlow and PyTorch both with and without support for NVIDIA GPUs.\n+In turn, these images are extended with an opinionated set of common tools\n+and packages to help new users to quickly get started with Kubeflow.\n+\n+**Lineage of the provided example Notebook Server Images:**\n+\n+![Flow Chart of example Notebook Servers](./kubeflow-example-notebook-servers.png)\n+\n+## Creating custom Notebook Server images\n+\n+Because the needs of users varies greatly, the provided images were created to\n+be easily extended by using the [S6-overlay](https://github.com/just-containers/s6-overlay)\n+init system and including [Conda](https://github.com/conda-forge/miniforge).\n+\n+### Installing packages\n+\n+The most common customization to Notebook Server images will be to install\n+a selection of packages specific that will be needed in the Notebook Server.\n+Users can install packages in a running Notebook Server using `pip install ...`\n+or `conda install ...`. However, packages installed in this manner will not\n+persist if the Notebook Server is stopped or the Pod is restarted.\n+While it is possible to install Python packages in the user's home directory\n+by using `pip install --user ...`, this can cause unexpected behaviour if the\n+workspace volume is later used in a different Notebook Server, as the packages\n+present in the home directory might be used rather than the ones present in the\n+Notebook Server's image. For this reason it is recommended to create custom",
        "comment_created_at": "2021-03-18T09:29:57+00:00",
        "comment_author": "davidspek",
        "comment_body": "While not directly relevant to this document, this very situation has been the cause of issues in the past so I do think this should be stated somewhere. I agree, it is a bit out of place here. I'll leave it in here for the moment until while I think of what to do with it. If needed, it can quickly be removed before merging. \r\n\r\nI'm thinking a `Best practices and considerations` section might be on option (in this README, as well as on the website, which I'm guessing will be mostly copy/paste from here with some formatting changes). ",
        "pr_file_module": null
      },
      {
        "comment_id": "608237698",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5694,
        "pr_file": "components/example-notebook-servers/README.md",
        "discussion_id": "596656576",
        "commented_code": "@@ -0,0 +1,139 @@\n+# Example Notebook Servers\n+\n+**DISCLAIMER:** The Notebooks Working Group provides these Dockerfiles and\n+their images as examples only, they are not tested with our CI/CD pipelines\n+and are not certified to work in every situation. As such, issues related to\n+these images will be dealt with in a best efforts approach. The Notebooks\n+Working Group will work on officially supporting some of these Notebook\n+Server images in the near future. If you do encounter a problem in one of\n+these images, contributions and issue reports are greatly appreciated.\n+\n+## Introduction\n+\n+This directory contains Dockerfiles that are intended to show users how to\n+create images for various types of Notebook Servers that can run on Kubeflow.\n+There is a common base images that starts from Ubuntu 20.04, adds some\n+dependencies and common utilities from APT, installs `kubectl`, creates the\n+user account for the downstream images and adds the\n+[S6-overlay](https://github.com/just-containers/s6-overlay) for the init system.\n+From this base image, images for Jupyter, RStudio and Visual Studio Code\n+(through [code-server]([https://github.com/cdr/code-server)) are created.\n+From the Jupyter image, images are created that show users how to install\n+TensorFlow and PyTorch both with and without support for NVIDIA GPUs.\n+In turn, these images are extended with an opinionated set of common tools\n+and packages to help new users to quickly get started with Kubeflow.\n+\n+**Lineage of the provided example Notebook Server Images:**\n+\n+![Flow Chart of example Notebook Servers](./kubeflow-example-notebook-servers.png)\n+\n+## Creating custom Notebook Server images\n+\n+Because the needs of users varies greatly, the provided images were created to\n+be easily extended by using the [S6-overlay](https://github.com/just-containers/s6-overlay)\n+init system and including [Conda](https://github.com/conda-forge/miniforge).\n+\n+### Installing packages\n+\n+The most common customization to Notebook Server images will be to install\n+a selection of packages specific that will be needed in the Notebook Server.\n+Users can install packages in a running Notebook Server using `pip install ...`\n+or `conda install ...`. However, packages installed in this manner will not\n+persist if the Notebook Server is stopped or the Pod is restarted.\n+While it is possible to install Python packages in the user's home directory\n+by using `pip install --user ...`, this can cause unexpected behaviour if the\n+workspace volume is later used in a different Notebook Server, as the packages\n+present in the home directory might be used rather than the ones present in the\n+Notebook Server's image. For this reason it is recommended to create custom",
        "comment_created_at": "2021-04-06T23:15:38+00:00",
        "comment_author": "thesuperzapper",
        "comment_body": "While I think this wording can be simplified, we should definitely discuss the implications of how kubeflow mounts PVCs to the home directory for `pip install`",
        "pr_file_module": null
      }
    ]
  }
]