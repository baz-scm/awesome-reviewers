[
  {
    "discussion_id": "1145098910",
    "pr_number": 6952,
    "pr_file": "components/crud-web-apps/jupyter/backend/apps/common/status.py",
    "created_at": "2023-03-22T16:23:18+00:00",
    "commented_code": "def process_status(notebook):\n    \"\"\"\n    Return status and reason. Status may be [running|waiting|warning|error]\n    Return status and reason. Status may be [running|waiting|warning]\n    \"\"\"\n    # Check if the Notebook is stopped\n    readyReplicas = notebook.get(\"status\", {}).get(\"readyReplicas\", 0)\n    metadata = notebook.get(\"metadata\", {})\n    annotations = metadata.get(\"annotations\", {})\n\n    if STOP_ANNOTATION in annotations:\n        if readyReplicas == 0:\n            return status.create_status(\n                status.STATUS_PHASE.STOPPED,\n                \"No Pods are currently running for this Notebook Server.\",\n            )\n        else:\n            return status.create_status(\n                status.STATUS_PHASE.TERMINATING, \"Notebook Server is stopping.\"\n            )\n    creationTimestamp = notebook[\"metadata\"][\"creationTimestamp\"]\n\n    # If the Notebook is being deleted, the status will be waiting\n    if \"deletionTimestamp\" in metadata:\n        return status.create_status(\n            status.STATUS_PHASE.TERMINATING, \"Deleting this notebook server\"\n        )\n\n    # Check the status\n    state = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n\n    # Use conditions on the Jupyter notebook (i.e., s) to determine overall\n    # status. If no container state is available, we try to extract information\n    # about why the notebook is not starting from the notebook's events\n    # (see find_error_event)\n    if readyReplicas == 1:\n        return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n\n    if \"waiting\" in state:\n        return status.create_status(\n            status.STATUS_PHASE.WAITING, state[\"waiting\"][\"reason\"]\n        )\n\n    # Provide the user with detailed information (if any) about\n    # why the notebook is not starting\n    notebook_events = get_notebook_events(notebook)\n    status_val, reason = status.STATUS_PHASE.WAITING, \"Scheduling the Pod\"\n    status_event, reason_event = find_error_event(notebook_events)\n    if status_event is not None:\n        status_val, reason = status_event, reason_event\n\n    return status.create_status(status_val, reason)\n    # Convert a date string of a format to datetime object\n    nb_creation_time = dt.datetime.strptime(\n        creationTimestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n    current_time = dt.datetime.utcnow().replace(microsecond=0)\n    delta = (current_time - nb_creation_time)\n\n    while delta.total_seconds() <= 10:",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1145098910",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 6952,
        "pr_file": "components/crud-web-apps/jupyter/backend/apps/common/status.py",
        "discussion_id": "1145098910",
        "commented_code": "@@ -8,54 +8,75 @@\n \n def process_status(notebook):\n     \"\"\"\n-    Return status and reason. Status may be [running|waiting|warning|error]\n+    Return status and reason. Status may be [running|waiting|warning]\n     \"\"\"\n-    # Check if the Notebook is stopped\n     readyReplicas = notebook.get(\"status\", {}).get(\"readyReplicas\", 0)\n-    metadata = notebook.get(\"metadata\", {})\n-    annotations = metadata.get(\"annotations\", {})\n-\n-    if STOP_ANNOTATION in annotations:\n-        if readyReplicas == 0:\n-            return status.create_status(\n-                status.STATUS_PHASE.STOPPED,\n-                \"No Pods are currently running for this Notebook Server.\",\n-            )\n-        else:\n-            return status.create_status(\n-                status.STATUS_PHASE.TERMINATING, \"Notebook Server is stopping.\"\n-            )\n+    creationTimestamp = notebook[\"metadata\"][\"creationTimestamp\"]\n \n-    # If the Notebook is being deleted, the status will be waiting\n-    if \"deletionTimestamp\" in metadata:\n-        return status.create_status(\n-            status.STATUS_PHASE.TERMINATING, \"Deleting this notebook server\"\n-        )\n-\n-    # Check the status\n-    state = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n-\n-    # Use conditions on the Jupyter notebook (i.e., s) to determine overall\n-    # status. If no container state is available, we try to extract information\n-    # about why the notebook is not starting from the notebook's events\n-    # (see find_error_event)\n-    if readyReplicas == 1:\n-        return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n-\n-    if \"waiting\" in state:\n-        return status.create_status(\n-            status.STATUS_PHASE.WAITING, state[\"waiting\"][\"reason\"]\n-        )\n-\n-    # Provide the user with detailed information (if any) about\n-    # why the notebook is not starting\n-    notebook_events = get_notebook_events(notebook)\n-    status_val, reason = status.STATUS_PHASE.WAITING, \"Scheduling the Pod\"\n-    status_event, reason_event = find_error_event(notebook_events)\n-    if status_event is not None:\n-        status_val, reason = status_event, reason_event\n-\n-    return status.create_status(status_val, reason)\n+    # Convert a date string of a format to datetime object\n+    nb_creation_time = dt.datetime.strptime(\n+        creationTimestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n+    current_time = dt.datetime.utcnow().replace(microsecond=0)\n+    delta = (current_time - nb_creation_time)\n+\n+    while delta.total_seconds() <= 10:",
        "comment_created_at": "2023-03-22T16:23:18+00:00",
        "comment_author": "kimwnasptd",
        "comment_body": "Why does this need to be a `while` loop and not an `if`? \r\n\r\nAlso, shouldn't we have the condition also check if the status is \"empty\"? Since we want to have this message only when the controller hasn't set the status? \r\n\r\nElse won't it always expose the `Waiting for StatefulSet to create the underlying Pod.` message for the first 10 seconds independently of whether the status is set?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1146056623",
    "pr_number": 6952,
    "pr_file": "components/crud-web-apps/jupyter/backend/apps/common/status.py",
    "created_at": "2023-03-23T11:40:47+00:00",
    "commented_code": "def process_status(notebook):\n    \"\"\"\n    Return status and reason. Status may be [running|waiting|warning|error]\n    Return status and reason. Status may be [running|waiting|warning]\n    \"\"\"\n    # Check if the Notebook is stopped\n    readyReplicas = notebook.get(\"status\", {}).get(\"readyReplicas\", 0)\n    metadata = notebook.get(\"metadata\", {})\n    annotations = metadata.get(\"annotations\", {})\n\n    if STOP_ANNOTATION in annotations:\n        if readyReplicas == 0:\n            return status.create_status(\n                status.STATUS_PHASE.STOPPED,\n                \"No Pods are currently running for this Notebook Server.\",\n            )\n        else:\n            return status.create_status(\n                status.STATUS_PHASE.TERMINATING, \"Notebook Server is stopping.\"\n            )\n    creationTimestamp = notebook[\"metadata\"][\"creationTimestamp\"]\n\n    # If the Notebook is being deleted, the status will be waiting\n    if \"deletionTimestamp\" in metadata:\n        return status.create_status(\n            status.STATUS_PHASE.TERMINATING, \"Deleting this notebook server\"\n        )\n\n    # Check the status\n    state = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n\n    # Use conditions on the Jupyter notebook (i.e., s) to determine overall\n    # status. If no container state is available, we try to extract information\n    # about why the notebook is not starting from the notebook's events\n    # (see find_error_event)\n    if readyReplicas == 1:\n        return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n\n    if \"waiting\" in state:\n        return status.create_status(\n            status.STATUS_PHASE.WAITING, state[\"waiting\"][\"reason\"]\n        )\n\n    # Provide the user with detailed information (if any) about\n    # why the notebook is not starting\n    notebook_events = get_notebook_events(notebook)\n    status_val, reason = status.STATUS_PHASE.WAITING, \"Scheduling the Pod\"\n    status_event, reason_event = find_error_event(notebook_events)\n    if status_event is not None:\n        status_val, reason = status_event, reason_event\n\n    return status.create_status(status_val, reason)\n    # Convert a date string of a format to datetime object\n    nb_creation_time = dt.datetime.strptime(\n        creationTimestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n    current_time = dt.datetime.utcnow().replace(microsecond=0)\n    delta = (current_time - nb_creation_time)\n\n    while delta.total_seconds() <= 10:\n        status_val, reason = status.STATUS_PHASE.WAITING, \"Waiting for StatefulSet to create the underlying Pod.\"\n\n        # Check if the Notebook is stopped or deleted\n        status_phase, status_message = check_stopped_deleted_nb(notebook)\n        if status_phase is not None:\n            status_val, reason = status_phase, status_message\n\n        return status.create_status(status_val, reason)\n    else:\n        # Check if the Notebook is stopped or deleted\n        status_phase, status_message = check_stopped_deleted_nb(notebook)\n        if status_phase is not None:\n            status_val, reason = status_phase, status_message\n            return status.create_status(status_val, reason)\n\n        # If the Notebook is running, the status will be ready\n        if readyReplicas == 1:\n            return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n\n        # Otherwise, first check .status.containerState to determine the status\n        # reason and message to determine the status\n        containerState = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n\n        if \"waiting\" in containerState:\n            if containerState[\"waiting\"][\"reason\"] == 'PodInitializing':\n                return status.create_status(\n                    status.STATUS_PHASE.WAITING, containerState[\"waiting\"][\"reason\"]\n                )\n            else:\n                return status.create_status(\n                    status.STATUS_PHASE.WARNING, containerState[\"waiting\"][\"reason\"] +\n                    ': ' + containerState[\"waiting\"][\"message\"]\n                )\n\n        # If no containerState is available, check .status.conditions, since they have\n        # a reason and a message to determine the status\n        conditions = notebook.get(\"status\", {}).get(\"conditions\", \"\")\n\n        for condition in conditions:\n            for item in condition:\n                if \"reason\" in item:",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1146056623",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 6952,
        "pr_file": "components/crud-web-apps/jupyter/backend/apps/common/status.py",
        "discussion_id": "1146056623",
        "commented_code": "@@ -8,54 +8,75 @@\n \n def process_status(notebook):\n     \"\"\"\n-    Return status and reason. Status may be [running|waiting|warning|error]\n+    Return status and reason. Status may be [running|waiting|warning]\n     \"\"\"\n-    # Check if the Notebook is stopped\n     readyReplicas = notebook.get(\"status\", {}).get(\"readyReplicas\", 0)\n-    metadata = notebook.get(\"metadata\", {})\n-    annotations = metadata.get(\"annotations\", {})\n-\n-    if STOP_ANNOTATION in annotations:\n-        if readyReplicas == 0:\n-            return status.create_status(\n-                status.STATUS_PHASE.STOPPED,\n-                \"No Pods are currently running for this Notebook Server.\",\n-            )\n-        else:\n-            return status.create_status(\n-                status.STATUS_PHASE.TERMINATING, \"Notebook Server is stopping.\"\n-            )\n+    creationTimestamp = notebook[\"metadata\"][\"creationTimestamp\"]\n \n-    # If the Notebook is being deleted, the status will be waiting\n-    if \"deletionTimestamp\" in metadata:\n-        return status.create_status(\n-            status.STATUS_PHASE.TERMINATING, \"Deleting this notebook server\"\n-        )\n-\n-    # Check the status\n-    state = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n-\n-    # Use conditions on the Jupyter notebook (i.e., s) to determine overall\n-    # status. If no container state is available, we try to extract information\n-    # about why the notebook is not starting from the notebook's events\n-    # (see find_error_event)\n-    if readyReplicas == 1:\n-        return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n-\n-    if \"waiting\" in state:\n-        return status.create_status(\n-            status.STATUS_PHASE.WAITING, state[\"waiting\"][\"reason\"]\n-        )\n-\n-    # Provide the user with detailed information (if any) about\n-    # why the notebook is not starting\n-    notebook_events = get_notebook_events(notebook)\n-    status_val, reason = status.STATUS_PHASE.WAITING, \"Scheduling the Pod\"\n-    status_event, reason_event = find_error_event(notebook_events)\n-    if status_event is not None:\n-        status_val, reason = status_event, reason_event\n-\n-    return status.create_status(status_val, reason)\n+    # Convert a date string of a format to datetime object\n+    nb_creation_time = dt.datetime.strptime(\n+        creationTimestamp, \"%Y-%m-%dT%H:%M:%SZ\")\n+    current_time = dt.datetime.utcnow().replace(microsecond=0)\n+    delta = (current_time - nb_creation_time)\n+\n+    while delta.total_seconds() <= 10:\n+        status_val, reason = status.STATUS_PHASE.WAITING, \"Waiting for StatefulSet to create the underlying Pod.\"\n+\n+        # Check if the Notebook is stopped or deleted\n+        status_phase, status_message = check_stopped_deleted_nb(notebook)\n+        if status_phase is not None:\n+            status_val, reason = status_phase, status_message\n+\n+        return status.create_status(status_val, reason)\n+    else:\n+        # Check if the Notebook is stopped or deleted\n+        status_phase, status_message = check_stopped_deleted_nb(notebook)\n+        if status_phase is not None:\n+            status_val, reason = status_phase, status_message\n+            return status.create_status(status_val, reason)\n+\n+        # If the Notebook is running, the status will be ready\n+        if readyReplicas == 1:\n+            return status.create_status(status.STATUS_PHASE.READY, \"Running\")\n+\n+        # Otherwise, first check .status.containerState to determine the status\n+        # reason and message to determine the status\n+        containerState = notebook.get(\"status\", {}).get(\"containerState\", \"\")\n+\n+        if \"waiting\" in containerState:\n+            if containerState[\"waiting\"][\"reason\"] == 'PodInitializing':\n+                return status.create_status(\n+                    status.STATUS_PHASE.WAITING, containerState[\"waiting\"][\"reason\"]\n+                )\n+            else:\n+                return status.create_status(\n+                    status.STATUS_PHASE.WARNING, containerState[\"waiting\"][\"reason\"] +\n+                    ': ' + containerState[\"waiting\"][\"message\"]\n+                )\n+\n+        # If no containerState is available, check .status.conditions, since they have\n+        # a reason and a message to determine the status\n+        conditions = notebook.get(\"status\", {}).get(\"conditions\", \"\")\n+\n+        for condition in conditions:\n+            for item in condition:\n+                if \"reason\" in item:",
        "comment_created_at": "2023-03-23T11:40:47+00:00",
        "comment_author": "kimwnasptd",
        "comment_body": "We can simplify this and remove the `for` loop for the `item` var.\r\n\r\nThe `coditions` are a list of dict objects. We only need to iterate over each condition dict, from the list, and check if that condition object contains the `reason` key",
        "pr_file_module": null
      }
    ]
  }
]