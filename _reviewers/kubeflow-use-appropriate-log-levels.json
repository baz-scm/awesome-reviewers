[
  {
    "discussion_id": "1165424028",
    "pr_number": 7091,
    "pr_file": "components/profile-controller/controllers/plugin_ad_workload_identity_azure.go",
    "created_at": "2023-04-13T12:03:03+00:00",
    "commented_code": "/*\nCopyright 2019 The Kubeflow Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage controllers\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/go-logr/logr\"\n\tprofilev1 \"github.com/kubeflow/kubeflow/components/profile-controller/api/v1\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n)\n\nconst (\n\tKIND_AZURE_AD_WORKLOAD_IDENTITY = \"AzureAdWorkloadIdentity\"\n\tAD_DEFAULT_SERVICE_ACCOUNT      = DEFAULT_EDITOR\n\tAZURE_CLIENT_ID_ANNOTATION_KEY  = \"azure.workload.identity/client-id\"\n\tAZURE_TENANT_ID_ANNOTATION_KEY  = \"azure.workload.identity/tenant-id\"\n\n\tAZURE_SA_TOKEN_EXPIRATION_ANNOTATION_KEY = \"azure.workload.identity/service-account-token-expiration\"\n\n\tAZURE_WORKLOAD_IDENTITY_POD_ANNOTATION = \"azure.workload.identity/use\"\n)\n\n// AzureAdWorkloadIdentity: plugin that setup Azure AD workload identity for target profile namespace\ntype AzureAdWorkloadIdentity struct {\n\tAzureIdentityClientId              string `json:\"identityClientId,omitempty\"`\n\tAzureIdentityTenantId              string `json:\"identityTenantId,omitempty\"`\n\tAzureServiceAccountTokenExpiration string `json:\"serviceAccountTokenExpiration,omitempty\"`\n}\n\n// ApplyPlugin will grant Azure workload identity to service account DEFAULT_EDITOR\nfunc (azure *AzureAdWorkloadIdentity) ApplyPlugin(r *ProfileReconciler, profile *profilev1.Profile) error {\n\tlogger := r.Log.WithValues(\"profile\", profile.Name)\n\n\tlogger.Info(\"Setting up workload identity\", \"ClientId\", azure.AzureIdentityClientId)",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "1165424028",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 7091,
        "pr_file": "components/profile-controller/controllers/plugin_ad_workload_identity_azure.go",
        "discussion_id": "1165424028",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+Copyright 2019 The Kubeflow Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package controllers\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\n+\t\"github.com/go-logr/logr\"\n+\tprofilev1 \"github.com/kubeflow/kubeflow/components/profile-controller/api/v1\"\n+\tcorev1 \"k8s.io/api/core/v1\"\n+\t\"k8s.io/apimachinery/pkg/types\"\n+)\n+\n+const (\n+\tKIND_AZURE_AD_WORKLOAD_IDENTITY = \"AzureAdWorkloadIdentity\"\n+\tAD_DEFAULT_SERVICE_ACCOUNT      = DEFAULT_EDITOR\n+\tAZURE_CLIENT_ID_ANNOTATION_KEY  = \"azure.workload.identity/client-id\"\n+\tAZURE_TENANT_ID_ANNOTATION_KEY  = \"azure.workload.identity/tenant-id\"\n+\n+\tAZURE_SA_TOKEN_EXPIRATION_ANNOTATION_KEY = \"azure.workload.identity/service-account-token-expiration\"\n+\n+\tAZURE_WORKLOAD_IDENTITY_POD_ANNOTATION = \"azure.workload.identity/use\"\n+)\n+\n+// AzureAdWorkloadIdentity: plugin that setup Azure AD workload identity for target profile namespace\n+type AzureAdWorkloadIdentity struct {\n+\tAzureIdentityClientId              string `json:\"identityClientId,omitempty\"`\n+\tAzureIdentityTenantId              string `json:\"identityTenantId,omitempty\"`\n+\tAzureServiceAccountTokenExpiration string `json:\"serviceAccountTokenExpiration,omitempty\"`\n+}\n+\n+// ApplyPlugin will grant Azure workload identity to service account DEFAULT_EDITOR\n+func (azure *AzureAdWorkloadIdentity) ApplyPlugin(r *ProfileReconciler, profile *profilev1.Profile) error {\n+\tlogger := r.Log.WithValues(\"profile\", profile.Name)\n+\n+\tlogger.Info(\"Setting up workload identity\", \"ClientId\", azure.AzureIdentityClientId)",
        "comment_created_at": "2023-04-13T12:03:03+00:00",
        "comment_author": "AhmedGrati",
        "comment_body": "I think that, preferably, log messages should start in lowercase.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "491869454",
    "pr_number": 5314,
    "pr_file": "components/notebook-controller/controllers/notebook_controller.go",
    "created_at": "2020-09-21T08:29:05+00:00",
    "commented_code": "} else {\n\t\t// Got the pod\n\t\tpodFound = true\n\t\tif len(pod.Status.ContainerStatuses) > 0 &&\n\t\t\tpod.Status.ContainerStatuses[0].State != instance.Status.ContainerState {\n\t\t\tlog.Info(\"Updating container state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n\t\t\tcs := pod.Status.ContainerStatuses[0].State\n\t\t\tinstance.Status.ContainerState = cs\n\t\t\toldConditions := instance.Status.Conditions\n\t\t\tnewCondition := getNextCondition(cs)\n\t\t\t// Append new condition\n\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n\t\t\t\toldConditions[0].Message != newCondition.Message {\n\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n\n\t\tif len(pod.Status.ContainerStatuses) > 0 {\n\t\t\tnotebookContainerFound := false\n\t\t\tfor i := range pod.Status.ContainerStatuses {\n\t\t\t\tif pod.Status.ContainerStatuses[i].Name == instance.Name &&\n\t\t\t\t\tpod.Status.ContainerStatuses[i].State != instance.Status.ContainerState {\n\t\t\t\t\tlog.Info(\"Updating Notebook CR state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n\t\t\t\t\tcs := pod.Status.ContainerStatuses[i].State\n\t\t\t\t\tinstance.Status.ContainerState = cs\n\t\t\t\t\toldConditions := instance.Status.Conditions\n\t\t\t\t\tnewCondition := getNextCondition(cs)\n\t\t\t\t\t// Append new condition\n\t\t\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n\t\t\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n\t\t\t\t\t\toldConditions[0].Message != newCondition.Message {\n\t\t\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n\t\t\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n\t\t\t\t\t}\n\t\t\t\t\terr = r.Status().Update(ctx, instance)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctrl.Result{}, err\n\t\t\t\t\t}\n\t\t\t\t\tnotebookContainerFound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = r.Status().Update(ctx, instance)\n\t\t\tif err != nil {\n\t\t\t\treturn ctrl.Result{}, err\n\t\t\tif !notebookContainerFound {\n\t\t\t\tlog.Info(\"WARNING: Notebook container is not found, so could not update State of Notebook CR\")",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "491869454",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5314,
        "pr_file": "components/notebook-controller/controllers/notebook_controller.go",
        "discussion_id": "491869454",
        "commented_code": "@@ -206,23 +206,34 @@ func (r *NotebookReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {\n \t} else {\n \t\t// Got the pod\n \t\tpodFound = true\n-\t\tif len(pod.Status.ContainerStatuses) > 0 &&\n-\t\t\tpod.Status.ContainerStatuses[0].State != instance.Status.ContainerState {\n-\t\t\tlog.Info(\"Updating container state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n-\t\t\tcs := pod.Status.ContainerStatuses[0].State\n-\t\t\tinstance.Status.ContainerState = cs\n-\t\t\toldConditions := instance.Status.Conditions\n-\t\t\tnewCondition := getNextCondition(cs)\n-\t\t\t// Append new condition\n-\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n-\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n-\t\t\t\toldConditions[0].Message != newCondition.Message {\n-\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n-\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\n+\t\tif len(pod.Status.ContainerStatuses) > 0 {\n+\t\t\tnotebookContainerFound := false\n+\t\t\tfor i := range pod.Status.ContainerStatuses {\n+\t\t\t\tif pod.Status.ContainerStatuses[i].Name == instance.Name &&\n+\t\t\t\t\tpod.Status.ContainerStatuses[i].State != instance.Status.ContainerState {\n+\t\t\t\t\tlog.Info(\"Updating Notebook CR state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n+\t\t\t\t\tcs := pod.Status.ContainerStatuses[i].State\n+\t\t\t\t\tinstance.Status.ContainerState = cs\n+\t\t\t\t\toldConditions := instance.Status.Conditions\n+\t\t\t\t\tnewCondition := getNextCondition(cs)\n+\t\t\t\t\t// Append new condition\n+\t\t\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n+\t\t\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n+\t\t\t\t\t\toldConditions[0].Message != newCondition.Message {\n+\t\t\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n+\t\t\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\t\t\t\t\t}\n+\t\t\t\t\terr = r.Status().Update(ctx, instance)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn ctrl.Result{}, err\n+\t\t\t\t\t}\n+\t\t\t\t\tnotebookContainerFound = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = r.Status().Update(ctx, instance)\n-\t\t\tif err != nil {\n-\t\t\t\treturn ctrl.Result{}, err\n+\t\t\tif !notebookContainerFound {\n+\t\t\t\tlog.Info(\"WARNING: Notebook container is not found, so could not update State of Notebook CR\")",
        "comment_created_at": "2020-09-21T08:29:05+00:00",
        "comment_author": "yanniszark",
        "comment_body": "I don't think that a log.Info should emit a `WARNING` message.\r\nIf the message is indeed a warning, use `log.Warn`.\r\nThis sounds like an error though.",
        "pr_file_module": null
      },
      {
        "comment_id": "491884574",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5314,
        "pr_file": "components/notebook-controller/controllers/notebook_controller.go",
        "discussion_id": "491869454",
        "commented_code": "@@ -206,23 +206,34 @@ func (r *NotebookReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {\n \t} else {\n \t\t// Got the pod\n \t\tpodFound = true\n-\t\tif len(pod.Status.ContainerStatuses) > 0 &&\n-\t\t\tpod.Status.ContainerStatuses[0].State != instance.Status.ContainerState {\n-\t\t\tlog.Info(\"Updating container state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n-\t\t\tcs := pod.Status.ContainerStatuses[0].State\n-\t\t\tinstance.Status.ContainerState = cs\n-\t\t\toldConditions := instance.Status.Conditions\n-\t\t\tnewCondition := getNextCondition(cs)\n-\t\t\t// Append new condition\n-\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n-\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n-\t\t\t\toldConditions[0].Message != newCondition.Message {\n-\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n-\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\n+\t\tif len(pod.Status.ContainerStatuses) > 0 {\n+\t\t\tnotebookContainerFound := false\n+\t\t\tfor i := range pod.Status.ContainerStatuses {\n+\t\t\t\tif pod.Status.ContainerStatuses[i].Name == instance.Name &&\n+\t\t\t\t\tpod.Status.ContainerStatuses[i].State != instance.Status.ContainerState {\n+\t\t\t\t\tlog.Info(\"Updating Notebook CR state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n+\t\t\t\t\tcs := pod.Status.ContainerStatuses[i].State\n+\t\t\t\t\tinstance.Status.ContainerState = cs\n+\t\t\t\t\toldConditions := instance.Status.Conditions\n+\t\t\t\t\tnewCondition := getNextCondition(cs)\n+\t\t\t\t\t// Append new condition\n+\t\t\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n+\t\t\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n+\t\t\t\t\t\toldConditions[0].Message != newCondition.Message {\n+\t\t\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n+\t\t\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\t\t\t\t\t}\n+\t\t\t\t\terr = r.Status().Update(ctx, instance)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn ctrl.Result{}, err\n+\t\t\t\t\t}\n+\t\t\t\t\tnotebookContainerFound = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = r.Status().Update(ctx, instance)\n-\t\t\tif err != nil {\n-\t\t\t\treturn ctrl.Result{}, err\n+\t\t\tif !notebookContainerFound {\n+\t\t\t\tlog.Info(\"WARNING: Notebook container is not found, so could not update State of Notebook CR\")",
        "comment_created_at": "2020-09-21T08:55:09+00:00",
        "comment_author": "kimwnasptd",
        "comment_body": "I agree with @yanniszark.\r\nAlthough AFAIK `logr` does not have a [Warning level](https://github.com/go-logr/logr#why-not-more-named-levels-like-warning). So we should do this an Error instead.\r\n\r\n@gilbeckers could you also make the error message more explicit as to why it couldn't find the Notebook Container? Something like: `Could not find the Notebook container. No container has the same name with the CR '{notebook-name}'. Will not update the status of the CR.`",
        "pr_file_module": null
      },
      {
        "comment_id": "492286533",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 5314,
        "pr_file": "components/notebook-controller/controllers/notebook_controller.go",
        "discussion_id": "491869454",
        "commented_code": "@@ -206,23 +206,34 @@ func (r *NotebookReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {\n \t} else {\n \t\t// Got the pod\n \t\tpodFound = true\n-\t\tif len(pod.Status.ContainerStatuses) > 0 &&\n-\t\t\tpod.Status.ContainerStatuses[0].State != instance.Status.ContainerState {\n-\t\t\tlog.Info(\"Updating container state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n-\t\t\tcs := pod.Status.ContainerStatuses[0].State\n-\t\t\tinstance.Status.ContainerState = cs\n-\t\t\toldConditions := instance.Status.Conditions\n-\t\t\tnewCondition := getNextCondition(cs)\n-\t\t\t// Append new condition\n-\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n-\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n-\t\t\t\toldConditions[0].Message != newCondition.Message {\n-\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n-\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\n+\t\tif len(pod.Status.ContainerStatuses) > 0 {\n+\t\t\tnotebookContainerFound := false\n+\t\t\tfor i := range pod.Status.ContainerStatuses {\n+\t\t\t\tif pod.Status.ContainerStatuses[i].Name == instance.Name &&\n+\t\t\t\t\tpod.Status.ContainerStatuses[i].State != instance.Status.ContainerState {\n+\t\t\t\t\tlog.Info(\"Updating Notebook CR state: \", \"namespace\", instance.Namespace, \"name\", instance.Name)\n+\t\t\t\t\tcs := pod.Status.ContainerStatuses[i].State\n+\t\t\t\t\tinstance.Status.ContainerState = cs\n+\t\t\t\t\toldConditions := instance.Status.Conditions\n+\t\t\t\t\tnewCondition := getNextCondition(cs)\n+\t\t\t\t\t// Append new condition\n+\t\t\t\t\tif len(oldConditions) == 0 || oldConditions[0].Type != newCondition.Type ||\n+\t\t\t\t\t\toldConditions[0].Reason != newCondition.Reason ||\n+\t\t\t\t\t\toldConditions[0].Message != newCondition.Message {\n+\t\t\t\t\t\tlog.Info(\"Appending to conditions: \", \"namespace\", instance.Namespace, \"name\", instance.Name, \"type\", newCondition.Type, \"reason\", newCondition.Reason, \"message\", newCondition.Message)\n+\t\t\t\t\t\tinstance.Status.Conditions = append([]v1beta1.NotebookCondition{newCondition}, oldConditions...)\n+\t\t\t\t\t}\n+\t\t\t\t\terr = r.Status().Update(ctx, instance)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn ctrl.Result{}, err\n+\t\t\t\t\t}\n+\t\t\t\t\tnotebookContainerFound = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n-\t\t\terr = r.Status().Update(ctx, instance)\n-\t\t\tif err != nil {\n-\t\t\t\treturn ctrl.Result{}, err\n+\t\t\tif !notebookContainerFound {\n+\t\t\t\tlog.Info(\"WARNING: Notebook container is not found, so could not update State of Notebook CR\")",
        "comment_created_at": "2020-09-21T19:11:06+00:00",
        "comment_author": "gilbeckers",
        "comment_body": "Done :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "320260335",
    "pr_number": 4040,
    "pr_file": "bootstrap/pkg/kfapp/apply/apply.go",
    "created_at": "2019-09-03T13:06:07+00:00",
    "commented_code": "package apply\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\tkftypes \"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/apis/apps\"\n\tkfdefsv3 \"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/apis/apps/kfdef/v1alpha1\"\n\t\"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/kfapp/coordinator\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// BootstrapKubeflow is used by the kfctl apply sub-command to take in a configfile\n// as a flag and boostrap a KfApp and deploy it\nfunc BootstrapKubeflow(configFilePath string, kfResource kftypes.ResourceEnum) error {\n\t// Set default app name to kf-app\n\tappName := \"kf-app\"\n\n\t// Construct KfDef from the configFilePath provided\n\tkfDef := &kfdefsv3.KfDef{}\n\tkfDef, err := kfdefsv3.LoadKFDefFromURI(configFilePath)\n\tif err != nil {\n\t\tlog.Printf(\"Unable to create KfDef from config file: %v\", err)\n\t}\n\tif kfDef.Name != \"\" {\n\t\tlog.Warnf(\"Overriding KfDef.Spec.Name; old value %v; new value %v\", kfDef.Name, appName)\n\t}\n\tkfDef.Name = appName\n\tisValid, msg := kfDef.IsValid()\n\tif !isValid {\n\t\tlog.Printf(\"Invalid kfdef: %v\", isValid)\n\t\tlog.Printf(\"Error validating generated KfDef, please check config file validity: %v\", msg)\n\t}\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Printf(\"Error getting current working directory: %v\", err)\n\t}\n\tfmt.Println(\"Present working directory is: %v\", cwd)",
    "repo_full_name": "kubeflow/kubeflow",
    "discussion_comments": [
      {
        "comment_id": "320260335",
        "repo_full_name": "kubeflow/kubeflow",
        "pr_number": 4040,
        "pr_file": "bootstrap/pkg/kfapp/apply/apply.go",
        "discussion_id": "320260335",
        "commented_code": "@@ -0,0 +1,103 @@\n+package apply\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\n+\tkftypes \"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/apis/apps\"\n+\tkfdefsv3 \"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/apis/apps/kfdef/v1alpha1\"\n+\t\"github.com/kubeflow/kubeflow/bootstrap/v3/pkg/kfapp/coordinator\"\n+\tlog \"github.com/sirupsen/logrus\"\n+)\n+\n+// BootstrapKubeflow is used by the kfctl apply sub-command to take in a configfile\n+// as a flag and boostrap a KfApp and deploy it\n+func BootstrapKubeflow(configFilePath string, kfResource kftypes.ResourceEnum) error {\n+\t// Set default app name to kf-app\n+\tappName := \"kf-app\"\n+\n+\t// Construct KfDef from the configFilePath provided\n+\tkfDef := &kfdefsv3.KfDef{}\n+\tkfDef, err := kfdefsv3.LoadKFDefFromURI(configFilePath)\n+\tif err != nil {\n+\t\tlog.Printf(\"Unable to create KfDef from config file: %v\", err)\n+\t}\n+\tif kfDef.Name != \"\" {\n+\t\tlog.Warnf(\"Overriding KfDef.Spec.Name; old value %v; new value %v\", kfDef.Name, appName)\n+\t}\n+\tkfDef.Name = appName\n+\tisValid, msg := kfDef.IsValid()\n+\tif !isValid {\n+\t\tlog.Printf(\"Invalid kfdef: %v\", isValid)\n+\t\tlog.Printf(\"Error validating generated KfDef, please check config file validity: %v\", msg)\n+\t}\n+\tcwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tlog.Printf(\"Error getting current working directory: %v\", err)\n+\t}\n+\tfmt.Println(\"Present working directory is: %v\", cwd)",
        "comment_created_at": "2019-09-03T13:06:07+00:00",
        "comment_author": "yanniszark",
        "comment_body": "Can you use log instead of fmt and change all instances of Println to a log-level function? (eg Info, Warn).",
        "pr_file_module": null
      }
    ]
  }
]