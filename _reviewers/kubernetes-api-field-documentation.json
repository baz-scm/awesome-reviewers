[
  {
    "discussion_id": "2208705536",
    "pr_number": 132522,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-07-15T21:18:17+00:00",
    "commented_code": "type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2208705536",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208705536",
        "commented_code": "@@ -348,11 +366,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
        "comment_created_at": "2025-07-15T21:18:17+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "Note for future (1.35+): I expect we will see a lot of duplication here - the same set of defined policies used over and over for devices in a ResourceSlice (more so even in a resource pool). We may end up wanting to \"name\" a policy, list it once in a ResourceSlice, and then refer to it here (similar to mixins). Along those lines we should make sure we are able to modify `CapacitySharingPolicy` to be a named reference rather than an inline struct in a future release, should we deem it necessary. I think that can be done with the code as written - it's possible in our API evolution rules to switch Default to a pointer and make it optional in a future release, I believe. @pohly is that true?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2210462446",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208705536",
        "commented_code": "@@ -348,11 +366,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
        "comment_created_at": "2025-07-16T13:35:33+00:00",
        "comment_author": "pohly",
        "comment_body": "So the question is about the content of `CapacitySharingPolicy`? We can make `CapacitySharingPolicy.Default resource.Quantity` (currently required) a pointer and optional and mutually exclusive with a new `CapacitySharingPolicy.Name *string`, but then we also should not allow the other fields. I think this interdependency between fields is frowned upon.\r\n\r\nA better approach would be to add an alternative to `SharingPolicy *CapacitySharingPolicy` here, something like `SharingPolicyRef *string` or `SharingPolicyName *string`. But naming is hard: the API convention is that `*Ref` is for a full-blown reference to some external resource, and `*Name` is for resources of a certain type, referenced by their name. I don't have a good proposal.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2216648362",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208705536",
        "commented_code": "@@ -348,11 +366,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
        "comment_created_at": "2025-07-18T18:21:59+00:00",
        "comment_author": "liggitt",
        "comment_body": "> it's possible in our API evolution rules to switch Default to a pointer and make it optional in a future release, I believe.\r\n\r\nMaking a previously required field optional would have weird implications for any clients assuming that field always has a value.\r\n\r\nIt looks like the mixins PR has `Capacity map[QualifiedName]DeviceCapacity` as a mixin... that would allow deduplicating identical capacity entries as a mixin. Do you think it will be common to need to define capacity local to the device, but reference a common sharing policy?",
        "pr_file_module": null
      },
      {
        "comment_id": "2225980457",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208705536",
        "commented_code": "@@ -348,11 +366,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
        "comment_created_at": "2025-07-23T15:34:54+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "In general we will have many devices that are both \"shaped\" the same and \"consumed\" in the same way. I would *expect* it to be rare to have individual devices override those shapes with respect to capacity. It will be common for them to override those shapes with respect to attributes (to add a name or UUID, etc.).",
        "pr_file_module": null
      },
      {
        "comment_id": "2225984220",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208705536",
        "commented_code": "@@ -348,11 +366,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.\n+\t//\n \t// +required\n \tValue resource.Quantity\n \n-\t// potential future addition: fields which define how to \"consume\"\n-\t// capacity (= share a single device between different consumers).\n+\t// SharingPolicy specifies that this device capacity must be consumed\n+\t// by each resource claim according to the defined sharing policy.\n+\t// The Device must have AllowMultipleAllocations set to true.\n+\t//\n+\t// If this field is unset, capacity sharing is unconstrained.\n+\t// All ResourceClaims or requests share the same capacity pool.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tSharingPolicy *CapacitySharingPolicy",
        "comment_created_at": "2025-07-23T15:36:07+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "I think now that Default is optional and a pointer, you can resolve this comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2208740327",
    "pr_number": 132522,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-07-15T21:30:16+00:00",
    "commented_code": "// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2208740327",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-15T21:30:16+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "So what we have here is:\r\n\r\n```yaml\r\napiVersion: resource.k8s.io/v1beta2\r\nkind: ResourceClaimTemplate\r\nmetadata:\r\n  name: example-resource-claim-template\r\nspec:\r\n  spec:\r\n    devices:\r\n      requests:\r\n      - name: device-claim\r\n        exactly:\r\n          deviceClassName: \"mydevice.example.com\"\r\n          capacityRequests:\r\n            minimum:\r\n              memory: 64Gi\r\n              bandwidth: 2M\r\n```\r\n\r\nIf on other hand, we aligned the terminology with the container spec, it would look like:\r\n\r\n```yaml\r\napiVersion: resource.k8s.io/v1beta2\r\nkind: ResourceClaimTemplate\r\nmetadata:\r\n  name: example-resource-claim-template\r\nspec:\r\n  spec:\r\n    devices:\r\n      requests:\r\n      - name: device-claim\r\n        exactly:\r\n          deviceClassName: \"mydevice.example.com\"\r\n          resources:\r\n            requests:\r\n              memory: 64Gi\r\n              bandwidth: 2M\r\n```\r\n\r\nHonestly that doesn't look bad to me? The \"requests is already used for device requests\" doesn't seem particularly confusing to me. But maybe I am too close to it. I would defer to @liggitt / api-reviewers.",
        "pr_file_module": null
      },
      {
        "comment_id": "2211618963",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-16T21:10:12+00:00",
        "comment_author": "liggitt",
        "comment_body": "I'm not steeped in the API, so the double `requests` took me a minute, but proximity to the parent field might make it ok...\r\n\r\n```\r\ndevices:\r\n  requests: # these are requests for devices?\r\n  ...\r\n    resources:\r\n      requests: # these are requests for resources?\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2211627500",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-16T21:15:24+00:00",
        "comment_author": "liggitt",
        "comment_body": "if the semantic matches how `requests` is used elsewhere in the API (minimum guaranteed, must be satisfied) that seems slightly better than inventing a new field name for basically the same thing",
        "pr_file_module": null
      },
      {
        "comment_id": "2211728278",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-16T22:27:33+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "yes, exactly",
        "pr_file_module": null
      },
      {
        "comment_id": "2211729110",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-16T22:27:58+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "(resources per device)",
        "pr_file_module": null
      },
      {
        "comment_id": "2211776416",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-16T22:59:27+00:00",
        "comment_author": "johnbelamaric",
        "comment_body": "my \"yes exactly\" was not in response to the \"semantic matches\" question, I think the comments came in later.\r\n\r\nI think though it is true, they are a minimum, and they are guaranteed",
        "pr_file_module": null
      },
      {
        "comment_id": "2212772645",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-17T09:02:56+00:00",
        "comment_author": "pohly",
        "comment_body": "I'm okay with\r\n```\r\ndevices:\r\n  requests: # for devices\r\n  ...\r\n    resources:\r\n      requests: # for resources which must be provided by those devices\r\n ```\r\n \r\n I was worried about potential confusion when explaining the API, but that can be addressed by clearly distinguishing which kind of requests are meant.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2214676272",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-18T01:34:51+00:00",
        "comment_author": "sunya-ch",
        "comment_body": "It seems that I can change back to `requests` with more clarification to differentiate between requests for devices and requests for resources which must be provided by devices.\r\nWhen we consider this capacity request must be guaranteed. Is that mean we should skip the device which capacity has no sharingPolicy to guarantee the resource? With the current KEP, we mention that it still allows allocation even if there is no sharingPolicy. Can I reinterpret as follows?\r\n\r\nonly allowMultipleAllocations => Not guaranteed - not selectable\r\nallowMultipleAllocations + sharingPolicy => Guaranteed - selectable\r\nwithout allowMultipleAllocations => Guaranteed (requests must be less than defined capacity value) - selectable\r\n \r\nNote that, there is no case of sharingPolicy without allowMultipleAllocations (validation will throw failure).",
        "pr_file_module": null
      },
      {
        "comment_id": "2214873863",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-18T04:35:20+00:00",
        "comment_author": "liggitt",
        "comment_body": "> only allowMultipleAllocations => Not guaranteed - not selectable\r\n\r\nDoes this case mean \"device has allowMultipleAllocations=true, defines some capacity, but doesn't define a sharing policy\"?\r\n\r\n> Is that mean we should skip the device which capacity has no sharingPolicy to guarantee the resource?\r\n\r\nMaybe I'm missing something, but the sharing policy on its own doesn't do anything outside of scheduling, the DRA driver must have visibility to the capacity consumed by each request (either because it was explicitly requested, or was defaulted or stepped up to an allowed value by the sharing policy), right? It seems like it has to in order to make the right capacity available to that claim. Isn't it the driver's job to configure and protect the capacity consumed by each request?\r\n\r\nIf it's a capacity that can be protected / prioritized (like the kubelet does for memory to allow burstable containers that get oom-killed under pressure before guaranteed containers), then operating without a sharing policy could make sense. If it's a capacity that the driver cannot set up that way, then a sharing policy with a default or minimum is probably required to force every claim to consume a specific amount of the capacity.",
        "pr_file_module": null
      },
      {
        "comment_id": "2217115443",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2208740327",
        "commented_code": "@@ -825,6 +954,40 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Minimum defines the minimum amount of each device capacity required for the request.\n+\t//\n+\t// If the capacity has a sharing policy, this value is rounded up to the nearest valid amount\n+\t// according to that policy. The rounded value is used during scheduling to determine how much capacity to consume.\n+\t//\n+\t// If the quantity does not have a sharing policy, this value is used as an additional filtering\n+\t// condition against the available capacity on the device.\n+\t// This is semantically equivalent to a CEL selector with\n+\t// `device.capacity[<domain>].<name>.compareTo(quantity(<minimum quantity>)) >= 0`\n+\t// For example, device.capacity['test-driver.cdi.k8s.io'].counters.compareTo(quantity('2')) >= 0\n+\t//\n+\t// +optional\n+\tMinimum map[QualifiedName]resource.Quantity\n+\n+\t// ^^^\n+\t// The alternative names proposed were: `Required`, `Reservation`, `Consumption`, and `Requests`.\n+\t// `Requests` was dropped since it's already used in the DRA API for device requests.",
        "comment_created_at": "2025-07-19T03:04:02+00:00",
        "comment_author": "sunya-ch",
        "comment_body": "I think I was confused with the term guarantee mentioned above about requests term. Does it mean guarantee the total capacity is enough for request or guarantee the total allocation?\n\nIf the capacityRequests defined as a resource request amount that the total claimed resource will never be more than the total capacity, the DeviceCapacity without guaranteed sharing policy may not satisfy this condition.\n\nHowever, if it is just a minimum amount that the claim requests regardless of total claimed resource (allow overcommit if no sharing policy defined), I will change the logic back to allow the case that allowMultipleAllocations without sharingPolicy. If the sharingPolicy defined, the scheduler can consume the capacity following the policy and can guarantee not overcommit on shared device allocation part. This is what we design first in the KEP.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214680397",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-18T01:36:46+00:00",
    "commented_code": "// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration `json:\"tolerations,omitempty\" protobuf:\"bytes,6,opt,name=tolerations\"`\n+\n+\t// CapacityRequests define resource requirements against each capacity.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2214680397",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2214680397",
        "commented_code": "@@ -739,6 +856,15 @@ type ExactDeviceRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration `json:\"tolerations,omitempty\" protobuf:\"bytes,6,opt,name=tolerations\"`\n+\n+\t// CapacityRequests define resource requirements against each capacity.",
        "comment_created_at": "2025-07-18T01:36:46+00:00",
        "comment_author": "liggitt",
        "comment_body": "document how this interacts with `Count` when `Count` is > 1 ... are these capacityRequests per device or across devices?\r\n\r\ndocument how this interacts with allocationMode=All ... does this select all matching devices, then fail allocation if any of them cannot satisfy the capacityRequests, or does it select all matching devices which can satisfy the capacityRequests?\r\n\r\n(same clarifications needed on DeviceSubRequests)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214878683",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-18T04:40:39+00:00",
    "commented_code": "// Device references one device instance via its name in the driver's\n \t// resource pool. It must be a DNS label.\n \t//\n+\t// If the allocation result includes a ShareID, the Device field is extended with the ShareID,\n+\t// formatted as `<device name>/<share id>`.\n+\t//\n \t// +required\n \tDevice string `json:\"device\" protobuf:\"bytes,3,rep,name=device\"`\n \n+\t// ^^^\n+\t// ShareID cannot be added here in the same way as in DeviceRequestAllocationResult,\n+\t// because it is intended to serve as part of a composite key for identifying devices.\n+\t// Making ShareID required is not an option, as the API feature gate should not introduce required fields.\n+\t// However, due to limitations with using `listType=map` in ResourceClaimStatus.Devices,",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2214878683",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2214878683",
        "commented_code": "@@ -1493,9 +1712,20 @@ type AllocatedDeviceStatus struct {\n \t// Device references one device instance via its name in the driver's\n \t// resource pool. It must be a DNS label.\n \t//\n+\t// If the allocation result includes a ShareID, the Device field is extended with the ShareID,\n+\t// formatted as `<device name>/<share id>`.\n+\t//\n \t// +required\n \tDevice string `json:\"device\" protobuf:\"bytes,3,rep,name=device\"`\n \n+\t// ^^^\n+\t// ShareID cannot be added here in the same way as in DeviceRequestAllocationResult,\n+\t// because it is intended to serve as part of a composite key for identifying devices.\n+\t// Making ShareID required is not an option, as the API feature gate should not introduce required fields.\n+\t// However, due to limitations with using `listType=map` in ResourceClaimStatus.Devices,",
        "comment_created_at": "2025-07-18T04:40:39+00:00",
        "comment_author": "liggitt",
        "comment_body": "the listMap issue is now fixed, so the distinct optional `ShareID *string` field can be used (and is preferred)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1961398788",
    "pr_number": 130160,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta1/types.go",
    "created_at": "2025-02-19T10:31:50+00:00",
    "commented_code": "//\n \t// +optional\n \tNetworkData *NetworkDeviceData `json:\"networkData,omitempty\" protobuf:\"bytes,6,opt,name=networkData\"`\n+\n+\t// UsageRestrictedToNode is a copy of the UsageRestrictedToNode\n+\t// as defined for the device at the time when it was allocated.\n+\t// If true, the node selector of the allocation matches exactly\n+\t// the node that was chosen for the pod which triggered allocation.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode bool `json:\"usageRestrictedToNode,omitempty\" protobuf:\"bytes,7,opt,name=usageRestrictedToNode\"`\n+\n+\t// BindingConditions is a copy of the BindingConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// All of these conditions must be to True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t//\n+\t// +optional\n+\tBindingConditions []string `json:\"bindingConditions,omitempty\" protobuf:\"bytes,8,opt,name=bindingConditions\"`\n+\n+\t// BindingFailureConditions is a copy of the BindingFailureConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// If any is True, a binding failure occurred.\n+\t//\n+\t// +optional\n+\tBindingFailureConditions []string `json:\"bindingFailureConditions,omitempty\" protobuf:\"bytes,9,opt,name=bindingFailureConditions\"`\n+\n+\t// BindingTimeout is a copy of the BindingTimeout\n+\t// as defined for the device at the time when it was allocated.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration `json:\"bindingTimeout,omitempty\" protobuf:\"bytes,10,opt,name=bindingTimeout\"`",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "1961398788",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta1/types.go",
        "discussion_id": "1961398788",
        "commented_code": "@@ -1055,6 +1091,39 @@ type AllocatedDeviceStatus struct {\n \t//\n \t// +optional\n \tNetworkData *NetworkDeviceData `json:\"networkData,omitempty\" protobuf:\"bytes,6,opt,name=networkData\"`\n+\n+\t// UsageRestrictedToNode is a copy of the UsageRestrictedToNode\n+\t// as defined for the device at the time when it was allocated.\n+\t// If true, the node selector of the allocation matches exactly\n+\t// the node that was chosen for the pod which triggered allocation.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode bool `json:\"usageRestrictedToNode,omitempty\" protobuf:\"bytes,7,opt,name=usageRestrictedToNode\"`\n+\n+\t// BindingConditions is a copy of the BindingConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// All of these conditions must be to True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t//\n+\t// +optional\n+\tBindingConditions []string `json:\"bindingConditions,omitempty\" protobuf:\"bytes,8,opt,name=bindingConditions\"`\n+\n+\t// BindingFailureConditions is a copy of the BindingFailureConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// If any is True, a binding failure occurred.\n+\t//\n+\t// +optional\n+\tBindingFailureConditions []string `json:\"bindingFailureConditions,omitempty\" protobuf:\"bytes,9,opt,name=bindingFailureConditions\"`\n+\n+\t// BindingTimeout is a copy of the BindingTimeout\n+\t// as defined for the device at the time when it was allocated.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration `json:\"bindingTimeout,omitempty\" protobuf:\"bytes,10,opt,name=bindingTimeout\"`",
        "comment_created_at": "2025-02-19T10:31:50+00:00",
        "comment_author": "pohly",
        "comment_body": "From https://github.com/kubernetes/kubernetes/pull/130160#issuecomment-2664589113:\r\n\r\n> Transferring AllocatedDeviceStatus from the allocator to the scheduler plugin\r\n\r\nLooking at how this is implemented in the allocator I started to wonder whether it really makes sense to add these fields here and not in the AllocationResult.\r\n\r\n* The AllocationResult is immutable. The AllocatedDeviceStatus isn't. I think we want these fields to be immutable.\r\n* Conceptually, they are set once during allocation.\r\n\r\n=> I think these fields belong into `DeviceRequestAllocationResult`.\r\n\r\nThis will also keep the allocator API simple.",
        "pr_file_module": null
      },
      {
        "comment_id": "1962768329",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta1/types.go",
        "discussion_id": "1961398788",
        "commented_code": "@@ -1055,6 +1091,39 @@ type AllocatedDeviceStatus struct {\n \t//\n \t// +optional\n \tNetworkData *NetworkDeviceData `json:\"networkData,omitempty\" protobuf:\"bytes,6,opt,name=networkData\"`\n+\n+\t// UsageRestrictedToNode is a copy of the UsageRestrictedToNode\n+\t// as defined for the device at the time when it was allocated.\n+\t// If true, the node selector of the allocation matches exactly\n+\t// the node that was chosen for the pod which triggered allocation.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode bool `json:\"usageRestrictedToNode,omitempty\" protobuf:\"bytes,7,opt,name=usageRestrictedToNode\"`\n+\n+\t// BindingConditions is a copy of the BindingConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// All of these conditions must be to True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t//\n+\t// +optional\n+\tBindingConditions []string `json:\"bindingConditions,omitempty\" protobuf:\"bytes,8,opt,name=bindingConditions\"`\n+\n+\t// BindingFailureConditions is a copy of the BindingFailureConditions\n+\t// as defined for the device at the time when it was allocated.\n+\t// If any is True, a binding failure occurred.\n+\t//\n+\t// +optional\n+\tBindingFailureConditions []string `json:\"bindingFailureConditions,omitempty\" protobuf:\"bytes,9,opt,name=bindingFailureConditions\"`\n+\n+\t// BindingTimeout is a copy of the BindingTimeout\n+\t// as defined for the device at the time when it was allocated.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration `json:\"bindingTimeout,omitempty\" protobuf:\"bytes,10,opt,name=bindingTimeout\"`",
        "comment_created_at": "2025-02-20T02:28:59+00:00",
        "comment_author": "KobayashiD27",
        "comment_body": "Thank you. That was one of the options I was thinking about. I'll try implementing it to add fields to `DeviceRequestAllocationResult`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1977262728",
    "pr_number": 130160,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-03-03T10:26:18+00:00",
    "commented_code": "//\n \t// +optional\n \tCapacity map[QualifiedName]DeviceCapacity\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool\n+\n+\t// BindingConditions defines the conditions for proceeding with binding.\n+\t// All of these conditions must be set in the per-device status\n+\t// conditions with a value of True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t// The maximum number of binding conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingConditions []string\n+\n+\t// BindingFailureConditions defines the conditions for binding failure.\n+\t// They may be set in the per-device status conditions.\n+\t// If any is true, a binding failure occurred.\n+\t// The maximum number of binding failure conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingFailureConditions []string\n+\n+\t// BindingTimeout indicates the prepare timeout period.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "1977262728",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "1977262728",
        "commented_code": "@@ -219,6 +221,40 @@ type BasicDevice struct {\n \t//\n \t// +optional\n \tCapacity map[QualifiedName]DeviceCapacity\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool\n+\n+\t// BindingConditions defines the conditions for proceeding with binding.\n+\t// All of these conditions must be set in the per-device status\n+\t// conditions with a value of True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t// The maximum number of binding conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingConditions []string\n+\n+\t// BindingFailureConditions defines the conditions for binding failure.\n+\t// They may be set in the per-device status conditions.\n+\t// If any is true, a binding failure occurred.\n+\t// The maximum number of binding failure conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingFailureConditions []string\n+\n+\t// BindingTimeout indicates the prepare timeout period.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration",
        "comment_created_at": "2025-03-03T10:26:18+00:00",
        "comment_author": "pohly",
        "comment_body": "I was reminded that `metav1.Duration` is not suitable for REST APIs because of the encoding/decoding overhead and because non-Go clients may have problems parsing a the string, so it has to be `something<Unit>` after all:\r\n\r\n```suggestion\r\n\tBindingTimeoutSeconds *int64\r\n```\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1978532138",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "1977262728",
        "commented_code": "@@ -219,6 +221,40 @@ type BasicDevice struct {\n \t//\n \t// +optional\n \tCapacity map[QualifiedName]DeviceCapacity\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool\n+\n+\t// BindingConditions defines the conditions for proceeding with binding.\n+\t// All of these conditions must be set in the per-device status\n+\t// conditions with a value of True to proceed with binding the pod to the node\n+\t// while scheduling the pod.\n+\t// The maximum number of binding conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingConditions []string\n+\n+\t// BindingFailureConditions defines the conditions for binding failure.\n+\t// They may be set in the per-device status conditions.\n+\t// If any is true, a binding failure occurred.\n+\t// The maximum number of binding failure conditions is 4.\n+\t//\n+\t// +optional\n+\t// +listType=atomic\n+\tBindingFailureConditions []string\n+\n+\t// BindingTimeout indicates the prepare timeout period.\n+\t// If the timeout period is exceeded before all BindingConditions reach a True state,\n+\t// the scheduler clears the allocation in the ResourceClaim and reschedules the Pod.\n+\t//\n+\t// The default timeout if not set is 10 minutes.\n+\t//\n+\t// +optional\n+\tBindingTimeout *metav1.Duration",
        "comment_created_at": "2025-03-04T03:04:08+00:00",
        "comment_author": "zhouhao3",
        "comment_body": "updated, PTAL",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002968859",
    "pr_number": 130160,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-03-19T10:18:12+00:00",
    "commented_code": "// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2002968859",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2002968859",
        "commented_code": "@@ -954,6 +990,42 @@ type DeviceRequestAllocationResult struct {\n \t// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
        "comment_created_at": "2025-03-19T10:18:12+00:00",
        "comment_author": "pohly",
        "comment_body": "I don't remember: do we really need this in the status? Who acts on it there?\r\n\r\nIf no, remove it?\r\nIf yes, add +featureGate.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2004840265",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2002968859",
        "commented_code": "@@ -954,6 +990,42 @@ type DeviceRequestAllocationResult struct {\n \t// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
        "comment_created_at": "2025-03-20T05:33:49+00:00",
        "comment_author": "hase1128",
        "comment_body": "I explain the behavior of the existing DRA.\r\nIf a node selector is specified in a ResourceSlice, when devices in this ResourceSlice allocate to a ResourceClaim, the contents of the node selector in this ResourceSlice are copied to ResourceClaim.status.allocation.nodeSelector.\r\n\r\nIf the label listed in the node selector matches more than one node, the composable DRA controller does not know which node to attach the device to.\r\nThat's why we introduced UsageRestrictedToNode. If this parameter is true, the node name is stored in ResourceClaim.status.allocation.nodeSelector. This node name is the node where the scheduler will deploy the pod.\r\n\r\nThis allows composable DRA to know which node to attach the device to.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005179791",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2002968859",
        "commented_code": "@@ -954,6 +990,42 @@ type DeviceRequestAllocationResult struct {\n \t// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
        "comment_created_at": "2025-03-20T09:37:58+00:00",
        "comment_author": "pohly",
        "comment_body": "But does the composable DRA driver need to read the claim.status.allocation.usageRestrictedToNode field for that? I don't think so.\r\n\r\nIt knows that it needs to do something because of the binding conditions that it has to modify. It knows the node name from the node selector. That's all that it needs.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2005181907",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2002968859",
        "commented_code": "@@ -954,6 +990,42 @@ type DeviceRequestAllocationResult struct {\n \t// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
        "comment_created_at": "2025-03-20T09:39:16+00:00",
        "comment_author": "pohly",
        "comment_body": "Worded differently: UsageRestrictedToNode is needed in the spec and needs to be handled by the scheduler. It is not needed in the status.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2005375340",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2002968859",
        "commented_code": "@@ -954,6 +990,42 @@ type DeviceRequestAllocationResult struct {\n \t// +optional\n \t// +featureGate=DRAAdminAccess\n \tAdminAccess *bool\n+\n+\t// UsageRestrictedToNode indicates if the usage of an allocation involving this device\n+\t// has to be limited to exactly the node that was chosen when allocating the claim.\n+\t//\n+\t// +optional\n+\tUsageRestrictedToNode *bool",
        "comment_created_at": "2025-03-20T11:18:18+00:00",
        "comment_author": "hase1128",
        "comment_body": "I see. You are right. we will delete it from DeviceRequestAllocationResult.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2209045606",
    "pr_number": 130653,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-16T01:58:34+00:00",
    "commented_code": "// it got removed. May be reused once decoding v1alpha3 is no longer\n \t// supported.\n \t// SuitableNodes *v1.NodeSelector `json:\"suitableNodes,omitempty\" protobuf:\"bytes,3,opt,name=suitableNodes\"`\n+\n+\t// ExtendedResourceName is the extended resource name for the devices of this class.\n+\t// This is an alpha field.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2209045606",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2209045606",
        "commented_code": "@@ -1379,6 +1379,12 @@ type DeviceClassSpec struct {\n \t// it got removed. May be reused once decoding v1alpha3 is no longer\n \t// supported.\n \t// SuitableNodes *v1.NodeSelector `json:\"suitableNodes,omitempty\" protobuf:\"bytes,3,opt,name=suitableNodes\"`\n+\n+\t// ExtendedResourceName is the extended resource name for the devices of this class.\n+\t// This is an alpha field.",
        "comment_created_at": "2025-07-16T01:58:34+00:00",
        "comment_author": "liggitt",
        "comment_body": "Describe what this does when set.\r\n\r\nDescribe the allowed format for values in this field\r\n\r\nNote that only one DeviceClass should specify this extended resource name, and if multiple specify the same `extendedResourceName`, what the behavior is.\r\n\r\n(same comments apply to the v1beta1 and internal type)",
        "pr_file_module": null
      },
      {
        "comment_id": "2211723609",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2209045606",
        "commented_code": "@@ -1379,6 +1379,12 @@ type DeviceClassSpec struct {\n \t// it got removed. May be reused once decoding v1alpha3 is no longer\n \t// supported.\n \t// SuitableNodes *v1.NodeSelector `json:\"suitableNodes,omitempty\" protobuf:\"bytes,3,opt,name=suitableNodes\"`\n+\n+\t// ExtendedResourceName is the extended resource name for the devices of this class.\n+\t// This is an alpha field.",
        "comment_created_at": "2025-07-16T22:24:12+00:00",
        "comment_author": "yliaog",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  }
]