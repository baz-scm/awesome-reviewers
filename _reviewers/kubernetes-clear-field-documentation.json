[
  {
    "discussion_id": "2187327842",
    "pr_number": 132522,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-07-05T14:26:54+00:00",
    "commented_code": "// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTaints []DeviceTaint\n+\n+\t// AllowMultipleAllocations marks whether the device is allowed to be allocated for multiple times.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2187327842",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2187327842",
        "commented_code": "@@ -322,6 +322,15 @@ type Device struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTaints []DeviceTaint\n+\n+\t// AllowMultipleAllocations marks whether the device is allowed to be allocated for multiple times.",
        "comment_created_at": "2025-07-05T14:26:54+00:00",
        "comment_author": "mortent",
        "comment_body": "```suggestion\r\n\t// AllowMultipleAllocations marks whether the device can be allocated by multiple ResourceClaims.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2189071588",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2187327842",
        "commented_code": "@@ -322,6 +322,15 @@ type Device struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTaints []DeviceTaint\n+\n+\t// AllowMultipleAllocations marks whether the device is allowed to be allocated for multiple times.",
        "comment_created_at": "2025-07-07T06:16:44+00:00",
        "comment_author": "pohly",
        "comment_body": "\"ResourceClaims\" is the wrong level - it can also be allocated multiple times in the same ResourceClaim, in different requests.\r\n\r\n```suggestion\r\n\t// AllowMultipleAllocations marks whether the device is allowed to be allocated multiple times.\r\n```\r\n\r\nLet's fix the language without going into whether \"multiple times\" is in different claims.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2189072807",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2187327842",
        "commented_code": "@@ -322,6 +322,15 @@ type Device struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTaints []DeviceTaint\n+\n+\t// AllowMultipleAllocations marks whether the device is allowed to be allocated for multiple times.",
        "comment_created_at": "2025-07-07T06:17:37+00:00",
        "comment_author": "pohly",
        "comment_body": "Also, claims don't allocate. The scheduler allocates, not the claim.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214643520",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-18T01:21:38+00:00",
    "commented_code": "type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2214643520",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2214643520",
        "commented_code": "@@ -351,11 +369,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.",
        "comment_created_at": "2025-07-18T01:21:38+00:00",
        "comment_author": "liggitt",
        "comment_body": "since the capacity can be partially consumed without this changing, would it be clearer to drop the word \"available\" from this documentation, and rephrase to something like `Value defines the total amount of this capacity the device has.`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214646019",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-18T01:23:11+00:00",
    "commented_code": "type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2214646019",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2214646019",
        "commented_code": "@@ -351,11 +369,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.",
        "comment_created_at": "2025-07-18T01:23:11+00:00",
        "comment_author": "liggitt",
        "comment_body": "rather than describing the implementation details, maybe just improve the documentation above to clarify that `value` is the full amount of the capacity the device has, not the unallocated / remaining / available amount?",
        "pr_file_module": null
      },
      {
        "comment_id": "2217527682",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2214646019",
        "commented_code": "@@ -351,11 +369,23 @@ type DeviceCounterConsumption struct {\n type DeviceCapacity struct {\n \t// Value defines how much of a certain device capacity is available.\n \t//\n+\t// If the capacity is consumable (i.e., a SharingPolicy is specified),\n+\t// the consumed amount is deducted and cached in memory by the scheduler.\n+\t// Note that the remaining capacity is not reflected in the resource slice.",
        "comment_created_at": "2025-07-20T01:40:05+00:00",
        "comment_author": "sunya-ch",
        "comment_body": "@liggitt  Thank you. How's about?\r\n\r\n```go\r\n\t// Value defines how much of a certain capacity that device has.\r\n\t//\r\n\t// This field reflects the fixed total capacity and does not change.\r\n\t// If the capacity is consumable (i.e., a SharingPolicy is defined),\r\n\t// the consumed amount is tracked separately and does not affect this value\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2222730582",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
    "created_at": "2025-07-22T14:27:37+00:00",
    "commented_code": "// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration `json:\"tolerations,omitempty\" protobuf:\"bytes,6,opt,name=tolerations\"`\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// If this field is unset and the device supports multiple allocations,\n+\t// the default value will be applied to each capacity with a defined sharing policy.\n+\t//\n+\t// Applies to each device allocation.\n+\t// If Count > 1,\n+\t// request fails if there aren't enough devices that meet the requirements.\n+\t// If AllocationMode is set to All,\n+\t// request fails if any device doesn't meet the requirements.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements `json:\"capacityRequests,omitempty\" protobuf:\"bytes,7,opt,name=capacityRequests\"`\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Requests represent individual device resource requests for distinct resources,\n+\t// all of which must be provided by the device.\n+\t//\n+\t// For each capacity with a defined SharingPolicy, the policy is applied:\n+\t// - If no request amount is provided, the Default value is applied.\n+\t// - If the capacity's SharingPolicy defines a ValidRange, the value is used as-is or rounded up\n+\t//   to the nearest valid amount according to the policy.\n+\t// - If the capacity's SharingPolicy defines ValidValues,\n+\t//   the value must be in the defined list to be selectable and used as-is.\n+\t// This applied value is used during scheduling to determine how much capacity to consume by the request.",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2222730582",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/api/resource/v1beta2/types.go",
        "discussion_id": "2222730582",
        "commented_code": "@@ -833,6 +973,60 @@ type DeviceSubRequest struct {\n \t// +listType=atomic\n \t// +featureGate=DRADeviceTaints\n \tTolerations []DeviceToleration `json:\"tolerations,omitempty\" protobuf:\"bytes,6,opt,name=tolerations\"`\n+\n+\t// CapacityRequests define resource requirements against each capacity.\n+\t//\n+\t// If this field is unset and the device supports multiple allocations,\n+\t// the default value will be applied to each capacity with a defined sharing policy.\n+\t//\n+\t// Applies to each device allocation.\n+\t// If Count > 1,\n+\t// request fails if there aren't enough devices that meet the requirements.\n+\t// If AllocationMode is set to All,\n+\t// request fails if any device doesn't meet the requirements.\n+\t//\n+\t// +optional\n+\t// +featureGate=DRAConsumableCapacity\n+\tCapacityRequests *CapacityRequirements `json:\"capacityRequests,omitempty\" protobuf:\"bytes,7,opt,name=capacityRequests\"`\n+}\n+\n+// CapacityRequirements defines the capacity requirements for a specific device request.\n+type CapacityRequirements struct {\n+\t// Requests represent individual device resource requests for distinct resources,\n+\t// all of which must be provided by the device.\n+\t//\n+\t// For each capacity with a defined SharingPolicy, the policy is applied:\n+\t// - If no request amount is provided, the Default value is applied.\n+\t// - If the capacity's SharingPolicy defines a ValidRange, the value is used as-is or rounded up\n+\t//   to the nearest valid amount according to the policy.\n+\t// - If the capacity's SharingPolicy defines ValidValues,\n+\t//   the value must be in the defined list to be selectable and used as-is.\n+\t// This applied value is used during scheduling to determine how much capacity to consume by the request.",
        "comment_created_at": "2025-07-22T14:27:37+00:00",
        "comment_author": "liggitt",
        "comment_body": "Be careful to make it clear in the documentation that \"applied\" does not mean \"written back to ResourceClaim spec\"\r\n\r\nFor example:\r\n\r\n```suggestion\r\n\t// For each device capacity with a defined sharingPolicy, the scheduler uses the policy to determine how much capacity is consumed:\r\n\t// - If no capacity request is specified, the device sharingPolicy.default value is used.\r\n\t// - If the device sharingPolicy defines a validRange, the capacity request is rounded up to the nearest valid value in the range.\r\n\t// - If the device sharingPolicy defines validValues, the capacity request is rounded up to the nearest valid value.\r\n\t// The consumed capacity is written to the resource claim status.devices[*].consumedCapacity field.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200656780",
    "pr_number": 130653,
    "pr_file": "pkg/apis/core/types.go",
    "created_at": "2025-07-11T12:53:27+00:00",
    "commented_code": "ResourceClaimName *string\n }\n \n+// PodExtendedResourceClaimStatus is stored in the PodStatus for the extended\n+// resource requests backed by DRA. It stores the generated name for\n+// the corresponding special ResourceClaim created by kube-scheduler.\n+type PodExtendedResourceClaimStatus struct {\n+\t// RequestMapping identifies the mapping of <container, extended resource backed by DRA> to  device request.\n+\tRequestMapping []ContainerExtendedResourceRequest\n+\n+\t// ResourceClaimName is the name of the ResourceClaim that was\n+\t// generated for the Pod in the namespace of the Pod.\n+\tResourceClaimName string\n+}\n+\n+type ContainerExtendedResourceRequest struct {\n+\t// container name",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2200656780",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/apis/core/types.go",
        "discussion_id": "2200656780",
        "commented_code": "@@ -3761,6 +3761,27 @@ type PodResourceClaimStatus struct {\n \tResourceClaimName *string\n }\n \n+// PodExtendedResourceClaimStatus is stored in the PodStatus for the extended\n+// resource requests backed by DRA. It stores the generated name for\n+// the corresponding special ResourceClaim created by kube-scheduler.\n+type PodExtendedResourceClaimStatus struct {\n+\t// RequestMapping identifies the mapping of <container, extended resource backed by DRA> to  device request.\n+\tRequestMapping []ContainerExtendedResourceRequest\n+\n+\t// ResourceClaimName is the name of the ResourceClaim that was\n+\t// generated for the Pod in the namespace of the Pod.\n+\tResourceClaimName string\n+}\n+\n+type ContainerExtendedResourceRequest struct {\n+\t// container name",
        "comment_created_at": "2025-07-11T12:53:27+00:00",
        "comment_author": "pohly",
        "comment_body": "This comment doesn't add any information, let's at least be more verbose.\r\n```suggestion\r\n\t// The name of the container requesting resources.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224377455",
    "pr_number": 130653,
    "pr_file": "pkg/scheduler/framework/plugins/dynamicresources/dynamicresources.go",
    "created_at": "2025-07-23T05:20:45+00:00",
    "commented_code": "if err != nil {\n \t\treturn statusError(klog.FromContext(ctx), err)\n \t}\n-\tif len(state.claims) == 0 {\n+\tif state.claims.empty() {\n \t\treturn fwk.NewStatus(fwk.Skip)\n \t}\n \treturn nil\n }\n \n+// bindExtendedResources creates the requestMappings for the special extended resource claim\n+func (pl *DynamicResources) bindRequestMappings(claim *resourceapi.ResourceClaim, pod *v1.Pod) []v1.ContainerExtendedResourceRequest {",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2224377455",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/scheduler/framework/plugins/dynamicresources/dynamicresources.go",
        "discussion_id": "2224377455",
        "commented_code": "@@ -837,19 +1325,69 @@ func (pl *DynamicResources) PreBindPreFlight(ctx context.Context, cs fwk.CycleSt\n \tif err != nil {\n \t\treturn statusError(klog.FromContext(ctx), err)\n \t}\n-\tif len(state.claims) == 0 {\n+\tif state.claims.empty() {\n \t\treturn fwk.NewStatus(fwk.Skip)\n \t}\n \treturn nil\n }\n \n+// bindExtendedResources creates the requestMappings for the special extended resource claim\n+func (pl *DynamicResources) bindRequestMappings(claim *resourceapi.ResourceClaim, pod *v1.Pod) []v1.ContainerExtendedResourceRequest {",
        "comment_created_at": "2025-07-23T05:20:45+00:00",
        "comment_author": "pohly",
        "comment_body": "The doc comment doesn't actually tell me anything about what a `requestMapping` is. This method and the logic around `podScalarResources` remain a mystery to me and completely lack comments in the body which explain what the code does and why.\r\n\r\n `podScalarResources` is document as \"May have extended resource backed by DRA.\" which is very vague. It's apparently a sum of all resources requested anywhere in the pod? At least say that.\r\n\r\nThis looks like an area where we need lots of dedicated unit tests which exercise the different ways how a pod may request resources. For example, I saw some comments in the called code about \"pod level resources\", but no corresponding unit tests. Should those be handled?",
        "pr_file_module": null
      },
      {
        "comment_id": "2227077346",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/scheduler/framework/plugins/dynamicresources/dynamicresources.go",
        "discussion_id": "2224377455",
        "commented_code": "@@ -837,19 +1325,69 @@ func (pl *DynamicResources) PreBindPreFlight(ctx context.Context, cs fwk.CycleSt\n \tif err != nil {\n \t\treturn statusError(klog.FromContext(ctx), err)\n \t}\n-\tif len(state.claims) == 0 {\n+\tif state.claims.empty() {\n \t\treturn fwk.NewStatus(fwk.Skip)\n \t}\n \treturn nil\n }\n \n+// bindExtendedResources creates the requestMappings for the special extended resource claim\n+func (pl *DynamicResources) bindRequestMappings(claim *resourceapi.ResourceClaim, pod *v1.Pod) []v1.ContainerExtendedResourceRequest {",
        "comment_created_at": "2025-07-24T01:24:19+00:00",
        "comment_author": "yliaog",
        "comment_body": "added unittests for two functions: createRequestMappings, and createDeviceRequests. for \"pod level resources\", we don't need to care about them, as they can be only cpu or memory currently. (https://kubernetes.io/docs/tasks/configure-pod-container/assign-pod-level-resources/)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2189346597",
    "pr_number": 131357,
    "pr_file": "pkg/apis/resource/types.go",
    "created_at": "2025-07-07T08:25:42+00:00",
    "commented_code": "// +listType=atomic\n \t// +featureGate=DRAPartitionableDevices\n \tSharedCounters []CounterSet\n+\n+\t// Mixins defines the mixins available for devices and counter sets",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2189346597",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 131357,
        "pr_file": "pkg/apis/resource/types.go",
        "discussion_id": "2189346597",
        "commented_code": "@@ -163,6 +163,13 @@ type ResourceSliceSpec struct {\n \t// +listType=atomic\n \t// +featureGate=DRAPartitionableDevices\n \tSharedCounters []CounterSet\n+\n+\t// Mixins defines the mixins available for devices and counter sets",
        "comment_created_at": "2025-07-07T08:25:42+00:00",
        "comment_author": "pohly",
        "comment_body": "The explanation is recursive - one has to know what mixins are to understand the field. How about:\r\n\r\n\"Mixins provides common definitions that can be used for devices and counter sets in the ResourceSlice.\"\r\n",
        "pr_file_module": null
      }
    ]
  }
]