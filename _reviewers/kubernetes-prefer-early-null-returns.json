[
  {
    "discussion_id": "2211637216",
    "pr_number": 132522,
    "pr_file": "staging/src/k8s.io/dynamic-resource-allocation/api/types.go",
    "created_at": "2025-07-16T21:21:33+00:00",
    "commented_code": "}\n \n type DeviceCapacity struct {\n-\tValue resource.Quantity\n+\tValue         resource.Quantity\n+\tSharingPolicy *CapacitySharingPolicy\n+}\n+\n+type CapacitySharingPolicy struct {\n+\tDefault     resource.Quantity\n+\tValidValues []resource.Quantity\n+\tValidRange  *CapacitySharingPolicyRange\n+}\n+\n+type CapacitySharingPolicyRange struct {\n+\tMinimum   resource.Quantity\n+\tMaximum   *resource.Quantity",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2211637216",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/dynamic-resource-allocation/api/types.go",
        "discussion_id": "2211637216",
        "commented_code": "@@ -82,7 +83,20 @@ type DeviceAttribute struct {\n }\n \n type DeviceCapacity struct {\n-\tValue resource.Quantity\n+\tValue         resource.Quantity\n+\tSharingPolicy *CapacitySharingPolicy\n+}\n+\n+type CapacitySharingPolicy struct {\n+\tDefault     resource.Quantity\n+\tValidValues []resource.Quantity\n+\tValidRange  *CapacitySharingPolicyRange\n+}\n+\n+type CapacitySharingPolicyRange struct {\n+\tMinimum   resource.Quantity\n+\tMaximum   *resource.Quantity",
        "comment_created_at": "2025-07-16T21:21:33+00:00",
        "comment_author": "liggitt",
        "comment_body": "is minimum required and maximum is optional?",
        "pr_file_module": null
      },
      {
        "comment_id": "2211811275",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "staging/src/k8s.io/dynamic-resource-allocation/api/types.go",
        "discussion_id": "2211637216",
        "commented_code": "@@ -82,7 +83,20 @@ type DeviceAttribute struct {\n }\n \n type DeviceCapacity struct {\n-\tValue resource.Quantity\n+\tValue         resource.Quantity\n+\tSharingPolicy *CapacitySharingPolicy\n+}\n+\n+type CapacitySharingPolicy struct {\n+\tDefault     resource.Quantity\n+\tValidValues []resource.Quantity\n+\tValidRange  *CapacitySharingPolicyRange\n+}\n+\n+type CapacitySharingPolicyRange struct {\n+\tMinimum   resource.Quantity\n+\tMaximum   *resource.Quantity",
        "comment_created_at": "2025-07-16T23:21:31+00:00",
        "comment_author": "sunya-ch",
        "comment_body": "@liggitt Yes. Minimum is required field when defining ValidRange while the rest is optional.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223033346",
    "pr_number": 132522,
    "pr_file": "pkg/registry/resource/resourceclaim/strategy.go",
    "created_at": "2025-07-22T15:54:26+00:00",
    "commented_code": "}\n \n // TODO: add tests after partitionable devices is merged (code conflict!)\n+\n+func draConsumableCapacityFeatureInUse(claim *resource.ResourceClaim) bool {\n+\tif claim == nil {\n+\t\treturn false\n+\t}\n+\n+\tfor _, request := range claim.Spec.Devices.Requests {\n+\t\tif request.Exactly != nil && request.Exactly.CapacityRequests != nil {\n+\t\t\treturn true\n+\t\t}\n+\t\tif len(request.FirstAvailable) > 0 {\n+\t\t\tfor _, subRequest := range request.FirstAvailable {\n+\t\t\t\tif subRequest.CapacityRequests != nil {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif allocation := claim.Status.Allocation; allocation != nil {\n+\t\tfor _, result := range allocation.Devices.Results {\n+\t\t\tif result.ShareID != nil || result.ConsumedCapacities != nil {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif devices := claim.Status.Devices; devices != nil {\n+\t\tfor _, device := range devices {\n+\t\t\tif device.ShareID != nil && *device.ShareID != \"\" { // must ignore default value",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2223033346",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 132522,
        "pr_file": "pkg/registry/resource/resourceclaim/strategy.go",
        "discussion_id": "2223033346",
        "commented_code": "@@ -345,3 +353,75 @@ func dropDeallocatedStatusDevices(newClaim, oldClaim *resource.ResourceClaim) {\n }\n \n // TODO: add tests after partitionable devices is merged (code conflict!)\n+\n+func draConsumableCapacityFeatureInUse(claim *resource.ResourceClaim) bool {\n+\tif claim == nil {\n+\t\treturn false\n+\t}\n+\n+\tfor _, request := range claim.Spec.Devices.Requests {\n+\t\tif request.Exactly != nil && request.Exactly.CapacityRequests != nil {\n+\t\t\treturn true\n+\t\t}\n+\t\tif len(request.FirstAvailable) > 0 {\n+\t\t\tfor _, subRequest := range request.FirstAvailable {\n+\t\t\t\tif subRequest.CapacityRequests != nil {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif allocation := claim.Status.Allocation; allocation != nil {\n+\t\tfor _, result := range allocation.Devices.Results {\n+\t\t\tif result.ShareID != nil || result.ConsumedCapacities != nil {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif devices := claim.Status.Devices; devices != nil {\n+\t\tfor _, device := range devices {\n+\t\t\tif device.ShareID != nil && *device.ShareID != \"\" { // must ignore default value",
        "comment_created_at": "2025-07-22T15:54:26+00:00",
        "comment_author": "liggitt",
        "comment_body": "no default values for optional alpha feature-gate-disabled fields\r\n\r\n```suggestion\r\n\t\t\tif device.ShareID != nil {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218461610",
    "pr_number": 130160,
    "pr_file": "pkg/apis/resource/validation/validation.go",
    "created_at": "2025-07-21T08:01:18+00:00",
    "commented_code": "return allErrs\n }\n+\n+func validateDeviceBindingParameters(bindingConditions, bindingFailureConditions []string, bindingTimeoutSeconds *int64, fldPath *field.Path) field.ErrorList {\n+\tvar allErrs field.ErrorList\n+\tallErrs = append(allErrs, validateSlice(bindingConditions, resource.BindingConditionsMaxSize,\n+\t\tmetav1validation.ValidateLabelName, fldPath.Child(\"bindingConditions\"))...)\n+\n+\tallErrs = append(allErrs, validateSlice(bindingFailureConditions, resource.BindingFailureConditionsMaxSize,\n+\t\tmetav1validation.ValidateLabelName, fldPath.Child(\"bindingFailureConditions\"))...)\n+\n+\tif bindingTimeoutSeconds != nil && *bindingTimeoutSeconds <= 0 {\n+\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"bindingTimeoutSeconds\"), bindingTimeoutSeconds, \"must be greater than zero\"))\n+\t}\n+\n+\tif bindingConditions == nil && bindingFailureConditions != nil {",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2218461610",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130160,
        "pr_file": "pkg/apis/resource/validation/validation.go",
        "discussion_id": "2218461610",
        "commented_code": "@@ -1192,3 +1195,22 @@ func validateLabelValue(value string, fldPath *field.Path) field.ErrorList {\n \n \treturn allErrs\n }\n+\n+func validateDeviceBindingParameters(bindingConditions, bindingFailureConditions []string, bindingTimeoutSeconds *int64, fldPath *field.Path) field.ErrorList {\n+\tvar allErrs field.ErrorList\n+\tallErrs = append(allErrs, validateSlice(bindingConditions, resource.BindingConditionsMaxSize,\n+\t\tmetav1validation.ValidateLabelName, fldPath.Child(\"bindingConditions\"))...)\n+\n+\tallErrs = append(allErrs, validateSlice(bindingFailureConditions, resource.BindingFailureConditionsMaxSize,\n+\t\tmetav1validation.ValidateLabelName, fldPath.Child(\"bindingFailureConditions\"))...)\n+\n+\tif bindingTimeoutSeconds != nil && *bindingTimeoutSeconds <= 0 {\n+\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"bindingTimeoutSeconds\"), bindingTimeoutSeconds, \"must be greater than zero\"))\n+\t}\n+\n+\tif bindingConditions == nil && bindingFailureConditions != nil {",
        "comment_created_at": "2025-07-21T08:01:18+00:00",
        "comment_author": "pohly",
        "comment_body": "```suggestion\r\n\tif len(bindingConditions) == 0 && len(bindingFailureConditions) > 0 {\r\n```\r\n\r\nThis avoids the assumption that a non-nil slice is automatically non-empty. It also shows the intent more clearly.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2209060776",
    "pr_number": 130653,
    "pr_file": "plugin/pkg/admission/noderestriction/admission.go",
    "created_at": "2025-07-16T02:11:57+00:00",
    "commented_code": "return true\n }\n \n+func extendedResourceClaimStatusEqual(statusA, statusB *api.PodExtendedResourceClaimStatus) bool {\n+\tif statusA == nil && statusB == nil {\n+\t\treturn true\n+\t}\n+\tif statusA != nil && statusB == nil {\n+\t\treturn false\n+\t}\n+\tif statusA == nil && statusB != nil {\n+\t\treturn false\n+\t}",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2209060776",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "plugin/pkg/admission/noderestriction/admission.go",
        "discussion_id": "2209060776",
        "commented_code": "@@ -369,6 +372,40 @@ func resourceClaimStatusesEqual(statusA, statusB []api.PodResourceClaimStatus) b\n \treturn true\n }\n \n+func extendedResourceClaimStatusEqual(statusA, statusB *api.PodExtendedResourceClaimStatus) bool {\n+\tif statusA == nil && statusB == nil {\n+\t\treturn true\n+\t}\n+\tif statusA != nil && statusB == nil {\n+\t\treturn false\n+\t}\n+\tif statusA == nil && statusB != nil {\n+\t\treturn false\n+\t}",
        "comment_created_at": "2025-07-16T02:11:57+00:00",
        "comment_author": "liggitt",
        "comment_body": "this might make it easier to see that statusA and statusB are non-nil once we get past the first checks:\r\n```\r\n\tif statusA == nil && statusB == nil {\r\n\t\treturn true\r\n\t}\r\n\tif statusA == nil || statusB == nil {\r\n\t\treturn false\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2211726734",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "plugin/pkg/admission/noderestriction/admission.go",
        "discussion_id": "2209060776",
        "commented_code": "@@ -369,6 +372,40 @@ func resourceClaimStatusesEqual(statusA, statusB []api.PodResourceClaimStatus) b\n \treturn true\n }\n \n+func extendedResourceClaimStatusEqual(statusA, statusB *api.PodExtendedResourceClaimStatus) bool {\n+\tif statusA == nil && statusB == nil {\n+\t\treturn true\n+\t}\n+\tif statusA != nil && statusB == nil {\n+\t\treturn false\n+\t}\n+\tif statusA == nil && statusB != nil {\n+\t\treturn false\n+\t}",
        "comment_created_at": "2025-07-16T22:26:34+00:00",
        "comment_author": "yliaog",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219209119",
    "pr_number": 130653,
    "pr_file": "pkg/scheduler/framework/plugins/noderesources/fit.go",
    "created_at": "2025-07-21T13:24:50+00:00",
    "commented_code": "// and the older (before v1.28) kubelet, make the Pod unschedulable.\n \t\treturn nil, fwk.NewStatus(fwk.UnschedulableAndUnresolvable, \"Pod has a restartable init container and the SidecarContainers feature is disabled\")\n \t}\n-\tcycleState.Write(preFilterStateKey, computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources}))\n+\tresult := computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources})\n+\thasExtendedResource := false\n+\tfor rName, rQuant := range result.ScalarResources {\n+\t\t// Skip in case request quantity is zero\n+\t\tif rQuant == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif v1helper.IsExtendedResourceName(rName) {\n+\t\t\thasExtendedResource = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif f.enableDRAExtendedResource && f.handle != nil && hasExtendedResource {",
    "repo_full_name": "kubernetes/kubernetes",
    "discussion_comments": [
      {
        "comment_id": "2219209119",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/scheduler/framework/plugins/noderesources/fit.go",
        "discussion_id": "2219209119",
        "commented_code": "@@ -236,7 +242,30 @@ func (f *Fit) PreFilter(ctx context.Context, cycleState fwk.CycleState, pod *v1.\n \t\t// and the older (before v1.28) kubelet, make the Pod unschedulable.\n \t\treturn nil, fwk.NewStatus(fwk.UnschedulableAndUnresolvable, \"Pod has a restartable init container and the SidecarContainers feature is disabled\")\n \t}\n-\tcycleState.Write(preFilterStateKey, computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources}))\n+\tresult := computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources})\n+\thasExtendedResource := false\n+\tfor rName, rQuant := range result.ScalarResources {\n+\t\t// Skip in case request quantity is zero\n+\t\tif rQuant == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif v1helper.IsExtendedResourceName(rName) {\n+\t\t\thasExtendedResource = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif f.enableDRAExtendedResource && f.handle != nil && hasExtendedResource {",
        "comment_created_at": "2025-07-21T13:24:50+00:00",
        "comment_author": "macsko",
        "comment_body": "Handle is always non-nil, isn't it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2219214397",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/scheduler/framework/plugins/noderesources/fit.go",
        "discussion_id": "2219209119",
        "commented_code": "@@ -236,7 +242,30 @@ func (f *Fit) PreFilter(ctx context.Context, cycleState fwk.CycleState, pod *v1.\n \t\t// and the older (before v1.28) kubelet, make the Pod unschedulable.\n \t\treturn nil, fwk.NewStatus(fwk.UnschedulableAndUnresolvable, \"Pod has a restartable init container and the SidecarContainers feature is disabled\")\n \t}\n-\tcycleState.Write(preFilterStateKey, computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources}))\n+\tresult := computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources})\n+\thasExtendedResource := false\n+\tfor rName, rQuant := range result.ScalarResources {\n+\t\t// Skip in case request quantity is zero\n+\t\tif rQuant == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif v1helper.IsExtendedResourceName(rName) {\n+\t\t\thasExtendedResource = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif f.enableDRAExtendedResource && f.handle != nil && hasExtendedResource {",
        "comment_created_at": "2025-07-21T13:26:32+00:00",
        "comment_author": "macsko",
        "comment_body": "And move the `if` body to a new func",
        "pr_file_module": null
      },
      {
        "comment_id": "2220210894",
        "repo_full_name": "kubernetes/kubernetes",
        "pr_number": 130653,
        "pr_file": "pkg/scheduler/framework/plugins/noderesources/fit.go",
        "discussion_id": "2219209119",
        "commented_code": "@@ -236,7 +242,30 @@ func (f *Fit) PreFilter(ctx context.Context, cycleState fwk.CycleState, pod *v1.\n \t\t// and the older (before v1.28) kubelet, make the Pod unschedulable.\n \t\treturn nil, fwk.NewStatus(fwk.UnschedulableAndUnresolvable, \"Pod has a restartable init container and the SidecarContainers feature is disabled\")\n \t}\n-\tcycleState.Write(preFilterStateKey, computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources}))\n+\tresult := computePodResourceRequest(pod, ResourceRequestsOptions{EnablePodLevelResources: f.enablePodLevelResources})\n+\thasExtendedResource := false\n+\tfor rName, rQuant := range result.ScalarResources {\n+\t\t// Skip in case request quantity is zero\n+\t\tif rQuant == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif v1helper.IsExtendedResourceName(rName) {\n+\t\t\thasExtendedResource = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif f.enableDRAExtendedResource && f.handle != nil && hasExtendedResource {",
        "comment_created_at": "2025-07-21T20:15:17+00:00",
        "comment_author": "yliaog",
        "comment_body": "removed f.handle != nil, the body is very small, so hopefully keeping it inlined is ok to read.",
        "pr_file_module": null
      }
    ]
  }
]