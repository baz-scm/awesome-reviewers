---
title: Chunked data processing
description: When processing large arrays or data structures, implement chunked processing
  to avoid stack size limitations and optimize performance. Break operations into
  manageable chunks rather than processing everything at once.
repository: langchain-ai/langchainjs
label: Algorithms
language: Typescript
comments_count: 3
repository_stars: 15004
---

When processing large arrays or data structures, implement chunked processing to avoid stack size limitations and optimize performance. Break operations into manageable chunks rather than processing everything at once.

**Key practices:**

1. Use appropriate chunk sizes (typically 100KB or less) when dealing with large binary data or strings
2. Choose the right collection operation for your use case:
   - Use `reduce()` when accumulating or combining values across collections
   - Use `map()` when transforming elements without combining them
   - Consider recursion for nested structures with appropriate base cases

**Example:**
```typescript
// Process large binary data in chunks to avoid stack overflow
async asString(): Promise<string> {
  const data = this.data ?? new Blob([]);
  const dataBuffer = await data.arrayBuffer();
  const dataArray = new Uint8Array(dataBuffer);

  // Need to handle the array in smaller chunks to deal with stack size limits
  let ret = "";
  const chunkSize = 102400;
  for (let i = 0; i < dataArray.length; i += chunkSize) {
    const chunk = dataArray.subarray(i, i + chunkSize);
    ret += String.fromCharCode(...chunk);
  }

  return ret;
}
```

Implementing chunked processing improves application stability by preventing stack overflows and can improve performance by managing memory more efficiently. This pattern is especially important when handling user-generated content, large API responses, or binary data operations.


[
  {
    "discussion_id": "2116365677",
    "pr_number": 8282,
    "pr_file": "libs/langchain-mcp-adapters/src/types.ts",
    "created_at": "2025-05-30T18:08:27+00:00",
    "commented_code": "* Zod schema for an individual content item within a CallToolResult.\n * Derived from CallToolResultSchema.\n */\nconst callToolResultContentSchema = CallToolResultSchema.shape.content.element;\n/**\n * Recursively unwrap common Zod wrappers (default, optional, nullable, effects)\n */\nfunction unwrapSchema(schema) {\n  const def = schema._def;\n  switch (def?.typeName) {\n    case ZodDefault.name:\n    case ZodOptional.name:\n    case ZodNullable.name:\n      return unwrapSchema(def.innerType);\n    case ZodEffects.name:\n      return unwrapSchema(def.schema);\n    default:\n      return schema;\n  }\n}\n\n/**\n * Zod schema for an individual content item within a CallToolResult.\n * Derived from CallToolResultSchema, with wrappers unwrapped.\n */\nconst arraySchema = CallToolResultSchema.shape.content;\nconst callToolResultContentSchema = unwrapSchema(arraySchema).element;",
    "repo_full_name": "langchain-ai/langchainjs",
    "discussion_comments": [
      {
        "comment_id": "2116365677",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 8282,
        "pr_file": "libs/langchain-mcp-adapters/src/types.ts",
        "discussion_id": "2116365677",
        "commented_code": "@@ -38,7 +42,29 @@ function isZodLiteral(schema: unknown): schema is ZodLiteral<Primitive> {\n  * Zod schema for an individual content item within a CallToolResult.\n  * Derived from CallToolResultSchema.\n  */\n-const callToolResultContentSchema = CallToolResultSchema.shape.content.element;\n+/**\n+ * Recursively unwrap common Zod wrappers (default, optional, nullable, effects)\n+ */\n+function unwrapSchema(schema) {\n+  const def = schema._def;\n+  switch (def?.typeName) {\n+    case ZodDefault.name:\n+    case ZodOptional.name:\n+    case ZodNullable.name:\n+      return unwrapSchema(def.innerType);\n+    case ZodEffects.name:\n+      return unwrapSchema(def.schema);\n+    default:\n+      return schema;\n+  }\n+}\n+\n+/**\n+ * Zod schema for an individual content item within a CallToolResult.\n+ * Derived from CallToolResultSchema, with wrappers unwrapped.\n+ */\n+const arraySchema = CallToolResultSchema.shape.content;\n+const callToolResultContentSchema = unwrapSchema(arraySchema).element;",
        "comment_created_at": "2025-05-30T18:08:27+00:00",
        "comment_author": "hntrl",
        "comment_body": "```suggestion\r\nfunction isZodDefault<T extends ZodTypeAny>(\r\n  schema: unknown\r\n): schema is ZodDefault<T> {\r\n  return (\r\n    typeof schema === \"object\" &&\r\n    schema !== null &&\r\n    \"_def\" in schema &&\r\n    (schema as { _def: { typeName: string } })._def.typeName === \"ZodDefault\"\r\n  );\r\n}\r\n\r\nfunction unwrapZodArray<TElement extends ZodTypeAny>(\r\n  schema: ZodArray<TElement> | ZodDefault<ZodArray<TElement>>\r\n): TElement {\r\n  if (isZodDefault(schema)) {\r\n    return schema._def.innerType.element;\r\n  }\r\n  return schema.element;\r\n}\r\n\r\n/**\r\n * Zod schema for an individual content item within a CallToolResult.\r\n * Derived from CallToolResultSchema, with wrappers unwrapped.\r\n */\r\nconst callToolResultContentSchema = unwrapZodArray(\r\n  CallToolResultSchema.shape.content\r\n);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1667177345",
    "pr_number": 5835,
    "pr_file": "libs/langchain-google-common/src/experimental/utils/media_core.ts",
    "created_at": "2024-07-05T21:46:14+00:00",
    "commented_code": "import { v4 as uuidv4 } from \"uuid\";\nimport { BaseStore } from \"@langchain/core/stores\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\n\nexport interface MediaBlobParameters {\n  data?: Blob;\n\n  metadata?: Record<string, unknown>;\n\n  path?: string;\n}\n\n/**\n * Represents a chunk of data that can be identified by the path where the\n * data is (or will be) located, along with optional metadata about the data.\n */\nexport class MediaBlob\n  extends Serializable // FIXME - I'm not sure this serializes or deserializes correctly\n  implements MediaBlobParameters\n{\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n\n  data?: Blob;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata?: Record<string, any>;\n\n  path?: string;\n\n  constructor(params?: MediaBlobParameters) {\n    super(params);\n    this.data = params?.data;\n    this.metadata = params?.metadata;\n    this.path = params?.path;\n  }\n\n  get size(): number {\n    return this.data?.size ?? 0;\n  }\n\n  get dataType(): string {\n    return this.data?.type ?? \"\";\n  }\n\n  get encoding(): string {\n    const charsetEquals = this.dataType.indexOf(\"charset=\");\n    return charsetEquals === -1\n      ? \"utf-8\"\n      : this.dataType.substring(charsetEquals + 8);\n  }\n\n  get mimetype(): string {\n    const semicolon = this.dataType.indexOf(\";\");\n    return semicolon === -1\n      ? this.dataType\n      : this.dataType.substring(0, semicolon);\n  }\n\n  async asString(): Promise<string> {\n    const data = this.data ?? new Blob([]);\n    const dataBuffer = await data.arrayBuffer();\n    const dataArray = new Uint8Array(dataBuffer);\n\n    // Need to handle the array in smaller chunks to deal with stack size limits\n    let ret = \"\";\n    const chunkSize = 102400;\n    for (let i = 0; i < dataArray.length; i += chunkSize) {\n      const chunk = dataArray.subarray(i, i + chunkSize);\n      ret += String.fromCharCode(...chunk);\n    }\n\n    return ret;\n  }\n\n  async asBase64(): Promise<string> {\n    return btoa(await this.asString());\n  }\n\n  async asDataUrl(): Promise<string> {\n    return `data:${this.mimetype};base64,${await this.asBase64()}`;\n  }\n\n  async asUri(): Promise<string> {\n    return this.path ?? (await this.asDataUrl());\n  }\n\n  async encode(): Promise<{ encoded: string; encoding: string }> {\n    const dataUrl = await this.asDataUrl();\n    const comma = dataUrl.indexOf(\",\");\n    const encoded = dataUrl.substring(comma + 1);\n    const encoding: string = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n    return {\n      encoded,\n      encoding,\n    };\n  }\n}\n\nexport type ActionIfInvalidAction =\n  | \"ignore\"\n  | \"prefixPath\"\n  | \"prefixUuid\"\n  | \"removePath\";\n\nexport interface BlobStoreStoreOptions {\n  /**\n   * If the path is missing or invalid in the blob, how should we create\n   * a new path?\n   * Subclasses may define their own methods, but the following are supported\n   * by default:\n   * - Undefined or an emtpy string: Reject the blob\n   * - \"ignore\": Attempt to store it anyway (but this may fail)\n   * - \"prefixPath\": Use the default prefix for the BlobStore and get the\n   *   unique portion from the URL. The original path is stored in the metadata\n   * - \"prefixUuid\": Use the default prefix for the BlobStore and get the\n   *   unique portion from a generated UUID. The original path is stored\n   *   in the metadata\n   */\n  actionIfInvalid?: ActionIfInvalidAction;\n\n  /**\n   * The expected prefix for URIs that are stored.\n   * This may be used to test if a MediaBlob is valid and used to create a new\n   * path if \"prefixPath\" or \"prefixUuid\" is set for actionIfInvalid.\n   */\n  pathPrefix?: string;\n}\n\nexport type ActionIfBlobMissingAction = \"emptyBlob\";\n\nexport interface BlobStoreFetchOptions {\n  /**\n   * If the blob is not found when fetching, what should we do?\n   * Subclasses may define their own methods, but the following are supported\n   * by default:\n   * - Undefined or an empty string: return undefined\n   * - \"emptyBlob\": return a new MediaBlob that has the path set, but nothing else.\n   */\n  actionIfBlobMissing?: ActionIfBlobMissingAction;\n}\n\nexport interface BlobStoreOptions {\n  defaultStoreOptions?: BlobStoreStoreOptions;\n\n  defaultFetchOptions?: BlobStoreFetchOptions;\n}\n\n/**\n * A specialized Store that is designed to handle MediaBlobs and use the\n * key that is included in the blob to determine exactly how it is stored.\n *\n * The full details of a MediaBlob may be changed when it is stored.\n * For example, it may get additional or different Metadata. This should be\n * what is returned when the store() method is called.\n *\n * Although BlobStore extends BaseStore, not all of the methods from\n * BaseStore may be implemented (or even possible). Those that are not\n * implemented should be documented and throw an Error if called.\n */\nexport abstract class BlobStore extends BaseStore<string, MediaBlob> {\n  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n\n  defaultStoreOptions: BlobStoreStoreOptions;\n\n  defaultFetchOptions: BlobStoreFetchOptions;\n\n  constructor(opts?: BlobStoreOptions) {\n    super(opts);\n    this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n    this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n  }\n\n  protected async _realKey(key: string | MediaBlob): Promise<string> {\n    return typeof key === \"string\" ? key : await key.asUri();\n  }\n\n  /**\n   * Is the path set in the MediaBlob supported by this BlobStore?\n   * Subclasses must implement and evaluate `blob.path` to make this\n   * determination.\n   *\n   * Although this is async, this is expected to be a relatively fast operation\n   * (ie - you shouldn't make network calls).\n   *\n   * The default implementation assumes that undefined blob.paths are invalid\n   * and then uses the replacePathPrefix (or an empty string) as an assumed path\n   * to start with.\n   *\n   * @param blob The blob to test\n   * @param opts Any options (if needed) that may be used to determine if it is valid\n   * @return If the string represented by blob.path is supported.\n   */\n  protected _hasValidPath(\n    blob: MediaBlob,\n    opts?: BlobStoreStoreOptions\n  ): Promise<boolean> {\n    const path = blob.path ?? \"\";\n    const prefix = opts?.pathPrefix ?? \"\";\n    const isPrefixed =\n      typeof blob.path !== \"undefined\" && path.startsWith(prefix);\n    return Promise.resolve(isPrefixed);\n  }\n\n  protected _blobPathSuffix(blob: MediaBlob): string {\n    // Get the path currently set and make sure we treat it as a string\n    const blobPath = `${blob.path}`;\n\n    // Advance past the first set of /\n    let pathStart = blobPath.indexOf(\"/\") + 1;\n    while (blobPath.charAt(pathStart) === \"/\") {\n      pathStart += 1;\n    }\n\n    // We will use the rest as the path for a replacement\n    return blobPath.substring(pathStart);\n  }\n\n  protected async _newBlob(\n    oldBlob: MediaBlob,\n    newPath?: string\n  ): Promise<MediaBlob> {\n    const oldPath = oldBlob.path;\n    const metadata = oldBlob?.metadata ?? {};\n    metadata.langchainOldPath = oldPath;\n    const newBlob = new MediaBlob({\n      ...oldBlob,\n      metadata,\n    });\n    if (newPath) {\n      newBlob.path = newPath;\n    } else if (newBlob.path) {\n      delete newBlob.path;\n    }\n    return newBlob;\n  }\n\n  protected async _validBlobPrefixPath(\n    blob: MediaBlob,\n    opts?: BlobStoreStoreOptions\n  ): Promise<MediaBlob> {\n    const prefix = opts?.pathPrefix ?? \"\";\n    const suffix = this._blobPathSuffix(blob);\n    const newPath = `${prefix}${suffix}`;\n    return this._newBlob(blob, newPath);\n  }\n\n  protected async _validBlobPrefixUuid(\n    blob: MediaBlob,\n    opts?: BlobStoreStoreOptions\n  ): Promise<MediaBlob> {\n    const prefix = opts?.pathPrefix ?? \"\";\n    const suffix = uuidv4(); // TODO - option to specify version?\n    const newPath = `${prefix}${suffix}`;\n    return this._newBlob(blob, newPath);\n  }\n\n  protected async _validBlobRemovePath(\n    blob: MediaBlob,\n    _opts?: BlobStoreStoreOptions\n  ): Promise<MediaBlob> {\n    return this._newBlob(blob, undefined);\n  }\n\n  /**\n   * Based on the blob and options, return a blob that has a valid path\n   * that can be saved.\n   * @param blob\n   * @param opts\n   */\n  protected async _validStoreBlob(\n    blob: MediaBlob,\n    opts?: BlobStoreStoreOptions\n  ): Promise<MediaBlob | undefined> {\n    if (await this._hasValidPath(blob, opts)) {\n      return blob;\n    }\n    switch (opts?.actionIfInvalid) {\n      case \"ignore\":\n        return blob;\n      case \"prefixPath\":\n        return this._validBlobPrefixPath(blob, opts);\n      case \"prefixUuid\":\n        return this._validBlobPrefixUuid(blob, opts);\n      case \"removePath\":\n        return this._validBlobRemovePath(blob, opts);\n      default:\n        return undefined;\n    }\n  }\n\n  async store(\n    blob: MediaBlob,\n    opts: BlobStoreStoreOptions = {}\n  ): Promise<MediaBlob | undefined> {\n    const allOpts: BlobStoreStoreOptions = {\n      ...this.defaultStoreOptions,\n      ...opts,\n    };\n    const validBlob = await this._validStoreBlob(blob, allOpts);\n    if (typeof validBlob !== \"undefined\") {\n      const validKey = await validBlob.asUri();\n      await this.mset([[validKey, validBlob]]);\n      const savedKey = await validBlob.asUri();\n      return await this.fetch(savedKey);\n    }\n    return undefined;\n  }\n\n  protected async _missingFetchBlobEmpty(\n    path: string,\n    _opts?: BlobStoreFetchOptions\n  ): Promise<MediaBlob> {\n    return new MediaBlob({ path });\n  }\n\n  protected async _missingFetchBlob(\n    path: string,\n    opts?: BlobStoreFetchOptions\n  ): Promise<MediaBlob | undefined> {\n    switch (opts?.actionIfBlobMissing) {\n      case \"emptyBlob\":\n        return this._missingFetchBlobEmpty(path, opts);\n      default:\n        return undefined;\n    }\n  }\n\n  async fetch(\n    key: string | MediaBlob,\n    opts: BlobStoreFetchOptions = {}\n  ): Promise<MediaBlob | undefined> {\n    const allOpts: BlobStoreFetchOptions = {\n      ...this.defaultFetchOptions,\n      ...opts,\n    };\n    const realKey = await this._realKey(key);\n    const ret = await this.mget([realKey]);\n    return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n  }\n}\n\nexport interface BackedBlobStoreOptions extends BlobStoreOptions {\n  backingStore: BaseStore<string, MediaBlob>;\n}\n\nexport class BackedBlobStore extends BlobStore {",
    "repo_full_name": "langchain-ai/langchainjs",
    "discussion_comments": [
      {
        "comment_id": "1667177345",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 5835,
        "pr_file": "libs/langchain-google-common/src/experimental/utils/media_core.ts",
        "discussion_id": "1667177345",
        "commented_code": "@@ -0,0 +1,504 @@\n+import { v4 as uuidv4 } from \"uuid\";\n+import { BaseStore } from \"@langchain/core/stores\";\n+import { Serializable } from \"@langchain/core/load/serializable\";\n+\n+export interface MediaBlobParameters {\n+  data?: Blob;\n+\n+  metadata?: Record<string, unknown>;\n+\n+  path?: string;\n+}\n+\n+/**\n+ * Represents a chunk of data that can be identified by the path where the\n+ * data is (or will be) located, along with optional metadata about the data.\n+ */\n+export class MediaBlob\n+  extends Serializable // FIXME - I'm not sure this serializes or deserializes correctly\n+  implements MediaBlobParameters\n+{\n+  lc_serializable = true;\n+\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  data?: Blob;\n+\n+  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+  metadata?: Record<string, any>;\n+\n+  path?: string;\n+\n+  constructor(params?: MediaBlobParameters) {\n+    super(params);\n+    this.data = params?.data;\n+    this.metadata = params?.metadata;\n+    this.path = params?.path;\n+  }\n+\n+  get size(): number {\n+    return this.data?.size ?? 0;\n+  }\n+\n+  get dataType(): string {\n+    return this.data?.type ?? \"\";\n+  }\n+\n+  get encoding(): string {\n+    const charsetEquals = this.dataType.indexOf(\"charset=\");\n+    return charsetEquals === -1\n+      ? \"utf-8\"\n+      : this.dataType.substring(charsetEquals + 8);\n+  }\n+\n+  get mimetype(): string {\n+    const semicolon = this.dataType.indexOf(\";\");\n+    return semicolon === -1\n+      ? this.dataType\n+      : this.dataType.substring(0, semicolon);\n+  }\n+\n+  async asString(): Promise<string> {\n+    const data = this.data ?? new Blob([]);\n+    const dataBuffer = await data.arrayBuffer();\n+    const dataArray = new Uint8Array(dataBuffer);\n+\n+    // Need to handle the array in smaller chunks to deal with stack size limits\n+    let ret = \"\";\n+    const chunkSize = 102400;\n+    for (let i = 0; i < dataArray.length; i += chunkSize) {\n+      const chunk = dataArray.subarray(i, i + chunkSize);\n+      ret += String.fromCharCode(...chunk);\n+    }\n+\n+    return ret;\n+  }\n+\n+  async asBase64(): Promise<string> {\n+    return btoa(await this.asString());\n+  }\n+\n+  async asDataUrl(): Promise<string> {\n+    return `data:${this.mimetype};base64,${await this.asBase64()}`;\n+  }\n+\n+  async asUri(): Promise<string> {\n+    return this.path ?? (await this.asDataUrl());\n+  }\n+\n+  async encode(): Promise<{ encoded: string; encoding: string }> {\n+    const dataUrl = await this.asDataUrl();\n+    const comma = dataUrl.indexOf(\",\");\n+    const encoded = dataUrl.substring(comma + 1);\n+    const encoding: string = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n+    return {\n+      encoded,\n+      encoding,\n+    };\n+  }\n+}\n+\n+export type ActionIfInvalidAction =\n+  | \"ignore\"\n+  | \"prefixPath\"\n+  | \"prefixUuid\"\n+  | \"removePath\";\n+\n+export interface BlobStoreStoreOptions {\n+  /**\n+   * If the path is missing or invalid in the blob, how should we create\n+   * a new path?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an emtpy string: Reject the blob\n+   * - \"ignore\": Attempt to store it anyway (but this may fail)\n+   * - \"prefixPath\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from the URL. The original path is stored in the metadata\n+   * - \"prefixUuid\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from a generated UUID. The original path is stored\n+   *   in the metadata\n+   */\n+  actionIfInvalid?: ActionIfInvalidAction;\n+\n+  /**\n+   * The expected prefix for URIs that are stored.\n+   * This may be used to test if a MediaBlob is valid and used to create a new\n+   * path if \"prefixPath\" or \"prefixUuid\" is set for actionIfInvalid.\n+   */\n+  pathPrefix?: string;\n+}\n+\n+export type ActionIfBlobMissingAction = \"emptyBlob\";\n+\n+export interface BlobStoreFetchOptions {\n+  /**\n+   * If the blob is not found when fetching, what should we do?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an empty string: return undefined\n+   * - \"emptyBlob\": return a new MediaBlob that has the path set, but nothing else.\n+   */\n+  actionIfBlobMissing?: ActionIfBlobMissingAction;\n+}\n+\n+export interface BlobStoreOptions {\n+  defaultStoreOptions?: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions?: BlobStoreFetchOptions;\n+}\n+\n+/**\n+ * A specialized Store that is designed to handle MediaBlobs and use the\n+ * key that is included in the blob to determine exactly how it is stored.\n+ *\n+ * The full details of a MediaBlob may be changed when it is stored.\n+ * For example, it may get additional or different Metadata. This should be\n+ * what is returned when the store() method is called.\n+ *\n+ * Although BlobStore extends BaseStore, not all of the methods from\n+ * BaseStore may be implemented (or even possible). Those that are not\n+ * implemented should be documented and throw an Error if called.\n+ */\n+export abstract class BlobStore extends BaseStore<string, MediaBlob> {\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  defaultStoreOptions: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions: BlobStoreFetchOptions;\n+\n+  constructor(opts?: BlobStoreOptions) {\n+    super(opts);\n+    this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n+    this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n+  }\n+\n+  protected async _realKey(key: string | MediaBlob): Promise<string> {\n+    return typeof key === \"string\" ? key : await key.asUri();\n+  }\n+\n+  /**\n+   * Is the path set in the MediaBlob supported by this BlobStore?\n+   * Subclasses must implement and evaluate `blob.path` to make this\n+   * determination.\n+   *\n+   * Although this is async, this is expected to be a relatively fast operation\n+   * (ie - you shouldn't make network calls).\n+   *\n+   * The default implementation assumes that undefined blob.paths are invalid\n+   * and then uses the replacePathPrefix (or an empty string) as an assumed path\n+   * to start with.\n+   *\n+   * @param blob The blob to test\n+   * @param opts Any options (if needed) that may be used to determine if it is valid\n+   * @return If the string represented by blob.path is supported.\n+   */\n+  protected _hasValidPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<boolean> {\n+    const path = blob.path ?? \"\";\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const isPrefixed =\n+      typeof blob.path !== \"undefined\" && path.startsWith(prefix);\n+    return Promise.resolve(isPrefixed);\n+  }\n+\n+  protected _blobPathSuffix(blob: MediaBlob): string {\n+    // Get the path currently set and make sure we treat it as a string\n+    const blobPath = `${blob.path}`;\n+\n+    // Advance past the first set of /\n+    let pathStart = blobPath.indexOf(\"/\") + 1;\n+    while (blobPath.charAt(pathStart) === \"/\") {\n+      pathStart += 1;\n+    }\n+\n+    // We will use the rest as the path for a replacement\n+    return blobPath.substring(pathStart);\n+  }\n+\n+  protected async _newBlob(\n+    oldBlob: MediaBlob,\n+    newPath?: string\n+  ): Promise<MediaBlob> {\n+    const oldPath = oldBlob.path;\n+    const metadata = oldBlob?.metadata ?? {};\n+    metadata.langchainOldPath = oldPath;\n+    const newBlob = new MediaBlob({\n+      ...oldBlob,\n+      metadata,\n+    });\n+    if (newPath) {\n+      newBlob.path = newPath;\n+    } else if (newBlob.path) {\n+      delete newBlob.path;\n+    }\n+    return newBlob;\n+  }\n+\n+  protected async _validBlobPrefixPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = this._blobPathSuffix(blob);\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobPrefixUuid(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = uuidv4(); // TODO - option to specify version?\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobRemovePath(\n+    blob: MediaBlob,\n+    _opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    return this._newBlob(blob, undefined);\n+  }\n+\n+  /**\n+   * Based on the blob and options, return a blob that has a valid path\n+   * that can be saved.\n+   * @param blob\n+   * @param opts\n+   */\n+  protected async _validStoreBlob(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob | undefined> {\n+    if (await this._hasValidPath(blob, opts)) {\n+      return blob;\n+    }\n+    switch (opts?.actionIfInvalid) {\n+      case \"ignore\":\n+        return blob;\n+      case \"prefixPath\":\n+        return this._validBlobPrefixPath(blob, opts);\n+      case \"prefixUuid\":\n+        return this._validBlobPrefixUuid(blob, opts);\n+      case \"removePath\":\n+        return this._validBlobRemovePath(blob, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async store(\n+    blob: MediaBlob,\n+    opts: BlobStoreStoreOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreStoreOptions = {\n+      ...this.defaultStoreOptions,\n+      ...opts,\n+    };\n+    const validBlob = await this._validStoreBlob(blob, allOpts);\n+    if (typeof validBlob !== \"undefined\") {\n+      const validKey = await validBlob.asUri();\n+      await this.mset([[validKey, validBlob]]);\n+      const savedKey = await validBlob.asUri();\n+      return await this.fetch(savedKey);\n+    }\n+    return undefined;\n+  }\n+\n+  protected async _missingFetchBlobEmpty(\n+    path: string,\n+    _opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob> {\n+    return new MediaBlob({ path });\n+  }\n+\n+  protected async _missingFetchBlob(\n+    path: string,\n+    opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob | undefined> {\n+    switch (opts?.actionIfBlobMissing) {\n+      case \"emptyBlob\":\n+        return this._missingFetchBlobEmpty(path, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async fetch(\n+    key: string | MediaBlob,\n+    opts: BlobStoreFetchOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreFetchOptions = {\n+      ...this.defaultFetchOptions,\n+      ...opts,\n+    };\n+    const realKey = await this._realKey(key);\n+    const ret = await this.mget([realKey]);\n+    return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n+  }\n+}\n+\n+export interface BackedBlobStoreOptions extends BlobStoreOptions {\n+  backingStore: BaseStore<string, MediaBlob>;\n+}\n+\n+export class BackedBlobStore extends BlobStore {",
        "comment_created_at": "2024-07-05T21:46:14+00:00",
        "comment_author": "eyurtsev",
        "comment_body": "Is this abstraction used?",
        "pr_file_module": null
      },
      {
        "comment_id": "1669461213",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 5835,
        "pr_file": "libs/langchain-google-common/src/experimental/utils/media_core.ts",
        "discussion_id": "1667177345",
        "commented_code": "@@ -0,0 +1,504 @@\n+import { v4 as uuidv4 } from \"uuid\";\n+import { BaseStore } from \"@langchain/core/stores\";\n+import { Serializable } from \"@langchain/core/load/serializable\";\n+\n+export interface MediaBlobParameters {\n+  data?: Blob;\n+\n+  metadata?: Record<string, unknown>;\n+\n+  path?: string;\n+}\n+\n+/**\n+ * Represents a chunk of data that can be identified by the path where the\n+ * data is (or will be) located, along with optional metadata about the data.\n+ */\n+export class MediaBlob\n+  extends Serializable // FIXME - I'm not sure this serializes or deserializes correctly\n+  implements MediaBlobParameters\n+{\n+  lc_serializable = true;\n+\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  data?: Blob;\n+\n+  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+  metadata?: Record<string, any>;\n+\n+  path?: string;\n+\n+  constructor(params?: MediaBlobParameters) {\n+    super(params);\n+    this.data = params?.data;\n+    this.metadata = params?.metadata;\n+    this.path = params?.path;\n+  }\n+\n+  get size(): number {\n+    return this.data?.size ?? 0;\n+  }\n+\n+  get dataType(): string {\n+    return this.data?.type ?? \"\";\n+  }\n+\n+  get encoding(): string {\n+    const charsetEquals = this.dataType.indexOf(\"charset=\");\n+    return charsetEquals === -1\n+      ? \"utf-8\"\n+      : this.dataType.substring(charsetEquals + 8);\n+  }\n+\n+  get mimetype(): string {\n+    const semicolon = this.dataType.indexOf(\";\");\n+    return semicolon === -1\n+      ? this.dataType\n+      : this.dataType.substring(0, semicolon);\n+  }\n+\n+  async asString(): Promise<string> {\n+    const data = this.data ?? new Blob([]);\n+    const dataBuffer = await data.arrayBuffer();\n+    const dataArray = new Uint8Array(dataBuffer);\n+\n+    // Need to handle the array in smaller chunks to deal with stack size limits\n+    let ret = \"\";\n+    const chunkSize = 102400;\n+    for (let i = 0; i < dataArray.length; i += chunkSize) {\n+      const chunk = dataArray.subarray(i, i + chunkSize);\n+      ret += String.fromCharCode(...chunk);\n+    }\n+\n+    return ret;\n+  }\n+\n+  async asBase64(): Promise<string> {\n+    return btoa(await this.asString());\n+  }\n+\n+  async asDataUrl(): Promise<string> {\n+    return `data:${this.mimetype};base64,${await this.asBase64()}`;\n+  }\n+\n+  async asUri(): Promise<string> {\n+    return this.path ?? (await this.asDataUrl());\n+  }\n+\n+  async encode(): Promise<{ encoded: string; encoding: string }> {\n+    const dataUrl = await this.asDataUrl();\n+    const comma = dataUrl.indexOf(\",\");\n+    const encoded = dataUrl.substring(comma + 1);\n+    const encoding: string = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n+    return {\n+      encoded,\n+      encoding,\n+    };\n+  }\n+}\n+\n+export type ActionIfInvalidAction =\n+  | \"ignore\"\n+  | \"prefixPath\"\n+  | \"prefixUuid\"\n+  | \"removePath\";\n+\n+export interface BlobStoreStoreOptions {\n+  /**\n+   * If the path is missing or invalid in the blob, how should we create\n+   * a new path?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an emtpy string: Reject the blob\n+   * - \"ignore\": Attempt to store it anyway (but this may fail)\n+   * - \"prefixPath\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from the URL. The original path is stored in the metadata\n+   * - \"prefixUuid\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from a generated UUID. The original path is stored\n+   *   in the metadata\n+   */\n+  actionIfInvalid?: ActionIfInvalidAction;\n+\n+  /**\n+   * The expected prefix for URIs that are stored.\n+   * This may be used to test if a MediaBlob is valid and used to create a new\n+   * path if \"prefixPath\" or \"prefixUuid\" is set for actionIfInvalid.\n+   */\n+  pathPrefix?: string;\n+}\n+\n+export type ActionIfBlobMissingAction = \"emptyBlob\";\n+\n+export interface BlobStoreFetchOptions {\n+  /**\n+   * If the blob is not found when fetching, what should we do?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an empty string: return undefined\n+   * - \"emptyBlob\": return a new MediaBlob that has the path set, but nothing else.\n+   */\n+  actionIfBlobMissing?: ActionIfBlobMissingAction;\n+}\n+\n+export interface BlobStoreOptions {\n+  defaultStoreOptions?: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions?: BlobStoreFetchOptions;\n+}\n+\n+/**\n+ * A specialized Store that is designed to handle MediaBlobs and use the\n+ * key that is included in the blob to determine exactly how it is stored.\n+ *\n+ * The full details of a MediaBlob may be changed when it is stored.\n+ * For example, it may get additional or different Metadata. This should be\n+ * what is returned when the store() method is called.\n+ *\n+ * Although BlobStore extends BaseStore, not all of the methods from\n+ * BaseStore may be implemented (or even possible). Those that are not\n+ * implemented should be documented and throw an Error if called.\n+ */\n+export abstract class BlobStore extends BaseStore<string, MediaBlob> {\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  defaultStoreOptions: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions: BlobStoreFetchOptions;\n+\n+  constructor(opts?: BlobStoreOptions) {\n+    super(opts);\n+    this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n+    this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n+  }\n+\n+  protected async _realKey(key: string | MediaBlob): Promise<string> {\n+    return typeof key === \"string\" ? key : await key.asUri();\n+  }\n+\n+  /**\n+   * Is the path set in the MediaBlob supported by this BlobStore?\n+   * Subclasses must implement and evaluate `blob.path` to make this\n+   * determination.\n+   *\n+   * Although this is async, this is expected to be a relatively fast operation\n+   * (ie - you shouldn't make network calls).\n+   *\n+   * The default implementation assumes that undefined blob.paths are invalid\n+   * and then uses the replacePathPrefix (or an empty string) as an assumed path\n+   * to start with.\n+   *\n+   * @param blob The blob to test\n+   * @param opts Any options (if needed) that may be used to determine if it is valid\n+   * @return If the string represented by blob.path is supported.\n+   */\n+  protected _hasValidPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<boolean> {\n+    const path = blob.path ?? \"\";\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const isPrefixed =\n+      typeof blob.path !== \"undefined\" && path.startsWith(prefix);\n+    return Promise.resolve(isPrefixed);\n+  }\n+\n+  protected _blobPathSuffix(blob: MediaBlob): string {\n+    // Get the path currently set and make sure we treat it as a string\n+    const blobPath = `${blob.path}`;\n+\n+    // Advance past the first set of /\n+    let pathStart = blobPath.indexOf(\"/\") + 1;\n+    while (blobPath.charAt(pathStart) === \"/\") {\n+      pathStart += 1;\n+    }\n+\n+    // We will use the rest as the path for a replacement\n+    return blobPath.substring(pathStart);\n+  }\n+\n+  protected async _newBlob(\n+    oldBlob: MediaBlob,\n+    newPath?: string\n+  ): Promise<MediaBlob> {\n+    const oldPath = oldBlob.path;\n+    const metadata = oldBlob?.metadata ?? {};\n+    metadata.langchainOldPath = oldPath;\n+    const newBlob = new MediaBlob({\n+      ...oldBlob,\n+      metadata,\n+    });\n+    if (newPath) {\n+      newBlob.path = newPath;\n+    } else if (newBlob.path) {\n+      delete newBlob.path;\n+    }\n+    return newBlob;\n+  }\n+\n+  protected async _validBlobPrefixPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = this._blobPathSuffix(blob);\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobPrefixUuid(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = uuidv4(); // TODO - option to specify version?\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobRemovePath(\n+    blob: MediaBlob,\n+    _opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    return this._newBlob(blob, undefined);\n+  }\n+\n+  /**\n+   * Based on the blob and options, return a blob that has a valid path\n+   * that can be saved.\n+   * @param blob\n+   * @param opts\n+   */\n+  protected async _validStoreBlob(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob | undefined> {\n+    if (await this._hasValidPath(blob, opts)) {\n+      return blob;\n+    }\n+    switch (opts?.actionIfInvalid) {\n+      case \"ignore\":\n+        return blob;\n+      case \"prefixPath\":\n+        return this._validBlobPrefixPath(blob, opts);\n+      case \"prefixUuid\":\n+        return this._validBlobPrefixUuid(blob, opts);\n+      case \"removePath\":\n+        return this._validBlobRemovePath(blob, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async store(\n+    blob: MediaBlob,\n+    opts: BlobStoreStoreOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreStoreOptions = {\n+      ...this.defaultStoreOptions,\n+      ...opts,\n+    };\n+    const validBlob = await this._validStoreBlob(blob, allOpts);\n+    if (typeof validBlob !== \"undefined\") {\n+      const validKey = await validBlob.asUri();\n+      await this.mset([[validKey, validBlob]]);\n+      const savedKey = await validBlob.asUri();\n+      return await this.fetch(savedKey);\n+    }\n+    return undefined;\n+  }\n+\n+  protected async _missingFetchBlobEmpty(\n+    path: string,\n+    _opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob> {\n+    return new MediaBlob({ path });\n+  }\n+\n+  protected async _missingFetchBlob(\n+    path: string,\n+    opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob | undefined> {\n+    switch (opts?.actionIfBlobMissing) {\n+      case \"emptyBlob\":\n+        return this._missingFetchBlobEmpty(path, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async fetch(\n+    key: string | MediaBlob,\n+    opts: BlobStoreFetchOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreFetchOptions = {\n+      ...this.defaultFetchOptions,\n+      ...opts,\n+    };\n+    const realKey = await this._realKey(key);\n+    const ret = await this.mget([realKey]);\n+    return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n+  }\n+}\n+\n+export interface BackedBlobStoreOptions extends BlobStoreOptions {\n+  backingStore: BaseStore<string, MediaBlob>;\n+}\n+\n+export class BackedBlobStore extends BlobStore {",
        "comment_created_at": "2024-07-09T00:02:08+00:00",
        "comment_author": "afirstenberg",
        "comment_body": "Yes.\r\n\r\nI use it in tests for `MediaManager` for an `aliasStore` that is backed by a memory store.\r\nI can also see it used in general for either the `aliasStore` or a retriever that will be using some other defined store to store things. I don't want people to need to re-invent the storage methodology to support the `BlobStore` semantics, but I do want to be able to support them.",
        "pr_file_module": null
      },
      {
        "comment_id": "1699469919",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 5835,
        "pr_file": "libs/langchain-google-common/src/experimental/utils/media_core.ts",
        "discussion_id": "1667177345",
        "commented_code": "@@ -0,0 +1,504 @@\n+import { v4 as uuidv4 } from \"uuid\";\n+import { BaseStore } from \"@langchain/core/stores\";\n+import { Serializable } from \"@langchain/core/load/serializable\";\n+\n+export interface MediaBlobParameters {\n+  data?: Blob;\n+\n+  metadata?: Record<string, unknown>;\n+\n+  path?: string;\n+}\n+\n+/**\n+ * Represents a chunk of data that can be identified by the path where the\n+ * data is (or will be) located, along with optional metadata about the data.\n+ */\n+export class MediaBlob\n+  extends Serializable // FIXME - I'm not sure this serializes or deserializes correctly\n+  implements MediaBlobParameters\n+{\n+  lc_serializable = true;\n+\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  data?: Blob;\n+\n+  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+  metadata?: Record<string, any>;\n+\n+  path?: string;\n+\n+  constructor(params?: MediaBlobParameters) {\n+    super(params);\n+    this.data = params?.data;\n+    this.metadata = params?.metadata;\n+    this.path = params?.path;\n+  }\n+\n+  get size(): number {\n+    return this.data?.size ?? 0;\n+  }\n+\n+  get dataType(): string {\n+    return this.data?.type ?? \"\";\n+  }\n+\n+  get encoding(): string {\n+    const charsetEquals = this.dataType.indexOf(\"charset=\");\n+    return charsetEquals === -1\n+      ? \"utf-8\"\n+      : this.dataType.substring(charsetEquals + 8);\n+  }\n+\n+  get mimetype(): string {\n+    const semicolon = this.dataType.indexOf(\";\");\n+    return semicolon === -1\n+      ? this.dataType\n+      : this.dataType.substring(0, semicolon);\n+  }\n+\n+  async asString(): Promise<string> {\n+    const data = this.data ?? new Blob([]);\n+    const dataBuffer = await data.arrayBuffer();\n+    const dataArray = new Uint8Array(dataBuffer);\n+\n+    // Need to handle the array in smaller chunks to deal with stack size limits\n+    let ret = \"\";\n+    const chunkSize = 102400;\n+    for (let i = 0; i < dataArray.length; i += chunkSize) {\n+      const chunk = dataArray.subarray(i, i + chunkSize);\n+      ret += String.fromCharCode(...chunk);\n+    }\n+\n+    return ret;\n+  }\n+\n+  async asBase64(): Promise<string> {\n+    return btoa(await this.asString());\n+  }\n+\n+  async asDataUrl(): Promise<string> {\n+    return `data:${this.mimetype};base64,${await this.asBase64()}`;\n+  }\n+\n+  async asUri(): Promise<string> {\n+    return this.path ?? (await this.asDataUrl());\n+  }\n+\n+  async encode(): Promise<{ encoded: string; encoding: string }> {\n+    const dataUrl = await this.asDataUrl();\n+    const comma = dataUrl.indexOf(\",\");\n+    const encoded = dataUrl.substring(comma + 1);\n+    const encoding: string = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n+    return {\n+      encoded,\n+      encoding,\n+    };\n+  }\n+}\n+\n+export type ActionIfInvalidAction =\n+  | \"ignore\"\n+  | \"prefixPath\"\n+  | \"prefixUuid\"\n+  | \"removePath\";\n+\n+export interface BlobStoreStoreOptions {\n+  /**\n+   * If the path is missing or invalid in the blob, how should we create\n+   * a new path?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an emtpy string: Reject the blob\n+   * - \"ignore\": Attempt to store it anyway (but this may fail)\n+   * - \"prefixPath\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from the URL. The original path is stored in the metadata\n+   * - \"prefixUuid\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from a generated UUID. The original path is stored\n+   *   in the metadata\n+   */\n+  actionIfInvalid?: ActionIfInvalidAction;\n+\n+  /**\n+   * The expected prefix for URIs that are stored.\n+   * This may be used to test if a MediaBlob is valid and used to create a new\n+   * path if \"prefixPath\" or \"prefixUuid\" is set for actionIfInvalid.\n+   */\n+  pathPrefix?: string;\n+}\n+\n+export type ActionIfBlobMissingAction = \"emptyBlob\";\n+\n+export interface BlobStoreFetchOptions {\n+  /**\n+   * If the blob is not found when fetching, what should we do?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an empty string: return undefined\n+   * - \"emptyBlob\": return a new MediaBlob that has the path set, but nothing else.\n+   */\n+  actionIfBlobMissing?: ActionIfBlobMissingAction;\n+}\n+\n+export interface BlobStoreOptions {\n+  defaultStoreOptions?: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions?: BlobStoreFetchOptions;\n+}\n+\n+/**\n+ * A specialized Store that is designed to handle MediaBlobs and use the\n+ * key that is included in the blob to determine exactly how it is stored.\n+ *\n+ * The full details of a MediaBlob may be changed when it is stored.\n+ * For example, it may get additional or different Metadata. This should be\n+ * what is returned when the store() method is called.\n+ *\n+ * Although BlobStore extends BaseStore, not all of the methods from\n+ * BaseStore may be implemented (or even possible). Those that are not\n+ * implemented should be documented and throw an Error if called.\n+ */\n+export abstract class BlobStore extends BaseStore<string, MediaBlob> {\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  defaultStoreOptions: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions: BlobStoreFetchOptions;\n+\n+  constructor(opts?: BlobStoreOptions) {\n+    super(opts);\n+    this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n+    this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n+  }\n+\n+  protected async _realKey(key: string | MediaBlob): Promise<string> {\n+    return typeof key === \"string\" ? key : await key.asUri();\n+  }\n+\n+  /**\n+   * Is the path set in the MediaBlob supported by this BlobStore?\n+   * Subclasses must implement and evaluate `blob.path` to make this\n+   * determination.\n+   *\n+   * Although this is async, this is expected to be a relatively fast operation\n+   * (ie - you shouldn't make network calls).\n+   *\n+   * The default implementation assumes that undefined blob.paths are invalid\n+   * and then uses the replacePathPrefix (or an empty string) as an assumed path\n+   * to start with.\n+   *\n+   * @param blob The blob to test\n+   * @param opts Any options (if needed) that may be used to determine if it is valid\n+   * @return If the string represented by blob.path is supported.\n+   */\n+  protected _hasValidPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<boolean> {\n+    const path = blob.path ?? \"\";\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const isPrefixed =\n+      typeof blob.path !== \"undefined\" && path.startsWith(prefix);\n+    return Promise.resolve(isPrefixed);\n+  }\n+\n+  protected _blobPathSuffix(blob: MediaBlob): string {\n+    // Get the path currently set and make sure we treat it as a string\n+    const blobPath = `${blob.path}`;\n+\n+    // Advance past the first set of /\n+    let pathStart = blobPath.indexOf(\"/\") + 1;\n+    while (blobPath.charAt(pathStart) === \"/\") {\n+      pathStart += 1;\n+    }\n+\n+    // We will use the rest as the path for a replacement\n+    return blobPath.substring(pathStart);\n+  }\n+\n+  protected async _newBlob(\n+    oldBlob: MediaBlob,\n+    newPath?: string\n+  ): Promise<MediaBlob> {\n+    const oldPath = oldBlob.path;\n+    const metadata = oldBlob?.metadata ?? {};\n+    metadata.langchainOldPath = oldPath;\n+    const newBlob = new MediaBlob({\n+      ...oldBlob,\n+      metadata,\n+    });\n+    if (newPath) {\n+      newBlob.path = newPath;\n+    } else if (newBlob.path) {\n+      delete newBlob.path;\n+    }\n+    return newBlob;\n+  }\n+\n+  protected async _validBlobPrefixPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = this._blobPathSuffix(blob);\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobPrefixUuid(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = uuidv4(); // TODO - option to specify version?\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobRemovePath(\n+    blob: MediaBlob,\n+    _opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    return this._newBlob(blob, undefined);\n+  }\n+\n+  /**\n+   * Based on the blob and options, return a blob that has a valid path\n+   * that can be saved.\n+   * @param blob\n+   * @param opts\n+   */\n+  protected async _validStoreBlob(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob | undefined> {\n+    if (await this._hasValidPath(blob, opts)) {\n+      return blob;\n+    }\n+    switch (opts?.actionIfInvalid) {\n+      case \"ignore\":\n+        return blob;\n+      case \"prefixPath\":\n+        return this._validBlobPrefixPath(blob, opts);\n+      case \"prefixUuid\":\n+        return this._validBlobPrefixUuid(blob, opts);\n+      case \"removePath\":\n+        return this._validBlobRemovePath(blob, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async store(\n+    blob: MediaBlob,\n+    opts: BlobStoreStoreOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreStoreOptions = {\n+      ...this.defaultStoreOptions,\n+      ...opts,\n+    };\n+    const validBlob = await this._validStoreBlob(blob, allOpts);\n+    if (typeof validBlob !== \"undefined\") {\n+      const validKey = await validBlob.asUri();\n+      await this.mset([[validKey, validBlob]]);\n+      const savedKey = await validBlob.asUri();\n+      return await this.fetch(savedKey);\n+    }\n+    return undefined;\n+  }\n+\n+  protected async _missingFetchBlobEmpty(\n+    path: string,\n+    _opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob> {\n+    return new MediaBlob({ path });\n+  }\n+\n+  protected async _missingFetchBlob(\n+    path: string,\n+    opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob | undefined> {\n+    switch (opts?.actionIfBlobMissing) {\n+      case \"emptyBlob\":\n+        return this._missingFetchBlobEmpty(path, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async fetch(\n+    key: string | MediaBlob,\n+    opts: BlobStoreFetchOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreFetchOptions = {\n+      ...this.defaultFetchOptions,\n+      ...opts,\n+    };\n+    const realKey = await this._realKey(key);\n+    const ret = await this.mget([realKey]);\n+    return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n+  }\n+}\n+\n+export interface BackedBlobStoreOptions extends BlobStoreOptions {\n+  backingStore: BaseStore<string, MediaBlob>;\n+}\n+\n+export class BackedBlobStore extends BlobStore {",
        "comment_created_at": "2024-08-01T05:59:07+00:00",
        "comment_author": "jacoblee93",
        "comment_body": "Why not just interact with instances of `this.backingStore` directly?\r\n\r\nWould rather just init three different instances of it or just have some kind of `.bind()` semantic if absolutely necessary - there's a lot of inheritance already\r\n\r\nIf just used for tests, put in a `utils/testing` file",
        "pr_file_module": null
      },
      {
        "comment_id": "1701014291",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 5835,
        "pr_file": "libs/langchain-google-common/src/experimental/utils/media_core.ts",
        "discussion_id": "1667177345",
        "commented_code": "@@ -0,0 +1,504 @@\n+import { v4 as uuidv4 } from \"uuid\";\n+import { BaseStore } from \"@langchain/core/stores\";\n+import { Serializable } from \"@langchain/core/load/serializable\";\n+\n+export interface MediaBlobParameters {\n+  data?: Blob;\n+\n+  metadata?: Record<string, unknown>;\n+\n+  path?: string;\n+}\n+\n+/**\n+ * Represents a chunk of data that can be identified by the path where the\n+ * data is (or will be) located, along with optional metadata about the data.\n+ */\n+export class MediaBlob\n+  extends Serializable // FIXME - I'm not sure this serializes or deserializes correctly\n+  implements MediaBlobParameters\n+{\n+  lc_serializable = true;\n+\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  data?: Blob;\n+\n+  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n+  metadata?: Record<string, any>;\n+\n+  path?: string;\n+\n+  constructor(params?: MediaBlobParameters) {\n+    super(params);\n+    this.data = params?.data;\n+    this.metadata = params?.metadata;\n+    this.path = params?.path;\n+  }\n+\n+  get size(): number {\n+    return this.data?.size ?? 0;\n+  }\n+\n+  get dataType(): string {\n+    return this.data?.type ?? \"\";\n+  }\n+\n+  get encoding(): string {\n+    const charsetEquals = this.dataType.indexOf(\"charset=\");\n+    return charsetEquals === -1\n+      ? \"utf-8\"\n+      : this.dataType.substring(charsetEquals + 8);\n+  }\n+\n+  get mimetype(): string {\n+    const semicolon = this.dataType.indexOf(\";\");\n+    return semicolon === -1\n+      ? this.dataType\n+      : this.dataType.substring(0, semicolon);\n+  }\n+\n+  async asString(): Promise<string> {\n+    const data = this.data ?? new Blob([]);\n+    const dataBuffer = await data.arrayBuffer();\n+    const dataArray = new Uint8Array(dataBuffer);\n+\n+    // Need to handle the array in smaller chunks to deal with stack size limits\n+    let ret = \"\";\n+    const chunkSize = 102400;\n+    for (let i = 0; i < dataArray.length; i += chunkSize) {\n+      const chunk = dataArray.subarray(i, i + chunkSize);\n+      ret += String.fromCharCode(...chunk);\n+    }\n+\n+    return ret;\n+  }\n+\n+  async asBase64(): Promise<string> {\n+    return btoa(await this.asString());\n+  }\n+\n+  async asDataUrl(): Promise<string> {\n+    return `data:${this.mimetype};base64,${await this.asBase64()}`;\n+  }\n+\n+  async asUri(): Promise<string> {\n+    return this.path ?? (await this.asDataUrl());\n+  }\n+\n+  async encode(): Promise<{ encoded: string; encoding: string }> {\n+    const dataUrl = await this.asDataUrl();\n+    const comma = dataUrl.indexOf(\",\");\n+    const encoded = dataUrl.substring(comma + 1);\n+    const encoding: string = dataUrl.indexOf(\"base64\") > -1 ? \"base64\" : \"8bit\";\n+    return {\n+      encoded,\n+      encoding,\n+    };\n+  }\n+}\n+\n+export type ActionIfInvalidAction =\n+  | \"ignore\"\n+  | \"prefixPath\"\n+  | \"prefixUuid\"\n+  | \"removePath\";\n+\n+export interface BlobStoreStoreOptions {\n+  /**\n+   * If the path is missing or invalid in the blob, how should we create\n+   * a new path?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an emtpy string: Reject the blob\n+   * - \"ignore\": Attempt to store it anyway (but this may fail)\n+   * - \"prefixPath\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from the URL. The original path is stored in the metadata\n+   * - \"prefixUuid\": Use the default prefix for the BlobStore and get the\n+   *   unique portion from a generated UUID. The original path is stored\n+   *   in the metadata\n+   */\n+  actionIfInvalid?: ActionIfInvalidAction;\n+\n+  /**\n+   * The expected prefix for URIs that are stored.\n+   * This may be used to test if a MediaBlob is valid and used to create a new\n+   * path if \"prefixPath\" or \"prefixUuid\" is set for actionIfInvalid.\n+   */\n+  pathPrefix?: string;\n+}\n+\n+export type ActionIfBlobMissingAction = \"emptyBlob\";\n+\n+export interface BlobStoreFetchOptions {\n+  /**\n+   * If the blob is not found when fetching, what should we do?\n+   * Subclasses may define their own methods, but the following are supported\n+   * by default:\n+   * - Undefined or an empty string: return undefined\n+   * - \"emptyBlob\": return a new MediaBlob that has the path set, but nothing else.\n+   */\n+  actionIfBlobMissing?: ActionIfBlobMissingAction;\n+}\n+\n+export interface BlobStoreOptions {\n+  defaultStoreOptions?: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions?: BlobStoreFetchOptions;\n+}\n+\n+/**\n+ * A specialized Store that is designed to handle MediaBlobs and use the\n+ * key that is included in the blob to determine exactly how it is stored.\n+ *\n+ * The full details of a MediaBlob may be changed when it is stored.\n+ * For example, it may get additional or different Metadata. This should be\n+ * what is returned when the store() method is called.\n+ *\n+ * Although BlobStore extends BaseStore, not all of the methods from\n+ * BaseStore may be implemented (or even possible). Those that are not\n+ * implemented should be documented and throw an Error if called.\n+ */\n+export abstract class BlobStore extends BaseStore<string, MediaBlob> {\n+  lc_namespace = [\"langchain\", \"google-common\"]; // FIXME - What should this be? And why?\n+\n+  defaultStoreOptions: BlobStoreStoreOptions;\n+\n+  defaultFetchOptions: BlobStoreFetchOptions;\n+\n+  constructor(opts?: BlobStoreOptions) {\n+    super(opts);\n+    this.defaultStoreOptions = opts?.defaultStoreOptions ?? {};\n+    this.defaultFetchOptions = opts?.defaultFetchOptions ?? {};\n+  }\n+\n+  protected async _realKey(key: string | MediaBlob): Promise<string> {\n+    return typeof key === \"string\" ? key : await key.asUri();\n+  }\n+\n+  /**\n+   * Is the path set in the MediaBlob supported by this BlobStore?\n+   * Subclasses must implement and evaluate `blob.path` to make this\n+   * determination.\n+   *\n+   * Although this is async, this is expected to be a relatively fast operation\n+   * (ie - you shouldn't make network calls).\n+   *\n+   * The default implementation assumes that undefined blob.paths are invalid\n+   * and then uses the replacePathPrefix (or an empty string) as an assumed path\n+   * to start with.\n+   *\n+   * @param blob The blob to test\n+   * @param opts Any options (if needed) that may be used to determine if it is valid\n+   * @return If the string represented by blob.path is supported.\n+   */\n+  protected _hasValidPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<boolean> {\n+    const path = blob.path ?? \"\";\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const isPrefixed =\n+      typeof blob.path !== \"undefined\" && path.startsWith(prefix);\n+    return Promise.resolve(isPrefixed);\n+  }\n+\n+  protected _blobPathSuffix(blob: MediaBlob): string {\n+    // Get the path currently set and make sure we treat it as a string\n+    const blobPath = `${blob.path}`;\n+\n+    // Advance past the first set of /\n+    let pathStart = blobPath.indexOf(\"/\") + 1;\n+    while (blobPath.charAt(pathStart) === \"/\") {\n+      pathStart += 1;\n+    }\n+\n+    // We will use the rest as the path for a replacement\n+    return blobPath.substring(pathStart);\n+  }\n+\n+  protected async _newBlob(\n+    oldBlob: MediaBlob,\n+    newPath?: string\n+  ): Promise<MediaBlob> {\n+    const oldPath = oldBlob.path;\n+    const metadata = oldBlob?.metadata ?? {};\n+    metadata.langchainOldPath = oldPath;\n+    const newBlob = new MediaBlob({\n+      ...oldBlob,\n+      metadata,\n+    });\n+    if (newPath) {\n+      newBlob.path = newPath;\n+    } else if (newBlob.path) {\n+      delete newBlob.path;\n+    }\n+    return newBlob;\n+  }\n+\n+  protected async _validBlobPrefixPath(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = this._blobPathSuffix(blob);\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobPrefixUuid(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    const prefix = opts?.pathPrefix ?? \"\";\n+    const suffix = uuidv4(); // TODO - option to specify version?\n+    const newPath = `${prefix}${suffix}`;\n+    return this._newBlob(blob, newPath);\n+  }\n+\n+  protected async _validBlobRemovePath(\n+    blob: MediaBlob,\n+    _opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob> {\n+    return this._newBlob(blob, undefined);\n+  }\n+\n+  /**\n+   * Based on the blob and options, return a blob that has a valid path\n+   * that can be saved.\n+   * @param blob\n+   * @param opts\n+   */\n+  protected async _validStoreBlob(\n+    blob: MediaBlob,\n+    opts?: BlobStoreStoreOptions\n+  ): Promise<MediaBlob | undefined> {\n+    if (await this._hasValidPath(blob, opts)) {\n+      return blob;\n+    }\n+    switch (opts?.actionIfInvalid) {\n+      case \"ignore\":\n+        return blob;\n+      case \"prefixPath\":\n+        return this._validBlobPrefixPath(blob, opts);\n+      case \"prefixUuid\":\n+        return this._validBlobPrefixUuid(blob, opts);\n+      case \"removePath\":\n+        return this._validBlobRemovePath(blob, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async store(\n+    blob: MediaBlob,\n+    opts: BlobStoreStoreOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreStoreOptions = {\n+      ...this.defaultStoreOptions,\n+      ...opts,\n+    };\n+    const validBlob = await this._validStoreBlob(blob, allOpts);\n+    if (typeof validBlob !== \"undefined\") {\n+      const validKey = await validBlob.asUri();\n+      await this.mset([[validKey, validBlob]]);\n+      const savedKey = await validBlob.asUri();\n+      return await this.fetch(savedKey);\n+    }\n+    return undefined;\n+  }\n+\n+  protected async _missingFetchBlobEmpty(\n+    path: string,\n+    _opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob> {\n+    return new MediaBlob({ path });\n+  }\n+\n+  protected async _missingFetchBlob(\n+    path: string,\n+    opts?: BlobStoreFetchOptions\n+  ): Promise<MediaBlob | undefined> {\n+    switch (opts?.actionIfBlobMissing) {\n+      case \"emptyBlob\":\n+        return this._missingFetchBlobEmpty(path, opts);\n+      default:\n+        return undefined;\n+    }\n+  }\n+\n+  async fetch(\n+    key: string | MediaBlob,\n+    opts: BlobStoreFetchOptions = {}\n+  ): Promise<MediaBlob | undefined> {\n+    const allOpts: BlobStoreFetchOptions = {\n+      ...this.defaultFetchOptions,\n+      ...opts,\n+    };\n+    const realKey = await this._realKey(key);\n+    const ret = await this.mget([realKey]);\n+    return ret?.[0] ?? (await this._missingFetchBlob(realKey, allOpts));\n+  }\n+}\n+\n+export interface BackedBlobStoreOptions extends BlobStoreOptions {\n+  backingStore: BaseStore<string, MediaBlob>;\n+}\n+\n+export class BackedBlobStore extends BlobStore {",
        "comment_created_at": "2024-08-01T23:41:41+00:00",
        "comment_author": "afirstenberg",
        "comment_body": "Because the `BlobStore` versions have different semantics for storing an object (they return values from a set while the `BaseStore` versions don't). So rather than reimplementing all of the `BaseStore` implementations (now and in the future), it guarantees those semantics for other `BaseStore` types.  A memory store being the biggest example, but anything that may save to a database or whatever also makes sense.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1695528343",
    "pr_number": 6250,
    "pr_file": "libs/langchain-aws/src/common.ts",
    "created_at": "2024-07-29T16:32:08+00:00",
    "commented_code": ".map((msg) => {\n      if (msg._getType() === \"ai\") {\n        const castMsg = msg as AIMessage;\n        if (typeof castMsg.content === \"string\" && castMsg.content !== \"\") {\n        if (castMsg.tool_calls && castMsg.tool_calls.length) {",
    "repo_full_name": "langchain-ai/langchainjs",
    "discussion_comments": [
      {
        "comment_id": "1695528343",
        "repo_full_name": "langchain-ai/langchainjs",
        "pr_number": 6250,
        "pr_file": "libs/langchain-aws/src/common.ts",
        "discussion_id": "1695528343",
        "commented_code": "@@ -82,7 +82,26 @@ export function convertToConverseMessages(messages: BaseMessage[]): {\n     .map((msg) => {\n       if (msg._getType() === \"ai\") {\n         const castMsg = msg as AIMessage;\n-        if (typeof castMsg.content === \"string\" && castMsg.content !== \"\") {\n+        if (castMsg.tool_calls && castMsg.tool_calls.length) {",
        "comment_created_at": "2024-07-29T16:32:08+00:00",
        "comment_author": "bracesproul",
        "comment_body": "Instead of mapping over it, calling `.reduce` would likely be a better method, so we can keep all content fields. Could you push up this refactor? If not I can push up in a little",
        "pr_file_module": null
      }
    ]
  }
]
