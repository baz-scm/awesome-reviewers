[
  {
    "discussion_id": "2246304468",
    "pr_number": 9077,
    "pr_file": "src/backend/base/langflow/base/mcp/util.py",
    "created_at": "2025-07-31T20:22:12+00:00",
    "commented_code": "class MCPSessionManager:\n-    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\"\"\"\n+    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\n+\n+    Fixed version that addresses the memory leak issue by:\n+    1. Session reuse based on server identity rather than unique context IDs\n+    2. Maximum session limits per server to prevent resource exhaustion\n+    3. Idle timeout for automatic session cleanup\n+    4. Periodic cleanup of stale sessions\n+    \"\"\"\n \n     def __init__(self):\n-        self.sessions = {}  # context_id -> session_info\n+        # Structure: server_key -> {\"sessions\": {session_id: session_info}, \"last_cleanup\": timestamp}\n+        self.sessions_by_server = {}\n         self._background_tasks = set()  # Keep references to background tasks\n-        self._last_server_by_session = {}  # context_id -> server_name for tracking switches\n+        # Backwards-compatibility maps: which context_id uses which (server_key, session_id)\n+        self._context_to_session: dict[str, tuple[str, str]] = {}",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2246304468",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9077,
        "pr_file": "src/backend/base/langflow/base/mcp/util.py",
        "discussion_id": "2246304468",
        "commented_code": "@@ -460,12 +468,90 @@ async def _validate_connection_params(mode: str, command: str | None = None, url\n \n \n class MCPSessionManager:\n-    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\"\"\"\n+    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\n+\n+    Fixed version that addresses the memory leak issue by:\n+    1. Session reuse based on server identity rather than unique context IDs\n+    2. Maximum session limits per server to prevent resource exhaustion\n+    3. Idle timeout for automatic session cleanup\n+    4. Periodic cleanup of stale sessions\n+    \"\"\"\n \n     def __init__(self):\n-        self.sessions = {}  # context_id -> session_info\n+        # Structure: server_key -> {\"sessions\": {session_id: session_info}, \"last_cleanup\": timestamp}\n+        self.sessions_by_server = {}\n         self._background_tasks = set()  # Keep references to background tasks\n-        self._last_server_by_session = {}  # context_id -> server_name for tracking switches\n+        # Backwards-compatibility maps: which context_id uses which (server_key, session_id)\n+        self._context_to_session: dict[str, tuple[str, str]] = {}",
        "comment_created_at": "2025-07-31T20:22:12+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Is this a hack that is required to support backwards compatibility? \r\n\r\nIf so, I like to put a date and version at which this was introduced, which will help us make decisions in the future for if and when we can safely remove it. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2246379689",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9077,
        "pr_file": "src/backend/base/langflow/base/mcp/util.py",
        "discussion_id": "2246304468",
        "commented_code": "@@ -460,12 +468,90 @@ async def _validate_connection_params(mode: str, command: str | None = None, url\n \n \n class MCPSessionManager:\n-    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\"\"\"\n+    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\n+\n+    Fixed version that addresses the memory leak issue by:\n+    1. Session reuse based on server identity rather than unique context IDs\n+    2. Maximum session limits per server to prevent resource exhaustion\n+    3. Idle timeout for automatic session cleanup\n+    4. Periodic cleanup of stale sessions\n+    \"\"\"\n \n     def __init__(self):\n-        self.sessions = {}  # context_id -> session_info\n+        # Structure: server_key -> {\"sessions\": {session_id: session_info}, \"last_cleanup\": timestamp}\n+        self.sessions_by_server = {}\n         self._background_tasks = set()  # Keep references to background tasks\n-        self._last_server_by_session = {}  # context_id -> server_name for tracking switches\n+        # Backwards-compatibility maps: which context_id uses which (server_key, session_id)\n+        self._context_to_session: dict[str, tuple[str, str]] = {}",
        "comment_created_at": "2025-07-31T21:06:59+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "This is a hack for backward compatibility, for old session handling using context id now its a hash.\r\n\r\nIdeally we can remove it in future, how do you suggest to add the note?",
        "pr_file_module": null
      },
      {
        "comment_id": "2248798311",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9077,
        "pr_file": "src/backend/base/langflow/base/mcp/util.py",
        "discussion_id": "2246304468",
        "commented_code": "@@ -460,12 +468,90 @@ async def _validate_connection_params(mode: str, command: str | None = None, url\n \n \n class MCPSessionManager:\n-    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\"\"\"\n+    \"\"\"Manages persistent MCP sessions with proper context manager lifecycle.\n+\n+    Fixed version that addresses the memory leak issue by:\n+    1. Session reuse based on server identity rather than unique context IDs\n+    2. Maximum session limits per server to prevent resource exhaustion\n+    3. Idle timeout for automatic session cleanup\n+    4. Periodic cleanup of stale sessions\n+    \"\"\"\n \n     def __init__(self):\n-        self.sessions = {}  # context_id -> session_info\n+        # Structure: server_key -> {\"sessions\": {session_id: session_info}, \"last_cleanup\": timestamp}\n+        self.sessions_by_server = {}\n         self._background_tasks = set()  # Keep references to background tasks\n-        self._last_server_by_session = {}  # context_id -> server_name for tracking switches\n+        # Backwards-compatibility maps: which context_id uses which (server_key, session_id)\n+        self._context_to_session: dict[str, tuple[str, str]] = {}",
        "comment_created_at": "2025-08-01T20:14:52+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Just put a comment",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132622565",
    "pr_number": 8395,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-06-06T17:54:06+00:00",
    "commented_code": "user_id: str | UUID | None = None,\n ) -> tuple[dict, CustomComponent]:\n     \"\"\"Build the field configuration for a custom component.\"\"\"\n+    # Check if the instance's class is a subclass of Component (but not Component itself)",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2132622565",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8395,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2132622565",
        "commented_code": "@@ -302,6 +305,10 @@ def run_build_config(\n     user_id: str | UUID | None = None,\n ) -> tuple[dict, CustomComponent]:\n     \"\"\"Build the field configuration for a custom component.\"\"\"\n+    # Check if the instance's class is a subclass of Component (but not Component itself)",
        "comment_created_at": "2025-06-06T17:54:06+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Can you add a comment explaining why this is? (iiuc, it's because we're manually creating a `Component` when the input is a user-supplied custom `dict`, in which case we need to compile/parse)",
        "pr_file_module": null
      }
    ]
  }
]