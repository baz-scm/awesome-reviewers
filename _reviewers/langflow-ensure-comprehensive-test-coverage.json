[
  {
    "discussion_id": "2274547503",
    "pr_number": 9317,
    "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
    "created_at": "2025-08-13T20:24:55+00:00",
    "commented_code": null,
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2274547503",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
        "discussion_id": "2274547503",
        "commented_code": null,
        "comment_created_at": "2025-08-13T20:24:55+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "can we add test coverage for this , make be using mocks too?",
        "pr_file_module": null
      },
      {
        "comment_id": "2275415671",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
        "discussion_id": "2274547503",
        "commented_code": null,
        "comment_created_at": "2025-08-14T05:02:16+00:00",
        "comment_author": "2getsandesh",
        "comment_body": "@edwinjosechittilappilly I've added patch/assert statements in `src/backend/tests/unit/services/tracing/test_tracing_service.py` by referring to other integrations such as Arize and Langsmith. Please let me know if any other tests are required.",
        "pr_file_module": null
      },
      {
        "comment_id": "2283111260",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
        "discussion_id": "2274547503",
        "commented_code": null,
        "comment_created_at": "2025-08-18T18:11:13+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "Cool! Thanks for that.\n\nBut lets see if in this or the follow up PR we can add bit more tests to make sure there is coverage. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2240698785",
    "pr_number": 9221,
    "pr_file": "scripts/generate_coverage_config.py",
    "created_at": "2025-07-29T18:58:26+00:00",
    "commented_code": "+#!/usr/bin/env python3\n+\"\"\"Script to generate a custom .coveragerc file for backend testing.\n+\n+This script:\n+1. Reads SIDEBAR_BUNDLES from frontend styleUtils.ts to get bundled component names\n+2. Scans backend components for files containing 'legacy = True'\n+3. Generates a .coveragerc file that omits these paths from coverage reporting\n+\n+Usage:\n+    python scripts/generate_coverage_config.py\n+\"\"\"\n+\n+import re\n+from pathlib import Path\n+\n+\n+def extract_sidebar_bundles(frontend_path: Path) -> set[str]:\n+    \"\"\"Extract component names from SIDEBAR_BUNDLES in styleUtils.ts.\"\"\"\n+    style_utils_path = frontend_path / \"src/utils/styleUtils.ts\"\n+\n+    if not style_utils_path.exists():\n+        print(f\"Warning: styleUtils.ts not found at {style_utils_path}\")\n+        return set()\n+\n+    bundle_names = set()\n+\n+    with style_utils_path.open(encoding=\"utf-8\") as f:\n+        content = f.read()\n+\n+    # Find SIDEBAR_BUNDLES array\n+    sidebar_match = re.search(r\"export const SIDEBAR_BUNDLES = \\[(.*?)\\];\", content, re.DOTALL)\n+    if not sidebar_match:\n+        print(\"Warning: SIDEBAR_BUNDLES not found in styleUtils.ts\")\n+        return set()\n+\n+    bundles_content = sidebar_match.group(1)\n+\n+    # Extract name fields using regex\n+    name_matches = re.findall(r'name:\\s*[\"\\']([^\"\\']+)[\"\\']', bundles_content)\n+\n+    for name in name_matches:\n+        bundle_names.add(name)\n+\n+    print(f\"Found {len(bundle_names)} bundled components from SIDEBAR_BUNDLES\")\n+    return bundle_names\n+\n+\n+def find_legacy_components(backend_components_path: Path) -> set[str]:\n+    \"\"\"Find Python files containing 'legacy = True'.\"\"\"\n+    legacy_files = set()\n+\n+    if not backend_components_path.exists():\n+        print(f\"Warning: Backend components path not found: {backend_components_path}\")\n+        return set()\n+\n+    # Walk through all Python files in components directory\n+    for py_file in backend_components_path.rglob(\"*.py\"):\n+        try:\n+            with py_file.open(encoding=\"utf-8\") as f:\n+                content = f.read()\n+\n+            # Check if file contains 'legacy = True'\n+            if re.search(r\"\\blegacy\\s*=\\s*True\\b\", content):\n+                # Get relative path from components directory\n+                rel_path = py_file.relative_to(backend_components_path)\n+                legacy_files.add(str(rel_path))\n+\n+        except (UnicodeDecodeError, PermissionError) as e:\n+            print(f\"Warning: Could not read {py_file}: {e}\")\n+            continue\n+\n+    print(f\"Found {len(legacy_files)} legacy component files\")\n+    return legacy_files\n+\n+\n+def generate_coveragerc(bundle_names: set[str], legacy_files: set[str], output_path: Path):\n+    \"\"\"Generate .coveragerc file with omit patterns.\"\"\"\n+    # Base coveragerc content\n+    config_content = \"\"\"# Auto-generated .coveragerc file\n+# Generated by scripts/generate_coverage_config.py\n+# Do not edit manually - changes will be overwritten\n+\n+[run]\n+source = src/backend/base/langflow\n+omit =\n+    # Test files\n+    */tests/*\n+    */test_*\n+    */*test*\n+\n+    # Migration files\n+    */alembic/*\n+    */migrations/*\n+\n+    # Cache and build files\n+    */__pycache__/*\n+    */.*\n+\n+    # Init files (typically just imports)\n+    */__init__.py\n+\n+    # Deactivate Components\n+    */components/deactivated/*",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2240698785",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9221,
        "pr_file": "scripts/generate_coverage_config.py",
        "discussion_id": "2240698785",
        "commented_code": "@@ -0,0 +1,168 @@\n+#!/usr/bin/env python3\n+\"\"\"Script to generate a custom .coveragerc file for backend testing.\n+\n+This script:\n+1. Reads SIDEBAR_BUNDLES from frontend styleUtils.ts to get bundled component names\n+2. Scans backend components for files containing 'legacy = True'\n+3. Generates a .coveragerc file that omits these paths from coverage reporting\n+\n+Usage:\n+    python scripts/generate_coverage_config.py\n+\"\"\"\n+\n+import re\n+from pathlib import Path\n+\n+\n+def extract_sidebar_bundles(frontend_path: Path) -> set[str]:\n+    \"\"\"Extract component names from SIDEBAR_BUNDLES in styleUtils.ts.\"\"\"\n+    style_utils_path = frontend_path / \"src/utils/styleUtils.ts\"\n+\n+    if not style_utils_path.exists():\n+        print(f\"Warning: styleUtils.ts not found at {style_utils_path}\")\n+        return set()\n+\n+    bundle_names = set()\n+\n+    with style_utils_path.open(encoding=\"utf-8\") as f:\n+        content = f.read()\n+\n+    # Find SIDEBAR_BUNDLES array\n+    sidebar_match = re.search(r\"export const SIDEBAR_BUNDLES = \\[(.*?)\\];\", content, re.DOTALL)\n+    if not sidebar_match:\n+        print(\"Warning: SIDEBAR_BUNDLES not found in styleUtils.ts\")\n+        return set()\n+\n+    bundles_content = sidebar_match.group(1)\n+\n+    # Extract name fields using regex\n+    name_matches = re.findall(r'name:\\s*[\"\\']([^\"\\']+)[\"\\']', bundles_content)\n+\n+    for name in name_matches:\n+        bundle_names.add(name)\n+\n+    print(f\"Found {len(bundle_names)} bundled components from SIDEBAR_BUNDLES\")\n+    return bundle_names\n+\n+\n+def find_legacy_components(backend_components_path: Path) -> set[str]:\n+    \"\"\"Find Python files containing 'legacy = True'.\"\"\"\n+    legacy_files = set()\n+\n+    if not backend_components_path.exists():\n+        print(f\"Warning: Backend components path not found: {backend_components_path}\")\n+        return set()\n+\n+    # Walk through all Python files in components directory\n+    for py_file in backend_components_path.rglob(\"*.py\"):\n+        try:\n+            with py_file.open(encoding=\"utf-8\") as f:\n+                content = f.read()\n+\n+            # Check if file contains 'legacy = True'\n+            if re.search(r\"\\blegacy\\s*=\\s*True\\b\", content):\n+                # Get relative path from components directory\n+                rel_path = py_file.relative_to(backend_components_path)\n+                legacy_files.add(str(rel_path))\n+\n+        except (UnicodeDecodeError, PermissionError) as e:\n+            print(f\"Warning: Could not read {py_file}: {e}\")\n+            continue\n+\n+    print(f\"Found {len(legacy_files)} legacy component files\")\n+    return legacy_files\n+\n+\n+def generate_coveragerc(bundle_names: set[str], legacy_files: set[str], output_path: Path):\n+    \"\"\"Generate .coveragerc file with omit patterns.\"\"\"\n+    # Base coveragerc content\n+    config_content = \"\"\"# Auto-generated .coveragerc file\n+# Generated by scripts/generate_coverage_config.py\n+# Do not edit manually - changes will be overwritten\n+\n+[run]\n+source = src/backend/base/langflow\n+omit =\n+    # Test files\n+    */tests/*\n+    */test_*\n+    */*test*\n+\n+    # Migration files\n+    */alembic/*\n+    */migrations/*\n+\n+    # Cache and build files\n+    */__pycache__/*\n+    */.*\n+\n+    # Init files (typically just imports)\n+    */__init__.py\n+\n+    # Deactivate Components\n+    */components/deactivated/*",
        "comment_created_at": "2025-07-29T18:58:26+00:00",
        "comment_author": "epinzur",
        "comment_body": "now also excluding deactivated components",
        "pr_file_module": null
      },
      {
        "comment_id": "2240806118",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9221,
        "pr_file": "scripts/generate_coverage_config.py",
        "discussion_id": "2240698785",
        "commented_code": "@@ -0,0 +1,168 @@\n+#!/usr/bin/env python3\n+\"\"\"Script to generate a custom .coveragerc file for backend testing.\n+\n+This script:\n+1. Reads SIDEBAR_BUNDLES from frontend styleUtils.ts to get bundled component names\n+2. Scans backend components for files containing 'legacy = True'\n+3. Generates a .coveragerc file that omits these paths from coverage reporting\n+\n+Usage:\n+    python scripts/generate_coverage_config.py\n+\"\"\"\n+\n+import re\n+from pathlib import Path\n+\n+\n+def extract_sidebar_bundles(frontend_path: Path) -> set[str]:\n+    \"\"\"Extract component names from SIDEBAR_BUNDLES in styleUtils.ts.\"\"\"\n+    style_utils_path = frontend_path / \"src/utils/styleUtils.ts\"\n+\n+    if not style_utils_path.exists():\n+        print(f\"Warning: styleUtils.ts not found at {style_utils_path}\")\n+        return set()\n+\n+    bundle_names = set()\n+\n+    with style_utils_path.open(encoding=\"utf-8\") as f:\n+        content = f.read()\n+\n+    # Find SIDEBAR_BUNDLES array\n+    sidebar_match = re.search(r\"export const SIDEBAR_BUNDLES = \\[(.*?)\\];\", content, re.DOTALL)\n+    if not sidebar_match:\n+        print(\"Warning: SIDEBAR_BUNDLES not found in styleUtils.ts\")\n+        return set()\n+\n+    bundles_content = sidebar_match.group(1)\n+\n+    # Extract name fields using regex\n+    name_matches = re.findall(r'name:\\s*[\"\\']([^\"\\']+)[\"\\']', bundles_content)\n+\n+    for name in name_matches:\n+        bundle_names.add(name)\n+\n+    print(f\"Found {len(bundle_names)} bundled components from SIDEBAR_BUNDLES\")\n+    return bundle_names\n+\n+\n+def find_legacy_components(backend_components_path: Path) -> set[str]:\n+    \"\"\"Find Python files containing 'legacy = True'.\"\"\"\n+    legacy_files = set()\n+\n+    if not backend_components_path.exists():\n+        print(f\"Warning: Backend components path not found: {backend_components_path}\")\n+        return set()\n+\n+    # Walk through all Python files in components directory\n+    for py_file in backend_components_path.rglob(\"*.py\"):\n+        try:\n+            with py_file.open(encoding=\"utf-8\") as f:\n+                content = f.read()\n+\n+            # Check if file contains 'legacy = True'\n+            if re.search(r\"\\blegacy\\s*=\\s*True\\b\", content):\n+                # Get relative path from components directory\n+                rel_path = py_file.relative_to(backend_components_path)\n+                legacy_files.add(str(rel_path))\n+\n+        except (UnicodeDecodeError, PermissionError) as e:\n+            print(f\"Warning: Could not read {py_file}: {e}\")\n+            continue\n+\n+    print(f\"Found {len(legacy_files)} legacy component files\")\n+    return legacy_files\n+\n+\n+def generate_coveragerc(bundle_names: set[str], legacy_files: set[str], output_path: Path):\n+    \"\"\"Generate .coveragerc file with omit patterns.\"\"\"\n+    # Base coveragerc content\n+    config_content = \"\"\"# Auto-generated .coveragerc file\n+# Generated by scripts/generate_coverage_config.py\n+# Do not edit manually - changes will be overwritten\n+\n+[run]\n+source = src/backend/base/langflow\n+omit =\n+    # Test files\n+    */tests/*\n+    */test_*\n+    */*test*\n+\n+    # Migration files\n+    */alembic/*\n+    */migrations/*\n+\n+    # Cache and build files\n+    */__pycache__/*\n+    */.*\n+\n+    # Init files (typically just imports)\n+    */__init__.py\n+\n+    # Deactivate Components\n+    */components/deactivated/*",
        "comment_created_at": "2025-07-29T19:52:51+00:00",
        "comment_author": "epinzur",
        "comment_body": "confirmed here: https://app.codecov.io/gh/langflow-ai/langflow/commit/f068470660973e523a7a98989f155a44cd3b174f/tree/src/backend/base/langflow/components?dropdown=coverage\r\n\r\nAnd now a 3% improvement gain in the backend: https://app.codecov.io/gh/langflow-ai/langflow/pull/9221/components",
        "pr_file_module": null
      }
    ]
  }
]