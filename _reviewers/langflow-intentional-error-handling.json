[
  {
    "discussion_id": "2234627820",
    "pr_number": 9192,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-07-28T04:18:12+00:00",
    "commented_code": "if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n \n-    return frontend_node.to_dict(keep_name=False), cc_instance\n+    # Analyze component dependencies\n+    try:\n+        dependency_info = analyze_component_dependencies(custom_component._code)\n+        frontend_node.metadata[\"dependencies\"] = dependency_info\n+    except (SyntaxError, TypeError, ValueError, ImportError) as exc:\n+        logger.warning(f\"Failed to analyze dependencies for component {ctype_name}: {exc}\")\n+        # Set minimal dependency info on failure",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2234627820",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9192,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2234627820",
        "commented_code": "@@ -485,7 +500,19 @@ def build_custom_component_template_from_inputs(\n         if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n \n-    return frontend_node.to_dict(keep_name=False), cc_instance\n+    # Analyze component dependencies\n+    try:\n+        dependency_info = analyze_component_dependencies(custom_component._code)\n+        frontend_node.metadata[\"dependencies\"] = dependency_info\n+    except (SyntaxError, TypeError, ValueError, ImportError) as exc:\n+        logger.warning(f\"Failed to analyze dependencies for component {ctype_name}: {exc}\")\n+        # Set minimal dependency info on failure",
        "comment_created_at": "2025-07-28T04:18:12+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "What's the behavior downstream of this decision to fallback rather than fail? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2285350801",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9192,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2234627820",
        "commented_code": "@@ -485,7 +500,19 @@ def build_custom_component_template_from_inputs(\n         if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n \n-    return frontend_node.to_dict(keep_name=False), cc_instance\n+    # Analyze component dependencies\n+    try:\n+        dependency_info = analyze_component_dependencies(custom_component._code)\n+        frontend_node.metadata[\"dependencies\"] = dependency_info\n+    except (SyntaxError, TypeError, ValueError, ImportError) as exc:\n+        logger.warning(f\"Failed to analyze dependencies for component {ctype_name}: {exc}\")\n+        # Set minimal dependency info on failure",
        "comment_created_at": "2025-08-19T13:53:13+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "Failing would be good in terms of finding errors faster but since this is not a feature that would break any functionality I didn't want it breaking anything else.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2079760284",
    "pr_number": 7771,
    "pr_file": "src/backend/base/langflow/components/logic/conditional_router.py",
    "created_at": "2025-05-08T13:49:02+00:00",
    "commented_code": "return bool(re.match(match_text, input_text))\n             except re.error:\n                 return False  # Return False if the regex is invalid\n+        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n+            try:\n+                input_num = float(input_text)\n+                match_num = float(match_text)",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2079760284",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 7771,
        "pr_file": "src/backend/base/langflow/components/logic/conditional_router.py",
        "discussion_id": "2079760284",
        "commented_code": "@@ -92,6 +103,20 @@ def evaluate_condition(self, input_text: str, match_text: str, operator: str, *,\n                 return bool(re.match(match_text, input_text))\n             except re.error:\n                 return False  # Return False if the regex is invalid\n+        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n+            try:\n+                input_num = float(input_text)\n+                match_num = float(match_text)",
        "comment_created_at": "2025-05-08T13:49:02+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "you should try/except here to provide a good error message.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2220038435",
    "pr_number": 9107,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-07-21T19:15:52+00:00",
    "commented_code": "reorder_fields(frontend_node, cc_instance._get_field_order())\n     if module_name:\n         frontend_node.metadata[\"module\"] = module_name\n+    else:\n+        module_name = get_module_name_from_display_name(frontend_node.display_name)\n+        frontend_node.metadata[\"module\"] = f\"custom_components.{module_name}\"\n \n-        # Generate code hash for cache invalidation and debugging\n-        code_hash = _generate_code_hash(custom_component._code, module_name, ctype_name)\n+    # Generate code hash for cache invalidation and debugging\n+    try:\n+        code_hash = _generate_code_hash(custom_component._code, module_name)\n         if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n+    except Exception as exc:  # noqa: BLE001\n+        logger.error(f\"Error generating code hash for {custom_component.__class__.__name__}: {exc}\")",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2220038435",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9107,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2220038435",
        "commented_code": "@@ -479,11 +490,17 @@ def build_custom_component_template_from_inputs(\n     reorder_fields(frontend_node, cc_instance._get_field_order())\n     if module_name:\n         frontend_node.metadata[\"module\"] = module_name\n+    else:\n+        module_name = get_module_name_from_display_name(frontend_node.display_name)\n+        frontend_node.metadata[\"module\"] = f\"custom_components.{module_name}\"\n \n-        # Generate code hash for cache invalidation and debugging\n-        code_hash = _generate_code_hash(custom_component._code, module_name, ctype_name)\n+    # Generate code hash for cache invalidation and debugging\n+    try:\n+        code_hash = _generate_code_hash(custom_component._code, module_name)\n         if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n+    except Exception as exc:  # noqa: BLE001\n+        logger.error(f\"Error generating code hash for {custom_component.__class__.__name__}: {exc}\")",
        "comment_created_at": "2025-07-21T19:15:52+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Should this be swallowing? Or do we want to do logger.exc",
        "pr_file_module": null
      },
      {
        "comment_id": "2225286167",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9107,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2220038435",
        "commented_code": "@@ -479,11 +490,17 @@ def build_custom_component_template_from_inputs(\n     reorder_fields(frontend_node, cc_instance._get_field_order())\n     if module_name:\n         frontend_node.metadata[\"module\"] = module_name\n+    else:\n+        module_name = get_module_name_from_display_name(frontend_node.display_name)\n+        frontend_node.metadata[\"module\"] = f\"custom_components.{module_name}\"\n \n-        # Generate code hash for cache invalidation and debugging\n-        code_hash = _generate_code_hash(custom_component._code, module_name, ctype_name)\n+    # Generate code hash for cache invalidation and debugging\n+    try:\n+        code_hash = _generate_code_hash(custom_component._code, module_name)\n         if code_hash:\n             frontend_node.metadata[\"code_hash\"] = code_hash\n+    except Exception as exc:  # noqa: BLE001\n+        logger.error(f\"Error generating code hash for {custom_component.__class__.__name__}: {exc}\")",
        "comment_created_at": "2025-07-23T11:40:44+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "i'll move to debug and add exception",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216382950",
    "pr_number": 8737,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-07-18T15:51:51+00:00",
    "commented_code": "from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2216382950",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8737,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2216382950",
        "commented_code": "@@ -32,6 +33,33 @@\n from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
        "comment_created_at": "2025-07-18T15:51:51+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Do we want this fallback in place, or should we fail fast here",
        "pr_file_module": null
      },
      {
        "comment_id": "2216566554",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8737,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2216382950",
        "commented_code": "@@ -32,6 +33,33 @@\n from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
        "comment_created_at": "2025-07-18T17:27:54+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "Fail fast might be better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177533012",
    "pr_number": 8792,
    "pr_file": "src/backend/base/langflow/base/mcp/util.py",
    "created_at": "2025-07-01T12:53:29+00:00",
    "commented_code": "# Store connection parameters for later use in run_tool\n         self._connection_params = server_params\n \n-        try:\n-            async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n-                await session.initialize()\n-                response = await session.list_tools()\n-                self._connected = True\n-                return response.tools\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            return []\n+        async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n+            await session.initialize()\n+            response = await session.list_tools()\n+            self._connected = True\n+            return response.tools\n \n     async def connect_to_server(self, command_str: str, env: dict[str, str] | None = None) -> list[StructuredTool]:\n         \"\"\"Connect to MCP server using stdio transport (SDK style).\"\"\"\n-        try:\n-            return await asyncio.wait_for(\n-                self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n-            )\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            msg = f\"Failed to connect to MCP stdio server: {e}\"\n-            raise ValueError(msg) from e\n+        return await asyncio.wait_for(\n+            self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n+        )",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2177533012",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8792,
        "pr_file": "src/backend/base/langflow/base/mcp/util.py",
        "discussion_id": "2177533012",
        "commented_code": "@@ -328,30 +405,17 @@ async def _connect_to_server(self, command_str: str, env: dict[str, str] | None\n         # Store connection parameters for later use in run_tool\n         self._connection_params = server_params\n \n-        try:\n-            async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n-                await session.initialize()\n-                response = await session.list_tools()\n-                self._connected = True\n-                return response.tools\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            return []\n+        async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n+            await session.initialize()\n+            response = await session.list_tools()\n+            self._connected = True\n+            return response.tools\n \n     async def connect_to_server(self, command_str: str, env: dict[str, str] | None = None) -> list[StructuredTool]:\n         \"\"\"Connect to MCP server using stdio transport (SDK style).\"\"\"\n-        try:\n-            return await asyncio.wait_for(\n-                self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n-            )\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            msg = f\"Failed to connect to MCP stdio server: {e}\"\n-            raise ValueError(msg) from e\n+        return await asyncio.wait_for(\n+            self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n+        )",
        "comment_created_at": "2025-07-01T12:53:29+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "Why remove try/except?",
        "pr_file_module": null
      },
      {
        "comment_id": "2178125561",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8792,
        "pr_file": "src/backend/base/langflow/base/mcp/util.py",
        "discussion_id": "2177533012",
        "commented_code": "@@ -328,30 +405,17 @@ async def _connect_to_server(self, command_str: str, env: dict[str, str] | None\n         # Store connection parameters for later use in run_tool\n         self._connection_params = server_params\n \n-        try:\n-            async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n-                await session.initialize()\n-                response = await session.list_tools()\n-                self._connected = True\n-                return response.tools\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            return []\n+        async with stdio_client(server_params) as (read, write), ClientSession(read, write) as session:\n+            await session.initialize()\n+            response = await session.list_tools()\n+            self._connected = True\n+            return response.tools\n \n     async def connect_to_server(self, command_str: str, env: dict[str, str] | None = None) -> list[StructuredTool]:\n         \"\"\"Connect to MCP server using stdio transport (SDK style).\"\"\"\n-        try:\n-            return await asyncio.wait_for(\n-                self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n-            )\n-        except (ConnectionError, TimeoutError, OSError, ValueError) as e:\n-            logger.error(f\"Failed to connect to MCP stdio server: {e}\")\n-            self._connection_params = None\n-            self._connected = False\n-            msg = f\"Failed to connect to MCP stdio server: {e}\"\n-            raise ValueError(msg) from e\n+        return await asyncio.wait_for(\n+            self._connect_to_server(command_str, env), timeout=get_settings_service().settings.mcp_server_timeout\n+        )",
        "comment_created_at": "2025-07-01T17:06:48+00:00",
        "comment_author": "lucaseduoli",
        "comment_body": "the try except was removed because the error is being handled a level above. With the try except, we had duplicate logs",
        "pr_file_module": null
      }
    ]
  }
]