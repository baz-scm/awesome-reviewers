[
  {
    "discussion_id": "2138922142",
    "pr_number": 8395,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-06-10T23:34:05+00:00",
    "commented_code": "def get_component_instance(custom_component: CustomComponent, user_id: str | UUID | None = None):\n-    if custom_component._code is None:\n-        error = \"Code is None\"\n-    elif not isinstance(custom_component._code, str):\n-        error = \"Invalid code type\"\n-    else:\n-        try:\n-            custom_class = eval_custom_component_code(custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while evaluating custom component code\")\n-            raise HTTPException(\n-                status_code=400,\n-                detail={\n-                    \"error\": (\"Invalid type conversion. Please check your code and try again.\"),\n-                    \"traceback\": traceback.format_exc(),\n-                },\n-            ) from exc\n-\n-        try:\n-            return custom_class(_user_id=user_id, _code=custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while instantiating custom component\")\n-            if hasattr(exc, \"detail\") and \"traceback\" in exc.detail:\n-                logger.error(exc.detail[\"traceback\"])\n+    \"\"\"Returns an instance of a custom component, evaluating its code if necessary.\n \n-            raise\n+    If the input is already an instance of `Component` or `CustomComponent`, it is returned directly.\n+    Otherwise, the function evaluates the component's code to create and return an instance. Raises an\n+    HTTP 400 error if the code is missing, invalid, or instantiation fails.\n+    \"\"\"\n+    # Fast path: avoid repeated str comparisons\n+    ctype_name = custom_component.__class__.__name__\n+    if ctype_name not in _COMPONENT_TYPE_NAMES:\n+        return custom_component\n+\n+    code = custom_component._code\n+    if not isinstance(code, str):\n+        # Only two failure cases: None, or other non-str\n+        error = \"Code is None\" if code is None else \"Invalid code type\"\n+        msg = f\"Invalid type conversion: {error}. Please check your code and try again.\"\n+        logger.error(msg)\n+        raise HTTPException(status_code=400, detail={\"error\": msg})\n+\n+    # Only now, try to process expensive exception/log traceback only *if needed*\n+    try:\n+        custom_class = eval_custom_component_code(code)",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2138922142",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8395,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2138922142",
        "commented_code": "@@ -263,45 +263,74 @@ def run_build_inputs(\n \n \n def get_component_instance(custom_component: CustomComponent, user_id: str | UUID | None = None):\n-    if custom_component._code is None:\n-        error = \"Code is None\"\n-    elif not isinstance(custom_component._code, str):\n-        error = \"Invalid code type\"\n-    else:\n-        try:\n-            custom_class = eval_custom_component_code(custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while evaluating custom component code\")\n-            raise HTTPException(\n-                status_code=400,\n-                detail={\n-                    \"error\": (\"Invalid type conversion. Please check your code and try again.\"),\n-                    \"traceback\": traceback.format_exc(),\n-                },\n-            ) from exc\n-\n-        try:\n-            return custom_class(_user_id=user_id, _code=custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while instantiating custom component\")\n-            if hasattr(exc, \"detail\") and \"traceback\" in exc.detail:\n-                logger.error(exc.detail[\"traceback\"])\n+    \"\"\"Returns an instance of a custom component, evaluating its code if necessary.\n \n-            raise\n+    If the input is already an instance of `Component` or `CustomComponent`, it is returned directly.\n+    Otherwise, the function evaluates the component's code to create and return an instance. Raises an\n+    HTTP 400 error if the code is missing, invalid, or instantiation fails.\n+    \"\"\"\n+    # Fast path: avoid repeated str comparisons\n+    ctype_name = custom_component.__class__.__name__\n+    if ctype_name not in _COMPONENT_TYPE_NAMES:\n+        return custom_component\n+\n+    code = custom_component._code\n+    if not isinstance(code, str):\n+        # Only two failure cases: None, or other non-str\n+        error = \"Code is None\" if code is None else \"Invalid code type\"\n+        msg = f\"Invalid type conversion: {error}. Please check your code and try again.\"\n+        logger.error(msg)\n+        raise HTTPException(status_code=400, detail={\"error\": msg})\n+\n+    # Only now, try to process expensive exception/log traceback only *if needed*\n+    try:\n+        custom_class = eval_custom_component_code(code)",
        "comment_created_at": "2025-06-10T23:34:05+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "Hi team,\r\nShould we whitelist the modules that can be imported?\r\nAs a wrapper to prevent any malicious code execution?",
        "pr_file_module": null
      },
      {
        "comment_id": "2139880358",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8395,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2138922142",
        "commented_code": "@@ -263,45 +263,74 @@ def run_build_inputs(\n \n \n def get_component_instance(custom_component: CustomComponent, user_id: str | UUID | None = None):\n-    if custom_component._code is None:\n-        error = \"Code is None\"\n-    elif not isinstance(custom_component._code, str):\n-        error = \"Invalid code type\"\n-    else:\n-        try:\n-            custom_class = eval_custom_component_code(custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while evaluating custom component code\")\n-            raise HTTPException(\n-                status_code=400,\n-                detail={\n-                    \"error\": (\"Invalid type conversion. Please check your code and try again.\"),\n-                    \"traceback\": traceback.format_exc(),\n-                },\n-            ) from exc\n-\n-        try:\n-            return custom_class(_user_id=user_id, _code=custom_component._code)\n-        except Exception as exc:\n-            logger.exception(\"Error while instantiating custom component\")\n-            if hasattr(exc, \"detail\") and \"traceback\" in exc.detail:\n-                logger.error(exc.detail[\"traceback\"])\n+    \"\"\"Returns an instance of a custom component, evaluating its code if necessary.\n \n-            raise\n+    If the input is already an instance of `Component` or `CustomComponent`, it is returned directly.\n+    Otherwise, the function evaluates the component's code to create and return an instance. Raises an\n+    HTTP 400 error if the code is missing, invalid, or instantiation fails.\n+    \"\"\"\n+    # Fast path: avoid repeated str comparisons\n+    ctype_name = custom_component.__class__.__name__\n+    if ctype_name not in _COMPONENT_TYPE_NAMES:\n+        return custom_component\n+\n+    code = custom_component._code\n+    if not isinstance(code, str):\n+        # Only two failure cases: None, or other non-str\n+        error = \"Code is None\" if code is None else \"Invalid code type\"\n+        msg = f\"Invalid type conversion: {error}. Please check your code and try again.\"\n+        logger.error(msg)\n+        raise HTTPException(status_code=400, detail={\"error\": msg})\n+\n+    # Only now, try to process expensive exception/log traceback only *if needed*\n+    try:\n+        custom_class = eval_custom_component_code(code)",
        "comment_created_at": "2025-06-11T11:18:36+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "I think so, yes. Now it is a lot easier for us to do that because the official components are processed through a different route. Any time an official component requires a blocklisted module we can just create a function outside of the component code to use it and it should work.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216388570",
    "pr_number": 8737,
    "pr_file": "src/backend/base/langflow/custom/utils.py",
    "created_at": "2025-07-18T15:54:11+00:00",
    "commented_code": "from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]\n+\n+        # Generate SHA256 hash of the source code\n+        return hashlib.sha256(source_code.encode(\"utf-8\")).hexdigest()[:12]  # First 12 chars for brevity\n+    except (UnicodeEncodeError, TypeError, ValueError) as e:\n+        # Handle encoding, type, or value errors during hashing\n+        logger.debug(f\"Could not generate hash for {class_name} in {modname}: {e}\")\n+        # Fallback: hash the module name + class name as a weak identifier\n+        fallback_str = f\"{modname}.{class_name}\"\n+        return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2216388570",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8737,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2216388570",
        "commented_code": "@@ -32,6 +33,33 @@\n from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]\n+\n+        # Generate SHA256 hash of the source code\n+        return hashlib.sha256(source_code.encode(\"utf-8\")).hexdigest()[:12]  # First 12 chars for brevity\n+    except (UnicodeEncodeError, TypeError, ValueError) as e:\n+        # Handle encoding, type, or value errors during hashing\n+        logger.debug(f\"Could not generate hash for {class_name} in {modname}: {e}\")\n+        # Fallback: hash the module name + class name as a weak identifier\n+        fallback_str = f\"{modname}.{class_name}\"\n+        return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
        "comment_created_at": "2025-07-18T15:54:11+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Same question -- what's the downstream consequences if we allow this fallback",
        "pr_file_module": null
      },
      {
        "comment_id": "2216568553",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 8737,
        "pr_file": "src/backend/base/langflow/custom/utils.py",
        "discussion_id": "2216388570",
        "commented_code": "@@ -32,6 +33,33 @@\n from langflow.utils.util import get_base_classes\n \n \n+def _generate_code_hash(source_code: str, modname: str, class_name: str) -> str | None:\n+    \"\"\"Generate a hash of the component source code.\n+\n+    Args:\n+        source_code: The source code string\n+        modname: The module name for fallback identification\n+        class_name: The class name for fallback identification\n+\n+    Returns:\n+        SHA256 hash of the source code, or None if unable to process\n+    \"\"\"\n+    try:\n+        if not source_code:\n+            # Fallback: hash the module name + class name as a weak identifier\n+            fallback_str = f\"{modname}.{class_name}\"\n+            return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]\n+\n+        # Generate SHA256 hash of the source code\n+        return hashlib.sha256(source_code.encode(\"utf-8\")).hexdigest()[:12]  # First 12 chars for brevity\n+    except (UnicodeEncodeError, TypeError, ValueError) as e:\n+        # Handle encoding, type, or value errors during hashing\n+        logger.debug(f\"Could not generate hash for {class_name} in {modname}: {e}\")\n+        # Fallback: hash the module name + class name as a weak identifier\n+        fallback_str = f\"{modname}.{class_name}\"\n+        return hashlib.sha256(fallback_str.encode(\"utf-8\")).hexdigest()[:12]",
        "comment_created_at": "2025-07-18T17:29:19+00:00",
        "comment_author": "ogabrielluiz",
        "comment_body": "The user would be able to fake a component with dangerous code and eval it because the name is safe. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2305917859",
    "pr_number": 9542,
    "pr_file": "src/backend/base/langflow/services/utils.py",
    "created_at": "2025-08-28T01:56:05+00:00",
    "commented_code": "msg = \"Could not create superuser. Please create a superuser manually.\"\n         raise RuntimeError(msg) from exc\n     finally:\n+        # Scrub credentials from in-memory settings after setup",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2305917859",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9542,
        "pr_file": "src/backend/base/langflow/services/utils.py",
        "discussion_id": "2305917859",
        "commented_code": "@@ -96,6 +103,7 @@ async def setup_superuser(settings_service: SettingsService, session: AsyncSessi\n         msg = \"Could not create superuser. Please create a superuser manually.\"\n         raise RuntimeError(msg) from exc\n     finally:\n+        # Scrub credentials from in-memory settings after setup",
        "comment_created_at": "2025-08-28T01:56:05+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "Elaborate on this comment -- add a note saying something like: \r\n```\r\nPrevents users from gaining access to admin credentials by accessing the SUPERUSER environment variables. \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2305922477",
    "pr_number": 9542,
    "pr_file": "src/backend/base/langflow/services/utils.py",
    "created_at": "2025-08-28T01:57:59+00:00",
    "commented_code": "msg = \"Could not create superuser. Please create a superuser manually.\"\n         raise RuntimeError(msg) from exc\n     finally:\n+        # Scrub credentials from in-memory settings after setup\n         settings_service.auth_settings.reset_credentials()",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2305922477",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9542,
        "pr_file": "src/backend/base/langflow/services/utils.py",
        "discussion_id": "2305922477",
        "commented_code": "@@ -96,6 +103,7 @@ async def setup_superuser(settings_service: SettingsService, session: AsyncSessi\n         msg = \"Could not create superuser. Please create a superuser manually.\"\n         raise RuntimeError(msg) from exc\n     finally:\n+        # Scrub credentials from in-memory settings after setup\n         settings_service.auth_settings.reset_credentials()",
        "comment_created_at": "2025-08-28T01:57:59+00:00",
        "comment_author": "jordanrfrazier",
        "comment_body": "`reset_credentials` resets the values to `langflow / langflow`. Maybe we should just clear them completely instead? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2307878572",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9542,
        "pr_file": "src/backend/base/langflow/services/utils.py",
        "discussion_id": "2305922477",
        "commented_code": "@@ -96,6 +103,7 @@ async def setup_superuser(settings_service: SettingsService, session: AsyncSessi\n         msg = \"Could not create superuser. Please create a superuser manually.\"\n         raise RuntimeError(msg) from exc\n     finally:\n+        # Scrub credentials from in-memory settings after setup\n         settings_service.auth_settings.reset_credentials()",
        "comment_created_at": "2025-08-28T16:03:33+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "    def reset_credentials(self) -> None:\r\n        # For AUTO_LOGIN workflows, keep username at default. Otherwise, preserve the\r\n        # configured username but scrub the password from memory to avoid plaintext exposure.\r\n        if self.AUTO_LOGIN:\r\n            self.SUPERUSER = DEFAULT_SUPERUSER\r\n        self.SUPERUSER_PASSWORD = SecretStr(\"\")\r\n        \r\n        \r\n        It resets to empty string, i think it should reset to default password ideally isnt when autologin is True.\r\n        \r\n        @jordanrfrazier  what do you suggest?",
        "pr_file_module": null
      }
    ]
  }
]