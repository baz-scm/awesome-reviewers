[
  {
    "discussion_id": "2274549388",
    "pr_number": 9317,
    "pr_file": "src/backend/base/langflow/custom/custom_component/component.py",
    "created_at": "2025-08-13T20:25:52+00:00",
    "commented_code": "def get_trace_as_metadata(self):\n         return {\n-            input_.name: input_.value\n+            input_.name: getattr(self, input_.name, input_.value)",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2274549388",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/custom/custom_component/component.py",
        "discussion_id": "2274549388",
        "commented_code": "@@ -1020,7 +1020,7 @@ def get_trace_as_inputs(self):\n \n     def get_trace_as_metadata(self):\n         return {\n-            input_.name: input_.value\n+            input_.name: getattr(self, input_.name, input_.value)",
        "comment_created_at": "2025-08-13T20:25:52+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "Will it effect the existing tracing metadata?\n\n@coderabbitai please explain the significance of this change?",
        "pr_file_module": null
      },
      {
        "comment_id": "2283101785",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/custom/custom_component/component.py",
        "discussion_id": "2274549388",
        "commented_code": "@@ -1020,7 +1020,7 @@ def get_trace_as_inputs(self):\n \n     def get_trace_as_metadata(self):\n         return {\n-            input_.name: input_.value\n+            input_.name: getattr(self, input_.name, input_.value)",
        "comment_created_at": "2025-08-18T18:06:26+00:00",
        "comment_author": "edwinjosechittilappilly",
        "comment_body": "@2getsandesh  is this relevant doesnt this effect the traceformat for all other eval and observanility platforms?\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2284004832",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/custom/custom_component/component.py",
        "discussion_id": "2274549388",
        "commented_code": "@@ -1020,7 +1020,7 @@ def get_trace_as_inputs(self):\n \n     def get_trace_as_metadata(self):\n         return {\n-            input_.name: input_.value\n+            input_.name: getattr(self, input_.name, input_.value)",
        "comment_created_at": "2025-08-19T04:05:11+00:00",
        "comment_author": "2getsandesh",
        "comment_body": "> @2getsandesh is this relevant doesnt this effect the traceformat for all other eval and observanility platforms?\r\n\r\nHmm... Seems like it might affect if the dynamically fetched value is not a key/value JSON-serializable metadata.\r\nLet me try to make it a type-safe version. Thanks for pointing it out.",
        "pr_file_module": null
      },
      {
        "comment_id": "2289822423",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/custom/custom_component/component.py",
        "discussion_id": "2274549388",
        "commented_code": "@@ -1020,7 +1020,7 @@ def get_trace_as_inputs(self):\n \n     def get_trace_as_metadata(self):\n         return {\n-            input_.name: input_.value\n+            input_.name: getattr(self, input_.name, input_.value)",
        "comment_created_at": "2025-08-21T04:28:15+00:00",
        "comment_author": "2getsandesh",
        "comment_body": "#[e866e83](https://github.com/langflow-ai/langflow/pull/9317/commits/e866e8348a44618d900cb338209922318f305b0c) This commit introduces a new implementation of get_trace_as_metadata that ensures all metadata values are compatible with OpenTelemetry attribute type restrictions.\r\n\t\u2022\tPrimitive types (str, int, float, bool, None) are stored directly.\r\n\t\u2022\tLists/tuples are sanitized element-by-element, with non-primitive items safely stringified.\r\n\t\u2022\tDicts and complex objects are serialized to JSON strings, with a fallback to str() if needed.\r\n\t\r\n@edwinjosechittilappilly Please let me know if any further changes required. Thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2285474501",
    "pr_number": 9317,
    "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
    "created_at": "2025-08-19T14:33:10+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+import os\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import urlparse\n+\n+from loguru import logger\n+from opentelemetry import trace\n+from traceloop.sdk import Traceloop\n+from traceloop.sdk.instruments import Instruments\n+from typing_extensions import override\n+\n+from langflow.services.tracing.base import BaseTracer\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from uuid import UUID\n+\n+    from langchain.callbacks.base import BaseCallbackHandler\n+\n+    from langflow.graph.vertex.base import Vertex\n+    from langflow.services.tracing.schema import Log\n+\n+\n+class TraceloopTracer(BaseTracer):\n+    \"\"\"Traceloop tracer for Langflow.\"\"\"\n+\n+    def __init__(\n+        self,\n+        trace_name: str,\n+        trace_type: str,\n+        project_name: str,\n+        trace_id: UUID,\n+        user_id: str | None = None,\n+        session_id: str | None = None,\n+    ):\n+        self.trace_id = trace_id\n+        self.trace_name = trace_name\n+        self.trace_type = trace_type\n+        self.project_name = project_name\n+        self.user_id = user_id\n+        self.session_id = session_id\n+        self._span_map: dict[str, trace.Span] = {}  # store spans by trace_name\n+\n+        if not self._validate_configuration():\n+            self._ready = False\n+            return\n+\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        try:\n+            Traceloop.init(\n+                instruments={Instruments.LANGCHAIN},\n+                app_name=project_name,\n+                disable_batch=True,\n+                api_key=api_key,\n+                api_endpoint=os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\"),\n+            )\n+            self._ready = True\n+            self._tracer = trace.get_tracer(\"langflow\")\n+            logger.info(\"Traceloop tracer initialized successfully\")\n+        except (ValueError, RuntimeError, OSError) as e:\n+            logger.error(f\"Failed to initialize Traceloop tracer: {e}\")\n+            self._ready = False\n+\n+    @property\n+    def ready(self) -> bool:\n+        return self._ready\n+\n+    def _validate_configuration(self) -> bool:\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        if not api_key:\n+            logger.warning(\"TRACELOOP_API_KEY not set or empty.\")\n+            return False\n+\n+        base_url = os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\")\n+        parsed = urlparse(base_url)\n+        if not (parsed.scheme in {\"https\"} and parsed.netloc):\n+            logger.error(f\"Invalid TRACELOOP_BASE_URL: {base_url}\")\n+            return False\n+\n+        return True\n+\n+    @override\n+    def add_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        trace_type: str,\n+        inputs: dict[str, Any],\n+        metadata: dict[str, Any] | None = None,\n+        vertex: Vertex | None = None,\n+    ) -> None:\n+        \"\"\"Start a new span for this trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span_name = f\"component.{trace_name}\"\n+        span = self._tracer.start_span(span_name)\n+        span.set_attributes(\n+            {\n+                \"trace_id\": trace_id,\n+                \"trace_name\": trace_name,\n+                \"trace_type\": trace_type,\n+                \"inputs\": str(inputs),\n+                \"vertex_id\": vertex.id if vertex else None,\n+                **(metadata or {}),\n+            }\n+        )\n+\n+        # Store the span so end_trace can finish it\n+        self._span_map[trace_name] = span\n+\n+    @override\n+    def end_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        outputs: dict[str, Any] | None = None,\n+        error: Exception | None = None,\n+        logs: Sequence[Log | dict] = (),\n+    ) -> None:\n+        \"\"\"End the span created in add_trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span = self._span_map.pop(trace_name, None)\n+        if span is None:\n+            logger.warning(f\"No active span found for {trace_name}\")\n+            return\n+\n+        if outputs:\n+            span.set_attributes({\"outputs\": str(outputs)})\n+        if logs:\n+            span.set_attributes({\"logs\": str(logs)})\n+        if error:\n+            span.record_exception(error)\n+\n+        span.end()  # Properly close span\n+\n+    @override\n+    def end(\n+        self,\n+        inputs: dict[str, Any],\n+        outputs: dict[str, Any],\n+        error: Exception | None = None,\n+        metadata: dict[str, Any] | None = None,\n+    ) -> None:\n+        \"\"\"End workflow-level span.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        with self._tracer.start_as_current_span(\"workflow.end\") as span:\n+            span.set_attributes(\n+                {\n+                    \"workflow_name\": self.trace_name,\n+                    \"workflow_id\": str(self.trace_id),\n+                    \"outputs\": str(outputs),\n+                    **(metadata or {}),",
    "repo_full_name": "langflow-ai/langflow",
    "discussion_comments": [
      {
        "comment_id": "2285474501",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
        "discussion_id": "2285474501",
        "commented_code": "@@ -0,0 +1,178 @@\n+from __future__ import annotations\n+\n+import os\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import urlparse\n+\n+from loguru import logger\n+from opentelemetry import trace\n+from traceloop.sdk import Traceloop\n+from traceloop.sdk.instruments import Instruments\n+from typing_extensions import override\n+\n+from langflow.services.tracing.base import BaseTracer\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from uuid import UUID\n+\n+    from langchain.callbacks.base import BaseCallbackHandler\n+\n+    from langflow.graph.vertex.base import Vertex\n+    from langflow.services.tracing.schema import Log\n+\n+\n+class TraceloopTracer(BaseTracer):\n+    \"\"\"Traceloop tracer for Langflow.\"\"\"\n+\n+    def __init__(\n+        self,\n+        trace_name: str,\n+        trace_type: str,\n+        project_name: str,\n+        trace_id: UUID,\n+        user_id: str | None = None,\n+        session_id: str | None = None,\n+    ):\n+        self.trace_id = trace_id\n+        self.trace_name = trace_name\n+        self.trace_type = trace_type\n+        self.project_name = project_name\n+        self.user_id = user_id\n+        self.session_id = session_id\n+        self._span_map: dict[str, trace.Span] = {}  # store spans by trace_name\n+\n+        if not self._validate_configuration():\n+            self._ready = False\n+            return\n+\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        try:\n+            Traceloop.init(\n+                instruments={Instruments.LANGCHAIN},\n+                app_name=project_name,\n+                disable_batch=True,\n+                api_key=api_key,\n+                api_endpoint=os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\"),\n+            )\n+            self._ready = True\n+            self._tracer = trace.get_tracer(\"langflow\")\n+            logger.info(\"Traceloop tracer initialized successfully\")\n+        except (ValueError, RuntimeError, OSError) as e:\n+            logger.error(f\"Failed to initialize Traceloop tracer: {e}\")\n+            self._ready = False\n+\n+    @property\n+    def ready(self) -> bool:\n+        return self._ready\n+\n+    def _validate_configuration(self) -> bool:\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        if not api_key:\n+            logger.warning(\"TRACELOOP_API_KEY not set or empty.\")\n+            return False\n+\n+        base_url = os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\")\n+        parsed = urlparse(base_url)\n+        if not (parsed.scheme in {\"https\"} and parsed.netloc):\n+            logger.error(f\"Invalid TRACELOOP_BASE_URL: {base_url}\")\n+            return False\n+\n+        return True\n+\n+    @override\n+    def add_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        trace_type: str,\n+        inputs: dict[str, Any],\n+        metadata: dict[str, Any] | None = None,\n+        vertex: Vertex | None = None,\n+    ) -> None:\n+        \"\"\"Start a new span for this trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span_name = f\"component.{trace_name}\"\n+        span = self._tracer.start_span(span_name)\n+        span.set_attributes(\n+            {\n+                \"trace_id\": trace_id,\n+                \"trace_name\": trace_name,\n+                \"trace_type\": trace_type,\n+                \"inputs\": str(inputs),\n+                \"vertex_id\": vertex.id if vertex else None,\n+                **(metadata or {}),\n+            }\n+        )\n+\n+        # Store the span so end_trace can finish it\n+        self._span_map[trace_name] = span\n+\n+    @override\n+    def end_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        outputs: dict[str, Any] | None = None,\n+        error: Exception | None = None,\n+        logs: Sequence[Log | dict] = (),\n+    ) -> None:\n+        \"\"\"End the span created in add_trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span = self._span_map.pop(trace_name, None)\n+        if span is None:\n+            logger.warning(f\"No active span found for {trace_name}\")\n+            return\n+\n+        if outputs:\n+            span.set_attributes({\"outputs\": str(outputs)})\n+        if logs:\n+            span.set_attributes({\"logs\": str(logs)})\n+        if error:\n+            span.record_exception(error)\n+\n+        span.end()  # Properly close span\n+\n+    @override\n+    def end(\n+        self,\n+        inputs: dict[str, Any],\n+        outputs: dict[str, Any],\n+        error: Exception | None = None,\n+        metadata: dict[str, Any] | None = None,\n+    ) -> None:\n+        \"\"\"End workflow-level span.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        with self._tracer.start_as_current_span(\"workflow.end\") as span:\n+            span.set_attributes(\n+                {\n+                    \"workflow_name\": self.trace_name,\n+                    \"workflow_id\": str(self.trace_id),\n+                    \"outputs\": str(outputs),\n+                    **(metadata or {}),",
        "comment_created_at": "2025-08-19T14:33:10+00:00",
        "comment_author": "ronensc",
        "comment_body": "\r\nThe `metadata` dict may contain values with types unsupported by OTel, which results in warnings like:  \r\n\r\n```\r\n[2025-08-19 14:09:09,719][WARNING] Invalid type StructuredTool in attribute 'tools' value sequence. Expected one of ['bool', 'str', 'bytes', 'int', 'float'] or None\r\n[2025-08-19 14:09:09,720][WARNING] Invalid type Message for attribute 'input_value' value. Expected one of ['bool', 'str', 'bytes', 'int', 'float'] or a sequence of those types\r\n```\r\nBoth [Opik](https://github.com/langflow-ai/langflow/blob/a973e747cb6e7b4a1f5f1826e351119197df4c66/src/backend/base/langflow/services/tracing/opik.py#L197-L201) and [Arize](https://github.com/langflow-ai/langflow/blob/a973e747cb6e7b4a1f5f1826e351119197df4c66/src/backend/base/langflow/services/tracing/arize_phoenix.py#L295-L301) implement conversion methods to handle this. We could take a similar approach here.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2291529846",
        "repo_full_name": "langflow-ai/langflow",
        "pr_number": 9317,
        "pr_file": "src/backend/base/langflow/services/tracing/traceloop.py",
        "discussion_id": "2285474501",
        "commented_code": "@@ -0,0 +1,178 @@\n+from __future__ import annotations\n+\n+import os\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import urlparse\n+\n+from loguru import logger\n+from opentelemetry import trace\n+from traceloop.sdk import Traceloop\n+from traceloop.sdk.instruments import Instruments\n+from typing_extensions import override\n+\n+from langflow.services.tracing.base import BaseTracer\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from uuid import UUID\n+\n+    from langchain.callbacks.base import BaseCallbackHandler\n+\n+    from langflow.graph.vertex.base import Vertex\n+    from langflow.services.tracing.schema import Log\n+\n+\n+class TraceloopTracer(BaseTracer):\n+    \"\"\"Traceloop tracer for Langflow.\"\"\"\n+\n+    def __init__(\n+        self,\n+        trace_name: str,\n+        trace_type: str,\n+        project_name: str,\n+        trace_id: UUID,\n+        user_id: str | None = None,\n+        session_id: str | None = None,\n+    ):\n+        self.trace_id = trace_id\n+        self.trace_name = trace_name\n+        self.trace_type = trace_type\n+        self.project_name = project_name\n+        self.user_id = user_id\n+        self.session_id = session_id\n+        self._span_map: dict[str, trace.Span] = {}  # store spans by trace_name\n+\n+        if not self._validate_configuration():\n+            self._ready = False\n+            return\n+\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        try:\n+            Traceloop.init(\n+                instruments={Instruments.LANGCHAIN},\n+                app_name=project_name,\n+                disable_batch=True,\n+                api_key=api_key,\n+                api_endpoint=os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\"),\n+            )\n+            self._ready = True\n+            self._tracer = trace.get_tracer(\"langflow\")\n+            logger.info(\"Traceloop tracer initialized successfully\")\n+        except (ValueError, RuntimeError, OSError) as e:\n+            logger.error(f\"Failed to initialize Traceloop tracer: {e}\")\n+            self._ready = False\n+\n+    @property\n+    def ready(self) -> bool:\n+        return self._ready\n+\n+    def _validate_configuration(self) -> bool:\n+        api_key = os.getenv(\"TRACELOOP_API_KEY\", \"\").strip()\n+        if not api_key:\n+            logger.warning(\"TRACELOOP_API_KEY not set or empty.\")\n+            return False\n+\n+        base_url = os.getenv(\"TRACELOOP_BASE_URL\", \"https://api.traceloop.com\")\n+        parsed = urlparse(base_url)\n+        if not (parsed.scheme in {\"https\"} and parsed.netloc):\n+            logger.error(f\"Invalid TRACELOOP_BASE_URL: {base_url}\")\n+            return False\n+\n+        return True\n+\n+    @override\n+    def add_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        trace_type: str,\n+        inputs: dict[str, Any],\n+        metadata: dict[str, Any] | None = None,\n+        vertex: Vertex | None = None,\n+    ) -> None:\n+        \"\"\"Start a new span for this trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span_name = f\"component.{trace_name}\"\n+        span = self._tracer.start_span(span_name)\n+        span.set_attributes(\n+            {\n+                \"trace_id\": trace_id,\n+                \"trace_name\": trace_name,\n+                \"trace_type\": trace_type,\n+                \"inputs\": str(inputs),\n+                \"vertex_id\": vertex.id if vertex else None,\n+                **(metadata or {}),\n+            }\n+        )\n+\n+        # Store the span so end_trace can finish it\n+        self._span_map[trace_name] = span\n+\n+    @override\n+    def end_trace(\n+        self,\n+        trace_id: str,\n+        trace_name: str,\n+        outputs: dict[str, Any] | None = None,\n+        error: Exception | None = None,\n+        logs: Sequence[Log | dict] = (),\n+    ) -> None:\n+        \"\"\"End the span created in add_trace.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        span = self._span_map.pop(trace_name, None)\n+        if span is None:\n+            logger.warning(f\"No active span found for {trace_name}\")\n+            return\n+\n+        if outputs:\n+            span.set_attributes({\"outputs\": str(outputs)})\n+        if logs:\n+            span.set_attributes({\"logs\": str(logs)})\n+        if error:\n+            span.record_exception(error)\n+\n+        span.end()  # Properly close span\n+\n+    @override\n+    def end(\n+        self,\n+        inputs: dict[str, Any],\n+        outputs: dict[str, Any],\n+        error: Exception | None = None,\n+        metadata: dict[str, Any] | None = None,\n+    ) -> None:\n+        \"\"\"End workflow-level span.\"\"\"\n+        if not self.ready:\n+            return\n+\n+        with self._tracer.start_as_current_span(\"workflow.end\") as span:\n+            span.set_attributes(\n+                {\n+                    \"workflow_name\": self.trace_name,\n+                    \"workflow_id\": str(self.trace_id),\n+                    \"outputs\": str(outputs),\n+                    **(metadata or {}),",
        "comment_created_at": "2025-08-21T16:11:08+00:00",
        "comment_author": "2getsandesh",
        "comment_body": "#[928fd99](https://github.com/langflow-ai/langflow/pull/9317/commits/928fd9969bbe91584ffe824b9cc4a7d0da997635) @ronensc This commit added sanitization for inputs and outputs to ensure only valid attribute \r\ntypes are passed and prevents warnings caused by dicts and \r\nother unsupported types.",
        "pr_file_module": null
      }
    ]
  }
]