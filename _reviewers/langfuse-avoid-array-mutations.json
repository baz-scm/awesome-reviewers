[
  {
    "discussion_id": "2161788637",
    "pr_number": 7388,
    "pr_file": "web/src/features/playground/page/components/MessagePlaceholders.tsx",
    "created_at": "2025-06-23T14:35:14+00:00",
    "commented_code": "+import { Divider } from \"@tremor/react\";\n+\n+import { usePlaygroundContext } from \"../context\";\n+import { MessagePlaceholderComponent } from \"./MessagePlaceholderComponent\";\n+\n+export const MessagePlaceholders = () => {\n+  const { messagePlaceholders } = usePlaygroundContext();\n+\n+  return (\n+    <div className=\"flex h-full flex-col\">\n+      <p className=\"font-semibold\">Message Placeholders</p>\n+      {messagePlaceholders.length === 0 ? (\n+        <div className=\"mt-4 text-xs\">\n+          <p className=\"mb-2\">No message placeholders defined.</p>\n+          <p>Placeholders can be used to e.g. inject message histories into prompts.</p>\n+        </div>\n+      ) : (\n+        <div className=\"h-full overflow-auto\">\n+          {messagePlaceholders\n+            .sort((a, b) => {",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2161788637",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7388,
        "pr_file": "web/src/features/playground/page/components/MessagePlaceholders.tsx",
        "discussion_id": "2161788637",
        "commented_code": "@@ -0,0 +1,37 @@\n+import { Divider } from \"@tremor/react\";\n+\n+import { usePlaygroundContext } from \"../context\";\n+import { MessagePlaceholderComponent } from \"./MessagePlaceholderComponent\";\n+\n+export const MessagePlaceholders = () => {\n+  const { messagePlaceholders } = usePlaygroundContext();\n+\n+  return (\n+    <div className=\"flex h-full flex-col\">\n+      <p className=\"font-semibold\">Message Placeholders</p>\n+      {messagePlaceholders.length === 0 ? (\n+        <div className=\"mt-4 text-xs\">\n+          <p className=\"mb-2\">No message placeholders defined.</p>\n+          <p>Placeholders can be used to e.g. inject message histories into prompts.</p>\n+        </div>\n+      ) : (\n+        <div className=\"h-full overflow-auto\">\n+          {messagePlaceholders\n+            .sort((a, b) => {",
        "comment_created_at": "2025-06-23T14:35:14+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Avoid in-place mutation of the context array using sort. Consider using slice() (e.g. messagePlaceholders.slice().sort(...)) to prevent side effects.\n```suggestion\n            .slice().sort((a, b) => {\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169503374",
    "pr_number": 7529,
    "pr_file": "web/src/features/prompts/components/SetPromptVersionLabels/index.tsx",
    "created_at": "2025-06-26T17:01:34+00:00",
    "commented_code": "const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n   const [labels, setLabels] = useState<string[]>([]);\n   const [isAddingLabel, setIsAddingLabel] = useState(false);\n+  const labelsChanged = JSON.stringify(selectedLabels.sort()) !== JSON.stringify(prompt.labels.sort());",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2169503374",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7529,
        "pr_file": "web/src/features/prompts/components/SetPromptVersionLabels/index.tsx",
        "discussion_id": "2169503374",
        "commented_code": "@@ -47,6 +47,7 @@ export function SetPromptVersionLabels({\n   const [selectedLabels, setSelectedLabels] = useState<string[]>([]);\n   const [labels, setLabels] = useState<string[]>([]);\n   const [isAddingLabel, setIsAddingLabel] = useState(false);\n+  const labelsChanged = JSON.stringify(selectedLabels.sort()) !== JSON.stringify(prompt.labels.sort());",
        "comment_created_at": "2025-06-26T17:01:34+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Avoid mutating state arrays by calling .sort() directly. Use a cloned array (e.g., [...selectedLabels].sort()) for a pure comparison.\n```suggestion\n  const labelsChanged = JSON.stringify([...selectedLabels].sort()) !== JSON.stringify([...prompt.labels].sort());\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2033147657",
    "pr_number": 6376,
    "pr_file": "web/src/features/widgets/components/DashboardWidget.tsx",
    "created_at": "2025-04-08T13:02:58+00:00",
    "commented_code": "+import { useMemo } from \"react\";\n+import { api } from \"@/src/utils/api\";\n+import {\n+  views,\n+  metricAggregations,\n+  mapLegacyUiTableFilterToView,\n+} from \"@/src/features/query\";\n+import { z } from \"zod\";\n+import { Chart } from \"@/src/features/widgets/chart-library/Chart\";\n+import { type FilterState } from \"@langfuse/shared\";\n+\n+interface WidgetPlacement {\n+  id: string;\n+  x: number;\n+  y: number;\n+  x_size: number;\n+  y_size: number;\n+}\n+\n+// Generate grid classes for each widget based on position and size\n+const getGridClasses = (widget: WidgetPlacement) => {\n+  return `col-start-${widget.x + 1} col-span-${widget.x_size} row-start-${widget.y + 1} row-span-${widget.y_size}`;\n+};\n+\n+export function DashboardWidget({\n+  key,\n+  projectId,\n+  placement,\n+  dateRange,\n+  filterState,\n+}: {\n+  key: string;\n+  projectId: string;\n+  placement: WidgetPlacement;\n+  dateRange: { from: Date; to: Date } | undefined;\n+  filterState: FilterState;\n+}) {\n+  const widget = api.dashboardWidgets.get.useQuery(\n+    {\n+      widgetId: placement.id,\n+      projectId,\n+    },\n+    {\n+      enabled: Boolean(projectId),\n+    },\n+  );\n+\n+  const fromTimestamp = dateRange\n+    ? dateRange.from\n+    : new Date(new Date().getTime() - 1000);\n+  const toTimestamp = dateRange ? dateRange.to : new Date();\n+\n+  const queryResult = api.dashboard.executeQuery.useQuery(\n+    {\n+      projectId,\n+      query: {\n+        view: (widget.data?.view as z.infer<typeof views>) ?? \"traces\",\n+        dimensions: widget.data?.dimensions ?? [],\n+        metrics:\n+          widget.data?.metrics.map((metric) => ({\n+            measure: metric.measure,\n+            aggregation: metric.agg as z.infer<typeof metricAggregations>,\n+          })) ?? [],\n+        filters: [\n+          ...(widget.data?.filters ?? []),\n+          ...mapLegacyUiTableFilterToView(\n+            (widget.data?.view as z.infer<typeof views>) ?? \"traces\",\n+            filterState,\n+          ),\n+        ],\n+        timeDimension: { granularity: \"auto\" },\n+        fromTimestamp: fromTimestamp.toISOString(),\n+        toTimestamp: toTimestamp.toISOString(),\n+        orderBy: null,\n+      },\n+    },\n+    {\n+      trpc: {\n+        context: {\n+          skipBatch: true,\n+        },\n+      },\n+      enabled: !widget.isLoading && Boolean(widget.data),\n+    },\n+  );\n+\n+  const transformedData = useMemo(() => {\n+    if (!widget.data || !queryResult.data) {\n+      return [];\n+    }\n+    return queryResult.data.map((item: any) => {\n+      // Get the dimension field (first dimension in the query)\n+      const dimensionField =\n+        widget.data.dimensions.slice().shift()?.field ?? \"none\";",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2033147657",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6376,
        "pr_file": "web/src/features/widgets/components/DashboardWidget.tsx",
        "discussion_id": "2033147657",
        "commented_code": "@@ -0,0 +1,149 @@\n+import { useMemo } from \"react\";\n+import { api } from \"@/src/utils/api\";\n+import {\n+  views,\n+  metricAggregations,\n+  mapLegacyUiTableFilterToView,\n+} from \"@/src/features/query\";\n+import { z } from \"zod\";\n+import { Chart } from \"@/src/features/widgets/chart-library/Chart\";\n+import { type FilterState } from \"@langfuse/shared\";\n+\n+interface WidgetPlacement {\n+  id: string;\n+  x: number;\n+  y: number;\n+  x_size: number;\n+  y_size: number;\n+}\n+\n+// Generate grid classes for each widget based on position and size\n+const getGridClasses = (widget: WidgetPlacement) => {\n+  return `col-start-${widget.x + 1} col-span-${widget.x_size} row-start-${widget.y + 1} row-span-${widget.y_size}`;\n+};\n+\n+export function DashboardWidget({\n+  key,\n+  projectId,\n+  placement,\n+  dateRange,\n+  filterState,\n+}: {\n+  key: string;\n+  projectId: string;\n+  placement: WidgetPlacement;\n+  dateRange: { from: Date; to: Date } | undefined;\n+  filterState: FilterState;\n+}) {\n+  const widget = api.dashboardWidgets.get.useQuery(\n+    {\n+      widgetId: placement.id,\n+      projectId,\n+    },\n+    {\n+      enabled: Boolean(projectId),\n+    },\n+  );\n+\n+  const fromTimestamp = dateRange\n+    ? dateRange.from\n+    : new Date(new Date().getTime() - 1000);\n+  const toTimestamp = dateRange ? dateRange.to : new Date();\n+\n+  const queryResult = api.dashboard.executeQuery.useQuery(\n+    {\n+      projectId,\n+      query: {\n+        view: (widget.data?.view as z.infer<typeof views>) ?? \"traces\",\n+        dimensions: widget.data?.dimensions ?? [],\n+        metrics:\n+          widget.data?.metrics.map((metric) => ({\n+            measure: metric.measure,\n+            aggregation: metric.agg as z.infer<typeof metricAggregations>,\n+          })) ?? [],\n+        filters: [\n+          ...(widget.data?.filters ?? []),\n+          ...mapLegacyUiTableFilterToView(\n+            (widget.data?.view as z.infer<typeof views>) ?? \"traces\",\n+            filterState,\n+          ),\n+        ],\n+        timeDimension: { granularity: \"auto\" },\n+        fromTimestamp: fromTimestamp.toISOString(),\n+        toTimestamp: toTimestamp.toISOString(),\n+        orderBy: null,\n+      },\n+    },\n+    {\n+      trpc: {\n+        context: {\n+          skipBatch: true,\n+        },\n+      },\n+      enabled: !widget.isLoading && Boolean(widget.data),\n+    },\n+  );\n+\n+  const transformedData = useMemo(() => {\n+    if (!widget.data || !queryResult.data) {\n+      return [];\n+    }\n+    return queryResult.data.map((item: any) => {\n+      // Get the dimension field (first dimension in the query)\n+      const dimensionField =\n+        widget.data.dimensions.slice().shift()?.field ?? \"none\";",
        "comment_created_at": "2025-04-08T13:02:58+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider using a simpler syntax (e.g. `widget.data.dimensions[0]?.field`) instead of `slice().shift()` for clarity and slight performance improvement.\n```suggestion\n        widget.data.dimensions[0]?.field ?? \"none\";\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013696667",
    "pr_number": 6216,
    "pr_file": "web/src/components/trace/TraceTimelineView.tsx",
    "created_at": "2025-03-26T09:20:09+00:00",
    "commented_code": "},\n   );\n \n-  if (!latency) return null;\n+  const timeIndexRef = useRef<HTMLDivElement>(null);\n+  const timelineContentRef = useRef<HTMLDivElement>(null);\n+  const outerContainerRef = useRef<HTMLDivElement>(null);\n+\n+  const [contentWidth, setContentWidth] = useState(SCALE_WIDTH);\n+\n+  // Use a useLayoutEffect to measure the actual content width after rendering\n+  useLayoutEffect(() => {\n+    if (!timelineContentRef.current) return;\n+\n+    // Use scrollWidth which accounts for all content, including overflow\n+    const scrollWidth = timelineContentRef.current.scrollWidth;\n+\n+    const newWidth = Math.max(SCALE_WIDTH, scrollWidth);\n+    if (newWidth !== contentWidth) {\n+      setContentWidth(newWidth);\n+    }\n+  }, [observations, expandedItems, observations.length, contentWidth]);",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2013696667",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6216,
        "pr_file": "web/src/components/trace/TraceTimelineView.tsx",
        "discussion_id": "2013696667",
        "commented_code": "@@ -494,8 +500,26 @@ export function TraceTimelineView({\n     },\n   );\n \n-  if (!latency) return null;\n+  const timeIndexRef = useRef<HTMLDivElement>(null);\n+  const timelineContentRef = useRef<HTMLDivElement>(null);\n+  const outerContainerRef = useRef<HTMLDivElement>(null);\n+\n+  const [contentWidth, setContentWidth] = useState(SCALE_WIDTH);\n+\n+  // Use a useLayoutEffect to measure the actual content width after rendering\n+  useLayoutEffect(() => {\n+    if (!timelineContentRef.current) return;\n+\n+    // Use scrollWidth which accounts for all content, including overflow\n+    const scrollWidth = timelineContentRef.current.scrollWidth;\n+\n+    const newWidth = Math.max(SCALE_WIDTH, scrollWidth);\n+    if (newWidth !== contentWidth) {\n+      setContentWidth(newWidth);\n+    }\n+  }, [observations, expandedItems, observations.length, contentWidth]);",
        "comment_created_at": "2025-03-26T09:20:09+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Redundant dependency: The dependency array in `useLayoutEffect` includes both `observations` and `observations.length`. `observations` itself covers length changes.\n```suggestion\n  }, [observations, expandedItems, contentWidth]);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013817875",
    "pr_number": 6216,
    "pr_file": "web/src/components/grouped-score-badge.tsx",
    "created_at": "2025-03-26T10:21:08+00:00",
    "commented_code": "HoverCardTrigger,\n } from \"@/src/components/ui/hover-card\";\n import { MessageCircleMoreIcon } from \"lucide-react\";\n-\n import { type APIScore, type LastUserScore } from \"@langfuse/shared\";\n \n+const partitionScores = <T extends APIScore | LastUserScore>(\n+  scores: Record<string, T[]>,\n+  maxVisible?: number,\n+) => {\n+  const sortedScores = Object.entries(scores).sort(([a], [b]) =>\n+    a < b ? -1 : 1,\n+  );\n+  if (!maxVisible) return { visibleScores: sortedScores, hiddenScores: [] };\n+\n+  const visibleScores = sortedScores.slice(0, maxVisible);\n+  const hiddenScores = sortedScores.slice(maxVisible);\n+  return { visibleScores, hiddenScores };\n+};\n+\n+const ScoreGroupBadge = <T extends APIScore | LastUserScore>({\n+  name,\n+  scores,\n+}: {\n+  name: string;\n+  scores: T[];\n+}) => {\n+  return (\n+    <Badge\n+      variant=\"tertiary\"\n+      key={name}",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2013817875",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6216,
        "pr_file": "web/src/components/grouped-score-badge.tsx",
        "discussion_id": "2013817875",
        "commented_code": "@@ -5,13 +5,69 @@ import {\n   HoverCardTrigger,\n } from \"@/src/components/ui/hover-card\";\n import { MessageCircleMoreIcon } from \"lucide-react\";\n-\n import { type APIScore, type LastUserScore } from \"@langfuse/shared\";\n \n+const partitionScores = <T extends APIScore | LastUserScore>(\n+  scores: Record<string, T[]>,\n+  maxVisible?: number,\n+) => {\n+  const sortedScores = Object.entries(scores).sort(([a], [b]) =>\n+    a < b ? -1 : 1,\n+  );\n+  if (!maxVisible) return { visibleScores: sortedScores, hiddenScores: [] };\n+\n+  const visibleScores = sortedScores.slice(0, maxVisible);\n+  const hiddenScores = sortedScores.slice(maxVisible);\n+  return { visibleScores, hiddenScores };\n+};\n+\n+const ScoreGroupBadge = <T extends APIScore | LastUserScore>({\n+  name,\n+  scores,\n+}: {\n+  name: string;\n+  scores: T[];\n+}) => {\n+  return (\n+    <Badge\n+      variant=\"tertiary\"\n+      key={name}",
        "comment_created_at": "2025-03-26T10:21:08+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Redundant key prop: The `<Badge>` inside `ScoreGroupBadge` receives a key prop, but `ScoreGroupBadge` itself is keyed when mapped by the parent. Remove the key here as React\u2019s keys are only needed in the list mapping.\n```suggestion\n\n```",
        "pr_file_module": null
      }
    ]
  }
]