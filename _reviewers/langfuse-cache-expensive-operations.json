[
  {
    "discussion_id": "2174556806",
    "pr_number": 7012,
    "pr_file": "web/src/features/prompts/server/routers/promptRouter.ts",
    "created_at": "2025-06-30T08:48:28+00:00",
    "commented_code": "// Unlock cache\n         await promptService.unlockCache({ projectId, promptName });\n+\n+        // Trigger webhooks for prompt deletion\n+        await Promise.all(\n+          resolvedPrompts.map(async (prompt) =>\n+            promptChangeEventSourcing(\n+              await promptService.resolvePrompt(prompt),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2174556806",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7012,
        "pr_file": "web/src/features/prompts/server/routers/promptRouter.ts",
        "discussion_id": "2174556806",
        "commented_code": "@@ -448,6 +454,16 @@ export const promptRouter = createTRPCRouter({\n \n         // Unlock cache\n         await promptService.unlockCache({ projectId, promptName });\n+\n+        // Trigger webhooks for prompt deletion\n+        await Promise.all(\n+          resolvedPrompts.map(async (prompt) =>\n+            promptChangeEventSourcing(\n+              await promptService.resolvePrompt(prompt),",
        "comment_created_at": "2025-06-30T08:48:28+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Redundant call: In the delete mutation, resolvedPrompts is computed earlier but then each prompt is passed to promptService.resolvePrompt again. Consider reusing the already resolved versions to avoid unnecessary async overhead.\n```suggestion\n              prompt,\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178489362",
    "pr_number": 7615,
    "pr_file": "worker/src/features/experiments/experimentService.ts",
    "created_at": "2025-07-01T20:50:13+00:00",
    "commented_code": "variables: string[],\n ): ChatMessage[] => {\n   const processContent = (content: string) => {\n-    // Extract only relevant variables from itemInput\n+    // Extract only Handlebars variables from itemInput (exclude message placeholders)\n+    const placeholderNames = extractPlaceholderNames(prompt as PromptMessage[]);",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2178489362",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7615,
        "pr_file": "worker/src/features/experiments/experimentService.ts",
        "discussion_id": "2178489362",
        "commented_code": "@@ -47,9 +48,12 @@ const replaceVariablesInPrompt = (\n   variables: string[],\n ): ChatMessage[] => {\n   const processContent = (content: string) => {\n-    // Extract only relevant variables from itemInput\n+    // Extract only Handlebars variables from itemInput (exclude message placeholders)\n+    const placeholderNames = extractPlaceholderNames(prompt as PromptMessage[]);",
        "comment_created_at": "2025-07-01T20:50:13+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Placeholder extraction runs on each call to processContent. Consider computing it once outside for performance.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2155072793",
    "pr_number": 7389,
    "pr_file": "packages/shared/seeder/clickhouse-builder.ts",
    "created_at": "2025-06-18T16:43:32+00:00",
    "commented_code": "+import { SEED_TEXT_PROMPTS } from \"./postgres-seed-constants\";\n+import { TraceData, ObservationData, ScoreData } from \"./types\";\n+\n+export class ClickHouseQueryBuilder {\n+  private escapeString(str: string): string {\n+    return str.replace(/'/g, \"''\");\n+  }\n+\n+  private formatValue(value: any): string {\n+    if (value === null || value === undefined) {\n+      return \"NULL\";\n+    }\n+    if (typeof value === \"string\") {\n+      return `'${this.escapeString(value)}'`;\n+    }\n+    if (typeof value === \"object\") {\n+      return `'${this.escapeString(JSON.stringify(value))}'`;\n+    }\n+    return String(value);\n+  }\n+\n+  private formatArray(arr: string[]): string {\n+    if (!arr || arr.length === 0) return \"array()\";\n+    return `array(${arr.map((item) => `'${this.escapeString(item)}'`).join(\", \")})`;\n+  }\n+\n+  private formatMap(obj: Record<string, any>): string {\n+    if (!obj || Object.keys(obj).length === 0) return \"map()\";\n+    const entries = Object.entries(obj).map(\n+      ([key, value]) =>\n+        `'${this.escapeString(key)}', ${this.formatValue(value)}`,\n+    );\n+    return `map(${entries.join(\", \")})`;\n+  }\n+\n+  buildTracesInsert(\n+    projectId: string,\n+    traces: TraceData[],\n+    batchSize: number = 1000,\n+  ): string {\n+    const chunks = this.chunkArray(traces, batchSize);\n+\n+    return chunks\n+      .map((chunk) => {\n+        const values = chunk\n+          .map(\n+            (trace) => `(\n+        '${trace.id}',\n+        toDateTime('${new Date().toISOString().slice(0, 19).replace(\"T\", \" \")}'),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2155072793",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7389,
        "pr_file": "packages/shared/seeder/clickhouse-builder.ts",
        "discussion_id": "2155072793",
        "commented_code": "@@ -0,0 +1,377 @@\n+import { SEED_TEXT_PROMPTS } from \"./postgres-seed-constants\";\n+import { TraceData, ObservationData, ScoreData } from \"./types\";\n+\n+export class ClickHouseQueryBuilder {\n+  private escapeString(str: string): string {\n+    return str.replace(/'/g, \"''\");\n+  }\n+\n+  private formatValue(value: any): string {\n+    if (value === null || value === undefined) {\n+      return \"NULL\";\n+    }\n+    if (typeof value === \"string\") {\n+      return `'${this.escapeString(value)}'`;\n+    }\n+    if (typeof value === \"object\") {\n+      return `'${this.escapeString(JSON.stringify(value))}'`;\n+    }\n+    return String(value);\n+  }\n+\n+  private formatArray(arr: string[]): string {\n+    if (!arr || arr.length === 0) return \"array()\";\n+    return `array(${arr.map((item) => `'${this.escapeString(item)}'`).join(\", \")})`;\n+  }\n+\n+  private formatMap(obj: Record<string, any>): string {\n+    if (!obj || Object.keys(obj).length === 0) return \"map()\";\n+    const entries = Object.entries(obj).map(\n+      ([key, value]) =>\n+        `'${this.escapeString(key)}', ${this.formatValue(value)}`,\n+    );\n+    return `map(${entries.join(\", \")})`;\n+  }\n+\n+  buildTracesInsert(\n+    projectId: string,\n+    traces: TraceData[],\n+    batchSize: number = 1000,\n+  ): string {\n+    const chunks = this.chunkArray(traces, batchSize);\n+\n+    return chunks\n+      .map((chunk) => {\n+        const values = chunk\n+          .map(\n+            (trace) => `(\n+        '${trace.id}',\n+        toDateTime('${new Date().toISOString().slice(0, 19).replace(\"T\", \" \")}'),",
        "comment_created_at": "2025-06-18T16:43:32+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Repeated calls to `new Date()` in query-building may yield slightly different timestamps across rows. Consider computing the timestamp once and reusing it for consistency.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2097343431",
    "pr_number": 6928,
    "pr_file": "web/src/ee/features/multi-tenant-sso/utils.ts",
    "created_at": "2025-05-20T08:33:40+00:00",
    "commented_code": "> => {\n   const allConfigs = await getSsoConfigs();\n \n-  const config = allConfigs.find(\n-    (c) => getAuthProviderIdForSsoConfig(c) === providerId,\n-  );\n+  const config = allConfigs",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2097343431",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6928,
        "pr_file": "web/src/ee/features/multi-tenant-sso/utils.ts",
        "discussion_id": "2097343431",
        "commented_code": "@@ -259,9 +259,9 @@ export const findMultiTenantSsoConfig = async ({\n > => {\n   const allConfigs = await getSsoConfigs();\n \n-  const config = allConfigs.find(\n-    (c) => getAuthProviderIdForSsoConfig(c) === providerId,\n-  );\n+  const config = allConfigs",
        "comment_created_at": "2025-05-20T08:33:40+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider consolidating the filter and find into a single iteration. For example, instead of filtering then finding, use:\n\n  `allConfigs.find(c => c.authConfig && getAuthProviderIdForSsoConfig(c) === providerId)`\n\nThis is both more efficient and concise.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2089083127",
    "pr_number": 6829,
    "pr_file": "web/src/__tests__/queryBuilder.servertest.ts",
    "created_at": "2025-05-14T14:24:59+00:00",
    "commented_code": "expect(result.data[0].name).toBe(\"score-premium\");\n         expect(parseFloat(result.data[0].avg_value)).toBeCloseTo(0.95);\n       });\n+\n+      it(\"LFE-4838: should filter scores-numeric by scoreName (fallback handling) without errors\", async () => {\n+        // Setup\n+        const projectId = randomUUID();\n+\n+        // Create trace\n+        const trace = createTrace({\n+          project_id: projectId,\n+          name: \"score-name-test-trace\",\n+          environment: \"production\",\n+        });\n+        await createTracesCh([trace]);\n+\n+        // Create scores with different names\n+        const scores = [\n+          {\n+            name: \"accuracy\",\n+            traceId: trace.id,\n+            value: 0.9,\n+            dataType: \"NUMERIC\" as const,\n+          },\n+          {\n+            name: \"relevance\",\n+            traceId: trace.id,\n+            value: 0.85,\n+            dataType: \"NUMERIC\" as const,\n+          },\n+        ];\n+\n+        await setupScores(projectId, scores);\n+\n+        // Define query with filter using \"scoreName\" instead of \"name\"\n+        // This tests the fallback handling in queryBuilder.ts that handles column names ending with \"Name\"\n+        const query: QueryType = {\n+          view: \"scores-numeric\",\n+          dimensions: [{ field: \"name\" }],\n+          metrics: [{ measure: \"count\", aggregation: \"count\" }],\n+          filters: [\n+            {\n+              column: \"scoreName\", // Using scoreName instead of name to test the fallback logic\n+              operator: \"=\",\n+              value: \"accuracy\",\n+              type: \"string\",\n+            },\n+          ],\n+          timeDimension: null,\n+          fromTimestamp: new Date(",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2089083127",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6829,
        "pr_file": "web/src/__tests__/queryBuilder.servertest.ts",
        "discussion_id": "2089083127",
        "commented_code": "@@ -2519,6 +2519,83 @@ describe(\"queryBuilder\", () => {\n         expect(result.data[0].name).toBe(\"score-premium\");\n         expect(parseFloat(result.data[0].avg_value)).toBeCloseTo(0.95);\n       });\n+\n+      it(\"LFE-4838: should filter scores-numeric by scoreName (fallback handling) without errors\", async () => {\n+        // Setup\n+        const projectId = randomUUID();\n+\n+        // Create trace\n+        const trace = createTrace({\n+          project_id: projectId,\n+          name: \"score-name-test-trace\",\n+          environment: \"production\",\n+        });\n+        await createTracesCh([trace]);\n+\n+        // Create scores with different names\n+        const scores = [\n+          {\n+            name: \"accuracy\",\n+            traceId: trace.id,\n+            value: 0.9,\n+            dataType: \"NUMERIC\" as const,\n+          },\n+          {\n+            name: \"relevance\",\n+            traceId: trace.id,\n+            value: 0.85,\n+            dataType: \"NUMERIC\" as const,\n+          },\n+        ];\n+\n+        await setupScores(projectId, scores);\n+\n+        // Define query with filter using \"scoreName\" instead of \"name\"\n+        // This tests the fallback handling in queryBuilder.ts that handles column names ending with \"Name\"\n+        const query: QueryType = {\n+          view: \"scores-numeric\",\n+          dimensions: [{ field: \"name\" }],\n+          metrics: [{ measure: \"count\", aggregation: \"count\" }],\n+          filters: [\n+            {\n+              column: \"scoreName\", // Using scoreName instead of name to test the fallback logic\n+              operator: \"=\",\n+              value: \"accuracy\",\n+              type: \"string\",\n+            },\n+          ],\n+          timeDimension: null,\n+          fromTimestamp: new Date(",
        "comment_created_at": "2025-05-14T14:24:59+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider caching the current time in a variable instead of calling `new Date()` multiple times when constructing the `fromTimestamp` and `toTimestamp`. This avoids slight time-drift issues in tests.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2003256936",
    "pr_number": 6039,
    "pr_file": "worker/src/__tests__/evalService.filtering.test.ts",
    "created_at": "2025-03-19T12:50:46+00:00",
    "commented_code": "+import { EvalTemplate, ObservationLevel, singleFilter } from \"@langfuse/shared\";\n+import { kyselyPrisma, prisma } from \"@langfuse/shared/src/db\";\n+import {\n+  convertDateToClickhouseDateTime,\n+  upsertObservation,\n+  upsertTrace,\n+} from \"@langfuse/shared/src/server\";\n+import { randomUUID } from \"crypto\";\n+import Decimal from \"decimal.js\";\n+import { afterEach } from \"node:test\";\n+import {\n+  afterAll,\n+  beforeAll,\n+  beforeEach,\n+  describe,\n+  expect,\n+  test as baseTest,\n+} from \"vitest\";\n+import { z } from \"zod\";\n+import { createEvalJobs } from \"../ee/evaluation/evalService\";\n+import { OpenAIServer } from \"./network\";\n+import { pruneDatabase } from \"./utils\";\n+\n+let OPENAI_API_KEY = process.env.OPENAI_API_KEY;\n+const hasActiveKey = Boolean(OPENAI_API_KEY);\n+if (!hasActiveKey) {\n+  OPENAI_API_KEY = \"sk-test_not_used_as_network_mocks_are_activated\";\n+}\n+const openAIServer = new OpenAIServer({\n+  hasActiveKey,\n+  useDefaultResponse: false,\n+});\n+\n+beforeAll(openAIServer.setup);\n+beforeEach(async () => {\n+  await pruneDatabase();\n+  openAIServer.respondWithDefault();\n+});\n+afterEach(openAIServer.reset);\n+afterAll(openAIServer.teardown);\n+\n+const test = baseTest.extend<{\n+  traceId1: string;\n+  traceId2: string;\n+  evalTemplate: EvalTemplate;\n+  projectId: string;\n+}>({\n+  projectId: \"7a88fb47-b4e2-43b8-a06c-a5ce950dc53a\",\n+  traceId1: randomUUID(),\n+  traceId2: randomUUID(),\n+  evalTemplate: async ({}, use) => {\n+    const evalTemplate = await prisma.evalTemplate.create({\n+      data: {\n+        id: randomUUID(),\n+        projectId: \"7a88fb47-b4e2-43b8-a06c-a5ce950dc53a\",\n+        name: \"test-template\",\n+        version: 1,\n+        prompt: \"Evaluate this trace\",\n+        model: \"gpt-3.5-turbo\",\n+        provider: \"openai\",\n+        modelParams: { temperature: 0 },\n+        vars: [],\n+        outputSchema: {\n+          type: \"object\",\n+          properties: { score: { type: \"number\" } },\n+        },\n+      },\n+    });\n+\n+    await use(evalTemplate);\n+  },\n+});\n+\n+describe(\"test eval filtering\", () => {\n+  test(\"creates eval job only for matching environment\", async ({\n+    traceId1,\n+    traceId2,\n+    evalTemplate,\n+    projectId,\n+  }) => {\n+    // Create two traces with different environments\n+    await upsertTrace({\n+      id: traceId1,\n+      project_id: projectId,\n+      environment: \"production\",\n+      timestamp: convertDateToClickhouseDateTime(new Date()),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2003256936",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6039,
        "pr_file": "worker/src/__tests__/evalService.filtering.test.ts",
        "discussion_id": "2003256936",
        "commented_code": "@@ -0,0 +1,1006 @@\n+import { EvalTemplate, ObservationLevel, singleFilter } from \"@langfuse/shared\";\n+import { kyselyPrisma, prisma } from \"@langfuse/shared/src/db\";\n+import {\n+  convertDateToClickhouseDateTime,\n+  upsertObservation,\n+  upsertTrace,\n+} from \"@langfuse/shared/src/server\";\n+import { randomUUID } from \"crypto\";\n+import Decimal from \"decimal.js\";\n+import { afterEach } from \"node:test\";\n+import {\n+  afterAll,\n+  beforeAll,\n+  beforeEach,\n+  describe,\n+  expect,\n+  test as baseTest,\n+} from \"vitest\";\n+import { z } from \"zod\";\n+import { createEvalJobs } from \"../ee/evaluation/evalService\";\n+import { OpenAIServer } from \"./network\";\n+import { pruneDatabase } from \"./utils\";\n+\n+let OPENAI_API_KEY = process.env.OPENAI_API_KEY;\n+const hasActiveKey = Boolean(OPENAI_API_KEY);\n+if (!hasActiveKey) {\n+  OPENAI_API_KEY = \"sk-test_not_used_as_network_mocks_are_activated\";\n+}\n+const openAIServer = new OpenAIServer({\n+  hasActiveKey,\n+  useDefaultResponse: false,\n+});\n+\n+beforeAll(openAIServer.setup);\n+beforeEach(async () => {\n+  await pruneDatabase();\n+  openAIServer.respondWithDefault();\n+});\n+afterEach(openAIServer.reset);\n+afterAll(openAIServer.teardown);\n+\n+const test = baseTest.extend<{\n+  traceId1: string;\n+  traceId2: string;\n+  evalTemplate: EvalTemplate;\n+  projectId: string;\n+}>({\n+  projectId: \"7a88fb47-b4e2-43b8-a06c-a5ce950dc53a\",\n+  traceId1: randomUUID(),\n+  traceId2: randomUUID(),\n+  evalTemplate: async ({}, use) => {\n+    const evalTemplate = await prisma.evalTemplate.create({\n+      data: {\n+        id: randomUUID(),\n+        projectId: \"7a88fb47-b4e2-43b8-a06c-a5ce950dc53a\",\n+        name: \"test-template\",\n+        version: 1,\n+        prompt: \"Evaluate this trace\",\n+        model: \"gpt-3.5-turbo\",\n+        provider: \"openai\",\n+        modelParams: { temperature: 0 },\n+        vars: [],\n+        outputSchema: {\n+          type: \"object\",\n+          properties: { score: { type: \"number\" } },\n+        },\n+      },\n+    });\n+\n+    await use(evalTemplate);\n+  },\n+});\n+\n+describe(\"test eval filtering\", () => {\n+  test(\"creates eval job only for matching environment\", async ({\n+    traceId1,\n+    traceId2,\n+    evalTemplate,\n+    projectId,\n+  }) => {\n+    // Create two traces with different environments\n+    await upsertTrace({\n+      id: traceId1,\n+      project_id: projectId,\n+      environment: \"production\",\n+      timestamp: convertDateToClickhouseDateTime(new Date()),",
        "comment_created_at": "2025-03-19T12:50:46+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Avoid multiple `new Date()` calls; store a consistent timestamp in a variable for `upsertTrace` calls.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002987447",
    "pr_number": 6088,
    "pr_file": "web/src/ee/features/playground/page/hooks/useModelParams.ts",
    "created_at": "2025-03-19T10:28:55+00:00",
    "commented_code": "value: selectedProviderApiKey.adapter,\n           enabled: true,\n         },\n-        maxTemperature: getDefaultAdapterParams(selectedProviderApiKey.adapter)\n-          .maxTemperature,\n+        maxTemperature: {\n+          value: getDefaultAdapterParams(selectedProviderApiKey.adapter)",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2002987447",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6088,
        "pr_file": "web/src/ee/features/playground/page/hooks/useModelParams.ts",
        "discussion_id": "2002987447",
        "commented_code": "@@ -93,15 +93,32 @@ export const useModelParams = () => {\n           value: selectedProviderApiKey.adapter,\n           enabled: true,\n         },\n-        maxTemperature: getDefaultAdapterParams(selectedProviderApiKey.adapter)\n-          .maxTemperature,\n+        maxTemperature: {\n+          value: getDefaultAdapterParams(selectedProviderApiKey.adapter)",
        "comment_created_at": "2025-03-19T10:28:55+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider caching the result of `getDefaultAdapterParams(selectedProviderApiKey.adapter)` in a local variable to avoid repeating the function call for each parameter (`maxTemperature`, `temperature`, `max_tokens`, `top_p`).",
        "pr_file_module": null
      }
    ]
  }
]