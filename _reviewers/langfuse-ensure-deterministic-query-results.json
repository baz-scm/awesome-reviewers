[
  {
    "discussion_id": "2195224515",
    "pr_number": 7776,
    "pr_file": "web/src/features/prompts/server/routers/promptRouter.ts",
    "created_at": "2025-07-09T14:46:04+00:00",
    "commented_code": "LIMIT ${limit} OFFSET ${page * limit};\n `;\n };\n+\n+const generatePromptQueryWithFolders = (\n+  select: Prisma.Sql,\n+  projectId: string,\n+  filterCondition: Prisma.Sql,\n+  orderCondition: Prisma.Sql,\n+  limit: number,\n+  page: number,\n+  pathFilter: Prisma.Sql = Prisma.empty,\n+  searchFilter: Prisma.Sql = Prisma.empty,\n+  pathPrefix: string = \"\",\n+) => {\n+  const startPos = pathPrefix ? pathPrefix.length + 2 : 1;\n+\n+  return Prisma.sql`\n+  WITH latest_prompts AS (\n+    SELECT name, MAX(version) as max_version\n+    FROM prompts p\n+    WHERE \"project_id\" = ${projectId}\n+    ${filterCondition}\n+    ${pathFilter}\n+    ${searchFilter}\n+    GROUP BY name\n+  ),\n+  all_data AS (\n+    SELECT \n+      p.*,\n+      split_part(substr(p.name, ${startPos}::int), '/', 1) as child_name,\n+      (position('/' in substr(p.name, ${startPos}::int)) > 0) as is_folder\n+    FROM prompts p\n+    INNER JOIN latest_prompts lp ON p.name = lp.name AND p.version = lp.max_version\n+    WHERE p.\"project_id\" = ${projectId}\n+    ${filterCondition}\n+    ${pathFilter}\n+    ${searchFilter}\n+  ),\n+  -- Folders: distinct folder paths\n+  folders AS (\n+    SELECT DISTINCT\n+      COALESCE(NULLIF(${pathPrefix}, '') || '/', '') || child_name as id,\n+      COALESCE(NULLIF(${pathPrefix}, '') || '/', '') || child_name as name,\n+      null::integer as version,\n+      project_id as \"projectId\", \n+      null::jsonb as prompt,\n+      'folder' as type,\n+      null::timestamp as \"updatedAt\",\n+      null::timestamp as \"createdAt\",\n+      null::text[] as labels,\n+      null::text[] as tags\n+    FROM all_data\n+    WHERE is_folder = true\n+  ),\n+  -- Direct prompts: actual prompt data\n+  direct_prompts AS (\n+    SELECT DISTINCT ON (child_name)\n+      id,\n+      ,",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2195224515",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7776,
        "pr_file": "web/src/features/prompts/server/routers/promptRouter.ts",
        "discussion_id": "2195224515",
        "commented_code": "@@ -1318,3 +1319,79 @@ const generatePromptQuery = (\n   LIMIT ${limit} OFFSET ${page * limit};\n `;\n };\n+\n+const generatePromptQueryWithFolders = (\n+  select: Prisma.Sql,\n+  projectId: string,\n+  filterCondition: Prisma.Sql,\n+  orderCondition: Prisma.Sql,\n+  limit: number,\n+  page: number,\n+  pathFilter: Prisma.Sql = Prisma.empty,\n+  searchFilter: Prisma.Sql = Prisma.empty,\n+  pathPrefix: string = \"\",\n+) => {\n+  const startPos = pathPrefix ? pathPrefix.length + 2 : 1;\n+\n+  return Prisma.sql`\n+  WITH latest_prompts AS (\n+    SELECT name, MAX(version) as max_version\n+    FROM prompts p\n+    WHERE \"project_id\" = ${projectId}\n+    ${filterCondition}\n+    ${pathFilter}\n+    ${searchFilter}\n+    GROUP BY name\n+  ),\n+  all_data AS (\n+    SELECT \n+      p.*,\n+      split_part(substr(p.name, ${startPos}::int), '/', 1) as child_name,\n+      (position('/' in substr(p.name, ${startPos}::int)) > 0) as is_folder\n+    FROM prompts p\n+    INNER JOIN latest_prompts lp ON p.name = lp.name AND p.version = lp.max_version\n+    WHERE p.\"project_id\" = ${projectId}\n+    ${filterCondition}\n+    ${pathFilter}\n+    ${searchFilter}\n+  ),\n+  -- Folders: distinct folder paths\n+  folders AS (\n+    SELECT DISTINCT\n+      COALESCE(NULLIF(${pathPrefix}, '') || '/', '') || child_name as id,\n+      COALESCE(NULLIF(${pathPrefix}, '') || '/', '') || child_name as name,\n+      null::integer as version,\n+      project_id as \"projectId\", \n+      null::jsonb as prompt,\n+      'folder' as type,\n+      null::timestamp as \"updatedAt\",\n+      null::timestamp as \"createdAt\",\n+      null::text[] as labels,\n+      null::text[] as tags\n+    FROM all_data\n+    WHERE is_folder = true\n+  ),\n+  -- Direct prompts: actual prompt data\n+  direct_prompts AS (\n+    SELECT DISTINCT ON (child_name)\n+      id,\n+      ,",
        "comment_created_at": "2025-07-09T14:46:04+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "There is an extraneous comma in the direct_prompts SELECT clause. This may cause an SQL syntax error; remove it or replace it with the intended column (e.g. 'child_name as name').\n```suggestion\n\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187271824",
    "pr_number": 7700,
    "pr_file": "web/src/features/public-api/server/traces.ts",
    "created_at": "2025-07-05T13:33:30+00:00",
    "commented_code": "newExecution: (input) => {\n       const tracesAmt = getTimeframesTracesAMT(input.fromTimestamp);\n \n+      // If user provides an order we prefer it or fallback to timestamp as the default.\n+      // In both cases we append a t.event_ts desc order to pick the latest event in case of duplicates\n+      // if we want to use a skip index.\n+      // This may still return stale information if the orderBy key was updated between traces or if a filter\n+      // applies only to a stale value.\n+      const chOrderBy =\n+        orderByToClickhouseSql(orderBy || [], orderByColumns) ||\n+        \"ORDER BY t.start_time desc\";",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2187271824",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7700,
        "pr_file": "web/src/features/public-api/server/traces.ts",
        "discussion_id": "2187271824",
        "commented_code": "@@ -205,6 +205,15 @@ export const generateTracesForPublicApi = async ({\n     newExecution: (input) => {\n       const tracesAmt = getTimeframesTracesAMT(input.fromTimestamp);\n \n+      // If user provides an order we prefer it or fallback to timestamp as the default.\n+      // In both cases we append a t.event_ts desc order to pick the latest event in case of duplicates\n+      // if we want to use a skip index.\n+      // This may still return stale information if the orderBy key was updated between traces or if a filter\n+      // applies only to a stale value.\n+      const chOrderBy =\n+        orderByToClickhouseSql(orderBy || [], orderByColumns) ||\n+        \"ORDER BY t.start_time desc\";",
        "comment_created_at": "2025-07-05T13:33:30+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "The comment here mentions appending `, t.event_ts desc` for skip indexes, but unlike the existingExecution branch, the newExecution branch doesn't conditionally append it. Clarify if this omission is intentional or update the comment/code accordingly.\n```suggestion\n        \"ORDER BY t.start_time desc\" + (shouldUseSkipIndexes ? \", t.event_ts desc\" : \"\");\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183136907",
    "pr_number": 7631,
    "pr_file": "packages/shared/src/server/repositories/traces.ts",
    "created_at": "2025-07-03T15:48:31+00:00",
    "commented_code": "timestamp?: Date,\n   clickhouseConfigs?: ClickHouseClientConfigOptions | undefined,\n ) => {\n-  const query = `\n-      SELECT * \n-      FROM traces\n-      WHERE id IN ({traceIds: Array(String)})\n-      AND project_id = {projectId: String}\n-      ${timestamp ? `AND timestamp >= {timestamp: DateTime64(3)}` : \"\"} \n-      ORDER BY event_ts DESC\n-      LIMIT 1 by id, project_id;`;\n-  const records = await queryClickhouse<TraceRecordReadType>({\n-    query,\n-    params: {\n-      traceIds,\n-      projectId,\n-      timestamp: timestamp ? convertDateToClickhouseDateTime(timestamp) : null,\n+  const records = await measureAndReturn({\n+    operationName: \"getTracesByIds\",\n+    projectId,\n+    input: {\n+      params: {\n+        traceIds,\n+        projectId,\n+        timestamp: timestamp\n+          ? convertDateToClickhouseDateTime(timestamp)\n+          : null,\n+      },\n+      tags: {\n+        feature: \"tracing\",\n+        type: \"trace\",\n+        kind: \"byId\",\n+        projectId,\n+      },\n+      clickhouseConfigs,\n     },\n-    tags: {\n-      feature: \"tracing\",\n-      type: \"trace\",\n-      kind: \"byId\",\n-      projectId,\n+    existingExecution: (input) => {\n+      const query = `\n+        SELECT * \n+        FROM traces\n+        WHERE id IN ({traceIds: Array(String)})\n+        AND project_id = {projectId: String}\n+        ${timestamp ? `AND timestamp >= {timestamp: DateTime64(3)}` : \"\"} \n+        ORDER BY event_ts DESC\n+        LIMIT 1 by id, project_id;\n+      `;\n+      return queryClickhouse<TraceRecordReadType>({\n+        query,\n+        params: input.params,\n+        tags: input.tags,\n+        clickhouseConfigs: input.clickhouseConfigs,\n+      });\n+    },\n+    newExecution: (input) => {\n+      const query = `\n+        SELECT \n+          id,\n+          name as name,\n+          user_id as user_id,\n+          metadata as metadata,\n+          release as release,\n+          version as version,\n+          project_id,\n+          environment,\n+          finalizeAggregation(public) as public,\n+          finalizeAggregation(bookmarked) as bookmarked,\n+          tags,\n+          finalizeAggregation(input) as input,\n+          finalizeAggregation(output) as output,\n+          session_id as session_id,\n+          0 as is_deleted,\n+          start_time as timestamp,\n+          created_at,\n+          updated_at,\n+          updated_at as event_ts\n+        FROM traces_all_amt\n+        WHERE id IN ({traceIds: Array(String)})\n+        AND project_id = {projectId: String}\n+        LIMIT 1 BY project_id, id",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2183136907",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7631,
        "pr_file": "packages/shared/src/server/repositories/traces.ts",
        "discussion_id": "2183136907",
        "commented_code": "@@ -171,28 +242,77 @@ export const getTracesByIds = async (\n   timestamp?: Date,\n   clickhouseConfigs?: ClickHouseClientConfigOptions | undefined,\n ) => {\n-  const query = `\n-      SELECT * \n-      FROM traces\n-      WHERE id IN ({traceIds: Array(String)})\n-      AND project_id = {projectId: String}\n-      ${timestamp ? `AND timestamp >= {timestamp: DateTime64(3)}` : \"\"} \n-      ORDER BY event_ts DESC\n-      LIMIT 1 by id, project_id;`;\n-  const records = await queryClickhouse<TraceRecordReadType>({\n-    query,\n-    params: {\n-      traceIds,\n-      projectId,\n-      timestamp: timestamp ? convertDateToClickhouseDateTime(timestamp) : null,\n+  const records = await measureAndReturn({\n+    operationName: \"getTracesByIds\",\n+    projectId,\n+    input: {\n+      params: {\n+        traceIds,\n+        projectId,\n+        timestamp: timestamp\n+          ? convertDateToClickhouseDateTime(timestamp)\n+          : null,\n+      },\n+      tags: {\n+        feature: \"tracing\",\n+        type: \"trace\",\n+        kind: \"byId\",\n+        projectId,\n+      },\n+      clickhouseConfigs,\n     },\n-    tags: {\n-      feature: \"tracing\",\n-      type: \"trace\",\n-      kind: \"byId\",\n-      projectId,\n+    existingExecution: (input) => {\n+      const query = `\n+        SELECT * \n+        FROM traces\n+        WHERE id IN ({traceIds: Array(String)})\n+        AND project_id = {projectId: String}\n+        ${timestamp ? `AND timestamp >= {timestamp: DateTime64(3)}` : \"\"} \n+        ORDER BY event_ts DESC\n+        LIMIT 1 by id, project_id;\n+      `;\n+      return queryClickhouse<TraceRecordReadType>({\n+        query,\n+        params: input.params,\n+        tags: input.tags,\n+        clickhouseConfigs: input.clickhouseConfigs,\n+      });\n+    },\n+    newExecution: (input) => {\n+      const query = `\n+        SELECT \n+          id,\n+          name as name,\n+          user_id as user_id,\n+          metadata as metadata,\n+          release as release,\n+          version as version,\n+          project_id,\n+          environment,\n+          finalizeAggregation(public) as public,\n+          finalizeAggregation(bookmarked) as bookmarked,\n+          tags,\n+          finalizeAggregation(input) as input,\n+          finalizeAggregation(output) as output,\n+          session_id as session_id,\n+          0 as is_deleted,\n+          start_time as timestamp,\n+          created_at,\n+          updated_at,\n+          updated_at as event_ts\n+        FROM traces_all_amt\n+        WHERE id IN ({traceIds: Array(String)})\n+        AND project_id = {projectId: String}\n+        LIMIT 1 BY project_id, id",
        "comment_created_at": "2025-07-03T15:48:31+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Switching from `LIMIT 1` to `LIMIT 1 BY project_id, id` now returns one row per unique (project_id, id) group. If the goal is to pick a specific (e.g. latest) row from each group, consider adding an explicit ORDER BY clause to ensure deterministic selection. Also, a comment explaining this experimental change would be helpful.\n```suggestion\n        ORDER BY event_ts DESC\\n        LIMIT 1 BY project_id, id\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057892467",
    "pr_number": 6367,
    "pr_file": "packages/shared/src/server/repositories/traces.ts",
    "created_at": "2025-04-24T08:52:50+00:00",
    "commented_code": "projectId: record.project_id,\n   }));\n };\n+\n+export const searchTraceWithSessionId = async (\n+  projectId: string,\n+  sessionId: string,\n+) => {\n+  const query = `\n+    SELECT id, project_id\n+    FROM traces\n+    WHERE session_id = {sessionId: String}\n+    AND project_id = {projectId: String}\n+    LIMIT 1",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2057892467",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6367,
        "pr_file": "packages/shared/src/server/repositories/traces.ts",
        "discussion_id": "2057892467",
        "commented_code": "@@ -1003,3 +1003,31 @@ export const getTracesByIdsForAnyProject = async (traceIds: string[]) => {\n     projectId: record.project_id,\n   }));\n };\n+\n+export const searchTraceWithSessionId = async (\n+  projectId: string,\n+  sessionId: string,\n+) => {\n+  const query = `\n+    SELECT id, project_id\n+    FROM traces\n+    WHERE session_id = {sessionId: String}\n+    AND project_id = {projectId: String}\n+    LIMIT 1",
        "comment_created_at": "2025-04-24T08:52:50+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "The newly added `searchTraceWithSessionId` function returns a single trace by session id. Consider adding an `ORDER BY` clause or commentary if multiple traces exist for a given session.\n```suggestion\n    ORDER BY event_ts DESC\\n    LIMIT 1\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2053001813",
    "pr_number": 6534,
    "pr_file": "packages/shared/src/server/repositories/eventLog.ts",
    "created_at": "2025-04-21T21:12:17+00:00",
    "commented_code": "},\n   });\n };\n+\n+// this function is only used for the background migration from event_log to blob_storage_file_log\n+export const insertIntoS3RefsTableFromEventLog = async (\n+  limit: number,\n+  offset: number,\n+) => {\n+  const query = `\n+    INSERT INTO blob_storage_file_log\n+    SELECT \n+      id,\n+      project_id,\n+      entity_type,\n+      entity_id,\n+      event_id,\n+      bucket_name,\n+      bucket_path,\n+      created_at,\n+      updated_at,\n+      created_at AS event_ts,\n+      0 AS is_deleted\n+    FROM event_log\n+    ORDER BY project_id, event_type, entity_id DESC",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2053001813",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6534,
        "pr_file": "packages/shared/src/server/repositories/eventLog.ts",
        "discussion_id": "2053001813",
        "commented_code": "@@ -258,3 +259,71 @@ export const deleteEventLogByProjectIdBeforeDate = async (\n     },\n   });\n };\n+\n+// this function is only used for the background migration from event_log to blob_storage_file_log\n+export const insertIntoS3RefsTableFromEventLog = async (\n+  limit: number,\n+  offset: number,\n+) => {\n+  const query = `\n+    INSERT INTO blob_storage_file_log\n+    SELECT \n+      id,\n+      project_id,\n+      entity_type,\n+      entity_id,\n+      event_id,\n+      bucket_name,\n+      bucket_path,\n+      created_at,\n+      updated_at,\n+      created_at AS event_ts,\n+      0 AS is_deleted\n+    FROM event_log\n+    ORDER BY project_id, event_type, entity_id DESC",
        "comment_created_at": "2025-04-21T21:12:17+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "The `ORDER BY` clause uses `event_type` while the `SELECT` and other parts use `entity_type`. This inconsistency suggests a typo. Consider changing `event_type` to `entity_type` to ensure consistency.\n```suggestion\n    ORDER BY project_id, entity_type, entity_id DESC\n```\n",
        "pr_file_module": null
      }
    ]
  }
]