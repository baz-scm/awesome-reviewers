[
  {
    "discussion_id": "2119244130",
    "pr_number": 7099,
    "pr_file": "packages/shared/src/server/redis/redis.ts",
    "created_at": "2025-06-01T15:06:58+00:00",
    "commented_code": "}\n     : {};\n \n+  logger.info(`-->> Connection string: ${env.REDIS_CONNECTION_STRING}`)\n+\n   const instance = env.REDIS_CONNECTION_STRING\n     ? new Redis(env.REDIS_CONNECTION_STRING, {\n+          username: String(env.REDIS_USERNAME),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2119244130",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7099,
        "pr_file": "packages/shared/src/server/redis/redis.ts",
        "discussion_id": "2119244130",
        "commented_code": "@@ -45,8 +45,12 @@\n       }\n     : {};\n \n+  logger.info(`-->> Connection string: ${env.REDIS_CONNECTION_STRING}`)\n+\n   const instance = env.REDIS_CONNECTION_STRING\n     ? new Redis(env.REDIS_CONNECTION_STRING, {\n+          username: String(env.REDIS_USERNAME),",
        "comment_created_at": "2025-06-01T15:06:58+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Using `String(env.REDIS_USERNAME/PASSWORD)` may yield unwanted values like `'undefined'`. Use a conditional (e.g., `env.REDIS_USERNAME ?? undefined`) instead.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2030202750",
    "pr_number": 6353,
    "pr_file": "web/src/components/trace/lib/helpers.ts",
    "created_at": "2025-04-06T16:47:21+00:00",
    "commented_code": "}\n   }\n \n-  const totalCost = observations.reduce(\n+  const totalCost = observations.reduce<Decimal | undefined>(\n     (prev: Decimal | undefined, curr: ObservationReturnType) => {\n       // if we don't have any calculated costs, we can't do anything\n-      if (\n-        !curr.calculatedTotalCost &&\n-        !curr.calculatedInputCost &&\n-        !curr.calculatedOutputCost\n-      )\n-        return prev;\n+      if (!curr.totalCost && !curr.inputCost && !curr.outputCost) return prev;\n \n       // if we have either input or output cost, but not total cost, we can use that\n-      if (\n-        !curr.calculatedTotalCost &&\n-        (curr.calculatedInputCost || curr.calculatedOutputCost)\n-      ) {\n+      if (!curr.totalCost && (curr.inputCost || curr.outputCost)) {\n+        const inputCost = curr.inputCost\n+          ? new Decimal(curr.inputCost)\n+          : new Decimal(0);\n+\n+        const outputCost = curr.outputCost",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2030202750",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6353,
        "pr_file": "web/src/components/trace/lib/helpers.ts",
        "discussion_id": "2030202750",
        "commented_code": "@@ -103,39 +103,34 @@ export function calculateDisplayTotalCost(p: {\n     }\n   }\n \n-  const totalCost = observations.reduce(\n+  const totalCost = observations.reduce<Decimal | undefined>(\n     (prev: Decimal | undefined, curr: ObservationReturnType) => {\n       // if we don't have any calculated costs, we can't do anything\n-      if (\n-        !curr.calculatedTotalCost &&\n-        !curr.calculatedInputCost &&\n-        !curr.calculatedOutputCost\n-      )\n-        return prev;\n+      if (!curr.totalCost && !curr.inputCost && !curr.outputCost) return prev;\n \n       // if we have either input or output cost, but not total cost, we can use that\n-      if (\n-        !curr.calculatedTotalCost &&\n-        (curr.calculatedInputCost || curr.calculatedOutputCost)\n-      ) {\n+      if (!curr.totalCost && (curr.inputCost || curr.outputCost)) {\n+        const inputCost = curr.inputCost\n+          ? new Decimal(curr.inputCost)\n+          : new Decimal(0);\n+\n+        const outputCost = curr.outputCost",
        "comment_created_at": "2025-04-06T16:47:21+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Using a truthy check for `curr.outputCost` may misinterpret a valid zero value as false. Consider checking for null/undefined (e.g. using `curr.outputCost != null`) or reverting to the nullish operator (`??`) to ensure 0 is handled correctly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2009642000",
    "pr_number": 6173,
    "pr_file": "web/src/features/otel/server/index.ts",
    "created_at": "2025-03-24T07:48:48+00:00",
    "commented_code": "return spanName;\n };\n \n+const extractMetadata = (\n+  attributes: Record<string, unknown>,\n+): Record<string, unknown> => {\n+  // Extract top-level metadata object if available\n+  let metadata: Record<string, unknown> = {};\n+  if (attributes[\"langfuse.metadata\"]) {\n+    try {\n+      // If it's a string (JSON), parse it\n+      if (typeof attributes[\"langfuse.metadata\"] === \"string\") {\n+        metadata = JSON.parse(attributes[\"langfuse.metadata\"] as string);",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2009642000",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6173,
        "pr_file": "web/src/features/otel/server/index.ts",
        "discussion_id": "2009642000",
        "commented_code": "@@ -270,6 +270,41 @@ const extractName = (\n   return spanName;\n };\n \n+const extractMetadata = (\n+  attributes: Record<string, unknown>,\n+): Record<string, unknown> => {\n+  // Extract top-level metadata object if available\n+  let metadata: Record<string, unknown> = {};\n+  if (attributes[\"langfuse.metadata\"]) {\n+    try {\n+      // If it's a string (JSON), parse it\n+      if (typeof attributes[\"langfuse.metadata\"] === \"string\") {\n+        metadata = JSON.parse(attributes[\"langfuse.metadata\"] as string);",
        "comment_created_at": "2025-03-24T07:48:48+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "In `extractMetadata`, consider validating that the parsed JSON (when 'langfuse.metadata' is a string) is actually an object before merging. This would prevent unexpected behavior if a primitive gets parsed.\n```suggestion\n        metadata = JSON.parse(attributes[\"langfuse.metadata\"] as string); if (typeof metadata !== 'object' || metadata === null) metadata = {};\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2008077561",
    "pr_number": 6157,
    "pr_file": "packages/shared/src/server/ingestion/modelMatch.ts",
    "created_at": "2025-03-21T18:03:58+00:00",
    "commented_code": "};\n \n export const redisModelToPrismaModel = (redisModel: string): Model => {\n-  const parsed = JSON.parse(redisModel);\n+  const parsed: Model = JSON.parse(redisModel);\n   return {\n     ...parsed,\n     createdAt: new Date(parsed.createdAt),\n     updatedAt: new Date(parsed.updatedAt),\n-    inputPrice: new Decimal(parsed.inputPrice),\n-    outputPrice: new Decimal(parsed.outputPrice),\n-    totalPrice: new Decimal(parsed.totalPrice),\n+    inputPrice: parsed.inputPrice ? new Decimal(parsed.inputPrice) : null,",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2008077561",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6157,
        "pr_file": "packages/shared/src/server/ingestion/modelMatch.ts",
        "discussion_id": "2008077561",
        "commented_code": "@@ -179,14 +179,14 @@ const getModelMatchKeyPrefix = () => {\n };\n \n export const redisModelToPrismaModel = (redisModel: string): Model => {\n-  const parsed = JSON.parse(redisModel);\n+  const parsed: Model = JSON.parse(redisModel);\n   return {\n     ...parsed,\n     createdAt: new Date(parsed.createdAt),\n     updatedAt: new Date(parsed.updatedAt),\n-    inputPrice: new Decimal(parsed.inputPrice),\n-    outputPrice: new Decimal(parsed.outputPrice),\n-    totalPrice: new Decimal(parsed.totalPrice),\n+    inputPrice: parsed.inputPrice ? new Decimal(parsed.inputPrice) : null,",
        "comment_created_at": "2025-03-21T18:03:58+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Potential bug: Using a falsy check for `inputPrice` may incorrectly convert valid 0 values to `null`. Consider: `parsed.inputPrice != null`.\n```suggestion\n    inputPrice: parsed.inputPrice != null ? new Decimal(parsed.inputPrice) : null,\n```",
        "pr_file_module": null
      }
    ]
  }
]