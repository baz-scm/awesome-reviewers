[
  {
    "discussion_id": "2192889878",
    "pr_number": 7748,
    "pr_file": "web/src/pages/api/public/integrations/blob-storage/index.ts",
    "created_at": "2025-07-08T15:54:02+00:00",
    "commented_code": "+import { auditLog } from \"@/src/features/audit-logs/auditLog\";\n+import { createAuthedProjectAPIRoute } from \"@/src/features/public-api/server/createAuthedProjectAPIRoute\";\n+import {\n+  PostBlobStorageIntegrationV1Body,\n+  PutBlobStorageIntegrationV1Body,\n+  BlobStorageIntegrationV1Response,\n+  transformBlobStorageIntegrationToAPIResponse,\n+} from \"@/src/features/public-api/types/blob-storage-integration\";\n+import { withMiddlewares } from \"@/src/features/public-api/server/withMiddlewares\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+import { encrypt } from \"@langfuse/shared/encryption\";\n+import { env } from \"@/src/env.mjs\";\n+import { BlobStorageIntegrationType } from \"@langfuse/shared\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+\n+export default withMiddlewares({\n+  GET: createAuthedProjectAPIRoute({\n+    name: \"Get Blob Storage Integration\",\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    fn: async ({ auth }) => {\n+      const integration = await prisma.blobStorageIntegration.findUnique({\n+        where: {\n+          projectId: auth.scope.projectId,\n+        },\n+        omit: {\n+          secretAccessKey: true,\n+        },\n+      });\n+\n+      if (!integration) {\n+        throw new LangfuseNotFoundError(\"Blob storage integration not found\");\n+      }\n+\n+      return transformBlobStorageIntegrationToAPIResponse(integration);\n+    },\n+  }),\n+\n+  POST: createAuthedProjectAPIRoute({\n+    name: \"Create Blob Storage Integration\",\n+    bodySchema: PostBlobStorageIntegrationV1Body,\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    successStatusCode: 201,\n+    rateLimitResource: \"ingestion\",\n+    fn: async ({ body, auth }) => {\n+      // Audit log for creation\n+      await auditLog({\n+        action: \"create\",\n+        resourceType: \"blobStorageIntegration\",\n+        resourceId: auth.scope.projectId,\n+        projectId: auth.scope.projectId,\n+        orgId: auth.scope.orgId,\n+        apiKeyId: auth.scope.apiKeyId,\n+      });\n+\n+      const {\n+        type,\n+        bucketName,\n+        endpoint,\n+        region,\n+        accessKeyId,\n+        secretAccessKey,\n+        prefix,\n+        exportFrequency,\n+        enabled,\n+        forcePathStyle,\n+        fileType,\n+      } = body;\n+\n+      // Validate credentials based on environment and type\n+      const isSelfHosted = !env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION;\n+      const canUseHostCredentials =\n+        isSelfHosted && type === BlobStorageIntegrationType.S3;\n+      const isUsingHostCredentials =\n+        canUseHostCredentials && (!accessKeyId || !secretAccessKey);\n+\n+      if (!canUseHostCredentials && !accessKeyId) {\n+        throw new LangfuseNotFoundError(\n+          \"Access Key ID and Secret Access Key are required\",\n+        );\n+      }\n+\n+      if (!isUsingHostCredentials && !secretAccessKey) {\n+        throw new LangfuseNotFoundError(\n+          \"Secret access key is required for new configuration when not using host credentials\",\n+        );\n+      }\n+\n+      // Check if integration already exists for this project\n+      const existingIntegration =\n+        await prisma.blobStorageIntegration.findUnique({\n+          where: {\n+            projectId: auth.scope.projectId,\n+          },\n+        });\n+\n+      if (existingIntegration) {\n+        throw new LangfuseNotFoundError(",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2192889878",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7748,
        "pr_file": "web/src/pages/api/public/integrations/blob-storage/index.ts",
        "discussion_id": "2192889878",
        "commented_code": "@@ -0,0 +1,261 @@\n+import { auditLog } from \"@/src/features/audit-logs/auditLog\";\n+import { createAuthedProjectAPIRoute } from \"@/src/features/public-api/server/createAuthedProjectAPIRoute\";\n+import {\n+  PostBlobStorageIntegrationV1Body,\n+  PutBlobStorageIntegrationV1Body,\n+  BlobStorageIntegrationV1Response,\n+  transformBlobStorageIntegrationToAPIResponse,\n+} from \"@/src/features/public-api/types/blob-storage-integration\";\n+import { withMiddlewares } from \"@/src/features/public-api/server/withMiddlewares\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+import { encrypt } from \"@langfuse/shared/encryption\";\n+import { env } from \"@/src/env.mjs\";\n+import { BlobStorageIntegrationType } from \"@langfuse/shared\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+\n+export default withMiddlewares({\n+  GET: createAuthedProjectAPIRoute({\n+    name: \"Get Blob Storage Integration\",\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    fn: async ({ auth }) => {\n+      const integration = await prisma.blobStorageIntegration.findUnique({\n+        where: {\n+          projectId: auth.scope.projectId,\n+        },\n+        omit: {\n+          secretAccessKey: true,\n+        },\n+      });\n+\n+      if (!integration) {\n+        throw new LangfuseNotFoundError(\"Blob storage integration not found\");\n+      }\n+\n+      return transformBlobStorageIntegrationToAPIResponse(integration);\n+    },\n+  }),\n+\n+  POST: createAuthedProjectAPIRoute({\n+    name: \"Create Blob Storage Integration\",\n+    bodySchema: PostBlobStorageIntegrationV1Body,\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    successStatusCode: 201,\n+    rateLimitResource: \"ingestion\",\n+    fn: async ({ body, auth }) => {\n+      // Audit log for creation\n+      await auditLog({\n+        action: \"create\",\n+        resourceType: \"blobStorageIntegration\",\n+        resourceId: auth.scope.projectId,\n+        projectId: auth.scope.projectId,\n+        orgId: auth.scope.orgId,\n+        apiKeyId: auth.scope.apiKeyId,\n+      });\n+\n+      const {\n+        type,\n+        bucketName,\n+        endpoint,\n+        region,\n+        accessKeyId,\n+        secretAccessKey,\n+        prefix,\n+        exportFrequency,\n+        enabled,\n+        forcePathStyle,\n+        fileType,\n+      } = body;\n+\n+      // Validate credentials based on environment and type\n+      const isSelfHosted = !env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION;\n+      const canUseHostCredentials =\n+        isSelfHosted && type === BlobStorageIntegrationType.S3;\n+      const isUsingHostCredentials =\n+        canUseHostCredentials && (!accessKeyId || !secretAccessKey);\n+\n+      if (!canUseHostCredentials && !accessKeyId) {\n+        throw new LangfuseNotFoundError(\n+          \"Access Key ID and Secret Access Key are required\",\n+        );\n+      }\n+\n+      if (!isUsingHostCredentials && !secretAccessKey) {\n+        throw new LangfuseNotFoundError(\n+          \"Secret access key is required for new configuration when not using host credentials\",\n+        );\n+      }\n+\n+      // Check if integration already exists for this project\n+      const existingIntegration =\n+        await prisma.blobStorageIntegration.findUnique({\n+          where: {\n+            projectId: auth.scope.projectId,\n+          },\n+        });\n+\n+      if (existingIntegration) {\n+        throw new LangfuseNotFoundError(",
        "comment_created_at": "2025-07-08T15:54:02+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider using a more appropriate error type (such as ConflictError) instead of LangfuseNotFoundError when an integration already exists.\n```suggestion\n        throw new ConflictError(\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2192889881",
    "pr_number": 7748,
    "pr_file": "web/src/pages/api/public/integrations/blob-storage/index.ts",
    "created_at": "2025-07-08T15:54:02+00:00",
    "commented_code": "+import { auditLog } from \"@/src/features/audit-logs/auditLog\";\n+import { createAuthedProjectAPIRoute } from \"@/src/features/public-api/server/createAuthedProjectAPIRoute\";\n+import {\n+  PostBlobStorageIntegrationV1Body,\n+  PutBlobStorageIntegrationV1Body,\n+  BlobStorageIntegrationV1Response,\n+  transformBlobStorageIntegrationToAPIResponse,\n+} from \"@/src/features/public-api/types/blob-storage-integration\";\n+import { withMiddlewares } from \"@/src/features/public-api/server/withMiddlewares\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+import { encrypt } from \"@langfuse/shared/encryption\";\n+import { env } from \"@/src/env.mjs\";\n+import { BlobStorageIntegrationType } from \"@langfuse/shared\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+\n+export default withMiddlewares({\n+  GET: createAuthedProjectAPIRoute({\n+    name: \"Get Blob Storage Integration\",\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    fn: async ({ auth }) => {\n+      const integration = await prisma.blobStorageIntegration.findUnique({\n+        where: {\n+          projectId: auth.scope.projectId,\n+        },\n+        omit: {\n+          secretAccessKey: true,\n+        },\n+      });\n+\n+      if (!integration) {\n+        throw new LangfuseNotFoundError(\"Blob storage integration not found\");\n+      }\n+\n+      return transformBlobStorageIntegrationToAPIResponse(integration);\n+    },\n+  }),\n+\n+  POST: createAuthedProjectAPIRoute({\n+    name: \"Create Blob Storage Integration\",\n+    bodySchema: PostBlobStorageIntegrationV1Body,\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    successStatusCode: 201,\n+    rateLimitResource: \"ingestion\",\n+    fn: async ({ body, auth }) => {\n+      // Audit log for creation\n+      await auditLog({\n+        action: \"create\",\n+        resourceType: \"blobStorageIntegration\",\n+        resourceId: auth.scope.projectId,\n+        projectId: auth.scope.projectId,\n+        orgId: auth.scope.orgId,\n+        apiKeyId: auth.scope.apiKeyId,\n+      });\n+\n+      const {\n+        type,\n+        bucketName,\n+        endpoint,\n+        region,\n+        accessKeyId,\n+        secretAccessKey,\n+        prefix,\n+        exportFrequency,\n+        enabled,\n+        forcePathStyle,\n+        fileType,\n+      } = body;\n+\n+      // Validate credentials based on environment and type\n+      const isSelfHosted = !env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION;\n+      const canUseHostCredentials =\n+        isSelfHosted && type === BlobStorageIntegrationType.S3;\n+      const isUsingHostCredentials =\n+        canUseHostCredentials && (!accessKeyId || !secretAccessKey);\n+\n+      if (!canUseHostCredentials && !accessKeyId) {\n+        throw new LangfuseNotFoundError(",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2192889881",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7748,
        "pr_file": "web/src/pages/api/public/integrations/blob-storage/index.ts",
        "discussion_id": "2192889881",
        "commented_code": "@@ -0,0 +1,261 @@\n+import { auditLog } from \"@/src/features/audit-logs/auditLog\";\n+import { createAuthedProjectAPIRoute } from \"@/src/features/public-api/server/createAuthedProjectAPIRoute\";\n+import {\n+  PostBlobStorageIntegrationV1Body,\n+  PutBlobStorageIntegrationV1Body,\n+  BlobStorageIntegrationV1Response,\n+  transformBlobStorageIntegrationToAPIResponse,\n+} from \"@/src/features/public-api/types/blob-storage-integration\";\n+import { withMiddlewares } from \"@/src/features/public-api/server/withMiddlewares\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+import { encrypt } from \"@langfuse/shared/encryption\";\n+import { env } from \"@/src/env.mjs\";\n+import { BlobStorageIntegrationType } from \"@langfuse/shared\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+\n+export default withMiddlewares({\n+  GET: createAuthedProjectAPIRoute({\n+    name: \"Get Blob Storage Integration\",\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    fn: async ({ auth }) => {\n+      const integration = await prisma.blobStorageIntegration.findUnique({\n+        where: {\n+          projectId: auth.scope.projectId,\n+        },\n+        omit: {\n+          secretAccessKey: true,\n+        },\n+      });\n+\n+      if (!integration) {\n+        throw new LangfuseNotFoundError(\"Blob storage integration not found\");\n+      }\n+\n+      return transformBlobStorageIntegrationToAPIResponse(integration);\n+    },\n+  }),\n+\n+  POST: createAuthedProjectAPIRoute({\n+    name: \"Create Blob Storage Integration\",\n+    bodySchema: PostBlobStorageIntegrationV1Body,\n+    responseSchema: BlobStorageIntegrationV1Response,\n+    successStatusCode: 201,\n+    rateLimitResource: \"ingestion\",\n+    fn: async ({ body, auth }) => {\n+      // Audit log for creation\n+      await auditLog({\n+        action: \"create\",\n+        resourceType: \"blobStorageIntegration\",\n+        resourceId: auth.scope.projectId,\n+        projectId: auth.scope.projectId,\n+        orgId: auth.scope.orgId,\n+        apiKeyId: auth.scope.apiKeyId,\n+      });\n+\n+      const {\n+        type,\n+        bucketName,\n+        endpoint,\n+        region,\n+        accessKeyId,\n+        secretAccessKey,\n+        prefix,\n+        exportFrequency,\n+        enabled,\n+        forcePathStyle,\n+        fileType,\n+      } = body;\n+\n+      // Validate credentials based on environment and type\n+      const isSelfHosted = !env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION;\n+      const canUseHostCredentials =\n+        isSelfHosted && type === BlobStorageIntegrationType.S3;\n+      const isUsingHostCredentials =\n+        canUseHostCredentials && (!accessKeyId || !secretAccessKey);\n+\n+      if (!canUseHostCredentials && !accessKeyId) {\n+        throw new LangfuseNotFoundError(",
        "comment_created_at": "2025-07-08T15:54:02+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Using a NotFound error for missing credentials may be misleading. Consider using a validation-specific error type for cases when required credentials (Access Key ID/Secret Access Key) are missing.\n```suggestion\n        throw new LangfuseValidationError(\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112200314",
    "pr_number": 7064,
    "pr_file": "packages/shared/src/server/services/StorageService.ts",
    "created_at": "2025-05-28T15:31:19+00:00",
    "commented_code": "return { signedUrl };\n     } catch (err) {\n       logger.error(`Failed to upload file to ${fileName}`, err);\n-      throw new Error(\"Failed to upload to S3 or generate signed URL\");\n+      throw new Error(`Failed to upload to S3 or generate signed URL: ${err}`);",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2112200314",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 7064,
        "pr_file": "packages/shared/src/server/services/StorageService.ts",
        "discussion_id": "2112200314",
        "commented_code": "@@ -460,7 +460,7 @@ class S3StorageService implements StorageService {\n       return { signedUrl };\n     } catch (err) {\n       logger.error(`Failed to upload file to ${fileName}`, err);\n-      throw new Error(\"Failed to upload to S3 or generate signed URL\");\n+      throw new Error(`Failed to upload to S3 or generate signed URL: ${err}`);",
        "comment_created_at": "2025-05-28T15:31:19+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider using `err.message` or `JSON.stringify(err)` instead of interpolating `err` directly to avoid potential '[object Object]' output and leaking sensitive details.\n```suggestion\n      throw new Error(`Failed to upload to S3 or generate signed URL: ${err.message ?? JSON.stringify(err)}`);\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2029855816",
    "pr_number": 6353,
    "pr_file": "packages/shared/src/server/repositories/observations_converters.ts",
    "created_at": "2025-04-05T12:20:58+00:00",
    "commented_code": "level: record.level as ObservationLevelType,\n     statusMessage: record.status_message ?? null,\n     version: record.version ?? null,\n-    input: (record.input\n-      ? parseJsonPrioritised(record.input)\n-      : null) as Prisma.JsonValue | null,\n-    output: (record.output\n-      ? parseJsonPrioritised(record.output)\n-      : null) as Prisma.JsonValue | null,\n+    input: record.input ? (parseJsonPrioritised(record.input) ?? null) : null,\n+    output: record.output\n+      ? (parseJsonPrioritised(record.output) ?? null)\n+      : null,\n     modelParameters: record.model_parameters\n-      ? JSON.parse(record.model_parameters)\n+      ? (JSON.parse(record.model_parameters) ?? null)",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2029855816",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6353,
        "pr_file": "packages/shared/src/server/repositories/observations_converters.ts",
        "discussion_id": "2029855816",
        "commented_code": "@@ -73,44 +33,19 @@ export const convertObservation = (\n     level: record.level as ObservationLevelType,\n     statusMessage: record.status_message ?? null,\n     version: record.version ?? null,\n-    input: (record.input\n-      ? parseJsonPrioritised(record.input)\n-      : null) as Prisma.JsonValue | null,\n-    output: (record.output\n-      ? parseJsonPrioritised(record.output)\n-      : null) as Prisma.JsonValue | null,\n+    input: record.input ? (parseJsonPrioritised(record.input) ?? null) : null,\n+    output: record.output\n+      ? (parseJsonPrioritised(record.output) ?? null)\n+      : null,\n     modelParameters: record.model_parameters\n-      ? JSON.parse(record.model_parameters)\n+      ? (JSON.parse(record.model_parameters) ?? null)",
        "comment_created_at": "2025-04-05T12:20:58+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider wrapping `JSON.parse` in a try-catch block (for `model_parameters`) to handle potential invalid JSON and prevent runtime errors.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989694064",
    "pr_number": 5882,
    "pr_file": "web/src/features/prompts/server/actions/createPrompt.ts",
    "created_at": "2025-03-11T16:29:07+00:00",
    "commented_code": "// If tags are undefined, use the tags from the latest prompt version\n   const finalTags = [...new Set(tags ?? latestPrompt?.tags ?? [])];\n+  const newPromptId = uuidv4();\n+\n+  const promptService = new PromptService(prisma, redis);\n+  const promptDependencies = parsePromptDependencyTags(prompt);\n+\n+  try {\n+    await promptService.buildAndResolvePromptGraph({\n+      projectId,\n+      parentPrompt: {\n+        id: newPromptId,\n+        prompt,\n+        version: latestPrompt?.version ? latestPrompt.version + 1 : 1,\n+        name,\n+        labels,\n+      },\n+      dependencies: promptDependencies,\n+    });\n+  } catch (err) {\n+    console.error(err);",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "1989694064",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 5882,
        "pr_file": "web/src/features/prompts/server/actions/createPrompt.ts",
        "discussion_id": "1989694064",
        "commented_code": "@@ -55,10 +59,35 @@ export const createPrompt = async ({\n \n   // If tags are undefined, use the tags from the latest prompt version\n   const finalTags = [...new Set(tags ?? latestPrompt?.tags ?? [])];\n+  const newPromptId = uuidv4();\n+\n+  const promptService = new PromptService(prisma, redis);\n+  const promptDependencies = parsePromptDependencyTags(prompt);\n+\n+  try {\n+    await promptService.buildAndResolvePromptGraph({\n+      projectId,\n+      parentPrompt: {\n+        id: newPromptId,\n+        prompt,\n+        version: latestPrompt?.version ? latestPrompt.version + 1 : 1,\n+        name,\n+        labels,\n+      },\n+      dependencies: promptDependencies,\n+    });\n+  } catch (err) {\n+    console.error(err);",
        "comment_created_at": "2025-03-11T16:29:07+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "In the catch block (lines 78\u201384), consider logging additional context (e.g., prompt name or dependency string) for easier debugging when graph resolution fails.\n```suggestion\n    console.error(`Error in prompt ${name}:`, err);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861875674",
    "pr_number": 4465,
    "pr_file": "packages/shared/src/server/repositories/observations.ts",
    "created_at": "2024-11-28T10:09:28+00:00",
    "commented_code": "WHERE project_id = {projectId: String}\n     AND trace_id IN ({traceIds: Array(String)});\n   `;\n-  await commandClickhouse({\n-    query: query,\n-    params: {\n-      projectId,\n-      traceIds,\n-    },\n-  });\n+\n+  const queryStats = `\n+    DELETE FROM observation_stats\n+    WHERE project_id = {projectId: String}\n+    AND trace_id IN ({traceIds: Array(String)});\n+  `;\n+\n+  await Promise.all([",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "1861875674",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 4465,
        "pr_file": "packages/shared/src/server/repositories/observations.ts",
        "discussion_id": "1861875674",
        "commented_code": "@@ -883,13 +883,29 @@ export const deleteObservationsByTraceIds = async (\n     WHERE project_id = {projectId: String}\n     AND trace_id IN ({traceIds: Array(String)});\n   `;\n-  await commandClickhouse({\n-    query: query,\n-    params: {\n-      projectId,\n-      traceIds,\n-    },\n-  });\n+\n+  const queryStats = `\n+    DELETE FROM observation_stats\n+    WHERE project_id = {projectId: String}\n+    AND trace_id IN ({traceIds: Array(String)});\n+  `;\n+\n+  await Promise.all([",
        "comment_created_at": "2024-11-28T10:09:28+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider adding error handling for the `Promise.all` call to manage potential errors from the `commandClickhouse` calls. This will help in identifying which operation failed and ensure that errors are handled gracefully.",
        "pr_file_module": null
      }
    ]
  }
]