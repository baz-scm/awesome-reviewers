[
  {
    "discussion_id": "2073081315",
    "pr_number": 6661,
    "pr_file": "worker/src/api/index.ts",
    "created_at": "2025-05-05T08:54:04+00:00",
    "commented_code": "}\n });\n \n+router.get<{}, {}>(\"/traces\", async (req, res) => {\n+  const trace = await getTraceById({\n+    traceId: req.query.id as string,",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2073081315",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6661,
        "pr_file": "worker/src/api/index.ts",
        "discussion_id": "2073081315",
        "commented_code": "@@ -29,4 +29,12 @@ router.get<{}, { status: string }>(\"/ready\", async (_req, res) => {\n   }\n });\n \n+router.get<{}, {}>(\"/traces\", async (req, res) => {\n+  const trace = await getTraceById({\n+    traceId: req.query.id as string,",
        "comment_created_at": "2025-05-05T08:54:04+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "New `/traces` endpoint added. Consider validating the query parameters (`id` and `projectId`) for security and robustness.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2101882333",
    "pr_number": 6965,
    "pr_file": "packages/shared/src/env.ts",
    "created_at": "2025-05-22T07:48:41+00:00",
    "commented_code": "LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE: z\n     .enum([\"true\", \"false\"])\n     .default(\"false\"),\n+  LANGFUSE_S3_EVENT_UPLOAD_SSE: z.string().optional(),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2101882333",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6965,
        "pr_file": "packages/shared/src/env.ts",
        "discussion_id": "2101882333",
        "commented_code": "@@ -65,6 +65,8 @@ const EnvSchema = z.object({\n   LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE: z\n     .enum([\"true\", \"false\"])\n     .default(\"false\"),\n+  LANGFUSE_S3_EVENT_UPLOAD_SSE: z.string().optional(),",
        "comment_created_at": "2025-05-22T07:48:41+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Consider validating the SSE env variables to accept only allowed values (e.g. `AES256` or `aws:kms`) instead of any string.\n```suggestion\n  LANGFUSE_S3_EVENT_UPLOAD_SSE: z.enum([\"AES256\", \"aws:kms\"]).optional(),\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2063742540",
    "pr_number": 6595,
    "pr_file": "web/src/server/api/routers/savedViews.ts",
    "created_at": "2025-04-28T14:07:17+00:00",
    "commented_code": "+import { z } from \"zod\";\n+import {\n+  createTRPCRouter,\n+  protectedProjectProcedure,\n+} from \"@/src/server/api/trpc\";\n+import { throwIfNoProjectAccess } from \"@/src/features/rbac/utils/checkProjectAccess\";\n+import {\n+  TableViewService,\n+  CreateSavedViewInput,\n+  UpdateSavedViewInput,\n+  UpdateSavedViewNameInput,\n+} from \"@langfuse/shared/src/server\";\n+import { TRPCError } from \"@trpc/server\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+\n+/**\n+ * Maps domain errors to appropriate TRPC errors\n+ * @param fn Function to execute that might throw domain errors\n+ * @param errorConfig Optional configuration for customizing error messages\n+ */\n+export async function withErrorMapping<T>(\n+  fn: () => Promise<T>,\n+  errorConfig?: {\n+    notFoundMessage?: string;\n+    // Add more error type configurations as needed\n+  },\n+): Promise<T> {\n+  try {\n+    return await fn();\n+  } catch (error) {\n+    // Map domain errors to TRPC errors\n+    if (error instanceof LangfuseNotFoundError) {\n+      throw new TRPCError({\n+        code: \"NOT_FOUND\",\n+        message: errorConfig?.notFoundMessage || error.message,\n+        cause: error,\n+      });\n+    }\n+\n+    // Re-throw unknown errors\n+    throw error;\n+  }\n+}\n+\n+export const savedViewsRouter = createTRPCRouter({\n+  create: protectedProjectProcedure\n+    .input(CreateSavedViewInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await TableViewService.createSavedView(\n+        input,\n+        ctx.session.user?.id,\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  update: protectedProjectProcedure\n+    .input(UpdateSavedViewInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await withErrorMapping(\n+        () => TableViewService.updateSavedView(input, ctx.session.user?.id),\n+        { notFoundMessage: \"Saved view not found, failed to update\" },\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  updateName: protectedProjectProcedure\n+    .input(UpdateSavedViewNameInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await withErrorMapping(\n+        () => TableViewService.updateSavedViewName(input, ctx.session.user?.id),\n+        { notFoundMessage: \"Saved view not found, failed to update name\" },\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  delete: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        projectId: z.string(),\n+        savedViewId: z.string(),\n+      }),\n+    )\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      await TableViewService.deleteSavedView(\n+        input.savedViewId,\n+        input.projectId,\n+      );\n+\n+      return {\n+        success: true,\n+      };\n+    }),\n+\n+  getByTableName: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        tableName: z.string(),\n+        projectId: z.string(),\n+      }),\n+    )\n+    .query(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:read\",\n+      });\n+\n+      return await TableViewService.getSavedViewsByTableName(\n+        input.tableName,\n+        input.projectId,\n+      );\n+    }),\n+\n+  getById: protectedProjectProcedure\n+    .input(z.object({ viewId: z.string(), projectId: z.string() }))\n+    .query(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:read\",\n+      });\n+\n+      return await withErrorMapping(\n+        () => TableViewService.getSavedViewById(input.viewId, input.projectId),\n+        { notFoundMessage: \"Saved view not found, likely it has been deleted\" },\n+      );\n+    }),\n+\n+  generatePermalink: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        projectId: z.string(),\n+        viewId: z.string(),\n+        tableName: z.string(),\n+        baseUrl: z.string(),",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2063742540",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6595,
        "pr_file": "web/src/server/api/routers/savedViews.ts",
        "discussion_id": "2063742540",
        "commented_code": "@@ -0,0 +1,188 @@\n+import { z } from \"zod\";\n+import {\n+  createTRPCRouter,\n+  protectedProjectProcedure,\n+} from \"@/src/server/api/trpc\";\n+import { throwIfNoProjectAccess } from \"@/src/features/rbac/utils/checkProjectAccess\";\n+import {\n+  TableViewService,\n+  CreateSavedViewInput,\n+  UpdateSavedViewInput,\n+  UpdateSavedViewNameInput,\n+} from \"@langfuse/shared/src/server\";\n+import { TRPCError } from \"@trpc/server\";\n+import { LangfuseNotFoundError } from \"@langfuse/shared\";\n+\n+/**\n+ * Maps domain errors to appropriate TRPC errors\n+ * @param fn Function to execute that might throw domain errors\n+ * @param errorConfig Optional configuration for customizing error messages\n+ */\n+export async function withErrorMapping<T>(\n+  fn: () => Promise<T>,\n+  errorConfig?: {\n+    notFoundMessage?: string;\n+    // Add more error type configurations as needed\n+  },\n+): Promise<T> {\n+  try {\n+    return await fn();\n+  } catch (error) {\n+    // Map domain errors to TRPC errors\n+    if (error instanceof LangfuseNotFoundError) {\n+      throw new TRPCError({\n+        code: \"NOT_FOUND\",\n+        message: errorConfig?.notFoundMessage || error.message,\n+        cause: error,\n+      });\n+    }\n+\n+    // Re-throw unknown errors\n+    throw error;\n+  }\n+}\n+\n+export const savedViewsRouter = createTRPCRouter({\n+  create: protectedProjectProcedure\n+    .input(CreateSavedViewInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await TableViewService.createSavedView(\n+        input,\n+        ctx.session.user?.id,\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  update: protectedProjectProcedure\n+    .input(UpdateSavedViewInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await withErrorMapping(\n+        () => TableViewService.updateSavedView(input, ctx.session.user?.id),\n+        { notFoundMessage: \"Saved view not found, failed to update\" },\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  updateName: protectedProjectProcedure\n+    .input(UpdateSavedViewNameInput)\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      const view = await withErrorMapping(\n+        () => TableViewService.updateSavedViewName(input, ctx.session.user?.id),\n+        { notFoundMessage: \"Saved view not found, failed to update name\" },\n+      );\n+\n+      return {\n+        success: true,\n+        view,\n+      };\n+    }),\n+\n+  delete: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        projectId: z.string(),\n+        savedViewId: z.string(),\n+      }),\n+    )\n+    .mutation(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:CUD\",\n+      });\n+\n+      await TableViewService.deleteSavedView(\n+        input.savedViewId,\n+        input.projectId,\n+      );\n+\n+      return {\n+        success: true,\n+      };\n+    }),\n+\n+  getByTableName: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        tableName: z.string(),\n+        projectId: z.string(),\n+      }),\n+    )\n+    .query(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:read\",\n+      });\n+\n+      return await TableViewService.getSavedViewsByTableName(\n+        input.tableName,\n+        input.projectId,\n+      );\n+    }),\n+\n+  getById: protectedProjectProcedure\n+    .input(z.object({ viewId: z.string(), projectId: z.string() }))\n+    .query(async ({ input, ctx }) => {\n+      throwIfNoProjectAccess({\n+        session: ctx.session,\n+        projectId: input.projectId,\n+        scope: \"savedViews:read\",\n+      });\n+\n+      return await withErrorMapping(\n+        () => TableViewService.getSavedViewById(input.viewId, input.projectId),\n+        { notFoundMessage: \"Saved view not found, likely it has been deleted\" },\n+      );\n+    }),\n+\n+  generatePermalink: protectedProjectProcedure\n+    .input(\n+      z.object({\n+        projectId: z.string(),\n+        viewId: z.string(),\n+        tableName: z.string(),\n+        baseUrl: z.string(),",
        "comment_created_at": "2025-04-28T14:07:17+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Added a `baseUrl` field to the input schema for `generatePermalink`. Consider validating that the provided `baseUrl` is an expected, trusted URL to avoid potential misuse.\n```suggestion\n        baseUrl: z.string().url(),\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006607014",
    "pr_number": 6129,
    "pr_file": "worker/src/services/modelMatch.ts",
    "created_at": "2025-03-20T23:34:51+00:00",
    "commented_code": "+import { Model, Prisma } from \"@prisma/client\";\n+import { logger, recordIncrement } from \"@langfuse/shared/src/server\";\n+import { redis } from \"@langfuse/shared/src/server\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+import { env } from \"../env\";\n+\n+export type ModelMatchProps = {\n+  projectId: string;\n+  model?: string;\n+};\n+\n+export async function findModel(p: ModelMatchProps): Promise<Model | null> {\n+  // try to find model in Redis\n+  const redisModel = await getModelFromRedis(p);\n+  if (redisModel) {\n+    return redisModel;\n+  }\n+\n+  // try to find model in Postgres\n+  const postgresModel = await findModelInPostgres(p);\n+\n+  if (postgresModel && env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"true\") {\n+    await addModelToRedis(p, postgresModel);\n+  }\n+\n+  return postgresModel;\n+}\n+\n+const getModelFromRedis = async (p: ModelMatchProps): Promise<Model | null> => {\n+  if (env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"false\") {\n+    return null;\n+  }\n+\n+  try {\n+    const key = getRedisModelKey(p);\n+    const redisModel = await redis?.getex(\n+      key,\n+      \"EX\",\n+      env.LANGFUSE_CACHE_MODEL_MATCH_TTL_SECONDS,\n+    );\n+    if (redisModel) {\n+      recordIncrement(\"langfuse.model-match.cache_hit\", 1);\n+      const model = JSON.parse(redisModel);\n+      return {\n+        ...model,\n+        createdAt: new Date(model.createdAt),\n+        updatedAt: new Date(model.updatedAt),\n+        startDate: model.startDate ? new Date(model.startDate) : null,\n+      };\n+    }\n+    recordIncrement(\"langfuse.model-match.cache_miss\", 1);\n+    return null;\n+  } catch (error) {\n+    logger.error(\n+      `Error getting model for ${JSON.stringify(p)} from Redis: ${error}`,\n+    );\n+    return null;\n+  }\n+};\n+\n+export async function findModelInPostgres(\n+  p: ModelMatchProps,\n+): Promise<Model | null> {\n+  const { projectId, model } = p;\n+  // either get the model from the existing observation\n+  // or match pattern on the user provided model name\n+  const modelCondition = model\n+    ? Prisma.sql`AND ${model} ~ match_pattern`",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2006607014",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6129,
        "pr_file": "worker/src/services/modelMatch.ts",
        "discussion_id": "2006607014",
        "commented_code": "@@ -0,0 +1,124 @@\n+import { Model, Prisma } from \"@prisma/client\";\n+import { logger, recordIncrement } from \"@langfuse/shared/src/server\";\n+import { redis } from \"@langfuse/shared/src/server\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+import { env } from \"../env\";\n+\n+export type ModelMatchProps = {\n+  projectId: string;\n+  model?: string;\n+};\n+\n+export async function findModel(p: ModelMatchProps): Promise<Model | null> {\n+  // try to find model in Redis\n+  const redisModel = await getModelFromRedis(p);\n+  if (redisModel) {\n+    return redisModel;\n+  }\n+\n+  // try to find model in Postgres\n+  const postgresModel = await findModelInPostgres(p);\n+\n+  if (postgresModel && env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"true\") {\n+    await addModelToRedis(p, postgresModel);\n+  }\n+\n+  return postgresModel;\n+}\n+\n+const getModelFromRedis = async (p: ModelMatchProps): Promise<Model | null> => {\n+  if (env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"false\") {\n+    return null;\n+  }\n+\n+  try {\n+    const key = getRedisModelKey(p);\n+    const redisModel = await redis?.getex(\n+      key,\n+      \"EX\",\n+      env.LANGFUSE_CACHE_MODEL_MATCH_TTL_SECONDS,\n+    );\n+    if (redisModel) {\n+      recordIncrement(\"langfuse.model-match.cache_hit\", 1);\n+      const model = JSON.parse(redisModel);\n+      return {\n+        ...model,\n+        createdAt: new Date(model.createdAt),\n+        updatedAt: new Date(model.updatedAt),\n+        startDate: model.startDate ? new Date(model.startDate) : null,\n+      };\n+    }\n+    recordIncrement(\"langfuse.model-match.cache_miss\", 1);\n+    return null;\n+  } catch (error) {\n+    logger.error(\n+      `Error getting model for ${JSON.stringify(p)} from Redis: ${error}`,\n+    );\n+    return null;\n+  }\n+};\n+\n+export async function findModelInPostgres(\n+  p: ModelMatchProps,\n+): Promise<Model | null> {\n+  const { projectId, model } = p;\n+  // either get the model from the existing observation\n+  // or match pattern on the user provided model name\n+  const modelCondition = model\n+    ? Prisma.sql`AND ${model} ~ match_pattern`",
        "comment_created_at": "2025-03-20T23:34:51+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Ensure that dynamically building the SQL fragment with the model value (using `${model} ~ match_pattern`) does not introduce SQL injection vulnerabilities. Consider parameterizing this value if it's user-controlled.\n```suggestion\n    ? Prisma.sql`AND $1 ~ match_pattern`, model\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006607015",
    "pr_number": 6129,
    "pr_file": "worker/src/services/modelMatch.ts",
    "created_at": "2025-03-20T23:34:51+00:00",
    "commented_code": "+import { Model, Prisma } from \"@prisma/client\";\n+import { logger, recordIncrement } from \"@langfuse/shared/src/server\";\n+import { redis } from \"@langfuse/shared/src/server\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+import { env } from \"../env\";\n+\n+export type ModelMatchProps = {\n+  projectId: string;\n+  model?: string;\n+};\n+\n+export async function findModel(p: ModelMatchProps): Promise<Model | null> {\n+  // try to find model in Redis\n+  const redisModel = await getModelFromRedis(p);\n+  if (redisModel) {\n+    return redisModel;\n+  }\n+\n+  // try to find model in Postgres\n+  const postgresModel = await findModelInPostgres(p);\n+\n+  if (postgresModel && env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"true\") {\n+    await addModelToRedis(p, postgresModel);\n+  }\n+\n+  return postgresModel;\n+}\n+\n+const getModelFromRedis = async (p: ModelMatchProps): Promise<Model | null> => {\n+  if (env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"false\") {\n+    return null;\n+  }\n+\n+  try {\n+    const key = getRedisModelKey(p);\n+    const redisModel = await redis?.getex(\n+      key,\n+      \"EX\",\n+      env.LANGFUSE_CACHE_MODEL_MATCH_TTL_SECONDS,\n+    );\n+    if (redisModel) {\n+      recordIncrement(\"langfuse.model-match.cache_hit\", 1);\n+      const model = JSON.parse(redisModel);\n+      return {\n+        ...model,\n+        createdAt: new Date(model.createdAt),\n+        updatedAt: new Date(model.updatedAt),\n+        startDate: model.startDate ? new Date(model.startDate) : null,\n+      };\n+    }\n+    recordIncrement(\"langfuse.model-match.cache_miss\", 1);\n+    return null;\n+  } catch (error) {\n+    logger.error(\n+      `Error getting model for ${JSON.stringify(p)} from Redis: ${error}`,\n+    );\n+    return null;\n+  }\n+};\n+\n+export async function findModelInPostgres(\n+  p: ModelMatchProps,\n+): Promise<Model | null> {\n+  const { projectId, model } = p;\n+  // either get the model from the existing observation\n+  // or match pattern on the user provided model name\n+  const modelCondition = model",
    "repo_full_name": "langfuse/langfuse",
    "discussion_comments": [
      {
        "comment_id": "2006607015",
        "repo_full_name": "langfuse/langfuse",
        "pr_number": 6129,
        "pr_file": "worker/src/services/modelMatch.ts",
        "discussion_id": "2006607015",
        "commented_code": "@@ -0,0 +1,124 @@\n+import { Model, Prisma } from \"@prisma/client\";\n+import { logger, recordIncrement } from \"@langfuse/shared/src/server\";\n+import { redis } from \"@langfuse/shared/src/server\";\n+import { prisma } from \"@langfuse/shared/src/db\";\n+import { env } from \"../env\";\n+\n+export type ModelMatchProps = {\n+  projectId: string;\n+  model?: string;\n+};\n+\n+export async function findModel(p: ModelMatchProps): Promise<Model | null> {\n+  // try to find model in Redis\n+  const redisModel = await getModelFromRedis(p);\n+  if (redisModel) {\n+    return redisModel;\n+  }\n+\n+  // try to find model in Postgres\n+  const postgresModel = await findModelInPostgres(p);\n+\n+  if (postgresModel && env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"true\") {\n+    await addModelToRedis(p, postgresModel);\n+  }\n+\n+  return postgresModel;\n+}\n+\n+const getModelFromRedis = async (p: ModelMatchProps): Promise<Model | null> => {\n+  if (env.LANGFUSE_CACHE_MODEL_MATCH_ENABLED === \"false\") {\n+    return null;\n+  }\n+\n+  try {\n+    const key = getRedisModelKey(p);\n+    const redisModel = await redis?.getex(\n+      key,\n+      \"EX\",\n+      env.LANGFUSE_CACHE_MODEL_MATCH_TTL_SECONDS,\n+    );\n+    if (redisModel) {\n+      recordIncrement(\"langfuse.model-match.cache_hit\", 1);\n+      const model = JSON.parse(redisModel);\n+      return {\n+        ...model,\n+        createdAt: new Date(model.createdAt),\n+        updatedAt: new Date(model.updatedAt),\n+        startDate: model.startDate ? new Date(model.startDate) : null,\n+      };\n+    }\n+    recordIncrement(\"langfuse.model-match.cache_miss\", 1);\n+    return null;\n+  } catch (error) {\n+    logger.error(\n+      `Error getting model for ${JSON.stringify(p)} from Redis: ${error}`,\n+    );\n+    return null;\n+  }\n+};\n+\n+export async function findModelInPostgres(\n+  p: ModelMatchProps,\n+): Promise<Model | null> {\n+  const { projectId, model } = p;\n+  // either get the model from the existing observation\n+  // or match pattern on the user provided model name\n+  const modelCondition = model",
        "comment_created_at": "2025-03-20T23:34:51+00:00",
        "comment_author": "ellipsis-dev[bot]",
        "comment_body": "Validate/sanitize the user-supplied `model` before using it in the SQL regex condition to avoid potential performance issues or abuse.",
        "pr_file_module": null
      }
    ]
  }
]