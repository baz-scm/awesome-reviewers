[
  {
    "discussion_id": "314130480",
    "pr_number": 710,
    "pr_file": "security/security.c",
    "created_at": "2019-08-14T23:51:56+00:00",
    "commented_code": "-// SPDX-License-Identifier: GPL-2.0-or-later\n-/*\n- * Security plug functions\n- *\n- * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>\n- * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>\n- * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>\n- * Copyright (C) 2016 Mellanox Technologies\n- */\n-\n-#define pr_fmt(fmt) \"LSM: \" fmt\n-\n-#include <linux/bpf.h>\n-#include <linux/capability.h>\n-#include <linux/dcache.h>\n-#include <linux/export.h>\n-#include <linux/init.h>\n-#include <linux/kernel.h>\n-#include <linux/lsm_hooks.h>\n-#include <linux/integrity.h>\n-#include <linux/ima.h>\n-#include <linux/evm.h>\n-#include <linux/fsnotify.h>\n-#include <linux/mman.h>\n-#include <linux/mount.h>\n-#include <linux/personality.h>\n-#include <linux/backing-dev.h>\n-#include <linux/string.h>\n-#include <linux/msg.h>\n-#include <net/flow.h>\n-\n-#define MAX_LSM_EVM_XATTR\t2\n-\n-/* How many LSMs were built into the kernel? */\n-#define LSM_COUNT (__end_lsm_info - __start_lsm_info)\n-\n-struct security_hook_heads security_hook_heads __lsm_ro_after_init;\n-static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);\n-\n-static struct kmem_cache *lsm_file_cache;\n-static struct kmem_cache *lsm_inode_cache;\n-\n-char *lsm_names;\n-static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;\n-\n-/* Boot-time LSM user choice */\n-static __initdata const char *chosen_lsm_order;\n-static __initdata const char *chosen_major_lsm;\n-\n-static __initconst const char * const builtin_lsm_order = CONFIG_LSM;\n-\n-/* Ordered list of LSMs to initialize. */\n-static __initdata struct lsm_info **ordered_lsms;\n-static __initdata struct lsm_info *exclusive;\n-\n-static __initdata bool debug;\n-#define init_debug(...)\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tif (debug)\t\t\t\t\t\\\n-\t\t\tpr_info(__VA_ARGS__);\t\t\t\\\n-\t} while (0)\n-\n-static bool __init is_enabled(struct lsm_info *lsm)\n-{\n-\tif (!lsm->enabled)\n-\t\treturn false;\n-\n-\treturn *lsm->enabled;\n-}\n-\n-/* Mark an LSM's enabled flag. */\n-static int lsm_enabled_true __initdata = 1;\n-static int lsm_enabled_false __initdata = 0;\n-static void __init set_enabled(struct lsm_info *lsm, bool enabled)\n-{\n-\t/*\n-\t * When an LSM hasn't configured an enable variable, we can use\n-\t * a hard-coded location for storing the default enabled state.\n-\t */\n-\tif (!lsm->enabled) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t\telse\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_true) {\n-\t\tif (!enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_false) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t} else {\n-\t\t*lsm->enabled = enabled;\n-\t}\n-}\n-\n-/* Is an LSM already listed in the ordered LSMs list? */\n-static bool __init exists_ordered_lsm(struct lsm_info *lsm)\n-{\n-\tstruct lsm_info **check;\n-\n-\tfor (check = ordered_lsms; *check; check++)\n-\t\tif (*check == lsm)\n-\t\t\treturn true;\n-\n-\treturn false;\n-}\n-\n-/* Append an LSM to the list of ordered LSMs to initialize. */\n-static int last_lsm __initdata;\n-static void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)\n-{\n-\t/* Ignore duplicate selections. */\n-\tif (exists_ordered_lsm(lsm))\n-\t\treturn;\n-\n-\tif (WARN(last_lsm == LSM_COUNT, \"%s: out of LSM slots!?\n\", from))\n-\t\treturn;\n-\n-\t/* Enable this LSM, if it is not already set. */\n-\tif (!lsm->enabled)\n-\t\tlsm->enabled = &lsm_enabled_true;\n-\tordered_lsms[last_lsm++] = lsm;\n-\n-\tinit_debug(\"%s ordering: %s (%sabled)\n\", from, lsm->name,\n-\t\t   is_enabled(lsm) ? \"en\" : \"dis\");\n-}\n-\n-/* Is an LSM allowed to be initialized? */\n-static bool __init lsm_allowed(struct lsm_info *lsm)\n-{\n-\t/* Skip if the LSM is disabled. */\n-\tif (!is_enabled(lsm))\n-\t\treturn false;\n-\n-\t/* Not allowed if another exclusive LSM already initialized. */\n-\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && exclusive) {\n-\t\tinit_debug(\"exclusive disabled: %s\n\", lsm->name);\n-\t\treturn false;\n-\t}\n-\n-\treturn true;\n-}\n-\n-static void __init lsm_set_blob_size(int *need, int *lbs)\n-{\n-\tint offset;\n-\n-\tif (*need > 0) {\n-\t\toffset = *lbs;\n-\t\t*lbs += *need;\n-\t\t*need = offset;\n-\t}\n-}\n-\n-static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)\n-{\n-\tif (!needed)\n-\t\treturn;\n-\n-\tlsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);\n-\tlsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);\n-\t/*\n-\t * The inode blob gets an rcu_head in addition to\n-\t * what the modules might need.\n-\t */\n-\tif (needed->lbs_inode && blob_sizes.lbs_inode == 0)\n-\t\tblob_sizes.lbs_inode = sizeof(struct rcu_head);\n-\tlsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);\n-\tlsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);\n-\tlsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);\n-\tlsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);\n-}\n-\n-/* Prepare LSM for initialization. */\n-static void __init prepare_lsm(struct lsm_info *lsm)\n-{\n-\tint enabled = lsm_allowed(lsm);\n-\n-\t/* Record enablement (to handle any following exclusive LSMs). */\n-\tset_enabled(lsm, enabled);\n-\n-\t/* If enabled, do pre-initialization work. */\n-\tif (enabled) {\n-\t\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {\n-\t\t\texclusive = lsm;\n-\t\t\tinit_debug(\"exclusive chosen: %s\n\", lsm->name);\n-\t\t}\n-\n-\t\tlsm_set_blob_sizes(lsm->blobs);\n-\t}\n-}\n-\n-/* Initialize a given LSM, if it is enabled. */\n-static void __init initialize_lsm(struct lsm_info *lsm)\n-{\n-\tif (is_enabled(lsm)) {\n-\t\tint ret;\n-\n-\t\tinit_debug(\"initializing %s\n\", lsm->name);\n-\t\tret = lsm->init();\n-\t\tWARN(ret, \"%s failed to initialize: %d\n\", lsm->name, ret);\n-\t}\n-}\n-\n-/* Populate ordered LSMs list from comma-separated LSM name list. */\n-static void __init ordered_lsm_parse(const char *order, const char *origin)\n-{\n-\tstruct lsm_info *lsm;\n-\tchar *sep, *name, *next;\n-\n-\t/* LSM_ORDER_FIRST is always first. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (lsm->order == LSM_ORDER_FIRST)\n-\t\t\tappend_ordered_lsm(lsm, \"first\");\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tstruct lsm_info *major;\n-\n-\t\t/*\n-\t\t * To match the original \"security=\" behavior, this\n-\t\t * explicitly does NOT fallback to another Legacy Major\n-\t\t * if the selected one was separately disabled: disable\n-\t\t * all non-matching Legacy Major LSMs.\n-\t\t */\n-\t\tfor (major = __start_lsm_info; major < __end_lsm_info;\n-\t\t     major++) {\n-\t\t\tif ((major->flags & LSM_FLAG_LEGACY_MAJOR) &&\n-\t\t\t    strcmp(major->name, chosen_major_lsm) != 0) {\n-\t\t\t\tset_enabled(major, false);\n-\t\t\t\tinit_debug(\"security=%s disabled: %s\n\",\n-\t\t\t\t\t   chosen_major_lsm, major->name);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tsep = kstrdup(order, GFP_KERNEL);\n-\tnext = sep;\n-\t/* Walk the list, looking for matching LSMs. */\n-\twhile ((name = strsep(&next, \",\")) != NULL) {\n-\t\tbool found = false;\n-\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (lsm->order == LSM_ORDER_MUTABLE &&\n-\t\t\t    strcmp(lsm->name, name) == 0) {\n-\t\t\t\tappend_ordered_lsm(lsm, origin);\n-\t\t\t\tfound = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!found)\n-\t\t\tinit_debug(\"%s ignored: %s\n\", origin, name);\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (exists_ordered_lsm(lsm))\n-\t\t\t\tcontinue;\n-\t\t\tif (strcmp(lsm->name, chosen_major_lsm) == 0)\n-\t\t\t\tappend_ordered_lsm(lsm, \"security=\");\n-\t\t}\n-\t}\n-\n-\t/* Disable all LSMs not in the ordered list. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (exists_ordered_lsm(lsm))\n-\t\t\tcontinue;\n-\t\tset_enabled(lsm, false);\n-\t\tinit_debug(\"%s disabled: %s\n\", origin, lsm->name);\n-\t}\n-\n-\tkfree(sep);\n-}\n-\n-static void __init lsm_early_cred(struct cred *cred);\n-static void __init lsm_early_task(struct task_struct *task);\n-\n-static void __init ordered_lsm_init(void)\n-{\n-\tstruct lsm_info **lsm;\n-\n-\tordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),\n-\t\t\t\tGFP_KERNEL);\n-\n-\tif (chosen_lsm_order) {\n-\t\tif (chosen_major_lsm) {\n-\t\t\tpr_info(\"security= is ignored because it is superseded by lsm=\n\");\n-\t\t\tchosen_major_lsm = NULL;\n-\t\t}\n-\t\tordered_lsm_parse(chosen_lsm_order, \"cmdline\");\n-\t} else\n-\t\tordered_lsm_parse(builtin_lsm_order, \"builtin\");\n-\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tprepare_lsm(*lsm);\n-\n-\tinit_debug(\"cred blob size     = %d\n\", blob_sizes.lbs_cred);\n-\tinit_debug(\"file blob size     = %d\n\", blob_sizes.lbs_file);\n-\tinit_debug(\"inode blob size    = %d\n\", blob_sizes.lbs_inode);\n-\tinit_debug(\"ipc blob size      = %d\n\", blob_sizes.lbs_ipc);\n-\tinit_debug(\"msg_msg blob size  = %d\n\", blob_sizes.lbs_msg_msg);\n-\tinit_debug(\"task blob size     = %d\n\", blob_sizes.lbs_task);\n-\n-\t/*\n-\t * Create any kmem_caches needed for blobs\n-\t */\n-\tif (blob_sizes.lbs_file)\n-\t\tlsm_file_cache = kmem_cache_create(\"lsm_file_cache\",\n-\t\t\t\t\t\t   blob_sizes.lbs_file, 0,\n-\t\t\t\t\t\t   SLAB_PANIC, NULL);\n-\tif (blob_sizes.lbs_inode)\n-\t\tlsm_inode_cache = kmem_cache_create(\"lsm_inode_cache\",\n-\t\t\t\t\t\t    blob_sizes.lbs_inode, 0,\n-\t\t\t\t\t\t    SLAB_PANIC, NULL);\n-\n-\tlsm_early_cred((struct cred *) current->cred);\n-\tlsm_early_task(current);\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tinitialize_lsm(*lsm);\n-\n-\tkfree(ordered_lsms);\n-}\n-\n-/**\n- * security_init - initializes the security framework\n- *\n- * This should be called early in the kernel initialization sequence.\n- */\n-int __init security_init(void)\n-{\n-\tint i;\n-\tstruct hlist_head *list = (struct hlist_head *) &security_hook_heads;\n-\n-\tpr_info(\"Security Framework initializing\n\");\n-\n-\tfor (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);\n-\t     i++)\n-\t\tINIT_HLIST_HEAD(&list[i]);\n-\n-\t/* Load LSMs in specified order. */\n-\tordered_lsm_init();\n-\n-\treturn 0;\n-}\n-\n-/* Save user chosen LSM */\n-static int __init choose_major_lsm(char *str)\n-{\n-\tchosen_major_lsm = str;\n-\treturn 1;\n-}\n-__setup(\"security=\", choose_major_lsm);\n-\n-/* Explicitly choose LSM initialization order. */\n-static int __init choose_lsm_order(char *str)\n-{\n-\tchosen_lsm_order = str;\n-\treturn 1;\n-}\n-__setup(\"lsm=\", choose_lsm_order);\n-\n-/* Enable LSM order debugging. */\n-static int __init enable_debug(char *str)\n-{\n-\tdebug = true;\n-\treturn 1;\n-}\n-__setup(\"lsm.debug\", enable_debug);\n-\n-static bool match_last_lsm(const char *list, const char *lsm)\n-{\n-\tconst char *last;\n-\n-\tif (WARN_ON(!list || !lsm))\n-\t\treturn false;\n-\tlast = strrchr(list, ',');\n-\tif (last)\n-\t\t/* Pass the comma, strcmp() will check for '\\0' */\n-\t\tlast++;\n-\telse\n-\t\tlast = list;\n-\treturn !strcmp(last, lsm);\n-}\n-\n-static int lsm_append(char *new, char **result)\n-{\n-\tchar *cp;\n-\n-\tif (*result == NULL) {\n-\t\t*result = kstrdup(new, GFP_KERNEL);\n-\t\tif (*result == NULL)\n-\t\t\treturn -ENOMEM;\n-\t} else {\n-\t\t/* Check if it is the last registered name */\n-\t\tif (match_last_lsm(*result, new))\n-\t\t\treturn 0;\n-\t\tcp = kasprintf(GFP_KERNEL, \"%s,%s\", *result, new);\n-\t\tif (cp == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\tkfree(*result);\n-\t\t*result = cp;\n-\t}\n-\treturn 0;\n-}\n-\n-/**\n- * security_add_hooks - Add a modules hooks to the hook lists.\n- * @hooks: the hooks to add\n- * @count: the number of hooks to add\n- * @lsm: the name of the security module\n- *\n- * Each LSM has to register its hooks with the infrastructure.\n- */\n-void __init security_add_hooks(struct security_hook_list *hooks, int count,\n-\t\t\t\tchar *lsm)\n-{\n-\tint i;\n-\n-\tfor (i = 0; i < count; i++) {\n-\t\thooks[i].lsm = lsm;\n-\t\thlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n-\t}\n-\tif (lsm_append(lsm, &lsm_names) < 0)\n-\t\tpanic(\"%s - Cannot get early memory.\n\", __func__);\n-}\n-\n-int call_blocking_lsm_notifier(enum lsm_event event, void *data)\n-{\n-\treturn blocking_notifier_call_chain(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t    event, data);\n-}\n-EXPORT_SYMBOL(call_blocking_lsm_notifier);\n-\n-int register_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_register(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\tnb);\n-}\n-EXPORT_SYMBOL(register_blocking_lsm_notifier);\n-\n-int unregister_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\t  nb);\n-}\n-EXPORT_SYMBOL(unregister_blocking_lsm_notifier);\n-\n-/**\n- * lsm_cred_alloc - allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- * @gfp: allocation type\n- *\n- * Allocate the cred blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)\n-{\n-\tif (blob_sizes.lbs_cred == 0) {\n-\t\tcred->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tcred->security = kzalloc(blob_sizes.lbs_cred, gfp);\n-\tif (cred->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_cred - during initialization allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- *\n- * Allocate the cred blob for all the modules\n- */\n-static void __init lsm_early_cred(struct cred *cred)\n-{\n-\tint rc = lsm_cred_alloc(cred, GFP_KERNEL);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early cred alloc failed.\n\", __func__);\n-}\n-\n-/**\n- * lsm_file_alloc - allocate a composite file blob\n- * @file: the file that needs a blob\n- *\n- * Allocate the file blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_file_alloc(struct file *file)\n-{\n-\tif (!lsm_file_cache) {\n-\t\tfile->f_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tfile->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);\n-\tif (file->f_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_inode_alloc - allocate a composite inode blob\n- * @inode: the inode that needs a blob\n- *\n- * Allocate the inode blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-int lsm_inode_alloc(struct inode *inode)\n-{\n-\tif (!lsm_inode_cache) {\n-\t\tinode->i_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tinode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);\n-\tif (inode->i_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_task_alloc - allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_task_alloc(struct task_struct *task)\n-{\n-\tif (blob_sizes.lbs_task == 0) {\n-\t\ttask->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\ttask->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);\n-\tif (task->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_ipc_alloc - allocate a composite ipc blob\n- * @kip: the ipc that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_ipc_alloc(struct kern_ipc_perm *kip)\n-{\n-\tif (blob_sizes.lbs_ipc == 0) {\n-\t\tkip->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tkip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);\n-\tif (kip->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_msg_msg_alloc - allocate a composite msg_msg blob\n- * @mp: the msg_msg that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_msg_msg_alloc(struct msg_msg *mp)\n-{\n-\tif (blob_sizes.lbs_msg_msg == 0) {\n-\t\tmp->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tmp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);\n-\tif (mp->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_task - during initialization allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- */\n-static void __init lsm_early_task(struct task_struct *task)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early task alloc failed.\n\", __func__);\n-}\n-\n-/*\n- * Hook list operation macros.\n- *\n- * call_void_hook:\n- *\tThis is a hook that does not return a value.\n- *\n- * call_int_hook:\n- *\tThis is a hook that returns a value.\n- */\n-\n-#define call_void_hook(FUNC, ...)\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) \\\n-\t\t\tP->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t} while (0)\n-\n-#define call_int_hook(FUNC, IRC, ...) ({\t\t\t\\\n-\tint RC = IRC;\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \\\n-\t\t\tRC = P->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t\t\tif (RC != 0)\t\t\t\t\\\n-\t\t\t\tbreak;\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\\\n-\t} while (0);\t\t\t\t\t\t\\\n-\tRC;\t\t\t\t\t\t\t\\\n-})\n-\n-/* Security operations */\n-\n-int security_binder_set_context_mgr(struct task_struct *mgr)\n-{\n-\treturn call_int_hook(binder_set_context_mgr, 0, mgr);\n-}\n-\n-int security_binder_transaction(struct task_struct *from,\n-\t\t\t\tstruct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transaction, 0, from, to);\n-}\n-\n-int security_binder_transfer_binder(struct task_struct *from,\n-\t\t\t\t    struct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transfer_binder, 0, from, to);\n-}\n-\n-int security_binder_transfer_file(struct task_struct *from,\n-\t\t\t\t  struct task_struct *to, struct file *file)\n-{\n-\treturn call_int_hook(binder_transfer_file, 0, from, to, file);\n-}\n-\n-int security_ptrace_access_check(struct task_struct *child, unsigned int mode)\n-{\n-\treturn call_int_hook(ptrace_access_check, 0, child, mode);\n-}\n-\n-int security_ptrace_traceme(struct task_struct *parent)\n-{\n-\treturn call_int_hook(ptrace_traceme, 0, parent);\n-}\n-\n-int security_capget(struct task_struct *target,\n-\t\t     kernel_cap_t *effective,\n-\t\t     kernel_cap_t *inheritable,\n-\t\t     kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capget, 0, target,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capset(struct cred *new, const struct cred *old,\n-\t\t    const kernel_cap_t *effective,\n-\t\t    const kernel_cap_t *inheritable,\n-\t\t    const kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capset, 0, new, old,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capable(const struct cred *cred,\n-\t\t     struct user_namespace *ns,\n-\t\t     int cap,\n-\t\t     unsigned int opts)\n-{\n-\treturn call_int_hook(capable, 0, cred, ns, cap, opts);\n-}\n-\n-int security_quotactl(int cmds, int type, int id, struct super_block *sb)\n-{\n-\treturn call_int_hook(quotactl, 0, cmds, type, id, sb);\n-}\n-\n-int security_quota_on(struct dentry *dentry)\n-{\n-\treturn call_int_hook(quota_on, 0, dentry);\n-}\n-\n-int security_syslog(int type)\n-{\n-\treturn call_int_hook(syslog, 0, type);\n-}\n-\n-int security_settime64(const struct timespec64 *ts, const struct timezone *tz)\n-{\n-\treturn call_int_hook(settime, 0, ts, tz);\n-}\n-\n-int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)\n-{\n-\tstruct security_hook_list *hp;\n-\tint cap_sys_admin = 1;\n-\tint rc;\n-\n-\t/*\n-\t * The module will respond with a positive value if\n-\t * it thinks the __vm_enough_memory() call should be\n-\t * made with the cap_sys_admin set. If all of the modules\n-\t * agree that it should be set it will. If any module\n-\t * thinks it should not be set it won't.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {\n-\t\trc = hp->hook.vm_enough_memory(mm, pages);\n-\t\tif (rc <= 0) {\n-\t\t\tcap_sys_admin = 0;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\treturn __vm_enough_memory(mm, pages, cap_sys_admin);\n-}\n-\n-int security_bprm_set_creds(struct linux_binprm *bprm)\n-{\n-\treturn call_int_hook(bprm_set_creds, 0, bprm);\n-}\n-\n-int security_bprm_check(struct linux_binprm *bprm)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(bprm_check_security, 0, bprm);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_bprm_check(bprm);\n-}\n-\n-void security_bprm_committing_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committing_creds, bprm);\n-}\n-\n-void security_bprm_committed_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committed_creds, bprm);\n-}\n-\n-int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n-{\n-\treturn call_int_hook(fs_context_dup, 0, fc, src_fc);\n-}\n-\n-int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)\n-{\n-\treturn call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);\n-}\n-\n-int security_sb_alloc(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_alloc_security, 0, sb);\n-}\n-\n-void security_sb_free(struct super_block *sb)\n-{\n-\tcall_void_hook(sb_free_security, sb);\n-}\n-\n-void security_free_mnt_opts(void **mnt_opts)\n-{\n-\tif (!*mnt_opts)\n-\t\treturn;\n-\tcall_void_hook(sb_free_mnt_opts, *mnt_opts);\n-\t*mnt_opts = NULL;\n-}\n-EXPORT_SYMBOL(security_free_mnt_opts);\n-\n-int security_sb_eat_lsm_opts(char *options, void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_eat_lsm_opts, 0, options, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_eat_lsm_opts);\n-\n-int security_sb_remount(struct super_block *sb,\n-\t\t\tvoid *mnt_opts)\n-{\n-\treturn call_int_hook(sb_remount, 0, sb, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_remount);\n-\n-int security_sb_kern_mount(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_kern_mount, 0, sb);\n-}\n-\n-int security_sb_show_options(struct seq_file *m, struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_show_options, 0, m, sb);\n-}\n-\n-int security_sb_statfs(struct dentry *dentry)\n-{\n-\treturn call_int_hook(sb_statfs, 0, dentry);\n-}\n-\n-int security_sb_mount(const char *dev_name, const struct path *path,\n-                       const char *type, unsigned long flags, void *data)\n-{\n-\treturn call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);\n-}\n-\n-int security_sb_umount(struct vfsmount *mnt, int flags)\n-{\n-\treturn call_int_hook(sb_umount, 0, mnt, flags);\n-}\n-\n-int security_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n-{\n-\treturn call_int_hook(sb_pivotroot, 0, old_path, new_path);\n-}\n-\n-int security_sb_set_mnt_opts(struct super_block *sb,\n-\t\t\t\tvoid *mnt_opts,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_set_mnt_opts,\n-\t\t\t\tmnt_opts ? -EOPNOTSUPP : 0, sb,\n-\t\t\t\tmnt_opts, kern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_set_mnt_opts);\n-\n-int security_sb_clone_mnt_opts(const struct super_block *oldsb,\n-\t\t\t\tstruct super_block *newsb,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb,\n-\t\t\t\tkern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_clone_mnt_opts);\n-\n-int security_add_mnt_opt(const char *option, const char *val, int len,\n-\t\t\t void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_add_mnt_opt, -EINVAL,\n-\t\t\t\t\toption, val, len, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_add_mnt_opt);\n-\n-int security_move_mount(const struct path *from_path, const struct path *to_path)\n-{\n-\treturn call_int_hook(move_mount, 0, from_path, to_path);\n-}\n-\n-int security_inode_alloc(struct inode *inode)\n-{\n-\tint rc = lsm_inode_alloc(inode);\n-\n-\tif (unlikely(rc))\n-\t\treturn rc;\n-\trc = call_int_hook(inode_alloc_security, 0, inode);\n-\tif (unlikely(rc))\n-\t\tsecurity_inode_free(inode);\n-\treturn rc;\n-}\n-\n-static void inode_free_by_rcu(struct rcu_head *head)\n-{\n-\t/*\n-\t * The rcu head is at the start of the inode blob\n-\t */\n-\tkmem_cache_free(lsm_inode_cache, head);\n-}\n-\n-void security_inode_free(struct inode *inode)\n-{\n-\tintegrity_inode_free(inode);\n-\tcall_void_hook(inode_free_security, inode);\n-\t/*\n-\t * The inode may still be referenced in a path walk and\n-\t * a call to security_inode_permission() can be made\n-\t * after inode_free_security() is called. Ideally, the VFS\n-\t * wouldn't do this, but fixing that is a much harder\n-\t * job. For now, simply free the i_security via RCU, and\n-\t * leave the current inode->i_security pointer intact.\n-\t * The inode will be freed after the RCU grace period too.\n-\t */\n-\tif (inode->i_security)\n-\t\tcall_rcu((struct rcu_head *)inode->i_security,\n-\t\t\t\tinode_free_by_rcu);\n-}\n-\n-int security_dentry_init_security(struct dentry *dentry, int mode,\n-\t\t\t\t\tconst struct qstr *name, void **ctx,\n-\t\t\t\t\tu32 *ctxlen)\n-{\n-\treturn call_int_hook(dentry_init_security, -EOPNOTSUPP, dentry, mode,\n-\t\t\t\tname, ctx, ctxlen);\n-}\n-EXPORT_SYMBOL(security_dentry_init_security);\n-\n-int security_dentry_create_files_as(struct dentry *dentry, int mode,\n-\t\t\t\t    struct qstr *name,\n-\t\t\t\t    const struct cred *old, struct cred *new)\n-{\n-\treturn call_int_hook(dentry_create_files_as, 0, dentry, mode,\n-\t\t\t\tname, old, new);\n-}\n-EXPORT_SYMBOL(security_dentry_create_files_as);\n-\n-int security_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t const struct qstr *qstr,\n-\t\t\t\t const initxattrs initxattrs, void *fs_data)\n-{\n-\tstruct xattr new_xattrs[MAX_LSM_EVM_XATTR + 1];\n-\tstruct xattr *lsm_xattr, *evm_xattr, *xattr;\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\n-\tif (!initxattrs)\n-\t\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode,\n-\t\t\t\t     dir, qstr, NULL, NULL, NULL);\n-\tmemset(new_xattrs, 0, sizeof(new_xattrs));\n-\tlsm_xattr = new_xattrs;\n-\tret = call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir, qstr,\n-\t\t\t\t\t\t&lsm_xattr->name,\n-\t\t\t\t\t\t&lsm_xattr->value,\n-\t\t\t\t\t\t&lsm_xattr->value_len);\n-\tif (ret)\n-\t\tgoto out;\n-\n-\tevm_xattr = lsm_xattr + 1;\n-\tret = evm_inode_init_security(inode, lsm_xattr, evm_xattr);\n-\tif (ret)\n-\t\tgoto out;\n-\tret = initxattrs(inode, new_xattrs, fs_data);\n-out:\n-\tfor (xattr = new_xattrs; xattr->value != NULL; xattr++)\n-\t\tkfree(xattr->value);\n-\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n-}\n-EXPORT_SYMBOL(security_inode_init_security);\n-\n-int security_old_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t     const struct qstr *qstr, const char **name,\n-\t\t\t\t     void **value, size_t *len)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir,\n-\t\t\t     qstr, name, value, len);\n-}\n-EXPORT_SYMBOL(security_old_inode_init_security);\n-\n-#ifdef CONFIG_SECURITY_PATH\n-int security_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode,\n-\t\t\tunsigned int dev)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mknod, 0, dir, dentry, mode, dev);\n-}\n-EXPORT_SYMBOL(security_path_mknod);\n-\n-int security_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL(security_path_mkdir);\n-\n-int security_path_rmdir(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_rmdir, 0, dir, dentry);\n-}\n-\n-int security_path_unlink(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_unlink, 0, dir, dentry);\n-}\n-EXPORT_SYMBOL(security_path_unlink);\n-\n-int security_path_symlink(const struct path *dir, struct dentry *dentry,\n-\t\t\t  const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_path_link(struct dentry *old_dentry, const struct path *new_dir,\n-\t\t       struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);\n-}\n-\n-int security_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n-\t\t\t const struct path *new_dir, struct dentry *new_dentry,\n-\t\t\t unsigned int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-\t\t     (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(path_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\told_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(path_rename, 0, old_dir, old_dentry, new_dir,\n-\t\t\t\tnew_dentry);\n-}\n-EXPORT_SYMBOL(security_path_rename);\n-\n-int security_path_truncate(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_truncate, 0, path);\n-}\n-\n-int security_path_chmod(const struct path *path, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chmod, 0, path, mode);\n-}\n-\n-int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chown, 0, path, uid, gid);\n-}\n-\n-int security_path_chroot(const struct path *path)\n-{\n-\treturn call_int_hook(path_chroot, 0, path);\n-}\n-#endif\n-\n-int security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_create, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_create);\n-\n-int security_inode_link(struct dentry *old_dentry, struct inode *dir,\n-\t\t\t struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_link, 0, old_dentry, dir, new_dentry);\n-}\n-\n-int security_inode_unlink(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_unlink, 0, dir, dentry);\n-}\n-\n-int security_inode_symlink(struct inode *dir, struct dentry *dentry,\n-\t\t\t    const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_mkdir);\n-\n-int security_inode_rmdir(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_rmdir, 0, dir, dentry);\n-}\n-\n-int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mknod, 0, dir, dentry, mode, dev);\n-}\n-\n-int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,\n-\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n-\t\t\t   unsigned int flags)\n-{\n-        if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-            (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(inode_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\t\t     old_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(inode_rename, 0, old_dir, old_dentry,\n-\t\t\t\t\t   new_dir, new_dentry);\n-}\n-\n-int security_inode_readlink(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_readlink, 0, dentry);\n-}\n-\n-int security_inode_follow_link(struct dentry *dentry, struct inode *inode,\n-\t\t\t       bool rcu)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_follow_link, 0, dentry, inode, rcu);\n-}\n-\n-int security_inode_permission(struct inode *inode, int mask)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_permission, 0, inode, mask);\n-}\n-\n-int security_inode_setattr(struct dentry *dentry, struct iattr *attr)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\tret = call_int_hook(inode_setattr, 0, dentry, attr);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setattr(dentry, attr);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_setattr);\n-\n-int security_inode_getattr(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getattr, 0, path);\n-}\n-\n-int security_inode_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t    const void *value, size_t size, int flags)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_setxattr, 1, dentry, name, value, size,\n-\t\t\t\tflags);\n-\n-\tif (ret == 1)\n-\t\tret = cap_inode_setxattr(dentry, name, value, size, flags);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_setxattr(dentry, name, value, size);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setxattr(dentry, name, value, size);\n-}\n-\n-void security_inode_post_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t\t  const void *value, size_t size, int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn;\n-\tcall_void_hook(inode_post_setxattr, dentry, name, value, size, flags);\n-\tevm_inode_post_setxattr(dentry, name, value, size);\n-}\n-\n-int security_inode_getxattr(struct dentry *dentry, const char *name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getxattr, 0, dentry, name);\n-}\n-\n-int security_inode_listxattr(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listxattr, 0, dentry);\n-}\n-\n-int security_inode_removexattr(struct dentry *dentry, const char *name)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_removexattr, 1, dentry, name);\n-\tif (ret == 1)\n-\t\tret = cap_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_removexattr(dentry, name);\n-}\n-\n-int security_inode_need_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_need_killpriv, 0, dentry);\n-}\n-\n-int security_inode_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_killpriv, 0, dentry);\n-}\n-\n-int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {\n-\t\trc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {\n-\t\trc = hp->hook.inode_setsecurity(inode, name, value, size,\n-\t\t\t\t\t\t\t\tflags);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listsecurity, 0, inode, buffer, buffer_size);\n-}\n-EXPORT_SYMBOL(security_inode_listsecurity);\n-\n-void security_inode_getsecid(struct inode *inode, u32 *secid)\n-{\n-\tcall_void_hook(inode_getsecid, inode, secid);\n-}\n-\n-int security_inode_copy_up(struct dentry *src, struct cred **new)\n-{\n-\treturn call_int_hook(inode_copy_up, 0, src, new);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up);\n-\n-int security_inode_copy_up_xattr(const char *name)\n-{\n-\treturn call_int_hook(inode_copy_up_xattr, -EOPNOTSUPP, name);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up_xattr);\n-\n-int security_kernfs_init_security(struct kernfs_node *kn_dir,\n-\t\t\t\t  struct kernfs_node *kn)\n-{\n-\treturn call_int_hook(kernfs_init_security, 0, kn_dir, kn);\n-}\n-\n-int security_file_permission(struct file *file, int mask)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_permission, 0, file, mask);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, mask);\n-}\n-\n-int security_file_alloc(struct file *file)\n-{\n-\tint rc = lsm_file_alloc(file);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(file_alloc_security, 0, file);\n-\tif (unlikely(rc))\n-\t\tsecurity_file_free(file);\n-\treturn rc;\n-}\n-\n-void security_file_free(struct file *file)\n-{\n-\tvoid *blob;\n-\n-\tcall_void_hook(file_free_security, file);\n-\n-\tblob = file->f_security;\n-\tif (blob) {\n-\t\tfile->f_security = NULL;\n-\t\tkmem_cache_free(lsm_file_cache, blob);\n-\t}\n-}\n-\n-int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_ioctl, 0, file, cmd, arg);\n-}\n-\n-static inline unsigned long mmap_prot(struct file *file, unsigned long prot)\n-{\n-\t/*\n-\t * Does we have PROT_READ and does the application expect\n-\t * it to imply PROT_EXEC?  If not, nothing to talk about...\n-\t */\n-\tif ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)\n-\t\treturn prot;\n-\tif (!(current->personality & READ_IMPLIES_EXEC))\n-\t\treturn prot;\n-\t/*\n-\t * if that's an anonymous mapping, let it.\n-\t */\n-\tif (!file)\n-\t\treturn prot | PROT_EXEC;\n-\t/*\n-\t * ditto if it's not on noexec mount, except that on !MMU we need\n-\t * NOMMU_MAP_EXEC (== VM_MAYEXEC) in this case\n-\t */\n-\tif (!path_noexec(&file->f_path)) {\n-#ifndef CONFIG_MMU\n-\t\tif (file->f_op->mmap_capabilities) {\n-\t\t\tunsigned caps = file->f_op->mmap_capabilities(file);\n-\t\t\tif (!(caps & NOMMU_MAP_EXEC))\n-\t\t\t\treturn prot;\n-\t\t}\n-#endif\n-\t\treturn prot | PROT_EXEC;\n-\t}\n-\t/* anything on noexec mount won't get PROT_EXEC */\n-\treturn prot;\n-}\n-\n-int security_mmap_file(struct file *file, unsigned long prot,\n-\t\t\tunsigned long flags)\n-{\n-\tint ret;\n-\tret = call_int_hook(mmap_file, 0, file, prot,\n-\t\t\t\t\tmmap_prot(file, prot), flags);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_file_mmap(file, prot);\n-}\n-\n-int security_mmap_addr(unsigned long addr)\n-{\n-\treturn call_int_hook(mmap_addr, 0, addr);\n-}\n-\n-int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\n-\t\t\t    unsigned long prot)\n-{\n-\treturn call_int_hook(file_mprotect, 0, vma, reqprot, prot);\n-}\n-\n-int security_file_lock(struct file *file, unsigned int cmd)\n-{\n-\treturn call_int_hook(file_lock, 0, file, cmd);\n-}\n-\n-int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_fcntl, 0, file, cmd, arg);\n-}\n-\n-void security_file_set_fowner(struct file *file)\n-{\n-\tcall_void_hook(file_set_fowner, file);\n-}\n-\n-int security_file_send_sigiotask(struct task_struct *tsk,\n-\t\t\t\t  struct fown_struct *fown, int sig)\n-{\n-\treturn call_int_hook(file_send_sigiotask, 0, tsk, fown, sig);\n-}\n-\n-int security_file_receive(struct file *file)\n-{\n-\treturn call_int_hook(file_receive, 0, file);\n-}\n-\n-int security_file_open(struct file *file)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_open, 0, file);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, MAY_OPEN);\n-}\n-\n-int security_task_alloc(struct task_struct *task, unsigned long clone_flags)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(task_alloc, 0, task, clone_flags);\n-\tif (unlikely(rc))\n-\t\tsecurity_task_free(task);\n-\treturn rc;\n-}\n-\n-void security_task_free(struct task_struct *task)\n-{\n-\tcall_void_hook(task_free, task);\n-\n-\tkfree(task->security);\n-\ttask->security = NULL;\n-}\n-\n-int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(cred, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_alloc_blank, 0, cred, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(cred);\n-\treturn rc;\n-}\n-\n-void security_cred_free(struct cred *cred)\n-{\n-\t/*\n-\t * There is a failure case in prepare_creds() that\n-\t * may result in a call here with ->security being NULL.\n-\t */\n-\tif (unlikely(cred->security == NULL))\n-\t\treturn;\n-\n-\tcall_void_hook(cred_free, cred);\n-\n-\tkfree(cred->security);\n-\tcred->security = NULL;\n-}\n-\n-int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(new, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_prepare, 0, new, old, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(new);\n-\treturn rc;\n-}\n-\n-void security_transfer_creds(struct cred *new, const struct cred *old)\n-{\n-\tcall_void_hook(cred_transfer, new, old);\n-}\n-\n-void security_cred_getsecid(const struct cred *c, u32 *secid)\n-{\n-\t*secid = 0;\n-\tcall_void_hook(cred_getsecid, c, secid);\n-}\n-EXPORT_SYMBOL(security_cred_getsecid);\n-\n-int security_kernel_act_as(struct cred *new, u32 secid)\n-{\n-\treturn call_int_hook(kernel_act_as, 0, new, secid);\n-}\n-\n-int security_kernel_create_files_as(struct cred *new, struct inode *inode)\n-{\n-\treturn call_int_hook(kernel_create_files_as, 0, new, inode);\n-}\n-\n-int security_kernel_module_request(char *kmod_name)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(kernel_module_request, 0, kmod_name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn integrity_kernel_module_request(kmod_name);\n+#include <stdio.h>\n+void main() {",
    "repo_full_name": "torvalds/linux",
    "discussion_comments": [
      {
        "comment_id": "314130480",
        "repo_full_name": "torvalds/linux",
        "pr_number": 710,
        "pr_file": "security/security.c",
        "discussion_id": "314130480",
        "commented_code": "@@ -1,2360 +1,6 @@\n-// SPDX-License-Identifier: GPL-2.0-or-later\n-/*\n- * Security plug functions\n- *\n- * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>\n- * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>\n- * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>\n- * Copyright (C) 2016 Mellanox Technologies\n- */\n-\n-#define pr_fmt(fmt) \"LSM: \" fmt\n-\n-#include <linux/bpf.h>\n-#include <linux/capability.h>\n-#include <linux/dcache.h>\n-#include <linux/export.h>\n-#include <linux/init.h>\n-#include <linux/kernel.h>\n-#include <linux/lsm_hooks.h>\n-#include <linux/integrity.h>\n-#include <linux/ima.h>\n-#include <linux/evm.h>\n-#include <linux/fsnotify.h>\n-#include <linux/mman.h>\n-#include <linux/mount.h>\n-#include <linux/personality.h>\n-#include <linux/backing-dev.h>\n-#include <linux/string.h>\n-#include <linux/msg.h>\n-#include <net/flow.h>\n-\n-#define MAX_LSM_EVM_XATTR\t2\n-\n-/* How many LSMs were built into the kernel? */\n-#define LSM_COUNT (__end_lsm_info - __start_lsm_info)\n-\n-struct security_hook_heads security_hook_heads __lsm_ro_after_init;\n-static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);\n-\n-static struct kmem_cache *lsm_file_cache;\n-static struct kmem_cache *lsm_inode_cache;\n-\n-char *lsm_names;\n-static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;\n-\n-/* Boot-time LSM user choice */\n-static __initdata const char *chosen_lsm_order;\n-static __initdata const char *chosen_major_lsm;\n-\n-static __initconst const char * const builtin_lsm_order = CONFIG_LSM;\n-\n-/* Ordered list of LSMs to initialize. */\n-static __initdata struct lsm_info **ordered_lsms;\n-static __initdata struct lsm_info *exclusive;\n-\n-static __initdata bool debug;\n-#define init_debug(...)\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tif (debug)\t\t\t\t\t\\\n-\t\t\tpr_info(__VA_ARGS__);\t\t\t\\\n-\t} while (0)\n-\n-static bool __init is_enabled(struct lsm_info *lsm)\n-{\n-\tif (!lsm->enabled)\n-\t\treturn false;\n-\n-\treturn *lsm->enabled;\n-}\n-\n-/* Mark an LSM's enabled flag. */\n-static int lsm_enabled_true __initdata = 1;\n-static int lsm_enabled_false __initdata = 0;\n-static void __init set_enabled(struct lsm_info *lsm, bool enabled)\n-{\n-\t/*\n-\t * When an LSM hasn't configured an enable variable, we can use\n-\t * a hard-coded location for storing the default enabled state.\n-\t */\n-\tif (!lsm->enabled) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t\telse\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_true) {\n-\t\tif (!enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_false) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t} else {\n-\t\t*lsm->enabled = enabled;\n-\t}\n-}\n-\n-/* Is an LSM already listed in the ordered LSMs list? */\n-static bool __init exists_ordered_lsm(struct lsm_info *lsm)\n-{\n-\tstruct lsm_info **check;\n-\n-\tfor (check = ordered_lsms; *check; check++)\n-\t\tif (*check == lsm)\n-\t\t\treturn true;\n-\n-\treturn false;\n-}\n-\n-/* Append an LSM to the list of ordered LSMs to initialize. */\n-static int last_lsm __initdata;\n-static void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)\n-{\n-\t/* Ignore duplicate selections. */\n-\tif (exists_ordered_lsm(lsm))\n-\t\treturn;\n-\n-\tif (WARN(last_lsm == LSM_COUNT, \"%s: out of LSM slots!?\\n\", from))\n-\t\treturn;\n-\n-\t/* Enable this LSM, if it is not already set. */\n-\tif (!lsm->enabled)\n-\t\tlsm->enabled = &lsm_enabled_true;\n-\tordered_lsms[last_lsm++] = lsm;\n-\n-\tinit_debug(\"%s ordering: %s (%sabled)\\n\", from, lsm->name,\n-\t\t   is_enabled(lsm) ? \"en\" : \"dis\");\n-}\n-\n-/* Is an LSM allowed to be initialized? */\n-static bool __init lsm_allowed(struct lsm_info *lsm)\n-{\n-\t/* Skip if the LSM is disabled. */\n-\tif (!is_enabled(lsm))\n-\t\treturn false;\n-\n-\t/* Not allowed if another exclusive LSM already initialized. */\n-\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && exclusive) {\n-\t\tinit_debug(\"exclusive disabled: %s\\n\", lsm->name);\n-\t\treturn false;\n-\t}\n-\n-\treturn true;\n-}\n-\n-static void __init lsm_set_blob_size(int *need, int *lbs)\n-{\n-\tint offset;\n-\n-\tif (*need > 0) {\n-\t\toffset = *lbs;\n-\t\t*lbs += *need;\n-\t\t*need = offset;\n-\t}\n-}\n-\n-static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)\n-{\n-\tif (!needed)\n-\t\treturn;\n-\n-\tlsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);\n-\tlsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);\n-\t/*\n-\t * The inode blob gets an rcu_head in addition to\n-\t * what the modules might need.\n-\t */\n-\tif (needed->lbs_inode && blob_sizes.lbs_inode == 0)\n-\t\tblob_sizes.lbs_inode = sizeof(struct rcu_head);\n-\tlsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);\n-\tlsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);\n-\tlsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);\n-\tlsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);\n-}\n-\n-/* Prepare LSM for initialization. */\n-static void __init prepare_lsm(struct lsm_info *lsm)\n-{\n-\tint enabled = lsm_allowed(lsm);\n-\n-\t/* Record enablement (to handle any following exclusive LSMs). */\n-\tset_enabled(lsm, enabled);\n-\n-\t/* If enabled, do pre-initialization work. */\n-\tif (enabled) {\n-\t\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {\n-\t\t\texclusive = lsm;\n-\t\t\tinit_debug(\"exclusive chosen: %s\\n\", lsm->name);\n-\t\t}\n-\n-\t\tlsm_set_blob_sizes(lsm->blobs);\n-\t}\n-}\n-\n-/* Initialize a given LSM, if it is enabled. */\n-static void __init initialize_lsm(struct lsm_info *lsm)\n-{\n-\tif (is_enabled(lsm)) {\n-\t\tint ret;\n-\n-\t\tinit_debug(\"initializing %s\\n\", lsm->name);\n-\t\tret = lsm->init();\n-\t\tWARN(ret, \"%s failed to initialize: %d\\n\", lsm->name, ret);\n-\t}\n-}\n-\n-/* Populate ordered LSMs list from comma-separated LSM name list. */\n-static void __init ordered_lsm_parse(const char *order, const char *origin)\n-{\n-\tstruct lsm_info *lsm;\n-\tchar *sep, *name, *next;\n-\n-\t/* LSM_ORDER_FIRST is always first. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (lsm->order == LSM_ORDER_FIRST)\n-\t\t\tappend_ordered_lsm(lsm, \"first\");\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tstruct lsm_info *major;\n-\n-\t\t/*\n-\t\t * To match the original \"security=\" behavior, this\n-\t\t * explicitly does NOT fallback to another Legacy Major\n-\t\t * if the selected one was separately disabled: disable\n-\t\t * all non-matching Legacy Major LSMs.\n-\t\t */\n-\t\tfor (major = __start_lsm_info; major < __end_lsm_info;\n-\t\t     major++) {\n-\t\t\tif ((major->flags & LSM_FLAG_LEGACY_MAJOR) &&\n-\t\t\t    strcmp(major->name, chosen_major_lsm) != 0) {\n-\t\t\t\tset_enabled(major, false);\n-\t\t\t\tinit_debug(\"security=%s disabled: %s\\n\",\n-\t\t\t\t\t   chosen_major_lsm, major->name);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tsep = kstrdup(order, GFP_KERNEL);\n-\tnext = sep;\n-\t/* Walk the list, looking for matching LSMs. */\n-\twhile ((name = strsep(&next, \",\")) != NULL) {\n-\t\tbool found = false;\n-\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (lsm->order == LSM_ORDER_MUTABLE &&\n-\t\t\t    strcmp(lsm->name, name) == 0) {\n-\t\t\t\tappend_ordered_lsm(lsm, origin);\n-\t\t\t\tfound = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!found)\n-\t\t\tinit_debug(\"%s ignored: %s\\n\", origin, name);\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (exists_ordered_lsm(lsm))\n-\t\t\t\tcontinue;\n-\t\t\tif (strcmp(lsm->name, chosen_major_lsm) == 0)\n-\t\t\t\tappend_ordered_lsm(lsm, \"security=\");\n-\t\t}\n-\t}\n-\n-\t/* Disable all LSMs not in the ordered list. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (exists_ordered_lsm(lsm))\n-\t\t\tcontinue;\n-\t\tset_enabled(lsm, false);\n-\t\tinit_debug(\"%s disabled: %s\\n\", origin, lsm->name);\n-\t}\n-\n-\tkfree(sep);\n-}\n-\n-static void __init lsm_early_cred(struct cred *cred);\n-static void __init lsm_early_task(struct task_struct *task);\n-\n-static void __init ordered_lsm_init(void)\n-{\n-\tstruct lsm_info **lsm;\n-\n-\tordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),\n-\t\t\t\tGFP_KERNEL);\n-\n-\tif (chosen_lsm_order) {\n-\t\tif (chosen_major_lsm) {\n-\t\t\tpr_info(\"security= is ignored because it is superseded by lsm=\\n\");\n-\t\t\tchosen_major_lsm = NULL;\n-\t\t}\n-\t\tordered_lsm_parse(chosen_lsm_order, \"cmdline\");\n-\t} else\n-\t\tordered_lsm_parse(builtin_lsm_order, \"builtin\");\n-\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tprepare_lsm(*lsm);\n-\n-\tinit_debug(\"cred blob size     = %d\\n\", blob_sizes.lbs_cred);\n-\tinit_debug(\"file blob size     = %d\\n\", blob_sizes.lbs_file);\n-\tinit_debug(\"inode blob size    = %d\\n\", blob_sizes.lbs_inode);\n-\tinit_debug(\"ipc blob size      = %d\\n\", blob_sizes.lbs_ipc);\n-\tinit_debug(\"msg_msg blob size  = %d\\n\", blob_sizes.lbs_msg_msg);\n-\tinit_debug(\"task blob size     = %d\\n\", blob_sizes.lbs_task);\n-\n-\t/*\n-\t * Create any kmem_caches needed for blobs\n-\t */\n-\tif (blob_sizes.lbs_file)\n-\t\tlsm_file_cache = kmem_cache_create(\"lsm_file_cache\",\n-\t\t\t\t\t\t   blob_sizes.lbs_file, 0,\n-\t\t\t\t\t\t   SLAB_PANIC, NULL);\n-\tif (blob_sizes.lbs_inode)\n-\t\tlsm_inode_cache = kmem_cache_create(\"lsm_inode_cache\",\n-\t\t\t\t\t\t    blob_sizes.lbs_inode, 0,\n-\t\t\t\t\t\t    SLAB_PANIC, NULL);\n-\n-\tlsm_early_cred((struct cred *) current->cred);\n-\tlsm_early_task(current);\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tinitialize_lsm(*lsm);\n-\n-\tkfree(ordered_lsms);\n-}\n-\n-/**\n- * security_init - initializes the security framework\n- *\n- * This should be called early in the kernel initialization sequence.\n- */\n-int __init security_init(void)\n-{\n-\tint i;\n-\tstruct hlist_head *list = (struct hlist_head *) &security_hook_heads;\n-\n-\tpr_info(\"Security Framework initializing\\n\");\n-\n-\tfor (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);\n-\t     i++)\n-\t\tINIT_HLIST_HEAD(&list[i]);\n-\n-\t/* Load LSMs in specified order. */\n-\tordered_lsm_init();\n-\n-\treturn 0;\n-}\n-\n-/* Save user chosen LSM */\n-static int __init choose_major_lsm(char *str)\n-{\n-\tchosen_major_lsm = str;\n-\treturn 1;\n-}\n-__setup(\"security=\", choose_major_lsm);\n-\n-/* Explicitly choose LSM initialization order. */\n-static int __init choose_lsm_order(char *str)\n-{\n-\tchosen_lsm_order = str;\n-\treturn 1;\n-}\n-__setup(\"lsm=\", choose_lsm_order);\n-\n-/* Enable LSM order debugging. */\n-static int __init enable_debug(char *str)\n-{\n-\tdebug = true;\n-\treturn 1;\n-}\n-__setup(\"lsm.debug\", enable_debug);\n-\n-static bool match_last_lsm(const char *list, const char *lsm)\n-{\n-\tconst char *last;\n-\n-\tif (WARN_ON(!list || !lsm))\n-\t\treturn false;\n-\tlast = strrchr(list, ',');\n-\tif (last)\n-\t\t/* Pass the comma, strcmp() will check for '\\0' */\n-\t\tlast++;\n-\telse\n-\t\tlast = list;\n-\treturn !strcmp(last, lsm);\n-}\n-\n-static int lsm_append(char *new, char **result)\n-{\n-\tchar *cp;\n-\n-\tif (*result == NULL) {\n-\t\t*result = kstrdup(new, GFP_KERNEL);\n-\t\tif (*result == NULL)\n-\t\t\treturn -ENOMEM;\n-\t} else {\n-\t\t/* Check if it is the last registered name */\n-\t\tif (match_last_lsm(*result, new))\n-\t\t\treturn 0;\n-\t\tcp = kasprintf(GFP_KERNEL, \"%s,%s\", *result, new);\n-\t\tif (cp == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\tkfree(*result);\n-\t\t*result = cp;\n-\t}\n-\treturn 0;\n-}\n-\n-/**\n- * security_add_hooks - Add a modules hooks to the hook lists.\n- * @hooks: the hooks to add\n- * @count: the number of hooks to add\n- * @lsm: the name of the security module\n- *\n- * Each LSM has to register its hooks with the infrastructure.\n- */\n-void __init security_add_hooks(struct security_hook_list *hooks, int count,\n-\t\t\t\tchar *lsm)\n-{\n-\tint i;\n-\n-\tfor (i = 0; i < count; i++) {\n-\t\thooks[i].lsm = lsm;\n-\t\thlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n-\t}\n-\tif (lsm_append(lsm, &lsm_names) < 0)\n-\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n-}\n-\n-int call_blocking_lsm_notifier(enum lsm_event event, void *data)\n-{\n-\treturn blocking_notifier_call_chain(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t    event, data);\n-}\n-EXPORT_SYMBOL(call_blocking_lsm_notifier);\n-\n-int register_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_register(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\tnb);\n-}\n-EXPORT_SYMBOL(register_blocking_lsm_notifier);\n-\n-int unregister_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\t  nb);\n-}\n-EXPORT_SYMBOL(unregister_blocking_lsm_notifier);\n-\n-/**\n- * lsm_cred_alloc - allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- * @gfp: allocation type\n- *\n- * Allocate the cred blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)\n-{\n-\tif (blob_sizes.lbs_cred == 0) {\n-\t\tcred->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tcred->security = kzalloc(blob_sizes.lbs_cred, gfp);\n-\tif (cred->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_cred - during initialization allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- *\n- * Allocate the cred blob for all the modules\n- */\n-static void __init lsm_early_cred(struct cred *cred)\n-{\n-\tint rc = lsm_cred_alloc(cred, GFP_KERNEL);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early cred alloc failed.\\n\", __func__);\n-}\n-\n-/**\n- * lsm_file_alloc - allocate a composite file blob\n- * @file: the file that needs a blob\n- *\n- * Allocate the file blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_file_alloc(struct file *file)\n-{\n-\tif (!lsm_file_cache) {\n-\t\tfile->f_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tfile->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);\n-\tif (file->f_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_inode_alloc - allocate a composite inode blob\n- * @inode: the inode that needs a blob\n- *\n- * Allocate the inode blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-int lsm_inode_alloc(struct inode *inode)\n-{\n-\tif (!lsm_inode_cache) {\n-\t\tinode->i_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tinode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);\n-\tif (inode->i_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_task_alloc - allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_task_alloc(struct task_struct *task)\n-{\n-\tif (blob_sizes.lbs_task == 0) {\n-\t\ttask->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\ttask->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);\n-\tif (task->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_ipc_alloc - allocate a composite ipc blob\n- * @kip: the ipc that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_ipc_alloc(struct kern_ipc_perm *kip)\n-{\n-\tif (blob_sizes.lbs_ipc == 0) {\n-\t\tkip->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tkip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);\n-\tif (kip->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_msg_msg_alloc - allocate a composite msg_msg blob\n- * @mp: the msg_msg that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_msg_msg_alloc(struct msg_msg *mp)\n-{\n-\tif (blob_sizes.lbs_msg_msg == 0) {\n-\t\tmp->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tmp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);\n-\tif (mp->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_task - during initialization allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- */\n-static void __init lsm_early_task(struct task_struct *task)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early task alloc failed.\\n\", __func__);\n-}\n-\n-/*\n- * Hook list operation macros.\n- *\n- * call_void_hook:\n- *\tThis is a hook that does not return a value.\n- *\n- * call_int_hook:\n- *\tThis is a hook that returns a value.\n- */\n-\n-#define call_void_hook(FUNC, ...)\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) \\\n-\t\t\tP->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t} while (0)\n-\n-#define call_int_hook(FUNC, IRC, ...) ({\t\t\t\\\n-\tint RC = IRC;\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \\\n-\t\t\tRC = P->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t\t\tif (RC != 0)\t\t\t\t\\\n-\t\t\t\tbreak;\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\\\n-\t} while (0);\t\t\t\t\t\t\\\n-\tRC;\t\t\t\t\t\t\t\\\n-})\n-\n-/* Security operations */\n-\n-int security_binder_set_context_mgr(struct task_struct *mgr)\n-{\n-\treturn call_int_hook(binder_set_context_mgr, 0, mgr);\n-}\n-\n-int security_binder_transaction(struct task_struct *from,\n-\t\t\t\tstruct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transaction, 0, from, to);\n-}\n-\n-int security_binder_transfer_binder(struct task_struct *from,\n-\t\t\t\t    struct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transfer_binder, 0, from, to);\n-}\n-\n-int security_binder_transfer_file(struct task_struct *from,\n-\t\t\t\t  struct task_struct *to, struct file *file)\n-{\n-\treturn call_int_hook(binder_transfer_file, 0, from, to, file);\n-}\n-\n-int security_ptrace_access_check(struct task_struct *child, unsigned int mode)\n-{\n-\treturn call_int_hook(ptrace_access_check, 0, child, mode);\n-}\n-\n-int security_ptrace_traceme(struct task_struct *parent)\n-{\n-\treturn call_int_hook(ptrace_traceme, 0, parent);\n-}\n-\n-int security_capget(struct task_struct *target,\n-\t\t     kernel_cap_t *effective,\n-\t\t     kernel_cap_t *inheritable,\n-\t\t     kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capget, 0, target,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capset(struct cred *new, const struct cred *old,\n-\t\t    const kernel_cap_t *effective,\n-\t\t    const kernel_cap_t *inheritable,\n-\t\t    const kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capset, 0, new, old,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capable(const struct cred *cred,\n-\t\t     struct user_namespace *ns,\n-\t\t     int cap,\n-\t\t     unsigned int opts)\n-{\n-\treturn call_int_hook(capable, 0, cred, ns, cap, opts);\n-}\n-\n-int security_quotactl(int cmds, int type, int id, struct super_block *sb)\n-{\n-\treturn call_int_hook(quotactl, 0, cmds, type, id, sb);\n-}\n-\n-int security_quota_on(struct dentry *dentry)\n-{\n-\treturn call_int_hook(quota_on, 0, dentry);\n-}\n-\n-int security_syslog(int type)\n-{\n-\treturn call_int_hook(syslog, 0, type);\n-}\n-\n-int security_settime64(const struct timespec64 *ts, const struct timezone *tz)\n-{\n-\treturn call_int_hook(settime, 0, ts, tz);\n-}\n-\n-int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)\n-{\n-\tstruct security_hook_list *hp;\n-\tint cap_sys_admin = 1;\n-\tint rc;\n-\n-\t/*\n-\t * The module will respond with a positive value if\n-\t * it thinks the __vm_enough_memory() call should be\n-\t * made with the cap_sys_admin set. If all of the modules\n-\t * agree that it should be set it will. If any module\n-\t * thinks it should not be set it won't.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {\n-\t\trc = hp->hook.vm_enough_memory(mm, pages);\n-\t\tif (rc <= 0) {\n-\t\t\tcap_sys_admin = 0;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\treturn __vm_enough_memory(mm, pages, cap_sys_admin);\n-}\n-\n-int security_bprm_set_creds(struct linux_binprm *bprm)\n-{\n-\treturn call_int_hook(bprm_set_creds, 0, bprm);\n-}\n-\n-int security_bprm_check(struct linux_binprm *bprm)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(bprm_check_security, 0, bprm);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_bprm_check(bprm);\n-}\n-\n-void security_bprm_committing_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committing_creds, bprm);\n-}\n-\n-void security_bprm_committed_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committed_creds, bprm);\n-}\n-\n-int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n-{\n-\treturn call_int_hook(fs_context_dup, 0, fc, src_fc);\n-}\n-\n-int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)\n-{\n-\treturn call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);\n-}\n-\n-int security_sb_alloc(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_alloc_security, 0, sb);\n-}\n-\n-void security_sb_free(struct super_block *sb)\n-{\n-\tcall_void_hook(sb_free_security, sb);\n-}\n-\n-void security_free_mnt_opts(void **mnt_opts)\n-{\n-\tif (!*mnt_opts)\n-\t\treturn;\n-\tcall_void_hook(sb_free_mnt_opts, *mnt_opts);\n-\t*mnt_opts = NULL;\n-}\n-EXPORT_SYMBOL(security_free_mnt_opts);\n-\n-int security_sb_eat_lsm_opts(char *options, void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_eat_lsm_opts, 0, options, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_eat_lsm_opts);\n-\n-int security_sb_remount(struct super_block *sb,\n-\t\t\tvoid *mnt_opts)\n-{\n-\treturn call_int_hook(sb_remount, 0, sb, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_remount);\n-\n-int security_sb_kern_mount(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_kern_mount, 0, sb);\n-}\n-\n-int security_sb_show_options(struct seq_file *m, struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_show_options, 0, m, sb);\n-}\n-\n-int security_sb_statfs(struct dentry *dentry)\n-{\n-\treturn call_int_hook(sb_statfs, 0, dentry);\n-}\n-\n-int security_sb_mount(const char *dev_name, const struct path *path,\n-                       const char *type, unsigned long flags, void *data)\n-{\n-\treturn call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);\n-}\n-\n-int security_sb_umount(struct vfsmount *mnt, int flags)\n-{\n-\treturn call_int_hook(sb_umount, 0, mnt, flags);\n-}\n-\n-int security_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n-{\n-\treturn call_int_hook(sb_pivotroot, 0, old_path, new_path);\n-}\n-\n-int security_sb_set_mnt_opts(struct super_block *sb,\n-\t\t\t\tvoid *mnt_opts,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_set_mnt_opts,\n-\t\t\t\tmnt_opts ? -EOPNOTSUPP : 0, sb,\n-\t\t\t\tmnt_opts, kern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_set_mnt_opts);\n-\n-int security_sb_clone_mnt_opts(const struct super_block *oldsb,\n-\t\t\t\tstruct super_block *newsb,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb,\n-\t\t\t\tkern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_clone_mnt_opts);\n-\n-int security_add_mnt_opt(const char *option, const char *val, int len,\n-\t\t\t void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_add_mnt_opt, -EINVAL,\n-\t\t\t\t\toption, val, len, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_add_mnt_opt);\n-\n-int security_move_mount(const struct path *from_path, const struct path *to_path)\n-{\n-\treturn call_int_hook(move_mount, 0, from_path, to_path);\n-}\n-\n-int security_inode_alloc(struct inode *inode)\n-{\n-\tint rc = lsm_inode_alloc(inode);\n-\n-\tif (unlikely(rc))\n-\t\treturn rc;\n-\trc = call_int_hook(inode_alloc_security, 0, inode);\n-\tif (unlikely(rc))\n-\t\tsecurity_inode_free(inode);\n-\treturn rc;\n-}\n-\n-static void inode_free_by_rcu(struct rcu_head *head)\n-{\n-\t/*\n-\t * The rcu head is at the start of the inode blob\n-\t */\n-\tkmem_cache_free(lsm_inode_cache, head);\n-}\n-\n-void security_inode_free(struct inode *inode)\n-{\n-\tintegrity_inode_free(inode);\n-\tcall_void_hook(inode_free_security, inode);\n-\t/*\n-\t * The inode may still be referenced in a path walk and\n-\t * a call to security_inode_permission() can be made\n-\t * after inode_free_security() is called. Ideally, the VFS\n-\t * wouldn't do this, but fixing that is a much harder\n-\t * job. For now, simply free the i_security via RCU, and\n-\t * leave the current inode->i_security pointer intact.\n-\t * The inode will be freed after the RCU grace period too.\n-\t */\n-\tif (inode->i_security)\n-\t\tcall_rcu((struct rcu_head *)inode->i_security,\n-\t\t\t\tinode_free_by_rcu);\n-}\n-\n-int security_dentry_init_security(struct dentry *dentry, int mode,\n-\t\t\t\t\tconst struct qstr *name, void **ctx,\n-\t\t\t\t\tu32 *ctxlen)\n-{\n-\treturn call_int_hook(dentry_init_security, -EOPNOTSUPP, dentry, mode,\n-\t\t\t\tname, ctx, ctxlen);\n-}\n-EXPORT_SYMBOL(security_dentry_init_security);\n-\n-int security_dentry_create_files_as(struct dentry *dentry, int mode,\n-\t\t\t\t    struct qstr *name,\n-\t\t\t\t    const struct cred *old, struct cred *new)\n-{\n-\treturn call_int_hook(dentry_create_files_as, 0, dentry, mode,\n-\t\t\t\tname, old, new);\n-}\n-EXPORT_SYMBOL(security_dentry_create_files_as);\n-\n-int security_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t const struct qstr *qstr,\n-\t\t\t\t const initxattrs initxattrs, void *fs_data)\n-{\n-\tstruct xattr new_xattrs[MAX_LSM_EVM_XATTR + 1];\n-\tstruct xattr *lsm_xattr, *evm_xattr, *xattr;\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\n-\tif (!initxattrs)\n-\t\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode,\n-\t\t\t\t     dir, qstr, NULL, NULL, NULL);\n-\tmemset(new_xattrs, 0, sizeof(new_xattrs));\n-\tlsm_xattr = new_xattrs;\n-\tret = call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir, qstr,\n-\t\t\t\t\t\t&lsm_xattr->name,\n-\t\t\t\t\t\t&lsm_xattr->value,\n-\t\t\t\t\t\t&lsm_xattr->value_len);\n-\tif (ret)\n-\t\tgoto out;\n-\n-\tevm_xattr = lsm_xattr + 1;\n-\tret = evm_inode_init_security(inode, lsm_xattr, evm_xattr);\n-\tif (ret)\n-\t\tgoto out;\n-\tret = initxattrs(inode, new_xattrs, fs_data);\n-out:\n-\tfor (xattr = new_xattrs; xattr->value != NULL; xattr++)\n-\t\tkfree(xattr->value);\n-\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n-}\n-EXPORT_SYMBOL(security_inode_init_security);\n-\n-int security_old_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t     const struct qstr *qstr, const char **name,\n-\t\t\t\t     void **value, size_t *len)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir,\n-\t\t\t     qstr, name, value, len);\n-}\n-EXPORT_SYMBOL(security_old_inode_init_security);\n-\n-#ifdef CONFIG_SECURITY_PATH\n-int security_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode,\n-\t\t\tunsigned int dev)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mknod, 0, dir, dentry, mode, dev);\n-}\n-EXPORT_SYMBOL(security_path_mknod);\n-\n-int security_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL(security_path_mkdir);\n-\n-int security_path_rmdir(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_rmdir, 0, dir, dentry);\n-}\n-\n-int security_path_unlink(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_unlink, 0, dir, dentry);\n-}\n-EXPORT_SYMBOL(security_path_unlink);\n-\n-int security_path_symlink(const struct path *dir, struct dentry *dentry,\n-\t\t\t  const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_path_link(struct dentry *old_dentry, const struct path *new_dir,\n-\t\t       struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);\n-}\n-\n-int security_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n-\t\t\t const struct path *new_dir, struct dentry *new_dentry,\n-\t\t\t unsigned int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-\t\t     (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(path_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\told_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(path_rename, 0, old_dir, old_dentry, new_dir,\n-\t\t\t\tnew_dentry);\n-}\n-EXPORT_SYMBOL(security_path_rename);\n-\n-int security_path_truncate(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_truncate, 0, path);\n-}\n-\n-int security_path_chmod(const struct path *path, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chmod, 0, path, mode);\n-}\n-\n-int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chown, 0, path, uid, gid);\n-}\n-\n-int security_path_chroot(const struct path *path)\n-{\n-\treturn call_int_hook(path_chroot, 0, path);\n-}\n-#endif\n-\n-int security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_create, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_create);\n-\n-int security_inode_link(struct dentry *old_dentry, struct inode *dir,\n-\t\t\t struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_link, 0, old_dentry, dir, new_dentry);\n-}\n-\n-int security_inode_unlink(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_unlink, 0, dir, dentry);\n-}\n-\n-int security_inode_symlink(struct inode *dir, struct dentry *dentry,\n-\t\t\t    const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_mkdir);\n-\n-int security_inode_rmdir(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_rmdir, 0, dir, dentry);\n-}\n-\n-int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mknod, 0, dir, dentry, mode, dev);\n-}\n-\n-int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,\n-\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n-\t\t\t   unsigned int flags)\n-{\n-        if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-            (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(inode_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\t\t     old_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(inode_rename, 0, old_dir, old_dentry,\n-\t\t\t\t\t   new_dir, new_dentry);\n-}\n-\n-int security_inode_readlink(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_readlink, 0, dentry);\n-}\n-\n-int security_inode_follow_link(struct dentry *dentry, struct inode *inode,\n-\t\t\t       bool rcu)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_follow_link, 0, dentry, inode, rcu);\n-}\n-\n-int security_inode_permission(struct inode *inode, int mask)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_permission, 0, inode, mask);\n-}\n-\n-int security_inode_setattr(struct dentry *dentry, struct iattr *attr)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\tret = call_int_hook(inode_setattr, 0, dentry, attr);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setattr(dentry, attr);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_setattr);\n-\n-int security_inode_getattr(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getattr, 0, path);\n-}\n-\n-int security_inode_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t    const void *value, size_t size, int flags)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_setxattr, 1, dentry, name, value, size,\n-\t\t\t\tflags);\n-\n-\tif (ret == 1)\n-\t\tret = cap_inode_setxattr(dentry, name, value, size, flags);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_setxattr(dentry, name, value, size);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setxattr(dentry, name, value, size);\n-}\n-\n-void security_inode_post_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t\t  const void *value, size_t size, int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn;\n-\tcall_void_hook(inode_post_setxattr, dentry, name, value, size, flags);\n-\tevm_inode_post_setxattr(dentry, name, value, size);\n-}\n-\n-int security_inode_getxattr(struct dentry *dentry, const char *name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getxattr, 0, dentry, name);\n-}\n-\n-int security_inode_listxattr(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listxattr, 0, dentry);\n-}\n-\n-int security_inode_removexattr(struct dentry *dentry, const char *name)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_removexattr, 1, dentry, name);\n-\tif (ret == 1)\n-\t\tret = cap_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_removexattr(dentry, name);\n-}\n-\n-int security_inode_need_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_need_killpriv, 0, dentry);\n-}\n-\n-int security_inode_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_killpriv, 0, dentry);\n-}\n-\n-int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {\n-\t\trc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {\n-\t\trc = hp->hook.inode_setsecurity(inode, name, value, size,\n-\t\t\t\t\t\t\t\tflags);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listsecurity, 0, inode, buffer, buffer_size);\n-}\n-EXPORT_SYMBOL(security_inode_listsecurity);\n-\n-void security_inode_getsecid(struct inode *inode, u32 *secid)\n-{\n-\tcall_void_hook(inode_getsecid, inode, secid);\n-}\n-\n-int security_inode_copy_up(struct dentry *src, struct cred **new)\n-{\n-\treturn call_int_hook(inode_copy_up, 0, src, new);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up);\n-\n-int security_inode_copy_up_xattr(const char *name)\n-{\n-\treturn call_int_hook(inode_copy_up_xattr, -EOPNOTSUPP, name);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up_xattr);\n-\n-int security_kernfs_init_security(struct kernfs_node *kn_dir,\n-\t\t\t\t  struct kernfs_node *kn)\n-{\n-\treturn call_int_hook(kernfs_init_security, 0, kn_dir, kn);\n-}\n-\n-int security_file_permission(struct file *file, int mask)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_permission, 0, file, mask);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, mask);\n-}\n-\n-int security_file_alloc(struct file *file)\n-{\n-\tint rc = lsm_file_alloc(file);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(file_alloc_security, 0, file);\n-\tif (unlikely(rc))\n-\t\tsecurity_file_free(file);\n-\treturn rc;\n-}\n-\n-void security_file_free(struct file *file)\n-{\n-\tvoid *blob;\n-\n-\tcall_void_hook(file_free_security, file);\n-\n-\tblob = file->f_security;\n-\tif (blob) {\n-\t\tfile->f_security = NULL;\n-\t\tkmem_cache_free(lsm_file_cache, blob);\n-\t}\n-}\n-\n-int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_ioctl, 0, file, cmd, arg);\n-}\n-\n-static inline unsigned long mmap_prot(struct file *file, unsigned long prot)\n-{\n-\t/*\n-\t * Does we have PROT_READ and does the application expect\n-\t * it to imply PROT_EXEC?  If not, nothing to talk about...\n-\t */\n-\tif ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)\n-\t\treturn prot;\n-\tif (!(current->personality & READ_IMPLIES_EXEC))\n-\t\treturn prot;\n-\t/*\n-\t * if that's an anonymous mapping, let it.\n-\t */\n-\tif (!file)\n-\t\treturn prot | PROT_EXEC;\n-\t/*\n-\t * ditto if it's not on noexec mount, except that on !MMU we need\n-\t * NOMMU_MAP_EXEC (== VM_MAYEXEC) in this case\n-\t */\n-\tif (!path_noexec(&file->f_path)) {\n-#ifndef CONFIG_MMU\n-\t\tif (file->f_op->mmap_capabilities) {\n-\t\t\tunsigned caps = file->f_op->mmap_capabilities(file);\n-\t\t\tif (!(caps & NOMMU_MAP_EXEC))\n-\t\t\t\treturn prot;\n-\t\t}\n-#endif\n-\t\treturn prot | PROT_EXEC;\n-\t}\n-\t/* anything on noexec mount won't get PROT_EXEC */\n-\treturn prot;\n-}\n-\n-int security_mmap_file(struct file *file, unsigned long prot,\n-\t\t\tunsigned long flags)\n-{\n-\tint ret;\n-\tret = call_int_hook(mmap_file, 0, file, prot,\n-\t\t\t\t\tmmap_prot(file, prot), flags);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_file_mmap(file, prot);\n-}\n-\n-int security_mmap_addr(unsigned long addr)\n-{\n-\treturn call_int_hook(mmap_addr, 0, addr);\n-}\n-\n-int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\n-\t\t\t    unsigned long prot)\n-{\n-\treturn call_int_hook(file_mprotect, 0, vma, reqprot, prot);\n-}\n-\n-int security_file_lock(struct file *file, unsigned int cmd)\n-{\n-\treturn call_int_hook(file_lock, 0, file, cmd);\n-}\n-\n-int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_fcntl, 0, file, cmd, arg);\n-}\n-\n-void security_file_set_fowner(struct file *file)\n-{\n-\tcall_void_hook(file_set_fowner, file);\n-}\n-\n-int security_file_send_sigiotask(struct task_struct *tsk,\n-\t\t\t\t  struct fown_struct *fown, int sig)\n-{\n-\treturn call_int_hook(file_send_sigiotask, 0, tsk, fown, sig);\n-}\n-\n-int security_file_receive(struct file *file)\n-{\n-\treturn call_int_hook(file_receive, 0, file);\n-}\n-\n-int security_file_open(struct file *file)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_open, 0, file);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, MAY_OPEN);\n-}\n-\n-int security_task_alloc(struct task_struct *task, unsigned long clone_flags)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(task_alloc, 0, task, clone_flags);\n-\tif (unlikely(rc))\n-\t\tsecurity_task_free(task);\n-\treturn rc;\n-}\n-\n-void security_task_free(struct task_struct *task)\n-{\n-\tcall_void_hook(task_free, task);\n-\n-\tkfree(task->security);\n-\ttask->security = NULL;\n-}\n-\n-int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(cred, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_alloc_blank, 0, cred, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(cred);\n-\treturn rc;\n-}\n-\n-void security_cred_free(struct cred *cred)\n-{\n-\t/*\n-\t * There is a failure case in prepare_creds() that\n-\t * may result in a call here with ->security being NULL.\n-\t */\n-\tif (unlikely(cred->security == NULL))\n-\t\treturn;\n-\n-\tcall_void_hook(cred_free, cred);\n-\n-\tkfree(cred->security);\n-\tcred->security = NULL;\n-}\n-\n-int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(new, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_prepare, 0, new, old, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(new);\n-\treturn rc;\n-}\n-\n-void security_transfer_creds(struct cred *new, const struct cred *old)\n-{\n-\tcall_void_hook(cred_transfer, new, old);\n-}\n-\n-void security_cred_getsecid(const struct cred *c, u32 *secid)\n-{\n-\t*secid = 0;\n-\tcall_void_hook(cred_getsecid, c, secid);\n-}\n-EXPORT_SYMBOL(security_cred_getsecid);\n-\n-int security_kernel_act_as(struct cred *new, u32 secid)\n-{\n-\treturn call_int_hook(kernel_act_as, 0, new, secid);\n-}\n-\n-int security_kernel_create_files_as(struct cred *new, struct inode *inode)\n-{\n-\treturn call_int_hook(kernel_create_files_as, 0, new, inode);\n-}\n-\n-int security_kernel_module_request(char *kmod_name)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(kernel_module_request, 0, kmod_name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn integrity_kernel_module_request(kmod_name);\n+#include <stdio.h>\n+void main() {",
        "comment_created_at": "2019-08-14T23:51:56+00:00",
        "comment_author": "JL2210",
        "comment_body": "`void main()` is bad practice. Use `int main(void)` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "320056892",
        "repo_full_name": "torvalds/linux",
        "pr_number": 710,
        "pr_file": "security/security.c",
        "discussion_id": "314130480",
        "commented_code": "@@ -1,2360 +1,6 @@\n-// SPDX-License-Identifier: GPL-2.0-or-later\n-/*\n- * Security plug functions\n- *\n- * Copyright (C) 2001 WireX Communications, Inc <chris@wirex.com>\n- * Copyright (C) 2001-2002 Greg Kroah-Hartman <greg@kroah.com>\n- * Copyright (C) 2001 Networks Associates Technology, Inc <ssmalley@nai.com>\n- * Copyright (C) 2016 Mellanox Technologies\n- */\n-\n-#define pr_fmt(fmt) \"LSM: \" fmt\n-\n-#include <linux/bpf.h>\n-#include <linux/capability.h>\n-#include <linux/dcache.h>\n-#include <linux/export.h>\n-#include <linux/init.h>\n-#include <linux/kernel.h>\n-#include <linux/lsm_hooks.h>\n-#include <linux/integrity.h>\n-#include <linux/ima.h>\n-#include <linux/evm.h>\n-#include <linux/fsnotify.h>\n-#include <linux/mman.h>\n-#include <linux/mount.h>\n-#include <linux/personality.h>\n-#include <linux/backing-dev.h>\n-#include <linux/string.h>\n-#include <linux/msg.h>\n-#include <net/flow.h>\n-\n-#define MAX_LSM_EVM_XATTR\t2\n-\n-/* How many LSMs were built into the kernel? */\n-#define LSM_COUNT (__end_lsm_info - __start_lsm_info)\n-\n-struct security_hook_heads security_hook_heads __lsm_ro_after_init;\n-static BLOCKING_NOTIFIER_HEAD(blocking_lsm_notifier_chain);\n-\n-static struct kmem_cache *lsm_file_cache;\n-static struct kmem_cache *lsm_inode_cache;\n-\n-char *lsm_names;\n-static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init;\n-\n-/* Boot-time LSM user choice */\n-static __initdata const char *chosen_lsm_order;\n-static __initdata const char *chosen_major_lsm;\n-\n-static __initconst const char * const builtin_lsm_order = CONFIG_LSM;\n-\n-/* Ordered list of LSMs to initialize. */\n-static __initdata struct lsm_info **ordered_lsms;\n-static __initdata struct lsm_info *exclusive;\n-\n-static __initdata bool debug;\n-#define init_debug(...)\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tif (debug)\t\t\t\t\t\\\n-\t\t\tpr_info(__VA_ARGS__);\t\t\t\\\n-\t} while (0)\n-\n-static bool __init is_enabled(struct lsm_info *lsm)\n-{\n-\tif (!lsm->enabled)\n-\t\treturn false;\n-\n-\treturn *lsm->enabled;\n-}\n-\n-/* Mark an LSM's enabled flag. */\n-static int lsm_enabled_true __initdata = 1;\n-static int lsm_enabled_false __initdata = 0;\n-static void __init set_enabled(struct lsm_info *lsm, bool enabled)\n-{\n-\t/*\n-\t * When an LSM hasn't configured an enable variable, we can use\n-\t * a hard-coded location for storing the default enabled state.\n-\t */\n-\tif (!lsm->enabled) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t\telse\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_true) {\n-\t\tif (!enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_false;\n-\t} else if (lsm->enabled == &lsm_enabled_false) {\n-\t\tif (enabled)\n-\t\t\tlsm->enabled = &lsm_enabled_true;\n-\t} else {\n-\t\t*lsm->enabled = enabled;\n-\t}\n-}\n-\n-/* Is an LSM already listed in the ordered LSMs list? */\n-static bool __init exists_ordered_lsm(struct lsm_info *lsm)\n-{\n-\tstruct lsm_info **check;\n-\n-\tfor (check = ordered_lsms; *check; check++)\n-\t\tif (*check == lsm)\n-\t\t\treturn true;\n-\n-\treturn false;\n-}\n-\n-/* Append an LSM to the list of ordered LSMs to initialize. */\n-static int last_lsm __initdata;\n-static void __init append_ordered_lsm(struct lsm_info *lsm, const char *from)\n-{\n-\t/* Ignore duplicate selections. */\n-\tif (exists_ordered_lsm(lsm))\n-\t\treturn;\n-\n-\tif (WARN(last_lsm == LSM_COUNT, \"%s: out of LSM slots!?\\n\", from))\n-\t\treturn;\n-\n-\t/* Enable this LSM, if it is not already set. */\n-\tif (!lsm->enabled)\n-\t\tlsm->enabled = &lsm_enabled_true;\n-\tordered_lsms[last_lsm++] = lsm;\n-\n-\tinit_debug(\"%s ordering: %s (%sabled)\\n\", from, lsm->name,\n-\t\t   is_enabled(lsm) ? \"en\" : \"dis\");\n-}\n-\n-/* Is an LSM allowed to be initialized? */\n-static bool __init lsm_allowed(struct lsm_info *lsm)\n-{\n-\t/* Skip if the LSM is disabled. */\n-\tif (!is_enabled(lsm))\n-\t\treturn false;\n-\n-\t/* Not allowed if another exclusive LSM already initialized. */\n-\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && exclusive) {\n-\t\tinit_debug(\"exclusive disabled: %s\\n\", lsm->name);\n-\t\treturn false;\n-\t}\n-\n-\treturn true;\n-}\n-\n-static void __init lsm_set_blob_size(int *need, int *lbs)\n-{\n-\tint offset;\n-\n-\tif (*need > 0) {\n-\t\toffset = *lbs;\n-\t\t*lbs += *need;\n-\t\t*need = offset;\n-\t}\n-}\n-\n-static void __init lsm_set_blob_sizes(struct lsm_blob_sizes *needed)\n-{\n-\tif (!needed)\n-\t\treturn;\n-\n-\tlsm_set_blob_size(&needed->lbs_cred, &blob_sizes.lbs_cred);\n-\tlsm_set_blob_size(&needed->lbs_file, &blob_sizes.lbs_file);\n-\t/*\n-\t * The inode blob gets an rcu_head in addition to\n-\t * what the modules might need.\n-\t */\n-\tif (needed->lbs_inode && blob_sizes.lbs_inode == 0)\n-\t\tblob_sizes.lbs_inode = sizeof(struct rcu_head);\n-\tlsm_set_blob_size(&needed->lbs_inode, &blob_sizes.lbs_inode);\n-\tlsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);\n-\tlsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);\n-\tlsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);\n-}\n-\n-/* Prepare LSM for initialization. */\n-static void __init prepare_lsm(struct lsm_info *lsm)\n-{\n-\tint enabled = lsm_allowed(lsm);\n-\n-\t/* Record enablement (to handle any following exclusive LSMs). */\n-\tset_enabled(lsm, enabled);\n-\n-\t/* If enabled, do pre-initialization work. */\n-\tif (enabled) {\n-\t\tif ((lsm->flags & LSM_FLAG_EXCLUSIVE) && !exclusive) {\n-\t\t\texclusive = lsm;\n-\t\t\tinit_debug(\"exclusive chosen: %s\\n\", lsm->name);\n-\t\t}\n-\n-\t\tlsm_set_blob_sizes(lsm->blobs);\n-\t}\n-}\n-\n-/* Initialize a given LSM, if it is enabled. */\n-static void __init initialize_lsm(struct lsm_info *lsm)\n-{\n-\tif (is_enabled(lsm)) {\n-\t\tint ret;\n-\n-\t\tinit_debug(\"initializing %s\\n\", lsm->name);\n-\t\tret = lsm->init();\n-\t\tWARN(ret, \"%s failed to initialize: %d\\n\", lsm->name, ret);\n-\t}\n-}\n-\n-/* Populate ordered LSMs list from comma-separated LSM name list. */\n-static void __init ordered_lsm_parse(const char *order, const char *origin)\n-{\n-\tstruct lsm_info *lsm;\n-\tchar *sep, *name, *next;\n-\n-\t/* LSM_ORDER_FIRST is always first. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (lsm->order == LSM_ORDER_FIRST)\n-\t\t\tappend_ordered_lsm(lsm, \"first\");\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tstruct lsm_info *major;\n-\n-\t\t/*\n-\t\t * To match the original \"security=\" behavior, this\n-\t\t * explicitly does NOT fallback to another Legacy Major\n-\t\t * if the selected one was separately disabled: disable\n-\t\t * all non-matching Legacy Major LSMs.\n-\t\t */\n-\t\tfor (major = __start_lsm_info; major < __end_lsm_info;\n-\t\t     major++) {\n-\t\t\tif ((major->flags & LSM_FLAG_LEGACY_MAJOR) &&\n-\t\t\t    strcmp(major->name, chosen_major_lsm) != 0) {\n-\t\t\t\tset_enabled(major, false);\n-\t\t\t\tinit_debug(\"security=%s disabled: %s\\n\",\n-\t\t\t\t\t   chosen_major_lsm, major->name);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tsep = kstrdup(order, GFP_KERNEL);\n-\tnext = sep;\n-\t/* Walk the list, looking for matching LSMs. */\n-\twhile ((name = strsep(&next, \",\")) != NULL) {\n-\t\tbool found = false;\n-\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (lsm->order == LSM_ORDER_MUTABLE &&\n-\t\t\t    strcmp(lsm->name, name) == 0) {\n-\t\t\t\tappend_ordered_lsm(lsm, origin);\n-\t\t\t\tfound = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!found)\n-\t\t\tinit_debug(\"%s ignored: %s\\n\", origin, name);\n-\t}\n-\n-\t/* Process \"security=\", if given. */\n-\tif (chosen_major_lsm) {\n-\t\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\t\tif (exists_ordered_lsm(lsm))\n-\t\t\t\tcontinue;\n-\t\t\tif (strcmp(lsm->name, chosen_major_lsm) == 0)\n-\t\t\t\tappend_ordered_lsm(lsm, \"security=\");\n-\t\t}\n-\t}\n-\n-\t/* Disable all LSMs not in the ordered list. */\n-\tfor (lsm = __start_lsm_info; lsm < __end_lsm_info; lsm++) {\n-\t\tif (exists_ordered_lsm(lsm))\n-\t\t\tcontinue;\n-\t\tset_enabled(lsm, false);\n-\t\tinit_debug(\"%s disabled: %s\\n\", origin, lsm->name);\n-\t}\n-\n-\tkfree(sep);\n-}\n-\n-static void __init lsm_early_cred(struct cred *cred);\n-static void __init lsm_early_task(struct task_struct *task);\n-\n-static void __init ordered_lsm_init(void)\n-{\n-\tstruct lsm_info **lsm;\n-\n-\tordered_lsms = kcalloc(LSM_COUNT + 1, sizeof(*ordered_lsms),\n-\t\t\t\tGFP_KERNEL);\n-\n-\tif (chosen_lsm_order) {\n-\t\tif (chosen_major_lsm) {\n-\t\t\tpr_info(\"security= is ignored because it is superseded by lsm=\\n\");\n-\t\t\tchosen_major_lsm = NULL;\n-\t\t}\n-\t\tordered_lsm_parse(chosen_lsm_order, \"cmdline\");\n-\t} else\n-\t\tordered_lsm_parse(builtin_lsm_order, \"builtin\");\n-\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tprepare_lsm(*lsm);\n-\n-\tinit_debug(\"cred blob size     = %d\\n\", blob_sizes.lbs_cred);\n-\tinit_debug(\"file blob size     = %d\\n\", blob_sizes.lbs_file);\n-\tinit_debug(\"inode blob size    = %d\\n\", blob_sizes.lbs_inode);\n-\tinit_debug(\"ipc blob size      = %d\\n\", blob_sizes.lbs_ipc);\n-\tinit_debug(\"msg_msg blob size  = %d\\n\", blob_sizes.lbs_msg_msg);\n-\tinit_debug(\"task blob size     = %d\\n\", blob_sizes.lbs_task);\n-\n-\t/*\n-\t * Create any kmem_caches needed for blobs\n-\t */\n-\tif (blob_sizes.lbs_file)\n-\t\tlsm_file_cache = kmem_cache_create(\"lsm_file_cache\",\n-\t\t\t\t\t\t   blob_sizes.lbs_file, 0,\n-\t\t\t\t\t\t   SLAB_PANIC, NULL);\n-\tif (blob_sizes.lbs_inode)\n-\t\tlsm_inode_cache = kmem_cache_create(\"lsm_inode_cache\",\n-\t\t\t\t\t\t    blob_sizes.lbs_inode, 0,\n-\t\t\t\t\t\t    SLAB_PANIC, NULL);\n-\n-\tlsm_early_cred((struct cred *) current->cred);\n-\tlsm_early_task(current);\n-\tfor (lsm = ordered_lsms; *lsm; lsm++)\n-\t\tinitialize_lsm(*lsm);\n-\n-\tkfree(ordered_lsms);\n-}\n-\n-/**\n- * security_init - initializes the security framework\n- *\n- * This should be called early in the kernel initialization sequence.\n- */\n-int __init security_init(void)\n-{\n-\tint i;\n-\tstruct hlist_head *list = (struct hlist_head *) &security_hook_heads;\n-\n-\tpr_info(\"Security Framework initializing\\n\");\n-\n-\tfor (i = 0; i < sizeof(security_hook_heads) / sizeof(struct hlist_head);\n-\t     i++)\n-\t\tINIT_HLIST_HEAD(&list[i]);\n-\n-\t/* Load LSMs in specified order. */\n-\tordered_lsm_init();\n-\n-\treturn 0;\n-}\n-\n-/* Save user chosen LSM */\n-static int __init choose_major_lsm(char *str)\n-{\n-\tchosen_major_lsm = str;\n-\treturn 1;\n-}\n-__setup(\"security=\", choose_major_lsm);\n-\n-/* Explicitly choose LSM initialization order. */\n-static int __init choose_lsm_order(char *str)\n-{\n-\tchosen_lsm_order = str;\n-\treturn 1;\n-}\n-__setup(\"lsm=\", choose_lsm_order);\n-\n-/* Enable LSM order debugging. */\n-static int __init enable_debug(char *str)\n-{\n-\tdebug = true;\n-\treturn 1;\n-}\n-__setup(\"lsm.debug\", enable_debug);\n-\n-static bool match_last_lsm(const char *list, const char *lsm)\n-{\n-\tconst char *last;\n-\n-\tif (WARN_ON(!list || !lsm))\n-\t\treturn false;\n-\tlast = strrchr(list, ',');\n-\tif (last)\n-\t\t/* Pass the comma, strcmp() will check for '\\0' */\n-\t\tlast++;\n-\telse\n-\t\tlast = list;\n-\treturn !strcmp(last, lsm);\n-}\n-\n-static int lsm_append(char *new, char **result)\n-{\n-\tchar *cp;\n-\n-\tif (*result == NULL) {\n-\t\t*result = kstrdup(new, GFP_KERNEL);\n-\t\tif (*result == NULL)\n-\t\t\treturn -ENOMEM;\n-\t} else {\n-\t\t/* Check if it is the last registered name */\n-\t\tif (match_last_lsm(*result, new))\n-\t\t\treturn 0;\n-\t\tcp = kasprintf(GFP_KERNEL, \"%s,%s\", *result, new);\n-\t\tif (cp == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\tkfree(*result);\n-\t\t*result = cp;\n-\t}\n-\treturn 0;\n-}\n-\n-/**\n- * security_add_hooks - Add a modules hooks to the hook lists.\n- * @hooks: the hooks to add\n- * @count: the number of hooks to add\n- * @lsm: the name of the security module\n- *\n- * Each LSM has to register its hooks with the infrastructure.\n- */\n-void __init security_add_hooks(struct security_hook_list *hooks, int count,\n-\t\t\t\tchar *lsm)\n-{\n-\tint i;\n-\n-\tfor (i = 0; i < count; i++) {\n-\t\thooks[i].lsm = lsm;\n-\t\thlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n-\t}\n-\tif (lsm_append(lsm, &lsm_names) < 0)\n-\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n-}\n-\n-int call_blocking_lsm_notifier(enum lsm_event event, void *data)\n-{\n-\treturn blocking_notifier_call_chain(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t    event, data);\n-}\n-EXPORT_SYMBOL(call_blocking_lsm_notifier);\n-\n-int register_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_register(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\tnb);\n-}\n-EXPORT_SYMBOL(register_blocking_lsm_notifier);\n-\n-int unregister_blocking_lsm_notifier(struct notifier_block *nb)\n-{\n-\treturn blocking_notifier_chain_unregister(&blocking_lsm_notifier_chain,\n-\t\t\t\t\t\t  nb);\n-}\n-EXPORT_SYMBOL(unregister_blocking_lsm_notifier);\n-\n-/**\n- * lsm_cred_alloc - allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- * @gfp: allocation type\n- *\n- * Allocate the cred blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_cred_alloc(struct cred *cred, gfp_t gfp)\n-{\n-\tif (blob_sizes.lbs_cred == 0) {\n-\t\tcred->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tcred->security = kzalloc(blob_sizes.lbs_cred, gfp);\n-\tif (cred->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_cred - during initialization allocate a composite cred blob\n- * @cred: the cred that needs a blob\n- *\n- * Allocate the cred blob for all the modules\n- */\n-static void __init lsm_early_cred(struct cred *cred)\n-{\n-\tint rc = lsm_cred_alloc(cred, GFP_KERNEL);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early cred alloc failed.\\n\", __func__);\n-}\n-\n-/**\n- * lsm_file_alloc - allocate a composite file blob\n- * @file: the file that needs a blob\n- *\n- * Allocate the file blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_file_alloc(struct file *file)\n-{\n-\tif (!lsm_file_cache) {\n-\t\tfile->f_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tfile->f_security = kmem_cache_zalloc(lsm_file_cache, GFP_KERNEL);\n-\tif (file->f_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_inode_alloc - allocate a composite inode blob\n- * @inode: the inode that needs a blob\n- *\n- * Allocate the inode blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-int lsm_inode_alloc(struct inode *inode)\n-{\n-\tif (!lsm_inode_cache) {\n-\t\tinode->i_security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tinode->i_security = kmem_cache_zalloc(lsm_inode_cache, GFP_NOFS);\n-\tif (inode->i_security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_task_alloc - allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_task_alloc(struct task_struct *task)\n-{\n-\tif (blob_sizes.lbs_task == 0) {\n-\t\ttask->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\ttask->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);\n-\tif (task->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_ipc_alloc - allocate a composite ipc blob\n- * @kip: the ipc that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_ipc_alloc(struct kern_ipc_perm *kip)\n-{\n-\tif (blob_sizes.lbs_ipc == 0) {\n-\t\tkip->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tkip->security = kzalloc(blob_sizes.lbs_ipc, GFP_KERNEL);\n-\tif (kip->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_msg_msg_alloc - allocate a composite msg_msg blob\n- * @mp: the msg_msg that needs a blob\n- *\n- * Allocate the ipc blob for all the modules\n- *\n- * Returns 0, or -ENOMEM if memory can't be allocated.\n- */\n-static int lsm_msg_msg_alloc(struct msg_msg *mp)\n-{\n-\tif (blob_sizes.lbs_msg_msg == 0) {\n-\t\tmp->security = NULL;\n-\t\treturn 0;\n-\t}\n-\n-\tmp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);\n-\tif (mp->security == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-/**\n- * lsm_early_task - during initialization allocate a composite task blob\n- * @task: the task that needs a blob\n- *\n- * Allocate the task blob for all the modules\n- */\n-static void __init lsm_early_task(struct task_struct *task)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\tpanic(\"%s: Early task alloc failed.\\n\", __func__);\n-}\n-\n-/*\n- * Hook list operation macros.\n- *\n- * call_void_hook:\n- *\tThis is a hook that does not return a value.\n- *\n- * call_int_hook:\n- *\tThis is a hook that returns a value.\n- */\n-\n-#define call_void_hook(FUNC, ...)\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) \\\n-\t\t\tP->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t} while (0)\n-\n-#define call_int_hook(FUNC, IRC, ...) ({\t\t\t\\\n-\tint RC = IRC;\t\t\t\t\t\t\\\n-\tdo {\t\t\t\t\t\t\t\\\n-\t\tstruct security_hook_list *P;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t\thlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \\\n-\t\t\tRC = P->hook.FUNC(__VA_ARGS__);\t\t\\\n-\t\t\tif (RC != 0)\t\t\t\t\\\n-\t\t\t\tbreak;\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\\\n-\t} while (0);\t\t\t\t\t\t\\\n-\tRC;\t\t\t\t\t\t\t\\\n-})\n-\n-/* Security operations */\n-\n-int security_binder_set_context_mgr(struct task_struct *mgr)\n-{\n-\treturn call_int_hook(binder_set_context_mgr, 0, mgr);\n-}\n-\n-int security_binder_transaction(struct task_struct *from,\n-\t\t\t\tstruct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transaction, 0, from, to);\n-}\n-\n-int security_binder_transfer_binder(struct task_struct *from,\n-\t\t\t\t    struct task_struct *to)\n-{\n-\treturn call_int_hook(binder_transfer_binder, 0, from, to);\n-}\n-\n-int security_binder_transfer_file(struct task_struct *from,\n-\t\t\t\t  struct task_struct *to, struct file *file)\n-{\n-\treturn call_int_hook(binder_transfer_file, 0, from, to, file);\n-}\n-\n-int security_ptrace_access_check(struct task_struct *child, unsigned int mode)\n-{\n-\treturn call_int_hook(ptrace_access_check, 0, child, mode);\n-}\n-\n-int security_ptrace_traceme(struct task_struct *parent)\n-{\n-\treturn call_int_hook(ptrace_traceme, 0, parent);\n-}\n-\n-int security_capget(struct task_struct *target,\n-\t\t     kernel_cap_t *effective,\n-\t\t     kernel_cap_t *inheritable,\n-\t\t     kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capget, 0, target,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capset(struct cred *new, const struct cred *old,\n-\t\t    const kernel_cap_t *effective,\n-\t\t    const kernel_cap_t *inheritable,\n-\t\t    const kernel_cap_t *permitted)\n-{\n-\treturn call_int_hook(capset, 0, new, old,\n-\t\t\t\teffective, inheritable, permitted);\n-}\n-\n-int security_capable(const struct cred *cred,\n-\t\t     struct user_namespace *ns,\n-\t\t     int cap,\n-\t\t     unsigned int opts)\n-{\n-\treturn call_int_hook(capable, 0, cred, ns, cap, opts);\n-}\n-\n-int security_quotactl(int cmds, int type, int id, struct super_block *sb)\n-{\n-\treturn call_int_hook(quotactl, 0, cmds, type, id, sb);\n-}\n-\n-int security_quota_on(struct dentry *dentry)\n-{\n-\treturn call_int_hook(quota_on, 0, dentry);\n-}\n-\n-int security_syslog(int type)\n-{\n-\treturn call_int_hook(syslog, 0, type);\n-}\n-\n-int security_settime64(const struct timespec64 *ts, const struct timezone *tz)\n-{\n-\treturn call_int_hook(settime, 0, ts, tz);\n-}\n-\n-int security_vm_enough_memory_mm(struct mm_struct *mm, long pages)\n-{\n-\tstruct security_hook_list *hp;\n-\tint cap_sys_admin = 1;\n-\tint rc;\n-\n-\t/*\n-\t * The module will respond with a positive value if\n-\t * it thinks the __vm_enough_memory() call should be\n-\t * made with the cap_sys_admin set. If all of the modules\n-\t * agree that it should be set it will. If any module\n-\t * thinks it should not be set it won't.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.vm_enough_memory, list) {\n-\t\trc = hp->hook.vm_enough_memory(mm, pages);\n-\t\tif (rc <= 0) {\n-\t\t\tcap_sys_admin = 0;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\treturn __vm_enough_memory(mm, pages, cap_sys_admin);\n-}\n-\n-int security_bprm_set_creds(struct linux_binprm *bprm)\n-{\n-\treturn call_int_hook(bprm_set_creds, 0, bprm);\n-}\n-\n-int security_bprm_check(struct linux_binprm *bprm)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(bprm_check_security, 0, bprm);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_bprm_check(bprm);\n-}\n-\n-void security_bprm_committing_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committing_creds, bprm);\n-}\n-\n-void security_bprm_committed_creds(struct linux_binprm *bprm)\n-{\n-\tcall_void_hook(bprm_committed_creds, bprm);\n-}\n-\n-int security_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n-{\n-\treturn call_int_hook(fs_context_dup, 0, fc, src_fc);\n-}\n-\n-int security_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param)\n-{\n-\treturn call_int_hook(fs_context_parse_param, -ENOPARAM, fc, param);\n-}\n-\n-int security_sb_alloc(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_alloc_security, 0, sb);\n-}\n-\n-void security_sb_free(struct super_block *sb)\n-{\n-\tcall_void_hook(sb_free_security, sb);\n-}\n-\n-void security_free_mnt_opts(void **mnt_opts)\n-{\n-\tif (!*mnt_opts)\n-\t\treturn;\n-\tcall_void_hook(sb_free_mnt_opts, *mnt_opts);\n-\t*mnt_opts = NULL;\n-}\n-EXPORT_SYMBOL(security_free_mnt_opts);\n-\n-int security_sb_eat_lsm_opts(char *options, void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_eat_lsm_opts, 0, options, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_eat_lsm_opts);\n-\n-int security_sb_remount(struct super_block *sb,\n-\t\t\tvoid *mnt_opts)\n-{\n-\treturn call_int_hook(sb_remount, 0, sb, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_sb_remount);\n-\n-int security_sb_kern_mount(struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_kern_mount, 0, sb);\n-}\n-\n-int security_sb_show_options(struct seq_file *m, struct super_block *sb)\n-{\n-\treturn call_int_hook(sb_show_options, 0, m, sb);\n-}\n-\n-int security_sb_statfs(struct dentry *dentry)\n-{\n-\treturn call_int_hook(sb_statfs, 0, dentry);\n-}\n-\n-int security_sb_mount(const char *dev_name, const struct path *path,\n-                       const char *type, unsigned long flags, void *data)\n-{\n-\treturn call_int_hook(sb_mount, 0, dev_name, path, type, flags, data);\n-}\n-\n-int security_sb_umount(struct vfsmount *mnt, int flags)\n-{\n-\treturn call_int_hook(sb_umount, 0, mnt, flags);\n-}\n-\n-int security_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n-{\n-\treturn call_int_hook(sb_pivotroot, 0, old_path, new_path);\n-}\n-\n-int security_sb_set_mnt_opts(struct super_block *sb,\n-\t\t\t\tvoid *mnt_opts,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_set_mnt_opts,\n-\t\t\t\tmnt_opts ? -EOPNOTSUPP : 0, sb,\n-\t\t\t\tmnt_opts, kern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_set_mnt_opts);\n-\n-int security_sb_clone_mnt_opts(const struct super_block *oldsb,\n-\t\t\t\tstruct super_block *newsb,\n-\t\t\t\tunsigned long kern_flags,\n-\t\t\t\tunsigned long *set_kern_flags)\n-{\n-\treturn call_int_hook(sb_clone_mnt_opts, 0, oldsb, newsb,\n-\t\t\t\tkern_flags, set_kern_flags);\n-}\n-EXPORT_SYMBOL(security_sb_clone_mnt_opts);\n-\n-int security_add_mnt_opt(const char *option, const char *val, int len,\n-\t\t\t void **mnt_opts)\n-{\n-\treturn call_int_hook(sb_add_mnt_opt, -EINVAL,\n-\t\t\t\t\toption, val, len, mnt_opts);\n-}\n-EXPORT_SYMBOL(security_add_mnt_opt);\n-\n-int security_move_mount(const struct path *from_path, const struct path *to_path)\n-{\n-\treturn call_int_hook(move_mount, 0, from_path, to_path);\n-}\n-\n-int security_inode_alloc(struct inode *inode)\n-{\n-\tint rc = lsm_inode_alloc(inode);\n-\n-\tif (unlikely(rc))\n-\t\treturn rc;\n-\trc = call_int_hook(inode_alloc_security, 0, inode);\n-\tif (unlikely(rc))\n-\t\tsecurity_inode_free(inode);\n-\treturn rc;\n-}\n-\n-static void inode_free_by_rcu(struct rcu_head *head)\n-{\n-\t/*\n-\t * The rcu head is at the start of the inode blob\n-\t */\n-\tkmem_cache_free(lsm_inode_cache, head);\n-}\n-\n-void security_inode_free(struct inode *inode)\n-{\n-\tintegrity_inode_free(inode);\n-\tcall_void_hook(inode_free_security, inode);\n-\t/*\n-\t * The inode may still be referenced in a path walk and\n-\t * a call to security_inode_permission() can be made\n-\t * after inode_free_security() is called. Ideally, the VFS\n-\t * wouldn't do this, but fixing that is a much harder\n-\t * job. For now, simply free the i_security via RCU, and\n-\t * leave the current inode->i_security pointer intact.\n-\t * The inode will be freed after the RCU grace period too.\n-\t */\n-\tif (inode->i_security)\n-\t\tcall_rcu((struct rcu_head *)inode->i_security,\n-\t\t\t\tinode_free_by_rcu);\n-}\n-\n-int security_dentry_init_security(struct dentry *dentry, int mode,\n-\t\t\t\t\tconst struct qstr *name, void **ctx,\n-\t\t\t\t\tu32 *ctxlen)\n-{\n-\treturn call_int_hook(dentry_init_security, -EOPNOTSUPP, dentry, mode,\n-\t\t\t\tname, ctx, ctxlen);\n-}\n-EXPORT_SYMBOL(security_dentry_init_security);\n-\n-int security_dentry_create_files_as(struct dentry *dentry, int mode,\n-\t\t\t\t    struct qstr *name,\n-\t\t\t\t    const struct cred *old, struct cred *new)\n-{\n-\treturn call_int_hook(dentry_create_files_as, 0, dentry, mode,\n-\t\t\t\tname, old, new);\n-}\n-EXPORT_SYMBOL(security_dentry_create_files_as);\n-\n-int security_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t const struct qstr *qstr,\n-\t\t\t\t const initxattrs initxattrs, void *fs_data)\n-{\n-\tstruct xattr new_xattrs[MAX_LSM_EVM_XATTR + 1];\n-\tstruct xattr *lsm_xattr, *evm_xattr, *xattr;\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\n-\tif (!initxattrs)\n-\t\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode,\n-\t\t\t\t     dir, qstr, NULL, NULL, NULL);\n-\tmemset(new_xattrs, 0, sizeof(new_xattrs));\n-\tlsm_xattr = new_xattrs;\n-\tret = call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir, qstr,\n-\t\t\t\t\t\t&lsm_xattr->name,\n-\t\t\t\t\t\t&lsm_xattr->value,\n-\t\t\t\t\t\t&lsm_xattr->value_len);\n-\tif (ret)\n-\t\tgoto out;\n-\n-\tevm_xattr = lsm_xattr + 1;\n-\tret = evm_inode_init_security(inode, lsm_xattr, evm_xattr);\n-\tif (ret)\n-\t\tgoto out;\n-\tret = initxattrs(inode, new_xattrs, fs_data);\n-out:\n-\tfor (xattr = new_xattrs; xattr->value != NULL; xattr++)\n-\t\tkfree(xattr->value);\n-\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n-}\n-EXPORT_SYMBOL(security_inode_init_security);\n-\n-int security_old_inode_init_security(struct inode *inode, struct inode *dir,\n-\t\t\t\t     const struct qstr *qstr, const char **name,\n-\t\t\t\t     void **value, size_t *len)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\treturn call_int_hook(inode_init_security, -EOPNOTSUPP, inode, dir,\n-\t\t\t     qstr, name, value, len);\n-}\n-EXPORT_SYMBOL(security_old_inode_init_security);\n-\n-#ifdef CONFIG_SECURITY_PATH\n-int security_path_mknod(const struct path *dir, struct dentry *dentry, umode_t mode,\n-\t\t\tunsigned int dev)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mknod, 0, dir, dentry, mode, dev);\n-}\n-EXPORT_SYMBOL(security_path_mknod);\n-\n-int security_path_mkdir(const struct path *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL(security_path_mkdir);\n-\n-int security_path_rmdir(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_rmdir, 0, dir, dentry);\n-}\n-\n-int security_path_unlink(const struct path *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_unlink, 0, dir, dentry);\n-}\n-EXPORT_SYMBOL(security_path_unlink);\n-\n-int security_path_symlink(const struct path *dir, struct dentry *dentry,\n-\t\t\t  const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dir->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_path_link(struct dentry *old_dentry, const struct path *new_dir,\n-\t\t       struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_link, 0, old_dentry, new_dir, new_dentry);\n-}\n-\n-int security_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n-\t\t\t const struct path *new_dir, struct dentry *new_dentry,\n-\t\t\t unsigned int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-\t\t     (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(path_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\told_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(path_rename, 0, old_dir, old_dentry, new_dir,\n-\t\t\t\tnew_dentry);\n-}\n-EXPORT_SYMBOL(security_path_rename);\n-\n-int security_path_truncate(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_truncate, 0, path);\n-}\n-\n-int security_path_chmod(const struct path *path, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chmod, 0, path, mode);\n-}\n-\n-int security_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(path_chown, 0, path, uid, gid);\n-}\n-\n-int security_path_chroot(const struct path *path)\n-{\n-\treturn call_int_hook(path_chroot, 0, path);\n-}\n-#endif\n-\n-int security_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_create, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_create);\n-\n-int security_inode_link(struct dentry *old_dentry, struct inode *dir,\n-\t\t\t struct dentry *new_dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(old_dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_link, 0, old_dentry, dir, new_dentry);\n-}\n-\n-int security_inode_unlink(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_unlink, 0, dir, dentry);\n-}\n-\n-int security_inode_symlink(struct inode *dir, struct dentry *dentry,\n-\t\t\t    const char *old_name)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_symlink, 0, dir, dentry, old_name);\n-}\n-\n-int security_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mkdir, 0, dir, dentry, mode);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_mkdir);\n-\n-int security_inode_rmdir(struct inode *dir, struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_rmdir, 0, dir, dentry);\n-}\n-\n-int security_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n-{\n-\tif (unlikely(IS_PRIVATE(dir)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_mknod, 0, dir, dentry, mode, dev);\n-}\n-\n-int security_inode_rename(struct inode *old_dir, struct dentry *old_dentry,\n-\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n-\t\t\t   unsigned int flags)\n-{\n-        if (unlikely(IS_PRIVATE(d_backing_inode(old_dentry)) ||\n-            (d_is_positive(new_dentry) && IS_PRIVATE(d_backing_inode(new_dentry)))))\n-\t\treturn 0;\n-\n-\tif (flags & RENAME_EXCHANGE) {\n-\t\tint err = call_int_hook(inode_rename, 0, new_dir, new_dentry,\n-\t\t\t\t\t\t     old_dir, old_dentry);\n-\t\tif (err)\n-\t\t\treturn err;\n-\t}\n-\n-\treturn call_int_hook(inode_rename, 0, old_dir, old_dentry,\n-\t\t\t\t\t   new_dir, new_dentry);\n-}\n-\n-int security_inode_readlink(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_readlink, 0, dentry);\n-}\n-\n-int security_inode_follow_link(struct dentry *dentry, struct inode *inode,\n-\t\t\t       bool rcu)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_follow_link, 0, dentry, inode, rcu);\n-}\n-\n-int security_inode_permission(struct inode *inode, int mask)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_permission, 0, inode, mask);\n-}\n-\n-int security_inode_setattr(struct dentry *dentry, struct iattr *attr)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\tret = call_int_hook(inode_setattr, 0, dentry, attr);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setattr(dentry, attr);\n-}\n-EXPORT_SYMBOL_GPL(security_inode_setattr);\n-\n-int security_inode_getattr(const struct path *path)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(path->dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getattr, 0, path);\n-}\n-\n-int security_inode_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t    const void *value, size_t size, int flags)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_setxattr, 1, dentry, name, value, size,\n-\t\t\t\tflags);\n-\n-\tif (ret == 1)\n-\t\tret = cap_inode_setxattr(dentry, name, value, size, flags);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_setxattr(dentry, name, value, size);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_setxattr(dentry, name, value, size);\n-}\n-\n-void security_inode_post_setxattr(struct dentry *dentry, const char *name,\n-\t\t\t\t  const void *value, size_t size, int flags)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn;\n-\tcall_void_hook(inode_post_setxattr, dentry, name, value, size, flags);\n-\tevm_inode_post_setxattr(dentry, name, value, size);\n-}\n-\n-int security_inode_getxattr(struct dentry *dentry, const char *name)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_getxattr, 0, dentry, name);\n-}\n-\n-int security_inode_listxattr(struct dentry *dentry)\n-{\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listxattr, 0, dentry);\n-}\n-\n-int security_inode_removexattr(struct dentry *dentry, const char *name)\n-{\n-\tint ret;\n-\n-\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n-\t\treturn 0;\n-\t/*\n-\t * SELinux and Smack integrate the cap call,\n-\t * so assume that all LSMs supplying this call do so.\n-\t */\n-\tret = call_int_hook(inode_removexattr, 1, dentry, name);\n-\tif (ret == 1)\n-\t\tret = cap_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = ima_inode_removexattr(dentry, name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn evm_inode_removexattr(dentry, name);\n-}\n-\n-int security_inode_need_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_need_killpriv, 0, dentry);\n-}\n-\n-int security_inode_killpriv(struct dentry *dentry)\n-{\n-\treturn call_int_hook(inode_killpriv, 0, dentry);\n-}\n-\n-int security_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_getsecurity, list) {\n-\t\trc = hp->hook.inode_getsecurity(inode, name, buffer, alloc);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_setsecurity(struct inode *inode, const char *name, const void *value, size_t size, int flags)\n-{\n-\tstruct security_hook_list *hp;\n-\tint rc;\n-\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn -EOPNOTSUPP;\n-\t/*\n-\t * Only one module will provide an attribute with a given name.\n-\t */\n-\thlist_for_each_entry(hp, &security_hook_heads.inode_setsecurity, list) {\n-\t\trc = hp->hook.inode_setsecurity(inode, name, value, size,\n-\t\t\t\t\t\t\t\tflags);\n-\t\tif (rc != -EOPNOTSUPP)\n-\t\t\treturn rc;\n-\t}\n-\treturn -EOPNOTSUPP;\n-}\n-\n-int security_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n-{\n-\tif (unlikely(IS_PRIVATE(inode)))\n-\t\treturn 0;\n-\treturn call_int_hook(inode_listsecurity, 0, inode, buffer, buffer_size);\n-}\n-EXPORT_SYMBOL(security_inode_listsecurity);\n-\n-void security_inode_getsecid(struct inode *inode, u32 *secid)\n-{\n-\tcall_void_hook(inode_getsecid, inode, secid);\n-}\n-\n-int security_inode_copy_up(struct dentry *src, struct cred **new)\n-{\n-\treturn call_int_hook(inode_copy_up, 0, src, new);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up);\n-\n-int security_inode_copy_up_xattr(const char *name)\n-{\n-\treturn call_int_hook(inode_copy_up_xattr, -EOPNOTSUPP, name);\n-}\n-EXPORT_SYMBOL(security_inode_copy_up_xattr);\n-\n-int security_kernfs_init_security(struct kernfs_node *kn_dir,\n-\t\t\t\t  struct kernfs_node *kn)\n-{\n-\treturn call_int_hook(kernfs_init_security, 0, kn_dir, kn);\n-}\n-\n-int security_file_permission(struct file *file, int mask)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_permission, 0, file, mask);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, mask);\n-}\n-\n-int security_file_alloc(struct file *file)\n-{\n-\tint rc = lsm_file_alloc(file);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(file_alloc_security, 0, file);\n-\tif (unlikely(rc))\n-\t\tsecurity_file_free(file);\n-\treturn rc;\n-}\n-\n-void security_file_free(struct file *file)\n-{\n-\tvoid *blob;\n-\n-\tcall_void_hook(file_free_security, file);\n-\n-\tblob = file->f_security;\n-\tif (blob) {\n-\t\tfile->f_security = NULL;\n-\t\tkmem_cache_free(lsm_file_cache, blob);\n-\t}\n-}\n-\n-int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_ioctl, 0, file, cmd, arg);\n-}\n-\n-static inline unsigned long mmap_prot(struct file *file, unsigned long prot)\n-{\n-\t/*\n-\t * Does we have PROT_READ and does the application expect\n-\t * it to imply PROT_EXEC?  If not, nothing to talk about...\n-\t */\n-\tif ((prot & (PROT_READ | PROT_EXEC)) != PROT_READ)\n-\t\treturn prot;\n-\tif (!(current->personality & READ_IMPLIES_EXEC))\n-\t\treturn prot;\n-\t/*\n-\t * if that's an anonymous mapping, let it.\n-\t */\n-\tif (!file)\n-\t\treturn prot | PROT_EXEC;\n-\t/*\n-\t * ditto if it's not on noexec mount, except that on !MMU we need\n-\t * NOMMU_MAP_EXEC (== VM_MAYEXEC) in this case\n-\t */\n-\tif (!path_noexec(&file->f_path)) {\n-#ifndef CONFIG_MMU\n-\t\tif (file->f_op->mmap_capabilities) {\n-\t\t\tunsigned caps = file->f_op->mmap_capabilities(file);\n-\t\t\tif (!(caps & NOMMU_MAP_EXEC))\n-\t\t\t\treturn prot;\n-\t\t}\n-#endif\n-\t\treturn prot | PROT_EXEC;\n-\t}\n-\t/* anything on noexec mount won't get PROT_EXEC */\n-\treturn prot;\n-}\n-\n-int security_mmap_file(struct file *file, unsigned long prot,\n-\t\t\tunsigned long flags)\n-{\n-\tint ret;\n-\tret = call_int_hook(mmap_file, 0, file, prot,\n-\t\t\t\t\tmmap_prot(file, prot), flags);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn ima_file_mmap(file, prot);\n-}\n-\n-int security_mmap_addr(unsigned long addr)\n-{\n-\treturn call_int_hook(mmap_addr, 0, addr);\n-}\n-\n-int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,\n-\t\t\t    unsigned long prot)\n-{\n-\treturn call_int_hook(file_mprotect, 0, vma, reqprot, prot);\n-}\n-\n-int security_file_lock(struct file *file, unsigned int cmd)\n-{\n-\treturn call_int_hook(file_lock, 0, file, cmd);\n-}\n-\n-int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n-{\n-\treturn call_int_hook(file_fcntl, 0, file, cmd, arg);\n-}\n-\n-void security_file_set_fowner(struct file *file)\n-{\n-\tcall_void_hook(file_set_fowner, file);\n-}\n-\n-int security_file_send_sigiotask(struct task_struct *tsk,\n-\t\t\t\t  struct fown_struct *fown, int sig)\n-{\n-\treturn call_int_hook(file_send_sigiotask, 0, tsk, fown, sig);\n-}\n-\n-int security_file_receive(struct file *file)\n-{\n-\treturn call_int_hook(file_receive, 0, file);\n-}\n-\n-int security_file_open(struct file *file)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(file_open, 0, file);\n-\tif (ret)\n-\t\treturn ret;\n-\n-\treturn fsnotify_perm(file, MAY_OPEN);\n-}\n-\n-int security_task_alloc(struct task_struct *task, unsigned long clone_flags)\n-{\n-\tint rc = lsm_task_alloc(task);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\trc = call_int_hook(task_alloc, 0, task, clone_flags);\n-\tif (unlikely(rc))\n-\t\tsecurity_task_free(task);\n-\treturn rc;\n-}\n-\n-void security_task_free(struct task_struct *task)\n-{\n-\tcall_void_hook(task_free, task);\n-\n-\tkfree(task->security);\n-\ttask->security = NULL;\n-}\n-\n-int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(cred, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_alloc_blank, 0, cred, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(cred);\n-\treturn rc;\n-}\n-\n-void security_cred_free(struct cred *cred)\n-{\n-\t/*\n-\t * There is a failure case in prepare_creds() that\n-\t * may result in a call here with ->security being NULL.\n-\t */\n-\tif (unlikely(cred->security == NULL))\n-\t\treturn;\n-\n-\tcall_void_hook(cred_free, cred);\n-\n-\tkfree(cred->security);\n-\tcred->security = NULL;\n-}\n-\n-int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)\n-{\n-\tint rc = lsm_cred_alloc(new, gfp);\n-\n-\tif (rc)\n-\t\treturn rc;\n-\n-\trc = call_int_hook(cred_prepare, 0, new, old, gfp);\n-\tif (unlikely(rc))\n-\t\tsecurity_cred_free(new);\n-\treturn rc;\n-}\n-\n-void security_transfer_creds(struct cred *new, const struct cred *old)\n-{\n-\tcall_void_hook(cred_transfer, new, old);\n-}\n-\n-void security_cred_getsecid(const struct cred *c, u32 *secid)\n-{\n-\t*secid = 0;\n-\tcall_void_hook(cred_getsecid, c, secid);\n-}\n-EXPORT_SYMBOL(security_cred_getsecid);\n-\n-int security_kernel_act_as(struct cred *new, u32 secid)\n-{\n-\treturn call_int_hook(kernel_act_as, 0, new, secid);\n-}\n-\n-int security_kernel_create_files_as(struct cred *new, struct inode *inode)\n-{\n-\treturn call_int_hook(kernel_create_files_as, 0, new, inode);\n-}\n-\n-int security_kernel_module_request(char *kmod_name)\n-{\n-\tint ret;\n-\n-\tret = call_int_hook(kernel_module_request, 0, kmod_name);\n-\tif (ret)\n-\t\treturn ret;\n-\treturn integrity_kernel_module_request(kmod_name);\n+#include <stdio.h>\n+void main() {",
        "comment_created_at": "2019-09-02T23:57:13+00:00",
        "comment_author": "rohand2290",
        "comment_body": "wth lol hahaha",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "220175117",
    "pr_number": 597,
    "pr_file": "kernel/sched/cpupri.c",
    "created_at": "2018-09-25T12:41:57+00:00",
    "commented_code": "#include \"sched.h\"\n \n /* Convert between a 140 based task->prio, and our 102 based cpupri */\n-static int convert_prio(int prio)\n+static int convert_prio(const int prio)\n {\n-\tint cpupri;\n-\n \tif (prio == CPUPRI_INVALID)\n-\t\tcpupri = CPUPRI_INVALID;\n+\t\treturn CPUPRI_INVALID;",
    "repo_full_name": "torvalds/linux",
    "discussion_comments": [
      {
        "comment_id": "220175117",
        "repo_full_name": "torvalds/linux",
        "pr_number": 597,
        "pr_file": "kernel/sched/cpupri.c",
        "discussion_id": "220175117",
        "commented_code": "@@ -29,20 +29,16 @@\n #include \"sched.h\"\n \n /* Convert between a 140 based task->prio, and our 102 based cpupri */\n-static int convert_prio(int prio)\n+static int convert_prio(const int prio)\n {\n-\tint cpupri;\n-\n \tif (prio == CPUPRI_INVALID)\n-\t\tcpupri = CPUPRI_INVALID;\n+\t\treturn CPUPRI_INVALID;",
        "comment_created_at": "2018-09-25T12:41:57+00:00",
        "comment_author": "gxgalx",
        "comment_body": "Isn't it clearer having just one return statement instead of several exit points?",
        "pr_file_module": null
      },
      {
        "comment_id": "221429470",
        "repo_full_name": "torvalds/linux",
        "pr_number": 597,
        "pr_file": "kernel/sched/cpupri.c",
        "discussion_id": "220175117",
        "commented_code": "@@ -29,20 +29,16 @@\n #include \"sched.h\"\n \n /* Convert between a 140 based task->prio, and our 102 based cpupri */\n-static int convert_prio(int prio)\n+static int convert_prio(const int prio)\n {\n-\tint cpupri;\n-\n \tif (prio == CPUPRI_INVALID)\n-\t\tcpupri = CPUPRI_INVALID;\n+\t\treturn CPUPRI_INVALID;",
        "comment_created_at": "2018-09-29T14:15:32+00:00",
        "comment_author": "GTANAdam",
        "comment_body": "It's a tiny optimization that should reduce the amount of instructions used in that method imo (if the compiler doesn't optimize that already), instead of assigning cpupri variable a value and then return it, it will just return the value instead.",
        "pr_file_module": null
      }
    ]
  }
]