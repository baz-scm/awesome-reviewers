[
  {
    "discussion_id": "2153683411",
    "pr_number": 11795,
    "pr_file": "enterprise/enterprise_hooks/managed_files.py",
    "created_at": "2025-06-18T05:38:00+00:00",
    "commented_code": "litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2153683411",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 11795,
        "pr_file": "enterprise/enterprise_hooks/managed_files.py",
        "discussion_id": "2153683411",
        "commented_code": "@@ -123,14 +123,18 @@ async def store_unified_object_id(\n             litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
        "comment_created_at": "2025-06-18T05:38:00+00:00",
        "comment_author": "krrishdholakia",
        "comment_body": "what is a scenario where we would expect the object id to already exist? @yeahyung ",
        "pr_file_module": null
      },
      {
        "comment_id": "2154492693",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 11795,
        "pr_file": "enterprise/enterprise_hooks/managed_files.py",
        "discussion_id": "2153683411",
        "commented_code": "@@ -123,14 +123,18 @@ async def store_unified_object_id(\n             litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
        "comment_created_at": "2025-06-18T12:37:37+00:00",
        "comment_author": "yeahyung",
        "comment_body": "@krrishdholakia \r\n1. if you call `/batches/retrieve` and if the batch status is complete, LiteLLM insert into managed object table\r\n2. if you call `/batches/retrieve` again, LiteLLM insert into managed object table again and get `UniqueViolationError` message",
        "pr_file_module": null
      },
      {
        "comment_id": "2159886562",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 11795,
        "pr_file": "enterprise/enterprise_hooks/managed_files.py",
        "discussion_id": "2153683411",
        "commented_code": "@@ -123,14 +123,18 @@ async def store_unified_object_id(\n             litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
        "comment_created_at": "2025-06-21T06:25:54+00:00",
        "comment_author": "krrishdholakia",
        "comment_body": "can you please add a test for this inside https://github.com/BerriAI/litellm/blob/main/tests/enterprise/enterprise_hooks/test_managed_files.py",
        "pr_file_module": null
      },
      {
        "comment_id": "2176375295",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 11795,
        "pr_file": "enterprise/enterprise_hooks/managed_files.py",
        "discussion_id": "2153683411",
        "commented_code": "@@ -123,14 +123,18 @@ async def store_unified_object_id(\n             litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
        "comment_created_at": "2025-07-01T04:21:36+00:00",
        "comment_author": "yeahyung",
        "comment_body": "sorry for late, test code added. please have a check",
        "pr_file_module": null
      },
      {
        "comment_id": "2200267753",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 11795,
        "pr_file": "enterprise/enterprise_hooks/managed_files.py",
        "discussion_id": "2153683411",
        "commented_code": "@@ -123,14 +123,18 @@ async def store_unified_object_id(\n             litellm_parent_otel_span=litellm_parent_otel_span,\n         )\n \n-        await self.prisma_client.db.litellm_managedobjecttable.create(\n+        await self.prisma_client.db.litellm_managedobjecttable.upsert(",
        "comment_created_at": "2025-07-11T09:54:09+00:00",
        "comment_author": "railscard",
        "comment_body": "@krrishdholakia @yeahyung I also tested the fix locally and can confirm it solves the problem",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173508819",
    "pr_number": 12082,
    "pr_file": "litellm/proxy/management_endpoints/team_endpoints.py",
    "created_at": "2025-06-28T19:53:39+00:00",
    "commented_code": "filtered_response = []\n     if user_id:\n-        for team in response:\n-            if team.members_with_roles:\n-                for member in team.members_with_roles:\n-                    if (\n-                        \"user_id\" in member\n-                        and member[\"user_id\"] is not None\n-                        and member[\"user_id\"] == user_id\n-                    ):\n+        # Get user object to access their teams array\n+        try:\n+            user_object = await prisma_client.db.litellm_usertable.find_unique(",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2173508819",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12082,
        "pr_file": "litellm/proxy/management_endpoints/team_endpoints.py",
        "discussion_id": "2173508819",
        "commented_code": "@@ -2104,15 +2173,30 @@ async def list_team(\n \n     filtered_response = []\n     if user_id:\n-        for team in response:\n-            if team.members_with_roles:\n-                for member in team.members_with_roles:\n-                    if (\n-                        \"user_id\" in member\n-                        and member[\"user_id\"] is not None\n-                        and member[\"user_id\"] == user_id\n-                    ):\n+        # Get user object to access their teams array\n+        try:\n+            user_object = await prisma_client.db.litellm_usertable.find_unique(",
        "comment_created_at": "2025-06-28T19:53:39+00:00",
        "comment_author": "krrishdholakia",
        "comment_body": "This could lead to issues. There are other places where team checks will rely on the member list within the team, so the user would see a team their user object might list, but they'd face errors when using it. \r\n\r\nDid you figure out what the underlying cause of the drift was? @colesmcintosh ",
        "pr_file_module": null
      },
      {
        "comment_id": "2173820902",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12082,
        "pr_file": "litellm/proxy/management_endpoints/team_endpoints.py",
        "discussion_id": "2173508819",
        "commented_code": "@@ -2104,15 +2173,30 @@ async def list_team(\n \n     filtered_response = []\n     if user_id:\n-        for team in response:\n-            if team.members_with_roles:\n-                for member in team.members_with_roles:\n-                    if (\n-                        \"user_id\" in member\n-                        and member[\"user_id\"] is not None\n-                        and member[\"user_id\"] == user_id\n-                    ):\n+        # Get user object to access their teams array\n+        try:\n+            user_object = await prisma_client.db.litellm_usertable.find_unique(",
        "comment_created_at": "2025-06-29T16:20:25+00:00",
        "comment_author": "colesmcintosh",
        "comment_body": " @krrishdholakia - Regarding the drift between user.teams and team.members_with_roles:\r\n\r\n  The root cause is that team membership is maintained in two separate places without transactional consistency:\r\n\r\n  1. user.teams - Array of team IDs on the user record\r\n  2. team.members_with_roles - Array of member objects on the team record\r\n\r\n  How the drift occurs:\r\n\r\n  1. Non-atomic updates: When adding/removing team members, the code updates both fields separately:\r\n    - In team_member_add: First updates user.teams (via add_new_member()), then updates team.members_with_roles\r\n    - In team_member_remove: Updates happen in reverse order\r\n    - If either operation fails, you get partial updates\r\n  2. Database push operations: The code uses Prisma's push operation for arrays, which can add duplicates if called multiple times (e.g., during retries or concurrent requests)\r\n  3. No validation: There's no check to ensure both fields stay synchronized after operations\r\n\r\n  Example scenario causing drift:\r\n  - User adds member A to a team\r\n  - user.teams gets updated successfully\r\n  - team.members_with_roles update fails (network issue, timeout, etc.)\r\n  - Result: User thinks they're in a team but team doesn't list them as member\r\n\r\nOpened https://github.com/BerriAI/litellm/pull/12142 to fix these issues",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2241369247",
    "pr_number": 12438,
    "pr_file": "litellm/proxy/management_endpoints/customer_endpoints.py",
    "created_at": "2025-07-30T17:12:27+00:00",
    "commented_code": "budget_table_data = {}\n         update_end_user_table_data = {}\n         for k, v in non_default_values.items():\n-            if k in LiteLLM_BudgetTable.model_fields.keys():\n+            # budget_id is for linking to existing budget, not for creating new budget\n+            if k == \"budget_id\":\n+                update_end_user_table_data[k] = v\n+            elif k in LiteLLM_BudgetTable.model_fields.keys():\n                 budget_table_data[k] = v\n \n-            if k in LiteLLM_EndUserTable.model_fields.keys():\n+            elif k in LiteLLM_EndUserTable.model_fields.keys():\n                 update_end_user_table_data[k] = v\n \n-        ## Check if budget id is set ##\n+        ## Check if we need to create a new budget (only if budget fields are provided, not just budget_id) ##\n         if budget_table_data:\n             if end_user_budget_table is None:\n                 ## Create new budget ##\n                 budget_table_data_record = (\n                     await prisma_client.db.litellm_budgettable.create(\n-                        data=budget_table_data, include={\"litellm_endusertable\": True}\n+                        data={\n+                            **budget_table_data,\n+                            \"created_by\": user_api_key_dict.user_id\n+                            or litellm_proxy_admin_name,\n+                            \"updated_by\": user_api_key_dict.user_id\n+                            or litellm_proxy_admin_name,\n+                        },\n+                        include={\"end_users\": True},",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2243368421",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12438,
        "pr_file": "litellm/proxy/management_endpoints/customer_endpoints.py",
        "discussion_id": "2241369247",
        "commented_code": "@@ -459,19 +459,29 @@ async def update_end_user(\n         budget_table_data = {}\n         update_end_user_table_data = {}\n         for k, v in non_default_values.items():\n-            if k in LiteLLM_BudgetTable.model_fields.keys():\n+            # budget_id is for linking to existing budget, not for creating new budget\n+            if k == \"budget_id\":\n+                update_end_user_table_data[k] = v\n+            elif k in LiteLLM_BudgetTable.model_fields.keys():\n                 budget_table_data[k] = v\n \n-            if k in LiteLLM_EndUserTable.model_fields.keys():\n+            elif k in LiteLLM_EndUserTable.model_fields.keys():\n                 update_end_user_table_data[k] = v\n \n-        ## Check if budget id is set ##\n+        ## Check if we need to create a new budget (only if budget fields are provided, not just budget_id) ##\n         if budget_table_data:\n             if end_user_budget_table is None:\n                 ## Create new budget ##\n                 budget_table_data_record = (\n                     await prisma_client.db.litellm_budgettable.create(\n-                        data=budget_table_data, include={\"litellm_endusertable\": True}\n+                        data={\n+                            **budget_table_data,\n+                            \"created_by\": user_api_key_dict.user_id\n+                            or litellm_proxy_admin_name,\n+                            \"updated_by\": user_api_key_dict.user_id\n+                            or litellm_proxy_admin_name,\n+                        },\n+                        include={\"end_users\": True},",
        "comment_created_at": "2025-07-30T17:12:27+00:00",
        "comment_author": "jasonpnnl",
        "comment_body": "1.  This is a false positive. As mentioned above, the fix correctly updates the Prisma include parameter to use the proper relation field name as defined in the schema.\r\n2. This is a valid but low-risk concern. The current code should work correctly in practice due to the hardcoded default. Default Value Protection: litellm_proxy_admin_name is set from LITELLM_PROXY_ADMIN_NAME = \"default_user_id\" in constants.py. ",
        "pr_file_module": null
      }
    ]
  }
]