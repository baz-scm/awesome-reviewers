[
  {
    "discussion_id": "2308409469",
    "pr_number": 14042,
    "pr_file": "litellm/proxy/spend_tracking/spend_tracking_utils.py",
    "created_at": "2025-08-28T20:01:17+00:00",
    "commented_code": "Truncates strings longer than 1000 characters and handles nested dictionaries.\n     \"\"\"\n     from litellm.constants import LITELLM_TRUNCATED_PAYLOAD_FIELD\n+\n     MAX_STRING_LENGTH = 1000",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2308409469",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 14042,
        "pr_file": "litellm/proxy/spend_tracking/spend_tracking_utils.py",
        "discussion_id": "2308409469",
        "commented_code": "@@ -484,6 +484,7 @@ def _sanitize_request_body_for_spend_logs_payload(\n     Truncates strings longer than 1000 characters and handles nested dictionaries.\n     \"\"\"\n     from litellm.constants import LITELLM_TRUNCATED_PAYLOAD_FIELD\n+\n     MAX_STRING_LENGTH = 1000",
        "comment_created_at": "2025-08-28T20:01:17+00:00",
        "comment_author": "ishaan-jaff",
        "comment_body": "instead - can you just make `MAX_STRING_LENGTH` a constant in constants.py and control it through a .env \r\n\r\nthat feels cleaner \r\n\r\nyou can call it something like `MAX_STRING_LENGTH_PROMPT_IN_DB` ",
        "pr_file_module": null
      },
      {
        "comment_id": "2308658641",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 14042,
        "pr_file": "litellm/proxy/spend_tracking/spend_tracking_utils.py",
        "discussion_id": "2308409469",
        "commented_code": "@@ -484,6 +484,7 @@ def _sanitize_request_body_for_spend_logs_payload(\n     Truncates strings longer than 1000 characters and handles nested dictionaries.\n     \"\"\"\n     from litellm.constants import LITELLM_TRUNCATED_PAYLOAD_FIELD\n+\n     MAX_STRING_LENGTH = 1000",
        "comment_created_at": "2025-08-28T22:12:21+00:00",
        "comment_author": "WilsonSunBritten",
        "comment_body": "Sure thing. I'll note the big trade-off is control over the max limit size in the db with the current approach, while with this you could end up ~20x larger than what you configure if you have many large sub-prompts in your request. Still for the purposes I'm trying to unblock that works great.",
        "pr_file_module": null
      },
      {
        "comment_id": "2308854732",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 14042,
        "pr_file": "litellm/proxy/spend_tracking/spend_tracking_utils.py",
        "discussion_id": "2308409469",
        "commented_code": "@@ -484,6 +484,7 @@ def _sanitize_request_body_for_spend_logs_payload(\n     Truncates strings longer than 1000 characters and handles nested dictionaries.\n     \"\"\"\n     from litellm.constants import LITELLM_TRUNCATED_PAYLOAD_FIELD\n+\n     MAX_STRING_LENGTH = 1000",
        "comment_created_at": "2025-08-29T00:40:54+00:00",
        "comment_author": "WilsonSunBritten",
        "comment_body": "Done and looking good!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2199596901",
    "pr_number": 12507,
    "pr_file": "litellm/utils.py",
    "created_at": "2025-07-11T05:01:41+00:00",
    "commented_code": "else:\n                 missing_keys.append(\"FEATHERLESS_AI_API_KEY\")\n         elif custom_llm_provider == \"gemini\":\n-            if \"GEMINI_API_KEY\" in os.environ:\n+            if (\"GOOGLE_API_KEY\" in os.environ) or (\"GEMINI_API_KEY\" in os.environ):\n                 keys_in_environment = True\n             else:\n-                missing_keys.append(\"GEMINI_API_KEY\")\n+                missing_keys.append(\"GEMINI_API_KEY/GOOGLE_API_KEY\")",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2199596901",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12507,
        "pr_file": "litellm/utils.py",
        "discussion_id": "2199596901",
        "commented_code": "@@ -5246,10 +5246,10 @@ def validate_environment(  # noqa: PLR0915\n             else:\n                 missing_keys.append(\"FEATHERLESS_AI_API_KEY\")\n         elif custom_llm_provider == \"gemini\":\n-            if \"GEMINI_API_KEY\" in os.environ:\n+            if (\"GOOGLE_API_KEY\" in os.environ) or (\"GEMINI_API_KEY\" in os.environ):\n                 keys_in_environment = True\n             else:\n-                missing_keys.append(\"GEMINI_API_KEY\")\n+                missing_keys.append(\"GEMINI_API_KEY/GOOGLE_API_KEY\")",
        "comment_created_at": "2025-07-11T05:01:41+00:00",
        "comment_author": "krrishdholakia",
        "comment_body": "please append both strings separately",
        "pr_file_module": null
      },
      {
        "comment_id": "2199605453",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12507,
        "pr_file": "litellm/utils.py",
        "discussion_id": "2199596901",
        "commented_code": "@@ -5246,10 +5246,10 @@ def validate_environment(  # noqa: PLR0915\n             else:\n                 missing_keys.append(\"FEATHERLESS_AI_API_KEY\")\n         elif custom_llm_provider == \"gemini\":\n-            if \"GEMINI_API_KEY\" in os.environ:\n+            if (\"GOOGLE_API_KEY\" in os.environ) or (\"GEMINI_API_KEY\" in os.environ):\n                 keys_in_environment = True\n             else:\n-                missing_keys.append(\"GEMINI_API_KEY\")\n+                missing_keys.append(\"GEMINI_API_KEY/GOOGLE_API_KEY\")",
        "comment_created_at": "2025-07-11T05:07:39+00:00",
        "comment_author": "sahusiddharth",
        "comment_body": "will do",
        "pr_file_module": null
      },
      {
        "comment_id": "2199646692",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12507,
        "pr_file": "litellm/utils.py",
        "discussion_id": "2199596901",
        "commented_code": "@@ -5246,10 +5246,10 @@ def validate_environment(  # noqa: PLR0915\n             else:\n                 missing_keys.append(\"FEATHERLESS_AI_API_KEY\")\n         elif custom_llm_provider == \"gemini\":\n-            if \"GEMINI_API_KEY\" in os.environ:\n+            if (\"GOOGLE_API_KEY\" in os.environ) or (\"GEMINI_API_KEY\" in os.environ):\n                 keys_in_environment = True\n             else:\n-                missing_keys.append(\"GEMINI_API_KEY\")\n+                missing_keys.append(\"GEMINI_API_KEY/GOOGLE_API_KEY\")",
        "comment_created_at": "2025-07-11T05:32:19+00:00",
        "comment_author": "sahusiddharth",
        "comment_body": "Hi, I think appending both keys separately is misleading - it implies both are required when only one is needed. \r\nUsers will see \"Missing: GOOGLE_API_KEY, GEMINI_API_KEY\" and can think they need both.\r\n\r\nmissing_keys.append(\"GOOGLE_API_KEY or GEMINI_API_KEY\")\r\n\r\nWhat do you think?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2206434958",
    "pr_number": 12507,
    "pr_file": "litellm/llms/gemini/realtime/transformation.py",
    "created_at": "2025-07-15T05:36:09+00:00",
    "commented_code": "if api_base is None:\n             api_base = \"wss://generativelanguage.googleapis.com\"\n         if api_key is None:\n-            api_key = os.environ.get(\"GEMINI_API_KEY\")\n+            api_key = os.environ.get(\"GOOGLE_API_KEY\") or os.environ.get(\"GEMINI_API_KEY\")",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2206434958",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12507,
        "pr_file": "litellm/llms/gemini/realtime/transformation.py",
        "discussion_id": "2206434958",
        "commented_code": "@@ -81,7 +81,7 @@ def get_complete_url(\n         if api_base is None:\n             api_base = \"wss://generativelanguage.googleapis.com\"\n         if api_key is None:\n-            api_key = os.environ.get(\"GEMINI_API_KEY\")\n+            api_key = os.environ.get(\"GOOGLE_API_KEY\") or os.environ.get(\"GEMINI_API_KEY\")",
        "comment_created_at": "2025-07-15T05:36:09+00:00",
        "comment_author": "krrishdholakia",
        "comment_body": "this approach looks unmaintainable over time (see the number of places the new env var was added to)\r\n\r\n\r\ncan we instead use a helper function - maybe inside `llms/gemini/common_utils.py` - and use that? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2207014742",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12507,
        "pr_file": "litellm/llms/gemini/realtime/transformation.py",
        "discussion_id": "2206434958",
        "commented_code": "@@ -81,7 +81,7 @@ def get_complete_url(\n         if api_base is None:\n             api_base = \"wss://generativelanguage.googleapis.com\"\n         if api_key is None:\n-            api_key = os.environ.get(\"GEMINI_API_KEY\")\n+            api_key = os.environ.get(\"GOOGLE_API_KEY\") or os.environ.get(\"GEMINI_API_KEY\")",
        "comment_created_at": "2025-07-15T09:48:07+00:00",
        "comment_author": "sahusiddharth",
        "comment_body": "Let me know if the changes that I made was something you had in mind, if you have any suggestion or better approach let me know",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196155585",
    "pr_number": 12426,
    "pr_file": "litellm/llms/bedrock/base_aws_llm.py",
    "created_at": "2025-07-09T23:02:10+00:00",
    "commented_code": "aws_region_name: str,\n         extra_headers: Optional[dict],\n         endpoint_url: str,\n-        data: str,\n+        data: Union[str, bytes],\n         headers: dict,\n+        api_key: Optional[str] = None,\n     ) -> AWSPreparedRequest:\n-        try:\n-            from botocore.auth import SigV4Auth\n-            from botocore.awsrequest import AWSRequest\n-        except ImportError:\n-            raise ImportError(\"Missing boto3 to call bedrock. Run 'pip install boto3'.\")\n-\n-        sigv4 = SigV4Auth(credentials, \"bedrock\", aws_region_name)\n-\n-        request = AWSRequest(\n-            method=\"POST\", url=endpoint_url, data=data, headers=headers\n-        )\n-        sigv4.add_auth(request)\n-        if (\n-            extra_headers is not None and \"Authorization\" in extra_headers\n-        ):  # prevent sigv4 from overwriting the auth header\n-            request.headers[\"Authorization\"] = extra_headers[\"Authorization\"]\n+        if api_key is not None:\n+            aws_bearer_token: Optional[str] = api_key\n+        else:\n+            aws_bearer_token = os.environ.get(\"AWS_BEARER_TOKEN_BEDROCK\")",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2196155585",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12426,
        "pr_file": "litellm/llms/bedrock/base_aws_llm.py",
        "discussion_id": "2196155585",
        "commented_code": "@@ -670,25 +671,39 @@ def get_request_headers(\n         aws_region_name: str,\n         extra_headers: Optional[dict],\n         endpoint_url: str,\n-        data: str,\n+        data: Union[str, bytes],\n         headers: dict,\n+        api_key: Optional[str] = None,\n     ) -> AWSPreparedRequest:\n-        try:\n-            from botocore.auth import SigV4Auth\n-            from botocore.awsrequest import AWSRequest\n-        except ImportError:\n-            raise ImportError(\"Missing boto3 to call bedrock. Run 'pip install boto3'.\")\n-\n-        sigv4 = SigV4Auth(credentials, \"bedrock\", aws_region_name)\n-\n-        request = AWSRequest(\n-            method=\"POST\", url=endpoint_url, data=data, headers=headers\n-        )\n-        sigv4.add_auth(request)\n-        if (\n-            extra_headers is not None and \"Authorization\" in extra_headers\n-        ):  # prevent sigv4 from overwriting the auth header\n-            request.headers[\"Authorization\"] = extra_headers[\"Authorization\"]\n+        if api_key is not None:\n+            aws_bearer_token: Optional[str] = api_key\n+        else:\n+            aws_bearer_token = os.environ.get(\"AWS_BEARER_TOKEN_BEDROCK\")",
        "comment_created_at": "2025-07-09T23:02:10+00:00",
        "comment_author": "ishaan-jaff",
        "comment_body": "`os.environ.get(\"AWS_BEARER_TOKEN_BEDROCK\")` \r\n\r\nuse get_secret_str util from litellm here ",
        "pr_file_module": null
      },
      {
        "comment_id": "2196267200",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12426,
        "pr_file": "litellm/llms/bedrock/base_aws_llm.py",
        "discussion_id": "2196155585",
        "commented_code": "@@ -670,25 +671,39 @@ def get_request_headers(\n         aws_region_name: str,\n         extra_headers: Optional[dict],\n         endpoint_url: str,\n-        data: str,\n+        data: Union[str, bytes],\n         headers: dict,\n+        api_key: Optional[str] = None,\n     ) -> AWSPreparedRequest:\n-        try:\n-            from botocore.auth import SigV4Auth\n-            from botocore.awsrequest import AWSRequest\n-        except ImportError:\n-            raise ImportError(\"Missing boto3 to call bedrock. Run 'pip install boto3'.\")\n-\n-        sigv4 = SigV4Auth(credentials, \"bedrock\", aws_region_name)\n-\n-        request = AWSRequest(\n-            method=\"POST\", url=endpoint_url, data=data, headers=headers\n-        )\n-        sigv4.add_auth(request)\n-        if (\n-            extra_headers is not None and \"Authorization\" in extra_headers\n-        ):  # prevent sigv4 from overwriting the auth header\n-            request.headers[\"Authorization\"] = extra_headers[\"Authorization\"]\n+        if api_key is not None:\n+            aws_bearer_token: Optional[str] = api_key\n+        else:\n+            aws_bearer_token = os.environ.get(\"AWS_BEARER_TOKEN_BEDROCK\")",
        "comment_created_at": "2025-07-10T00:47:46+00:00",
        "comment_author": "0x-fang",
        "comment_body": "thank you, will fix it. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172276211",
    "pr_number": 12092,
    "pr_file": "litellm/proxy/utils.py",
    "created_at": "2025-06-27T15:21:41+00:00",
    "commented_code": "return error_message\n \n \n-def _get_redoc_url() -> str:\n+def _get_redoc_url() -> Optional[str]:\n     \"\"\"\n-    Get the redoc URL from the environment variables.\n+    Get the Redoc URL from the environment variables.\n \n     - If REDOC_URL is set, return it.\n+    - If NO_REDOC is True, return None.\n     - Otherwise, default to \"/redoc\".\n     \"\"\"\n-    return os.getenv(\"REDOC_URL\", \"/redoc\")\n+    redoc_url = os.getenv(\"REDOC_URL\", None)\n+    if redoc_url:\n+        return redoc_url\n+    \n+    if os.getenv(\"NO_REDOC\", \"False\") == \"True\":",
    "repo_full_name": "BerriAI/litellm",
    "discussion_comments": [
      {
        "comment_id": "2172276211",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12092,
        "pr_file": "litellm/proxy/utils.py",
        "discussion_id": "2172276211",
        "commented_code": "@@ -2987,19 +2987,27 @@ def get_error_message_str(e: Exception) -> str:\n     return error_message\n \n \n-def _get_redoc_url() -> str:\n+def _get_redoc_url() -> Optional[str]:\n     \"\"\"\n-    Get the redoc URL from the environment variables.\n+    Get the Redoc URL from the environment variables.\n \n     - If REDOC_URL is set, return it.\n+    - If NO_REDOC is True, return None.\n     - Otherwise, default to \"/redoc\".\n     \"\"\"\n-    return os.getenv(\"REDOC_URL\", \"/redoc\")\n+    redoc_url = os.getenv(\"REDOC_URL\", None)\n+    if redoc_url:\n+        return redoc_url\n+    \n+    if os.getenv(\"NO_REDOC\", \"False\") == \"True\":",
        "comment_created_at": "2025-06-27T15:21:41+00:00",
        "comment_author": "ishaan-jaff",
        "comment_body": "please us str_to_bool we use this in our codebase for reading env vars ",
        "pr_file_module": null
      },
      {
        "comment_id": "2173094821",
        "repo_full_name": "BerriAI/litellm",
        "pr_number": 12092,
        "pr_file": "litellm/proxy/utils.py",
        "discussion_id": "2172276211",
        "commented_code": "@@ -2987,19 +2987,27 @@ def get_error_message_str(e: Exception) -> str:\n     return error_message\n \n \n-def _get_redoc_url() -> str:\n+def _get_redoc_url() -> Optional[str]:\n     \"\"\"\n-    Get the redoc URL from the environment variables.\n+    Get the Redoc URL from the environment variables.\n \n     - If REDOC_URL is set, return it.\n+    - If NO_REDOC is True, return None.\n     - Otherwise, default to \"/redoc\".\n     \"\"\"\n-    return os.getenv(\"REDOC_URL\", \"/redoc\")\n+    redoc_url = os.getenv(\"REDOC_URL\", None)\n+    if redoc_url:\n+        return redoc_url\n+    \n+    if os.getenv(\"NO_REDOC\", \"False\") == \"True\":",
        "comment_created_at": "2025-06-28T02:47:02+00:00",
        "comment_author": "zhangyoufu",
        "comment_body": "Done.\r\n\r\nIMHO, current implementation of `str_to_bool` should be called `str_to_optional_bool`. A real `str_to_bool` should require a `default` boolean argument and never returns None. It's ugly we pass a boolean string default value to `os.getenv`.\r\n\r\nI would prefer\r\n```\r\nstr_to_bool(os.getenv(\"DISABLE_AIOHTTP_TRANSPORT\"), default=False)\r\n```\r\nthan\r\n```\r\nstr_to_bool(os.getenv(\"DISABLE_AIOHTTP_TRANSPORT\", \"False\")) is True\r\n```",
        "pr_file_module": null
      }
    ]
  }
]