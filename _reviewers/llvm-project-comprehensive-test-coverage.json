[
  {
    "discussion_id": "2214136708",
    "pr_number": 148948,
    "pr_file": "libc/test/integration/src/pthread/pthread_barrier_test.cpp",
    "created_at": "2025-07-17T19:34:11+00:00",
    "commented_code": "+//===-- Tests for pthread_barrier_t ---------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/pthread/pthread_barrier_destroy.h\"\n+#include \"src/pthread/pthread_barrier_init.h\"\n+#include \"src/pthread/pthread_barrier_wait.h\"\n+\n+#include \"src/__support/CPP/atomic.h\"\n+#include \"src/pthread/pthread_create.h\"\n+#include \"src/pthread/pthread_join.h\"\n+#include \"src/pthread/pthread_mutex_destroy.h\"\n+#include \"src/pthread/pthread_mutex_init.h\"\n+#include \"src/pthread/pthread_mutex_lock.h\"\n+#include \"src/pthread/pthread_mutex_unlock.h\"\n+#include \"src/stdio/printf.h\"\n+\n+#include \"test/IntegrationTest/test.h\"\n+\n+#include <pthread.h>\n+\n+pthread_barrier_t barrier;\n+\n+void smoke_test() {\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_init(&barrier, nullptr, 1), 0);\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_wait(&barrier),\n+            PTHREAD_BARRIER_SERIAL_THREAD);\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_destroy(&barrier), 0);\n+}\n+\n+LIBC_NAMESPACE::cpp::Atomic<int> counter;\n+void *increment_counter_and_wait(void *args) {\n+  counter.fetch_add(1);\n+  LIBC_NAMESPACE::pthread_barrier_wait(&barrier);",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214136708",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148948,
        "pr_file": "libc/test/integration/src/pthread/pthread_barrier_test.cpp",
        "discussion_id": "2214136708",
        "commented_code": "@@ -0,0 +1,117 @@\n+//===-- Tests for pthread_barrier_t ---------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/pthread/pthread_barrier_destroy.h\"\n+#include \"src/pthread/pthread_barrier_init.h\"\n+#include \"src/pthread/pthread_barrier_wait.h\"\n+\n+#include \"src/__support/CPP/atomic.h\"\n+#include \"src/pthread/pthread_create.h\"\n+#include \"src/pthread/pthread_join.h\"\n+#include \"src/pthread/pthread_mutex_destroy.h\"\n+#include \"src/pthread/pthread_mutex_init.h\"\n+#include \"src/pthread/pthread_mutex_lock.h\"\n+#include \"src/pthread/pthread_mutex_unlock.h\"\n+#include \"src/stdio/printf.h\"\n+\n+#include \"test/IntegrationTest/test.h\"\n+\n+#include <pthread.h>\n+\n+pthread_barrier_t barrier;\n+\n+void smoke_test() {\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_init(&barrier, nullptr, 1), 0);\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_wait(&barrier),\n+            PTHREAD_BARRIER_SERIAL_THREAD);\n+  ASSERT_EQ(LIBC_NAMESPACE::pthread_barrier_destroy(&barrier), 0);\n+}\n+\n+LIBC_NAMESPACE::cpp::Atomic<int> counter;\n+void *increment_counter_and_wait(void *args) {\n+  counter.fetch_add(1);\n+  LIBC_NAMESPACE::pthread_barrier_wait(&barrier);",
        "comment_created_at": "2025-07-17T19:34:11+00:00",
        "comment_author": "brooksmoses",
        "comment_body": "This could check the return value as well, and then you wouldn't need your separate `one_nonzero_wait_returnval` test.\r\n\r\nI'd suggest adding a second counter, which you increment if and only if the return value is `PTHREAD_BARRIER_SERIAL_THREAD`, and otherwise assert that the return value is 0.  Then after the threads are joined you can check that this second counter has a value of 1.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2099746077",
    "pr_number": 140158,
    "pr_file": "llvm/lib/Transforms/HipStdPar/HipStdPar.cpp",
    "created_at": "2025-05-21T08:53:56+00:00",
    "commented_code": "return PreservedAnalyses::none();\n }\n+\n+static constexpr std::pair<StringLiteral, StringLiteral> MathLibToHipStdPar[]{\n+    {\"acosh\", \"__hipstdpar_acosh_f64\"},\n+    {\"acoshf\", \"__hipstdpar_acosh_f32\"},\n+    {\"asinh\", \"__hipstdpar_asinh_f64\"},\n+    {\"asinhf\", \"__hipstdpar_asinh_f32\"},\n+    {\"atanh\", \"__hipstdpar_atanh_f64\"},\n+    {\"atanhf\", \"__hipstdpar_atanh_f32\"},\n+    {\"cbrt\", \"__hipstdpar_cbrt_f64\"},\n+    {\"cbrtf\", \"__hipstdpar_cbrt_f32\"},\n+    {\"erf\", \"__hipstdpar_erf_f64\"},\n+    {\"erff\", \"__hipstdpar_erf_f32\"},\n+    {\"erfc\", \"__hipstdpar_erfc_f64\"},\n+    {\"erfcf\", \"__hipstdpar_erfc_f32\"},\n+    {\"fdim\", \"__hipstdpar_fdim_f64\"},\n+    {\"fdimf\", \"__hipstdpar_fdim_f32\"},\n+    {\"expm1\", \"__hipstdpar_expm1_f64\"},\n+    {\"expm1f\", \"__hipstdpar_expm1_f32\"},\n+    {\"hypot\", \"__hipstdpar_hypot_f64\"},\n+    {\"hypotf\", \"__hipstdpar_hypot_f32\"},\n+    {\"ilogb\", \"__hipstdpar_ilogb_f64\"},\n+    {\"ilogbf\", \"__hipstdpar_ilogb_f32\"},\n+    {\"lgamma\", \"__hipstdpar_lgamma_f64\"},\n+    {\"lgammaf\", \"__hipstdpar_lgamma_f32\"},\n+    {\"log1p\", \"__hipstdpar_log1p_f64\"},\n+    {\"log1pf\", \"__hipstdpar_log1p_f32\"},\n+    {\"logb\", \"__hipstdpar_logb_f64\"},\n+    {\"logbf\", \"__hipstdpar_logb_f32\"},\n+    {\"nextafter\", \"__hipstdpar_nextafter_f64\"},\n+    {\"nextafterf\", \"__hipstdpar_nextafter_f32\"},\n+    {\"nexttoward\", \"__hipstdpar_nexttoward_f64\"},\n+    {\"nexttowardf\", \"__hipstdpar_nexttoward_f32\"},\n+    {\"remainder\", \"__hipstdpar_remainder_f64\"},\n+    {\"remainderf\", \"__hipstdpar_remainder_f32\"},\n+    {\"remquo\", \"__hipstdpar_remquo_f64\"},\n+    {\"remquof\", \"__hipstdpar_remquo_f32\"},\n+    {\"scalbln\", \"__hipstdpar_scalbln_f64\"},\n+    {\"scalblnf\", \"__hipstdpar_scalbln_f32\"},\n+    {\"scalbn\", \"__hipstdpar_scalbn_f64\"},\n+    {\"scalbnf\", \"__hipstdpar_scalbn_f32\"},\n+    {\"tgamma\", \"__hipstdpar_tgamma_f64\"},\n+    {\"tgammaf\", \"__hipstdpar_tgamma_f32\"}};\n+\n+PreservedAnalyses HipStdParMathFixupPass::run(Module &M,\n+                                              ModuleAnalysisManager &) {\n+  if (M.empty())\n+    return PreservedAnalyses::all();\n+\n+  SmallVector<std::pair<Function *, std::string>> ToReplace;\n+  for (auto &&F : M) {\n+    if (!F.hasName())\n+      continue;\n+\n+    StringRef N = F.getName();\n+    Intrinsic::ID ID = F.getIntrinsicID();\n+\n+    switch (ID) {\n+    case Intrinsic::not_intrinsic: {\n+      auto It =\n+          find_if(MathLibToHipStdPar, [&](auto &&M) { return M.first == N; });\n+      if (It == std::cend(MathLibToHipStdPar))\n+        continue;\n+      ToReplace.emplace_back(&F, It->second);\n+      break;\n+    }\n+    case Intrinsic::acos:\n+    case Intrinsic::asin:\n+    case Intrinsic::atan:\n+    case Intrinsic::atan2:\n+    case Intrinsic::cosh:\n+    case Intrinsic::modf:\n+    case Intrinsic::sinh:\n+    case Intrinsic::tan:\n+    case Intrinsic::tanh:\n+      break;\n+    default: {\n+      if (F.getReturnType()->isDoubleTy()) {\n+        switch (ID) {\n+        case Intrinsic::cos:\n+        case Intrinsic::exp:\n+        case Intrinsic::exp2:\n+        case Intrinsic::log:\n+        case Intrinsic::log10:\n+        case Intrinsic::log2:\n+        case Intrinsic::pow:\n+        case Intrinsic::sin:\n+          break;\n+        default:\n+          continue;\n+        }\n+        break;\n+      }\n+      continue;\n+    }\n+    }\n+\n+    ToReplace.emplace_back(&F, N);\n+    llvm::replace(ToReplace.back().second, '.', '_');\n+    StringRef Prefix = \"llvm\";\n+    ToReplace.back().second.replace(0, Prefix.size(), \"__hipstdpar\");\n+  }\n+  for (auto &&F : ToReplace)\n+    F.first->replaceAllUsesWith(",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2099746077",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140158,
        "pr_file": "llvm/lib/Transforms/HipStdPar/HipStdPar.cpp",
        "discussion_id": "2099746077",
        "commented_code": "@@ -321,3 +332,111 @@ HipStdParAllocationInterpositionPass::run(Module &M, ModuleAnalysisManager&) {\n \n   return PreservedAnalyses::none();\n }\n+\n+static constexpr std::pair<StringLiteral, StringLiteral> MathLibToHipStdPar[]{\n+    {\"acosh\", \"__hipstdpar_acosh_f64\"},\n+    {\"acoshf\", \"__hipstdpar_acosh_f32\"},\n+    {\"asinh\", \"__hipstdpar_asinh_f64\"},\n+    {\"asinhf\", \"__hipstdpar_asinh_f32\"},\n+    {\"atanh\", \"__hipstdpar_atanh_f64\"},\n+    {\"atanhf\", \"__hipstdpar_atanh_f32\"},\n+    {\"cbrt\", \"__hipstdpar_cbrt_f64\"},\n+    {\"cbrtf\", \"__hipstdpar_cbrt_f32\"},\n+    {\"erf\", \"__hipstdpar_erf_f64\"},\n+    {\"erff\", \"__hipstdpar_erf_f32\"},\n+    {\"erfc\", \"__hipstdpar_erfc_f64\"},\n+    {\"erfcf\", \"__hipstdpar_erfc_f32\"},\n+    {\"fdim\", \"__hipstdpar_fdim_f64\"},\n+    {\"fdimf\", \"__hipstdpar_fdim_f32\"},\n+    {\"expm1\", \"__hipstdpar_expm1_f64\"},\n+    {\"expm1f\", \"__hipstdpar_expm1_f32\"},\n+    {\"hypot\", \"__hipstdpar_hypot_f64\"},\n+    {\"hypotf\", \"__hipstdpar_hypot_f32\"},\n+    {\"ilogb\", \"__hipstdpar_ilogb_f64\"},\n+    {\"ilogbf\", \"__hipstdpar_ilogb_f32\"},\n+    {\"lgamma\", \"__hipstdpar_lgamma_f64\"},\n+    {\"lgammaf\", \"__hipstdpar_lgamma_f32\"},\n+    {\"log1p\", \"__hipstdpar_log1p_f64\"},\n+    {\"log1pf\", \"__hipstdpar_log1p_f32\"},\n+    {\"logb\", \"__hipstdpar_logb_f64\"},\n+    {\"logbf\", \"__hipstdpar_logb_f32\"},\n+    {\"nextafter\", \"__hipstdpar_nextafter_f64\"},\n+    {\"nextafterf\", \"__hipstdpar_nextafter_f32\"},\n+    {\"nexttoward\", \"__hipstdpar_nexttoward_f64\"},\n+    {\"nexttowardf\", \"__hipstdpar_nexttoward_f32\"},\n+    {\"remainder\", \"__hipstdpar_remainder_f64\"},\n+    {\"remainderf\", \"__hipstdpar_remainder_f32\"},\n+    {\"remquo\", \"__hipstdpar_remquo_f64\"},\n+    {\"remquof\", \"__hipstdpar_remquo_f32\"},\n+    {\"scalbln\", \"__hipstdpar_scalbln_f64\"},\n+    {\"scalblnf\", \"__hipstdpar_scalbln_f32\"},\n+    {\"scalbn\", \"__hipstdpar_scalbn_f64\"},\n+    {\"scalbnf\", \"__hipstdpar_scalbn_f32\"},\n+    {\"tgamma\", \"__hipstdpar_tgamma_f64\"},\n+    {\"tgammaf\", \"__hipstdpar_tgamma_f32\"}};\n+\n+PreservedAnalyses HipStdParMathFixupPass::run(Module &M,\n+                                              ModuleAnalysisManager &) {\n+  if (M.empty())\n+    return PreservedAnalyses::all();\n+\n+  SmallVector<std::pair<Function *, std::string>> ToReplace;\n+  for (auto &&F : M) {\n+    if (!F.hasName())\n+      continue;\n+\n+    StringRef N = F.getName();\n+    Intrinsic::ID ID = F.getIntrinsicID();\n+\n+    switch (ID) {\n+    case Intrinsic::not_intrinsic: {\n+      auto It =\n+          find_if(MathLibToHipStdPar, [&](auto &&M) { return M.first == N; });\n+      if (It == std::cend(MathLibToHipStdPar))\n+        continue;\n+      ToReplace.emplace_back(&F, It->second);\n+      break;\n+    }\n+    case Intrinsic::acos:\n+    case Intrinsic::asin:\n+    case Intrinsic::atan:\n+    case Intrinsic::atan2:\n+    case Intrinsic::cosh:\n+    case Intrinsic::modf:\n+    case Intrinsic::sinh:\n+    case Intrinsic::tan:\n+    case Intrinsic::tanh:\n+      break;\n+    default: {\n+      if (F.getReturnType()->isDoubleTy()) {\n+        switch (ID) {\n+        case Intrinsic::cos:\n+        case Intrinsic::exp:\n+        case Intrinsic::exp2:\n+        case Intrinsic::log:\n+        case Intrinsic::log10:\n+        case Intrinsic::log2:\n+        case Intrinsic::pow:\n+        case Intrinsic::sin:\n+          break;\n+        default:\n+          continue;\n+        }\n+        break;\n+      }\n+      continue;\n+    }\n+    }\n+\n+    ToReplace.emplace_back(&F, N);\n+    llvm::replace(ToReplace.back().second, '.', '_');\n+    StringRef Prefix = \"llvm\";\n+    ToReplace.back().second.replace(0, Prefix.size(), \"__hipstdpar\");\n+  }\n+  for (auto &&F : ToReplace)\n+    F.first->replaceAllUsesWith(",
        "comment_created_at": "2025-05-21T08:53:56+00:00",
        "comment_author": "arsenm",
        "comment_body": "Can you also add a test with some abnormal transformed function uses? i.e. address capturing stores, call sites with the wrong signature, global initializer?",
        "pr_file_module": null
      },
      {
        "comment_id": "2150908461",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140158,
        "pr_file": "llvm/lib/Transforms/HipStdPar/HipStdPar.cpp",
        "discussion_id": "2099746077",
        "commented_code": "@@ -321,3 +332,111 @@ HipStdParAllocationInterpositionPass::run(Module &M, ModuleAnalysisManager&) {\n \n   return PreservedAnalyses::none();\n }\n+\n+static constexpr std::pair<StringLiteral, StringLiteral> MathLibToHipStdPar[]{\n+    {\"acosh\", \"__hipstdpar_acosh_f64\"},\n+    {\"acoshf\", \"__hipstdpar_acosh_f32\"},\n+    {\"asinh\", \"__hipstdpar_asinh_f64\"},\n+    {\"asinhf\", \"__hipstdpar_asinh_f32\"},\n+    {\"atanh\", \"__hipstdpar_atanh_f64\"},\n+    {\"atanhf\", \"__hipstdpar_atanh_f32\"},\n+    {\"cbrt\", \"__hipstdpar_cbrt_f64\"},\n+    {\"cbrtf\", \"__hipstdpar_cbrt_f32\"},\n+    {\"erf\", \"__hipstdpar_erf_f64\"},\n+    {\"erff\", \"__hipstdpar_erf_f32\"},\n+    {\"erfc\", \"__hipstdpar_erfc_f64\"},\n+    {\"erfcf\", \"__hipstdpar_erfc_f32\"},\n+    {\"fdim\", \"__hipstdpar_fdim_f64\"},\n+    {\"fdimf\", \"__hipstdpar_fdim_f32\"},\n+    {\"expm1\", \"__hipstdpar_expm1_f64\"},\n+    {\"expm1f\", \"__hipstdpar_expm1_f32\"},\n+    {\"hypot\", \"__hipstdpar_hypot_f64\"},\n+    {\"hypotf\", \"__hipstdpar_hypot_f32\"},\n+    {\"ilogb\", \"__hipstdpar_ilogb_f64\"},\n+    {\"ilogbf\", \"__hipstdpar_ilogb_f32\"},\n+    {\"lgamma\", \"__hipstdpar_lgamma_f64\"},\n+    {\"lgammaf\", \"__hipstdpar_lgamma_f32\"},\n+    {\"log1p\", \"__hipstdpar_log1p_f64\"},\n+    {\"log1pf\", \"__hipstdpar_log1p_f32\"},\n+    {\"logb\", \"__hipstdpar_logb_f64\"},\n+    {\"logbf\", \"__hipstdpar_logb_f32\"},\n+    {\"nextafter\", \"__hipstdpar_nextafter_f64\"},\n+    {\"nextafterf\", \"__hipstdpar_nextafter_f32\"},\n+    {\"nexttoward\", \"__hipstdpar_nexttoward_f64\"},\n+    {\"nexttowardf\", \"__hipstdpar_nexttoward_f32\"},\n+    {\"remainder\", \"__hipstdpar_remainder_f64\"},\n+    {\"remainderf\", \"__hipstdpar_remainder_f32\"},\n+    {\"remquo\", \"__hipstdpar_remquo_f64\"},\n+    {\"remquof\", \"__hipstdpar_remquo_f32\"},\n+    {\"scalbln\", \"__hipstdpar_scalbln_f64\"},\n+    {\"scalblnf\", \"__hipstdpar_scalbln_f32\"},\n+    {\"scalbn\", \"__hipstdpar_scalbn_f64\"},\n+    {\"scalbnf\", \"__hipstdpar_scalbn_f32\"},\n+    {\"tgamma\", \"__hipstdpar_tgamma_f64\"},\n+    {\"tgammaf\", \"__hipstdpar_tgamma_f32\"}};\n+\n+PreservedAnalyses HipStdParMathFixupPass::run(Module &M,\n+                                              ModuleAnalysisManager &) {\n+  if (M.empty())\n+    return PreservedAnalyses::all();\n+\n+  SmallVector<std::pair<Function *, std::string>> ToReplace;\n+  for (auto &&F : M) {\n+    if (!F.hasName())\n+      continue;\n+\n+    StringRef N = F.getName();\n+    Intrinsic::ID ID = F.getIntrinsicID();\n+\n+    switch (ID) {\n+    case Intrinsic::not_intrinsic: {\n+      auto It =\n+          find_if(MathLibToHipStdPar, [&](auto &&M) { return M.first == N; });\n+      if (It == std::cend(MathLibToHipStdPar))\n+        continue;\n+      ToReplace.emplace_back(&F, It->second);\n+      break;\n+    }\n+    case Intrinsic::acos:\n+    case Intrinsic::asin:\n+    case Intrinsic::atan:\n+    case Intrinsic::atan2:\n+    case Intrinsic::cosh:\n+    case Intrinsic::modf:\n+    case Intrinsic::sinh:\n+    case Intrinsic::tan:\n+    case Intrinsic::tanh:\n+      break;\n+    default: {\n+      if (F.getReturnType()->isDoubleTy()) {\n+        switch (ID) {\n+        case Intrinsic::cos:\n+        case Intrinsic::exp:\n+        case Intrinsic::exp2:\n+        case Intrinsic::log:\n+        case Intrinsic::log10:\n+        case Intrinsic::log2:\n+        case Intrinsic::pow:\n+        case Intrinsic::sin:\n+          break;\n+        default:\n+          continue;\n+        }\n+        break;\n+      }\n+      continue;\n+    }\n+    }\n+\n+    ToReplace.emplace_back(&F, N);\n+    llvm::replace(ToReplace.back().second, '.', '_');\n+    StringRef Prefix = \"llvm\";\n+    ToReplace.back().second.replace(0, Prefix.size(), \"__hipstdpar\");\n+  }\n+  for (auto &&F : ToReplace)\n+    F.first->replaceAllUsesWith(",
        "comment_created_at": "2025-06-16T21:19:47+00:00",
        "comment_author": "AlexVlx",
        "comment_body": "I most definitely can but could you please clarify the middle scenario - what would a call site with the wrong signature look like / where would it originate, given that these would originate from well formed correct HLL invocations of math lib interfaces, which have passed the FE and are thus linguistically correct? Perhaps I am missing something obvious here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164482905",
    "pr_number": 140282,
    "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
    "created_at": "2025-06-24T16:49:33+00:00",
    "commented_code": "+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s\n+\n+// Semantic tests for sycl_external attribute\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+static void func1() {}\n+\n+namespace {\n+  [[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func2() {}\n+\n+  struct UnnX {};\n+}\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func4(UnnX) {}\n+\n+// FIXME: The first declaration of a function is required to have the attribute.\n+// The attribute may be optionally present on subsequent declarations\n+int foo(int c);\n+\n+[[clang::sycl_external]] void foo();\n+\n+class C {\n+  [[clang::sycl_external]] void member();\n+};\n+\n+[[clang::sycl_external]] int main() // expected-error {{'sycl_external' cannot be applied to main function}}\n+{\n+    return 0;\n+}\n+\n+class D {\n+  [[clang::sycl_external]] void del() = delete; // expected-error {{'sycl_external' cannot be applied to explicitly deleted functions}}\n+};\n+\n+class A {\n+  [[clang::sycl_external]]\n+  A() {}\n+\n+  [[clang::sycl_external]] void func3() {}\n+};\n+\n+class B {\n+public:\n+  [[clang::sycl_external]] virtual void foo() {}\n+\n+  [[clang::sycl_external]] virtual void bar() = 0;\n+};\n+\n+[[clang::sycl_external]] int *func0() { return nullptr; }\n+\n+[[clang::sycl_external]] void func2(int *) {}\n+",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2164482905",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
        "discussion_id": "2164482905",
        "commented_code": "@@ -0,0 +1,54 @@\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s\n+\n+// Semantic tests for sycl_external attribute\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+static void func1() {}\n+\n+namespace {\n+  [[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func2() {}\n+\n+  struct UnnX {};\n+}\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func4(UnnX) {}\n+\n+// FIXME: The first declaration of a function is required to have the attribute.\n+// The attribute may be optionally present on subsequent declarations\n+int foo(int c);\n+\n+[[clang::sycl_external]] void foo();\n+\n+class C {\n+  [[clang::sycl_external]] void member();\n+};\n+\n+[[clang::sycl_external]] int main() // expected-error {{'sycl_external' cannot be applied to main function}}\n+{\n+    return 0;\n+}\n+\n+class D {\n+  [[clang::sycl_external]] void del() = delete; // expected-error {{'sycl_external' cannot be applied to explicitly deleted functions}}\n+};\n+\n+class A {\n+  [[clang::sycl_external]]\n+  A() {}\n+\n+  [[clang::sycl_external]] void func3() {}\n+};\n+\n+class B {\n+public:\n+  [[clang::sycl_external]] virtual void foo() {}\n+\n+  [[clang::sycl_external]] virtual void bar() = 0;\n+};\n+\n+[[clang::sycl_external]] int *func0() { return nullptr; }\n+\n+[[clang::sycl_external]] void func2(int *) {}\n+",
        "comment_created_at": "2025-06-24T16:49:33+00:00",
        "comment_author": "tahonermann",
        "comment_body": "Let's add tests for functions declared `constexpr` and `consteval` as well. `consteval` requires C++20, so the `RUN` line will have to be updated accordingly. I suggest running the test for both C++17 and C++20 with the portion that exercises C++20 features appropriately #ifdef'd.\r\n\r\nI wonder if we should reject use of the attribute with functions declared `consteval` since no symbols are emitted for such functions. I'm on the fence since the attribute doesn't do any harm there. Perhaps a warning about a useless attribute use would be appropriate?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198735537",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
        "discussion_id": "2164482905",
        "commented_code": "@@ -0,0 +1,54 @@\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s\n+\n+// Semantic tests for sycl_external attribute\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+static void func1() {}\n+\n+namespace {\n+  [[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func2() {}\n+\n+  struct UnnX {};\n+}\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func4(UnnX) {}\n+\n+// FIXME: The first declaration of a function is required to have the attribute.\n+// The attribute may be optionally present on subsequent declarations\n+int foo(int c);\n+\n+[[clang::sycl_external]] void foo();\n+\n+class C {\n+  [[clang::sycl_external]] void member();\n+};\n+\n+[[clang::sycl_external]] int main() // expected-error {{'sycl_external' cannot be applied to main function}}\n+{\n+    return 0;\n+}\n+\n+class D {\n+  [[clang::sycl_external]] void del() = delete; // expected-error {{'sycl_external' cannot be applied to explicitly deleted functions}}\n+};\n+\n+class A {\n+  [[clang::sycl_external]]\n+  A() {}\n+\n+  [[clang::sycl_external]] void func3() {}\n+};\n+\n+class B {\n+public:\n+  [[clang::sycl_external]] virtual void foo() {}\n+\n+  [[clang::sycl_external]] virtual void bar() = 0;\n+};\n+\n+[[clang::sycl_external]] int *func0() { return nullptr; }\n+\n+[[clang::sycl_external]] void func2(int *) {}\n+",
        "comment_created_at": "2025-07-10T21:00:47+00:00",
        "comment_author": "schittir",
        "comment_body": "Added constexpr and consteval tests here 45f7b09b282750d5f3dde549961ad7b5fc0434a5. \r\nAdding a warning for the consteval would make it more thorough, of course, but I don't know if there is value beyond that. I can certainly add it!  \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2202191427",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
        "discussion_id": "2164482905",
        "commented_code": "@@ -0,0 +1,54 @@\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s\n+\n+// Semantic tests for sycl_external attribute\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+static void func1() {}\n+\n+namespace {\n+  [[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func2() {}\n+\n+  struct UnnX {};\n+}\n+\n+[[clang::sycl_external]] // expected-error {{'sycl_external' can only be applied to functions with external linkage}}\n+  void func4(UnnX) {}\n+\n+// FIXME: The first declaration of a function is required to have the attribute.\n+// The attribute may be optionally present on subsequent declarations\n+int foo(int c);\n+\n+[[clang::sycl_external]] void foo();\n+\n+class C {\n+  [[clang::sycl_external]] void member();\n+};\n+\n+[[clang::sycl_external]] int main() // expected-error {{'sycl_external' cannot be applied to main function}}\n+{\n+    return 0;\n+}\n+\n+class D {\n+  [[clang::sycl_external]] void del() = delete; // expected-error {{'sycl_external' cannot be applied to explicitly deleted functions}}\n+};\n+\n+class A {\n+  [[clang::sycl_external]]\n+  A() {}\n+\n+  [[clang::sycl_external]] void func3() {}\n+};\n+\n+class B {\n+public:\n+  [[clang::sycl_external]] virtual void foo() {}\n+\n+  [[clang::sycl_external]] virtual void bar() = 0;\n+};\n+\n+[[clang::sycl_external]] int *func0() { return nullptr; }\n+\n+[[clang::sycl_external]] void func2(int *) {}\n+",
        "comment_created_at": "2025-07-12T00:27:37+00:00",
        "comment_author": "tahonermann",
        "comment_body": "Yeah, let's not bother with a warning for use with `consteval`. That would probably be considered excessive nannying.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214190869",
    "pr_number": 140282,
    "pr_file": "clang/test/SemaSYCL/sycl-external-attr-appertainment.cpp",
    "created_at": "2025-07-17T20:04:21+00:00",
    "commented_code": "+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++17 -verify %s\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++20 -verify %s\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++23 -verify %s",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214190869",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr-appertainment.cpp",
        "discussion_id": "2214190869",
        "commented_code": "@@ -0,0 +1,33 @@\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++17 -verify %s\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++20 -verify %s\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++23 -verify %s",
        "comment_created_at": "2025-07-17T20:04:21+00:00",
        "comment_author": "tahonermann",
        "comment_body": "Validate diagnostics for host compilation too.\r\n```suggestion\r\n// RUN: %clang_cc1 -fsycl-is-host -fsyntax-only -std=c++17 -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++17 -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-host -fsyntax-only -std=c++20 -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++20 -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-host -fsyntax-only -std=c++23 -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -std=c++23 -verify %s\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214193302",
    "pr_number": 140282,
    "pr_file": "clang/test/SemaSYCL/sycl-external-attr-grammar.cpp",
    "created_at": "2025-07-17T20:05:58+00:00",
    "commented_code": "+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214193302",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr-grammar.cpp",
        "discussion_id": "2214193302",
        "commented_code": "@@ -0,0 +1,15 @@\n+// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s",
        "comment_created_at": "2025-07-17T20:05:58+00:00",
        "comment_author": "tahonermann",
        "comment_body": "Validate diagnostics for host compilation too.\r\n```suggestion\r\n// RUN: %clang_cc1 -fsycl-is-host -fsyntax-only -verify %s\r\n// RUN: %clang_cc1 -fsycl-is-device -fsyntax-only -verify %s\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214200062",
    "pr_number": 140282,
    "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
    "created_at": "2025-07-17T20:10:38+00:00",
    "commented_code": "+// RUN: %clang_cc1 -fsycl-is-device -std=c++17 -fsyntax-only -verify -DCPP17 %s\n+// RUN: %clang_cc1 -fsycl-is-device -std=c++20 -fsyntax-only -verify -DCPP20 %s",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214200062",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/SemaSYCL/sycl-external-attr.cpp",
        "discussion_id": "2214200062",
        "commented_code": "@@ -0,0 +1,112 @@\n+// RUN: %clang_cc1 -fsycl-is-device -std=c++17 -fsyntax-only -verify -DCPP17 %s\n+// RUN: %clang_cc1 -fsycl-is-device -std=c++20 -fsyntax-only -verify -DCPP20 %s",
        "comment_created_at": "2025-07-17T20:10:38+00:00",
        "comment_author": "tahonermann",
        "comment_body": "Validate diagnostics for host compilation too.\r\n```suggestion\r\n// RUN: %clang_cc1 -fsycl-is-host -std=c++17 -fsyntax-only -verify -DCPP17 %s\r\n// RUN: %clang_cc1 -fsycl-is-device -std=c++17 -fsyntax-only -verify -DCPP17 %s\r\n// RUN: %clang_cc1 -fsycl-is-host -std=c++20 -fsyntax-only -verify -DCPP20 %s\r\n// RUN: %clang_cc1 -fsycl-is-device -std=c++20 -fsyntax-only -verify -DCPP20 %s\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2228523008",
    "pr_number": 150417,
    "pr_file": "clang/lib/StaticAnalyzer/Checkers/StoreToImmutableChecker.cpp",
    "created_at": "2025-07-24T13:26:36+00:00",
    "commented_code": "+//=== StoreToImmutableChecker.cpp - Store to immutable memory checker -*- C++\n+//-*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines StoreToImmutableChecker, a checker that detects writes\n+// to immutable memory regions. This implements part of SEI CERT Rule ENV30-C.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h\"\n+#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n+#include \"clang/StaticAnalyzer/Core/Checker.h\"\n+#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n+\n+using namespace clang;\n+using namespace ento;\n+\n+namespace {\n+class StoreToImmutableChecker : public Checker<check::Bind> {\n+  const BugType BT{this, \"Write to immutable memory\", \"CERT Environment (ENV)\"};\n+\n+public:\n+  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n+\n+private:\n+  bool isConstVariable(const MemRegion *MR, CheckerContext &C) const;\n+  bool isConstQualifiedType(const MemRegion *MR, CheckerContext &C) const;\n+};\n+} // end anonymous namespace\n+\n+bool StoreToImmutableChecker::isConstVariable(const MemRegion *MR,\n+                                              CheckerContext &C) const {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2228523008",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150417,
        "pr_file": "clang/lib/StaticAnalyzer/Checkers/StoreToImmutableChecker.cpp",
        "discussion_id": "2228523008",
        "commented_code": "@@ -0,0 +1,146 @@\n+//=== StoreToImmutableChecker.cpp - Store to immutable memory checker -*- C++\n+//-*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines StoreToImmutableChecker, a checker that detects writes\n+// to immutable memory regions. This implements part of SEI CERT Rule ENV30-C.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h\"\n+#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n+#include \"clang/StaticAnalyzer/Core/Checker.h\"\n+#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n+\n+using namespace clang;\n+using namespace ento;\n+\n+namespace {\n+class StoreToImmutableChecker : public Checker<check::Bind> {\n+  const BugType BT{this, \"Write to immutable memory\", \"CERT Environment (ENV)\"};\n+\n+public:\n+  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n+\n+private:\n+  bool isConstVariable(const MemRegion *MR, CheckerContext &C) const;\n+  bool isConstQualifiedType(const MemRegion *MR, CheckerContext &C) const;\n+};\n+} // end anonymous namespace\n+\n+bool StoreToImmutableChecker::isConstVariable(const MemRegion *MR,\n+                                              CheckerContext &C) const {",
        "comment_created_at": "2025-07-24T13:26:36+00:00",
        "comment_author": "steakhal",
        "comment_body": "Could you please paste the test coverage of this function? It has a lot of branches, and I'm not sure if all of these are feasible.",
        "pr_file_module": null
      },
      {
        "comment_id": "2229821110",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150417,
        "pr_file": "clang/lib/StaticAnalyzer/Checkers/StoreToImmutableChecker.cpp",
        "discussion_id": "2228523008",
        "commented_code": "@@ -0,0 +1,146 @@\n+//=== StoreToImmutableChecker.cpp - Store to immutable memory checker -*- C++\n+//-*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines StoreToImmutableChecker, a checker that detects writes\n+// to immutable memory regions. This implements part of SEI CERT Rule ENV30-C.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h\"\n+#include \"clang/StaticAnalyzer/Core/BugReporter/BugType.h\"\n+#include \"clang/StaticAnalyzer/Core/Checker.h\"\n+#include \"clang/StaticAnalyzer/Core/CheckerManager.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h\"\n+#include \"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h\"\n+\n+using namespace clang;\n+using namespace ento;\n+\n+namespace {\n+class StoreToImmutableChecker : public Checker<check::Bind> {\n+  const BugType BT{this, \"Write to immutable memory\", \"CERT Environment (ENV)\"};\n+\n+public:\n+  void checkBind(SVal Loc, SVal Val, const Stmt *S, CheckerContext &C) const;\n+\n+private:\n+  bool isConstVariable(const MemRegion *MR, CheckerContext &C) const;\n+  bool isConstQualifiedType(const MemRegion *MR, CheckerContext &C) const;\n+};\n+} // end anonymous namespace\n+\n+bool StoreToImmutableChecker::isConstVariable(const MemRegion *MR,\n+                                              CheckerContext &C) const {",
        "comment_created_at": "2025-07-24T23:54:38+00:00",
        "comment_author": "gamesh411",
        "comment_body": "As you suspected, no hits for ParamVarRegion or StringRegion.\r\nParamVarRegion may not even be possible to encounter in this context (just a guess), and I am not sure where is binding to a String region occurs. I will remove these two cases for now.\r\n\r\n```\r\n   38|       |bool StoreToImmutableChecker::isConstVariable(const MemRegion *MR,\r\n   39|     21|                                              CheckerContext &C) const {\r\n   40|       |  // Check if the region is in the global immutable space\r\n   41|     21|  const MemSpaceRegion *MS = MR->getMemorySpace(C.getState());\r\n   42|     21|  if (isa<GlobalImmutableSpaceRegion>(MS))\r\n   43|      3|    return true;\r\n   44|       |\r\n   45|       |  // Check if this is a VarRegion with a const-qualified type\r\n   46|     18|  if (const VarRegion *VR = dyn_cast<VarRegion>(MR)) {\r\n   47|      8|    const VarDecl *VD = VR->getDecl();\r\n   48|      8|    if (VD && VD->getType().isConstQualified())\r\n   49|      2|      return true;\r\n   50|      8|  }\r\n   51|       |\r\n   52|       |  // Check if this is a ParamVarRegion with a const-qualified type\r\n   53|     16|  if (const ParamVarRegion *PVR = dyn_cast<ParamVarRegion>(MR)) {\r\n   54|      0|    const ParmVarDecl *PVD = PVR->getDecl();\r\n   55|      0|    if (PVD && PVD->getType().isConstQualified())\r\n   56|      0|      return true;\r\n   57|      0|  }\r\n   58|       |\r\n   59|       |  // Check if this is a FieldRegion with a const-qualified type\r\n   60|     16|  if (const FieldRegion *FR = dyn_cast<FieldRegion>(MR)) {\r\n   61|      5|    const FieldDecl *FD = FR->getDecl();\r\n   62|      5|    if (FD && FD->getType().isConstQualified())\r\n   63|      4|      return true;\r\n   64|      5|  }\r\n   65|       |\r\n   66|       |  // Check if this is a StringRegion (string literals are const)\r\n   67|     12|  if (isa<StringRegion>(MR))\r\n   68|      0|    return true;\r\n   69|       |\r\n   70|       |  // Check if this is a SymbolicRegion with a const-qualified pointee type\r\n   71|     12|  if (const SymbolicRegion *SR = dyn_cast<SymbolicRegion>(MR)) {\r\n   72|      3|    QualType PointeeType = SR->getPointeeStaticType();\r\n   73|      3|    if (PointeeType.isConstQualified())\r\n   74|      3|      return true;\r\n   75|      3|  }\r\n   76|       |\r\n   77|       |  // Check if this is an ElementRegion accessing a const array\r\n   78|      9|  if (const ElementRegion *ER = dyn_cast<ElementRegion>(MR)) {\r\n   79|      2|    return isConstQualifiedType(ER->getSuperRegion(), C);\r\n   80|      2|  }\r\n   81|       |\r\n   82|      7|  return false;\r\n   83|      9|}\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  }
]