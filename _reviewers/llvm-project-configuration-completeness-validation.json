[
  {
    "discussion_id": "2235547107",
    "pr_number": 149469,
    "pr_file": "clang/lib/Frontend/CompilerInvocation.cpp",
    "created_at": "2025-07-28T09:26:43+00:00",
    "commented_code": "}\n   }\n \n+  // Process MinGW -mcrtdll option\n+  if (Arg *A = Args.getLastArg(OPT_mcrtdll_EQ)) {\n+    Opts.MinGWCRTDll =\n+        llvm::StringSwitch<enum LangOptions::WindowsCRTDLLVersion>(\n+            A->getValue())\n+            .StartsWithLower(\"crtdll\",\n+                             LangOptions::WindowsCRTDLLVersion::CRTDLL)\n+            .StartsWithLower(\"msvcrt10\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT10)\n+            .StartsWithLower(\"msvcrt20\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT20)\n+            .StartsWithLower(\"msvcrt40\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT40)\n+            .StartsWithLower(\"msvcr40\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT40)\n+            .StartsWithLower(\"msvcrtd\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRTD)\n+            .StartsWithLower(\"msvcr70\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR70)\n+            .StartsWithLower(\"msvcr71\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR71)\n+            .StartsWithLower(\"msvcr80\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR80)\n+            .StartsWithLower(\"msvcr90\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR90)\n+            .StartsWithLower(\"msvcr100\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR100)\n+            .StartsWithLower(\"msvcr110\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR110)\n+            .StartsWithLower(\"msvcr120\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR120)",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2235547107",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149469,
        "pr_file": "clang/lib/Frontend/CompilerInvocation.cpp",
        "discussion_id": "2235547107",
        "commented_code": "@@ -4705,6 +4705,44 @@ bool CompilerInvocation::ParseLangArgs(LangOptions &Opts, ArgList &Args,\n     }\n   }\n \n+  // Process MinGW -mcrtdll option\n+  if (Arg *A = Args.getLastArg(OPT_mcrtdll_EQ)) {\n+    Opts.MinGWCRTDll =\n+        llvm::StringSwitch<enum LangOptions::WindowsCRTDLLVersion>(\n+            A->getValue())\n+            .StartsWithLower(\"crtdll\",\n+                             LangOptions::WindowsCRTDLLVersion::CRTDLL)\n+            .StartsWithLower(\"msvcrt10\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT10)\n+            .StartsWithLower(\"msvcrt20\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT20)\n+            .StartsWithLower(\"msvcrt40\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT40)\n+            .StartsWithLower(\"msvcr40\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRT40)\n+            .StartsWithLower(\"msvcrtd\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCRTD)\n+            .StartsWithLower(\"msvcr70\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR70)\n+            .StartsWithLower(\"msvcr71\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR71)\n+            .StartsWithLower(\"msvcr80\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR80)\n+            .StartsWithLower(\"msvcr90\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR90)\n+            .StartsWithLower(\"msvcr100\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR100)\n+            .StartsWithLower(\"msvcr110\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR110)\n+            .StartsWithLower(\"msvcr120\",\n+                             LangOptions::WindowsCRTDLLVersion::MSVCR120)",
        "comment_created_at": "2025-07-28T09:26:43+00:00",
        "comment_author": "mstorsjo",
        "comment_body": "You're missing a case (and enum) for `msvcrt-os`, if this is to mimic the GCC implementation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2229366696",
    "pr_number": 149293,
    "pr_file": "mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp",
    "created_at": "2025-07-24T19:17:03+00:00",
    "commented_code": "auto destSize = unpackOp.getDestRank();\n \n-  if (!inputVectorSizes.empty())\n-    assert(inputVectorSizes.size() == destSize &&\n+  if (!inputVectorSizes.empty()) {\n+    assert(inputVectorSizes.size() == destSize + sourceShape.size() &&\n            \"Incorrect number of input vector sizes\");\n+  }\n+\n+  SmallVector<bool> readScalableVectorFlags;\n+  SmallVector<bool> writeScalableVectorFlags;\n+  SmallVector<int64_t> readVectorSizes;\n+  SmallVector<int64_t> writeVectorSizes;\n \n-  // vectorSizes is the shape of the vector that will be used to do final\n+  // Split input-vector-sizes into vector sizes for the read and write\n+  // operations.\n+  if (!inputVectorSizes.empty()) {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2229366696",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149293,
        "pr_file": "mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp",
        "discussion_id": "2229366696",
        "commented_code": "@@ -1860,25 +1866,54 @@ vectorizeAsTensorUnpackOp(RewriterBase &rewriter, linalg::UnPackOp unpackOp,\n \n   auto destSize = unpackOp.getDestRank();\n \n-  if (!inputVectorSizes.empty())\n-    assert(inputVectorSizes.size() == destSize &&\n+  if (!inputVectorSizes.empty()) {\n+    assert(inputVectorSizes.size() == destSize + sourceShape.size() &&\n            \"Incorrect number of input vector sizes\");\n+  }\n+\n+  SmallVector<bool> readScalableVectorFlags;\n+  SmallVector<bool> writeScalableVectorFlags;\n+  SmallVector<int64_t> readVectorSizes;\n+  SmallVector<int64_t> writeVectorSizes;\n \n-  // vectorSizes is the shape of the vector that will be used to do final\n+  // Split input-vector-sizes into vector sizes for the read and write\n+  // operations.\n+  if (!inputVectorSizes.empty()) {",
        "comment_created_at": "2025-07-24T19:17:03+00:00",
        "comment_author": "egebeysel",
        "comment_body": "One thing I'm curious about, even if we have fully static sizes and inner tiles, if the user specifies some size, we use that one. I think this was the previous behaviour as well, but should we maybe add some sort of sanity check for this? I'm not really familiar with the current behaviour either so this is rather a question on why things are the way they are :) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2230820059",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149293,
        "pr_file": "mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp",
        "discussion_id": "2229366696",
        "commented_code": "@@ -1860,25 +1866,54 @@ vectorizeAsTensorUnpackOp(RewriterBase &rewriter, linalg::UnPackOp unpackOp,\n \n   auto destSize = unpackOp.getDestRank();\n \n-  if (!inputVectorSizes.empty())\n-    assert(inputVectorSizes.size() == destSize &&\n+  if (!inputVectorSizes.empty()) {\n+    assert(inputVectorSizes.size() == destSize + sourceShape.size() &&\n            \"Incorrect number of input vector sizes\");\n+  }\n+\n+  SmallVector<bool> readScalableVectorFlags;\n+  SmallVector<bool> writeScalableVectorFlags;\n+  SmallVector<int64_t> readVectorSizes;\n+  SmallVector<int64_t> writeVectorSizes;\n \n-  // vectorSizes is the shape of the vector that will be used to do final\n+  // Split input-vector-sizes into vector sizes for the read and write\n+  // operations.\n+  if (!inputVectorSizes.empty()) {",
        "comment_created_at": "2025-07-25T11:09:48+00:00",
        "comment_author": "banach-space",
        "comment_body": "Thanks for these questions!\r\n\r\n> even if we have fully static sizes and inner tiles, if the user specifies some size, we use that one\r\n\r\nIf a \"user\" provides the configuration, the compiler ought to respect that. Otherwise, we could have a situation where a user provides some input and that's unexpectedly ignored by the compiler. (*)\r\n\r\nAlso, if a \"user\" provides the configuration, it is similar to saying \"Hey, compiler, I know better, follow my instructions! And ignore the static loop bounds that you may have access to - like I said - I know better.\" :)\r\n\r\nNote that:\r\n* If the user-specified vectors are too large, masking is used to make sure there are no out-of-bounds accesses.\r\n* If the user-specified vectors are smaller than the actual run-time input then there won't be any out-of-bounds accesses anyway.\r\n\r\nHopefully this makes sense :)\r\n\r\n> should we maybe add some sort of sanity check for this?\r\n\r\nYes, I have updated the pre-condition calculation in [this commit](https://github.com/llvm/llvm-project/pull/149293/commits/3b482fcb0013d971aa5befb9b99da166a34bb1a5). Can we do more and/or better? \ud83e\udd14 \r\n\r\n(*) One option would be for the compiler to issue some diagnostic saying that the user input was ignored. However, I personally feel that we should avoid such high-level complexities.",
        "pr_file_module": null
      },
      {
        "comment_id": "2231939445",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149293,
        "pr_file": "mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp",
        "discussion_id": "2229366696",
        "commented_code": "@@ -1860,25 +1866,54 @@ vectorizeAsTensorUnpackOp(RewriterBase &rewriter, linalg::UnPackOp unpackOp,\n \n   auto destSize = unpackOp.getDestRank();\n \n-  if (!inputVectorSizes.empty())\n-    assert(inputVectorSizes.size() == destSize &&\n+  if (!inputVectorSizes.empty()) {\n+    assert(inputVectorSizes.size() == destSize + sourceShape.size() &&\n            \"Incorrect number of input vector sizes\");\n+  }\n+\n+  SmallVector<bool> readScalableVectorFlags;\n+  SmallVector<bool> writeScalableVectorFlags;\n+  SmallVector<int64_t> readVectorSizes;\n+  SmallVector<int64_t> writeVectorSizes;\n \n-  // vectorSizes is the shape of the vector that will be used to do final\n+  // Split input-vector-sizes into vector sizes for the read and write\n+  // operations.\n+  if (!inputVectorSizes.empty()) {",
        "comment_created_at": "2025-07-25T20:18:18+00:00",
        "comment_author": "hanhanW",
        "comment_body": "Yes, we should verify if it has valid input vectors or not in precondition check, like the linalg one.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2093829179",
    "pr_number": 140282,
    "pr_file": "clang/lib/AST/ASTContext.cpp",
    "created_at": "2025-05-17T02:07:43+00:00",
    "commented_code": "if (D->hasAttr<WeakRefAttr>())\n     return false;\n \n+  if (LangOpts.SYCLIsDevice && !D->hasAttr<SYCLKernelEntryPointAttr>())\n+    return false;",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2093829179",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2093829179",
        "commented_code": "@@ -12909,6 +12909,9 @@ bool ASTContext::DeclMustBeEmitted(const Decl *D) {\n   if (D->hasAttr<WeakRefAttr>())\n     return false;\n \n+  if (LangOpts.SYCLIsDevice && !D->hasAttr<SYCLKernelEntryPointAttr>())\n+    return false;",
        "comment_created_at": "2025-05-17T02:07:43+00:00",
        "comment_author": "tahonermann",
        "comment_body": "This will also need to check for the new `SYCLExternalAttr` attribute for the new code below to be reachable (I neglected to add this condition in the example I gave you elsewhere).\r\n```suggestion\r\n  if (LangOpts.SYCLIsDevice && !D->hasAttr<SYCLKernelEntryPointAttr>() &&\r\n      !D->hasAttr<SYCLExternalAttr>())\r\n    return false;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2095995712",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2093829179",
        "commented_code": "@@ -12909,6 +12909,9 @@ bool ASTContext::DeclMustBeEmitted(const Decl *D) {\n   if (D->hasAttr<WeakRefAttr>())\n     return false;\n \n+  if (LangOpts.SYCLIsDevice && !D->hasAttr<SYCLKernelEntryPointAttr>())\n+    return false;",
        "comment_created_at": "2025-05-19T15:31:13+00:00",
        "comment_author": "schittir",
        "comment_body": "Yes, indeed. I left that one out of this draft because adding that check caused three additional failures than those caused by the check for KernelEntryPointAttr alone. I didn't expect you to review it, but I should have labeled it clearly, just in case. Thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2237312447",
    "pr_number": 140282,
    "pr_file": "clang/test/CodeGenSYCL/sycl-external-attr.cpp",
    "created_at": "2025-07-28T17:09:23+00:00",
    "commented_code": "+// RUN: %clang_cc1 -fsycl-is-device -triple spir64-unknown-unknown -disable-llvm-passes -emit-llvm %s -o - | FileCheck %s\n+\n+// This test code generation when sycl_external attribute is used\n+\n+// Function defined and not used - symbols emitted\n+[[clang::sycl_external]] int square(int x) { return x*x; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z6squarei\n+\n+// Function defined and used - symbols emitted\n+[[clang::sycl_external]] int squareUsed(int x) { return x*x; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z10squareUsedi\n+\n+// Constexpr function defined and not used - symbols emitted\n+[[clang::sycl_external]] constexpr int squareInlined(int x) { return x*x; }\n+// CHECK: define linkonce_odr spir_func noundef i32 @_Z13squareInlinedi\n+\n+// Function declared but not defined or used - no symbols emitted\n+[[clang::sycl_external]] int decl();\n+\n+// FIXME: Function declared and used but not defined - emit external reference\n+[[clang::sycl_external]] void declused(int y);\n+\n+// Function overload with definition - symbols emitted\n+[[clang::sycl_external]] int func1(int arg);\n+int func1(int arg) { return arg; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z5func1i\n+\n+class A {\n+// Defaulted special member functions - no symbols emitted\n+  [[clang::sycl_external]] A& operator=(A& a) = default;\n+};\n+\n+class B {\n+  [[clang::sycl_external]] virtual void BFunc1WithAttr() { int i = 1; }\n+// CHECK: define linkonce_odr spir_func void @_ZN1B14BFunc1WithAttrEv\n+  virtual void BFunc2NoAttr() { int i = 2; }\n+};\n+\n+class C {\n+// Special member function defined - symbols emitted\n+  [[clang::sycl_external]] ~C() {}\n+// CHECK: define linkonce_odr spir_func void @_ZN1CD1Ev\n+};\n+\n+int ret1() { return 1; }\n+[[clang::sycl_external]] int withAttr() { return ret1(); }\n+// CHECK: define dso_local spir_func noundef i32 @_Z8withAttrv\n+// CHECK: define dso_local spir_func noundef i32 @_Z4ret1v\n+\n+template <typename T>\n+[[clang::sycl_external]] void tFunc1(T arg) {}\n+// Explicit specialization defined - symbols emitted\n+template<>\n+[[clang::sycl_external]] void tFunc1<int>(int arg) {}\n+// CHECK: define dso_local spir_func void @_Z6tFunc1IiEvT_\n+\n+// FIXME: symbols should be emitted for the instantiation and the specialization\n+// tFunc2 below\n+template <typename T>\n+void tFunc2(T arg) {}\n+template void tFunc2<int>(int arg); // emit code for this\n+template<> void tFunc2<char>(char arg) {} // and this",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2237312447",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/test/CodeGenSYCL/sycl-external-attr.cpp",
        "discussion_id": "2237312447",
        "commented_code": "@@ -0,0 +1,73 @@\n+// RUN: %clang_cc1 -fsycl-is-device -triple spir64-unknown-unknown -disable-llvm-passes -emit-llvm %s -o - | FileCheck %s\n+\n+// This test code generation when sycl_external attribute is used\n+\n+// Function defined and not used - symbols emitted\n+[[clang::sycl_external]] int square(int x) { return x*x; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z6squarei\n+\n+// Function defined and used - symbols emitted\n+[[clang::sycl_external]] int squareUsed(int x) { return x*x; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z10squareUsedi\n+\n+// Constexpr function defined and not used - symbols emitted\n+[[clang::sycl_external]] constexpr int squareInlined(int x) { return x*x; }\n+// CHECK: define linkonce_odr spir_func noundef i32 @_Z13squareInlinedi\n+\n+// Function declared but not defined or used - no symbols emitted\n+[[clang::sycl_external]] int decl();\n+\n+// FIXME: Function declared and used but not defined - emit external reference\n+[[clang::sycl_external]] void declused(int y);\n+\n+// Function overload with definition - symbols emitted\n+[[clang::sycl_external]] int func1(int arg);\n+int func1(int arg) { return arg; }\n+// CHECK: define dso_local spir_func noundef i32 @_Z5func1i\n+\n+class A {\n+// Defaulted special member functions - no symbols emitted\n+  [[clang::sycl_external]] A& operator=(A& a) = default;\n+};\n+\n+class B {\n+  [[clang::sycl_external]] virtual void BFunc1WithAttr() { int i = 1; }\n+// CHECK: define linkonce_odr spir_func void @_ZN1B14BFunc1WithAttrEv\n+  virtual void BFunc2NoAttr() { int i = 2; }\n+};\n+\n+class C {\n+// Special member function defined - symbols emitted\n+  [[clang::sycl_external]] ~C() {}\n+// CHECK: define linkonce_odr spir_func void @_ZN1CD1Ev\n+};\n+\n+int ret1() { return 1; }\n+[[clang::sycl_external]] int withAttr() { return ret1(); }\n+// CHECK: define dso_local spir_func noundef i32 @_Z8withAttrv\n+// CHECK: define dso_local spir_func noundef i32 @_Z4ret1v\n+\n+template <typename T>\n+[[clang::sycl_external]] void tFunc1(T arg) {}\n+// Explicit specialization defined - symbols emitted\n+template<>\n+[[clang::sycl_external]] void tFunc1<int>(int arg) {}\n+// CHECK: define dso_local spir_func void @_Z6tFunc1IiEvT_\n+\n+// FIXME: symbols should be emitted for the instantiation and the specialization\n+// tFunc2 below\n+template <typename T>\n+void tFunc2(T arg) {}\n+template void tFunc2<int>(int arg); // emit code for this\n+template<> void tFunc2<char>(char arg) {} // and this",
        "comment_created_at": "2025-07-28T17:09:23+00:00",
        "comment_author": "tahonermann",
        "comment_body": "None of these are declared with `sycl_external`. The template instantiation declaration will inherit the attribute from the primary function template. The explicit specializations will as well, but they shouldn't (according to the C++ standard), so we should test explicit specializations both with and without the attribute. I think we want something like this:\r\n```suggestion\r\n// FIXME: symbols should be emitted for the instantiation and the specialization\r\n// tFunc2 below\r\ntemplate <typename T>\r\n[[clang::sycl_external]] void tFunc2(T arg) {}\r\ntemplate void tFunc2<int>(int arg);\r\ntemplate<> void tFunc2<char>(char arg) {}\r\ntemplate<> [[clang::sycl_external]] void  tFunc2<long>(long arg) {}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]