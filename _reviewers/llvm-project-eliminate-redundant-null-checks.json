[
  {
    "discussion_id": "2231407535",
    "pr_number": 150520,
    "pr_file": "clang/lib/CIR/Lowering/DirectToLLVM/LowerToLLVM.cpp",
    "created_at": "2025-07-25T15:21:14+00:00",
    "commented_code": "resultType ? resultType : mlir::LLVM::LLVMVoidType::get(getContext()),\n       signatureConversion.getConvertedTypes(),\n       /*isVarArg=*/fnType.isVarArg());\n+\n+  // If this is an alias, it needs to be lowered to llvm::AliasOp.\n+  std::optional<mlir::FlatSymbolRefAttr> aliasee = op.getAliaseeAttr();\n+  if (aliasee && *aliasee)\n+    return matchAndRewriteAlias(op, *aliasee, llvmFnTy, adaptor, rewriter);",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2231407535",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150520,
        "pr_file": "clang/lib/CIR/Lowering/DirectToLLVM/LowerToLLVM.cpp",
        "discussion_id": "2231407535",
        "commented_code": "@@ -1190,6 +1248,12 @@ mlir::LogicalResult CIRToLLVMFuncOpLowering::matchAndRewrite(\n       resultType ? resultType : mlir::LLVM::LLVMVoidType::get(getContext()),\n       signatureConversion.getConvertedTypes(),\n       /*isVarArg=*/fnType.isVarArg());\n+\n+  // If this is an alias, it needs to be lowered to llvm::AliasOp.\n+  std::optional<mlir::FlatSymbolRefAttr> aliasee = op.getAliaseeAttr();\n+  if (aliasee && *aliasee)\n+    return matchAndRewriteAlias(op, *aliasee, llvmFnTy, adaptor, rewriter);",
        "comment_created_at": "2025-07-25T15:21:14+00:00",
        "comment_author": "xlauko",
        "comment_body": "```suggestion\r\n  if (std::optional<llvm::StringRef> aliasee = op.getAliasee())\r\n    return matchAndRewriteAlias(op, *aliasee, llvmFnTy, adaptor, rewriter);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193329318",
    "pr_number": 147442,
    "pr_file": "flang/lib/Semantics/resolve-directives.cpp",
    "created_at": "2025-07-08T19:51:41+00:00",
    "commented_code": "useLastDeclSymbol();\n       PRINT_IMPLICIT_RULE(\"3) enclosing context\");\n     } else if (targetDir) {\n-      // TODO 4) not mapped target variable -> firstprivate\n+      // 4) not mapped target variable  -> firstprivate\n+      //    - i.e. implicit, but meets OpenMP specification rules for\n+      //    firstprivate \"promotion\"\n+      if (enableDelayedPrivatizationStaging && symbol &&",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2193329318",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147442,
        "pr_file": "flang/lib/Semantics/resolve-directives.cpp",
        "discussion_id": "2193329318",
        "commented_code": "@@ -2444,7 +2473,15 @@ void OmpAttributeVisitor::CreateImplicitSymbols(const Symbol *symbol) {\n       useLastDeclSymbol();\n       PRINT_IMPLICIT_RULE(\"3) enclosing context\");\n     } else if (targetDir) {\n-      // TODO 4) not mapped target variable -> firstprivate\n+      // 4) not mapped target variable  -> firstprivate\n+      //    - i.e. implicit, but meets OpenMP specification rules for\n+      //    firstprivate \"promotion\"\n+      if (enableDelayedPrivatizationStaging && symbol &&",
        "comment_created_at": "2025-07-08T19:51:41+00:00",
        "comment_author": "luporl",
        "comment_body": "`symbol` can't be NULL, as that is one of the conditions checked before calling `CreateImplicitSymbols`.\r\nIn the future, it would be good to change its `symbol` parameter to a reference.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2226971311",
    "pr_number": 150331,
    "pr_file": "lldb/source/API/SBModule.cpp",
    "created_at": "2025-07-23T23:52:49+00:00",
    "commented_code": "const bool mandatory = false;\n   ModuleList::RemoveOrphanSharedModules(mandatory);\n }\n+\n+const char *SBModule::GetName() const {\n+  LLDB_INSTRUMENT_VA(this);\n+  if (!m_opaque_sp) {\n+    return nullptr;\n+  }\n+  auto mod_name = m_opaque_sp->GetObjectName();\n+  if (!mod_name) {\n+    return nullptr;\n+  }\n+  return mod_name.AsCString();",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2226971311",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150331,
        "pr_file": "lldb/source/API/SBModule.cpp",
        "discussion_id": "2226971311",
        "commented_code": "@@ -671,3 +671,15 @@ void SBModule::GarbageCollectAllocatedModules() {\n   const bool mandatory = false;\n   ModuleList::RemoveOrphanSharedModules(mandatory);\n }\n+\n+const char *SBModule::GetName() const {\n+  LLDB_INSTRUMENT_VA(this);\n+  if (!m_opaque_sp) {\n+    return nullptr;\n+  }\n+  auto mod_name = m_opaque_sp->GetObjectName();\n+  if (!mod_name) {\n+    return nullptr;\n+  }\n+  return mod_name.AsCString();",
        "comment_created_at": "2025-07-23T23:52:49+00:00",
        "comment_author": "JDevlieghere",
        "comment_body": "`AsCString` will return `nullptr` if the `ConstString` is empty, so the previous check is redundant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950907443",
    "pr_number": 126324,
    "pr_file": "clang/lib/Lex/PPMacroExpansion.cpp",
    "created_at": "2025-02-11T14:00:05+00:00",
    "commented_code": "diag::err_feature_check_malformed);\n         return II && HasExtension(*this, II->getName());\n       });\n-  } else if (II == Ident__has_builtin) {\n+  } else if (II == Ident__has_builtin || II == Ident__has_target_builtin) {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "1950907443",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 126324,
        "pr_file": "clang/lib/Lex/PPMacroExpansion.cpp",
        "discussion_id": "1950907443",
        "commented_code": "@@ -1797,16 +1803,18 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {\n                                            diag::err_feature_check_malformed);\n         return II && HasExtension(*this, II->getName());\n       });\n-  } else if (II == Ident__has_builtin) {\n+  } else if (II == Ident__has_builtin || II == Ident__has_target_builtin) {",
        "comment_created_at": "2025-02-11T14:00:05+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "FWIW, I just verified that `II` can't be nullptr here, so we don't have to worry about `Ident__has_target_builtin` matching in that case. Note that non-asserts builds won't catch this failure though and we may get weird behavior as a result if it were to happen somehow.",
        "pr_file_module": null
      },
      {
        "comment_id": "1950990405",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 126324,
        "pr_file": "clang/lib/Lex/PPMacroExpansion.cpp",
        "discussion_id": "1950907443",
        "commented_code": "@@ -1797,16 +1803,18 @@ void Preprocessor::ExpandBuiltinMacro(Token &Tok) {\n                                            diag::err_feature_check_malformed);\n         return II && HasExtension(*this, II->getName());\n       });\n-  } else if (II == Ident__has_builtin) {\n+  } else if (II == Ident__has_builtin || II == Ident__has_target_builtin) {",
        "comment_created_at": "2025-02-11T14:46:47+00:00",
        "comment_author": "sarnex",
        "comment_body": "Yeah I had the same concern originally and came to the same conclusion, but based on other feedback I'm going to make `__has_target_builtin` always defined, so `Ident__has_target_builtin` will never be `nullptr` so non-assert builds won't be weird (at least with this macro)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2231660610",
    "pr_number": 150661,
    "pr_file": "libc/src/wchar/wcschr.cpp",
    "created_at": "2025-07-25T17:22:54+00:00",
    "commented_code": "#include \"hdr/types/wchar_t.h\"\n #include \"src/__support/common.h\"\n #include \"src/__support/macros/config.h\"\n+#include \"wchar_utils.h\"\n \n namespace LIBC_NAMESPACE_DECL {\n \n LLVM_LIBC_FUNCTION(const wchar_t *, wcschr, (const wchar_t *s, wchar_t c)) {\n-  for (; *s && *s != c; ++s)\n-    ;\n-  if (*s == c)\n-    return s;\n-  return nullptr;\n+  return internal::wcschr(s, c);",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2231660610",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150661,
        "pr_file": "libc/src/wchar/wcschr.cpp",
        "discussion_id": "2231660610",
        "commented_code": "@@ -11,15 +11,12 @@\n #include \"hdr/types/wchar_t.h\"\n #include \"src/__support/common.h\"\n #include \"src/__support/macros/config.h\"\n+#include \"wchar_utils.h\"\n \n namespace LIBC_NAMESPACE_DECL {\n \n LLVM_LIBC_FUNCTION(const wchar_t *, wcschr, (const wchar_t *s, wchar_t c)) {\n-  for (; *s && *s != c; ++s)\n-    ;\n-  if (*s == c)\n-    return s;\n-  return nullptr;\n+  return internal::wcschr(s, c);",
        "comment_created_at": "2025-07-25T17:22:54+00:00",
        "comment_author": "lntue",
        "comment_body": "since you are here, can you add `LIBC_CRASH_ON_NULLPTR(s);` and its header+dependency?",
        "pr_file_module": null
      },
      {
        "comment_id": "2231679781",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150661,
        "pr_file": "libc/src/wchar/wcschr.cpp",
        "discussion_id": "2231660610",
        "commented_code": "@@ -11,15 +11,12 @@\n #include \"hdr/types/wchar_t.h\"\n #include \"src/__support/common.h\"\n #include \"src/__support/macros/config.h\"\n+#include \"wchar_utils.h\"\n \n namespace LIBC_NAMESPACE_DECL {\n \n LLVM_LIBC_FUNCTION(const wchar_t *, wcschr, (const wchar_t *s, wchar_t c)) {\n-  for (; *s && *s != c; ++s)\n-    ;\n-  if (*s == c)\n-    return s;\n-  return nullptr;\n+  return internal::wcschr(s, c);",
        "comment_created_at": "2025-07-25T17:34:03+00:00",
        "comment_author": "enh-google",
        "comment_body": "(done)",
        "pr_file_module": null
      }
    ]
  }
]