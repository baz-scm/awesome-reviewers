[
  {
    "discussion_id": "2213773320",
    "pr_number": 149176,
    "pr_file": "clang/test/Headers/check-NULL.c",
    "created_at": "2025-07-17T16:14:40+00:00",
    "commented_code": "+// There are at least 2 valid C null-pointer constants as defined\n+// by the C language standard.\n+// Test that the macro NULL is defined consistently for all platforms by\n+// those headers that the C standard mandates a macro definition for NULL.\n+\n+// RUN: %clang %s -Dheader=\"<locale.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdio.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdlib.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<string.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<time.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<wchar.h>\" -E | tail -1 | FileCheck %s",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2213773320",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149176,
        "pr_file": "clang/test/Headers/check-NULL.c",
        "discussion_id": "2213773320",
        "commented_code": "@@ -0,0 +1,15 @@\n+// There are at least 2 valid C null-pointer constants as defined\n+// by the C language standard.\n+// Test that the macro NULL is defined consistently for all platforms by\n+// those headers that the C standard mandates a macro definition for NULL.\n+\n+// RUN: %clang %s -Dheader=\"<locale.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdio.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdlib.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<string.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<time.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<wchar.h>\" -E | tail -1 | FileCheck %s",
        "comment_created_at": "2025-07-17T16:14:40+00:00",
        "comment_author": "efriedma-quic",
        "comment_body": "This is assuming that the default search path for clang will find system headers. This isn't really a safe assumption if the default triple is a cross-compile triple.",
        "pr_file_module": null
      },
      {
        "comment_id": "2213861611",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149176,
        "pr_file": "clang/test/Headers/check-NULL.c",
        "discussion_id": "2213773320",
        "commented_code": "@@ -0,0 +1,15 @@\n+// There are at least 2 valid C null-pointer constants as defined\n+// by the C language standard.\n+// Test that the macro NULL is defined consistently for all platforms by\n+// those headers that the C standard mandates a macro definition for NULL.\n+\n+// RUN: %clang %s -Dheader=\"<locale.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdio.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdlib.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<string.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<time.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<wchar.h>\" -E | tail -1 | FileCheck %s",
        "comment_created_at": "2025-07-17T17:01:28+00:00",
        "comment_author": "jamieschmeiser",
        "comment_body": "How can that happen?  According to https://clang.llvm.org/docs/CrossCompilation.html:  `If you don\u2019t specify the target, CPU names won\u2019t match (since Clang assumes the host triple), and the compilation will go ahead, creating code for the host platform`. There is no target specified so it will not be cross-compiling.\r\n\r\nIs there something that you would suggest to alleviate your concerns?",
        "pr_file_module": null
      },
      {
        "comment_id": "2213923261",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149176,
        "pr_file": "clang/test/Headers/check-NULL.c",
        "discussion_id": "2213773320",
        "commented_code": "@@ -0,0 +1,15 @@\n+// There are at least 2 valid C null-pointer constants as defined\n+// by the C language standard.\n+// Test that the macro NULL is defined consistently for all platforms by\n+// those headers that the C standard mandates a macro definition for NULL.\n+\n+// RUN: %clang %s -Dheader=\"<locale.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdio.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdlib.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<string.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<time.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<wchar.h>\" -E | tail -1 | FileCheck %s",
        "comment_created_at": "2025-07-17T17:36:08+00:00",
        "comment_author": "hubert-reinterpretcast",
        "comment_body": "> There is no target specified so it will not be cross-compiling.\r\n\r\nIt's entirely possible to create a cross-compiling build where the architecture is the same but the OS is different.\r\n\r\nUsing\r\n```\r\n%clang_cc1 -x c++ -internal-isystem %S/Inputs/include\r\n```\r\ninstead of `%clang` seems like part of the solution.",
        "pr_file_module": null
      },
      {
        "comment_id": "2213973974",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149176,
        "pr_file": "clang/test/Headers/check-NULL.c",
        "discussion_id": "2213773320",
        "commented_code": "@@ -0,0 +1,15 @@\n+// There are at least 2 valid C null-pointer constants as defined\n+// by the C language standard.\n+// Test that the macro NULL is defined consistently for all platforms by\n+// those headers that the C standard mandates a macro definition for NULL.\n+\n+// RUN: %clang %s -Dheader=\"<locale.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdio.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<stdlib.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<string.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<time.h>\" -E | tail -1 | FileCheck %s\n+// RUN: %clang %s -Dheader=\"<wchar.h>\" -E | tail -1 | FileCheck %s",
        "comment_created_at": "2025-07-17T18:05:56+00:00",
        "comment_author": "efriedma-quic",
        "comment_body": "The statement \"Clang assumes the host triple\" is an approximation.  clang's default target is specified by the LLVM_DEFAULT_TARGET_TRIPLE CMake flag.  By default, that's the host triple, but you can override it.\r\n\r\nIf you need some specific set of \"libc\" headers, you can mock them in clang/test/Headers/Inputs/ .",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2233250581",
    "pr_number": 150791,
    "pr_file": "clang-tools-extra/test/clang-tidy/checkers/bugprone/unsafe-functions.c",
    "created_at": "2025-07-26T20:28:19+00:00",
    "commented_code": "// parsing and preprocessor state will not have that case.\n // UNSUPPORTED: target={{.*-(ps4|ps5)}}\n //\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K-CERT-ONLY  %s bugprone-unsafe-functions %t -- \\\n+// RUN: %check_clang_tidy -std=c11-or-later -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2233250581",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150791,
        "pr_file": "clang-tools-extra/test/clang-tidy/checkers/bugprone/unsafe-functions.c",
        "discussion_id": "2233250581",
        "commented_code": "@@ -5,14 +5,14 @@\n // parsing and preprocessor state will not have that case.\n // UNSUPPORTED: target={{.*-(ps4|ps5)}}\n //\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K-CERT-ONLY  %s bugprone-unsafe-functions %t -- \\\n+// RUN: %check_clang_tidy -std=c11-or-later -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1",
        "comment_created_at": "2025-07-26T20:28:19+00:00",
        "comment_author": "vbvictor",
        "comment_body": "Do we need to add `-std` here? I'd suggest to make a separate PR with this changes after current lands.\r\nHere you added `-std` but in `misc/unused-parameters.c` don't.\r\nI'd suggest keeping this PR as small as possible with functional changes and the create a NFC.",
        "pr_file_module": null
      },
      {
        "comment_id": "2233658542",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150791,
        "pr_file": "clang-tools-extra/test/clang-tidy/checkers/bugprone/unsafe-functions.c",
        "discussion_id": "2233250581",
        "commented_code": "@@ -5,14 +5,14 @@\n // parsing and preprocessor state will not have that case.\n // UNSUPPORTED: target={{.*-(ps4|ps5)}}\n //\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -U__STDC_WANT_LIB_EXT1__\n-// RUN: %check_clang_tidy -check-suffix=WITHOUT-ANNEX-K         %s bugprone-unsafe-functions %t -- -- -U__STDC_LIB_EXT1__   -D__STDC_WANT_LIB_EXT1__=1\n-// RUN: %check_clang_tidy -check-suffix=WITH-ANNEX-K-CERT-ONLY  %s bugprone-unsafe-functions %t -- \\\n+// RUN: %check_clang_tidy -std=c11-or-later -check-suffix=WITH-ANNEX-K            %s bugprone-unsafe-functions %t -- -- -D__STDC_LIB_EXT1__=1 -D__STDC_WANT_LIB_EXT1__=1",
        "comment_created_at": "2025-07-27T04:28:39+00:00",
        "comment_author": "localspook",
        "comment_body": "We do: this test doesn't work with C99 because Annex K is a C11 feature. I realized though that all the `-check-suffix=WITHOUT-ANNEX-K` cases work with C99, so I've restored those.",
        "pr_file_module": null
      }
    ]
  }
]