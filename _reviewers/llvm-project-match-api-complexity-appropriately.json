[
  {
    "discussion_id": "2222110765",
    "pr_number": 148243,
    "pr_file": "llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h",
    "created_at": "2025-07-22T10:33:43+00:00",
    "commented_code": "/// header. If the loop header's size exceeds the threshold, the loop rotation\n /// will give up. The flag IsUtilMode controls the heuristic used in the\n /// LoopRotation. If it is true, the profitability heuristic will be ignored.\n-LLVM_ABI bool LoopRotation(Loop *L, LoopInfo *LI,\n-                           const TargetTransformInfo *TTI, AssumptionCache *AC,\n-                           DominatorTree *DT, ScalarEvolution *SE,\n-                           MemorySSAUpdater *MSSAU, const SimplifyQuery &SQ,\n-                           bool RotationOnly, unsigned Threshold,\n-                           bool IsUtilMode, bool PrepareForLTO = false);\n+/// The ProfitabilityCheck function can override general profitability check.\n+LLVM_ABI bool LoopRotation(\n+    Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI, AssumptionCache *AC,\n+    DominatorTree *DT, ScalarEvolution *SE, MemorySSAUpdater *MSSAU,\n+    const SimplifyQuery &SQ, bool RotationOnly, unsigned Threshold,\n+    bool IsUtilMode, bool PrepareForLTO = false,\n+    function_ref<bool(Loop *, ScalarEvolution *)> ProfitabilityCheck =",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2222110765",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148243,
        "pr_file": "llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h",
        "discussion_id": "2222110765",
        "commented_code": "@@ -32,12 +33,14 @@ class TargetTransformInfo;\n /// header. If the loop header's size exceeds the threshold, the loop rotation\n /// will give up. The flag IsUtilMode controls the heuristic used in the\n /// LoopRotation. If it is true, the profitability heuristic will be ignored.\n-LLVM_ABI bool LoopRotation(Loop *L, LoopInfo *LI,\n-                           const TargetTransformInfo *TTI, AssumptionCache *AC,\n-                           DominatorTree *DT, ScalarEvolution *SE,\n-                           MemorySSAUpdater *MSSAU, const SimplifyQuery &SQ,\n-                           bool RotationOnly, unsigned Threshold,\n-                           bool IsUtilMode, bool PrepareForLTO = false);\n+/// The ProfitabilityCheck function can override general profitability check.\n+LLVM_ABI bool LoopRotation(\n+    Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI, AssumptionCache *AC,\n+    DominatorTree *DT, ScalarEvolution *SE, MemorySSAUpdater *MSSAU,\n+    const SimplifyQuery &SQ, bool RotationOnly, unsigned Threshold,\n+    bool IsUtilMode, bool PrepareForLTO = false,\n+    function_ref<bool(Loop *, ScalarEvolution *)> ProfitabilityCheck =",
        "comment_created_at": "2025-07-22T10:33:43+00:00",
        "comment_author": "fhahn",
        "comment_body": "It looks like the lambda is currently not used, it either returns true or false? In that case make it a boolean argument",
        "pr_file_module": null
      },
      {
        "comment_id": "2222195287",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148243,
        "pr_file": "llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h",
        "discussion_id": "2222110765",
        "commented_code": "@@ -32,12 +33,14 @@ class TargetTransformInfo;\n /// header. If the loop header's size exceeds the threshold, the loop rotation\n /// will give up. The flag IsUtilMode controls the heuristic used in the\n /// LoopRotation. If it is true, the profitability heuristic will be ignored.\n-LLVM_ABI bool LoopRotation(Loop *L, LoopInfo *LI,\n-                           const TargetTransformInfo *TTI, AssumptionCache *AC,\n-                           DominatorTree *DT, ScalarEvolution *SE,\n-                           MemorySSAUpdater *MSSAU, const SimplifyQuery &SQ,\n-                           bool RotationOnly, unsigned Threshold,\n-                           bool IsUtilMode, bool PrepareForLTO = false);\n+/// The ProfitabilityCheck function can override general profitability check.\n+LLVM_ABI bool LoopRotation(\n+    Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI, AssumptionCache *AC,\n+    DominatorTree *DT, ScalarEvolution *SE, MemorySSAUpdater *MSSAU,\n+    const SimplifyQuery &SQ, bool RotationOnly, unsigned Threshold,\n+    bool IsUtilMode, bool PrepareForLTO = false,\n+    function_ref<bool(Loop *, ScalarEvolution *)> ProfitabilityCheck =",
        "comment_created_at": "2025-07-22T11:09:04+00:00",
        "comment_author": "mark-sed",
        "comment_body": "The idea was that the lambda could be useful later on in other parts which (will) use loopRotate to do a rotation under certain condition (similar to for example `replaceUsesWithIf`). In this exact case we have 1 loop and do the check before calling it so it is just a `return true` statement.\r\nIf you really prefer to have a flag instead, then I can change it. Nonetheless I still plan to make an NFC to refactor the loop rotate and split the legality and profitability checks, which will allow for loop unroll to ignore the existing profitability checks and not override it by this \"filter\" function.",
        "pr_file_module": null
      },
      {
        "comment_id": "2236695490",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148243,
        "pr_file": "llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h",
        "discussion_id": "2222110765",
        "commented_code": "@@ -32,12 +33,14 @@ class TargetTransformInfo;\n /// header. If the loop header's size exceeds the threshold, the loop rotation\n /// will give up. The flag IsUtilMode controls the heuristic used in the\n /// LoopRotation. If it is true, the profitability heuristic will be ignored.\n-LLVM_ABI bool LoopRotation(Loop *L, LoopInfo *LI,\n-                           const TargetTransformInfo *TTI, AssumptionCache *AC,\n-                           DominatorTree *DT, ScalarEvolution *SE,\n-                           MemorySSAUpdater *MSSAU, const SimplifyQuery &SQ,\n-                           bool RotationOnly, unsigned Threshold,\n-                           bool IsUtilMode, bool PrepareForLTO = false);\n+/// The ProfitabilityCheck function can override general profitability check.\n+LLVM_ABI bool LoopRotation(\n+    Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI, AssumptionCache *AC,\n+    DominatorTree *DT, ScalarEvolution *SE, MemorySSAUpdater *MSSAU,\n+    const SimplifyQuery &SQ, bool RotationOnly, unsigned Threshold,\n+    bool IsUtilMode, bool PrepareForLTO = false,\n+    function_ref<bool(Loop *, ScalarEvolution *)> ProfitabilityCheck =",
        "comment_created_at": "2025-07-28T14:20:26+00:00",
        "comment_author": "annamthomas",
        "comment_body": "I think it makes sense as a boolean argument for now. We don't have a strong usecase for a filter function. \r\nIf any refactoring will be done, we can think of how the filter function fits in then.",
        "pr_file_module": null
      },
      {
        "comment_id": "2237193851",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148243,
        "pr_file": "llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h",
        "discussion_id": "2222110765",
        "commented_code": "@@ -32,12 +33,14 @@ class TargetTransformInfo;\n /// header. If the loop header's size exceeds the threshold, the loop rotation\n /// will give up. The flag IsUtilMode controls the heuristic used in the\n /// LoopRotation. If it is true, the profitability heuristic will be ignored.\n-LLVM_ABI bool LoopRotation(Loop *L, LoopInfo *LI,\n-                           const TargetTransformInfo *TTI, AssumptionCache *AC,\n-                           DominatorTree *DT, ScalarEvolution *SE,\n-                           MemorySSAUpdater *MSSAU, const SimplifyQuery &SQ,\n-                           bool RotationOnly, unsigned Threshold,\n-                           bool IsUtilMode, bool PrepareForLTO = false);\n+/// The ProfitabilityCheck function can override general profitability check.\n+LLVM_ABI bool LoopRotation(\n+    Loop *L, LoopInfo *LI, const TargetTransformInfo *TTI, AssumptionCache *AC,\n+    DominatorTree *DT, ScalarEvolution *SE, MemorySSAUpdater *MSSAU,\n+    const SimplifyQuery &SQ, bool RotationOnly, unsigned Threshold,\n+    bool IsUtilMode, bool PrepareForLTO = false,\n+    function_ref<bool(Loop *, ScalarEvolution *)> ProfitabilityCheck =",
        "comment_created_at": "2025-07-28T16:31:25+00:00",
        "comment_author": "mark-sed",
        "comment_body": "I have changed it to the boolean flag now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230965575",
    "pr_number": 145382,
    "pr_file": "lldb/source/Plugins/Platform/Android/AdbClient.h",
    "created_at": "2025-07-25T12:30:16+00:00",
    "commented_code": "using DeviceIDList = std::list<std::string>;\n \n-  class SyncService {\n-    friend class AdbClient;\n-\n-  public:\n-    virtual ~SyncService();\n-\n-    virtual Status PullFile(const FileSpec &remote_file,\n-                            const FileSpec &local_file);\n-\n-    Status PushFile(const FileSpec &local_file, const FileSpec &remote_file);\n-\n-    virtual Status Stat(const FileSpec &remote_file, uint32_t &mode,\n-                        uint32_t &size, uint32_t &mtime);\n-\n-    bool IsConnected() const;\n-\n-  protected:\n-    explicit SyncService(std::unique_ptr<Connection> &&conn);\n-\n-  private:\n-    Status SendSyncRequest(const char *request_id, const uint32_t data_len,\n-                           const void *data);\n-\n-    Status ReadSyncHeader(std::string &response_id, uint32_t &data_len);\n-\n-    Status PullFileChunk(std::vector<char> &buffer, bool &eof);\n-\n-    Status ReadAllBytes(void *buffer, size_t size);\n-\n-    Status internalPullFile(const FileSpec &remote_file,\n-                            const FileSpec &local_file);\n-\n-    Status internalPushFile(const FileSpec &local_file,\n-                            const FileSpec &remote_file);\n-\n-    Status internalStat(const FileSpec &remote_file, uint32_t &mode,\n-                        uint32_t &size, uint32_t &mtime);\n-\n-    Status executeCommand(const std::function<Status()> &cmd);\n-\n-    std::unique_ptr<Connection> m_conn;\n-  };\n-\n-  static Status CreateByDeviceID(const std::string &device_id, AdbClient &adb);\n+  /// Resolves a device identifier to its canonical form.\n+  ///\n+  /// \\param device_id the device identifier to resolve (may be empty).\n+  /// \\param [out] resolved_device_id filled with the canonical device ID.\n+  ///\n+  /// \\returns Status object indicating success or failure. Returns error if\n+  ///          the device ID cannot be resolved or is ambiguous.\n+  static Status ResolveDeviceID(const std::string &device_id, std::string &resolved_device_id);",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2230965575",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 145382,
        "pr_file": "lldb/source/Plugins/Platform/Android/AdbClient.h",
        "discussion_id": "2230965575",
        "commented_code": "@@ -32,50 +34,14 @@ class AdbClient {\n \n   using DeviceIDList = std::list<std::string>;\n \n-  class SyncService {\n-    friend class AdbClient;\n-\n-  public:\n-    virtual ~SyncService();\n-\n-    virtual Status PullFile(const FileSpec &remote_file,\n-                            const FileSpec &local_file);\n-\n-    Status PushFile(const FileSpec &local_file, const FileSpec &remote_file);\n-\n-    virtual Status Stat(const FileSpec &remote_file, uint32_t &mode,\n-                        uint32_t &size, uint32_t &mtime);\n-\n-    bool IsConnected() const;\n-\n-  protected:\n-    explicit SyncService(std::unique_ptr<Connection> &&conn);\n-\n-  private:\n-    Status SendSyncRequest(const char *request_id, const uint32_t data_len,\n-                           const void *data);\n-\n-    Status ReadSyncHeader(std::string &response_id, uint32_t &data_len);\n-\n-    Status PullFileChunk(std::vector<char> &buffer, bool &eof);\n-\n-    Status ReadAllBytes(void *buffer, size_t size);\n-\n-    Status internalPullFile(const FileSpec &remote_file,\n-                            const FileSpec &local_file);\n-\n-    Status internalPushFile(const FileSpec &local_file,\n-                            const FileSpec &remote_file);\n-\n-    Status internalStat(const FileSpec &remote_file, uint32_t &mode,\n-                        uint32_t &size, uint32_t &mtime);\n-\n-    Status executeCommand(const std::function<Status()> &cmd);\n-\n-    std::unique_ptr<Connection> m_conn;\n-  };\n-\n-  static Status CreateByDeviceID(const std::string &device_id, AdbClient &adb);\n+  /// Resolves a device identifier to its canonical form.\n+  ///\n+  /// \\param device_id the device identifier to resolve (may be empty).\n+  /// \\param [out] resolved_device_id filled with the canonical device ID.\n+  ///\n+  /// \\returns Status object indicating success or failure. Returns error if\n+  ///          the device ID cannot be resolved or is ambiguous.\n+  static Status ResolveDeviceID(const std::string &device_id, std::string &resolved_device_id);",
        "comment_created_at": "2025-07-25T12:30:16+00:00",
        "comment_author": "labath",
        "comment_body": "```suggestion\r\n  static llvm::Expected<std::string> ResolveDeviceID(llvm::StringRef device_id);\r\n```",
        "pr_file_module": null
      }
    ]
  }
]