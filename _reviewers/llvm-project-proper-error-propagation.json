[
  {
    "discussion_id": "2211630385",
    "pr_number": 148013,
    "pr_file": "llvm/tools/llvm-profgen/PerfReader.cpp",
    "created_at": "2025-07-16T21:17:10+00:00",
    "commented_code": "return PerfReader;\n }\n \n+void PerfReaderBase::parseDataAccessPerfTraces(\n+    StringRef DataAccessPerfTraceFile, std::optional<int32_t> PIDFilter) {\n+  std::regex logRegex(\n+      R\"(^.*?PERF_RECORD_SAMPLE\\(.*?\\):\\s*(\\d+)\\/(\\d+):\\s*(0x[0-9a-fA-F]+)\\s+period:\\s*\\d+\\s+addr:\\s*(0x[0-9a-fA-F]+)$)\");\n+\n+  auto BufferOrErr = MemoryBuffer::getFile(DataAccessPerfTraceFile);\n+  std::error_code EC = BufferOrErr.getError();\n+  if (EC)",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2211630385",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148013,
        "pr_file": "llvm/tools/llvm-profgen/PerfReader.cpp",
        "discussion_id": "2211630385",
        "commented_code": "@@ -370,6 +377,61 @@ PerfReaderBase::create(ProfiledBinary *Binary, PerfInputFile &PerfInput,\n   return PerfReader;\n }\n \n+void PerfReaderBase::parseDataAccessPerfTraces(\n+    StringRef DataAccessPerfTraceFile, std::optional<int32_t> PIDFilter) {\n+  std::regex logRegex(\n+      R\"(^.*?PERF_RECORD_SAMPLE\\(.*?\\):\\s*(\\d+)\\/(\\d+):\\s*(0x[0-9a-fA-F]+)\\s+period:\\s*\\d+\\s+addr:\\s*(0x[0-9a-fA-F]+)$)\");\n+\n+  auto BufferOrErr = MemoryBuffer::getFile(DataAccessPerfTraceFile);\n+  std::error_code EC = BufferOrErr.getError();\n+  if (EC)",
        "comment_created_at": "2025-07-16T21:17:10+00:00",
        "comment_author": "snehasish",
        "comment_body": "IMO this error should be handled by the caller of this function. It seems a little out of place to exit from this library method.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216932712",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148013,
        "pr_file": "llvm/tools/llvm-profgen/PerfReader.cpp",
        "discussion_id": "2211630385",
        "commented_code": "@@ -370,6 +377,61 @@ PerfReaderBase::create(ProfiledBinary *Binary, PerfInputFile &PerfInput,\n   return PerfReader;\n }\n \n+void PerfReaderBase::parseDataAccessPerfTraces(\n+    StringRef DataAccessPerfTraceFile, std::optional<int32_t> PIDFilter) {\n+  std::regex logRegex(\n+      R\"(^.*?PERF_RECORD_SAMPLE\\(.*?\\):\\s*(\\d+)\\/(\\d+):\\s*(0x[0-9a-fA-F]+)\\s+period:\\s*\\d+\\s+addr:\\s*(0x[0-9a-fA-F]+)$)\");\n+\n+  auto BufferOrErr = MemoryBuffer::getFile(DataAccessPerfTraceFile);\n+  std::error_code EC = BufferOrErr.getError();\n+  if (EC)",
        "comment_created_at": "2025-07-18T21:16:56+00:00",
        "comment_author": "mingmingl-llvm",
        "comment_body": "done by returning error_code in this function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2231668709",
    "pr_number": 149232,
    "pr_file": "llvm/lib/Target/DirectX/DXILRootSignature.cpp",
    "created_at": "2025-07-25T17:27:38+00:00",
    "commented_code": "reportError(Ctx, \"Root Element is not a metadata node.\");\n       continue;\n     }\n-    mcdxbc::RootSignatureDesc RSD;\n-    if (std::optional<uint32_t> Version = extractMdIntValue(RSDefNode, 2))\n-      RSD.Version = *Version;\n-    else {\n+    std::optional<uint32_t> V = extractMdIntValue(RSDefNode, 2);\n+    if (!V.has_value()) {\n       reportError(Ctx, \"Invalid RSDefNode value, expected constant int\");\n       continue;\n     }\n \n+    llvm::hlsl::rootsig::MetadataParser MDParser(RootElementListNode);\n+    llvm::Expected<mcdxbc::RootSignatureDesc> RSDOrErr =\n+        MDParser.ParseRootSignature(V.value());\n+\n+    if (auto Err = RSDOrErr.takeError()) {\n+      reportError(Ctx, toString(std::move(Err)));",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2231668709",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149232,
        "pr_file": "llvm/lib/Target/DirectX/DXILRootSignature.cpp",
        "discussion_id": "2231668709",
        "commented_code": "@@ -111,14 +110,23 @@ analyzeModule(Module &M) {\n       reportError(Ctx, \"Root Element is not a metadata node.\");\n       continue;\n     }\n-    mcdxbc::RootSignatureDesc RSD;\n-    if (std::optional<uint32_t> Version = extractMdIntValue(RSDefNode, 2))\n-      RSD.Version = *Version;\n-    else {\n+    std::optional<uint32_t> V = extractMdIntValue(RSDefNode, 2);\n+    if (!V.has_value()) {\n       reportError(Ctx, \"Invalid RSDefNode value, expected constant int\");\n       continue;\n     }\n \n+    llvm::hlsl::rootsig::MetadataParser MDParser(RootElementListNode);\n+    llvm::Expected<mcdxbc::RootSignatureDesc> RSDOrErr =\n+        MDParser.ParseRootSignature(V.value());\n+\n+    if (auto Err = RSDOrErr.takeError()) {\n+      reportError(Ctx, toString(std::move(Err)));",
        "comment_created_at": "2025-07-25T17:27:38+00:00",
        "comment_author": "llvm-beanz",
        "comment_body": "In general with errors especially if they can be more than one error you don't just want to call toString, you should handle each error.\r\n\r\nI think this is about right, but you'll need to try it:\r\n```suggestion\r\n    if (!RSDOrErr) {\r\n      handleAllErrors(RSDOrErr.takeError(), [&](ErrorInfoBase &EIB) {\r\n        Ctx->emitError(EI.message());\r\n      });\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214048058",
    "pr_number": 148948,
    "pr_file": "libc/src/__support/threads/barrier.cpp",
    "created_at": "2025-07-17T18:46:07+00:00",
    "commented_code": "+//===-- Implementation of Barrier class ------------- ---------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/__support/threads/barrier.h\"\n+#include \"barrier.h\"\n+#include \"hdr/errno_macros.h\"\n+#include \"src/__support/threads/mutex.h\"\n+\n+namespace LIBC_NAMESPACE_DECL {\n+\n+const int BARRIER_FIRST_EXITED = -1;\n+\n+int Barrier::init(Barrier *b,\n+                  const pthread_barrierattr_t *attr __attribute__((unused)),\n+                  unsigned count) {\n+  LIBC_ASSERT(attr == nullptr); // TODO implement barrierattr\n+  if (count == 0)\n+    return EINVAL;\n+\n+  b->expected = count;\n+  b->waiting = 0;\n+  b->blocking = true;\n+\n+  int err;\n+  err = CndVar::init(&b->entering);\n+  if (err != 0)\n+    return err;\n+\n+  err = CndVar::init(&b->exiting);\n+  if (err != 0)\n+    return err;\n+\n+  Mutex::init(&b->m, false, false, false, false);",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214048058",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148948,
        "pr_file": "libc/src/__support/threads/barrier.cpp",
        "discussion_id": "2214048058",
        "commented_code": "@@ -0,0 +1,83 @@\n+//===-- Implementation of Barrier class ------------- ---------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/__support/threads/barrier.h\"\n+#include \"barrier.h\"\n+#include \"hdr/errno_macros.h\"\n+#include \"src/__support/threads/mutex.h\"\n+\n+namespace LIBC_NAMESPACE_DECL {\n+\n+const int BARRIER_FIRST_EXITED = -1;\n+\n+int Barrier::init(Barrier *b,\n+                  const pthread_barrierattr_t *attr __attribute__((unused)),\n+                  unsigned count) {\n+  LIBC_ASSERT(attr == nullptr); // TODO implement barrierattr\n+  if (count == 0)\n+    return EINVAL;\n+\n+  b->expected = count;\n+  b->waiting = 0;\n+  b->blocking = true;\n+\n+  int err;\n+  err = CndVar::init(&b->entering);\n+  if (err != 0)\n+    return err;\n+\n+  err = CndVar::init(&b->exiting);\n+  if (err != 0)\n+    return err;\n+\n+  Mutex::init(&b->m, false, false, false, false);",
        "comment_created_at": "2025-07-17T18:46:07+00:00",
        "comment_author": "brooksmoses",
        "comment_body": "Why aren't we checking this for an error return?\r\n\r\n(I see that currently `Mutex::init` always returns `MutexError::NONE`, but that could change in the future.  Alternately, if we don't expect it to change, then the `Mutex::init` function shouldn't have a return value.)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2197912123",
    "pr_number": 147959,
    "pr_file": "clang/lib/Basic/SanitizerSpecialCaseList.cpp",
    "created_at": "2025-07-10T14:33:21+00:00",
    "commented_code": "std::unique_ptr<SanitizerSpecialCaseList>\n SanitizerSpecialCaseList::createOrDie(const std::vector<std::string> &Paths,\n-                                      llvm::vfs::FileSystem &VFS) {\n+                                      llvm::vfs::FileSystem &VFS,\n+                                      DiagnosticsEngine &Diags) {\n   std::string Error;\n   if (auto SSCL = create(Paths, VFS, Error))\n     return SSCL;\n-  llvm::report_fatal_error(StringRef(Error));\n+  unsigned DiagID = Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n+                                          \"failed to load NoSanitize file: %0\");",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2197912123",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/Basic/SanitizerSpecialCaseList.cpp",
        "discussion_id": "2197912123",
        "commented_code": "@@ -30,11 +30,16 @@ SanitizerSpecialCaseList::create(const std::vector<std::string> &Paths,\n \n std::unique_ptr<SanitizerSpecialCaseList>\n SanitizerSpecialCaseList::createOrDie(const std::vector<std::string> &Paths,\n-                                      llvm::vfs::FileSystem &VFS) {\n+                                      llvm::vfs::FileSystem &VFS,\n+                                      DiagnosticsEngine &Diags) {\n   std::string Error;\n   if (auto SSCL = create(Paths, VFS, Error))\n     return SSCL;\n-  llvm::report_fatal_error(StringRef(Error));\n+  unsigned DiagID = Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n+                                          \"failed to load NoSanitize file: %0\");",
        "comment_created_at": "2025-07-10T14:33:21+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "This shouldn't be a custom diagnostic; I would imagine this would be a driver diagnostic. But we can't emit driver diagnostics from Basic.\r\n\r\nI think we need a bit wider of an approach where `createOrDie` is `create` which the caller has to respond to if it returns an empty `unique_ptr` so that the driver eventually is what emits the diagnostic.\r\n\r\nCC @MaskRay for more opinions",
        "pr_file_module": null
      },
      {
        "comment_id": "2212955825",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/Basic/SanitizerSpecialCaseList.cpp",
        "discussion_id": "2197912123",
        "commented_code": "@@ -30,11 +30,16 @@ SanitizerSpecialCaseList::create(const std::vector<std::string> &Paths,\n \n std::unique_ptr<SanitizerSpecialCaseList>\n SanitizerSpecialCaseList::createOrDie(const std::vector<std::string> &Paths,\n-                                      llvm::vfs::FileSystem &VFS) {\n+                                      llvm::vfs::FileSystem &VFS,\n+                                      DiagnosticsEngine &Diags) {\n   std::string Error;\n   if (auto SSCL = create(Paths, VFS, Error))\n     return SSCL;\n-  llvm::report_fatal_error(StringRef(Error));\n+  unsigned DiagID = Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n+                                          \"failed to load NoSanitize file: %0\");",
        "comment_created_at": "2025-07-17T10:21:02+00:00",
        "comment_author": "woruyu",
        "comment_body": "@MaskRay Do you have any thoughts on this approach? Would appreciate your input.",
        "pr_file_module": null
      },
      {
        "comment_id": "2217383322",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/Basic/SanitizerSpecialCaseList.cpp",
        "discussion_id": "2197912123",
        "commented_code": "@@ -30,11 +30,16 @@ SanitizerSpecialCaseList::create(const std::vector<std::string> &Paths,\n \n std::unique_ptr<SanitizerSpecialCaseList>\n SanitizerSpecialCaseList::createOrDie(const std::vector<std::string> &Paths,\n-                                      llvm::vfs::FileSystem &VFS) {\n+                                      llvm::vfs::FileSystem &VFS,\n+                                      DiagnosticsEngine &Diags) {\n   std::string Error;\n   if (auto SSCL = create(Paths, VFS, Error))\n     return SSCL;\n-  llvm::report_fatal_error(StringRef(Error));\n+  unsigned DiagID = Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n+                                          \"failed to load NoSanitize file: %0\");",
        "comment_created_at": "2025-07-19T17:27:26+00:00",
        "comment_author": "MaskRay",
        "comment_body": "I agree that ideally this error reporting is delayed.\r\n\r\ncreateOrDie is called by NoSanitizeList::NoSanitizeList, which is called by ASTContext::ASTContext. To report a proper diagnostic, we need to remove these calls from ctors to an init function.",
        "pr_file_module": null
      },
      {
        "comment_id": "2218465312",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/Basic/SanitizerSpecialCaseList.cpp",
        "discussion_id": "2197912123",
        "commented_code": "@@ -30,11 +30,16 @@ SanitizerSpecialCaseList::create(const std::vector<std::string> &Paths,\n \n std::unique_ptr<SanitizerSpecialCaseList>\n SanitizerSpecialCaseList::createOrDie(const std::vector<std::string> &Paths,\n-                                      llvm::vfs::FileSystem &VFS) {\n+                                      llvm::vfs::FileSystem &VFS,\n+                                      DiagnosticsEngine &Diags) {\n   std::string Error;\n   if (auto SSCL = create(Paths, VFS, Error))\n     return SSCL;\n-  llvm::report_fatal_error(StringRef(Error));\n+  unsigned DiagID = Diags.getCustomDiagID(clang::DiagnosticsEngine::Error,\n+                                          \"failed to load NoSanitize file: %0\");",
        "comment_created_at": "2025-07-21T08:03:29+00:00",
        "comment_author": "woruyu",
        "comment_body": "Done! I have refactor it!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219169653",
    "pr_number": 147959,
    "pr_file": "clang/lib/AST/ASTContext.cpp",
    "created_at": "2025-07-21T13:09:18+00:00",
    "commented_code": "return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2219169653",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-21T13:09:18+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "I think this assumes that the first file in the list is the one we cannot read; what happens if we can read that one fine but a subsequent file is where we struggle? We'd report the wrong path to the user in that case, which would be hard for them to reason about.",
        "pr_file_module": null
      },
      {
        "comment_id": "2221791797",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-22T08:56:21+00:00",
        "comment_author": "woruyu",
        "comment_body": "There are two kind of error for NoSanitizeL. The first is `can't open file`, the second is `error parsing file`, so I think using CustomDiagID is better!",
        "pr_file_module": null
      },
      {
        "comment_id": "2222216948",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-22T11:19:39+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "> so I think using CustomDiagID is better!\r\n\r\nCustom diagnostics are not an acceptable solution IMO; the reason is because they don't get a warning group associated with them and so users have no way to silence those diagnostics. We have some uses of the API in Clang but in every case they're the wrong tool to use.\r\n\r\nWe actually document this on the API itself, but not very clearly: https://github.com/llvm/llvm-project/blob/b3e016e05f1d21428298760db82b26fd0266f8bb/clang/include/clang/Basic/Diagnostic.h#L898 (I'll fix up the comment)",
        "pr_file_module": null
      },
      {
        "comment_id": "2224540164",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-23T06:30:25+00:00",
        "comment_author": "woruyu",
        "comment_body": "> Custom diagnostics are not an acceptable solution IMO;\r\n\r\nThanks for the feedback! To confirm: is the correct fix to define dedicated diagnostics in a `.td` file like this:\r\n```\r\ndef err_no_sanitize_file_open_fail : Error<\r\n  \"failed to load NoSanitize file: can't open file '%0'\">;\r\n\r\ndef err_no_sanitize_file_parse_fail : Error<\r\n  \"failed to load NoSanitize file: error parsing file '%0'\">;\r\n\r\ndef SanitizeIgnorelist : DiagGroup<\"sanitize-ignorelist\">;\r\n```\r\nThen use them accordingly in `ASTContext::initSanitizers`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2225393961",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-23T12:18:09+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "Almost! You can split the diagnostics up if that's easier for you, but another approach would be:\r\n```\r\ndef err_no_sanitize_file_failure : Error<\r\n  \"failed to %select{load|parse}0 sanitizer ignorelist file '%1'\">;\r\n```\r\nwhere you only have a single diagnostic but pass in an argument to switch between `load` and `parse`.\r\n\r\nNote, you don't need:\r\n\r\n> `def SanitizeIgnorelist : DiagGroup<\"sanitize-ignorelist\">;`\r\n\r\nbecause diagnostic groups are only for warnings, and you're producing errors.",
        "pr_file_module": null
      },
      {
        "comment_id": "2227599156",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-24T06:53:35+00:00",
        "comment_author": "woruyu",
        "comment_body": "I decided to go with:\r\n```\r\ndef err_sanitize_ignorelist_failure : Error<\r\n  \"failed to sanitize ignorelist file: %0\">;\r\n```\r\ninstead of \r\n```\r\ndef err_no_sanitize_file_failure : Error<\r\n  \"failed to %select{load|parse}0 sanitizer ignorelist file '%1'\">;\r\n```\r\nfor two reasons:\r\n1.The `%select` logic is essentially string formatting and can be handled downstream where the error message is constructed.\r\n2.Changing `SpecialCaseList::createInternal` to propagate structured error info adds unnecessary complexity, especially given its general-purpose nature.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2229066634",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-24T16:58:33+00:00",
        "comment_author": "AaronBallman",
        "comment_body": "> 1.The %select logic is essentially string formatting and can be handled downstream where the error message is constructed.\r\n\r\nWellllll kind of yes but also kind of no. We try to avoid tying together strings like that because there are downstreams which want to localize diagnostic messages (and we'd like to someday do the same upstream). It's easier for localizers to handle `%select` for any various languages instead of having to try to reword diagnostics so that they still make sense with arbitrary string concatenation. So it works but we prefer `%select` whenever possible.\r\n\r\n> 2.Changing SpecialCaseList::createInternal to propagate structured error info adds unnecessary complexity, especially given its general-purpose nature.\r\n\r\nWe currently have to thread through the error string, the suggestion is to use an enumeration as well as a string. e.g., \r\n`\"failed to %enum_select<SpecialCaseListFailure>{%Open{open}|%Parse{parse}}0 sanitizer ignorelist file: %1\">;` as the diagnostic message, and then use `std::pair<unsigned, std::string>` for passing the diagnostic information around, where the first parameter would be something like: `diag::SpecialCaseListFailure::Open`. So when you go to emit the diagnostic, it would effectively be: `Diag(Loc, diag::err_no_sanitize_file_failure) << Error.first << Error.second;`\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2230058064",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147959,
        "pr_file": "clang/lib/AST/ASTContext.cpp",
        "discussion_id": "2219169653",
        "commented_code": "@@ -1697,6 +1698,15 @@ ASTContext::getRelocationInfoForCXXRecord(const CXXRecordDecl *RD) const {\n   return std::nullopt;\n }\n \n+void ASTContext::initSanitizers(const LangOptions &LangOpts,\n+                                SourceManager &SM) {\n+  std::string Error;\n+  if (!NoSanitizeL->init(LangOpts.NoSanitizeFiles, Error)) {\n+    const std::string &Path = LangOpts.NoSanitizeFiles.front();",
        "comment_created_at": "2025-07-25T03:27:08+00:00",
        "comment_author": "woruyu",
        "comment_body": "Done! By the way, I find many diagnose to modify such as ` err_drv_malformed_sanitizer_coverage_allowlist, err_drv_malformed_sanitizer_ignorelist` and so on, but I get a redefine error of SpecialCaseListFailure, so I change it to %select.",
        "pr_file_module": null
      }
    ]
  }
]