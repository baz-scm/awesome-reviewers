[
  {
    "discussion_id": "2157489841",
    "pr_number": 144926,
    "pr_file": "mlir/lib/Conversion/ComplexToROCDL/ComplexToROCDL.cpp",
    "created_at": "2025-06-19T18:21:21+00:00",
    "commented_code": "+//===-- ComplexToROCDL.cpp - conversion from Complex to ROCDL calls -------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"mlir/Conversion/ComplexToROCDL/ComplexToROCDL.h\"\n+#include \"mlir/Dialect/Complex/IR/Complex.h\"\n+#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n+#include \"mlir/IR/PatternMatch.h\"\n+#include \"mlir/Transforms/DialectConversion.h\"\n+#include <optional>\n+\n+namespace mlir {\n+#define GEN_PASS_DEF_CONVERTCOMPLEXTOROCDL\n+#include \"mlir/Conversion/Passes.h.inc\"\n+} // namespace mlir\n+\n+using namespace mlir;\n+\n+namespace {\n+struct FloatTypeResolver {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2157489841",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 144926,
        "pr_file": "mlir/lib/Conversion/ComplexToROCDL/ComplexToROCDL.cpp",
        "discussion_id": "2157489841",
        "commented_code": "@@ -0,0 +1,94 @@\n+//===-- ComplexToROCDL.cpp - conversion from Complex to ROCDL calls -------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"mlir/Conversion/ComplexToROCDL/ComplexToROCDL.h\"\n+#include \"mlir/Dialect/Complex/IR/Complex.h\"\n+#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n+#include \"mlir/IR/PatternMatch.h\"\n+#include \"mlir/Transforms/DialectConversion.h\"\n+#include <optional>\n+\n+namespace mlir {\n+#define GEN_PASS_DEF_CONVERTCOMPLEXTOROCDL\n+#include \"mlir/Conversion/Passes.h.inc\"\n+} // namespace mlir\n+\n+using namespace mlir;\n+\n+namespace {\n+struct FloatTypeResolver {",
        "comment_created_at": "2025-06-19T18:21:21+00:00",
        "comment_author": "ftynse",
        "comment_body": "Please document top-level entities.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214069686",
    "pr_number": 148948,
    "pr_file": "libc/src/__support/threads/barrier.cpp",
    "created_at": "2025-07-17T18:58:04+00:00",
    "commented_code": "+//===-- Implementation of Barrier class ------------- ---------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/__support/threads/barrier.h\"\n+#include \"barrier.h\"\n+#include \"hdr/errno_macros.h\"\n+#include \"src/__support/threads/mutex.h\"\n+\n+namespace LIBC_NAMESPACE_DECL {\n+\n+const int BARRIER_FIRST_EXITED = -1;\n+\n+int Barrier::init(Barrier *b,\n+                  const pthread_barrierattr_t *attr __attribute__((unused)),\n+                  unsigned count) {\n+  LIBC_ASSERT(attr == nullptr); // TODO implement barrierattr\n+  if (count == 0)\n+    return EINVAL;\n+\n+  b->expected = count;\n+  b->waiting = 0;\n+  b->blocking = true;\n+\n+  int err;\n+  err = CndVar::init(&b->entering);\n+  if (err != 0)\n+    return err;\n+\n+  err = CndVar::init(&b->exiting);\n+  if (err != 0)\n+    return err;\n+\n+  Mutex::init(&b->m, false, false, false, false);\n+  return 0;\n+}\n+\n+int Barrier::wait() {\n+  m.lock();\n+\n+  // if the barrier is emptying out threads, wait until it finishes\n+  while (!blocking) {\n+    entering.wait(&m);\n+  }\n+  waiting++;\n+\n+  if (waiting == expected) {\n+    // this is the last thread to call wait(), so lets wake everyone up\n+    blocking = false;\n+    exiting.broadcast();\n+  } else {\n+    // block threads until waiting = expected\n+    while (blocking) {\n+      exiting.wait(&m);\n+    }\n+  }\n+  waiting--;\n+\n+  // all threads have exited the barrier, lets let the ones waiting to enter\n+  // continue",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2214069686",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148948,
        "pr_file": "libc/src/__support/threads/barrier.cpp",
        "discussion_id": "2214069686",
        "commented_code": "@@ -0,0 +1,83 @@\n+//===-- Implementation of Barrier class ------------- ---------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"src/__support/threads/barrier.h\"\n+#include \"barrier.h\"\n+#include \"hdr/errno_macros.h\"\n+#include \"src/__support/threads/mutex.h\"\n+\n+namespace LIBC_NAMESPACE_DECL {\n+\n+const int BARRIER_FIRST_EXITED = -1;\n+\n+int Barrier::init(Barrier *b,\n+                  const pthread_barrierattr_t *attr __attribute__((unused)),\n+                  unsigned count) {\n+  LIBC_ASSERT(attr == nullptr); // TODO implement barrierattr\n+  if (count == 0)\n+    return EINVAL;\n+\n+  b->expected = count;\n+  b->waiting = 0;\n+  b->blocking = true;\n+\n+  int err;\n+  err = CndVar::init(&b->entering);\n+  if (err != 0)\n+    return err;\n+\n+  err = CndVar::init(&b->exiting);\n+  if (err != 0)\n+    return err;\n+\n+  Mutex::init(&b->m, false, false, false, false);\n+  return 0;\n+}\n+\n+int Barrier::wait() {\n+  m.lock();\n+\n+  // if the barrier is emptying out threads, wait until it finishes\n+  while (!blocking) {\n+    entering.wait(&m);\n+  }\n+  waiting++;\n+\n+  if (waiting == expected) {\n+    // this is the last thread to call wait(), so lets wake everyone up\n+    blocking = false;\n+    exiting.broadcast();\n+  } else {\n+    // block threads until waiting = expected\n+    while (blocking) {\n+      exiting.wait(&m);\n+    }\n+  }\n+  waiting--;\n+\n+  // all threads have exited the barrier, lets let the ones waiting to enter\n+  // continue",
        "comment_created_at": "2025-07-17T18:58:04+00:00",
        "comment_author": "brooksmoses",
        "comment_body": "Here you have the condition-explaining comment before the `if`, but above you have the comments within the `if`.  This should be consistent.\r\n\r\nAlso, this should be \"let's\", and the comment should probably mention why `BARRIER_FIRST_EXITED` is being set for this condition.  (Something like \"Posix expects the return value to be `PTHREAD_BARRIER_SERIAL_THREAD` for exactly one arbitrary thread in the set, so it might as well be this one,\" perhaps?)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2201261299",
    "pr_number": 140282,
    "pr_file": "clang/lib/Sema/SemaDecl.cpp",
    "created_at": "2025-07-11T16:43:40+00:00",
    "commented_code": "diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n     }\n \n+    // SYCL spec 2020\n+    //   The first declaration of a function with external linkage must\n+    //   specify sycl_external attribute.\n+    //   Subsequent declarations may optionally specify this attribute.",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2201261299",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/Sema/SemaDecl.cpp",
        "discussion_id": "2201261299",
        "commented_code": "@@ -4084,6 +4084,19 @@ bool Sema::MergeFunctionDecl(FunctionDecl *New, NamedDecl *&OldD, Scope *S,\n            diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n     }\n \n+    // SYCL spec 2020\n+    //   The first declaration of a function with external linkage must\n+    //   specify sycl_external attribute.\n+    //   Subsequent declarations may optionally specify this attribute.",
        "comment_created_at": "2025-07-11T16:43:40+00:00",
        "comment_author": "tahonermann",
        "comment_body": "It is helpful to quote the specification verbatim so that the intent is understood from the quoted context in the event that the specification changes.\r\n```suggestion\r\n    // SYCL 2020 section 5.10.1, \"SYCL functions and member functions linkage\":\r\n    //   When a function is declared with SYCL_EXTERNAL, that macro must be\r\n    //   used on the first declaration of that function in the translation unit.\r\n    //   Redeclarations of the function in the same translation unit may\r\n    //   optionally use SYCL_EXTERNAL, but this is not required.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2201840656",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/Sema/SemaDecl.cpp",
        "discussion_id": "2201261299",
        "commented_code": "@@ -4084,6 +4084,19 @@ bool Sema::MergeFunctionDecl(FunctionDecl *New, NamedDecl *&OldD, Scope *S,\n            diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n     }\n \n+    // SYCL spec 2020\n+    //   The first declaration of a function with external linkage must\n+    //   specify sycl_external attribute.\n+    //   Subsequent declarations may optionally specify this attribute.",
        "comment_created_at": "2025-07-11T21:00:13+00:00",
        "comment_author": "schittir",
        "comment_body": "Thank you for the suggestion. \r\nI will implement the wording as it is except for one point - wouldn't it be better to use `sycl_external` attribute instead of `SYCL_EXTERNAL` macro which is not yet implemented?  ",
        "pr_file_module": null
      },
      {
        "comment_id": "2202195211",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/Sema/SemaDecl.cpp",
        "discussion_id": "2201261299",
        "commented_code": "@@ -4084,6 +4084,19 @@ bool Sema::MergeFunctionDecl(FunctionDecl *New, NamedDecl *&OldD, Scope *S,\n            diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n     }\n \n+    // SYCL spec 2020\n+    //   The first declaration of a function with external linkage must\n+    //   specify sycl_external attribute.\n+    //   Subsequent declarations may optionally specify this attribute.",
        "comment_created_at": "2025-07-12T00:29:45+00:00",
        "comment_author": "tahonermann",
        "comment_body": "I tend towards quoting the text verbatim. Readers are likely to be aware that the intent of the `sycl_external` attribute is to implement the `SYCL_EXTERNAL` macro; that was made clear in the documentation for the attribute.",
        "pr_file_module": null
      },
      {
        "comment_id": "2204971979",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/lib/Sema/SemaDecl.cpp",
        "discussion_id": "2201261299",
        "commented_code": "@@ -4084,6 +4084,19 @@ bool Sema::MergeFunctionDecl(FunctionDecl *New, NamedDecl *&OldD, Scope *S,\n            diag::note_carries_dependency_missing_first_decl) << 0/*Function*/;\n     }\n \n+    // SYCL spec 2020\n+    //   The first declaration of a function with external linkage must\n+    //   specify sycl_external attribute.\n+    //   Subsequent declarations may optionally specify this attribute.",
        "comment_created_at": "2025-07-14T13:38:30+00:00",
        "comment_author": "schittir",
        "comment_body": "Makes sense. Thank you. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218572817",
    "pr_number": 147198,
    "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinuxArm64Shared.cpp",
    "created_at": "2025-07-21T08:58:38+00:00",
    "commented_code": "+#include \"NativeRegisterContextLinuxArm64Shared.h\"",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2218572817",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinuxArm64Shared.cpp",
        "discussion_id": "2218572817",
        "commented_code": "@@ -0,0 +1,63 @@\n+#include \"NativeRegisterContextLinuxArm64Shared.h\"",
        "comment_created_at": "2025-07-21T08:58:38+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "All new .cpp and .h files need the license header, you can copy one from an existing file and modify it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2218589076",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinuxArm64Shared.cpp",
        "discussion_id": "2218572817",
        "commented_code": "@@ -0,0 +1,63 @@\n+#include \"NativeRegisterContextLinuxArm64Shared.h\"",
        "comment_created_at": "2025-07-21T09:05:36+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "Also the top of this file needs a comment explaining why it needed to be split out.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2231583039",
    "pr_number": 150572,
    "pr_file": "mlir/lib/Dialect/EmitC/Transforms/AddReflectionMap.cpp",
    "created_at": "2025-07-25T16:40:21+00:00",
    "commented_code": "+//===- AddReflectionMap.cpp - Add a reflection map to a class -------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"mlir/Dialect/EmitC/IR/EmitC.h\"\n+#include \"mlir/Dialect/EmitC/Transforms/Passes.h\"\n+#include \"mlir/Dialect/EmitC/Transforms/Transforms.h\"\n+#include \"mlir/IR/Attributes.h\"\n+#include \"mlir/IR/Builders.h\"\n+#include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"mlir/IR/PatternMatch.h\"\n+#include \"mlir/Transforms/WalkPatternRewriteDriver.h\"\n+\n+using namespace mlir;\n+using namespace emitc;\n+\n+namespace mlir {\n+namespace emitc {\n+#define GEN_PASS_DEF_ADDREFLECTIONMAPPASS\n+#include \"mlir/Dialect/EmitC/Transforms/Passes.h.inc\"\n+\n+namespace {\n+constexpr const char *kMapLibraryHeader = \"map\";\n+constexpr const char *kStringLibraryHeader = \"string\";\n+class AddReflectionMapPass\n+    : public impl::AddReflectionMapPassBase<AddReflectionMapPass> {\n+  using AddReflectionMapPassBase::AddReflectionMapPassBase;\n+  void runOnOperation() override {\n+    mlir::ModuleOp module = getOperation();\n+\n+    RewritePatternSet patterns(&getContext());\n+    populateAddReflectionMapPatterns(patterns, namedAttribute);\n+\n+    walkAndApplyPatterns(module, std::move(patterns));\n+    bool hasMap = false;\n+    bool hasString = false;\n+    for (auto &op : *module.getBody()) {\n+      emitc::IncludeOp includeOp = llvm::dyn_cast<mlir::emitc::IncludeOp>(op);\n+      if (!includeOp)\n+        continue;\n+      if (includeOp.getIsStandardInclude()) {\n+        if (includeOp.getInclude() == kMapLibraryHeader)\n+          hasMap = true;\n+        if (includeOp.getInclude() == kStringLibraryHeader)\n+          hasString = true;\n+      }\n+    }\n+\n+    if (hasMap && hasString)\n+      return;\n+\n+    mlir::OpBuilder builder(module.getBody(), module.getBody()->begin());\n+    if (!hasMap) {\n+      StringAttr includeAttr = builder.getStringAttr(kMapLibraryHeader);\n+      builder.create<mlir::emitc::IncludeOp>(\n+          module.getLoc(), includeAttr,\n+          /*is_standard_include=*/builder.getUnitAttr());\n+    }\n+    if (!hasString) {\n+      StringAttr includeAttr = builder.getStringAttr(kStringLibraryHeader);\n+      builder.create<emitc::IncludeOp>(\n+          module.getLoc(), includeAttr,\n+          /*is_standard_include=*/builder.getUnitAttr());\n+    }\n+  }\n+};\n+\n+} // namespace\n+} // namespace emitc\n+} // namespace mlir\n+\n+class AddReflectionMapClass : public OpRewritePattern<emitc::ClassOp> {\n+public:\n+  AddReflectionMapClass(MLIRContext *context, StringRef attrName)\n+      : OpRewritePattern<emitc::ClassOp>(context), attributeName(attrName) {}\n+\n+  LogicalResult matchAndRewrite(mlir::emitc::ClassOp classOp,\n+                                PatternRewriter &rewriter) const override {\n+    mlir::MLIRContext *context = rewriter.getContext();\n+    emitc::OpaqueType stringViewType =\n+        mlir::emitc::OpaqueType::get(rewriter.getContext(), \"std::string_view\");\n+    emitc::OpaqueType charType =\n+        mlir::emitc::OpaqueType::get(rewriter.getContext(), \"char\");\n+    emitc::OpaqueType mapType = mlir::emitc::OpaqueType::get(\n+        rewriter.getContext(), \"const std::map<std::string, char*>\");\n+\n+    FunctionType funcType =\n+        rewriter.getFunctionType({stringViewType}, {charType});\n+    emitc::FuncOp executeFunc =\n+        classOp.lookupSymbol<mlir::emitc::FuncOp>(\"execute\");\n+    if (executeFunc)\n+      rewriter.setInsertionPoint(executeFunc);\n+    else\n+      classOp.emitError() << \"ClassOp must contain a function named 'execute' \"\n+                             \"to add reflection map\";\n+\n+    emitc::FuncOp getBufferFunc = rewriter.create<mlir::emitc::FuncOp>(\n+        classOp.getLoc(), \"getBufferForName\", funcType);\n+\n+    Block *funcBody = getBufferFunc.addEntryBlock();\n+    rewriter.setInsertionPointToStart(funcBody);\n+\n+    // Collect all field names\n+    std::vector<std::pair<std::string, std::string>> fieldNames;\n+    classOp.walk([&](mlir::emitc::FieldOp fieldOp) {\n+      if (mlir::Attribute attrsAttr =\n+              fieldOp->getAttrDictionary().get(\"attrs\")) {\n+        if (DictionaryAttr innerDictAttr =\n+                dyn_cast<mlir::DictionaryAttr>(attrsAttr)) {\n+          ArrayAttr arrayAttr = dyn_cast<mlir::ArrayAttr>(\n+              innerDictAttr.getNamed(attributeName)->getValue());\n+          if (!arrayAttr.empty()) {\n+            StringAttr stringAttr = dyn_cast<mlir::StringAttr>(arrayAttr[0]);\n+            std::string indexPath = stringAttr.getValue().str();\n+            fieldNames.emplace_back(indexPath, fieldOp.getName().str());\n+          }\n+          if (arrayAttr.size() > 1) {\n+            fieldOp.emitError() << attributeName\n+                                << \" attribute must \"\n+                                   \"contain at most one value, but found \"\n+                                << arrayAttr.size() << \" values.\";\n+            return;\n+          }\n+        }\n+      }\n+    });\n+\n+    std::string mapInitializer = \"{ \";\n+    for (size_t i = 0; i < fieldNames.size(); ++i) {\n+      mapInitializer += \" { \\\"\" + fieldNames[i].first + \"\\\", \" +\n+                        \"reinterpret_cast<char*>(&\" + fieldNames[i].second +\n+                        \")\",\n+          mapInitializer += \" }\";\n+      if (i < fieldNames.size() - 1)\n+        mapInitializer += \", \";\n+    }\n+    mapInitializer += \" }\";\n+\n+    emitc::OpaqueType iteratorType = mlir::emitc::OpaqueType::get(\n+        context, \"std::map<std::string, char*>::const_iterator\");\n+\n+    emitc::ConstantOp bufferMap = rewriter.create<emitc::ConstantOp>(\n+        classOp.getLoc(), mapType,\n+        emitc::OpaqueAttr::get(context, mapInitializer));\n+\n+    mlir::Value nameArg = getBufferFunc.getArgument(0);\n+    emitc::CallOpaqueOp it = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), iteratorType, rewriter.getStringAttr(\"find\"),\n+        mlir::ValueRange{bufferMap.getResult(), nameArg});\n+    emitc::CallOpaqueOp endIt = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), iteratorType, rewriter.getStringAttr(\"end\"),\n+        bufferMap.getResult());\n+    emitc::CallOpaqueOp isEnd = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), rewriter.getI1Type(),\n+        \"operator==\", mlir::ValueRange{it.getResult(0), endIt.getResult(0)});\n+    emitc::ConstantOp nullPtr = rewriter.create<emitc::ConstantOp>(\n+        classOp.getLoc(), charType, emitc::OpaqueAttr::get(context, \"nullptr\"));\n+    emitc::CallOpaqueOp second = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), charType, \"second\", it.getResult(0));\n+\n+    emitc::ConditionalOp result = rewriter.create<emitc::ConditionalOp>(\n+        classOp.getLoc(), charType, isEnd.getResult(0), nullPtr.getResult(),\n+        second.getResult(0));",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2231583039",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150572,
        "pr_file": "mlir/lib/Dialect/EmitC/Transforms/AddReflectionMap.cpp",
        "discussion_id": "2231583039",
        "commented_code": "@@ -0,0 +1,180 @@\n+//===- AddReflectionMap.cpp - Add a reflection map to a class -------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"mlir/Dialect/EmitC/IR/EmitC.h\"\n+#include \"mlir/Dialect/EmitC/Transforms/Passes.h\"\n+#include \"mlir/Dialect/EmitC/Transforms/Transforms.h\"\n+#include \"mlir/IR/Attributes.h\"\n+#include \"mlir/IR/Builders.h\"\n+#include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"mlir/IR/PatternMatch.h\"\n+#include \"mlir/Transforms/WalkPatternRewriteDriver.h\"\n+\n+using namespace mlir;\n+using namespace emitc;\n+\n+namespace mlir {\n+namespace emitc {\n+#define GEN_PASS_DEF_ADDREFLECTIONMAPPASS\n+#include \"mlir/Dialect/EmitC/Transforms/Passes.h.inc\"\n+\n+namespace {\n+constexpr const char *kMapLibraryHeader = \"map\";\n+constexpr const char *kStringLibraryHeader = \"string\";\n+class AddReflectionMapPass\n+    : public impl::AddReflectionMapPassBase<AddReflectionMapPass> {\n+  using AddReflectionMapPassBase::AddReflectionMapPassBase;\n+  void runOnOperation() override {\n+    mlir::ModuleOp module = getOperation();\n+\n+    RewritePatternSet patterns(&getContext());\n+    populateAddReflectionMapPatterns(patterns, namedAttribute);\n+\n+    walkAndApplyPatterns(module, std::move(patterns));\n+    bool hasMap = false;\n+    bool hasString = false;\n+    for (auto &op : *module.getBody()) {\n+      emitc::IncludeOp includeOp = llvm::dyn_cast<mlir::emitc::IncludeOp>(op);\n+      if (!includeOp)\n+        continue;\n+      if (includeOp.getIsStandardInclude()) {\n+        if (includeOp.getInclude() == kMapLibraryHeader)\n+          hasMap = true;\n+        if (includeOp.getInclude() == kStringLibraryHeader)\n+          hasString = true;\n+      }\n+    }\n+\n+    if (hasMap && hasString)\n+      return;\n+\n+    mlir::OpBuilder builder(module.getBody(), module.getBody()->begin());\n+    if (!hasMap) {\n+      StringAttr includeAttr = builder.getStringAttr(kMapLibraryHeader);\n+      builder.create<mlir::emitc::IncludeOp>(\n+          module.getLoc(), includeAttr,\n+          /*is_standard_include=*/builder.getUnitAttr());\n+    }\n+    if (!hasString) {\n+      StringAttr includeAttr = builder.getStringAttr(kStringLibraryHeader);\n+      builder.create<emitc::IncludeOp>(\n+          module.getLoc(), includeAttr,\n+          /*is_standard_include=*/builder.getUnitAttr());\n+    }\n+  }\n+};\n+\n+} // namespace\n+} // namespace emitc\n+} // namespace mlir\n+\n+class AddReflectionMapClass : public OpRewritePattern<emitc::ClassOp> {\n+public:\n+  AddReflectionMapClass(MLIRContext *context, StringRef attrName)\n+      : OpRewritePattern<emitc::ClassOp>(context), attributeName(attrName) {}\n+\n+  LogicalResult matchAndRewrite(mlir::emitc::ClassOp classOp,\n+                                PatternRewriter &rewriter) const override {\n+    mlir::MLIRContext *context = rewriter.getContext();\n+    emitc::OpaqueType stringViewType =\n+        mlir::emitc::OpaqueType::get(rewriter.getContext(), \"std::string_view\");\n+    emitc::OpaqueType charType =\n+        mlir::emitc::OpaqueType::get(rewriter.getContext(), \"char\");\n+    emitc::OpaqueType mapType = mlir::emitc::OpaqueType::get(\n+        rewriter.getContext(), \"const std::map<std::string, char*>\");\n+\n+    FunctionType funcType =\n+        rewriter.getFunctionType({stringViewType}, {charType});\n+    emitc::FuncOp executeFunc =\n+        classOp.lookupSymbol<mlir::emitc::FuncOp>(\"execute\");\n+    if (executeFunc)\n+      rewriter.setInsertionPoint(executeFunc);\n+    else\n+      classOp.emitError() << \"ClassOp must contain a function named 'execute' \"\n+                             \"to add reflection map\";\n+\n+    emitc::FuncOp getBufferFunc = rewriter.create<mlir::emitc::FuncOp>(\n+        classOp.getLoc(), \"getBufferForName\", funcType);\n+\n+    Block *funcBody = getBufferFunc.addEntryBlock();\n+    rewriter.setInsertionPointToStart(funcBody);\n+\n+    // Collect all field names\n+    std::vector<std::pair<std::string, std::string>> fieldNames;\n+    classOp.walk([&](mlir::emitc::FieldOp fieldOp) {\n+      if (mlir::Attribute attrsAttr =\n+              fieldOp->getAttrDictionary().get(\"attrs\")) {\n+        if (DictionaryAttr innerDictAttr =\n+                dyn_cast<mlir::DictionaryAttr>(attrsAttr)) {\n+          ArrayAttr arrayAttr = dyn_cast<mlir::ArrayAttr>(\n+              innerDictAttr.getNamed(attributeName)->getValue());\n+          if (!arrayAttr.empty()) {\n+            StringAttr stringAttr = dyn_cast<mlir::StringAttr>(arrayAttr[0]);\n+            std::string indexPath = stringAttr.getValue().str();\n+            fieldNames.emplace_back(indexPath, fieldOp.getName().str());\n+          }\n+          if (arrayAttr.size() > 1) {\n+            fieldOp.emitError() << attributeName\n+                                << \" attribute must \"\n+                                   \"contain at most one value, but found \"\n+                                << arrayAttr.size() << \" values.\";\n+            return;\n+          }\n+        }\n+      }\n+    });\n+\n+    std::string mapInitializer = \"{ \";\n+    for (size_t i = 0; i < fieldNames.size(); ++i) {\n+      mapInitializer += \" { \\\"\" + fieldNames[i].first + \"\\\", \" +\n+                        \"reinterpret_cast<char*>(&\" + fieldNames[i].second +\n+                        \")\",\n+          mapInitializer += \" }\";\n+      if (i < fieldNames.size() - 1)\n+        mapInitializer += \", \";\n+    }\n+    mapInitializer += \" }\";\n+\n+    emitc::OpaqueType iteratorType = mlir::emitc::OpaqueType::get(\n+        context, \"std::map<std::string, char*>::const_iterator\");\n+\n+    emitc::ConstantOp bufferMap = rewriter.create<emitc::ConstantOp>(\n+        classOp.getLoc(), mapType,\n+        emitc::OpaqueAttr::get(context, mapInitializer));\n+\n+    mlir::Value nameArg = getBufferFunc.getArgument(0);\n+    emitc::CallOpaqueOp it = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), iteratorType, rewriter.getStringAttr(\"find\"),\n+        mlir::ValueRange{bufferMap.getResult(), nameArg});\n+    emitc::CallOpaqueOp endIt = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), iteratorType, rewriter.getStringAttr(\"end\"),\n+        bufferMap.getResult());\n+    emitc::CallOpaqueOp isEnd = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), rewriter.getI1Type(),\n+        \"operator==\", mlir::ValueRange{it.getResult(0), endIt.getResult(0)});\n+    emitc::ConstantOp nullPtr = rewriter.create<emitc::ConstantOp>(\n+        classOp.getLoc(), charType, emitc::OpaqueAttr::get(context, \"nullptr\"));\n+    emitc::CallOpaqueOp second = rewriter.create<emitc::CallOpaqueOp>(\n+        classOp.getLoc(), charType, \"second\", it.getResult(0));\n+\n+    emitc::ConditionalOp result = rewriter.create<emitc::ConditionalOp>(\n+        classOp.getLoc(), charType, isEnd.getResult(0), nullPtr.getResult(),\n+        second.getResult(0));",
        "comment_created_at": "2025-07-25T16:40:21+00:00",
        "comment_author": "ilovepi",
        "comment_body": "For blocks like this, where you're basically spelling out the C++ code, you may want to write that down in a comment, so its easy to see what operations you're doing.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205003401",
    "pr_number": 133672,
    "pr_file": "llvm/lib/Transforms/Scalar/LoopInterchange.cpp",
    "created_at": "2025-07-14T13:51:56+00:00",
    "commented_code": "static void printDepMatrix(CharMatrix &DepMatrix) {\n   for (auto &Row : DepMatrix) {\n-    for (auto D : Row)\n+    ArrayRef<char> RowRef(Row);\n+\n+    // Drop the last element because it is a flag indicating whether the row is\n+    // \"lexically forward\", which doesn't affect the legality check.",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2205003401",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 133672,
        "pr_file": "llvm/lib/Transforms/Scalar/LoopInterchange.cpp",
        "discussion_id": "2205003401",
        "commented_code": "@@ -119,7 +119,11 @@ static bool noDuplicateRules(ArrayRef<RuleTy> Rules) {\n \n static void printDepMatrix(CharMatrix &DepMatrix) {\n   for (auto &Row : DepMatrix) {\n-    for (auto D : Row)\n+    ArrayRef<char> RowRef(Row);\n+\n+    // Drop the last element because it is a flag indicating whether the row is\n+    // \"lexically forward\", which doesn't affect the legality check.",
        "comment_created_at": "2025-07-14T13:51:56+00:00",
        "comment_author": "Meinersbur",
        "comment_body": "Can you add a comment somehwere, e.g. the typedef of `DepMatrix` that the last element is forward/backward dependency?",
        "pr_file_module": null
      },
      {
        "comment_id": "2228038395",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 133672,
        "pr_file": "llvm/lib/Transforms/Scalar/LoopInterchange.cpp",
        "discussion_id": "2205003401",
        "commented_code": "@@ -119,7 +119,11 @@ static bool noDuplicateRules(ArrayRef<RuleTy> Rules) {\n \n static void printDepMatrix(CharMatrix &DepMatrix) {\n   for (auto &Row : DepMatrix) {\n-    for (auto D : Row)\n+    ArrayRef<char> RowRef(Row);\n+\n+    // Drop the last element because it is a flag indicating whether the row is\n+    // \"lexically forward\", which doesn't affect the legality check.",
        "comment_created_at": "2025-07-24T09:52:11+00:00",
        "comment_author": "kasuga-fj",
        "comment_body": "Added comments above the typedef of `DepMatrix`.",
        "pr_file_module": null
      }
    ]
  }
]