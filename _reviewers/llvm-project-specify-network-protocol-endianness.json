[
  {
    "discussion_id": "2229662609",
    "pr_number": 150143,
    "pr_file": "lldb/docs/resources/lldbgdbremote.md",
    "created_at": "2025-07-24T21:57:16+00:00",
    "commented_code": "stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs.",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2229662609",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2229662609",
        "commented_code": "@@ -1998,6 +1998,18 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs.",
        "comment_created_at": "2025-07-24T21:57:16+00:00",
        "comment_author": "jasonmolenda",
        "comment_body": "Is 32-bit a possibility?  I'd say native endian bytes - I believe the bytes in this example are showing little endian byte ordering.  Or this could return a comma separated list of big-endian ordinal values instead of an asciihex byte stream, like `4000000000009c01,400000000000e501,400000000000fe01` if i swapped the bytes correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2229706689",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2229662609",
        "commented_code": "@@ -1998,6 +1998,18 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs.",
        "comment_created_at": "2025-07-24T22:24:51+00:00",
        "comment_author": "JDevlieghere",
        "comment_body": "No, we (ab)use the 64-bit address space to encode the address space in the top bits. Given that we already have two runtimes that support these extensions, I'm hesitant to change them. The data in the runtime is always [little endian](https://github.com/llvm/llvm-project/pull/150143#discussion_r2228006194) per the wasm spec. I've made little endian mandatory to avoid confusion. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2229662609",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2229662609",
        "commented_code": "@@ -1998,6 +1998,18 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs.",
        "comment_created_at": "2025-07-24T21:57:16+00:00",
        "comment_author": "jasonmolenda",
        "comment_body": "Is 32-bit a possibility?  I'd say native endian bytes - I believe the bytes in this example are showing little endian byte ordering.  Or this could return a comma separated list of big-endian ordinal values instead of an asciihex byte stream, like `4000000000009c01,400000000000e501,400000000000fe01` if i swapped the bytes correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2229706689",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2229662609",
        "commented_code": "@@ -1998,6 +1998,18 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs.",
        "comment_created_at": "2025-07-24T22:24:51+00:00",
        "comment_author": "JDevlieghere",
        "comment_body": "No, we (ab)use the 64-bit address space to encode the address space in the top bits. Given that we already have two runtimes that support these extensions, I'm hesitant to change them. The data in the runtime is always [little endian](https://github.com/llvm/llvm-project/pull/150143#discussion_r2228006194) per the wasm spec. I've made little endian mandatory to avoid confusion. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2235362188",
    "pr_number": 150143,
    "pr_file": "lldb/docs/resources/lldbgdbremote.md",
    "created_at": "2025-07-28T08:43:01+00:00",
    "commented_code": "stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs. To match the Wasm specification, the\n+addresses are encoded in little endian byte order.",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2235362188",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2235362188",
        "commented_code": "@@ -1998,6 +1998,19 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs. To match the Wasm specification, the\n+addresses are encoded in little endian byte order.",
        "comment_created_at": "2025-07-28T08:43:01+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "Add \"even if the endian of the Wasm runtime's host is not little endian.\".",
        "pr_file_module": null
      },
      {
        "comment_id": "2235362188",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150143,
        "pr_file": "lldb/docs/resources/lldbgdbremote.md",
        "discussion_id": "2235362188",
        "commented_code": "@@ -1998,6 +1998,19 @@ threads (live system debug) / cores (JTAG) in your program have\n stopped and allows LLDB to display and control your program\n correctly.\n \n+## qWasmCallStack\n+\n+Get the Wasm callback for the given thread id. This returns a hex-encoding list\n+of 64-bit addresses for the frame PCs. To match the Wasm specification, the\n+addresses are encoded in little endian byte order.",
        "comment_created_at": "2025-07-28T08:43:01+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "Add \"even if the endian of the Wasm runtime's host is not little endian.\".",
        "pr_file_module": null
      }
    ]
  }
]