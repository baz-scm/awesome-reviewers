[
  {
    "discussion_id": "1951289096",
    "pr_number": 126324,
    "pr_file": "clang/docs/LanguageExtensions.rst",
    "created_at": "2025-02-11T17:31:39+00:00",
    "commented_code": "the constant evaluation of the corresponding builtin (for example,\n ``std::fmax`` calls ``__builtin_fmax``) is supported in Clang.\n \n+``__has_target_builtin``\n+------------------------\n+\n+This function-like macro takes a single identifier argument that is the name of\n+a builtin function, a builtin pseudo-function (taking one or more type\n+arguments), or a builtin template.\n+It evaluates to 1 if the builtin is supported on the current target or 0 if not.\n+\n+``__has_builtin`` and ``__has_target_builtin`` behave identically for normal C++ compilations.\n+\n+For heterogeneous compilations that see source code intended for more than one target:\n+\n+``__has_builtin`` returns true if the builtin is known to the compiler\n+(i.e. it's available via one of the targets), but makes no promises whether it's available on the current target.\n+The compiler can parse it, but not necessarily generate code for it.\n+\n+``__has_target_builtin`` returns true if the builtin can actually be generated for the current target.\n+\n+It can be used like this:\n+\n+.. code-block:: c++\n+\n+  #ifdef __CUDA__\n+  #if __has_target_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif\n+  #else // !CUDA\n+  #if __has_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "1951289096",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 126324,
        "pr_file": "clang/docs/LanguageExtensions.rst",
        "discussion_id": "1951289096",
        "commented_code": "@@ -96,6 +100,47 @@ the ``<cmath>`` header file to conditionally make a function constexpr whenever\n the constant evaluation of the corresponding builtin (for example,\n ``std::fmax`` calls ``__builtin_fmax``) is supported in Clang.\n \n+``__has_target_builtin``\n+------------------------\n+\n+This function-like macro takes a single identifier argument that is the name of\n+a builtin function, a builtin pseudo-function (taking one or more type\n+arguments), or a builtin template.\n+It evaluates to 1 if the builtin is supported on the current target or 0 if not.\n+\n+``__has_builtin`` and ``__has_target_builtin`` behave identically for normal C++ compilations.\n+\n+For heterogeneous compilations that see source code intended for more than one target:\n+\n+``__has_builtin`` returns true if the builtin is known to the compiler\n+(i.e. it's available via one of the targets), but makes no promises whether it's available on the current target.\n+The compiler can parse it, but not necessarily generate code for it.\n+\n+``__has_target_builtin`` returns true if the builtin can actually be generated for the current target.\n+\n+It can be used like this:\n+\n+.. code-block:: c++\n+\n+  #ifdef __CUDA__\n+  #if __has_target_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif\n+  #else // !CUDA\n+  #if __has_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif",
        "comment_created_at": "2025-02-11T17:31:39+00:00",
        "comment_author": "jhuber6",
        "comment_body": "```suggestion\r\n  #else // !CUDA\r\n  #if __has_builtin(__builtin_trap)\r\n    __builtin_trap();\r\n  #else\r\n    abort();\r\n  #endif\r\n```\r\nIs this still necessary now that we allow it on all targets?",
        "pr_file_module": null
      },
      {
        "comment_id": "1951298195",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 126324,
        "pr_file": "clang/docs/LanguageExtensions.rst",
        "discussion_id": "1951289096",
        "commented_code": "@@ -96,6 +100,47 @@ the ``<cmath>`` header file to conditionally make a function constexpr whenever\n the constant evaluation of the corresponding builtin (for example,\n ``std::fmax`` calls ``__builtin_fmax``) is supported in Clang.\n \n+``__has_target_builtin``\n+------------------------\n+\n+This function-like macro takes a single identifier argument that is the name of\n+a builtin function, a builtin pseudo-function (taking one or more type\n+arguments), or a builtin template.\n+It evaluates to 1 if the builtin is supported on the current target or 0 if not.\n+\n+``__has_builtin`` and ``__has_target_builtin`` behave identically for normal C++ compilations.\n+\n+For heterogeneous compilations that see source code intended for more than one target:\n+\n+``__has_builtin`` returns true if the builtin is known to the compiler\n+(i.e. it's available via one of the targets), but makes no promises whether it's available on the current target.\n+The compiler can parse it, but not necessarily generate code for it.\n+\n+``__has_target_builtin`` returns true if the builtin can actually be generated for the current target.\n+\n+It can be used like this:\n+\n+.. code-block:: c++\n+\n+  #ifdef __CUDA__\n+  #if __has_target_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif\n+  #else // !CUDA\n+  #if __has_builtin(__builtin_trap)\n+    __builtin_trap();\n+  #else\n+    abort();\n+  #endif",
        "comment_created_at": "2025-02-11T17:36:49+00:00",
        "comment_author": "sarnex",
        "comment_body": "thanks, its not necessary, but i was thinking we leave it to suggest users to only use this for offloading, even if it does work for normal compilation modes. if you think the explanation of the differences between `has_builtin` and `has_target_builtin` is enough for users, ill remove the offload/nooffload check from the example",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169385038",
    "pr_number": 145899,
    "pr_file": "mlir/include/mlir/Dialect/LLVMIR/LLVMAttrDefs.td",
    "created_at": "2025-06-26T15:50:29+00:00",
    "commented_code": "include \"mlir/Dialect/LLVMIR/LLVMInterfaces.td\"\n include \"mlir/IR/AttrTypeBase.td\"\n include \"mlir/IR/CommonAttrConstraints.td\"\n+include \"mlir/Interfaces/DataLayoutInterfaces.td\"\n \n-// All of the attributes will extend this class.\n-class LLVM_Attr<string name, string attrMnemonic,\n-                list<Trait> traits = [],\n-                string baseCppClass = \"::mlir::Attribute\">\n-    : AttrDef<LLVM_Dialect, name, traits, baseCppClass> {\n-  let mnemonic = attrMnemonic;\n+//===----------------------------------------------------------------------===//\n+// LLVM_TargetAttr\n+//===----------------------------------------------------------------------===//\n+\n+def LLVM_TargetAttr : LLVM_Attr<\"Target\", \"target\", [LLVM_TargetAttrInterface]> {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2169385038",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 145899,
        "pr_file": "mlir/include/mlir/Dialect/LLVMIR/LLVMAttrDefs.td",
        "discussion_id": "2169385038",
        "commented_code": "@@ -13,13 +13,118 @@ include \"mlir/Dialect/LLVMIR/LLVMDialect.td\"\n include \"mlir/Dialect/LLVMIR/LLVMInterfaces.td\"\n include \"mlir/IR/AttrTypeBase.td\"\n include \"mlir/IR/CommonAttrConstraints.td\"\n+include \"mlir/Interfaces/DataLayoutInterfaces.td\"\n \n-// All of the attributes will extend this class.\n-class LLVM_Attr<string name, string attrMnemonic,\n-                list<Trait> traits = [],\n-                string baseCppClass = \"::mlir::Attribute\">\n-    : AttrDef<LLVM_Dialect, name, traits, baseCppClass> {\n-  let mnemonic = attrMnemonic;\n+//===----------------------------------------------------------------------===//\n+// LLVM_TargetAttr\n+//===----------------------------------------------------------------------===//\n+\n+def LLVM_TargetAttr : LLVM_Attr<\"Target\", \"target\", [LLVM_TargetAttrInterface]> {",
        "comment_created_at": "2025-06-26T15:50:29+00:00",
        "comment_author": "rolfmorel",
        "comment_body": "@rengolin, I am not sure what we want to do for verification here. Do we want to insist on the specified `triple`, `cpu`, and `target_features` being valid together. And do we verify that through constructing the relevant `TargetMachine`?\r\n\r\nHow would that work for dealing with IR which is annotated with a `#llvm.target` specifying a target that your current `llvm-project` isn't built with. Is it right that verification fails in that case? (Maybe it is, but it feels wrong as now verification succeeding or failing becomes a function of whether you built MLIR with the right flags.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2169774178",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 145899,
        "pr_file": "mlir/include/mlir/Dialect/LLVMIR/LLVMAttrDefs.td",
        "discussion_id": "2169385038",
        "commented_code": "@@ -13,13 +13,118 @@ include \"mlir/Dialect/LLVMIR/LLVMDialect.td\"\n include \"mlir/Dialect/LLVMIR/LLVMInterfaces.td\"\n include \"mlir/IR/AttrTypeBase.td\"\n include \"mlir/IR/CommonAttrConstraints.td\"\n+include \"mlir/Interfaces/DataLayoutInterfaces.td\"\n \n-// All of the attributes will extend this class.\n-class LLVM_Attr<string name, string attrMnemonic,\n-                list<Trait> traits = [],\n-                string baseCppClass = \"::mlir::Attribute\">\n-    : AttrDef<LLVM_Dialect, name, traits, baseCppClass> {\n-  let mnemonic = attrMnemonic;\n+//===----------------------------------------------------------------------===//\n+// LLVM_TargetAttr\n+//===----------------------------------------------------------------------===//\n+\n+def LLVM_TargetAttr : LLVM_Attr<\"Target\", \"target\", [LLVM_TargetAttrInterface]> {",
        "comment_created_at": "2025-06-26T19:06:22+00:00",
        "comment_author": "rengolin",
        "comment_body": "One problem we faced on our side earlier was that it's not that easy to know you're constructing an invalid `TargetMachine` ([link](https://discourse.llvm.org/t/generating-riscv-code-from-mlir/85863)). But validating all possible combinations is just not viable. For downstream targets, you'd have to overload some verification to match their alternatives.\r\n\r\nOther tools don't verify much either (other than completely crash if the strings are invalid), so I guess we can start with that. The discussion about which combinations are valid ([link](https://discourse.llvm.org/t/move-remove-vcix-dialect/86920/46)) are generally higher in the pipeline (front-end). At the IR level, we can only treat them as \"gospel\" and crash if we really can't build a `TargetMachine`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2201181718",
    "pr_number": 140282,
    "pr_file": "clang/include/clang/Basic/Attr.td",
    "created_at": "2025-07-11T16:20:56+00:00",
    "commented_code": "}];\n }\n \n+def SYCLExternal : InheritableAttr {\n+  let Spellings = [Clang<\"sycl_external\">];\n+  let Subjects = SubjectList<[Function], ErrorDiag>;\n+  let LangOpts = [SYCLDevice];",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2201181718",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 140282,
        "pr_file": "clang/include/clang/Basic/Attr.td",
        "discussion_id": "2201181718",
        "commented_code": "@@ -1641,6 +1641,13 @@ def DeviceKernel : DeclOrTypeAttr {\n }];\n }\n \n+def SYCLExternal : InheritableAttr {\n+  let Spellings = [Clang<\"sycl_external\">];\n+  let Subjects = SubjectList<[Function], ErrorDiag>;\n+  let LangOpts = [SYCLDevice];",
        "comment_created_at": "2025-07-11T16:20:56+00:00",
        "comment_author": "tahonermann",
        "comment_body": "In restrospect, I think we should allow the `sycl_external` attribute to be present for SYCL host compilation. It won't have an affect on what is emitted on the host side, but will allow for semantic diagnostics to be issued. It might be useful for SYCL implementations like AdaptiveCpp that don't (necessarily) perform a separate device compilation.\r\n```suggestion\r\n  let LangOpts = [SYCLHost, SYCLDevice];\r\n```",
        "pr_file_module": null
      }
    ]
  }
]