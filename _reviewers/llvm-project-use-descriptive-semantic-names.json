[
  {
    "discussion_id": "2211576248",
    "pr_number": 148013,
    "pr_file": "llvm/tools/llvm-profgen/ProfiledBinary.h",
    "created_at": "2025-07-16T20:47:46+00:00",
    "commented_code": "// String table owning function name strings created from the symbolizer.\n   std::unordered_set<std::string> NameStrings;\n \n+  // MMap events for PT_LOAD segments without 'x' memory protection flag.\n+  SmallVector<MMapEvent> MMapNonTextEvents;\n+\n+  // Records the file offset, file size and virtual address of program headers.\n+  struct PhdrInfo {\n+    uint64_t FileOffset;\n+    uint64_t FileSz;\n+    uint64_t vAddr;",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2211576248",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148013,
        "pr_file": "llvm/tools/llvm-profgen/ProfiledBinary.h",
        "discussion_id": "2211576248",
        "commented_code": "@@ -276,6 +286,19 @@ class ProfiledBinary {\n   // String table owning function name strings created from the symbolizer.\n   std::unordered_set<std::string> NameStrings;\n \n+  // MMap events for PT_LOAD segments without 'x' memory protection flag.\n+  SmallVector<MMapEvent> MMapNonTextEvents;\n+\n+  // Records the file offset, file size and virtual address of program headers.\n+  struct PhdrInfo {\n+    uint64_t FileOffset;\n+    uint64_t FileSz;\n+    uint64_t vAddr;",
        "comment_created_at": "2025-07-16T20:47:46+00:00",
        "comment_author": "snehasish",
        "comment_body": "nit: Variable name should start with caps.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216604886",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 148013,
        "pr_file": "llvm/tools/llvm-profgen/ProfiledBinary.h",
        "discussion_id": "2211576248",
        "commented_code": "@@ -276,6 +286,19 @@ class ProfiledBinary {\n   // String table owning function name strings created from the symbolizer.\n   std::unordered_set<std::string> NameStrings;\n \n+  // MMap events for PT_LOAD segments without 'x' memory protection flag.\n+  SmallVector<MMapEvent> MMapNonTextEvents;\n+\n+  // Records the file offset, file size and virtual address of program headers.\n+  struct PhdrInfo {\n+    uint64_t FileOffset;\n+    uint64_t FileSz;\n+    uint64_t vAddr;",
        "comment_created_at": "2025-07-18T17:54:02+00:00",
        "comment_author": "mingmingl-llvm",
        "comment_body": "got it. My original thinking was that the `VA` prefix in `VAddr` felt a bit uncommon and harder to quickly parse. Now I renamed the field to `VirtualAddr`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230004712",
    "pr_number": 149409,
    "pr_file": "llvm/lib/Target/RISCV/RISCVFeatures.td",
    "created_at": "2025-07-25T02:32:49+00:00",
    "commented_code": "def TunePostRAScheduler : SubtargetFeature<\"use-postra-scheduler\",\n     \"UsePostRAScheduler\", \"true\", \"Schedule again after register allocation\">;\n \n+def TuneDisableMISchedLoadClustering : SubtargetFeature<\"disable-misched-load-clustering\",\n+    \"NoMISchedLoadClustering\", \"true\", \"Disable load clustering in the machine scheduler\">;",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2230004712",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149409,
        "pr_file": "llvm/lib/Target/RISCV/RISCVFeatures.td",
        "discussion_id": "2230004712",
        "commented_code": "@@ -1700,6 +1700,18 @@ def TuneNLogNVRGather\n def TunePostRAScheduler : SubtargetFeature<\"use-postra-scheduler\",\n     \"UsePostRAScheduler\", \"true\", \"Schedule again after register allocation\">;\n \n+def TuneDisableMISchedLoadClustering : SubtargetFeature<\"disable-misched-load-clustering\",\n+    \"NoMISchedLoadClustering\", \"true\", \"Disable load clustering in the machine scheduler\">;",
        "comment_created_at": "2025-07-25T02:32:49+00:00",
        "comment_author": "wangpc-pp",
        "comment_body": "```suggestion\n    \"MISchedLoadClustering\", \"false\", \"Disable load clustering in the machine scheduler\">;\n```\n\nNegate the enum and the value. See also `TuneNoDefaultUnroll` and `TuneNoSinkSplatOperands`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230825050",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149409,
        "pr_file": "llvm/lib/Target/RISCV/RISCVFeatures.td",
        "discussion_id": "2230004712",
        "commented_code": "@@ -1700,6 +1700,18 @@ def TuneNLogNVRGather\n def TunePostRAScheduler : SubtargetFeature<\"use-postra-scheduler\",\n     \"UsePostRAScheduler\", \"true\", \"Schedule again after register allocation\">;\n \n+def TuneDisableMISchedLoadClustering : SubtargetFeature<\"disable-misched-load-clustering\",\n+    \"NoMISchedLoadClustering\", \"true\", \"Disable load clustering in the machine scheduler\">;",
        "comment_created_at": "2025-07-25T11:12:59+00:00",
        "comment_author": "wangpc-pp",
        "comment_body": "You can add `Enable` before the enum, like `EnableMISchedLoadClustering`. So that the auto-generated methods will be like `enableXXX()`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230858477",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 149409,
        "pr_file": "llvm/lib/Target/RISCV/RISCVFeatures.td",
        "discussion_id": "2230004712",
        "commented_code": "@@ -1700,6 +1700,18 @@ def TuneNLogNVRGather\n def TunePostRAScheduler : SubtargetFeature<\"use-postra-scheduler\",\n     \"UsePostRAScheduler\", \"true\", \"Schedule again after register allocation\">;\n \n+def TuneDisableMISchedLoadClustering : SubtargetFeature<\"disable-misched-load-clustering\",\n+    \"NoMISchedLoadClustering\", \"true\", \"Disable load clustering in the machine scheduler\">;",
        "comment_created_at": "2025-07-25T11:30:28+00:00",
        "comment_author": "danielhb",
        "comment_body": "That explains why I didn't find an enableDefaultUnroll() method ... ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218594834",
    "pr_number": 147198,
    "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
    "created_at": "2025-07-21T09:08:36+00:00",
    "commented_code": "bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2218594834",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
        "discussion_id": "2218594834",
        "commented_code": "@@ -74,8 +75,10 @@ class NativeRegisterContextLinux_arm : public NativeRegisterContextLinux {\n \n   bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
        "comment_created_at": "2025-07-21T09:08:36+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "I don't see the need for `static const DREGType eDREGTypeBREAK` and I think it would be clearer to fully qualify DREGType and DREG rather than `using` them.",
        "pr_file_module": null
      },
      {
        "comment_id": "2233074689",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
        "discussion_id": "2218594834",
        "commented_code": "@@ -74,8 +75,10 @@ class NativeRegisterContextLinux_arm : public NativeRegisterContextLinux {\n \n   bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
        "comment_created_at": "2025-07-26T16:18:18+00:00",
        "comment_author": "b10902118",
        "comment_body": "I did that just for modifying less files, not sure whether this should be a concern.\r\n\r\nI am considering porting arm to use NativeRegisterContextDBReg, after this it will be not fully qualified again.",
        "pr_file_module": null
      },
      {
        "comment_id": "2235277020",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
        "discussion_id": "2218594834",
        "commented_code": "@@ -74,8 +75,10 @@ class NativeRegisterContextLinux_arm : public NativeRegisterContextLinux {\n \n   bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
        "comment_created_at": "2025-07-28T08:21:11+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "> I am considering porting arm to use NativeRegisterContextDBReg, after this it will be not fully qualified again.\r\n\r\nIf it's the class that LoongArch and AArch64 use, I might have a tree where I did this. I never found the time to test it with Arm/Thumb options though.\r\n\r\nPlease fully qualify the names for now and I'll look for those changes of mine.",
        "pr_file_module": null
      },
      {
        "comment_id": "2236355304",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
        "discussion_id": "2218594834",
        "commented_code": "@@ -74,8 +75,10 @@ class NativeRegisterContextLinux_arm : public NativeRegisterContextLinux {\n \n   bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
        "comment_created_at": "2025-07-28T13:00:24+00:00",
        "comment_author": "DavidSpickett",
        "comment_body": "I do have those changes still.\r\n\r\nI suggest that we go ahead with your change here, as I don't want to derail you from the problem you came here to fix.\r\n\r\nOnce that's in, I will rebase my changes on top. I needed to read them through carefully anyway, so I can do both at the same time. I want to be sure I don't drop any Arm/Thumb handling details along the way.",
        "pr_file_module": null
      },
      {
        "comment_id": "2236628562",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 147198,
        "pr_file": "lldb/source/Plugins/Process/Linux/NativeRegisterContextLinux_arm.h",
        "discussion_id": "2218594834",
        "commented_code": "@@ -74,8 +75,10 @@ class NativeRegisterContextLinux_arm : public NativeRegisterContextLinux {\n \n   bool WatchpointIsEnabled(uint32_t wp_index);\n \n-  // Debug register type select\n-  enum DREGType { eDREGTypeWATCH = 0, eDREGTypeBREAK };\n+  using DREGType = NativeRegisterContextDBReg::DREGType;\n+  static const DREGType eDREGTypeBREAK = DREGType::eDREGTypeBREAK;\n+  static const DREGType eDREGTypeWATCH = DREGType::eDREGTypeWATCH;\n+  using DREG = NativeRegisterContextDBReg::DREG;",
        "comment_created_at": "2025-07-28T14:03:51+00:00",
        "comment_author": "b10902118",
        "comment_body": "Got it. I know thumb breakpoint address requires an additional 1 offset, at least in gdb, kind of annoying.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2237044646",
    "pr_number": 150823,
    "pr_file": "clang/include/clang/AST/DeclTemplate.h",
    "created_at": "2025-07-28T15:50:54+00:00",
    "commented_code": "return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n   }\n \n+  TemplateNameKind kind() const {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2237044646",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150823,
        "pr_file": "clang/include/clang/AST/DeclTemplate.h",
        "discussion_id": "2237044646",
        "commented_code": "@@ -1746,6 +1754,16 @@ class TemplateTemplateParmDecl final\n     return SourceRange(getTemplateParameters()->getTemplateLoc(), End);\n   }\n \n+  TemplateNameKind kind() const {",
        "comment_created_at": "2025-07-28T15:50:54+00:00",
        "comment_author": "erichkeane",
        "comment_body": "Mild preference for `templateKind` or something like that (perhaps something more accurate? `nameKind` seems wrong toot hough)?  We use `kind` to mean sooooo many different things, it makes reading later not particularly descriptive.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234966846",
    "pr_number": 150887,
    "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
    "created_at": "2025-07-28T07:01:13+00:00",
    "commented_code": "def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
    "repo_full_name": "llvm/llvm-project",
    "discussion_comments": [
      {
        "comment_id": "2234966846",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150887,
        "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
        "discussion_id": "2234966846",
        "commented_code": "@@ -1621,6 +1621,13 @@ let OtherPredicates = [HasImageInsts] in {\n   def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
        "comment_created_at": "2025-07-28T07:01:13+00:00",
        "comment_author": "arsenm",
        "comment_body": "Synthetic variants of real instructions should use a lowercase suffix ",
        "pr_file_module": null
      },
      {
        "comment_id": "2235154357",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150887,
        "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
        "discussion_id": "2234966846",
        "commented_code": "@@ -1621,6 +1621,13 @@ let OtherPredicates = [HasImageInsts] in {\n   def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
        "comment_created_at": "2025-07-28T07:52:03+00:00",
        "comment_author": "ssahasra",
        "comment_body": "Yeah, I have a great deal of uncertainty on what this pseudo should be called. It seems the \"_soft\" suffix signifies a definite wait count argument, which the SIInsertWaitcnts pass is allowed to relax. Are you suggesting \"S_WAITCNT_lds_direct\"? Because \"_direct\" as a suffix doesn't contain enough information, and there is no \"S_WAITCNT_LDS\".",
        "pr_file_module": null
      },
      {
        "comment_id": "2235593662",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150887,
        "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
        "discussion_id": "2234966846",
        "commented_code": "@@ -1621,6 +1621,13 @@ let OtherPredicates = [HasImageInsts] in {\n   def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
        "comment_created_at": "2025-07-28T09:38:44+00:00",
        "comment_author": "Pierre-vh",
        "comment_body": "`WAIT_LDS_DIRECT_PSEUDO` (following a similar pattern to `ATOMIC_FENCE` and other SOP pseudos?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2235690087",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150887,
        "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
        "discussion_id": "2234966846",
        "commented_code": "@@ -1621,6 +1621,13 @@ let OtherPredicates = [HasImageInsts] in {\n   def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
        "comment_created_at": "2025-07-28T10:06:38+00:00",
        "comment_author": "arsenm",
        "comment_body": "`S_WAITCNT_something_lowercase`",
        "pr_file_module": null
      },
      {
        "comment_id": "2235895132",
        "repo_full_name": "llvm/llvm-project",
        "pr_number": 150887,
        "pr_file": "llvm/lib/Target/AMDGPU/SOPInstructions.td",
        "discussion_id": "2234966846",
        "commented_code": "@@ -1621,6 +1621,13 @@ let OtherPredicates = [HasImageInsts] in {\n   def S_WAIT_KMCNT_soft : SOPP_Pseudo <\"s_soft_wait_kmcnt\", (ins s16imm:$simm16), \"$simm16\">;\n }\n \n+// Represents the point at which a wave must wait for all outstanding direct loads to LDS.\n+// Typically inserted by the memory legalizer and consumed by SIInsertWaitcnts.\n+\n+def S_WAITCNT_LDS_DIRECT : SPseudoInstSI<(outs), (ins)> {",
        "comment_created_at": "2025-07-28T11:04:24+00:00",
        "comment_author": "ssahasra",
        "comment_body": "I am now using `S_WAITCNT_lds_direct` .... it represents a wait count, for direct loads to LDS, but it's not real. Having it called `S_WAITCNT_something` like everything else near it helps reinforce that its relevance is to the SIInsertWaitcnts pass, where it is included by the `isWaitInstr()` predicate.",
        "pr_file_module": null
      }
    ]
  }
]