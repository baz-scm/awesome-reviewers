[
  {
    "discussion_id": "1965162590",
    "pr_number": 6386,
    "pr_file": "src/config/auth.ts",
    "created_at": "2025-02-21T09:33:34+00:00",
    "commented_code": "// Casdoor\n       CASDOOR_WEBHOOK_SECRET: process.env.CASDOOR_WEBHOOK_SECRET,\n+\n+      // feishu\n+      FEISHU_APP_ID: process.env.FEISHU_APP_ID,",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1965162590",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 6386,
        "pr_file": "src/config/auth.ts",
        "discussion_id": "1965162590",
        "commented_code": "@@ -269,6 +277,10 @@ export const getAuthConfig = () => {\n \n       // Casdoor\n       CASDOOR_WEBHOOK_SECRET: process.env.CASDOOR_WEBHOOK_SECRET,\n+\n+      // feishu\n+      FEISHU_APP_ID: process.env.FEISHU_APP_ID,",
        "comment_created_at": "2025-02-21T09:33:34+00:00",
        "comment_author": "cy948",
        "comment_body": "clientId \u548c secret \u7684\u73af\u5883\u53d8\u91cf\u547d\u540d\u5bf9\u9f50\u4e00\u4e0b  environment variable inference \u3002 https://authjs.dev/getting-started/deployment",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1904845711",
    "pr_number": 5177,
    "pr_file": "src/const/settings/knowledge.ts",
    "created_at": "2025-01-07T02:58:39+00:00",
    "commented_code": "+import { FilesConfig, FilesConfigItem } from '@/types/user/settings/filesConfig';\n+\n+import {\n+  DEFAULT_EMBEDDING_MODEL,\n+  DEFAULT_PROVIDER,\n+  DEFAULT_RERANK_MODEL,\n+  DEFAULT_RERANK_PROVIDER,\n+  DEFAULT_RERANK_QUERY_MODE,\n+} from './llm';\n+\n+export const DEFAULT_FILE_EMBEDDING_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_EMBEDDING_MODEL,\n+  provider: DEFAULT_PROVIDER,\n+};\n+\n+export const DEFAULT_FILE_RERANK_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_RERANK_MODEL,\n+  provider: DEFAULT_RERANK_PROVIDER,\n+};\n+\n+export const DEFAULT_FILES_CONFIG: FilesConfig = {\n+  embedding_model: DEFAULT_FILE_EMBEDDING_MODEL_ITEM,",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1904845711",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 5177,
        "pr_file": "src/const/settings/knowledge.ts",
        "discussion_id": "1904845711",
        "commented_code": "@@ -0,0 +1,25 @@\n+import { FilesConfig, FilesConfigItem } from '@/types/user/settings/filesConfig';\n+\n+import {\n+  DEFAULT_EMBEDDING_MODEL,\n+  DEFAULT_PROVIDER,\n+  DEFAULT_RERANK_MODEL,\n+  DEFAULT_RERANK_PROVIDER,\n+  DEFAULT_RERANK_QUERY_MODE,\n+} from './llm';\n+\n+export const DEFAULT_FILE_EMBEDDING_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_EMBEDDING_MODEL,\n+  provider: DEFAULT_PROVIDER,\n+};\n+\n+export const DEFAULT_FILE_RERANK_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_RERANK_MODEL,\n+  provider: DEFAULT_RERANK_PROVIDER,\n+};\n+\n+export const DEFAULT_FILES_CONFIG: FilesConfig = {\n+  embedding_model: DEFAULT_FILE_EMBEDDING_MODEL_ITEM,",
        "comment_created_at": "2025-01-07T02:58:39+00:00",
        "comment_author": "arvinxx",
        "comment_body": "\u8fd9\u91cc\u7684\u5bf9\u8c61\u90fd\u4f7f\u7528\u5c0f\u9a7c\u5cf0\uff0cembeddingModel,queryModel,rerankerModel",
        "pr_file_module": null
      },
      {
        "comment_id": "1904863177",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 5177,
        "pr_file": "src/const/settings/knowledge.ts",
        "discussion_id": "1904845711",
        "commented_code": "@@ -0,0 +1,25 @@\n+import { FilesConfig, FilesConfigItem } from '@/types/user/settings/filesConfig';\n+\n+import {\n+  DEFAULT_EMBEDDING_MODEL,\n+  DEFAULT_PROVIDER,\n+  DEFAULT_RERANK_MODEL,\n+  DEFAULT_RERANK_PROVIDER,\n+  DEFAULT_RERANK_QUERY_MODE,\n+} from './llm';\n+\n+export const DEFAULT_FILE_EMBEDDING_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_EMBEDDING_MODEL,\n+  provider: DEFAULT_PROVIDER,\n+};\n+\n+export const DEFAULT_FILE_RERANK_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_RERANK_MODEL,\n+  provider: DEFAULT_RERANK_PROVIDER,\n+};\n+\n+export const DEFAULT_FILES_CONFIG: FilesConfig = {\n+  embedding_model: DEFAULT_FILE_EMBEDDING_MODEL_ITEM,",
        "comment_created_at": "2025-01-07T03:25:51+00:00",
        "comment_author": "cookieY",
        "comment_body": "\u5728\u8fd9\u91cc\u6211\u662f\u8ba9\u914d\u7f6e\u6587\u4ef6\u540c\u6b65\u4e5f\u4f7f\u7528\u5c0f\u9a7c\u5cf0 \u8fd8\u662f\u5c06\u914d\u7f6e\u6587\u4ef6\u4e2d\u4e0b\u5212\u7ebf\u8f6c\u5199\u6210\u5c0f\u9a7c\u5cf0\uff1f",
        "pr_file_module": null
      },
      {
        "comment_id": "1904865476",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 5177,
        "pr_file": "src/const/settings/knowledge.ts",
        "discussion_id": "1904845711",
        "commented_code": "@@ -0,0 +1,25 @@\n+import { FilesConfig, FilesConfigItem } from '@/types/user/settings/filesConfig';\n+\n+import {\n+  DEFAULT_EMBEDDING_MODEL,\n+  DEFAULT_PROVIDER,\n+  DEFAULT_RERANK_MODEL,\n+  DEFAULT_RERANK_PROVIDER,\n+  DEFAULT_RERANK_QUERY_MODE,\n+} from './llm';\n+\n+export const DEFAULT_FILE_EMBEDDING_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_EMBEDDING_MODEL,\n+  provider: DEFAULT_PROVIDER,\n+};\n+\n+export const DEFAULT_FILE_RERANK_MODEL_ITEM: FilesConfigItem = {\n+  model: DEFAULT_RERANK_MODEL,\n+  provider: DEFAULT_RERANK_PROVIDER,\n+};\n+\n+export const DEFAULT_FILES_CONFIG: FilesConfig = {\n+  embedding_model: DEFAULT_FILE_EMBEDDING_MODEL_ITEM,",
        "comment_created_at": "2025-01-07T03:31:03+00:00",
        "comment_author": "arvinxx",
        "comment_body": "\u914d\u7f6e\u6587\u4ef6\u7528\u86c7\u5f62\uff0c\u4ee3\u7801\u91cc\u7684\u53d8\u91cf\u7528\u5c0f\u9a7c\u5cf0\uff0c\u8fd9\u6837\u80fd\u533a\u5206\u51fa\u6765",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1667597062",
    "pr_number": 2935,
    "pr_file": "src/server/context.ts",
    "created_at": "2024-07-07T03:09:03+00:00",
    "commented_code": "* This is useful for testing when we don't want to mock Next.js' request/response\n  */\n export const createContextInner = async (params?: {\n-  auth?: ClerkAuth;\n+  auth?: ClerkAuth | User;",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1667597062",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2935,
        "pr_file": "src/server/context.ts",
        "discussion_id": "1667597062",
        "commented_code": "@@ -18,7 +20,7 @@ export interface AuthContext {\n  * This is useful for testing when we don't want to mock Next.js' request/response\n  */\n export const createContextInner = async (params?: {\n-  auth?: ClerkAuth;\n+  auth?: ClerkAuth | User;",
        "comment_created_at": "2024-07-07T03:09:03+00:00",
        "comment_author": "arvinxx",
        "comment_body": "\u5efa\u8bae\u62c6\u4e00\u4e0b\uff0c\u8fd9\u4e2a auth\u6539\u540d\u4e3a clerkAuth\uff0c\u7136\u540e\u518d\u52a0\u4e00\u4e2a nextAuth",
        "pr_file_module": null
      },
      {
        "comment_id": "1670281310",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2935,
        "pr_file": "src/server/context.ts",
        "discussion_id": "1667597062",
        "commented_code": "@@ -18,7 +20,7 @@ export interface AuthContext {\n  * This is useful for testing when we don't want to mock Next.js' request/response\n  */\n export const createContextInner = async (params?: {\n-  auth?: ClerkAuth;\n+  auth?: ClerkAuth | User;",
        "comment_created_at": "2024-07-09T10:54:08+00:00",
        "comment_author": "cy948",
        "comment_body": "\u5df2\u62c6\u5206",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1678758737",
    "pr_number": 2935,
    "pr_file": "src/database/server/schemas/lobechat.ts",
    "created_at": "2024-07-16T04:59:06+00:00",
    "commented_code": "// Time user was created in Clerk\n   clerkCreatedAt: timestamptz('clerk_created_at'),\n \n-  preference: jsonb('preference').$defaultFn(() => DEFAULT_PREFERENCE),\n+  // Required by nextauth, all null allowed\n+  emailVerified: timestamptz('email_verified'),",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1678758737",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2935,
        "pr_file": "src/database/server/schemas/lobechat.ts",
        "discussion_id": "1678758737",
        "commented_code": "@@ -47,7 +50,10 @@ export const users = pgTable('users', {\n   // Time user was created in Clerk\n   clerkCreatedAt: timestamptz('clerk_created_at'),\n \n-  preference: jsonb('preference').$defaultFn(() => DEFAULT_PREFERENCE),\n+  // Required by nextauth, all null allowed\n+  emailVerified: timestamptz('email_verified'),",
        "comment_created_at": "2024-07-16T04:59:06+00:00",
        "comment_author": "arvinxx",
        "comment_body": "  `emailVerifiedAt: timestamptz('email_verified_at'),`\r\n\r\n\u4fdd\u6301\u547d\u540d\u98ce\u683c\u7edf\u4e00",
        "pr_file_module": null
      },
      {
        "comment_id": "1679056331",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2935,
        "pr_file": "src/database/server/schemas/lobechat.ts",
        "discussion_id": "1678758737",
        "commented_code": "@@ -47,7 +50,10 @@ export const users = pgTable('users', {\n   // Time user was created in Clerk\n   clerkCreatedAt: timestamptz('clerk_created_at'),\n \n-  preference: jsonb('preference').$defaultFn(() => DEFAULT_PREFERENCE),\n+  // Required by nextauth, all null allowed\n+  emailVerified: timestamptz('email_verified'),",
        "comment_created_at": "2024-07-16T09:22:48+00:00",
        "comment_author": "cy948",
        "comment_body": "\u5df2\u6539\u4e3a\u4e0a\u8ff0\u547d\u540d\u3002 https://github.com/lobehub/lobe-chat/pull/2935/commits/5ee2d9c623ba1d9c373a1625daf49cb0193a45eb",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1749116079",
    "pr_number": 3757,
    "pr_file": "src/config/modelProviders/siliconcloud.ts",
    "created_at": "2024-09-08T07:22:33+00:00",
    "commented_code": "const SiliconCloud: ModelProviderCard = {\n   chatModels: [\n     {\n-      enabled: true,\n-      id: 'Qwen/Qwen2-72B-Instruct',\n+      displayName: 'Qwen 2 1.5B',\n+      id: 'Qwen/Qwen2-1.5B-Instruct',\n       tokens: 32_768,\n     },\n     {\n       enabled: true,\n-      id: 'Qwen/Qwen2-Math-72B-Instruct',\n+      displayName: 'Qwen 2 7B',\n+      id: 'Qwen/Qwen2-7B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      enabled: true,\n+      displayName: 'Qwen 2 57B A14B',\n       id: 'Qwen/Qwen2-57B-A14B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen2-7B-Instruct',\n+      enabled: true,\n+      displayName: 'Qwen 2 72B',\n+      id: 'Qwen/Qwen2-72B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen2-1.5B-Instruct',\n+      enabled: true,\n+      displayName: 'Qwen 2 Math 72B',\n+      id: 'Qwen/Qwen2-Math-72B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-110B-Chat',\n+      displayName: 'Qwen 1.5 7B',\n+      id: 'Qwen/Qwen1.5-7B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-32B-Chat',\n+      displayName: 'Qwen 1.5 14B',\n+      id: 'Qwen/Qwen1.5-14B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-14B-Chat',\n+      displayName: 'Qwen 1.5 32B',\n+      id: 'Qwen/Qwen1.5-32B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-7B-Chat',\n+      displayName: 'Qwen 1.5 110B',\n+      id: 'Qwen/Qwen1.5-110B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'deepseek-ai/DeepSeek-Coder-V2-Instruct',\n-      tokens: 32_768,\n+      displayName: 'Yi 1.5 6B',",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1749116079",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 3757,
        "pr_file": "src/config/modelProviders/siliconcloud.ts",
        "discussion_id": "1749116079",
        "commented_code": "@@ -4,116 +4,150 @@ import { ModelProviderCard } from '@/types/llm';\n const SiliconCloud: ModelProviderCard = {\n   chatModels: [\n     {\n-      enabled: true,\n-      id: 'Qwen/Qwen2-72B-Instruct',\n+      displayName: 'Qwen 2 1.5B',\n+      id: 'Qwen/Qwen2-1.5B-Instruct',\n       tokens: 32_768,\n     },\n     {\n       enabled: true,\n-      id: 'Qwen/Qwen2-Math-72B-Instruct',\n+      displayName: 'Qwen 2 7B',\n+      id: 'Qwen/Qwen2-7B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      enabled: true,\n+      displayName: 'Qwen 2 57B A14B',\n       id: 'Qwen/Qwen2-57B-A14B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen2-7B-Instruct',\n+      enabled: true,\n+      displayName: 'Qwen 2 72B',\n+      id: 'Qwen/Qwen2-72B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen2-1.5B-Instruct',\n+      enabled: true,\n+      displayName: 'Qwen 2 Math 72B',\n+      id: 'Qwen/Qwen2-Math-72B-Instruct',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-110B-Chat',\n+      displayName: 'Qwen 1.5 7B',\n+      id: 'Qwen/Qwen1.5-7B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-32B-Chat',\n+      displayName: 'Qwen 1.5 14B',\n+      id: 'Qwen/Qwen1.5-14B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-14B-Chat',\n+      displayName: 'Qwen 1.5 32B',\n+      id: 'Qwen/Qwen1.5-32B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'Qwen/Qwen1.5-7B-Chat',\n+      displayName: 'Qwen 1.5 110B',\n+      id: 'Qwen/Qwen1.5-110B-Chat',\n       tokens: 32_768,\n     },\n     {\n-      id: 'deepseek-ai/DeepSeek-Coder-V2-Instruct',\n-      tokens: 32_768,\n+      displayName: 'Yi 1.5 6B',",
        "comment_created_at": "2024-09-08T07:22:33+00:00",
        "comment_author": "sxjeru",
        "comment_body": "Yi-1.5\uff0cGLM-4 \u8fd9\u4e9b\uff0c\u5c31\u50cf GPT-4 \u4e00\u6837\uff0c\u4e0d\u5efa\u8bae\u5c06\u6a2a\u6760\u8f6c\u6210\u7a7a\u683c\u3002",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1571947662",
    "pr_number": 2041,
    "pr_file": "src/app/api/chat/agentRuntime.ts",
    "created_at": "2024-04-19T07:25:59+00:00",
    "commented_code": "trace?: TracePayload;\n }\n \n-class AgentRuntime {\n-  private _runtime: LobeRuntimeAI;\n-\n-  constructor(runtime: LobeRuntimeAI) {\n-    this._runtime = runtime;\n-  }\n-\n-  async chat(\n-    payload: ChatStreamPayload,\n-    { trace: tracePayload, provider, enableTrace }: AgentChatOptions,\n-  ) {\n-    const { messages, model, tools, ...parameters } = payload;\n-\n-    // if not enabled trace then just call the runtime\n-    if (!enableTrace) return this._runtime.chat(payload);\n-\n-    // create a trace to monitor the completion\n-    const traceClient = new TraceClient();\n-    const trace = traceClient.createTrace({\n-      id: tracePayload?.traceId,\n-      input: messages,\n-      metadata: { provider },\n-      name: tracePayload?.traceName,\n-      sessionId: `${tracePayload?.sessionId || INBOX_SESSION_ID}@${tracePayload?.topicId || 'start'}`,\n-      tags: tracePayload?.tags,\n-      userId: tracePayload?.userId,\n-    });\n-\n-    const generation = trace?.generation({\n-      input: messages,\n-      metadata: { provider },\n-      model,\n-      modelParameters: parameters as any,\n-      name: `Chat Completion (${provider})`,\n-      startTime: new Date(),\n-    });\n-\n-    return this._runtime.chat(payload, {\n-      callback: {\n-        experimental_onToolCall: async () => {\n-          trace?.update({\n-            tags: [...(tracePayload?.tags || []), TraceTagMap.ToolsCall],\n-          });\n-        },\n-\n-        onCompletion: async (completion) => {\n-          generation?.update({\n-            endTime: new Date(),\n-            metadata: { provider, tools },\n-            output: completion,\n-          });\n-\n-          trace?.update({ output: completion });\n-        },\n-\n-        onFinal: async () => {\n-          await traceClient.shutdownAsync();\n-        },\n-\n-        onStart: () => {\n-          generation?.update({ completionStartTime: new Date() });\n-        },\n-      },\n-      headers: {\n-        [LOBE_CHAT_OBSERVATION_ID]: generation?.id,\n-        [LOBE_CHAT_TRACE_ID]: trace?.id,\n-      },\n-    });\n-  }\n-\n-  async models() {\n-    return this._runtime.models?.();\n-  }\n-\n-  static async initializeWithUserPayload(provider: string, payload: JWTPayload) {\n-    let runtimeModel: LobeRuntimeAI;\n-\n-    switch (provider) {\n-      default:\n-      case 'oneapi':\n-      case ModelProvider.OpenAI: {\n-        runtimeModel = this.initOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Azure: {\n-        runtimeModel = this.initAzureOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZhiPu: {\n-        runtimeModel = await this.initZhipu(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Google: {\n-        runtimeModel = this.initGoogle(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Moonshot: {\n-        runtimeModel = this.initMoonshot(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Bedrock: {\n-        runtimeModel = this.initBedrock(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Ollama: {\n-        runtimeModel = this.initOllama(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Perplexity: {\n-        runtimeModel = this.initPerplexity(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Anthropic: {\n-        runtimeModel = this.initAnthropic(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Mistral: {\n-        runtimeModel = this.initMistral(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Groq: {\n-        runtimeModel = this.initGroq(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.OpenRouter: {\n-        runtimeModel = this.initOpenRouter(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.TogetherAI: {\n-        runtimeModel = this.initTogetherAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZeroOne: {\n-        runtimeModel = this.initZeroOne(payload);\n-        break;\n+/**\n+ * Retrieves the options object from environment and apikeymanager\n+ * based on the provider and payload.\n+ *\n+ * @param provider - The model provider.\n+ * @param payload - The JWT payload.\n+ * @returns The options object.\n+ */\n+const getLlmOptionsFromPayload = (provider: string, payload: JWTPayload) => {\n+  switch (provider) {\n+    default: // Use Openai options as default\n+    case ModelProvider.OpenAI: {\n+      const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n+      const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n+      const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n+      const apiKey = apiKeyManager.pick(openaiApiKey);\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Azure: {\n+      const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n+      const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n+      const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n+      return {\n+        apiVersion,\n+        apikey: apiKey,\n+        endpoint,\n+      };\n+    }\n+    case ModelProvider.ZhiPu: {\n+      const { ZHIPU_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Google: {\n+      const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n+      const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Moonshot: {\n+      const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n+      return {\n+        apiKey,\n+        baseURL: MOONSHOT_PROXY_URL,\n+      };\n+    }\n+    case ModelProvider.Bedrock: {\n+      const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n+      let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n+      let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n+      let region = AWS_REGION;\n+      // if the payload has the api key, use user\n+      if (payload.apiKey) {\n+        accessKeyId = payload?.awsAccessKeyId;\n+        accessKeySecret = payload?.awsSecretAccessKey;\n+        region = payload?.awsRegion;\n       }\n+      return {\n+        accessKeyId,\n+        accessKeySecret,\n+        region,\n+      };\n     }\n-\n-    return new AgentRuntime(runtimeModel);\n-  }\n-\n-  private static initOpenAI(payload: JWTPayload) {\n-    const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n-    const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n-    const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n-\n-    const apiKey = apiKeyManager.pick(openaiApiKey);\n-\n-    return new LobeOpenAI({ apiKey, baseURL });\n-  }\n-\n-  private static initAzureOpenAI(payload: JWTPayload) {\n-    const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n-    const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n-    const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n-\n-    return new LobeAzureOpenAI(endpoint, apiKey, apiVersion);\n-  }\n-\n-  private static async initZhipu(payload: JWTPayload) {\n-    const { ZHIPU_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n-\n-    return LobeZhipuAI.fromAPIKey({ apiKey });\n-  }\n-\n-  private static initMoonshot(payload: JWTPayload) {\n-    const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n-\n-    return new LobeMoonshotAI({ apiKey, baseURL: MOONSHOT_PROXY_URL });\n-  }\n-\n-  private static initGoogle(payload: JWTPayload) {\n-    const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n-    const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n-\n-    return new LobeGoogleAI({ apiKey, baseURL });\n-  }\n-\n-  private static initBedrock(payload: JWTPayload) {\n-    const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n-\n-    let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n-    let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n-    let region = AWS_REGION;\n-    // if the payload has the api key, use user\n-    if (payload.apiKey) {\n-      accessKeyId = payload?.awsAccessKeyId;\n-      accessKeySecret = payload?.awsSecretAccessKey;\n-      region = payload?.awsRegion;\n+    case ModelProvider.Ollama: {\n+      const { OLLAMA_PROXY_URL } = getServerConfig();\n+      const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n+      return {\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Perplexity: {\n+      const { PERPLEXITY_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Anthropic: {\n+      const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n+      const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Mistral: {\n+      const { MISTRAL_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Groq: {\n+      const { GROQ_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.OpenRouter: {\n+      const { OPENROUTER_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.TogetherAI: {\n+      const { TOGETHERAI_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || TOGETHERAI_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.ZeroOne: {\n+      const { ZEROONE_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZEROONE_API_KEY);\n+      return {\n+        apiKey,\n+      };\n     }\n-\n-    return new LobeBedrockAI({ accessKeyId, accessKeySecret, region });\n-  }\n-\n-  private static initOllama(payload: JWTPayload) {\n-    const { OLLAMA_PROXY_URL } = getServerConfig();\n-    const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n-\n-    return new LobeOllamaAI({ baseURL });\n-  }\n-\n-  private static initPerplexity(payload: JWTPayload) {\n-    const { PERPLEXITY_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n-\n-    return new LobePerplexityAI({ apiKey });\n-  }\n-\n-  private static initAnthropic(payload: JWTPayload) {\n-    const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n-    const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n-    return new LobeAnthropicAI({ apiKey, baseURL });\n-  }\n-\n-  private static initMistral(payload: JWTPayload) {\n-    const { MISTRAL_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n-\n-    return new LobeMistralAI({ apiKey });\n-  }\n-\n-  private static initGroq(payload: JWTPayload) {\n-    const { GROQ_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n-\n-    return new LobeGroq({ apiKey });\n-  }\n-\n-  private static initOpenRouter(payload: JWTPayload) {\n-    const { OPENROUTER_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n-\n-    return new LobeOpenRouterAI({ apiKey });\n   }\n+};\n+\n+/**\n+ * Initializes the agent runtime with the user payload in backend\n+ * @param provider - The provider name.\n+ * @param payload - The JWT payload.\n+ * @returns A promise that resolves when the agent runtime is initialized.\n+ */\n+export const initializeWithUserPayload = (provider: string, payload: JWTPayload) => {",
    "repo_full_name": "lobehub/lobe-chat",
    "discussion_comments": [
      {
        "comment_id": "1571947662",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2041,
        "pr_file": "src/app/api/chat/agentRuntime.ts",
        "discussion_id": "1571947662",
        "commented_code": "@@ -36,272 +18,207 @@ export interface AgentChatOptions {\n   trace?: TracePayload;\n }\n \n-class AgentRuntime {\n-  private _runtime: LobeRuntimeAI;\n-\n-  constructor(runtime: LobeRuntimeAI) {\n-    this._runtime = runtime;\n-  }\n-\n-  async chat(\n-    payload: ChatStreamPayload,\n-    { trace: tracePayload, provider, enableTrace }: AgentChatOptions,\n-  ) {\n-    const { messages, model, tools, ...parameters } = payload;\n-\n-    // if not enabled trace then just call the runtime\n-    if (!enableTrace) return this._runtime.chat(payload);\n-\n-    // create a trace to monitor the completion\n-    const traceClient = new TraceClient();\n-    const trace = traceClient.createTrace({\n-      id: tracePayload?.traceId,\n-      input: messages,\n-      metadata: { provider },\n-      name: tracePayload?.traceName,\n-      sessionId: `${tracePayload?.sessionId || INBOX_SESSION_ID}@${tracePayload?.topicId || 'start'}`,\n-      tags: tracePayload?.tags,\n-      userId: tracePayload?.userId,\n-    });\n-\n-    const generation = trace?.generation({\n-      input: messages,\n-      metadata: { provider },\n-      model,\n-      modelParameters: parameters as any,\n-      name: `Chat Completion (${provider})`,\n-      startTime: new Date(),\n-    });\n-\n-    return this._runtime.chat(payload, {\n-      callback: {\n-        experimental_onToolCall: async () => {\n-          trace?.update({\n-            tags: [...(tracePayload?.tags || []), TraceTagMap.ToolsCall],\n-          });\n-        },\n-\n-        onCompletion: async (completion) => {\n-          generation?.update({\n-            endTime: new Date(),\n-            metadata: { provider, tools },\n-            output: completion,\n-          });\n-\n-          trace?.update({ output: completion });\n-        },\n-\n-        onFinal: async () => {\n-          await traceClient.shutdownAsync();\n-        },\n-\n-        onStart: () => {\n-          generation?.update({ completionStartTime: new Date() });\n-        },\n-      },\n-      headers: {\n-        [LOBE_CHAT_OBSERVATION_ID]: generation?.id,\n-        [LOBE_CHAT_TRACE_ID]: trace?.id,\n-      },\n-    });\n-  }\n-\n-  async models() {\n-    return this._runtime.models?.();\n-  }\n-\n-  static async initializeWithUserPayload(provider: string, payload: JWTPayload) {\n-    let runtimeModel: LobeRuntimeAI;\n-\n-    switch (provider) {\n-      default:\n-      case 'oneapi':\n-      case ModelProvider.OpenAI: {\n-        runtimeModel = this.initOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Azure: {\n-        runtimeModel = this.initAzureOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZhiPu: {\n-        runtimeModel = await this.initZhipu(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Google: {\n-        runtimeModel = this.initGoogle(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Moonshot: {\n-        runtimeModel = this.initMoonshot(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Bedrock: {\n-        runtimeModel = this.initBedrock(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Ollama: {\n-        runtimeModel = this.initOllama(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Perplexity: {\n-        runtimeModel = this.initPerplexity(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Anthropic: {\n-        runtimeModel = this.initAnthropic(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Mistral: {\n-        runtimeModel = this.initMistral(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Groq: {\n-        runtimeModel = this.initGroq(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.OpenRouter: {\n-        runtimeModel = this.initOpenRouter(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.TogetherAI: {\n-        runtimeModel = this.initTogetherAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZeroOne: {\n-        runtimeModel = this.initZeroOne(payload);\n-        break;\n+/**\n+ * Retrieves the options object from environment and apikeymanager\n+ * based on the provider and payload.\n+ *\n+ * @param provider - The model provider.\n+ * @param payload - The JWT payload.\n+ * @returns The options object.\n+ */\n+const getLlmOptionsFromPayload = (provider: string, payload: JWTPayload) => {\n+  switch (provider) {\n+    default: // Use Openai options as default\n+    case ModelProvider.OpenAI: {\n+      const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n+      const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n+      const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n+      const apiKey = apiKeyManager.pick(openaiApiKey);\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Azure: {\n+      const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n+      const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n+      const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n+      return {\n+        apiVersion,\n+        apikey: apiKey,\n+        endpoint,\n+      };\n+    }\n+    case ModelProvider.ZhiPu: {\n+      const { ZHIPU_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Google: {\n+      const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n+      const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Moonshot: {\n+      const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n+      return {\n+        apiKey,\n+        baseURL: MOONSHOT_PROXY_URL,\n+      };\n+    }\n+    case ModelProvider.Bedrock: {\n+      const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n+      let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n+      let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n+      let region = AWS_REGION;\n+      // if the payload has the api key, use user\n+      if (payload.apiKey) {\n+        accessKeyId = payload?.awsAccessKeyId;\n+        accessKeySecret = payload?.awsSecretAccessKey;\n+        region = payload?.awsRegion;\n       }\n+      return {\n+        accessKeyId,\n+        accessKeySecret,\n+        region,\n+      };\n     }\n-\n-    return new AgentRuntime(runtimeModel);\n-  }\n-\n-  private static initOpenAI(payload: JWTPayload) {\n-    const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n-    const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n-    const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n-\n-    const apiKey = apiKeyManager.pick(openaiApiKey);\n-\n-    return new LobeOpenAI({ apiKey, baseURL });\n-  }\n-\n-  private static initAzureOpenAI(payload: JWTPayload) {\n-    const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n-    const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n-    const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n-\n-    return new LobeAzureOpenAI(endpoint, apiKey, apiVersion);\n-  }\n-\n-  private static async initZhipu(payload: JWTPayload) {\n-    const { ZHIPU_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n-\n-    return LobeZhipuAI.fromAPIKey({ apiKey });\n-  }\n-\n-  private static initMoonshot(payload: JWTPayload) {\n-    const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n-\n-    return new LobeMoonshotAI({ apiKey, baseURL: MOONSHOT_PROXY_URL });\n-  }\n-\n-  private static initGoogle(payload: JWTPayload) {\n-    const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n-    const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n-\n-    return new LobeGoogleAI({ apiKey, baseURL });\n-  }\n-\n-  private static initBedrock(payload: JWTPayload) {\n-    const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n-\n-    let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n-    let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n-    let region = AWS_REGION;\n-    // if the payload has the api key, use user\n-    if (payload.apiKey) {\n-      accessKeyId = payload?.awsAccessKeyId;\n-      accessKeySecret = payload?.awsSecretAccessKey;\n-      region = payload?.awsRegion;\n+    case ModelProvider.Ollama: {\n+      const { OLLAMA_PROXY_URL } = getServerConfig();\n+      const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n+      return {\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Perplexity: {\n+      const { PERPLEXITY_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Anthropic: {\n+      const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n+      const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Mistral: {\n+      const { MISTRAL_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Groq: {\n+      const { GROQ_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.OpenRouter: {\n+      const { OPENROUTER_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.TogetherAI: {\n+      const { TOGETHERAI_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || TOGETHERAI_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.ZeroOne: {\n+      const { ZEROONE_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZEROONE_API_KEY);\n+      return {\n+        apiKey,\n+      };\n     }\n-\n-    return new LobeBedrockAI({ accessKeyId, accessKeySecret, region });\n-  }\n-\n-  private static initOllama(payload: JWTPayload) {\n-    const { OLLAMA_PROXY_URL } = getServerConfig();\n-    const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n-\n-    return new LobeOllamaAI({ baseURL });\n-  }\n-\n-  private static initPerplexity(payload: JWTPayload) {\n-    const { PERPLEXITY_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n-\n-    return new LobePerplexityAI({ apiKey });\n-  }\n-\n-  private static initAnthropic(payload: JWTPayload) {\n-    const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n-    const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n-    return new LobeAnthropicAI({ apiKey, baseURL });\n-  }\n-\n-  private static initMistral(payload: JWTPayload) {\n-    const { MISTRAL_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n-\n-    return new LobeMistralAI({ apiKey });\n-  }\n-\n-  private static initGroq(payload: JWTPayload) {\n-    const { GROQ_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n-\n-    return new LobeGroq({ apiKey });\n-  }\n-\n-  private static initOpenRouter(payload: JWTPayload) {\n-    const { OPENROUTER_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n-\n-    return new LobeOpenRouterAI({ apiKey });\n   }\n+};\n+\n+/**\n+ * Initializes the agent runtime with the user payload in backend\n+ * @param provider - The provider name.\n+ * @param payload - The JWT payload.\n+ * @returns A promise that resolves when the agent runtime is initialized.\n+ */\n+export const initializeWithUserPayload = (provider: string, payload: JWTPayload) => {",
        "comment_created_at": "2024-04-19T07:25:59+00:00",
        "comment_author": "arvinxx",
        "comment_body": "\u7531\u4e8e\u8fd9\u91cc\u53d8\u6210\u4e86\u4e00\u4e2a\u521d\u59cb\u5316\u65b9\u6cd5\uff0c\u6211\u5efa\u8bae\u6539\u540d\u53eb `initAgentRuntimeWithUserPayload` \uff0c\u8fd9\u6837\u6709\u5bbe\u8bed\u4f1a\u66f4\u52a0\u6e05\u695a",
        "pr_file_module": null
      },
      {
        "comment_id": "1572362640",
        "repo_full_name": "lobehub/lobe-chat",
        "pr_number": 2041,
        "pr_file": "src/app/api/chat/agentRuntime.ts",
        "discussion_id": "1571947662",
        "commented_code": "@@ -36,272 +18,207 @@ export interface AgentChatOptions {\n   trace?: TracePayload;\n }\n \n-class AgentRuntime {\n-  private _runtime: LobeRuntimeAI;\n-\n-  constructor(runtime: LobeRuntimeAI) {\n-    this._runtime = runtime;\n-  }\n-\n-  async chat(\n-    payload: ChatStreamPayload,\n-    { trace: tracePayload, provider, enableTrace }: AgentChatOptions,\n-  ) {\n-    const { messages, model, tools, ...parameters } = payload;\n-\n-    // if not enabled trace then just call the runtime\n-    if (!enableTrace) return this._runtime.chat(payload);\n-\n-    // create a trace to monitor the completion\n-    const traceClient = new TraceClient();\n-    const trace = traceClient.createTrace({\n-      id: tracePayload?.traceId,\n-      input: messages,\n-      metadata: { provider },\n-      name: tracePayload?.traceName,\n-      sessionId: `${tracePayload?.sessionId || INBOX_SESSION_ID}@${tracePayload?.topicId || 'start'}`,\n-      tags: tracePayload?.tags,\n-      userId: tracePayload?.userId,\n-    });\n-\n-    const generation = trace?.generation({\n-      input: messages,\n-      metadata: { provider },\n-      model,\n-      modelParameters: parameters as any,\n-      name: `Chat Completion (${provider})`,\n-      startTime: new Date(),\n-    });\n-\n-    return this._runtime.chat(payload, {\n-      callback: {\n-        experimental_onToolCall: async () => {\n-          trace?.update({\n-            tags: [...(tracePayload?.tags || []), TraceTagMap.ToolsCall],\n-          });\n-        },\n-\n-        onCompletion: async (completion) => {\n-          generation?.update({\n-            endTime: new Date(),\n-            metadata: { provider, tools },\n-            output: completion,\n-          });\n-\n-          trace?.update({ output: completion });\n-        },\n-\n-        onFinal: async () => {\n-          await traceClient.shutdownAsync();\n-        },\n-\n-        onStart: () => {\n-          generation?.update({ completionStartTime: new Date() });\n-        },\n-      },\n-      headers: {\n-        [LOBE_CHAT_OBSERVATION_ID]: generation?.id,\n-        [LOBE_CHAT_TRACE_ID]: trace?.id,\n-      },\n-    });\n-  }\n-\n-  async models() {\n-    return this._runtime.models?.();\n-  }\n-\n-  static async initializeWithUserPayload(provider: string, payload: JWTPayload) {\n-    let runtimeModel: LobeRuntimeAI;\n-\n-    switch (provider) {\n-      default:\n-      case 'oneapi':\n-      case ModelProvider.OpenAI: {\n-        runtimeModel = this.initOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Azure: {\n-        runtimeModel = this.initAzureOpenAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZhiPu: {\n-        runtimeModel = await this.initZhipu(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Google: {\n-        runtimeModel = this.initGoogle(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Moonshot: {\n-        runtimeModel = this.initMoonshot(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Bedrock: {\n-        runtimeModel = this.initBedrock(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Ollama: {\n-        runtimeModel = this.initOllama(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Perplexity: {\n-        runtimeModel = this.initPerplexity(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Anthropic: {\n-        runtimeModel = this.initAnthropic(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Mistral: {\n-        runtimeModel = this.initMistral(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.Groq: {\n-        runtimeModel = this.initGroq(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.OpenRouter: {\n-        runtimeModel = this.initOpenRouter(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.TogetherAI: {\n-        runtimeModel = this.initTogetherAI(payload);\n-        break;\n-      }\n-\n-      case ModelProvider.ZeroOne: {\n-        runtimeModel = this.initZeroOne(payload);\n-        break;\n+/**\n+ * Retrieves the options object from environment and apikeymanager\n+ * based on the provider and payload.\n+ *\n+ * @param provider - The model provider.\n+ * @param payload - The JWT payload.\n+ * @returns The options object.\n+ */\n+const getLlmOptionsFromPayload = (provider: string, payload: JWTPayload) => {\n+  switch (provider) {\n+    default: // Use Openai options as default\n+    case ModelProvider.OpenAI: {\n+      const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n+      const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n+      const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n+      const apiKey = apiKeyManager.pick(openaiApiKey);\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Azure: {\n+      const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n+      const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n+      const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n+      return {\n+        apiVersion,\n+        apikey: apiKey,\n+        endpoint,\n+      };\n+    }\n+    case ModelProvider.ZhiPu: {\n+      const { ZHIPU_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Google: {\n+      const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n+      const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Moonshot: {\n+      const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n+      return {\n+        apiKey,\n+        baseURL: MOONSHOT_PROXY_URL,\n+      };\n+    }\n+    case ModelProvider.Bedrock: {\n+      const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n+      let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n+      let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n+      let region = AWS_REGION;\n+      // if the payload has the api key, use user\n+      if (payload.apiKey) {\n+        accessKeyId = payload?.awsAccessKeyId;\n+        accessKeySecret = payload?.awsSecretAccessKey;\n+        region = payload?.awsRegion;\n       }\n+      return {\n+        accessKeyId,\n+        accessKeySecret,\n+        region,\n+      };\n     }\n-\n-    return new AgentRuntime(runtimeModel);\n-  }\n-\n-  private static initOpenAI(payload: JWTPayload) {\n-    const { OPENAI_API_KEY, OPENAI_PROXY_URL } = getServerConfig();\n-    const openaiApiKey = payload?.apiKey || OPENAI_API_KEY;\n-    const baseURL = payload?.endpoint || OPENAI_PROXY_URL;\n-\n-    const apiKey = apiKeyManager.pick(openaiApiKey);\n-\n-    return new LobeOpenAI({ apiKey, baseURL });\n-  }\n-\n-  private static initAzureOpenAI(payload: JWTPayload) {\n-    const { AZURE_API_KEY, AZURE_API_VERSION, AZURE_ENDPOINT } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || AZURE_API_KEY);\n-    const endpoint = payload?.endpoint || AZURE_ENDPOINT;\n-    const apiVersion = payload?.azureApiVersion || AZURE_API_VERSION;\n-\n-    return new LobeAzureOpenAI(endpoint, apiKey, apiVersion);\n-  }\n-\n-  private static async initZhipu(payload: JWTPayload) {\n-    const { ZHIPU_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ZHIPU_API_KEY);\n-\n-    return LobeZhipuAI.fromAPIKey({ apiKey });\n-  }\n-\n-  private static initMoonshot(payload: JWTPayload) {\n-    const { MOONSHOT_API_KEY, MOONSHOT_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MOONSHOT_API_KEY);\n-\n-    return new LobeMoonshotAI({ apiKey, baseURL: MOONSHOT_PROXY_URL });\n-  }\n-\n-  private static initGoogle(payload: JWTPayload) {\n-    const { GOOGLE_API_KEY, GOOGLE_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GOOGLE_API_KEY);\n-    const baseURL = payload?.endpoint || GOOGLE_PROXY_URL;\n-\n-    return new LobeGoogleAI({ apiKey, baseURL });\n-  }\n-\n-  private static initBedrock(payload: JWTPayload) {\n-    const { AWS_SECRET_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_REGION } = getServerConfig();\n-\n-    let accessKeyId: string | undefined = AWS_ACCESS_KEY_ID;\n-    let accessKeySecret: string | undefined = AWS_SECRET_ACCESS_KEY;\n-    let region = AWS_REGION;\n-    // if the payload has the api key, use user\n-    if (payload.apiKey) {\n-      accessKeyId = payload?.awsAccessKeyId;\n-      accessKeySecret = payload?.awsSecretAccessKey;\n-      region = payload?.awsRegion;\n+    case ModelProvider.Ollama: {\n+      const { OLLAMA_PROXY_URL } = getServerConfig();\n+      const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n+      return {\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Perplexity: {\n+      const { PERPLEXITY_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Anthropic: {\n+      const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n+      const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n+      return {\n+        apiKey,\n+        baseURL,\n+      };\n+    }\n+    case ModelProvider.Mistral: {\n+      const { MISTRAL_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.Groq: {\n+      const { GROQ_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.OpenRouter: {\n+      const { OPENROUTER_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.TogetherAI: {\n+      const { TOGETHERAI_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || TOGETHERAI_API_KEY);\n+      return {\n+        apiKey,\n+      };\n+    }\n+    case ModelProvider.ZeroOne: {\n+      const { ZEROONE_API_KEY } = getServerConfig();\n+      const apiKey = apiKeyManager.pick(payload?.apiKey || ZEROONE_API_KEY);\n+      return {\n+        apiKey,\n+      };\n     }\n-\n-    return new LobeBedrockAI({ accessKeyId, accessKeySecret, region });\n-  }\n-\n-  private static initOllama(payload: JWTPayload) {\n-    const { OLLAMA_PROXY_URL } = getServerConfig();\n-    const baseURL = payload?.endpoint || OLLAMA_PROXY_URL;\n-\n-    return new LobeOllamaAI({ baseURL });\n-  }\n-\n-  private static initPerplexity(payload: JWTPayload) {\n-    const { PERPLEXITY_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || PERPLEXITY_API_KEY);\n-\n-    return new LobePerplexityAI({ apiKey });\n-  }\n-\n-  private static initAnthropic(payload: JWTPayload) {\n-    const { ANTHROPIC_API_KEY, ANTHROPIC_PROXY_URL } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || ANTHROPIC_API_KEY);\n-    const baseURL = payload?.endpoint || ANTHROPIC_PROXY_URL;\n-    return new LobeAnthropicAI({ apiKey, baseURL });\n-  }\n-\n-  private static initMistral(payload: JWTPayload) {\n-    const { MISTRAL_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || MISTRAL_API_KEY);\n-\n-    return new LobeMistralAI({ apiKey });\n-  }\n-\n-  private static initGroq(payload: JWTPayload) {\n-    const { GROQ_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || GROQ_API_KEY);\n-\n-    return new LobeGroq({ apiKey });\n-  }\n-\n-  private static initOpenRouter(payload: JWTPayload) {\n-    const { OPENROUTER_API_KEY } = getServerConfig();\n-    const apiKey = apiKeyManager.pick(payload?.apiKey || OPENROUTER_API_KEY);\n-\n-    return new LobeOpenRouterAI({ apiKey });\n   }\n+};\n+\n+/**\n+ * Initializes the agent runtime with the user payload in backend\n+ * @param provider - The provider name.\n+ * @param payload - The JWT payload.\n+ * @returns A promise that resolves when the agent runtime is initialized.\n+ */\n+export const initializeWithUserPayload = (provider: string, payload: JWTPayload) => {",
        "comment_created_at": "2024-04-19T13:19:51+00:00",
        "comment_author": "cy948",
        "comment_body": "\u5df2\u6539",
        "pr_file_module": null
      }
    ]
  }
]