[
  {
    "discussion_id": "1735684204",
    "pr_number": 11491,
    "pr_file": "deps/outliner/src/logseq/outliner/core.cljs",
    "created_at": "2024-08-29T07:10:07+00:00",
    "commented_code": "(map (fn [tag]\n                 [:db/retract (:db/id block) :block/tags (:db/id tag)])))))\n \n+;; TODO: Validate tagless pages and other block types\n+(defn- validate-unique-by-name-tag-and-block-type\n+  [db new-title {:block/keys [tags] :as entity}]\n+  ;; (prn :entity entity)\n+  (cond\n+    (ldb/page? entity)\n+    (when-let [res (seq (d/q '[:find [(pull ?b [* {:block/tags [:block/title]}])]",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1735684204",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11491,
        "pr_file": "deps/outliner/src/logseq/outliner/core.cljs",
        "discussion_id": "1735684204",
        "commented_code": "@@ -232,6 +232,40 @@\n          (map (fn [tag]\n                 [:db/retract (:db/id block) :block/tags (:db/id tag)])))))\n \n+;; TODO: Validate tagless pages and other block types\n+(defn- validate-unique-by-name-tag-and-block-type\n+  [db new-title {:block/keys [tags] :as entity}]\n+  ;; (prn :entity entity)\n+  (cond\n+    (ldb/page? entity)\n+    (when-let [res (seq (d/q '[:find [(pull ?b [* {:block/tags [:block/title]}])]",
        "comment_created_at": "2024-08-29T07:10:07+00:00",
        "comment_author": "RCmerci",
        "comment_body": "there's no need to `pull ?b` here, only used in the exception-branch(`throw ex-info`). \r\nwe should delay this `pull`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1735726633",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11491,
        "pr_file": "deps/outliner/src/logseq/outliner/core.cljs",
        "discussion_id": "1735684204",
        "commented_code": "@@ -232,6 +232,40 @@\n          (map (fn [tag]\n                 [:db/retract (:db/id block) :block/tags (:db/id tag)])))))\n \n+;; TODO: Validate tagless pages and other block types\n+(defn- validate-unique-by-name-tag-and-block-type\n+  [db new-title {:block/keys [tags] :as entity}]\n+  ;; (prn :entity entity)\n+  (cond\n+    (ldb/page? entity)\n+    (when-let [res (seq (d/q '[:find [(pull ?b [* {:block/tags [:block/title]}])]",
        "comment_created_at": "2024-08-29T07:43:22+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "Agree, I'll leave this to @logseq-cldwalker.",
        "pr_file_module": null
      },
      {
        "comment_id": "1736305044",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11491,
        "pr_file": "deps/outliner/src/logseq/outliner/core.cljs",
        "discussion_id": "1735684204",
        "commented_code": "@@ -232,6 +232,40 @@\n          (map (fn [tag]\n                 [:db/retract (:db/id block) :block/tags (:db/id tag)])))))\n \n+;; TODO: Validate tagless pages and other block types\n+(defn- validate-unique-by-name-tag-and-block-type\n+  [db new-title {:block/keys [tags] :as entity}]\n+  ;; (prn :entity entity)\n+  (cond\n+    (ldb/page? entity)\n+    (when-let [res (seq (d/q '[:find [(pull ?b [* {:block/tags [:block/title]}])]",
        "comment_created_at": "2024-08-29T14:14:06+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Ah yep. Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1134608788",
    "pr_number": 8774,
    "pr_file": "src/main/frontend/handler/query/builder.cljs",
    "created_at": "2023-03-13T20:57:40+00:00",
    "commented_code": "+(ns frontend.handler.query.builder\n+  \"DSL query builder handler\"\n+  (:require [clojure.walk :as walk]\n+            [logseq.graph-parser.util.page-ref :as page-ref]))\n+\n+;; TODO: make it extensible for Datalog/SPARQL etc.\n+\n+(def operators [:and :or :not])\n+(def operators-set (set operators))\n+(def page-filters [\"all page tags\"\n+                   \"namespace\"\n+                   \"tags\"\n+                   \"property\"\n+                   \"sample\"])\n+(def block-filters [\"page reference\"\n+                    \"property\"\n+                    \"task\"\n+                    \"priority\"\n+                    \"page\"\n+                    \"full text search\"\n+                    \"between\"\n+                    \"sample\"])\n+\n+(defn- vec-dissoc-item\n+  [vec idx]\n+  (into (subvec vec 0 idx) (subvec vec (inc idx))))\n+\n+(defn- vec-assoc-item\n+  [vec idx item]\n+  (into (conj (subvec vec 0 idx) item)\n+        (subvec vec idx)))\n+\n+(defn- vec-replace-item\n+  [v idx item]\n+  (into (if (and (coll? item)\n+                 (not (operators-set (first item))))\n+          (vec (concat (subvec v 0 idx) item))\n+          (conj (subvec v 0 idx) item))\n+        (subvec v (inc idx))))\n+\n+(defn add-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (cond\n+    (and (seq loc) (= 1 (count loc)))\n+    (vec-assoc-item q (first loc) x)\n+\n+    (seq loc)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-assoc-item v (last loc) x)))\n+\n+    (seq q)\n+    (conj q x)\n+\n+    :else\n+    [x]))\n+\n+(defn append-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (let [idx (count (get-in q (vec (butlast loc))))\n+        loc' (vec-replace-item loc (dec (count loc)) idx)]\n+    (add-element q loc' x)))\n+\n+(defn remove-element\n+  [q loc]\n+  (if (seq loc)\n+    (let [idx (last loc)\n+          ks (vec (butlast loc))\n+          f #(vec-dissoc-item % idx)]\n+      (if (seq ks)\n+        (let [result (update-in q ks f)]\n+          (if (seq (get-in result ks))\n+            result\n+            ;; remove the wrapped empty vector\n+            (remove-element result ks)))\n+        (f q)))\n+    ;; default to AND operator\n+    [:and]))\n+\n+(defn replace-element\n+  [q loc x]\n+  {:pre [(vector? loc) (seq loc) (some? x)]}\n+  (if (= 1 (count loc))\n+    (vec-replace-item q (first loc) x)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-replace-item v (last loc) x)))))\n+\n+(defn wrap-operator\n+  [q loc operator]\n+  {:pre [(seq q) (operators-set operator)]}\n+  (if (or (= loc [0]) (empty? loc))\n+    [operator q]\n+    (when-let [x (get-in q loc)]\n+      (let [x' [operator x]]\n+        (replace-element q loc x')))))\n+\n+(defn unwrap-operator\n+  [q loc]\n+  {:pre [(seq q) (seq loc)]}\n+  (let [result (if (and (= loc [0]) (operators-set (first q)))\n+                 (second q)\n+                 (when-let [x (get-in q loc)]\n+                   (when (and (operators-set (first x))\n+                              (seq (rest x)))\n+                     (let [x' (rest x)]\n+                       (replace-element q loc x')))))]\n+    (if (empty? result)\n+      q\n+      result)))\n+\n+(defn ->page-ref\n+  [x]\n+  (if (string? x)\n+    (symbol (page-ref/->page-ref x))\n+    (->page-ref (second x))))\n+\n+(defn ->dsl\n+  [col]\n+  (->>\n+   (walk/prewalk\n+    (fn [f]\n+      (cond\n+        (and (vector? f) (= :priority (keyword (first f))))\n+        (vec (cons (symbol :priority) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :task (keyword (first f))))\n+        (vec (cons (symbol :task) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :page-ref (keyword (first f))))\n+        (->page-ref (second f))\n+\n+        (and (vector? f) (= :page-tags (keyword (first f))))\n+        [(symbol :page-tags) (->page-ref (second f))]\n+\n+        (and (vector? f) (= :between (keyword (first f))))\n+        (into [(symbol :between)] (map ->page-ref (rest f)))\n+\n+        ;; property key value\n+        (and (vector? f) (= 3 (count f)) (contains? #{:page-property :property} (keyword (first f))))\n+        (let [l (if (page-ref/page-ref? (str (last f)))\n+                  (symbol (last f))\n+                  (last f))]\n+          (into [(symbol (first f))] [(second f) l]))\n+\n+        (and (vector? f) (contains? #{:page :namespace :tags} (keyword (first f))))\n+        (into [(symbol (first f))] (map ->page-ref (rest f)))\n+\n+        :else f))\n+    col)\n+   (walk/prewalk",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1134608788",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8774,
        "pr_file": "src/main/frontend/handler/query/builder.cljs",
        "discussion_id": "1134608788",
        "commented_code": "@@ -0,0 +1,181 @@\n+(ns frontend.handler.query.builder\n+  \"DSL query builder handler\"\n+  (:require [clojure.walk :as walk]\n+            [logseq.graph-parser.util.page-ref :as page-ref]))\n+\n+;; TODO: make it extensible for Datalog/SPARQL etc.\n+\n+(def operators [:and :or :not])\n+(def operators-set (set operators))\n+(def page-filters [\"all page tags\"\n+                   \"namespace\"\n+                   \"tags\"\n+                   \"property\"\n+                   \"sample\"])\n+(def block-filters [\"page reference\"\n+                    \"property\"\n+                    \"task\"\n+                    \"priority\"\n+                    \"page\"\n+                    \"full text search\"\n+                    \"between\"\n+                    \"sample\"])\n+\n+(defn- vec-dissoc-item\n+  [vec idx]\n+  (into (subvec vec 0 idx) (subvec vec (inc idx))))\n+\n+(defn- vec-assoc-item\n+  [vec idx item]\n+  (into (conj (subvec vec 0 idx) item)\n+        (subvec vec idx)))\n+\n+(defn- vec-replace-item\n+  [v idx item]\n+  (into (if (and (coll? item)\n+                 (not (operators-set (first item))))\n+          (vec (concat (subvec v 0 idx) item))\n+          (conj (subvec v 0 idx) item))\n+        (subvec v (inc idx))))\n+\n+(defn add-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (cond\n+    (and (seq loc) (= 1 (count loc)))\n+    (vec-assoc-item q (first loc) x)\n+\n+    (seq loc)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-assoc-item v (last loc) x)))\n+\n+    (seq q)\n+    (conj q x)\n+\n+    :else\n+    [x]))\n+\n+(defn append-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (let [idx (count (get-in q (vec (butlast loc))))\n+        loc' (vec-replace-item loc (dec (count loc)) idx)]\n+    (add-element q loc' x)))\n+\n+(defn remove-element\n+  [q loc]\n+  (if (seq loc)\n+    (let [idx (last loc)\n+          ks (vec (butlast loc))\n+          f #(vec-dissoc-item % idx)]\n+      (if (seq ks)\n+        (let [result (update-in q ks f)]\n+          (if (seq (get-in result ks))\n+            result\n+            ;; remove the wrapped empty vector\n+            (remove-element result ks)))\n+        (f q)))\n+    ;; default to AND operator\n+    [:and]))\n+\n+(defn replace-element\n+  [q loc x]\n+  {:pre [(vector? loc) (seq loc) (some? x)]}\n+  (if (= 1 (count loc))\n+    (vec-replace-item q (first loc) x)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-replace-item v (last loc) x)))))\n+\n+(defn wrap-operator\n+  [q loc operator]\n+  {:pre [(seq q) (operators-set operator)]}\n+  (if (or (= loc [0]) (empty? loc))\n+    [operator q]\n+    (when-let [x (get-in q loc)]\n+      (let [x' [operator x]]\n+        (replace-element q loc x')))))\n+\n+(defn unwrap-operator\n+  [q loc]\n+  {:pre [(seq q) (seq loc)]}\n+  (let [result (if (and (= loc [0]) (operators-set (first q)))\n+                 (second q)\n+                 (when-let [x (get-in q loc)]\n+                   (when (and (operators-set (first x))\n+                              (seq (rest x)))\n+                     (let [x' (rest x)]\n+                       (replace-element q loc x')))))]\n+    (if (empty? result)\n+      q\n+      result)))\n+\n+(defn ->page-ref\n+  [x]\n+  (if (string? x)\n+    (symbol (page-ref/->page-ref x))\n+    (->page-ref (second x))))\n+\n+(defn ->dsl\n+  [col]\n+  (->>\n+   (walk/prewalk\n+    (fn [f]\n+      (cond\n+        (and (vector? f) (= :priority (keyword (first f))))\n+        (vec (cons (symbol :priority) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :task (keyword (first f))))\n+        (vec (cons (symbol :task) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :page-ref (keyword (first f))))\n+        (->page-ref (second f))\n+\n+        (and (vector? f) (= :page-tags (keyword (first f))))\n+        [(symbol :page-tags) (->page-ref (second f))]\n+\n+        (and (vector? f) (= :between (keyword (first f))))\n+        (into [(symbol :between)] (map ->page-ref (rest f)))\n+\n+        ;; property key value\n+        (and (vector? f) (= 3 (count f)) (contains? #{:page-property :property} (keyword (first f))))\n+        (let [l (if (page-ref/page-ref? (str (last f)))\n+                  (symbol (last f))\n+                  (last f))]\n+          (into [(symbol (first f))] [(second f) l]))\n+\n+        (and (vector? f) (contains? #{:page :namespace :tags} (keyword (first f))))\n+        (into [(symbol (first f))] (map ->page-ref (rest f)))\n+\n+        :else f))\n+    col)\n+   (walk/prewalk",
        "comment_created_at": "2023-03-13T20:57:40+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Given how walks aren't that performant, we should remove extra ones like this if we don't need em. I'll do this",
        "pr_file_module": null
      },
      {
        "comment_id": "1134885264",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8774,
        "pr_file": "src/main/frontend/handler/query/builder.cljs",
        "discussion_id": "1134608788",
        "commented_code": "@@ -0,0 +1,181 @@\n+(ns frontend.handler.query.builder\n+  \"DSL query builder handler\"\n+  (:require [clojure.walk :as walk]\n+            [logseq.graph-parser.util.page-ref :as page-ref]))\n+\n+;; TODO: make it extensible for Datalog/SPARQL etc.\n+\n+(def operators [:and :or :not])\n+(def operators-set (set operators))\n+(def page-filters [\"all page tags\"\n+                   \"namespace\"\n+                   \"tags\"\n+                   \"property\"\n+                   \"sample\"])\n+(def block-filters [\"page reference\"\n+                    \"property\"\n+                    \"task\"\n+                    \"priority\"\n+                    \"page\"\n+                    \"full text search\"\n+                    \"between\"\n+                    \"sample\"])\n+\n+(defn- vec-dissoc-item\n+  [vec idx]\n+  (into (subvec vec 0 idx) (subvec vec (inc idx))))\n+\n+(defn- vec-assoc-item\n+  [vec idx item]\n+  (into (conj (subvec vec 0 idx) item)\n+        (subvec vec idx)))\n+\n+(defn- vec-replace-item\n+  [v idx item]\n+  (into (if (and (coll? item)\n+                 (not (operators-set (first item))))\n+          (vec (concat (subvec v 0 idx) item))\n+          (conj (subvec v 0 idx) item))\n+        (subvec v (inc idx))))\n+\n+(defn add-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (cond\n+    (and (seq loc) (= 1 (count loc)))\n+    (vec-assoc-item q (first loc) x)\n+\n+    (seq loc)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-assoc-item v (last loc) x)))\n+\n+    (seq q)\n+    (conj q x)\n+\n+    :else\n+    [x]))\n+\n+(defn append-element\n+  [q loc x]\n+  {:pre [(vector? loc) (some? x)]}\n+  (let [idx (count (get-in q (vec (butlast loc))))\n+        loc' (vec-replace-item loc (dec (count loc)) idx)]\n+    (add-element q loc' x)))\n+\n+(defn remove-element\n+  [q loc]\n+  (if (seq loc)\n+    (let [idx (last loc)\n+          ks (vec (butlast loc))\n+          f #(vec-dissoc-item % idx)]\n+      (if (seq ks)\n+        (let [result (update-in q ks f)]\n+          (if (seq (get-in result ks))\n+            result\n+            ;; remove the wrapped empty vector\n+            (remove-element result ks)))\n+        (f q)))\n+    ;; default to AND operator\n+    [:and]))\n+\n+(defn replace-element\n+  [q loc x]\n+  {:pre [(vector? loc) (seq loc) (some? x)]}\n+  (if (= 1 (count loc))\n+    (vec-replace-item q (first loc) x)\n+    (update-in q (vec (butlast loc))\n+               (fn [v]\n+                 (vec-replace-item v (last loc) x)))))\n+\n+(defn wrap-operator\n+  [q loc operator]\n+  {:pre [(seq q) (operators-set operator)]}\n+  (if (or (= loc [0]) (empty? loc))\n+    [operator q]\n+    (when-let [x (get-in q loc)]\n+      (let [x' [operator x]]\n+        (replace-element q loc x')))))\n+\n+(defn unwrap-operator\n+  [q loc]\n+  {:pre [(seq q) (seq loc)]}\n+  (let [result (if (and (= loc [0]) (operators-set (first q)))\n+                 (second q)\n+                 (when-let [x (get-in q loc)]\n+                   (when (and (operators-set (first x))\n+                              (seq (rest x)))\n+                     (let [x' (rest x)]\n+                       (replace-element q loc x')))))]\n+    (if (empty? result)\n+      q\n+      result)))\n+\n+(defn ->page-ref\n+  [x]\n+  (if (string? x)\n+    (symbol (page-ref/->page-ref x))\n+    (->page-ref (second x))))\n+\n+(defn ->dsl\n+  [col]\n+  (->>\n+   (walk/prewalk\n+    (fn [f]\n+      (cond\n+        (and (vector? f) (= :priority (keyword (first f))))\n+        (vec (cons (symbol :priority) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :task (keyword (first f))))\n+        (vec (cons (symbol :task) (map symbol (rest f))))\n+\n+        (and (vector? f) (= :page-ref (keyword (first f))))\n+        (->page-ref (second f))\n+\n+        (and (vector? f) (= :page-tags (keyword (first f))))\n+        [(symbol :page-tags) (->page-ref (second f))]\n+\n+        (and (vector? f) (= :between (keyword (first f))))\n+        (into [(symbol :between)] (map ->page-ref (rest f)))\n+\n+        ;; property key value\n+        (and (vector? f) (= 3 (count f)) (contains? #{:page-property :property} (keyword (first f))))\n+        (let [l (if (page-ref/page-ref? (str (last f)))\n+                  (symbol (last f))\n+                  (last f))]\n+          (into [(symbol (first f))] [(second f) l]))\n+\n+        (and (vector? f) (contains? #{:page :namespace :tags} (keyword (first f))))\n+        (into [(symbol (first f))] (map ->page-ref (rest f)))\n+\n+        :else f))\n+    col)\n+   (walk/prewalk",
        "comment_created_at": "2023-03-14T03:33:34+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "Thanks for addressing this!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1067948383",
    "pr_number": 8323,
    "pr_file": "deps/graph-parser/src/logseq/graph_parser/util.cljs",
    "created_at": "2023-01-12T10:24:53+00:00",
    "commented_code": "el))\n    nm))\n \n+(defn remove-nils-non-nested\n+  \"remove pairs of key-value that has nil value from a map (nested not supported).\"\n+  [nm]\n+  (into {} (remove (comp nil? second)) nm))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1067948383",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8323,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/util.cljs",
        "discussion_id": "1067948383",
        "commented_code": "@@ -37,6 +38,16 @@\n        el))\n    nm))\n \n+(defn remove-nils-non-nested\n+  \"remove pairs of key-value that has nil value from a map (nested not supported).\"\n+  [nm]\n+  (into {} (remove (comp nil? second)) nm))",
        "comment_created_at": "2023-01-12T10:24:53+00:00",
        "comment_author": "RCmerci",
        "comment_body": "``` clojure\r\n(def remove-nils-non-nested\r\n  (let [f (comp nil? second)]\r\n    (fn [nm]\r\n      (into {} (remove f) nm))))\r\n```\r\nthis version can be faster, no need to construct `(comp nil? second)` on every remove-nils-non-nested call",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1065701014",
    "pr_number": 8294,
    "pr_file": "src/electron/electron/handler.cljs",
    "created_at": "2023-01-10T12:00:48+00:00",
    "commented_code": "(defmethod handle :mkdir-recur [_window [_ dir]]\n   (fs/mkdirSync dir #js {:recursive true}))\n \n-;; {encoding: 'utf8', withFileTypes: true}\n (defn- readdir\n-  [dir]\n+  \"Read directory recursively, return all filenames\"",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1065701014",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8294,
        "pr_file": "src/electron/electron/handler.cljs",
        "discussion_id": "1065701014",
        "commented_code": "@@ -38,19 +38,23 @@\n (defmethod handle :mkdir-recur [_window [_ dir]]\n   (fs/mkdirSync dir #js {:recursive true}))\n \n-;; {encoding: 'utf8', withFileTypes: true}\n (defn- readdir\n-  [dir]\n+  \"Read directory recursively, return all filenames\"",
        "comment_created_at": "2023-01-10T12:00:48+00:00",
        "comment_author": "andelf",
        "comment_body": "- filter out diretories.\r\n- avoid `statSync` call\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "955179880",
    "pr_number": 6483,
    "pr_file": "src/main/frontend/util/property.cljs",
    "created_at": "2022-08-25T16:19:11+00:00",
    "commented_code": "(defn remove-built-in-properties\n   [format content]\n   (let [built-in-properties* (built-in-properties)\n-        content (reduce (fn [content key]\n-                          (remove-property format key content)) content built-in-properties*)]\n+        prop-pat (string/join \"|\" (map #(gstring/regExpEscape (subs (str %) 1)) built-in-properties*))\n+        prop-line-pat (if (= format :org)\n+                        (str \"(\\\n|^)(#\\\\+|:)\" \"(\" prop-pat \"): .+?(\\\n|$)\")\n+                        (str \"(\\\n|^)(\" prop-pat \"):: .+?(\\\n|$)\"))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "955179880",
        "repo_full_name": "logseq/logseq",
        "pr_number": 6483,
        "pr_file": "src/main/frontend/util/property.cljs",
        "discussion_id": "955179880",
        "commented_code": "@@ -357,10 +358,13 @@\n (defn remove-built-in-properties\n   [format content]\n   (let [built-in-properties* (built-in-properties)\n-        content (reduce (fn [content key]\n-                          (remove-property format key content)) content built-in-properties*)]\n+        prop-pat (string/join \"|\" (map #(gstring/regExpEscape (subs (str %) 1)) built-in-properties*))\n+        prop-line-pat (if (= format :org)\n+                        (str \"(\\\\n|^)(#\\\\+|:)\" \"(\" prop-pat \"): .+?(\\\\n|$)\")\n+                        (str \"(\\\\n|^)(\" prop-pat \"):: .+?(\\\\n|$)\"))",
        "comment_created_at": "2022-08-25T16:19:11+00:00",
        "comment_author": "andelf",
        "comment_body": "This can be a `defonce` for better performance.",
        "pr_file_module": null
      }
    ]
  }
]