[
  {
    "discussion_id": "2012076979",
    "pr_number": 11790,
    "pr_file": "src/main/frontend/db/async.cljs",
    "created_at": "2025-03-25T13:17:27+00:00",
    "commented_code": "name-or-uuid)]\n     (if (or (:block.temp/fully-loaded? e) async-requested?)\n       e\n-      (when-let [^Object sqlite @db-browser/*worker]",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "2012076979",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "src/main/frontend/db/async.cljs",
        "discussion_id": "2012076979",
        "commented_code": "@@ -147,13 +147,12 @@\n                name-or-uuid)]\n     (if (or (:block.temp/fully-loaded? e) async-requested?)\n       e\n-      (when-let [^Object sqlite @db-browser/*worker]",
        "comment_created_at": "2025-03-25T13:17:27+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Almost everywhere we call a worker fn we use a when-let. Is this actually necessary in most places or is it only one or two places that needed it before worker was defined and then it got copied everywhere? If it is needed in most places, would it be helpful to provide a more stable api fn that wraps the atom?",
        "pr_file_module": null
      },
      {
        "comment_id": "2013915489",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "src/main/frontend/db/async.cljs",
        "discussion_id": "2012076979",
        "commented_code": "@@ -147,13 +147,12 @@\n                name-or-uuid)]\n     (if (or (:block.temp/fully-loaded? e) async-requested?)\n       e\n-      (when-let [^Object sqlite @db-browser/*worker]",
        "comment_created_at": "2025-03-26T11:12:17+00:00",
        "comment_author": "RCmerci",
        "comment_body": "update:\r\nI removed ~40 instances of code like `(when-let [worker @*db-worker] (worker ...))`.\r\nuse `<invoke-db-worker` to replace them.\r\n> Is this actually necessary in most places or is it only one or two places that needed it before worker was defined\r\n\r\nyes, I think so.\r\nAdditionally, I believe we haven't properly handled the failure case of (when-let ...),\r\nonly skipping certain logic execution.  \r\nTherefore, I think when encountering `(nil? @*db-worker)`, we should fail fast and throw an error(because all the usages should happen after *db-worker inited).",
        "pr_file_module": null
      },
      {
        "comment_id": "2014069423",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "src/main/frontend/db/async.cljs",
        "discussion_id": "2012076979",
        "commented_code": "@@ -147,13 +147,12 @@\n                name-or-uuid)]\n     (if (or (:block.temp/fully-loaded? e) async-requested?)\n       e\n-      (when-let [^Object sqlite @db-browser/*worker]",
        "comment_created_at": "2025-03-26T12:46:26+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Thanks for making this more consistent to use and adding explicit error handling!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014086284",
    "pr_number": 11790,
    "pr_file": "deps/db/src/logseq/db/sqlite/util.cljs",
    "created_at": "2025-03-26T12:56:10+00:00",
    "commented_code": "\"datascript/Entity\" identity)\n                             (merge read-handlers))\n         reader (transit/reader :json {:handlers read-handlers*})]\n-    (fn read-transit-str* [s] (transit/read reader s))))\n+    (fn read-transit-str* [s]\n+      (if (and (string? s) (identical? \"[\" (first s)))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "2014086284",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "deps/db/src/logseq/db/sqlite/util.cljs",
        "discussion_id": "2014086284",
        "commented_code": "@@ -50,7 +50,11 @@\n                                    \"datascript/Entity\" identity)\n                             (merge read-handlers))\n         reader (transit/reader :json {:handlers read-handlers*})]\n-    (fn read-transit-str* [s] (transit/read reader s))))\n+    (fn read-transit-str* [s]\n+      (if (and (string? s) (identical? \"[\" (first s)))",
        "comment_created_at": "2025-03-26T12:56:10+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "A comment for this check could be helpful. Unclear why we pass invalid calls through silently rather than fail explicitly",
        "pr_file_module": null
      },
      {
        "comment_id": "2014120469",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "deps/db/src/logseq/db/sqlite/util.cljs",
        "discussion_id": "2014086284",
        "commented_code": "@@ -50,7 +50,11 @@\n                                    \"datascript/Entity\" identity)\n                             (merge read-handlers))\n         reader (transit/reader :json {:handlers read-handlers*})]\n-    (fn read-transit-str* [s] (transit/read reader s))))\n+    (fn read-transit-str* [s]\n+      (if (and (string? s) (identical? \"[\" (first s)))",
        "comment_created_at": "2025-03-26T13:15:20+00:00",
        "comment_author": "RCmerci",
        "comment_body": "The reason I didn't throw an error here is:  \r\nIf I accidentally missed deleting an ldb/read-transit-str in this PR, we can still see the :invalid-transit-string message in the console,  \r\nwithout affecting the original normal logic.  \r\n\r\nanother reason for not using `assert` here:  \r\nIf assert is used here but ldb/read-transit-str is used within `p/let` (without explicit `p/catch`), I found no error log appears in the console, which provides no help in identifying the issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "2014129686",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "deps/db/src/logseq/db/sqlite/util.cljs",
        "discussion_id": "2014086284",
        "commented_code": "@@ -50,7 +50,11 @@\n                                    \"datascript/Entity\" identity)\n                             (merge read-handlers))\n         reader (transit/reader :json {:handlers read-handlers*})]\n-    (fn read-transit-str* [s] (transit/read reader s))))\n+    (fn read-transit-str* [s]\n+      (if (and (string? s) (identical? \"[\" (first s)))",
        "comment_created_at": "2025-03-26T13:19:51+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Gotcha. Good to know it was useful for refactoring. Hopefully we can delete it later when there aren't any more missed deletions",
        "pr_file_module": null
      },
      {
        "comment_id": "2014142320",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11790,
        "pr_file": "deps/db/src/logseq/db/sqlite/util.cljs",
        "discussion_id": "2014086284",
        "commented_code": "@@ -50,7 +50,11 @@\n                                    \"datascript/Entity\" identity)\n                             (merge read-handlers))\n         reader (transit/reader :json {:handlers read-handlers*})]\n-    (fn read-transit-str* [s] (transit/read reader s))))\n+    (fn read-transit-str* [s]\n+      (if (and (string? s) (identical? \"[\" (first s)))",
        "comment_created_at": "2025-03-26T13:25:57+00:00",
        "comment_author": "RCmerci",
        "comment_body": "yes, we can keep it for maybe 1 month. let me add a todo in comment",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1431990823",
    "pr_number": 10726,
    "pr_file": "src/main/frontend/persist_db/browser.cljs",
    "created_at": "2023-12-19T22:18:06+00:00",
    "commented_code": "(.releaseAccessHandles sqlite repo)))\n \n   (<transact-data [_this repo tx-data tx-meta]\n-    (let [^js sqlite @*sqlite]\n-      (p/let [_ (when sqlite (.transact sqlite repo (pr-str tx-data) (pr-str tx-meta)))]\n-        nil)))\n+    (let [^js sqlite @*sqlite\n+          tx-data' (pr-str tx-data)\n+          tx-meta' (pr-str tx-meta)]\n+      (p/do!\n+       (ipc/ipc :db-transact repo tx-data' tx-meta')\n+       (when sqlite (.transact sqlite repo tx-data' tx-meta'))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1431990823",
        "repo_full_name": "logseq/logseq",
        "pr_number": 10726,
        "pr_file": "src/main/frontend/persist_db/browser.cljs",
        "discussion_id": "1431990823",
        "commented_code": "@@ -77,9 +77,13 @@\n       (.releaseAccessHandles sqlite repo)))\n \n   (<transact-data [_this repo tx-data tx-meta]\n-    (let [^js sqlite @*sqlite]\n-      (p/let [_ (when sqlite (.transact sqlite repo (pr-str tx-data) (pr-str tx-meta)))]\n-        nil)))\n+    (let [^js sqlite @*sqlite\n+          tx-data' (pr-str tx-data)\n+          tx-meta' (pr-str tx-meta)]\n+      (p/do!\n+       (ipc/ipc :db-transact repo tx-data' tx-meta')\n+       (when sqlite (.transact sqlite repo tx-data' tx-meta'))",
        "comment_created_at": "2023-12-19T22:18:06+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "This isn't a change in this PR but if sqlite is missing, we should fail explicitly to the user so users are aware their data isn't being written and they could lose a lot of data silently. I can address this tomorrow if you'd like",
        "pr_file_module": null
      },
      {
        "comment_id": "1432563770",
        "repo_full_name": "logseq/logseq",
        "pr_number": 10726,
        "pr_file": "src/main/frontend/persist_db/browser.cljs",
        "discussion_id": "1431990823",
        "commented_code": "@@ -77,9 +77,13 @@\n       (.releaseAccessHandles sqlite repo)))\n \n   (<transact-data [_this repo tx-data tx-meta]\n-    (let [^js sqlite @*sqlite]\n-      (p/let [_ (when sqlite (.transact sqlite repo (pr-str tx-data) (pr-str tx-meta)))]\n-        nil)))\n+    (let [^js sqlite @*sqlite\n+          tx-data' (pr-str tx-data)\n+          tx-meta' (pr-str tx-meta)]\n+      (p/do!\n+       (ipc/ipc :db-transact repo tx-data' tx-meta')\n+       (when sqlite (.transact sqlite repo tx-data' tx-meta'))",
        "comment_created_at": "2023-12-20T10:53:38+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "Agreed! Thanks for the help!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1073899512",
    "pr_number": 8387,
    "pr_file": "deps/graph-parser/src/logseq/graph_parser/util/db.cljs",
    "created_at": "2023-01-18T18:10:12+00:00",
    "commented_code": "(parse-long\n    (string/replace (date-time-util/ymd date) \"/\" \"\")))\n \n+(defn old->new-relative-date-format [input]\n+  (let [count (re-find #\"^\\d+\" (name input))\n+        plus-minus (if (re-find #\"after\" (name input)) \"+\" \"-\")\n+        ms? (string/ends-with? (name input) \"-ms\")]\n+    (keyword :today (str plus-minus count \"d\" (if ms? \"-ms\" \"\")))))\n+\n+(comment\n+  (old->new-relative-date-format \"1d\")\n+  (old->new-relative-date-format \"1d-before\")\n+  (old->new-relative-date-format \"1d-after\")\n+  (old->new-relative-date-format \"1d-before-ms\")\n+  (old->new-relative-date-format \"1d-after-ms\")\n+  (old->new-relative-date-format \"1w-after-ms\"))\n+\n+(defn keyword-input-dispatch [input]\n+  (cond \n+    (#{:current-page :current-block :parent-block :today :yesterday :tomorrow :right-now-ms} input) input\n+    (re-find #\"^[+-]\\d+[dwmy](-ms)?$\" (name input)) :relative-date\n+    (re-find #\"^\\d+d(-before|-after|-before-ms|-after-ms)?$\" (name input)) :DEPRECATED-relative-date\n+    (= :start-of-today-ms input) :DEPRECATED-start-of-today-ms \n+    (= :end-of-today-ms input) :DEPRECATED-end-of-today-ms))\n+(defmulti resolve-keyword-input (fn [_db input _opts] (keyword-input-dispatch input))) \n+\n+(defmethod resolve-keyword-input :DEPRECATED-relative-date [db input opts]\n+  ;; This handles all of the cases covered by the following:\n+  ;; :Xd, :Xd-before, :Xd-before-ms, :Xd-after, :Xd-after-ms\n+  (resolve-keyword-input db (old->new-relative-date-format input) opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-start-of-today-ms [db _ opts]\n+  (resolve-keyword-input db :today/-0d-ms opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-end-of-today-ms [db _ opts] \n+  (resolve-keyword-input db :today/+0d-ms opts))\n+\n+(defmethod resolve-keyword-input :current-page [_ _ {:keys [current-page-fn]}]\n+  ;; TODO: handle current-page-fn not being provided\n+  (some-> (current-page-fn) string/lower-case))\n+\n+(defmethod resolve-keyword-input :current-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (d/entity db [:block/uuid current-block-uuid])))\n+\n+(defmethod resolve-keyword-input :parent-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid]))))\n+\n+(defmethod resolve-keyword-input :today [_ _ _]\n+  (date->int (t/today)))\n+\n+(defmethod resolve-keyword-input :yesterday [_ _ _]\n+  (date->int (t/minus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :tomorrow [_ _ _]\n+  (date->int (t/plus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :right-now-ms [_ _ _]\n+  (date-time-util/time-ms))\n+\n+(defmethod resolve-keyword-input :relative-date [db input opts]\n+  (let [relative-to (case (or (namespace input) \"today\")\n+                      \"today\" (t/today))\n+        [_ offset-direction offset offset-unit offset-ms?] (re-find #\"^([+-])(\\d+)([dwmy])(-ms)?$\" (name input))\n+        offset-fn (case offset-direction \"+\" t/plus \"-\" t/minus)\n+        offset-amount (parse-long offset) \n+        offset-unit-fn (case offset-unit\n+                         \"d\" t/days\n+                         \"w\" t/weeks\n+                         \"m\" t/months\n+                         \"y\" t/years)\n+        offset-hour (case offset-direction \"+\" 24 \"-\" 0)]\n+    (if offset-ms?\n+      (date-at-local-ms (offset-fn relative-to (offset-unit-fn offset-amount)) offset-hour 0 0 0)\n+      (date->int (offset-fn relative-to (offset-unit-fn offset-amount))))))\n+\n (defn resolve-input\n   \"Main fn for resolving advanced query :inputs\"\n   [db input {:keys [current-block-uuid current-page-fn]\n              :or {current-page-fn (constantly nil)}}]\n   (cond\n-    ;; page and block inputs\n-    (= :current-page input)\n-    (some-> (current-page-fn) string/lower-case)\n-    (and current-block-uuid (= :current-block input))\n-    (:db/id (d/entity db [:block/uuid current-block-uuid]))\n-    (and current-block-uuid (= :parent-block input))\n-    (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid])))\n-\n-    ;; journal date inputs\n-    (= :today input)\n-    (date->int (t/today))\n-    (= :yesterday input)\n-    (date->int (t/minus (t/today) (t/days 1)))\n-    (= :tomorrow input)\n-    (date->int (t/plus (t/today) (t/days 1)))\n-    ;; e.g. :3d-before\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-before)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/minus (t/today) (t/days days))))\n-    ;; e.g. :3d-after\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-after)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/plus (t/today) (t/days days))))\n-\n-    ;; timestamp inputs\n-    (= :right-now-ms input) (date-time-util/time-ms)\n-    (= :start-of-today-ms input) (date-at-local-ms 0 0 0 0)\n-    (= :end-of-today-ms input) (date-at-local-ms 24 0 0 0)\n-    ;; e.g. :3d-before-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-before-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/minus (t/today) (t/days days)) 0 0 0 0))\n-    ;; e.g. :3d-after-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-after-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/plus (t/today) (t/days days)) 24 0 0 0))\n-\n+    (keyword? input) \n+    (try \n+      (resolve-keyword-input db input {:current-block-uuid current-block-uuid\n+                                       :current-page-fn current-page-fn})\n+      (catch js/Error e",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1073899512",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8387,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/util/db.cljs",
        "discussion_id": "1073899512",
        "commented_code": "@@ -22,56 +22,93 @@ it will return 1622433600000, which is equivalent to Mon May 31 2021 00 :00:00.\"\n   (parse-long\n    (string/replace (date-time-util/ymd date) \"/\" \"\")))\n \n+(defn old->new-relative-date-format [input]\n+  (let [count (re-find #\"^\\d+\" (name input))\n+        plus-minus (if (re-find #\"after\" (name input)) \"+\" \"-\")\n+        ms? (string/ends-with? (name input) \"-ms\")]\n+    (keyword :today (str plus-minus count \"d\" (if ms? \"-ms\" \"\")))))\n+\n+(comment\n+  (old->new-relative-date-format \"1d\")\n+  (old->new-relative-date-format \"1d-before\")\n+  (old->new-relative-date-format \"1d-after\")\n+  (old->new-relative-date-format \"1d-before-ms\")\n+  (old->new-relative-date-format \"1d-after-ms\")\n+  (old->new-relative-date-format \"1w-after-ms\"))\n+\n+(defn keyword-input-dispatch [input]\n+  (cond \n+    (#{:current-page :current-block :parent-block :today :yesterday :tomorrow :right-now-ms} input) input\n+    (re-find #\"^[+-]\\d+[dwmy](-ms)?$\" (name input)) :relative-date\n+    (re-find #\"^\\d+d(-before|-after|-before-ms|-after-ms)?$\" (name input)) :DEPRECATED-relative-date\n+    (= :start-of-today-ms input) :DEPRECATED-start-of-today-ms \n+    (= :end-of-today-ms input) :DEPRECATED-end-of-today-ms))\n+(defmulti resolve-keyword-input (fn [_db input _opts] (keyword-input-dispatch input))) \n+\n+(defmethod resolve-keyword-input :DEPRECATED-relative-date [db input opts]\n+  ;; This handles all of the cases covered by the following:\n+  ;; :Xd, :Xd-before, :Xd-before-ms, :Xd-after, :Xd-after-ms\n+  (resolve-keyword-input db (old->new-relative-date-format input) opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-start-of-today-ms [db _ opts]\n+  (resolve-keyword-input db :today/-0d-ms opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-end-of-today-ms [db _ opts] \n+  (resolve-keyword-input db :today/+0d-ms opts))\n+\n+(defmethod resolve-keyword-input :current-page [_ _ {:keys [current-page-fn]}]\n+  ;; TODO: handle current-page-fn not being provided\n+  (some-> (current-page-fn) string/lower-case))\n+\n+(defmethod resolve-keyword-input :current-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (d/entity db [:block/uuid current-block-uuid])))\n+\n+(defmethod resolve-keyword-input :parent-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid]))))\n+\n+(defmethod resolve-keyword-input :today [_ _ _]\n+  (date->int (t/today)))\n+\n+(defmethod resolve-keyword-input :yesterday [_ _ _]\n+  (date->int (t/minus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :tomorrow [_ _ _]\n+  (date->int (t/plus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :right-now-ms [_ _ _]\n+  (date-time-util/time-ms))\n+\n+(defmethod resolve-keyword-input :relative-date [db input opts]\n+  (let [relative-to (case (or (namespace input) \"today\")\n+                      \"today\" (t/today))\n+        [_ offset-direction offset offset-unit offset-ms?] (re-find #\"^([+-])(\\d+)([dwmy])(-ms)?$\" (name input))\n+        offset-fn (case offset-direction \"+\" t/plus \"-\" t/minus)\n+        offset-amount (parse-long offset) \n+        offset-unit-fn (case offset-unit\n+                         \"d\" t/days\n+                         \"w\" t/weeks\n+                         \"m\" t/months\n+                         \"y\" t/years)\n+        offset-hour (case offset-direction \"+\" 24 \"-\" 0)]\n+    (if offset-ms?\n+      (date-at-local-ms (offset-fn relative-to (offset-unit-fn offset-amount)) offset-hour 0 0 0)\n+      (date->int (offset-fn relative-to (offset-unit-fn offset-amount))))))\n+\n (defn resolve-input\n   \"Main fn for resolving advanced query :inputs\"\n   [db input {:keys [current-block-uuid current-page-fn]\n              :or {current-page-fn (constantly nil)}}]\n   (cond\n-    ;; page and block inputs\n-    (= :current-page input)\n-    (some-> (current-page-fn) string/lower-case)\n-    (and current-block-uuid (= :current-block input))\n-    (:db/id (d/entity db [:block/uuid current-block-uuid]))\n-    (and current-block-uuid (= :parent-block input))\n-    (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid])))\n-\n-    ;; journal date inputs\n-    (= :today input)\n-    (date->int (t/today))\n-    (= :yesterday input)\n-    (date->int (t/minus (t/today) (t/days 1)))\n-    (= :tomorrow input)\n-    (date->int (t/plus (t/today) (t/days 1)))\n-    ;; e.g. :3d-before\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-before)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/minus (t/today) (t/days days))))\n-    ;; e.g. :3d-after\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-after)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/plus (t/today) (t/days days))))\n-\n-    ;; timestamp inputs\n-    (= :right-now-ms input) (date-time-util/time-ms)\n-    (= :start-of-today-ms input) (date-at-local-ms 0 0 0 0)\n-    (= :end-of-today-ms input) (date-at-local-ms 24 0 0 0)\n-    ;; e.g. :3d-before-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-before-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/minus (t/today) (t/days days)) 0 0 0 0))\n-    ;; e.g. :3d-after-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-after-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/plus (t/today) (t/days days)) 24 0 0 0))\n-\n+    (keyword? input) \n+    (try \n+      (resolve-keyword-input db input {:current-block-uuid current-block-uuid\n+                                       :current-page-fn current-page-fn})\n+      (catch js/Error e",
        "comment_created_at": "2023-01-18T18:10:12+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "A catch here has the downsides that it gives users a misleading impression that something works when it doesn't and we don't get a sentry issue if something fails. What motivated adding a catch here?",
        "pr_file_module": null
      },
      {
        "comment_id": "1080877486",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8387,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/util/db.cljs",
        "discussion_id": "1073899512",
        "commented_code": "@@ -22,56 +22,93 @@ it will return 1622433600000, which is equivalent to Mon May 31 2021 00 :00:00.\"\n   (parse-long\n    (string/replace (date-time-util/ymd date) \"/\" \"\")))\n \n+(defn old->new-relative-date-format [input]\n+  (let [count (re-find #\"^\\d+\" (name input))\n+        plus-minus (if (re-find #\"after\" (name input)) \"+\" \"-\")\n+        ms? (string/ends-with? (name input) \"-ms\")]\n+    (keyword :today (str plus-minus count \"d\" (if ms? \"-ms\" \"\")))))\n+\n+(comment\n+  (old->new-relative-date-format \"1d\")\n+  (old->new-relative-date-format \"1d-before\")\n+  (old->new-relative-date-format \"1d-after\")\n+  (old->new-relative-date-format \"1d-before-ms\")\n+  (old->new-relative-date-format \"1d-after-ms\")\n+  (old->new-relative-date-format \"1w-after-ms\"))\n+\n+(defn keyword-input-dispatch [input]\n+  (cond \n+    (#{:current-page :current-block :parent-block :today :yesterday :tomorrow :right-now-ms} input) input\n+    (re-find #\"^[+-]\\d+[dwmy](-ms)?$\" (name input)) :relative-date\n+    (re-find #\"^\\d+d(-before|-after|-before-ms|-after-ms)?$\" (name input)) :DEPRECATED-relative-date\n+    (= :start-of-today-ms input) :DEPRECATED-start-of-today-ms \n+    (= :end-of-today-ms input) :DEPRECATED-end-of-today-ms))\n+(defmulti resolve-keyword-input (fn [_db input _opts] (keyword-input-dispatch input))) \n+\n+(defmethod resolve-keyword-input :DEPRECATED-relative-date [db input opts]\n+  ;; This handles all of the cases covered by the following:\n+  ;; :Xd, :Xd-before, :Xd-before-ms, :Xd-after, :Xd-after-ms\n+  (resolve-keyword-input db (old->new-relative-date-format input) opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-start-of-today-ms [db _ opts]\n+  (resolve-keyword-input db :today/-0d-ms opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-end-of-today-ms [db _ opts] \n+  (resolve-keyword-input db :today/+0d-ms opts))\n+\n+(defmethod resolve-keyword-input :current-page [_ _ {:keys [current-page-fn]}]\n+  ;; TODO: handle current-page-fn not being provided\n+  (some-> (current-page-fn) string/lower-case))\n+\n+(defmethod resolve-keyword-input :current-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (d/entity db [:block/uuid current-block-uuid])))\n+\n+(defmethod resolve-keyword-input :parent-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid]))))\n+\n+(defmethod resolve-keyword-input :today [_ _ _]\n+  (date->int (t/today)))\n+\n+(defmethod resolve-keyword-input :yesterday [_ _ _]\n+  (date->int (t/minus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :tomorrow [_ _ _]\n+  (date->int (t/plus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :right-now-ms [_ _ _]\n+  (date-time-util/time-ms))\n+\n+(defmethod resolve-keyword-input :relative-date [db input opts]\n+  (let [relative-to (case (or (namespace input) \"today\")\n+                      \"today\" (t/today))\n+        [_ offset-direction offset offset-unit offset-ms?] (re-find #\"^([+-])(\\d+)([dwmy])(-ms)?$\" (name input))\n+        offset-fn (case offset-direction \"+\" t/plus \"-\" t/minus)\n+        offset-amount (parse-long offset) \n+        offset-unit-fn (case offset-unit\n+                         \"d\" t/days\n+                         \"w\" t/weeks\n+                         \"m\" t/months\n+                         \"y\" t/years)\n+        offset-hour (case offset-direction \"+\" 24 \"-\" 0)]\n+    (if offset-ms?\n+      (date-at-local-ms (offset-fn relative-to (offset-unit-fn offset-amount)) offset-hour 0 0 0)\n+      (date->int (offset-fn relative-to (offset-unit-fn offset-amount))))))\n+\n (defn resolve-input\n   \"Main fn for resolving advanced query :inputs\"\n   [db input {:keys [current-block-uuid current-page-fn]\n              :or {current-page-fn (constantly nil)}}]\n   (cond\n-    ;; page and block inputs\n-    (= :current-page input)\n-    (some-> (current-page-fn) string/lower-case)\n-    (and current-block-uuid (= :current-block input))\n-    (:db/id (d/entity db [:block/uuid current-block-uuid]))\n-    (and current-block-uuid (= :parent-block input))\n-    (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid])))\n-\n-    ;; journal date inputs\n-    (= :today input)\n-    (date->int (t/today))\n-    (= :yesterday input)\n-    (date->int (t/minus (t/today) (t/days 1)))\n-    (= :tomorrow input)\n-    (date->int (t/plus (t/today) (t/days 1)))\n-    ;; e.g. :3d-before\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-before)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/minus (t/today) (t/days days))))\n-    ;; e.g. :3d-after\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-after)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/plus (t/today) (t/days days))))\n-\n-    ;; timestamp inputs\n-    (= :right-now-ms input) (date-time-util/time-ms)\n-    (= :start-of-today-ms input) (date-at-local-ms 0 0 0 0)\n-    (= :end-of-today-ms input) (date-at-local-ms 24 0 0 0)\n-    ;; e.g. :3d-before-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-before-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/minus (t/today) (t/days days)) 0 0 0 0))\n-    ;; e.g. :3d-after-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-after-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/plus (t/today) (t/days days)) 24 0 0 0))\n-\n+    (keyword? input) \n+    (try \n+      (resolve-keyword-input db input {:current-block-uuid current-block-uuid\n+                                       :current-page-fn current-page-fn})\n+      (catch js/Error e",
        "comment_created_at": "2023-01-19T07:10:12+00:00",
        "comment_author": "bendyorke",
        "comment_body": "consistency was the only motivation here, but I'll add proper error handling since that's not out of scope :) ",
        "pr_file_module": null
      },
      {
        "comment_id": "1082683739",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8387,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/util/db.cljs",
        "discussion_id": "1073899512",
        "commented_code": "@@ -22,56 +22,93 @@ it will return 1622433600000, which is equivalent to Mon May 31 2021 00 :00:00.\"\n   (parse-long\n    (string/replace (date-time-util/ymd date) \"/\" \"\")))\n \n+(defn old->new-relative-date-format [input]\n+  (let [count (re-find #\"^\\d+\" (name input))\n+        plus-minus (if (re-find #\"after\" (name input)) \"+\" \"-\")\n+        ms? (string/ends-with? (name input) \"-ms\")]\n+    (keyword :today (str plus-minus count \"d\" (if ms? \"-ms\" \"\")))))\n+\n+(comment\n+  (old->new-relative-date-format \"1d\")\n+  (old->new-relative-date-format \"1d-before\")\n+  (old->new-relative-date-format \"1d-after\")\n+  (old->new-relative-date-format \"1d-before-ms\")\n+  (old->new-relative-date-format \"1d-after-ms\")\n+  (old->new-relative-date-format \"1w-after-ms\"))\n+\n+(defn keyword-input-dispatch [input]\n+  (cond \n+    (#{:current-page :current-block :parent-block :today :yesterday :tomorrow :right-now-ms} input) input\n+    (re-find #\"^[+-]\\d+[dwmy](-ms)?$\" (name input)) :relative-date\n+    (re-find #\"^\\d+d(-before|-after|-before-ms|-after-ms)?$\" (name input)) :DEPRECATED-relative-date\n+    (= :start-of-today-ms input) :DEPRECATED-start-of-today-ms \n+    (= :end-of-today-ms input) :DEPRECATED-end-of-today-ms))\n+(defmulti resolve-keyword-input (fn [_db input _opts] (keyword-input-dispatch input))) \n+\n+(defmethod resolve-keyword-input :DEPRECATED-relative-date [db input opts]\n+  ;; This handles all of the cases covered by the following:\n+  ;; :Xd, :Xd-before, :Xd-before-ms, :Xd-after, :Xd-after-ms\n+  (resolve-keyword-input db (old->new-relative-date-format input) opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-start-of-today-ms [db _ opts]\n+  (resolve-keyword-input db :today/-0d-ms opts))\n+\n+(defmethod resolve-keyword-input :DEPRECATED-end-of-today-ms [db _ opts] \n+  (resolve-keyword-input db :today/+0d-ms opts))\n+\n+(defmethod resolve-keyword-input :current-page [_ _ {:keys [current-page-fn]}]\n+  ;; TODO: handle current-page-fn not being provided\n+  (some-> (current-page-fn) string/lower-case))\n+\n+(defmethod resolve-keyword-input :current-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (d/entity db [:block/uuid current-block-uuid])))\n+\n+(defmethod resolve-keyword-input :parent-block [db _ {:keys [current-block-uuid]}]\n+  ;; TODO: handle current-block-uuid not being provided\n+  (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid]))))\n+\n+(defmethod resolve-keyword-input :today [_ _ _]\n+  (date->int (t/today)))\n+\n+(defmethod resolve-keyword-input :yesterday [_ _ _]\n+  (date->int (t/minus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :tomorrow [_ _ _]\n+  (date->int (t/plus (t/today) (t/days 1))))\n+\n+(defmethod resolve-keyword-input :right-now-ms [_ _ _]\n+  (date-time-util/time-ms))\n+\n+(defmethod resolve-keyword-input :relative-date [db input opts]\n+  (let [relative-to (case (or (namespace input) \"today\")\n+                      \"today\" (t/today))\n+        [_ offset-direction offset offset-unit offset-ms?] (re-find #\"^([+-])(\\d+)([dwmy])(-ms)?$\" (name input))\n+        offset-fn (case offset-direction \"+\" t/plus \"-\" t/minus)\n+        offset-amount (parse-long offset) \n+        offset-unit-fn (case offset-unit\n+                         \"d\" t/days\n+                         \"w\" t/weeks\n+                         \"m\" t/months\n+                         \"y\" t/years)\n+        offset-hour (case offset-direction \"+\" 24 \"-\" 0)]\n+    (if offset-ms?\n+      (date-at-local-ms (offset-fn relative-to (offset-unit-fn offset-amount)) offset-hour 0 0 0)\n+      (date->int (offset-fn relative-to (offset-unit-fn offset-amount))))))\n+\n (defn resolve-input\n   \"Main fn for resolving advanced query :inputs\"\n   [db input {:keys [current-block-uuid current-page-fn]\n              :or {current-page-fn (constantly nil)}}]\n   (cond\n-    ;; page and block inputs\n-    (= :current-page input)\n-    (some-> (current-page-fn) string/lower-case)\n-    (and current-block-uuid (= :current-block input))\n-    (:db/id (d/entity db [:block/uuid current-block-uuid]))\n-    (and current-block-uuid (= :parent-block input))\n-    (:db/id (:block/parent (d/entity db [:block/uuid current-block-uuid])))\n-\n-    ;; journal date inputs\n-    (= :today input)\n-    (date->int (t/today))\n-    (= :yesterday input)\n-    (date->int (t/minus (t/today) (t/days 1)))\n-    (= :tomorrow input)\n-    (date->int (t/plus (t/today) (t/days 1)))\n-    ;; e.g. :3d-before\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-before)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/minus (t/today) (t/days days))))\n-    ;; e.g. :3d-after\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d(-after)?$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date->int (t/plus (t/today) (t/days days))))\n-\n-    ;; timestamp inputs\n-    (= :right-now-ms input) (date-time-util/time-ms)\n-    (= :start-of-today-ms input) (date-at-local-ms 0 0 0 0)\n-    (= :end-of-today-ms input) (date-at-local-ms 24 0 0 0)\n-    ;; e.g. :3d-before-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-before-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/minus (t/today) (t/days days)) 0 0 0 0))\n-    ;; e.g. :3d-after-ms\n-    (and (keyword? input)\n-         (re-find #\"^\\d+d-after-ms$\" (name input)))\n-    (let [input (name input)\n-          days (parse-long (re-find #\"^\\d+\" input))]\n-      (date-at-local-ms (t/plus (t/today) (t/days days)) 24 0 0 0))\n-\n+    (keyword? input) \n+    (try \n+      (resolve-keyword-input db input {:current-block-uuid current-block-uuid\n+                                       :current-page-fn current-page-fn})\n+      (catch js/Error e",
        "comment_created_at": "2023-01-20T15:13:43+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "Thanks for addressing",
        "pr_file_module": null
      }
    ]
  }
]