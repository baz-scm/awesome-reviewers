[
  {
    "discussion_id": "2151636304",
    "pr_number": 11948,
    "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
    "created_at": "2025-06-17T08:19:42+00:00",
    "commented_code": "(defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "2151636304",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T08:19:42+00:00",
        "comment_author": "RCmerci",
        "comment_body": "I don't understand why we check a small amount of data every 100 steps here",
        "pr_file_module": null
      },
      {
        "comment_id": "2151703669",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T08:50:07+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "I guess it's to detect failure earlier? I also don't think it's the right place to detect cycle parent,",
        "pr_file_module": null
      },
      {
        "comment_id": "2151728959",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T09:01:15+00:00",
        "comment_author": "RCmerci",
        "comment_body": "point of my confusion is that this check seems to examine only 1% of the data, ignoring 99%, and moreover, it never takes effect for cases with less than 100 steps?",
        "pr_file_module": null
      },
      {
        "comment_id": "2151739956",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T09:06:16+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "Yes, it doesn't work for less than 100 steps, but It does test all the data because all the visited children have been added to `seen`. How about removing the check here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2151749598",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T09:10:32+00:00",
        "comment_author": "RCmerci",
        "comment_body": "> but It does test all the data because all the visited children have been added to seen\r\n\r\nbut it only tested `uuids-to-add` of a certain loop...\r\n\r\nI agree to remove it",
        "pr_file_module": null
      },
      {
        "comment_id": "2151758042",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11948,
        "pr_file": "deps/db/src/logseq/db/common/initial_data.cljs",
        "discussion_id": "2151636304",
        "commented_code": "@@ -132,27 +128,35 @@\n \n (defn get-block-children-ids\n   \"Returns children UUIDs\"\n-  [db block-uuid]\n+  [db block-uuid & {:keys [include-collapsed-children?]\n+                    :or {include-collapsed-children? true}}]\n   (when-let [eid (:db/id (d/entity db [:block/uuid block-uuid]))]\n-    (let [seen   (volatile! [])]\n+    (let [seen (volatile! #{})]\n       (loop [steps          100      ;check result every 100 steps\n              eids-to-expand [eid]]\n         (when (seq eids-to-expand)\n-          (let [eids-to-expand*\n-                (mapcat (fn [eid] (map first (d/datoms db :avet :block/parent eid))) eids-to-expand)\n-                uuids-to-add (remove nil? (map #(:block/uuid (d/entity db %)) eids-to-expand*))]\n+          (let [children\n+                (mapcat (fn [eid]\n+                          (let [e (d/entity db eid)]\n+                            (when (or include-collapsed-children?\n+                                      (not (:block/collapsed? e))\n+                                      (common-entity-util/page? e))\n+\n+                              (:block/_parent e)))) eids-to-expand)\n+                uuids-to-add (keep :block/uuid children)]\n             (when (and (zero? steps)\n                        (seq (set/intersection (set @seen) (set uuids-to-add))))",
        "comment_created_at": "2025-06-17T09:14:12+00:00",
        "comment_author": "tiensonqin",
        "comment_body": "[Removed](https://github.com/logseq/logseq/commit/8dfec94266f191eff1e01ff3ce55ae8940f360ca).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1899125415",
    "pr_number": 11654,
    "pr_file": "src/main/frontend/db/async.cljs",
    "created_at": "2024-12-29T12:49:46+00:00",
    "commented_code": "(let [future-days (state/get-scheduled-future-days)\n           date-format (tf/formatter \"yyyyMMdd\")\n           current-day (tf/parse date-format (str date))\n-          future-day (some->> (t/plus current-day (t/days future-days))\n+          future-date (t/plus current-day (t/days future-days))\n+          future-day (some->> future-date\n                               (tf/unparse date-format)\n-                              (parse-long))]\n+                              (parse-long))\n+          start-time (date/journal-day->ts date)\n+          future-time (tc/to-long future-date)]\n       (when-let [repo (and future-day (state/get-current-repo))]\n         (p/let [result\n                 (if (config/db-based-graph? repo)\n                   (<q repo {}\n                       '[:find [(pull ?block ?block-attrs) ...]\n-                        :in $ ?day ?future ?block-attrs\n+                        :in $ ?start-time ?end-time ?block-attrs\n                         :where\n-                        [?block :logseq.task/deadline ?deadline]\n-                        [?deadline :block/journal-day ?d]\n+                        (or [?block :logseq.task/scheduled ?n]\n+                            [?block :logseq.task/deadline ?n])\n                         [?block :logseq.task/status ?status]\n                         [?status :db/ident ?status-ident]\n                         [(not= ?status-ident :logseq.task/status.done)]\n                         [(not= ?status-ident :logseq.task/status.canceled)]\n-                        [(<= ?d ?future)]\n-                        [(>= ?d ?day)]]\n-                      date\n-                      future-day\n+                        [(>= ?n ?start-time)]",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1899125415",
        "repo_full_name": "logseq/logseq",
        "pr_number": 11654,
        "pr_file": "src/main/frontend/db/async.cljs",
        "discussion_id": "1899125415",
        "commented_code": "@@ -229,26 +230,29 @@\n     (let [future-days (state/get-scheduled-future-days)\n           date-format (tf/formatter \"yyyyMMdd\")\n           current-day (tf/parse date-format (str date))\n-          future-day (some->> (t/plus current-day (t/days future-days))\n+          future-date (t/plus current-day (t/days future-days))\n+          future-day (some->> future-date\n                               (tf/unparse date-format)\n-                              (parse-long))]\n+                              (parse-long))\n+          start-time (date/journal-day->ts date)\n+          future-time (tc/to-long future-date)]\n       (when-let [repo (and future-day (state/get-current-repo))]\n         (p/let [result\n                 (if (config/db-based-graph? repo)\n                   (<q repo {}\n                       '[:find [(pull ?block ?block-attrs) ...]\n-                        :in $ ?day ?future ?block-attrs\n+                        :in $ ?start-time ?end-time ?block-attrs\n                         :where\n-                        [?block :logseq.task/deadline ?deadline]\n-                        [?deadline :block/journal-day ?d]\n+                        (or [?block :logseq.task/scheduled ?n]\n+                            [?block :logseq.task/deadline ?n])\n                         [?block :logseq.task/status ?status]\n                         [?status :db/ident ?status-ident]\n                         [(not= ?status-ident :logseq.task/status.done)]\n                         [(not= ?status-ident :logseq.task/status.canceled)]\n-                        [(<= ?d ?future)]\n-                        [(>= ?d ?day)]]\n-                      date\n-                      future-day\n+                        [(>= ?n ?start-time)]",
        "comment_created_at": "2024-12-29T12:49:46+00:00",
        "comment_author": "RCmerci",
        "comment_body": "it's better to execute these 2 clauses earlier, like this:\r\n```\r\n(or [?block :logseq.task/scheduled ?n]\r\n      [?block :logseq.task/deadline ?n])\r\n[(>= ?n ?start-time)]\r\n[(<= ?n ?end-time)]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1115044832",
    "pr_number": 8695,
    "pr_file": "deps/graph-parser/src/logseq/graph_parser/block.cljs",
    "created_at": "2023-02-22T22:33:33+00:00",
    "commented_code": "(remove string/blank?)\n          distinct)))\n \n+(defn- extract-block-refs\n+  [nodes]\n+  (let [ref-blocks (atom nil)]\n+    (walk/postwalk",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1115044832",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8695,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/block.cljs",
        "discussion_id": "1115044832",
        "commented_code": "@@ -181,6 +181,20 @@\n          (remove string/blank?)\n          distinct)))\n \n+(defn- extract-block-refs\n+  [nodes]\n+  (let [ref-blocks (atom nil)]\n+    (walk/postwalk",
        "comment_created_at": "2023-02-22T22:33:33+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "For perf reasons I wish we weren't using postwalk but without a good understanding of every ast node combination, this is what we have to do",
        "pr_file_module": null
      },
      {
        "comment_id": "1116576897",
        "repo_full_name": "logseq/logseq",
        "pr_number": 8695,
        "pr_file": "deps/graph-parser/src/logseq/graph_parser/block.cljs",
        "discussion_id": "1115044832",
        "commented_code": "@@ -181,6 +181,20 @@\n          (remove string/blank?)\n          distinct)))\n \n+(defn- extract-block-refs\n+  [nodes]\n+  (let [ref-blocks (atom nil)]\n+    (walk/postwalk",
        "comment_created_at": "2023-02-24T07:05:31+00:00",
        "comment_author": "RCmerci",
        "comment_body": "I plan to add the ast malli schema later. \r\nwe can leave this 'walk' for now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1022517950",
    "pr_number": 7333,
    "pr_file": "deps/db/src/logseq/db/rules.cljc",
    "created_at": "2022-11-15T09:05:07+00:00",
    "commented_code": "\"Datalog rules for use with logseq.db.schema\")\n \n (def ^:large-vars/data-var rules\n+  \"Rules used mainly in frontend.db.model\"\n   ;; rule \"parent\" is optimized for parent node -> child node nesting queries\n-  '[[(parent ?p ?c)\n-     [?c :block/parent ?p]]\n-    [(parent ?p ?c)\n-     [?c :block/parent ?t]\n-     (parent ?p ?t)]\n-\n-  ;; rule \"child\" is optimized for child node -> parent node nesting queries\n-    [(child ?p ?c)\n-     [?c :block/parent ?p]]\n-    [(child ?p ?c)\n-     [?t :block/parent ?p]\n-     (child ?t ?c)]\n-\n-  ;; rule \"namespace\" is optimized for child node -> node of upper namespace level nesting queries\n-    [(namespace ?p ?c)\n-     [?c :block/namespace ?p]]\n-    [(namespace ?p ?c)\n-     [?t :block/namespace ?p]\n-     (namespace ?t ?c)]\n-\n-    ;; Select rules carefully, as it is critical for performance.\n-    ;; The rules have different clause order and resolving directions.\n-    ;; Clause order Reference:\n-    ;; https://docs.datomic.com/on-prem/query/query-executing.html#clause-order\n-    ;; Recursive optimization Reference:\n-    ;; https://stackoverflow.com/questions/42457136/recursive-datalog-queries-for-datomic-really-slow\n-    ;; Should optimize for query the decendents of a block\n-    ;; Quote:\n-    ;; My theory is that your rules are not written in a way that Datalog can optimize for this read pattern - probably resulting in a traversal of all the entities. I suggest to rewrite them as follows:\n-    ;; [[(ubersymbol ?c ?p)\n-    ;;   (?c :ml/parent ?p)]\n-    ;;  [(ubersymbol ?c ?p)\n-    ;;   ;; we bind a child of the ancestor, instead of a parent of the descendant\n-    ;;   (?c1 :ml/parent ?p)\n-    ;;   (ubersymbol ?c ?c1)]]\n-\n-    ;; This way of writing the ruleset is optimized to find the descendants of some node. The way you originally wrote it is optimized to find the anscestors of some node.\n-\n-    ;; from https://stackoverflow.com/questions/43784258/find-entities-whose-ref-to-many-attribute-contains-all-elements-of-input\n-    ;; Quote:\n-    ;; You're tackling the general problem of 'dynamic conjunction' in Datomic's Datalog.\n-    ;; Write a dynamic Datalog query which uses 2 negations and 1 disjunction or a recursive rule\n-    ;; Datalog has no direct way of expressing dynamic conjunction (logical AND / 'for all ...' / set intersection).\n-    ;; However, you can achieve it in pure Datalog by combining one disjunction\n-    ;; (logical OR / 'exists ...' / set union) and two negations, i.e\n-    ;; (For all ?g in ?Gs p(?e,?g)) <=> NOT(Exists ?g in ?Gs, such that NOT(p(?e, ?g)))\n-\n-    ;; [(matches-all ?e ?a ?vs)\n-    ;;  [(first ?vs) ?v0]\n-    ;;  [?e ?a ?v0]\n-    ;;  (not-join [?e ?vs]\n-    ;;            [(identity ?vs) [?v ...]]\n-    ;;            (not-join [?e ?v]\n-    ;;                      [?e ?a ?v]))]\n-    ])\n+  {:namespace\n+   '[[(namespace ?p ?c)\n+      [?c :block/namespace ?p]]\n+     [(namespace ?p ?c)\n+      [?t :block/namespace ?p]\n+      (namespace ?t ?c)]]\n+\n+   :alias\n+   '[[(alias ?e2 ?e1)\n+      [?e2 :block/alias ?e1]]\n+     [(alias ?e2 ?e1)\n+      [?e1 :block/alias ?e2]]\n+     [(alias ?e1 ?e3)",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "1022517950",
        "repo_full_name": "logseq/logseq",
        "pr_number": 7333,
        "pr_file": "deps/db/src/logseq/db/rules.cljc",
        "discussion_id": "1022517950",
        "commented_code": "@@ -2,62 +2,63 @@\n   \"Datalog rules for use with logseq.db.schema\")\n \n (def ^:large-vars/data-var rules\n+  \"Rules used mainly in frontend.db.model\"\n   ;; rule \"parent\" is optimized for parent node -> child node nesting queries\n-  '[[(parent ?p ?c)\n-     [?c :block/parent ?p]]\n-    [(parent ?p ?c)\n-     [?c :block/parent ?t]\n-     (parent ?p ?t)]\n-\n-  ;; rule \"child\" is optimized for child node -> parent node nesting queries\n-    [(child ?p ?c)\n-     [?c :block/parent ?p]]\n-    [(child ?p ?c)\n-     [?t :block/parent ?p]\n-     (child ?t ?c)]\n-\n-  ;; rule \"namespace\" is optimized for child node -> node of upper namespace level nesting queries\n-    [(namespace ?p ?c)\n-     [?c :block/namespace ?p]]\n-    [(namespace ?p ?c)\n-     [?t :block/namespace ?p]\n-     (namespace ?t ?c)]\n-\n-    ;; Select rules carefully, as it is critical for performance.\n-    ;; The rules have different clause order and resolving directions.\n-    ;; Clause order Reference:\n-    ;; https://docs.datomic.com/on-prem/query/query-executing.html#clause-order\n-    ;; Recursive optimization Reference:\n-    ;; https://stackoverflow.com/questions/42457136/recursive-datalog-queries-for-datomic-really-slow\n-    ;; Should optimize for query the decendents of a block\n-    ;; Quote:\n-    ;; My theory is that your rules are not written in a way that Datalog can optimize for this read pattern - probably resulting in a traversal of all the entities. I suggest to rewrite them as follows:\n-    ;; [[(ubersymbol ?c ?p)\n-    ;;   (?c :ml/parent ?p)]\n-    ;;  [(ubersymbol ?c ?p)\n-    ;;   ;; we bind a child of the ancestor, instead of a parent of the descendant\n-    ;;   (?c1 :ml/parent ?p)\n-    ;;   (ubersymbol ?c ?c1)]]\n-\n-    ;; This way of writing the ruleset is optimized to find the descendants of some node. The way you originally wrote it is optimized to find the anscestors of some node.\n-\n-    ;; from https://stackoverflow.com/questions/43784258/find-entities-whose-ref-to-many-attribute-contains-all-elements-of-input\n-    ;; Quote:\n-    ;; You're tackling the general problem of 'dynamic conjunction' in Datomic's Datalog.\n-    ;; Write a dynamic Datalog query which uses 2 negations and 1 disjunction or a recursive rule\n-    ;; Datalog has no direct way of expressing dynamic conjunction (logical AND / 'for all ...' / set intersection).\n-    ;; However, you can achieve it in pure Datalog by combining one disjunction\n-    ;; (logical OR / 'exists ...' / set union) and two negations, i.e\n-    ;; (For all ?g in ?Gs p(?e,?g)) <=> NOT(Exists ?g in ?Gs, such that NOT(p(?e, ?g)))\n-\n-    ;; [(matches-all ?e ?a ?vs)\n-    ;;  [(first ?vs) ?v0]\n-    ;;  [?e ?a ?v0]\n-    ;;  (not-join [?e ?vs]\n-    ;;            [(identity ?vs) [?v ...]]\n-    ;;            (not-join [?e ?v]\n-    ;;                      [?e ?a ?v]))]\n-    ])\n+  {:namespace\n+   '[[(namespace ?p ?c)\n+      [?c :block/namespace ?p]]\n+     [(namespace ?p ?c)\n+      [?t :block/namespace ?p]\n+      (namespace ?t ?c)]]\n+\n+   :alias\n+   '[[(alias ?e2 ?e1)\n+      [?e2 :block/alias ?e1]]\n+     [(alias ?e2 ?e1)\n+      [?e1 :block/alias ?e2]]\n+     [(alias ?e1 ?e3)",
        "comment_created_at": "2022-11-15T09:05:07+00:00",
        "comment_author": "andrewzhurov",
        "comment_body": "There can be an alias for an alias?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "951878138",
    "pr_number": 6134,
    "pr_file": "src/test/frontend/db/name_sanity_test.cljs",
    "created_at": "2022-08-22T20:23:17+00:00",
    "commented_code": "+(ns frontend.db.name-sanity-test\n+  (:require [cljs.test :refer [deftest testing is use-fixtures]]\n+            [clojure.string :as string]\n+            [logseq.graph-parser.util :as gp-util]\n+            [frontend.handler.page :as page-handler]\n+            [frontend.handler.conversion :as conversion-handler]\n+            [frontend.util.fs :as fs-util]\n+            [frontend.test.fixtures :as fixtures]))\n+\n+(use-fixtures :each fixtures/reset-db)\n+\n+(def all-reserved-chars fs-util/multiplatform-reserved-chars)\n+\n+(defn- test-page-name\n+  \"Check if page name can be preserved after \"\n+  [page-name]\n+  (testing (str \"Test sanitization page-name: \" page-name)\n+    (let [file-name   (fs-util/file-name-sanity page-name)\n+          page-name'  (gp-util/title-parsing file-name)\n+          url-single  (js/encodeURIComponent file-name)\n+          url-double  (js/encodeURIComponent url-single)\n+          file-name'  (js/decodeURIComponent url-single)\n+          file-name'' ( js/decodeURIComponent (js/decodeURIComponent url-double))]\n+      (is (= page-name page-name'))\n+      (is (not (fs-util/include-reserved-chars? file-name)))\n+      (is (not (contains? fs-util/windows-reserved-filebodies file-name)))\n+      (is (not (string/ends-with? file-name \".\")))\n+      (is (= file-name' file-name))\n+      (is (= file-name'' file-name)))))\n+\n+(deftest page-name-sanitization-tests\n+  (test-page-name \"Some.Content!\")\n+  (test-page-name \"More _/_ Con tents\")\n+  (test-page-name \"More _________/________ Con tents\")\n+  (test-page-name \"More _________/___-_-_-_---___----__/_ Con tents\")\n+  (test-page-name \"Cont./__cont_ cont/ lsdksdf\")\n+  (test-page-name \"Cont.?/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"Cont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"__ont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"______ont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"__ont.?__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"+*++***+++__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"+*++_.x2A_.x2A***+++__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte/#__0xbbcont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte/#_&amp;ont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte&lowbar;/#_&amp;ont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"dsa&amp&semi;l dsalfjk jkl\")\n+  (test-page-name \"dsa&amp&semi;l dsalfjk jkl.\")\n+  (test-page-name \"CON.\")\n+  (map test-page-name fs-util/windows-reserved-filebodies))",
    "repo_full_name": "logseq/logseq",
    "discussion_comments": [
      {
        "comment_id": "951878138",
        "repo_full_name": "logseq/logseq",
        "pr_number": 6134,
        "pr_file": "src/test/frontend/db/name_sanity_test.cljs",
        "discussion_id": "951878138",
        "commented_code": "@@ -0,0 +1,125 @@\n+(ns frontend.db.name-sanity-test\n+  (:require [cljs.test :refer [deftest testing is use-fixtures]]\n+            [clojure.string :as string]\n+            [logseq.graph-parser.util :as gp-util]\n+            [frontend.handler.page :as page-handler]\n+            [frontend.handler.conversion :as conversion-handler]\n+            [frontend.util.fs :as fs-util]\n+            [frontend.test.fixtures :as fixtures]))\n+\n+(use-fixtures :each fixtures/reset-db)\n+\n+(def all-reserved-chars fs-util/multiplatform-reserved-chars)\n+\n+(defn- test-page-name\n+  \"Check if page name can be preserved after \"\n+  [page-name]\n+  (testing (str \"Test sanitization page-name: \" page-name)\n+    (let [file-name   (fs-util/file-name-sanity page-name)\n+          page-name'  (gp-util/title-parsing file-name)\n+          url-single  (js/encodeURIComponent file-name)\n+          url-double  (js/encodeURIComponent url-single)\n+          file-name'  (js/decodeURIComponent url-single)\n+          file-name'' ( js/decodeURIComponent (js/decodeURIComponent url-double))]\n+      (is (= page-name page-name'))\n+      (is (not (fs-util/include-reserved-chars? file-name)))\n+      (is (not (contains? fs-util/windows-reserved-filebodies file-name)))\n+      (is (not (string/ends-with? file-name \".\")))\n+      (is (= file-name' file-name))\n+      (is (= file-name'' file-name)))))\n+\n+(deftest page-name-sanitization-tests\n+  (test-page-name \"Some.Content!\")\n+  (test-page-name \"More _/_ Con tents\")\n+  (test-page-name \"More _________/________ Con tents\")\n+  (test-page-name \"More _________/___-_-_-_---___----__/_ Con tents\")\n+  (test-page-name \"Cont./__cont_ cont/ lsdksdf\")\n+  (test-page-name \"Cont.?/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"Cont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"__ont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"______ont.?__byte/#__cont_ cont%/_ lsdksdf\")\n+  (test-page-name \"__ont.?__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"+*++***+++__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"+*++_.x2A_.x2A***+++__byte/#__cont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte/#__0xbbcont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte/#_&amp;ont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"__ont.?__byte&lowbar;/#_&amp;ont_ cont%/_ lsdksdf__\")\n+  (test-page-name \"dsa&amp&semi;l dsalfjk jkl\")\n+  (test-page-name \"dsa&amp&semi;l dsalfjk jkl.\")\n+  (test-page-name \"CON.\")\n+  (map test-page-name fs-util/windows-reserved-filebodies))",
        "comment_created_at": "2022-08-22T20:23:17+00:00",
        "comment_author": "logseq-cldwalker",
        "comment_body": "`map` is lazy so this isn't being run. Would recommend `mapv` or `doseq`",
        "pr_file_module": null
      }
    ]
  }
]