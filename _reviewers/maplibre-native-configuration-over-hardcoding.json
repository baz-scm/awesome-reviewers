[
  {
    "discussion_id": "1273616345",
    "pr_number": 1289,
    "pr_file": "src/mbgl/util/i18n.cpp",
    "created_at": "2023-07-25T14:14:46+00:00",
    "commented_code": "} // namespace i18n\n } // namespace util\n+\n+GlyphIDType charGlyphIDType(char16_t ch, GlyphIDType lastChType) {\n+    if (u'\\uFE00' == ch) {\n+        return lastChType;\n+    }\n+\n+    if (isInKhmer(ch)) return GlyphIDType::Khmer;\n+    if (isInMyanmar(ch) || isInMyanmarExtendedA(ch) || isInMyanmarExtendedB(ch)) return GlyphIDType::Myanmar;\n+    if (isInDevanagari(ch) || isInDevanagariExtended(ch)) return GlyphIDType::Devanagari;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1273616345",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1289,
        "pr_file": "src/mbgl/util/i18n.cpp",
        "discussion_id": "1273616345",
        "commented_code": "@@ -627,4 +628,17 @@ bool isWhitespace(char16_t chr) {\n \n } // namespace i18n\n } // namespace util\n+\n+GlyphIDType charGlyphIDType(char16_t ch, GlyphIDType lastChType) {\n+    if (u'\\uFE00' == ch) {\n+        return lastChType;\n+    }\n+\n+    if (isInKhmer(ch)) return GlyphIDType::Khmer;\n+    if (isInMyanmar(ch) || isInMyanmarExtendedA(ch) || isInMyanmarExtendedB(ch)) return GlyphIDType::Myanmar;\n+    if (isInDevanagari(ch) || isInDevanagariExtended(ch)) return GlyphIDType::Devanagari;",
        "comment_created_at": "2023-07-25T14:14:46+00:00",
        "comment_author": "wipfli",
        "comment_body": "Here the mapping from unicode range to font file is hard coded. For every new language we would need to add an entry.\r\n\r\nWould it make more sense to specify in the font definition what unicode range it covers:\r\n\r\nSo instead of \r\n\r\n```json\r\n\"fonts\": \"https://alanchenboy.github.io/harfbuzzResource/fonts/{fontstack}/{language}.ttf\"\r\n```\r\n\r\nwe could do this:\r\n\r\n```json\r\n\"fonts\": [\r\n  {\r\n    \"name\": \"devanagari\",\r\n    \"url\": \"https://example.com/path-to-font-file.ttf\"\r\n    \"unicode-range\": \"U+4??\"\r\n  }\r\n]\r\n```\r\n\r\nthe unicode-range would use the same definition as the CSS specification https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range",
        "pr_file_module": null
      },
      {
        "comment_id": "1277376748",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1289,
        "pr_file": "src/mbgl/util/i18n.cpp",
        "discussion_id": "1273616345",
        "commented_code": "@@ -627,4 +628,17 @@ bool isWhitespace(char16_t chr) {\n \n } // namespace i18n\n } // namespace util\n+\n+GlyphIDType charGlyphIDType(char16_t ch, GlyphIDType lastChType) {\n+    if (u'\\uFE00' == ch) {\n+        return lastChType;\n+    }\n+\n+    if (isInKhmer(ch)) return GlyphIDType::Khmer;\n+    if (isInMyanmar(ch) || isInMyanmarExtendedA(ch) || isInMyanmarExtendedB(ch)) return GlyphIDType::Myanmar;\n+    if (isInDevanagari(ch) || isInDevanagariExtended(ch)) return GlyphIDType::Devanagari;",
        "comment_created_at": "2023-07-28T10:22:23+00:00",
        "comment_author": "alanchenboy",
        "comment_body": "This means we leave the code range setting to the style, hmm, does this necessary? cause only a few languages need shaping the entries won't be that many. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2155657033",
    "pr_number": 3570,
    "pr_file": "src/mbgl/style/sources/tile_source.cpp",
    "created_at": "2025-06-18T22:47:56+00:00",
    "commented_code": "+#include <mbgl/storage/file_source.hpp>\n+#include <mbgl/style/conversion/json.hpp>\n+#include <mbgl/style/conversion/tileset.hpp>\n+#include <mbgl/style/layer.hpp>\n+#include <mbgl/style/source_observer.hpp>\n+#include <mbgl/style/sources/tile_source.hpp>\n+#include <mbgl/style/sources/tile_source_impl.hpp>\n+#include <mbgl/tile/tile.hpp>\n+#include <mbgl/util/async_request.hpp>\n+#include <mbgl/util/exception.hpp>\n+#include <mbgl/util/mapbox.hpp>\n+\n+namespace mbgl {\n+namespace style {\n+\n+TileSource::TileSource(std::string id,\n+                           variant<std::string, Tileset> urlOrTileset_,\n+                           uint16_t tileSize,\n+                           SourceType sourceType)\n+    : Source(makeMutable<Impl>(sourceType, std::move(id), tileSize)),\n+      urlOrTileset(std::move(urlOrTileset_)) {}\n+\n+TileSource::~TileSource() = default;\n+\n+const TileSource::Impl& TileSource::impl() const {\n+    return static_cast<const Impl&>(*baseImpl);\n+}\n+\n+const variant<std::string, Tileset>& TileSource::getURLOrTileset() const {\n+    return urlOrTileset;\n+}\n+\n+std::optional<std::string> TileSource::getURL() const {\n+    if (urlOrTileset.is<Tileset>()) {\n+        return {};\n+    }\n+\n+    return urlOrTileset.get<std::string>();\n+}\n+\n+uint16_t TileSource::getTileSize() const {\n+    return impl().getTileSize();\n+}\n+\n+void TileSource::loadDescription(FileSource& fileSource) {\n+    if (urlOrTileset.is<Tileset>()) {\n+        baseImpl = makeMutable<Impl>(impl(), urlOrTileset.get<Tileset>());\n+        loaded = true;\n+        observer->onSourceLoaded(*this);\n+        return;\n+    }\n+\n+    if (req) {\n+        return;\n+    }\n+\n+    const auto& rawURL = urlOrTileset.get<std::string>();\n+    const auto& url = util::mapbox::canonicalizeSourceURL(fileSource.getResourceOptions().tileServerOptions(), rawURL);\n+\n+    req = fileSource.request(Resource::source(url), [this, url, &fileSource](const Response& res) {\n+        if (res.error) {\n+            observer->onSourceError(*this, std::make_exception_ptr(std::runtime_error(res.error->message)));\n+        } else if (res.notModified) {\n+            return;\n+        } else if (res.noContent) {\n+            observer->onSourceError(*this, std::make_exception_ptr(std::runtime_error(\"unexpectedly empty TileJSON\")));\n+        } else {\n+            conversion::Error error;\n+            std::optional<Tileset> tileset = conversion::convertJSON<Tileset>(*res.data, error);\n+            if (!tileset) {\n+                observer->onSourceError(*this, std::make_exception_ptr(util::StyleParseException(error.message)));\n+                return;\n+            }\n+            const auto& tileServerOptions = fileSource.getResourceOptions().tileServerOptions();\n+            if (tileServerOptions.uriSchemeAlias() == \"mapbox\") {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2155657033",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3570,
        "pr_file": "src/mbgl/style/sources/tile_source.cpp",
        "discussion_id": "2155657033",
        "commented_code": "@@ -0,0 +1,108 @@\n+#include <mbgl/storage/file_source.hpp>\n+#include <mbgl/style/conversion/json.hpp>\n+#include <mbgl/style/conversion/tileset.hpp>\n+#include <mbgl/style/layer.hpp>\n+#include <mbgl/style/source_observer.hpp>\n+#include <mbgl/style/sources/tile_source.hpp>\n+#include <mbgl/style/sources/tile_source_impl.hpp>\n+#include <mbgl/tile/tile.hpp>\n+#include <mbgl/util/async_request.hpp>\n+#include <mbgl/util/exception.hpp>\n+#include <mbgl/util/mapbox.hpp>\n+\n+namespace mbgl {\n+namespace style {\n+\n+TileSource::TileSource(std::string id,\n+                           variant<std::string, Tileset> urlOrTileset_,\n+                           uint16_t tileSize,\n+                           SourceType sourceType)\n+    : Source(makeMutable<Impl>(sourceType, std::move(id), tileSize)),\n+      urlOrTileset(std::move(urlOrTileset_)) {}\n+\n+TileSource::~TileSource() = default;\n+\n+const TileSource::Impl& TileSource::impl() const {\n+    return static_cast<const Impl&>(*baseImpl);\n+}\n+\n+const variant<std::string, Tileset>& TileSource::getURLOrTileset() const {\n+    return urlOrTileset;\n+}\n+\n+std::optional<std::string> TileSource::getURL() const {\n+    if (urlOrTileset.is<Tileset>()) {\n+        return {};\n+    }\n+\n+    return urlOrTileset.get<std::string>();\n+}\n+\n+uint16_t TileSource::getTileSize() const {\n+    return impl().getTileSize();\n+}\n+\n+void TileSource::loadDescription(FileSource& fileSource) {\n+    if (urlOrTileset.is<Tileset>()) {\n+        baseImpl = makeMutable<Impl>(impl(), urlOrTileset.get<Tileset>());\n+        loaded = true;\n+        observer->onSourceLoaded(*this);\n+        return;\n+    }\n+\n+    if (req) {\n+        return;\n+    }\n+\n+    const auto& rawURL = urlOrTileset.get<std::string>();\n+    const auto& url = util::mapbox::canonicalizeSourceURL(fileSource.getResourceOptions().tileServerOptions(), rawURL);\n+\n+    req = fileSource.request(Resource::source(url), [this, url, &fileSource](const Response& res) {\n+        if (res.error) {\n+            observer->onSourceError(*this, std::make_exception_ptr(std::runtime_error(res.error->message)));\n+        } else if (res.notModified) {\n+            return;\n+        } else if (res.noContent) {\n+            observer->onSourceError(*this, std::make_exception_ptr(std::runtime_error(\"unexpectedly empty TileJSON\")));\n+        } else {\n+            conversion::Error error;\n+            std::optional<Tileset> tileset = conversion::convertJSON<Tileset>(*res.data, error);\n+            if (!tileset) {\n+                observer->onSourceError(*this, std::make_exception_ptr(util::StyleParseException(error.message)));\n+                return;\n+            }\n+            const auto& tileServerOptions = fileSource.getResourceOptions().tileServerOptions();\n+            if (tileServerOptions.uriSchemeAlias() == \"mapbox\") {",
        "comment_created_at": "2025-06-18T22:47:56+00:00",
        "comment_author": "scottrhoyt",
        "comment_body": "Previously, this check for mapbox as the uri scheme was only present in `RasterSource`. It was added in #1171 . This change would effectively add this check for `VectorSource` as well. It appears this only has to do with the built-in tile server schemes like maptiler and mapbox. I verified both raster and vector maps from maptiler uris worked as expected. Let me know if there are other implications to this.",
        "pr_file_module": null
      }
    ]
  }
]