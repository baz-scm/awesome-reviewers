[
  {
    "discussion_id": "1917794819",
    "pr_number": 3137,
    "pr_file": "docs/mdbook/src/rust.md",
    "created_at": "2025-01-16T06:03:14+00:00",
    "commented_code": "+# Rust\n+\n+We have added experimental support for intergrating Rust code into the source tree.\n+\n+## Rust Bridge\n+\n+The Rust bridge lives in the root `rustutils` directory.\n+\n+We use [CXX](https://cxx.rs/) to allow interop between Rust and C++.\n+\n+## Building\n+\n+### CMake\n+\n+When building with CMake, need to have the correct Rust toolchain(s) installed. See [Install Rust](https://www.rust-lang.org/tools/install) to install Rust.\n+\n+You can use `rustup` to manage toolchains. Which toolchain you needs depends on your host platform and for what platform you are trying to build. If your host and target platform are the same, you probably have the correct toolchain installed after installing Rust. For example when building for **Android** and building on a **x84 Linux** host you would use the following command:\n+\n+```\n+rustup target add --toolchain stable-x86_64-unknown-linux-gnu aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android\n+```\n+\n+See [Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html) in the Rust documentation for more details. You will get a descriptive error message when the correct toolchain is not available, so we don't list all possible combinations here.\n+\n+You also need to have cxxbridge installed:\n+\n+```\n+cargo install cxxbridge-cmd\n+```\n+\n+Set `-DMLN_USE_RUST=ON` when generating a configuration with CMake.\n+\n+### Bazel\n+\n+Pass the `--//:use_rust` flag to Bazel commands.\n+\n+Note that when [generating an Xcode project](./ios/README.md) you should not pass this option to Bazel directly, but as follows:\n+\n+```\n+bazel run //platform/ios:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags=\"--//:renderer=metal --//:use_rust\"\n+```",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1917794819",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3137,
        "pr_file": "docs/mdbook/src/rust.md",
        "discussion_id": "1917794819",
        "commented_code": "@@ -0,0 +1,67 @@\n+# Rust\n+\n+We have added experimental support for intergrating Rust code into the source tree.\n+\n+## Rust Bridge\n+\n+The Rust bridge lives in the root `rustutils` directory.\n+\n+We use [CXX](https://cxx.rs/) to allow interop between Rust and C++.\n+\n+## Building\n+\n+### CMake\n+\n+When building with CMake, need to have the correct Rust toolchain(s) installed. See [Install Rust](https://www.rust-lang.org/tools/install) to install Rust.\n+\n+You can use `rustup` to manage toolchains. Which toolchain you needs depends on your host platform and for what platform you are trying to build. If your host and target platform are the same, you probably have the correct toolchain installed after installing Rust. For example when building for **Android** and building on a **x84 Linux** host you would use the following command:\n+\n+```\n+rustup target add --toolchain stable-x86_64-unknown-linux-gnu aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android\n+```\n+\n+See [Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html) in the Rust documentation for more details. You will get a descriptive error message when the correct toolchain is not available, so we don't list all possible combinations here.\n+\n+You also need to have cxxbridge installed:\n+\n+```\n+cargo install cxxbridge-cmd\n+```\n+\n+Set `-DMLN_USE_RUST=ON` when generating a configuration with CMake.\n+\n+### Bazel\n+\n+Pass the `--//:use_rust` flag to Bazel commands.\n+\n+Note that when [generating an Xcode project](./ios/README.md) you should not pass this option to Bazel directly, but as follows:\n+\n+```\n+bazel run //platform/ios:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags=\"--//:renderer=metal --//:use_rust\"\n+```",
        "comment_created_at": "2025-01-16T06:03:14+00:00",
        "comment_author": "ianthetechie",
        "comment_body": "This bazel run command fails locally with the following error:\r\n\r\n```\r\nat 15:01:00 \u276f bazel run //platform/ios:xcodeproj --@rules_xcodeproj//xcodeproj:extra_common_flags=\"--//:renderer=metal --//:use_rust\"\r\nWARNING: Build options --//:renderer, --//:use_rust, and --@@rules_xcodeproj~//xcodeproj:extra_common_flags have changed, discarding analysis cache (this can be expensive, see https://bazel.build/advanced/performance/iteration-speed).\r\nINFO: Analyzed target //platform/ios:xcodeproj (0 packages loaded, 21 targets configured).\r\nINFO: Found 1 target...\r\nTarget //platform/ios:xcodeproj up-to-date:\r\n  bazel-bin/platform/ios/xcodeproj-runner.sh\r\nINFO: Elapsed time: 0.580s, Critical Path: 0.00s\r\nINFO: 1 process: 1 internal.\r\nINFO: Build completed successfully, 1 total action\r\nINFO: Running command line: bazel-bin/platform/ios/xcodeproj-runner.sh\r\n\r\nGenerating \"platform/ios/MapLibre.xcodeproj\"\r\nERROR: /Users/ianthetechie/maplibre-native/rustutils/BUILD.bazel:19:20: While resolving toolchains for target //rustutils:rustutils (6507d1a): No matching toolchains found for types @@rules_rust~//rust:toolchain_type.\r\nTo debug, rerun with --toolchain_resolution_debug='@@rules_rust~//rust:toolchain_type'\r\nIf platforms or toolchains are a new concept for you, we'd encourage reading https://bazel.build/concepts/platforms-intro.\r\nERROR: Analysis of target '@@rules_xcodeproj~~internal~rules_xcodeproj_generated//generator/platform/ios/xcodeproj:xcodeproj' failed; build aborted: Analysis failed\r\nINFO: Elapsed time: 0.359s, Critical Path: 0.00s\r\nINFO: 1 process: 1 internal.\r\nERROR: Build did NOT complete successfully\r\nERROR: Build failed. Not running target\r\nFAILED:\r\n    Fetching repository @@apple_support~~apple_cc_configure_extension~local_config_apple_cc; starting\r\n    Fetching repository @@rules_python~~python~python_3_11_aarch64-apple-darwin; starting\r\n    Fetching repository @@aspect_rules_js~~npm~npm__jake__10.8.7; starting\r\n    Fetching repository @@aspect_rules_js~~npm~npm__argparse__2.0.1; starting\r\n    Fetching repository @@aspect_bazel_lib~~toolchains~bsd_tar_darwin_arm64; starting\r\n    Fetching repository @@aspect_bazel_lib~~toolchains~copy_directory_darwin_arm64; starting\r\n    Fetching repository @@aspect_rules_js~~npm~npm__has-flag__4.0.0; starting\r\n    Fetching repository @@aspect_rules_js~~npm~npm__filelist__1.0.4; starting ... (10 fetches)\r\n```\r\n\r\n`bazel build //platform/ios:App --//:renderer=metal --//:use_rust` downloads the toolchain and ultimately builds successfully.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1100555007",
    "pr_number": 789,
    "pr_file": "design-proposals/2023-02-08-code-organisation.md",
    "created_at": "2023-02-08T18:57:20+00:00",
    "commented_code": "+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK\n+\n+We leave the SDK organisation up to the specific platform developers. It should probably follow conventions of the platform to simplify distribution and usage.\n+\n+The build system is also not explicitly defined. It would be strongly preferred that the core is built by `CMake` (or at least the necessary build scripts are not duplicated in a SDK repository/folder but generated by `CMake`).\n+\n+### Scope and feature-parity\n+\n+Different SDKs and bindings **are not expected to have feature-parity**. They can/will live in separate repositories and will be developed independently.\n+\n+When a feature is added to the core it may not be added to all SDKs at the same time.\n+\n+## Repository split - yes or no?\n+\n+This proposal does not touch much on repository splitting. If SDKs continue to live in the main repository, they should be put under `sdk/<platform>`. The following primary SDKs should be created and supported based on the currently available code:\n+\n+- Android SDK\n+- Apple SDK (common between all Apple platforms)\n+- Qt SDK\n+- Node.js Binaries and SDK\n+- GLFW SDK\n+\n+Navigation SDKs could then be merged with respective platform SDK.\n+\n+### Repository naming\n+\n+- `maplibre-native-core` or `maplibre-native-renderer` for the core functionality.\n+- SDKs:\n+  - `maplibre-native-sdk-apple` (iOS and macOS, potentially merged with `maplibre-navigation-ios`)",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1100555007",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1100555007",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK\n+\n+We leave the SDK organisation up to the specific platform developers. It should probably follow conventions of the platform to simplify distribution and usage.\n+\n+The build system is also not explicitly defined. It would be strongly preferred that the core is built by `CMake` (or at least the necessary build scripts are not duplicated in a SDK repository/folder but generated by `CMake`).\n+\n+### Scope and feature-parity\n+\n+Different SDKs and bindings **are not expected to have feature-parity**. They can/will live in separate repositories and will be developed independently.\n+\n+When a feature is added to the core it may not be added to all SDKs at the same time.\n+\n+## Repository split - yes or no?\n+\n+This proposal does not touch much on repository splitting. If SDKs continue to live in the main repository, they should be put under `sdk/<platform>`. The following primary SDKs should be created and supported based on the currently available code:\n+\n+- Android SDK\n+- Apple SDK (common between all Apple platforms)\n+- Qt SDK\n+- Node.js Binaries and SDK\n+- GLFW SDK\n+\n+Navigation SDKs could then be merged with respective platform SDK.\n+\n+### Repository naming\n+\n+- `maplibre-native-core` or `maplibre-native-renderer` for the core functionality.\n+- SDKs:\n+  - `maplibre-native-sdk-apple` (iOS and macOS, potentially merged with `maplibre-navigation-ios`)",
        "comment_created_at": "2023-02-08T18:57:20+00:00",
        "comment_author": "1ec5",
        "comment_body": "The package managers on Apple platforms are oriented around Git(Hub) repositories. Merging the map SDK and navigation SDK repositories effectively means eliminating the map SDK in favor of a monolithic navigation SDK unless significant workarounds are put in place.",
        "pr_file_module": null
      },
      {
        "comment_id": "1161970138",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1100555007",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK\n+\n+We leave the SDK organisation up to the specific platform developers. It should probably follow conventions of the platform to simplify distribution and usage.\n+\n+The build system is also not explicitly defined. It would be strongly preferred that the core is built by `CMake` (or at least the necessary build scripts are not duplicated in a SDK repository/folder but generated by `CMake`).\n+\n+### Scope and feature-parity\n+\n+Different SDKs and bindings **are not expected to have feature-parity**. They can/will live in separate repositories and will be developed independently.\n+\n+When a feature is added to the core it may not be added to all SDKs at the same time.\n+\n+## Repository split - yes or no?\n+\n+This proposal does not touch much on repository splitting. If SDKs continue to live in the main repository, they should be put under `sdk/<platform>`. The following primary SDKs should be created and supported based on the currently available code:\n+\n+- Android SDK\n+- Apple SDK (common between all Apple platforms)\n+- Qt SDK\n+- Node.js Binaries and SDK\n+- GLFW SDK\n+\n+Navigation SDKs could then be merged with respective platform SDK.\n+\n+### Repository naming\n+\n+- `maplibre-native-core` or `maplibre-native-renderer` for the core functionality.\n+- SDKs:\n+  - `maplibre-native-sdk-apple` (iOS and macOS, potentially merged with `maplibre-navigation-ios`)",
        "comment_created_at": "2023-04-10T18:31:42+00:00",
        "comment_author": "ntadej",
        "comment_body": "OK, will remove this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1101328975",
    "pr_number": 789,
    "pr_file": "design-proposals/2023-02-08-code-organisation.md",
    "created_at": "2023-02-09T11:26:20+00:00",
    "commented_code": "+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1101328975",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1101328975",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK",
        "comment_created_at": "2023-02-09T11:26:20+00:00",
        "comment_author": "louwers",
        "comment_body": "@1ec5 mentioned on Slack that a source-only distribution is the prefered way of distribution for Apple platforms now. For MapLibre I don't know if would apply to just the SDK (probably written in Swift in the long term) or also the core written in C++.",
        "pr_file_module": null
      },
      {
        "comment_id": "1101673524",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1101328975",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK",
        "comment_created_at": "2023-02-09T15:49:32+00:00",
        "comment_author": "1ec5",
        "comment_body": "This was in the context of the discussion on package managers. It\u2019s a lot easier to set up, for instance, SPM based on source distribution. MapLibre already has a workaround for SPM based on a binary distribution in [a dedicated repository](https://github.com/maplibre/maplibre-gl-native-distribution), but it isn\u2019t ideal in terms of requiring additional release steps and less obvious installation steps.\r\n\r\nThere are some hurdles to source-only distribution: the CMake-based build system is not straightforward enough for tight integration with package managers. mbgl takes a relatively long time to build. The whole gl-native repository and its submodules are too large to comfortably make every application developer clone it anew every time they resolve dependencies.\r\n\r\nThese hurdles mostly go away if the platform-specific code (other than a few low-level odds and ends) wind up in a separate repository like mapbox-gl-native-ios. That repository couldn\u2019t achieve source-only distribution partly because it carried the entire commit and tag history of gl-native along with it: https://github.com/maplibre/maplibre-gl-native/pull/789#discussion_r1100558480. But mbgl might still need to be distributed as a formal dependency package.\r\n\r\nTo be clear, source distribution is not mutually exclusive of binary distribution. It would remain possible to attach a prebuilt binary to a GitHub release, just as the gl-native-distribution repository currently does.",
        "pr_file_module": null
      },
      {
        "comment_id": "1136065086",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1101328975",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK",
        "comment_created_at": "2023-03-14T19:09:33+00:00",
        "comment_author": "thehoneymad",
        "comment_body": "Onboard with the package manager point.",
        "pr_file_module": null
      },
      {
        "comment_id": "1136088626",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 789,
        "pr_file": "design-proposals/2023-02-08-code-organisation.md",
        "discussion_id": "1101328975",
        "commented_code": "@@ -0,0 +1,137 @@\n+# MapLibre Native Code Organisation Design Proposal\n+\n+This proposal is to define code organisation that allows simple and efficient development and usage of MapLibre Native.\n+\n+## Motivation\n+\n+MapLibre Native is currently a monorepo that includes both the core functionality and the SDKs. It's not obvious what is used where andfirst-time contributors may also be repelled a bit by the complexity. This proposal is not necessarily about the splitting of repository (although it will be covered in a section) but in general about code organisation.\n+\n+## Terminology\n+\n+- \"*renderer*\" or \"*core*\" (will use \"*core*\" throughout the document) usually refers to the core part of MapLibre Native that is platform-independent to the extent that it builds and runs\n+- \"*platform*\" refers to the operating system and/or a platform that MapLibre runs on, examples are Linux, Windows, macOS, iOS, Android but also Node.js and Qt which provide an universal platform layer that we can use\n+- \"*SDK*\", \"*language bindings*\" or \"*platform bindings*\" refer to the interface that is provided to integrate MapLibre Native core to the client applications or projects.\n+\n+## MapLibre Native Core\n+\n+MapLibre Native core should provide base rendering functionality and the \"brain\" of the project. It should implement all the rendering and mapping functionality (i.e. loading of tiles) that is platform-independent. All functionality should be available on all platforms. Platform-specific functionality should be part of the SDKs.\n+\n+### Organisation\n+\n+The code needs to be organised in the following way:\n+\n+- `src`: contains main implementation that is completely platform-independent, also contains all private headers\n+- `include`: contains only public headers, that can be split into two categories\n+  - functionality of the library\n+  - interfaces for platform-specific bindings\n+- `platform`: contains minimum set of platform-specific classes for I/O, database access and rendering to make the library functional; any language binding and/or SDK helpers should not go here; examples:\n+  - `platform/darwin` or `platform/apple`\n+  - `platform/windows`\n+  - `platform/qt`\n+- `test`: common (headless) tests for all platforms; disabled only in exceptional cases if some features are not applicable due to the nature of a specific platform\n+\n+The core itself ideally should have no binaries unless they are really platform-independent (e.g. headless rendering).\n+\n+### Supported platforms\n+\n+We can split the platforms into two categories:\n+\n+- **Native platforms / operating systems**\n+  - Windows\n+  - Linux\n+  - Darwin and its derivatives (macOS, iOS, tvOS, ...)\n+  - Android\n+- **Cross-platform engines**\n+  - Node.js\n+  - Qt\n+  - GLFW\n+\n+### Build infrastructure\n+\n+The core should be exclusively built by `CMake`. All currently supported platforms are supported by it. No wrapper script or `Makefile` should be used. Can export `Xcode` projects if needed.\n+\n+The functionality part of the library (under `src`) should yield a separate object library. Similarly the platform-specific part (under `platform`) should be separate. Each 3rd-party dependency should also build as its own object library if distributed together with MapLibre. Static libraries may only be used as backwards compatibility for older platforms that the community may be interested in.\n+\n+The code should be C++17 or later (unless required otherwise by platform-specific integration).\n+\n+Compilation flags should ideally be the same on one native platform / operating system. This would allow building multiple platform-specific parts in parallel and would speed-up the development.\n+\n+Final products of the core would be two or more object libraries to be directly used by the SDKs or one static or dynamic library for binary distribution. *Note: At this point it is not clear if all platforms need binary distribution independent of the SDK that will be provided for that platform.*\n+\n+Examples of binary distributions could be:\n+\n+- Dynamic libraries for Windows, Linux and Android.\n+- Dynamic and static frameworks for macOS and iOS.\n+- Cross-platform engines will probably build the core as part of the SDK and no direct core binaries are needed (as written above this may also apply for native platforms).\n+\n+### Testing\n+\n+All testing should be done for all platforms at the same time and as complete as possible. Basic rendering tests should be done headlessly for all platforms.\n+\n+If needed for specific platforms (iOS comes to mind), a dedicated test app could be made to run the necessary rendering tests. This app should implement the minimal functionality that does not include the actual full-fledged integration of MapLibre (e.g. gestures, widgets, ...).\n+\n+Testing should be done by `CTest` if the platform allows (may not be possible for all integration tests on mobile devices).\n+\n+### Release cycle\n+\n+The core should have an independent release cycle. At this point we imagine SDKs to be much more actively developed. This also allows bigger refactoring to take place without affecting SDKs (e.g. Metal migration).\n+\n+## SDKs and other bindings\n+\n+SDKs, language bindings and platform bindings should provide utilities to integrate MapLibre better to a specific platform. They should not add any core mapping functionality but they could add integration utilities that can not be made platform independent, e.g.\n+\n+- widgets\n+- gestures support on toucscreen devices\n+- location services (GPS, location from the mobile network)\n+\n+### Organisation\n+\n+MapLibre core could be provided as a submodule, but it is not necessary. For mobile platforms this may or may not be the case, depending on the level of the integration, for example:\n+\n+- on Android if Kotlin/Java is mostly used, then distributing the core separately as a dynamic library is completely reasonable\n+- on iOS where static building may be much more beneficial due to size the core will probably be built together with the SDK",
        "comment_created_at": "2023-03-14T19:31:10+00:00",
        "comment_author": "1ec5",
        "comment_body": "By the way, if core is packaged up as a build artifact for iOS or macOS, note that a framework can\u2019t expose any Objective-C++ because the C++ won\u2019t translate across ABI boundaries. This means any framework/library vended by core for iOS/macOS would need to stick to pure C or C++ in its public interface. This should already be the case, but it would influence where we draw the line between core and SDK codebases.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1260159195",
    "pr_number": 1342,
    "pr_file": "platform/ios/platform/ios/README.md",
    "created_at": "2023-07-11T19:01:58+00:00",
    "commented_code": "3. Choose \"Next\". Xcode should clone the distribution repository and download the binaries.\n \n+4. To create a minimal app, update `ContentView.swift` (which should have been automatically created when you initalized the new XCode project) with the following contents:\n+\n+```\n+import SwiftUI\n+import Mapbox\n+\n+struct ContentView: View {\n+    var body: some View {\n+        MapView().edgesIgnoringSafeArea(.all)\n+    }\n+}\n+\n+struct ContentView_Previews: PreviewProvider {\n+    static var previews: some View {\n+        ContentView()\n+    }\n+}\n+\n+struct MapView: UIViewRepresentable {\n+    func makeUIView(context: Context) -> MGLMapView {\n+        // Build the style URL\n+        let styleURL = URL(string: \"https://demotiles.maplibre.org/style.json\")\n+        \n+        // Create the map view\n+        let mapView = MGLMapView(frame: .zero, styleURL: styleURL)\n+        \n+        mapView.logoView.isHidden = true\n+        \n+        mapView.setCenter(\n+            CLLocationCoordinate2D(\n+                latitude: 23.16, longitude: -109.50), animated: false)\n+        \n+        mapView.setZoomLevel(4, animated: false)\n+        return mapView\n+        \n+    }\n+    \n+    func updateUIView(_ mapView: MGLMapView, context: Context) {\n+        // Update the view if needed\n+    }\n+}\n+```\n+\n There is a an open bounty to extend this Getting Started guide ([#809](https://github.com/maplibre/maplibre-native/issues/809)). In the meantime, refer to one of these external guides:\n \n - [Get Started with MapLibre Native for iOS using SwiftUI](https://docs.maptiler.com/maplibre-gl-native-ios/ios-swiftui-basic-get-started/)\n - [Get Started With MapLibre Native for iOS using UIKit](https://docs.maptiler.com/maplibre-gl-native-ios/ios-uikit-basic-get-started/)\n \n ## Developing\n \n-### CMake\n+The following are instructions on how to build `maplibre-native` for development purposes. \n \n-The main build tool generator supported by MapLibre Native is CMake. There is a `Makefile` which calls CMake and `xcodebuild` under the hood to complete various development tasks, including building with various kinds of configurations and running tests. This `Makefile` can also can set up an Xcode project for MapLibre Native development by copying a `.xcodeproj` file part of the source tree and combining that with the output of CMake.\n+### Downloading Source\n \n-To set up an Xcode project and open Xcode, use the following command.\n+Download the source and install all submodules if you have not already, by running the following from the root of the repository. \n \n ```\n-make iproj\n+git clone git@github.com:maplibre/maplibre-native.git maplibre-native",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1260159195",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1342,
        "pr_file": "platform/ios/platform/ios/README.md",
        "discussion_id": "1260159195",
        "commented_code": "@@ -14,34 +14,154 @@ MapLibre Native for iOS is distributed using the [Swift Package Index](https://s\n \n 3. Choose \"Next\". Xcode should clone the distribution repository and download the binaries.\n \n+4. To create a minimal app, update `ContentView.swift` (which should have been automatically created when you initalized the new XCode project) with the following contents:\n+\n+```\n+import SwiftUI\n+import Mapbox\n+\n+struct ContentView: View {\n+    var body: some View {\n+        MapView().edgesIgnoringSafeArea(.all)\n+    }\n+}\n+\n+struct ContentView_Previews: PreviewProvider {\n+    static var previews: some View {\n+        ContentView()\n+    }\n+}\n+\n+struct MapView: UIViewRepresentable {\n+    func makeUIView(context: Context) -> MGLMapView {\n+        // Build the style URL\n+        let styleURL = URL(string: \"https://demotiles.maplibre.org/style.json\")\n+        \n+        // Create the map view\n+        let mapView = MGLMapView(frame: .zero, styleURL: styleURL)\n+        \n+        mapView.logoView.isHidden = true\n+        \n+        mapView.setCenter(\n+            CLLocationCoordinate2D(\n+                latitude: 23.16, longitude: -109.50), animated: false)\n+        \n+        mapView.setZoomLevel(4, animated: false)\n+        return mapView\n+        \n+    }\n+    \n+    func updateUIView(_ mapView: MGLMapView, context: Context) {\n+        // Update the view if needed\n+    }\n+}\n+```\n+\n There is a an open bounty to extend this Getting Started guide ([#809](https://github.com/maplibre/maplibre-native/issues/809)). In the meantime, refer to one of these external guides:\n \n - [Get Started with MapLibre Native for iOS using SwiftUI](https://docs.maptiler.com/maplibre-gl-native-ios/ios-swiftui-basic-get-started/)\n - [Get Started With MapLibre Native for iOS using UIKit](https://docs.maptiler.com/maplibre-gl-native-ios/ios-uikit-basic-get-started/)\n \n ## Developing\n \n-### CMake\n+The following are instructions on how to build `maplibre-native` for development purposes. \n \n-The main build tool generator supported by MapLibre Native is CMake. There is a `Makefile` which calls CMake and `xcodebuild` under the hood to complete various development tasks, including building with various kinds of configurations and running tests. This `Makefile` can also can set up an Xcode project for MapLibre Native development by copying a `.xcodeproj` file part of the source tree and combining that with the output of CMake.\n+### Downloading Source\n \n-To set up an Xcode project and open Xcode, use the following command.\n+Download the source and install all submodules if you have not already, by running the following from the root of the repository. \n \n ```\n-make iproj\n+git clone git@github.com:maplibre/maplibre-native.git maplibre-native",
        "comment_created_at": "2023-07-11T19:01:58+00:00",
        "comment_author": "louwers",
        "comment_body": "It's easier to just clone with `--recurse-submodules`",
        "pr_file_module": null
      }
    ]
  }
]