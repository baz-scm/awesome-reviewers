[
  {
    "discussion_id": "1783220707",
    "pr_number": 2882,
    "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
    "created_at": "2024-10-01T17:13:39+00:00",
    "commented_code": "+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1783220707",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1783220707",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
        "comment_created_at": "2024-10-01T17:13:39+00:00",
        "comment_author": "louwers",
        "comment_body": "Avoid magic numbers",
        "pr_file_module": null
      },
      {
        "comment_id": "1783522111",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1783220707",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
        "comment_created_at": "2024-10-01T20:54:41+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "The numbers are following the PMTiles specification (same as the [JS version](https://github.com/protomaps/PMTiles/blob/main/js/index.ts#L613)). Should I just put a comment telling about their origin, or should I make something different in this piece of code? I'm open to advice.",
        "pr_file_module": null
      },
      {
        "comment_id": "1783692656",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1783220707",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
        "comment_created_at": "2024-10-02T00:47:02+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "I made some changes to the code, and a comment explaining where does the numbers come from, could you please review?",
        "pr_file_module": null
      },
      {
        "comment_id": "1784036842",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1783220707",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
        "comment_created_at": "2024-10-02T08:29:27+00:00",
        "comment_author": "louwers",
        "comment_body": "Adding comments is good, but I would also assign these numbers to a const.",
        "pr_file_module": null
      },
      {
        "comment_id": "1784409717",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1783220707",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+const int MAX_DIRECTORY_CACHE_ENTRIES = 100;\n+\n+bool acceptsURL(const std::string& url) {\n+    return 0 == url.rfind(mbgl::util::PMTILES_PROTOCOL, 0);\n+}\n+\n+std::string extract_url(const std::string& url) {\n+    return url.substr(std::char_traits<char>::length(mbgl::util::PMTILES_PROTOCOL));\n+}\n+} // namespace\n+\n+namespace mbgl {\n+using namespace rapidjson;\n+\n+using AsyncCallback = std::function<void(std::unique_ptr<Response::Error>)>;\n+using AsyncTileCallback = std::function<void(std::pair<uint64_t, uint32_t>, std::unique_ptr<Response::Error>)>;\n+\n+class PMTilesFileSource::Impl {\n+public:\n+    explicit Impl(const ActorRef<Impl>&, const ResourceOptions& resourceOptions_, const ClientOptions& clientOptions_)\n+        : resourceOptions(resourceOptions_.clone()),\n+          clientOptions(clientOptions_.clone()) {}\n+\n+    // Generate a tilejson resource from .pmtiles file\n+    void request_tilejson(AsyncRequest* req, const Resource& resource, const ActorRef<FileSourceRequest>& ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getMetadata(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            Response response;\n+\n+            if (error) {\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            response.data = std::make_shared<std::string>(metadata_cache.at(url));\n+            ref.invoke(&FileSourceRequest::setResponse, response);\n+        });\n+    }\n+\n+    // Load data for specific tile\n+    void request_tile(AsyncRequest* req, const Resource& resource, ActorRef<FileSourceRequest> ref) {\n+        auto url = extract_url(resource.url);\n+\n+        getHeaderAndRootDirectory(url, req, [=, this](std::unique_ptr<Response::Error> error) {\n+            if (error) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::move(error);\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            pmtiles::headerv3 header = header_cache.at(url);\n+\n+            if (resource.tileData->z < header.min_zoom || resource.tileData->z > header.max_zoom) {\n+                Response response;\n+                response.noContent = true;\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            uint64_t tileID;\n+\n+            try {\n+                tileID = pmtiles::zxy_to_tileid(static_cast<uint8_t>(resource.tileData->z),\n+                                                static_cast<uint32_t>(resource.tileData->x),\n+                                                static_cast<uint32_t>(resource.tileData->y));\n+            } catch (const std::exception& e) {\n+                Response response;\n+                response.noContent = true;\n+                response.error = std::make_unique<Response::Error>(Response::Error::Reason::Other,\n+                                                                   std::string(\"Invalid tile: \") + e.what());\n+                ref.invoke(&FileSourceRequest::setResponse, response);\n+                return;\n+            }\n+\n+            getTileAddress(\n+                url,\n+                req,\n+                tileID,\n+                header.root_dir_offset,\n+                header.root_dir_bytes,\n+                0,\n+                [=, this](std::pair<uint64_t, uint32_t> tileAddress, std::unique_ptr<Response::Error> tileError) {\n+                    if (tileError) {\n+                        Response response;\n+                        response.noContent = true;\n+                        response.error = std::move(tileError);\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    if (tileAddress.first == 0 && tileAddress.second == 0) {\n+                        Response response;\n+                        response.noContent = true;\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    }\n+\n+                    Resource tileResource(Resource::Kind::Source, url);\n+                    tileResource.loadingMethod = Resource::LoadingMethod::Network;\n+                    tileResource.dataRange = std::make_pair(tileAddress.first,\n+                                                            tileAddress.first + tileAddress.second - 1);\n+\n+                    tasks[req] = getFileSource()->request(tileResource, [=](const Response& tileResponse) {\n+                        Response response;\n+                        response.noContent = true;\n+\n+                        if (tileResponse.error) {\n+                            response.error = std::make_unique<Response::Error>(\n+                                tileResponse.error->reason,\n+                                std::string(\"Error fetching PMTiles tile: \") + tileResponse.error->message);\n+                            ref.invoke(&FileSourceRequest::setResponse, response);\n+                            return;\n+                        }\n+\n+                        response.data = tileResponse.data;\n+                        response.noContent = false;\n+                        response.modified = tileResponse.modified;\n+                        response.expires = tileResponse.expires;\n+                        response.etag = tileResponse.etag;\n+\n+                        if (header.tile_compression == pmtiles::COMPRESSION_GZIP) {\n+                            response.data = std::make_shared<std::string>(util::decompress(*tileResponse.data));\n+                        }\n+\n+                        ref.invoke(&FileSourceRequest::setResponse, response);\n+                        return;\n+                    });\n+                });\n+        });\n+    }\n+\n+    void setResourceOptions(ResourceOptions options) {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        resourceOptions = options;\n+    }\n+\n+    ResourceOptions getResourceOptions() {\n+        std::lock_guard<std::mutex> lock(resourceOptionsMutex);\n+        return resourceOptions.clone();\n+    }\n+\n+    void setClientOptions(ClientOptions options) {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        clientOptions = options;\n+    }\n+\n+    ClientOptions getClientOptions() {\n+        std::lock_guard<std::mutex> lock(clientOptionsMutex);\n+        return clientOptions.clone();\n+    }\n+\n+private:\n+    mutable std::mutex resourceOptionsMutex;\n+    mutable std::mutex clientOptionsMutex;\n+    ResourceOptions resourceOptions;\n+    ClientOptions clientOptions;\n+\n+    std::shared_ptr<FileSource> fileSource;\n+    std::map<std::string, pmtiles::headerv3> header_cache;\n+    std::map<std::string, std::string> metadata_cache;\n+    std::map<std::string, std::map<std::string, std::vector<pmtiles::entryv3>>> directory_cache;\n+    std::map<std::string, std::vector<std::string>> directory_cache_control;\n+    std::map<AsyncRequest*, std::unique_ptr<AsyncRequest>> tasks;\n+\n+    std::shared_ptr<FileSource> getFileSource() {\n+        if (!fileSource) {\n+            fileSource = FileSourceManager::get()->getFileSource(\n+                FileSourceType::ResourceLoader, resourceOptions, clientOptions);\n+        }\n+\n+        return fileSource;\n+    }\n+\n+    void getHeaderAndRootDirectory(const std::string& url, AsyncRequest* req, AsyncCallback callback) {\n+        if (header_cache.find(url) != header_cache.end()) {\n+            callback(std::unique_ptr<Response::Error>());\n+        }\n+\n+        Resource resource(Resource::Kind::Source, url);\n+        resource.loadingMethod = Resource::LoadingMethod::Network;\n+        resource.dataRange = std::make_pair<uint64_t, uint64_t>(0, 16383);",
        "comment_created_at": "2024-10-02T12:18:23+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "That's a very good idea. Please check if it's better now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1789292566",
    "pr_number": 2882,
    "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
    "created_at": "2024-10-06T23:13:03+00:00",
    "commented_code": "+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+// https://github.com/protomaps/PMTiles/blob/main/spec/v3/spec.md#3-header\n+constexpr int PMTILES_HEADER_OFFSET = 0;\n+constexpr int PMTILES_HEADER_LENGTH = 127;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1789292566",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1789292566",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+// https://github.com/protomaps/PMTiles/blob/main/spec/v3/spec.md#3-header\n+constexpr int PMTILES_HEADER_OFFSET = 0;\n+constexpr int PMTILES_HEADER_LENGTH = 127;",
        "comment_created_at": "2024-10-06T23:13:03+00:00",
        "comment_author": "louwers",
        "comment_body": "I think all upper case names should be reserved for macros. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#nl9-use-all_caps-for-macro-names-only",
        "pr_file_module": null
      },
      {
        "comment_id": "1789344793",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1789292566",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+// https://github.com/protomaps/PMTiles/blob/main/spec/v3/spec.md#3-header\n+constexpr int PMTILES_HEADER_OFFSET = 0;\n+constexpr int PMTILES_HEADER_LENGTH = 127;",
        "comment_created_at": "2024-10-07T01:15:48+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "Originally I wanted to declare these numbers as defines, but how to use them correctly? The compiler complains when I define them using #define.",
        "pr_file_module": null
      },
      {
        "comment_id": "1807384648",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2882,
        "pr_file": "platform/default/src/mbgl/storage/pmtiles_file_source.cpp",
        "discussion_id": "1789292566",
        "commented_code": "@@ -0,0 +1,547 @@\n+#include <sstream>\n+#include <map>\n+\n+#include <mbgl/platform/settings.hpp>\n+#include <mbgl/storage/pmtiles_file_source.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/file_source_request.hpp>\n+\n+#include <rapidjson/document.h>\n+#include <rapidjson/rapidjson.h>\n+#include <rapidjson/stringbuffer.h>\n+#include <rapidjson/writer.h>\n+\n+#include <mbgl/util/thread.hpp>\n+#include <mbgl/util/url.hpp>\n+#include <mbgl/util/chrono.hpp>\n+#include <mbgl/util/compression.hpp>\n+#include <mbgl/util/filesystem.hpp>\n+\n+#include <pmtiles.hpp>\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#if defined(__QT__) && (defined(_WIN32) || defined(__EMSCRIPTEN__))\n+#include <QtZlib/zlib.h>\n+#else\n+#include <zlib.h>\n+#endif\n+\n+namespace {\n+// https://github.com/protomaps/PMTiles/blob/main/spec/v3/spec.md#3-header\n+constexpr int PMTILES_HEADER_OFFSET = 0;\n+constexpr int PMTILES_HEADER_LENGTH = 127;",
        "comment_created_at": "2024-10-19T15:19:59+00:00",
        "comment_author": "louwers",
        "comment_body": "Keep it `constexpr`, but lowercase them.\r\n\r\nAlso camelcase maybe `pmtilesHeaderOffset`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1465667996",
    "pr_number": 2050,
    "pr_file": "src/mbgl/renderer/layers/line_layer_tweaker.cpp",
    "created_at": "2024-01-24T23:31:25+00:00",
    "commented_code": "void LineLayerTweaker::execute(LayerGroupBase& layerGroup, const PaintParameters& parameters) {\n     auto& context = parameters.context;\n+    const auto zoom = parameters.state.getZoom();\n     const auto& evaluated = static_cast<const LineLayerProperties&>(*evaluatedProperties).evaluated;\n     const auto& crossfade = static_cast<const LineLayerProperties&>(*evaluatedProperties).crossfade;\n \n-    const auto zoom = parameters.state.getZoom();\n+    // Each property UBO is updated at most once if new evaluated properties were set\n+    bool propUpdateFlags[4] = {propertiesUpdated, propertiesUpdated, propertiesUpdated, propertiesUpdated};\n+    propertiesUpdated = false;\n \n     const auto getLinePropsBuffer = [&]() {\n-        if (!linePropertiesBuffer) {\n+        if (!linePropertiesBuffer || propUpdateFlags[0]) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1465667996",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2050,
        "pr_file": "src/mbgl/renderer/layers/line_layer_tweaker.cpp",
        "discussion_id": "1465667996",
        "commented_code": "@@ -38,13 +38,16 @@ static const StringIdentity idTexImageName = stringIndexer().get(\"u_image\");\n \n void LineLayerTweaker::execute(LayerGroupBase& layerGroup, const PaintParameters& parameters) {\n     auto& context = parameters.context;\n+    const auto zoom = parameters.state.getZoom();\n     const auto& evaluated = static_cast<const LineLayerProperties&>(*evaluatedProperties).evaluated;\n     const auto& crossfade = static_cast<const LineLayerProperties&>(*evaluatedProperties).crossfade;\n \n-    const auto zoom = parameters.state.getZoom();\n+    // Each property UBO is updated at most once if new evaluated properties were set\n+    bool propUpdateFlags[4] = {propertiesUpdated, propertiesUpdated, propertiesUpdated, propertiesUpdated};\n+    propertiesUpdated = false;\n \n     const auto getLinePropsBuffer = [&]() {\n-        if (!linePropertiesBuffer) {\n+        if (!linePropertiesBuffer || propUpdateFlags[0]) {",
        "comment_created_at": "2024-01-24T23:31:25+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Could you assign these indices to names to help clarify? ie `constexpr size_t LinePropUpdateFlags = 0;` (or with an enum),",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1323378029",
    "pr_number": 1616,
    "pr_file": "src/mbgl/mtl/context.cpp",
    "created_at": "2023-09-12T17:50:30+00:00",
    "commented_code": "+#include <mbgl/mtl/context.hpp>\n+\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/mtl/command_encoder.hpp>\n+#include <mbgl/mtl/drawable_builder.hpp>\n+#include <mbgl/mtl/layer_group.hpp>\n+#include <mbgl/mtl/renderer_backend.hpp>\n+#include <mbgl/mtl/renderable_resource.hpp>\n+#include <mbgl/mtl/texture2d.hpp>\n+#include <mbgl/mtl/tile_layer_group.hpp>\n+#include <mbgl/mtl/uniform_buffer.hpp>\n+#include <mbgl/mtl/upload_pass.hpp>\n+#include <mbgl/programs/program_parameters.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/shaders/mtl/shader_program.hpp>\n+#include <mbgl/util/traits.hpp>\n+#include <mbgl/util/std.hpp>\n+#include <mbgl/util/logging.hpp>\n+\n+#include <Foundation/Foundation.hpp>\n+#include <Metal/Metal.hpp>\n+\n+#include <algorithm>\n+#include <cstring>\n+\n+namespace mbgl {\n+namespace mtl {\n+\n+Context::Context(RendererBackend& backend_)\n+    : gfx::Context(16), // TODO",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1323378029",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1616,
        "pr_file": "src/mbgl/mtl/context.cpp",
        "discussion_id": "1323378029",
        "commented_code": "@@ -0,0 +1,209 @@\n+#include <mbgl/mtl/context.hpp>\n+\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/mtl/command_encoder.hpp>\n+#include <mbgl/mtl/drawable_builder.hpp>\n+#include <mbgl/mtl/layer_group.hpp>\n+#include <mbgl/mtl/renderer_backend.hpp>\n+#include <mbgl/mtl/renderable_resource.hpp>\n+#include <mbgl/mtl/texture2d.hpp>\n+#include <mbgl/mtl/tile_layer_group.hpp>\n+#include <mbgl/mtl/uniform_buffer.hpp>\n+#include <mbgl/mtl/upload_pass.hpp>\n+#include <mbgl/programs/program_parameters.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/shaders/mtl/shader_program.hpp>\n+#include <mbgl/util/traits.hpp>\n+#include <mbgl/util/std.hpp>\n+#include <mbgl/util/logging.hpp>\n+\n+#include <Foundation/Foundation.hpp>\n+#include <Metal/Metal.hpp>\n+\n+#include <algorithm>\n+#include <cstring>\n+\n+namespace mbgl {\n+namespace mtl {\n+\n+Context::Context(RendererBackend& backend_)\n+    : gfx::Context(16), // TODO",
        "comment_created_at": "2023-09-12T17:50:30+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Can you store this in a named variable to add context, ex `constexpr uint32_t maximumVertexBindingCount = 16;`",
        "pr_file_module": null
      }
    ]
  }
]