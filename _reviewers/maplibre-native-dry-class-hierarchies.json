[
  {
    "discussion_id": "2077374279",
    "pr_number": 3333,
    "pr_file": "platform/android/MapLibreAuto/src/main/java/org/maplibre/android/maps/TransformAuto.java",
    "created_at": "2025-05-07T11:03:14+00:00",
    "commented_code": "+package org.maplibre.android.maps;\n+\n+import android.os.Handler;\n+import android.os.Looper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.UiThread;\n+\n+import org.maplibre.android.camera.CameraPosition;\n+import org.maplibre.android.camera.CameraUpdate;\n+import org.maplibre.android.camera.CameraUpdateFactory;\n+\n+public final class TransformAuto extends Transform {\n+\n+    private static final String TAG = \"GrabMap-Auto-Transform\";\n+\n+    private final NativeMap nativeMap;\n+    @Nullable\n+    private MapView mapView;\n+    @Nullable\n+    private MapSurface mapSurface;\n+\n+    private final Handler handler = new Handler(Looper.getMainLooper());\n+\n+    @Nullable\n+    private CameraPosition cameraPosition;\n+    @Nullable\n+    private MapLibreMap.CancelableCallback cameraCancelableCallback;\n+    private final CameraChangeDispatcher cameraChangeDispatcher;\n+\n+    private final MapView.OnCameraDidChangeListener moveByChangeListener = new MapView.OnCameraDidChangeListener() {\n+        @Override\n+        public void onCameraDidChange(boolean animated) {\n+            if (animated) {\n+                cameraChangeDispatcher.onCameraIdle();\n+                removeOnCameraDidChangeListener(this);\n+            }\n+        }\n+    };\n+\n+    TransformAuto(@NonNull MapView mapView, NativeMap nativeMap, CameraChangeDispatcher cameraChangeDispatcher) {\n+        super(mapView, nativeMap, cameraChangeDispatcher);\n+        this.mapView = mapView;\n+        this.nativeMap = nativeMap;\n+        this.cameraChangeDispatcher = cameraChangeDispatcher;\n+    }\n+\n+    TransformAuto(@NonNull MapSurface mapSurface, NativeMap nativeMap, CameraChangeDispatcher cameraChangeDispatcher) {\n+        super(null, nativeMap, cameraChangeDispatcher);\n+        this.mapSurface = mapSurface;\n+        this.nativeMap = nativeMap;\n+        this.cameraChangeDispatcher = cameraChangeDispatcher;\n+    }\n+\n+    void initialise(@NonNull MapLibreMap maplibreMap, @NonNull MapLibreMapOptions options) {\n+        CameraPosition position = options.getCamera();\n+        if (position != null && !position.equals(CameraPosition.DEFAULT)) {\n+            moveCamera(maplibreMap, CameraUpdateFactory.newCameraPosition(position), null);\n+        }\n+        setMinZoom(options.getMinZoomPreference());\n+        setMaxZoom(options.getMaxZoomPreference());\n+        setMinPitch(options.getMinPitchPreference());\n+        setMaxPitch(options.getMaxPitchPreference());\n+    }\n+\n+    //\n+    // Camera API\n+    //\n+\n+    @Nullable\n+    @UiThread\n+    public CameraPosition getCameraPosition() {\n+        if (cameraPosition == null) {\n+            cameraPosition = invalidateCameraPosition();\n+        }\n+        return cameraPosition;\n+    }",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2077374279",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3333,
        "pr_file": "platform/android/MapLibreAuto/src/main/java/org/maplibre/android/maps/TransformAuto.java",
        "discussion_id": "2077374279",
        "commented_code": "@@ -0,0 +1,197 @@\n+package org.maplibre.android.maps;\n+\n+import android.os.Handler;\n+import android.os.Looper;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.UiThread;\n+\n+import org.maplibre.android.camera.CameraPosition;\n+import org.maplibre.android.camera.CameraUpdate;\n+import org.maplibre.android.camera.CameraUpdateFactory;\n+\n+public final class TransformAuto extends Transform {\n+\n+    private static final String TAG = \"GrabMap-Auto-Transform\";\n+\n+    private final NativeMap nativeMap;\n+    @Nullable\n+    private MapView mapView;\n+    @Nullable\n+    private MapSurface mapSurface;\n+\n+    private final Handler handler = new Handler(Looper.getMainLooper());\n+\n+    @Nullable\n+    private CameraPosition cameraPosition;\n+    @Nullable\n+    private MapLibreMap.CancelableCallback cameraCancelableCallback;\n+    private final CameraChangeDispatcher cameraChangeDispatcher;\n+\n+    private final MapView.OnCameraDidChangeListener moveByChangeListener = new MapView.OnCameraDidChangeListener() {\n+        @Override\n+        public void onCameraDidChange(boolean animated) {\n+            if (animated) {\n+                cameraChangeDispatcher.onCameraIdle();\n+                removeOnCameraDidChangeListener(this);\n+            }\n+        }\n+    };\n+\n+    TransformAuto(@NonNull MapView mapView, NativeMap nativeMap, CameraChangeDispatcher cameraChangeDispatcher) {\n+        super(mapView, nativeMap, cameraChangeDispatcher);\n+        this.mapView = mapView;\n+        this.nativeMap = nativeMap;\n+        this.cameraChangeDispatcher = cameraChangeDispatcher;\n+    }\n+\n+    TransformAuto(@NonNull MapSurface mapSurface, NativeMap nativeMap, CameraChangeDispatcher cameraChangeDispatcher) {\n+        super(null, nativeMap, cameraChangeDispatcher);\n+        this.mapSurface = mapSurface;\n+        this.nativeMap = nativeMap;\n+        this.cameraChangeDispatcher = cameraChangeDispatcher;\n+    }\n+\n+    void initialise(@NonNull MapLibreMap maplibreMap, @NonNull MapLibreMapOptions options) {\n+        CameraPosition position = options.getCamera();\n+        if (position != null && !position.equals(CameraPosition.DEFAULT)) {\n+            moveCamera(maplibreMap, CameraUpdateFactory.newCameraPosition(position), null);\n+        }\n+        setMinZoom(options.getMinZoomPreference());\n+        setMaxZoom(options.getMaxZoomPreference());\n+        setMinPitch(options.getMinPitchPreference());\n+        setMaxPitch(options.getMaxPitchPreference());\n+    }\n+\n+    //\n+    // Camera API\n+    //\n+\n+    @Nullable\n+    @UiThread\n+    public CameraPosition getCameraPosition() {\n+        if (cameraPosition == null) {\n+            cameraPosition = invalidateCameraPosition();\n+        }\n+        return cameraPosition;\n+    }",
        "comment_created_at": "2025-05-07T11:03:14+00:00",
        "comment_author": "ahmedre",
        "comment_body": "from testing this pr, this method causes the camera position to _always_ be 0,0, even when the underlying native map has the correct position. i believe that this is because `cameraPosition` is never set here beyond the first `invalidateCameraPosition`, and the parent `Transform` class has its own `cameraPosition`.\r\n\r\nwhat if we delegate this method to the parent and remove the `cameraPosition` variable from this class altogether? i tested this and it fixed the camera position for me.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1739192178",
    "pr_number": 2711,
    "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/MapRenderer.java",
    "created_at": "2024-08-30T17:44:44+00:00",
    "commented_code": "+package org.maplibre.android.maps.renderer;\n+\n+import android.content.Context;\n+import android.view.Surface;\n+import android.view.TextureView;\n+import android.view.View;\n+\n+import androidx.annotation.CallSuper;\n+import androidx.annotation.Keep;\n+import androidx.annotation.NonNull;\n+\n+import org.maplibre.android.LibraryLoader;\n+import org.maplibre.android.log.Logger;\n+import org.maplibre.android.maps.MapLibreMap;\n+import org.maplibre.android.maps.MapLibreMapOptions;\n+import org.maplibre.android.maps.renderer.surfaceview.MapLibreSurfaceView;\n+import org.maplibre.android.maps.renderer.surfaceview.SurfaceViewMapRenderer;\n+import org.maplibre.android.maps.renderer.textureview.TextureViewMapRenderer;\n+\n+/**\n+ * The {@link MapRenderer} encapsulates the render thread.\n+ * <p>\n+ * Performs actions on the render thread to manage the resources and\n+ * render on the one end and acts as a scheduler to request work to\n+ * be performed on the render thread on the other.\n+ */\n+@Keep\n+public abstract class MapRenderer implements MapRendererScheduler {\n+\n+  static {\n+    LibraryLoader.load();\n+  }\n+\n+  private static final String TAG = \"Mbgl-MapRenderer\";\n+\n+  // Holds the pointer to the native peer after initialisation\n+  private long nativePtr = 0;\n+  private double expectedRenderTime = 0;\n+  private MapLibreMap.OnFpsChangedListener onFpsChangedListener;\n+\n+  public static MapRenderer create(MapLibreMapOptions options, @NonNull Context context, Runnable initCallback) {\n+\n+    MapRenderer renderer = null;\n+    String localFontFamily = options.getLocalIdeographFontFamily();\n+\n+    if (options.getTextureMode()) {\n+      TextureView textureView = new TextureView(context);\n+      boolean translucentSurface = options.getTranslucentTextureSurface();\n+      renderer = new TextureViewMapRenderer(context, textureView, localFontFamily, translucentSurface) {\n+        @Override\n+        protected void onSurfaceCreated(Surface surface) {\n+          initCallback.run();\n+          super.onSurfaceCreated(surface);\n+        }\n+      };\n+    } else {\n+      MapLibreSurfaceView surfaceView = new MapLibreSurfaceView(context);\n+      surfaceView.setZOrderMediaOverlay(options.getRenderSurfaceOnTop());\n+      renderer = new SurfaceViewMapRenderer(context, surfaceView, localFontFamily) {\n+        @Override\n+        public void onSurfaceCreated() {\n+          initCallback.run();\n+          super.onSurfaceCreated();\n+        }\n+      };\n+    }\n+\n+    return renderer;\n+  }\n+\n+  public MapRenderer(@NonNull Context context, String localIdeographFontFamily) {\n+    float pixelRatio = context.getResources().getDisplayMetrics().density;\n+\n+    // Initialise native peer\n+    nativeInitialize(this, pixelRatio, localIdeographFontFamily);\n+  }\n+\n+  public abstract View getView();\n+\n+  public void onStart() {\n+    // Implement if needed\n+  }\n+\n+  public void onPause() {\n+    // Implement if needed\n+  }\n+\n+  public void onResume() {\n+    // Implement if needed\n+  }\n+\n+  public void onStop() {\n+    // Implement if needed\n+  }\n+\n+  public void onDestroy() {\n+    // Implement if needed\n+  }\n+\n+  public void setOnFpsChangedListener(MapLibreMap.OnFpsChangedListener listener) {\n+    onFpsChangedListener = listener;\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceCreated(Surface surface) {\n+    nativeOnSurfaceCreated(surface);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceChanged(int width, int height) {\n+    nativeOnSurfaceChanged(width, height);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceDestroyed() {\n+    nativeOnSurfaceDestroyed();\n+  }\n+\n+  @CallSuper\n+  protected void onDrawFrame() {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1739192178",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2711,
        "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/MapRenderer.java",
        "discussion_id": "1739192178",
        "commented_code": "@@ -0,0 +1,202 @@\n+package org.maplibre.android.maps.renderer;\n+\n+import android.content.Context;\n+import android.view.Surface;\n+import android.view.TextureView;\n+import android.view.View;\n+\n+import androidx.annotation.CallSuper;\n+import androidx.annotation.Keep;\n+import androidx.annotation.NonNull;\n+\n+import org.maplibre.android.LibraryLoader;\n+import org.maplibre.android.log.Logger;\n+import org.maplibre.android.maps.MapLibreMap;\n+import org.maplibre.android.maps.MapLibreMapOptions;\n+import org.maplibre.android.maps.renderer.surfaceview.MapLibreSurfaceView;\n+import org.maplibre.android.maps.renderer.surfaceview.SurfaceViewMapRenderer;\n+import org.maplibre.android.maps.renderer.textureview.TextureViewMapRenderer;\n+\n+/**\n+ * The {@link MapRenderer} encapsulates the render thread.\n+ * <p>\n+ * Performs actions on the render thread to manage the resources and\n+ * render on the one end and acts as a scheduler to request work to\n+ * be performed on the render thread on the other.\n+ */\n+@Keep\n+public abstract class MapRenderer implements MapRendererScheduler {\n+\n+  static {\n+    LibraryLoader.load();\n+  }\n+\n+  private static final String TAG = \"Mbgl-MapRenderer\";\n+\n+  // Holds the pointer to the native peer after initialisation\n+  private long nativePtr = 0;\n+  private double expectedRenderTime = 0;\n+  private MapLibreMap.OnFpsChangedListener onFpsChangedListener;\n+\n+  public static MapRenderer create(MapLibreMapOptions options, @NonNull Context context, Runnable initCallback) {\n+\n+    MapRenderer renderer = null;\n+    String localFontFamily = options.getLocalIdeographFontFamily();\n+\n+    if (options.getTextureMode()) {\n+      TextureView textureView = new TextureView(context);\n+      boolean translucentSurface = options.getTranslucentTextureSurface();\n+      renderer = new TextureViewMapRenderer(context, textureView, localFontFamily, translucentSurface) {\n+        @Override\n+        protected void onSurfaceCreated(Surface surface) {\n+          initCallback.run();\n+          super.onSurfaceCreated(surface);\n+        }\n+      };\n+    } else {\n+      MapLibreSurfaceView surfaceView = new MapLibreSurfaceView(context);\n+      surfaceView.setZOrderMediaOverlay(options.getRenderSurfaceOnTop());\n+      renderer = new SurfaceViewMapRenderer(context, surfaceView, localFontFamily) {\n+        @Override\n+        public void onSurfaceCreated() {\n+          initCallback.run();\n+          super.onSurfaceCreated();\n+        }\n+      };\n+    }\n+\n+    return renderer;\n+  }\n+\n+  public MapRenderer(@NonNull Context context, String localIdeographFontFamily) {\n+    float pixelRatio = context.getResources().getDisplayMetrics().density;\n+\n+    // Initialise native peer\n+    nativeInitialize(this, pixelRatio, localIdeographFontFamily);\n+  }\n+\n+  public abstract View getView();\n+\n+  public void onStart() {\n+    // Implement if needed\n+  }\n+\n+  public void onPause() {\n+    // Implement if needed\n+  }\n+\n+  public void onResume() {\n+    // Implement if needed\n+  }\n+\n+  public void onStop() {\n+    // Implement if needed\n+  }\n+\n+  public void onDestroy() {\n+    // Implement if needed\n+  }\n+\n+  public void setOnFpsChangedListener(MapLibreMap.OnFpsChangedListener listener) {\n+    onFpsChangedListener = listener;\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceCreated(Surface surface) {\n+    nativeOnSurfaceCreated(surface);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceChanged(int width, int height) {\n+    nativeOnSurfaceChanged(width, height);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceDestroyed() {\n+    nativeOnSurfaceDestroyed();\n+  }\n+\n+  @CallSuper\n+  protected void onDrawFrame() {",
        "comment_created_at": "2024-08-30T17:44:44+00:00",
        "comment_author": "louwers",
        "comment_body": "Duplicated. I feel like this should be in a common base class.",
        "pr_file_module": null
      },
      {
        "comment_id": "1742375548",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2711,
        "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/MapRenderer.java",
        "discussion_id": "1739192178",
        "commented_code": "@@ -0,0 +1,202 @@\n+package org.maplibre.android.maps.renderer;\n+\n+import android.content.Context;\n+import android.view.Surface;\n+import android.view.TextureView;\n+import android.view.View;\n+\n+import androidx.annotation.CallSuper;\n+import androidx.annotation.Keep;\n+import androidx.annotation.NonNull;\n+\n+import org.maplibre.android.LibraryLoader;\n+import org.maplibre.android.log.Logger;\n+import org.maplibre.android.maps.MapLibreMap;\n+import org.maplibre.android.maps.MapLibreMapOptions;\n+import org.maplibre.android.maps.renderer.surfaceview.MapLibreSurfaceView;\n+import org.maplibre.android.maps.renderer.surfaceview.SurfaceViewMapRenderer;\n+import org.maplibre.android.maps.renderer.textureview.TextureViewMapRenderer;\n+\n+/**\n+ * The {@link MapRenderer} encapsulates the render thread.\n+ * <p>\n+ * Performs actions on the render thread to manage the resources and\n+ * render on the one end and acts as a scheduler to request work to\n+ * be performed on the render thread on the other.\n+ */\n+@Keep\n+public abstract class MapRenderer implements MapRendererScheduler {\n+\n+  static {\n+    LibraryLoader.load();\n+  }\n+\n+  private static final String TAG = \"Mbgl-MapRenderer\";\n+\n+  // Holds the pointer to the native peer after initialisation\n+  private long nativePtr = 0;\n+  private double expectedRenderTime = 0;\n+  private MapLibreMap.OnFpsChangedListener onFpsChangedListener;\n+\n+  public static MapRenderer create(MapLibreMapOptions options, @NonNull Context context, Runnable initCallback) {\n+\n+    MapRenderer renderer = null;\n+    String localFontFamily = options.getLocalIdeographFontFamily();\n+\n+    if (options.getTextureMode()) {\n+      TextureView textureView = new TextureView(context);\n+      boolean translucentSurface = options.getTranslucentTextureSurface();\n+      renderer = new TextureViewMapRenderer(context, textureView, localFontFamily, translucentSurface) {\n+        @Override\n+        protected void onSurfaceCreated(Surface surface) {\n+          initCallback.run();\n+          super.onSurfaceCreated(surface);\n+        }\n+      };\n+    } else {\n+      MapLibreSurfaceView surfaceView = new MapLibreSurfaceView(context);\n+      surfaceView.setZOrderMediaOverlay(options.getRenderSurfaceOnTop());\n+      renderer = new SurfaceViewMapRenderer(context, surfaceView, localFontFamily) {\n+        @Override\n+        public void onSurfaceCreated() {\n+          initCallback.run();\n+          super.onSurfaceCreated();\n+        }\n+      };\n+    }\n+\n+    return renderer;\n+  }\n+\n+  public MapRenderer(@NonNull Context context, String localIdeographFontFamily) {\n+    float pixelRatio = context.getResources().getDisplayMetrics().density;\n+\n+    // Initialise native peer\n+    nativeInitialize(this, pixelRatio, localIdeographFontFamily);\n+  }\n+\n+  public abstract View getView();\n+\n+  public void onStart() {\n+    // Implement if needed\n+  }\n+\n+  public void onPause() {\n+    // Implement if needed\n+  }\n+\n+  public void onResume() {\n+    // Implement if needed\n+  }\n+\n+  public void onStop() {\n+    // Implement if needed\n+  }\n+\n+  public void onDestroy() {\n+    // Implement if needed\n+  }\n+\n+  public void setOnFpsChangedListener(MapLibreMap.OnFpsChangedListener listener) {\n+    onFpsChangedListener = listener;\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceCreated(Surface surface) {\n+    nativeOnSurfaceCreated(surface);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceChanged(int width, int height) {\n+    nativeOnSurfaceChanged(width, height);\n+  }\n+\n+  @CallSuper\n+  protected void onSurfaceDestroyed() {\n+    nativeOnSurfaceDestroyed();\n+  }\n+\n+  @CallSuper\n+  protected void onDrawFrame() {",
        "comment_created_at": "2024-09-03T16:42:49+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Moved `MapRenderer` to the main source set and generated factory classes for implementations. This will also help when/if we decide to merge the source sets and have a build with both backends available",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1739199403",
    "pr_number": 2711,
    "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/textureview/TextureViewRenderThread.java",
    "created_at": "2024-08-30T17:51:07+00:00",
    "commented_code": "+package org.maplibre.android.maps.renderer.textureview;\n+\n+import android.graphics.SurfaceTexture;\n+import android.view.Surface;\n+import android.view.TextureView;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.UiThread;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * The render thread is responsible for managing the communication between the\n+ * ui thread and the render thread it creates\n+ */\n+class TextureViewRenderThread extends Thread implements TextureView.SurfaceTextureListener {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1739199403",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2711,
        "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/textureview/TextureViewRenderThread.java",
        "discussion_id": "1739199403",
        "commented_code": "@@ -0,0 +1,271 @@\n+package org.maplibre.android.maps.renderer.textureview;\n+\n+import android.graphics.SurfaceTexture;\n+import android.view.Surface;\n+import android.view.TextureView;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.UiThread;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * The render thread is responsible for managing the communication between the\n+ * ui thread and the render thread it creates\n+ */\n+class TextureViewRenderThread extends Thread implements TextureView.SurfaceTextureListener {",
        "comment_created_at": "2024-08-30T17:51:07+00:00",
        "comment_author": "louwers",
        "comment_body": "Most code in this class is identical to the GL version. They can probably use a common base class.",
        "pr_file_module": null
      },
      {
        "comment_id": "1742395907",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2711,
        "pr_file": "platform/android/MapLibreAndroid/src/vulkan/java/org/maplibre/android/maps/renderer/textureview/TextureViewRenderThread.java",
        "discussion_id": "1739199403",
        "commented_code": "@@ -0,0 +1,271 @@\n+package org.maplibre.android.maps.renderer.textureview;\n+\n+import android.graphics.SurfaceTexture;\n+import android.view.Surface;\n+import android.view.TextureView;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.UiThread;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * The render thread is responsible for managing the communication between the\n+ * ui thread and the render thread it creates\n+ */\n+class TextureViewRenderThread extends Thread implements TextureView.SurfaceTextureListener {",
        "comment_created_at": "2024-09-03T17:00:37+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Lifecycle function moved to shared code",
        "pr_file_module": null
      }
    ]
  }
]