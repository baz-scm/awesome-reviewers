[
  {
    "discussion_id": "2077527733",
    "pr_number": 3198,
    "pr_file": "src/mbgl/gfx/dynamic_texture.cpp",
    "created_at": "2025-05-07T12:37:18+00:00",
    "commented_code": "+#include <mbgl/gfx/dynamic_texture.hpp>\n+#include <mbgl/gfx/texture2d.hpp>\n+#include <mbgl/gfx/context.hpp>\n+\n+namespace mbgl {\n+namespace gfx {\n+\n+DynamicTexture::DynamicTexture(Context& context, Size size, TexturePixelType pixelType) {\n+    mapbox::ShelfPack::ShelfPackOptions options;\n+    options.autoResize = false;\n+    shelfPack = mapbox::ShelfPack(size.width, size.height, options);\n+\n+    texture = context.createTexture2D();\n+    texture->setSize(size);\n+    texture->setFormat(pixelType, TextureChannelDataType::UnsignedByte);\n+    texture->setSamplerConfiguration(\n+        {gfx::TextureFilterType::Linear, gfx::TextureWrapType::Clamp, gfx::TextureWrapType::Clamp});\n+#if MLN_DEFER_UPLOAD_ON_RENDER_THREAD\n+    deferredCreation = true;\n+#else\n+    texture->create();\n+#endif\n+}\n+\n+const Texture2DPtr& DynamicTexture::getTexture() const {\n+    assert(texture);\n+    return texture;\n+}\n+\n+TexturePixelType DynamicTexture::getPixelFormat() const {\n+    assert(texture);\n+    return texture->getFormat();\n+}\n+\n+bool DynamicTexture::isEmpty() const {\n+    return (numTextures == 0);\n+}\n+\n+std::optional<TextureHandle> DynamicTexture::reserveSize(const Size& size, int32_t uniqueId) {\n+    mutex.lock();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2077527733",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3198,
        "pr_file": "src/mbgl/gfx/dynamic_texture.cpp",
        "discussion_id": "2077527733",
        "commented_code": "@@ -0,0 +1,110 @@\n+#include <mbgl/gfx/dynamic_texture.hpp>\n+#include <mbgl/gfx/texture2d.hpp>\n+#include <mbgl/gfx/context.hpp>\n+\n+namespace mbgl {\n+namespace gfx {\n+\n+DynamicTexture::DynamicTexture(Context& context, Size size, TexturePixelType pixelType) {\n+    mapbox::ShelfPack::ShelfPackOptions options;\n+    options.autoResize = false;\n+    shelfPack = mapbox::ShelfPack(size.width, size.height, options);\n+\n+    texture = context.createTexture2D();\n+    texture->setSize(size);\n+    texture->setFormat(pixelType, TextureChannelDataType::UnsignedByte);\n+    texture->setSamplerConfiguration(\n+        {gfx::TextureFilterType::Linear, gfx::TextureWrapType::Clamp, gfx::TextureWrapType::Clamp});\n+#if MLN_DEFER_UPLOAD_ON_RENDER_THREAD\n+    deferredCreation = true;\n+#else\n+    texture->create();\n+#endif\n+}\n+\n+const Texture2DPtr& DynamicTexture::getTexture() const {\n+    assert(texture);\n+    return texture;\n+}\n+\n+TexturePixelType DynamicTexture::getPixelFormat() const {\n+    assert(texture);\n+    return texture->getFormat();\n+}\n+\n+bool DynamicTexture::isEmpty() const {\n+    return (numTextures == 0);\n+}\n+\n+std::optional<TextureHandle> DynamicTexture::reserveSize(const Size& size, int32_t uniqueId) {\n+    mutex.lock();",
        "comment_created_at": "2025-05-07T12:37:18+00:00",
        "comment_author": "louwers",
        "comment_body": "Use a lock guard? Can deadlock if anything throws I think.\r\n\r\nAlso applies to other methods.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1475768743",
    "pr_number": 2051,
    "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
    "created_at": "2024-02-02T09:10:00+00:00",
    "commented_code": "tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1475768743",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T09:10:00+00:00",
        "comment_author": "louwers",
        "comment_body": "Somehow my brain can't parse this capture group.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476222892",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T15:43:08+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "I had to look up how to do this actually, haha. It extracts a value from the container and move it to a shared pointer inside the lambda's capture group. Doing it this way means we can keep using the iterator for the rest of the container.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476296171",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T16:43:10+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "~~I don't follow, why would it invalidate the iterator?~~  Oh, I see, `extract` invalidates.\r\n\r\nI somehow never noticed this, but I think it has the same temporary lambda copy retention issue as in `TileCache`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476479793",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T17:51:34+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Is `tiles.extract((tilesIt++)->first)` important here, vs. `tiles.extract(tilesIt++)`?  It's doing an extra key search.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476512530",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T18:26:39+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "From when I worked on it, I believe `extract().mapped()` was my best option to prevent a copy of the element while also removing it from the container. Other options didn't look like they'd work.\r\n\r\nIt may have that lambda issue, I never noticed the other instance in `TileCache`. I also haven't seen the destructor running on the main thread. To be safe, I'd say do the same here as in `TileCache`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476538909",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T18:52:04+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "It seems to be called somewhat rarely.  I couldn't trigger it from the benchmark or interactive, but it happens a few times in the render tests, apparently related to GeoJSON, so it might show up in performance in some scenario related to that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476556658",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T19:09:20+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "> Is `tiles.extract((tilesIt++)->first)` important here, vs. `tiles.extract(tilesIt++)`? It's doing an extra key search.\r\n\r\nIf it compiles and works correctly then no, I suppose it isn't.",
        "pr_file_module": null
      },
      {
        "comment_id": "1476557836",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2051,
        "pr_file": "src/mbgl/renderer/tile_pyramid.cpp",
        "discussion_id": "1475768743",
        "commented_code": "@@ -231,7 +233,14 @@ void TilePyramid::update(const std::vector<Immutable<style::LayerProperties>>& l\n                     tilesIt->second->setNecessity(TileNecessity::Optional);\n                     cache.add(tilesIt->first, std::move(tilesIt->second));\n                 }\n-                tiles.erase(tilesIt++);\n+\n+                if (tilesIt->second) {\n+                    tilesIt->second->cancel();\n+                    Scheduler::GetBackground()->schedule(\n+                        [tile_{std::shared_ptr<Tile>(std::move(tiles.extract((tilesIt++)->first).mapped()))}]() {});",
        "comment_created_at": "2024-02-02T19:10:36+00:00",
        "comment_author": "mwilsnd",
        "comment_body": ">It seems to be called somewhat rarely.\r\n\r\nIf it gets called at all then I say we should fix it, there is always a possibility of threading issues if that is allowed to happen.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1330707097",
    "pr_number": 1666,
    "pr_file": "src/mbgl/util/string_indexer.cpp",
    "created_at": "2023-09-19T21:14:24+00:00",
    "commented_code": "}\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1330707097",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1666,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1330707097",
        "commented_code": "@@ -51,20 +66,21 @@ StringIdentity StringIndexer::get(std::string_view string) {\n     }\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
        "comment_created_at": "2023-09-19T21:14:24+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Have you considered what might happen if the caller holds on to the returned `string_view` while another thread (or even the same one later on) triggers a reallocation of `buffer`?\r\n\r\nIt might be prudent to couple the read lock with the returned string_view to at least reduce such a possibility.",
        "pr_file_module": null
      },
      {
        "comment_id": "1330720899",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1666,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1330707097",
        "commented_code": "@@ -51,20 +66,21 @@ StringIdentity StringIndexer::get(std::string_view string) {\n     }\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
        "comment_created_at": "2023-09-19T21:24:04+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "I see the issue, but I don't quite follow the solution. It would be prudent to return a copy?",
        "pr_file_module": null
      },
      {
        "comment_id": "1330722155",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1666,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1330707097",
        "commented_code": "@@ -51,20 +66,21 @@ StringIdentity StringIndexer::get(std::string_view string) {\n     }\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
        "comment_created_at": "2023-09-19T21:24:51+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "That's a good point, and is another argument for something else we talking about, just using fixed-sized, pre-allocated blocks that never change, at a small cost of unused memory.\r\n\r\nThere aren't many uses for getting strings by ID outside of debugging, though, so we could just return `std::string` with minimal performance effect.",
        "pr_file_module": null
      },
      {
        "comment_id": "1330745908",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1666,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1330707097",
        "commented_code": "@@ -51,20 +66,21 @@ StringIdentity StringIndexer::get(std::string_view string) {\n     }\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
        "comment_created_at": "2023-09-19T21:54:05+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "> using fixed-sized, pre-allocated blocks that never change, at a small cost of unused memory.\r\n\r\nyeah, turning `buffer` into a vector of buffers would be a cool solution. if the vector of buffers uses move semantics to grow, that is :) or just go for a `std::deque` of buffers",
        "pr_file_module": null
      },
      {
        "comment_id": "1330754584",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1666,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1330707097",
        "commented_code": "@@ -51,20 +66,21 @@ StringIdentity StringIndexer::get(std::string_view string) {\n     }\n }\n \n-const std::string& StringIndexer::get(const StringIdentity id) {\n+std::string_view StringIndexer::get(const StringIdentity id) {\n     std::shared_lock<std::shared_mutex> readerLock(instance().sharedMutex);\n \n     const auto& identityToString = instance().identityToString;\n     assert(id < identityToString.size());\n \n-    return id < identityToString.size() ? identityToString[id] : empty;\n+    return id < identityToString.size() ? (instance().buffer.data() + identityToString[id]) : empty;",
        "comment_created_at": "2023-09-19T22:06:43+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Yes, a copy would be the safest option if you feel that is acceptable. I would consider the frequency at which strings are fetched from the buffer to determine if constructing `std::string`s is an acceptable performance trade-off.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1326473693",
    "pr_number": 1610,
    "pr_file": "src/mbgl/util/string_indexer.cpp",
    "created_at": "2023-09-14T20:18:18+00:00",
    "commented_code": "}\n \n StringIdentity StringIndexer::get(const std::string& string) {\n-    MapType& stringToIdentity = getMap();\n-    VectorType& identityToString = getVector();\n+    std::unique_lock<std::shared_mutex> writerLock(instance().sharedMutex);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1326473693",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1610,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1326473693",
        "commented_code": "@@ -9,8 +9,10 @@ const std::string empty;\n }\n \n StringIdentity StringIndexer::get(const std::string& string) {\n-    MapType& stringToIdentity = getMap();\n-    VectorType& identityToString = getVector();\n+    std::unique_lock<std::shared_mutex> writerLock(instance().sharedMutex);",
        "comment_created_at": "2023-09-14T20:18:18+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "We can just take a read lock here. If we don't find our string in the cache, we release the read lock and take a write lock to do our insertion.",
        "pr_file_module": null
      },
      {
        "comment_id": "1326823195",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1610,
        "pr_file": "src/mbgl/util/string_indexer.cpp",
        "discussion_id": "1326473693",
        "commented_code": "@@ -9,8 +9,10 @@ const std::string empty;\n }\n \n StringIdentity StringIndexer::get(const std::string& string) {\n-    MapType& stringToIdentity = getMap();\n-    VectorType& identityToString = getVector();\n+    std::unique_lock<std::shared_mutex> writerLock(instance().sharedMutex);",
        "comment_created_at": "2023-09-15T05:55:21+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "Right, I thought about it but then assumed that write contention is quite low and happening mostly in initialization phase. \r\nI'll change it the way you suggest.\r\nIf the string access is proving to be an issue we could switch to a lock-free solution using atomics and spins, so we avoid potential thread priority inversions as well.\r\n\r\nOther aspect to consider is the indexer's use of two containers, which is not ideal memory wise - in terms of size, fragmentation and allocator pressure. Considering we're only doing additions, a single _buffer_ and linear search could be more memory cache friendly at a certain scale.\r\n",
        "pr_file_module": null
      }
    ]
  }
]