[
  {
    "discussion_id": "1861417154",
    "pr_number": 3054,
    "pr_file": "platform/android/settings.gradle.kts",
    "created_at": "2024-11-28T02:00:54+00:00",
    "commented_code": "include(\":MapLibreAndroid\", \":MapLibreAndroidTestApp\", \":MapLibreAndroidLint\")\n \n-rootProject.name = \"MapLibre Native for Android\"",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1861417154",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3054,
        "pr_file": "platform/android/settings.gradle.kts",
        "discussion_id": "1861417154",
        "commented_code": "@@ -25,7 +25,7 @@ plugins {\n \n include(\":MapLibreAndroid\", \":MapLibreAndroidTestApp\", \":MapLibreAndroidLint\")\n \n-rootProject.name = \"MapLibre Native for Android\"",
        "comment_created_at": "2024-11-28T02:00:54+00:00",
        "comment_author": "sargunv",
        "comment_body": "The spaces were causing problems with Dokka, so I searched if Gradle even supports spaces in project names and found this: https://discuss.gradle.org/t/space-character-in-build-name/24164\r\n\r\nseems like spaces are discouraged (and Dokka errors out with them now)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1790086619",
    "pr_number": 2902,
    "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
    "created_at": "2024-10-07T11:57:50+00:00",
    "commented_code": "+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1790086619",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-07T11:57:50+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "This will disable `ccache` if it's located outside the list. An environmental variable check might be useful to configure the path.",
        "pr_file_module": null
      },
      {
        "comment_id": "1790181844",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-07T13:00:18+00:00",
        "comment_author": "louwers",
        "comment_body": "Good suggestion, but that is outside the scope of this PR, because this is also what we do on `main`:\r\n\r\n```groovy\r\n                        // Enable ccache if the user has installed it.\r\n                        if (file(\"/usr/bin/ccache\").exists()) {\r\n                            arguments \"-DANDROID_CCACHE=/usr/bin/ccache\"\r\n                        } else if (file(\"/usr/local/bin/ccache\").exists()) {\r\n                            arguments \"-DANDROID_CCACHE=/usr/local/bin/ccache\"\r\n                        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1790242216",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-07T13:35:51+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Indeed the main one has the same checks. I was thinking of the build file in [render-test](https://github.com/maplibre/maplibre-native/blob/d83c4ac4074fe436551ef042a92aa95c142140b5/render-test/android/app/build.gradle#L31)/[benchmark](https://github.com/maplibre/maplibre-native/blob/d83c4ac4074fe436551ef042a92aa95c142140b5/benchmark/android/app/build.gradle#L26).",
        "pr_file_module": null
      },
      {
        "comment_id": "1791526433",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-08T09:22:59+00:00",
        "comment_author": "louwers",
        "comment_body": "Could you create a new issue for this? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1791568624",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-08T09:50:48+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "https://github.com/maplibre/maplibre-native/issues/2911",
        "pr_file_module": null
      },
      {
        "comment_id": "1793645189",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/buildSrc/src/main/kotlin/NativeBuildPlugin.kt",
        "discussion_id": "1790086619",
        "commented_code": "@@ -0,0 +1,107 @@\n+import com.android.build.gradle.BaseExtension\n+import org.gradle.api.Plugin\n+import org.gradle.api.Project\n+import org.gradle.kotlin.dsl.getByType\n+\n+open class NativeBuildPlugin : Plugin<Project> {\n+    override fun apply(project: Project) {\n+        val extension = project.extensions.create(\"nativeBuild\", NativeBuildExtension::class.java)\n+        project.afterEvaluate {\n+            val targets = extension.nativeTargets\n+            project.nativeBuild(nativeTargets = targets)\n+        }\n+    }\n+}\n+\n+open class NativeBuildExtension {\n+    var nativeTargets: List<String> = listOf()\n+}\n+\n+fun Project.nativeBuild(nativeTargets: List<String>) =\n+    this.extensions.getByType<BaseExtension>().run {\n+\n+        // We sometimes want to invoke Gradle without building a native dependency, e.g. when we just want\n+        // to invoke the Java tests. When we explicitly specify an ABI of 'none', no native dependencies are\n+        // added. When another ABI is specified explicitly, we're just going to build that ABI. In all other\n+        // cases, all ABIs are built.\n+        //\n+        // When invoking from the command line or to override the device default, set `-Pmaplibre.abis=...` to\n+        // only build the desired architectures.\n+        //\n+        // When building from Android Studio, gradle.properties sets `android.buildOnlyTargetAbi=true` so that\n+        // only the architecture for the device you're running on gets built.\n+\n+\n+        var abi = \"all\"\n+        if (!project.hasProperty(\"android.injected.invoked.from.ide\") && project.hasProperty(\"maplibre.abis\")) {\n+            abi = project.property(\"maplibre.abis\") as String\n+        }\n+\n+        if (abi != \"none\") {\n+            externalNativeBuild {\n+                cmake {\n+                    path = file(\"../MapLibreAndroid/src/cpp/CMakeLists.txt\")\n+                    version = Versions.cmakeVersion\n+                }\n+            }\n+        }\n+\n+        // Determine the C++ STL being used.\n+        var stl = \"c++_static\"\n+        if (project.hasProperty(\"mapbox.stl\")) {\n+            stl = project.property(\"mapbox.stl\") as String\n+        }\n+\n+        defaultConfig {\n+            if (abi != \"none\") {\n+                externalNativeBuild {\n+                    cmake {\n+                        arguments.addAll(\n+                            listOf(\n+                                \"-DANDROID_TOOLCHAIN=clang\",\n+                                \"-DANDROID_STL=$stl\",\n+                                \"-DANDROID_CPP_FEATURES=exceptions\",\n+                                \"-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON\"\n+                            )\n+                        )\n+\n+                        // Enable ccache if available.\n+                        val ccachePaths = listOf(\"/usr/bin/ccache\", \"/usr/local/bin/ccache\")",
        "comment_created_at": "2024-10-09T14:34:11+00:00",
        "comment_author": "westnordost",
        "comment_body": "Note that the current implementation in this PR will add two `-DANDROID_CCACHE=` arguments if both \"/usr/bin/ccache\" and \"/usr/local/bin/ccache\" exist. This is a change in behavior as from the groovy version.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1793576578",
    "pr_number": 2902,
    "pr_file": "platform/android/MapLibreAndroid/build.gradle.kts",
    "created_at": "2024-10-09T13:55:10+00:00",
    "commented_code": "+import org.jetbrains.dokka.gradle.DokkaTask\n+\n+plugins {\n+    alias(libs.plugins.kotlinter)\n+    alias(libs.plugins.dokka)\n+    id(\"com.android.library\")\n+    id(\"com.jaredsburrows.license\")\n+    kotlin(\"android\")\n+    id(\"maplibre.download-vulkan-validation\")\n+    id(\"maplibre.gradle-checkstyle\")\n+    id(\"maplibre.gradle-dependencies-graph\")\n+    id(\"maplibre.android-nitpick\")\n+    id(\"maplibre.gradle-publish\")\n+    id(\"maplibre.artifact-settings\")\n+}\n+\n+dependencies {\n+    lintChecks(project(\":MapLibreAndroidLint\"))\n+    api(libs.maplibreJavaGeoJSON)\n+    api(libs.maplibreGestures)\n+\n+    implementation(libs.maplibreJavaTurf)\n+    implementation(libs.supportAnnotations)\n+    implementation(libs.supportFragmentV4)\n+    implementation(libs.okhttp3)\n+    implementation(libs.timber)\n+    implementation(libs.interpolator)\n+\n+    testImplementation(libs.junit)\n+    testImplementation(libs.mockito)\n+    testImplementation(libs.mockk)\n+    testImplementation(libs.robolectric)\n+    testImplementation(libs.commonsIO)\n+    testImplementation(libs.assertjcore)\n+\n+    androidTestImplementation(libs.testRunner)\n+    androidTestImplementation(libs.testRules)\n+}\n+\n+tasks.withType<DokkaTask> {\n+    moduleName.set(\"MapLibre Native Android\")\n+\n+    dokkaSourceSets {\n+        configureEach {\n+            includes.from(\"Module.md\")\n+        }\n+    }\n+}\n+\n+android {\n+    defaultConfig {\n+        compileSdk = 34\n+        minSdk = 21\n+        targetSdk = 33\n+        buildConfigField(\"String\", \"GIT_REVISION_SHORT\", \"\\\"${getGitRevision()}\\\"\")\n+        buildConfigField(\"String\", \"GIT_REVISION\", \"\\\"${getGitRevision(false)}\\\"\")\n+        buildConfigField(\n+            \"String\",\n+            \"MAPLIBRE_VERSION_STRING\",\n+            \"\\\"MapLibre Native/${project.property(\"VERSION_NAME\")}\\\"\"\n+        )\n+        consumerProguardFiles(\"proguard-rules.pro\")\n+\n+        externalNativeBuild {\n+            cmake {\n+                arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+            }\n+        }\n+    }\n+\n+    flavorDimensions += \"renderer\"\n+    productFlavors {\n+        create(\"legacy\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+                }\n+            }\n+        }\n+        create(\"drawable\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                }\n+            }\n+        }\n+        create(\"vulkan\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                    arguments(\"-DMLN_WITH_OPENGL=OFF\", \"-DMLN_WITH_VULKAN=ON\")\n+                }\n+            }\n+        }\n+    }\n+\n+    sourceSets {\n+        getByName(\"legacy\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+        getByName(\"drawable\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+    }\n+\n+    // Build native libraries\n+    val nativeTargets = mutableListOf(\"maplibre\")\n+    if (project.hasProperty(\"mapbox.with_test\")) {\n+        nativeTargets.add(\"mbgl-test\")\n+    }\n+    if (project.hasProperty(\"mapbox.with_benchmark\")) {\n+        nativeTargets.add(\"mbgl-benchmark\")\n+    }\n+    nativeBuild(nativeTargets)\n+\n+    // Avoid naming conflicts, force usage of prefix\n+    resourcePrefix(\"maplibre_\")\n+\n+    sourceSets {\n+        getByName(\"main\") {\n+            res.srcDirs(\"src/main/res-public\")\n+        }\n+    }\n+\n+    testOptions {\n+        unitTests {\n+            isReturnDefaultValues = true\n+\n+            // Robolectric 4.0 required config\n+            // http://robolectric.org/migrating/#migrating-to-40\n+            isIncludeAndroidResources = true\n+        }\n+    }\n+\n+    buildTypes {\n+        getByName(\"debug\") {\n+            isTestCoverageEnabled = false\n+            isJniDebuggable = true\n+//            debuggable = true\n+        }\n+    }\n+\n+    namespace = \"org.maplibre.android\"\n+\n+    lint {\n+        checkAllWarnings = true\n+        disable += listOf(\n+            \"MissingTranslation\",\n+            \"TypographyQuotes\",\n+            \"ObsoleteLintCustomCheck\",\n+            \"MissingPermission\",\n+            \"WrongThreadInterprocedural\"\n+        )\n+        warningsAsErrors = false\n+    }\n+\n+    buildFeatures {\n+        buildConfig = true\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility = JavaVersion.VERSION_11\n+        targetCompatibility = JavaVersion.VERSION_11\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = \"11\"\n+    }\n+}\n+\n+licenseReport {\n+    generateHtmlReport = false\n+    generateJsonReport = true\n+    copyHtmlReportToAssets = false\n+    copyJsonReportToAssets = false\n+}\n+\n+fun getGitRevision(shortRev: Boolean = true): String {\n+    val cmd = if (shortRev) \"git rev-parse --short HEAD\" else \"git rev-parse HEAD\"\n+    val proc = Runtime.getRuntime().exec(cmd)\n+    return proc.inputStream.bufferedReader().readText().trim()\n+}\n+//in gradle kotlin dsl checkstyle is failing due to this\n+/*configurations {\n+    all {\n+        exclude(group = \"commons-logging\", module = \"commons-logging\")\n+        exclude(group = \"commons-collections\", module = \"commons-collections\")\n+    }\n+}*/",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1793576578",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/MapLibreAndroid/build.gradle.kts",
        "discussion_id": "1793576578",
        "commented_code": "@@ -0,0 +1,196 @@\n+import org.jetbrains.dokka.gradle.DokkaTask\n+\n+plugins {\n+    alias(libs.plugins.kotlinter)\n+    alias(libs.plugins.dokka)\n+    id(\"com.android.library\")\n+    id(\"com.jaredsburrows.license\")\n+    kotlin(\"android\")\n+    id(\"maplibre.download-vulkan-validation\")\n+    id(\"maplibre.gradle-checkstyle\")\n+    id(\"maplibre.gradle-dependencies-graph\")\n+    id(\"maplibre.android-nitpick\")\n+    id(\"maplibre.gradle-publish\")\n+    id(\"maplibre.artifact-settings\")\n+}\n+\n+dependencies {\n+    lintChecks(project(\":MapLibreAndroidLint\"))\n+    api(libs.maplibreJavaGeoJSON)\n+    api(libs.maplibreGestures)\n+\n+    implementation(libs.maplibreJavaTurf)\n+    implementation(libs.supportAnnotations)\n+    implementation(libs.supportFragmentV4)\n+    implementation(libs.okhttp3)\n+    implementation(libs.timber)\n+    implementation(libs.interpolator)\n+\n+    testImplementation(libs.junit)\n+    testImplementation(libs.mockito)\n+    testImplementation(libs.mockk)\n+    testImplementation(libs.robolectric)\n+    testImplementation(libs.commonsIO)\n+    testImplementation(libs.assertjcore)\n+\n+    androidTestImplementation(libs.testRunner)\n+    androidTestImplementation(libs.testRules)\n+}\n+\n+tasks.withType<DokkaTask> {\n+    moduleName.set(\"MapLibre Native Android\")\n+\n+    dokkaSourceSets {\n+        configureEach {\n+            includes.from(\"Module.md\")\n+        }\n+    }\n+}\n+\n+android {\n+    defaultConfig {\n+        compileSdk = 34\n+        minSdk = 21\n+        targetSdk = 33\n+        buildConfigField(\"String\", \"GIT_REVISION_SHORT\", \"\\\"${getGitRevision()}\\\"\")\n+        buildConfigField(\"String\", \"GIT_REVISION\", \"\\\"${getGitRevision(false)}\\\"\")\n+        buildConfigField(\n+            \"String\",\n+            \"MAPLIBRE_VERSION_STRING\",\n+            \"\\\"MapLibre Native/${project.property(\"VERSION_NAME\")}\\\"\"\n+        )\n+        consumerProguardFiles(\"proguard-rules.pro\")\n+\n+        externalNativeBuild {\n+            cmake {\n+                arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+            }\n+        }\n+    }\n+\n+    flavorDimensions += \"renderer\"\n+    productFlavors {\n+        create(\"legacy\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+                }\n+            }\n+        }\n+        create(\"drawable\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                }\n+            }\n+        }\n+        create(\"vulkan\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                    arguments(\"-DMLN_WITH_OPENGL=OFF\", \"-DMLN_WITH_VULKAN=ON\")\n+                }\n+            }\n+        }\n+    }\n+\n+    sourceSets {\n+        getByName(\"legacy\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+        getByName(\"drawable\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+    }\n+\n+    // Build native libraries\n+    val nativeTargets = mutableListOf(\"maplibre\")\n+    if (project.hasProperty(\"mapbox.with_test\")) {\n+        nativeTargets.add(\"mbgl-test\")\n+    }\n+    if (project.hasProperty(\"mapbox.with_benchmark\")) {\n+        nativeTargets.add(\"mbgl-benchmark\")\n+    }\n+    nativeBuild(nativeTargets)\n+\n+    // Avoid naming conflicts, force usage of prefix\n+    resourcePrefix(\"maplibre_\")\n+\n+    sourceSets {\n+        getByName(\"main\") {\n+            res.srcDirs(\"src/main/res-public\")\n+        }\n+    }\n+\n+    testOptions {\n+        unitTests {\n+            isReturnDefaultValues = true\n+\n+            // Robolectric 4.0 required config\n+            // http://robolectric.org/migrating/#migrating-to-40\n+            isIncludeAndroidResources = true\n+        }\n+    }\n+\n+    buildTypes {\n+        getByName(\"debug\") {\n+            isTestCoverageEnabled = false\n+            isJniDebuggable = true\n+//            debuggable = true\n+        }\n+    }\n+\n+    namespace = \"org.maplibre.android\"\n+\n+    lint {\n+        checkAllWarnings = true\n+        disable += listOf(\n+            \"MissingTranslation\",\n+            \"TypographyQuotes\",\n+            \"ObsoleteLintCustomCheck\",\n+            \"MissingPermission\",\n+            \"WrongThreadInterprocedural\"\n+        )\n+        warningsAsErrors = false\n+    }\n+\n+    buildFeatures {\n+        buildConfig = true\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility = JavaVersion.VERSION_11\n+        targetCompatibility = JavaVersion.VERSION_11\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = \"11\"\n+    }\n+}\n+\n+licenseReport {\n+    generateHtmlReport = false\n+    generateJsonReport = true\n+    copyHtmlReportToAssets = false\n+    copyJsonReportToAssets = false\n+}\n+\n+fun getGitRevision(shortRev: Boolean = true): String {\n+    val cmd = if (shortRev) \"git rev-parse --short HEAD\" else \"git rev-parse HEAD\"\n+    val proc = Runtime.getRuntime().exec(cmd)\n+    return proc.inputStream.bufferedReader().readText().trim()\n+}\n+//in gradle kotlin dsl checkstyle is failing due to this\n+/*configurations {\n+    all {\n+        exclude(group = \"commons-logging\", module = \"commons-logging\")\n+        exclude(group = \"commons-collections\", module = \"commons-collections\")\n+    }\n+}*/",
        "comment_created_at": "2024-10-09T13:55:10+00:00",
        "comment_author": "westnordost",
        "comment_body": "but if it is commented out, the commons logging and collections stuff is included, so it is a change in behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "1793826484",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2902,
        "pr_file": "platform/android/MapLibreAndroid/build.gradle.kts",
        "discussion_id": "1793576578",
        "commented_code": "@@ -0,0 +1,196 @@\n+import org.jetbrains.dokka.gradle.DokkaTask\n+\n+plugins {\n+    alias(libs.plugins.kotlinter)\n+    alias(libs.plugins.dokka)\n+    id(\"com.android.library\")\n+    id(\"com.jaredsburrows.license\")\n+    kotlin(\"android\")\n+    id(\"maplibre.download-vulkan-validation\")\n+    id(\"maplibre.gradle-checkstyle\")\n+    id(\"maplibre.gradle-dependencies-graph\")\n+    id(\"maplibre.android-nitpick\")\n+    id(\"maplibre.gradle-publish\")\n+    id(\"maplibre.artifact-settings\")\n+}\n+\n+dependencies {\n+    lintChecks(project(\":MapLibreAndroidLint\"))\n+    api(libs.maplibreJavaGeoJSON)\n+    api(libs.maplibreGestures)\n+\n+    implementation(libs.maplibreJavaTurf)\n+    implementation(libs.supportAnnotations)\n+    implementation(libs.supportFragmentV4)\n+    implementation(libs.okhttp3)\n+    implementation(libs.timber)\n+    implementation(libs.interpolator)\n+\n+    testImplementation(libs.junit)\n+    testImplementation(libs.mockito)\n+    testImplementation(libs.mockk)\n+    testImplementation(libs.robolectric)\n+    testImplementation(libs.commonsIO)\n+    testImplementation(libs.assertjcore)\n+\n+    androidTestImplementation(libs.testRunner)\n+    androidTestImplementation(libs.testRules)\n+}\n+\n+tasks.withType<DokkaTask> {\n+    moduleName.set(\"MapLibre Native Android\")\n+\n+    dokkaSourceSets {\n+        configureEach {\n+            includes.from(\"Module.md\")\n+        }\n+    }\n+}\n+\n+android {\n+    defaultConfig {\n+        compileSdk = 34\n+        minSdk = 21\n+        targetSdk = 33\n+        buildConfigField(\"String\", \"GIT_REVISION_SHORT\", \"\\\"${getGitRevision()}\\\"\")\n+        buildConfigField(\"String\", \"GIT_REVISION\", \"\\\"${getGitRevision(false)}\\\"\")\n+        buildConfigField(\n+            \"String\",\n+            \"MAPLIBRE_VERSION_STRING\",\n+            \"\\\"MapLibre Native/${project.property(\"VERSION_NAME\")}\\\"\"\n+        )\n+        consumerProguardFiles(\"proguard-rules.pro\")\n+\n+        externalNativeBuild {\n+            cmake {\n+                arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+            }\n+        }\n+    }\n+\n+    flavorDimensions += \"renderer\"\n+    productFlavors {\n+        create(\"legacy\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=ON\", \"-DMLN_DRAWABLE_RENDERER=OFF\")\n+                }\n+            }\n+        }\n+        create(\"drawable\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                }\n+            }\n+        }\n+        create(\"vulkan\") {\n+            dimension = \"renderer\"\n+            externalNativeBuild {\n+                cmake {\n+                    arguments(\"-DMLN_LEGACY_RENDERER=OFF\", \"-DMLN_DRAWABLE_RENDERER=ON\")\n+                    arguments(\"-DMLN_WITH_OPENGL=OFF\", \"-DMLN_WITH_VULKAN=ON\")\n+                }\n+            }\n+        }\n+    }\n+\n+    sourceSets {\n+        getByName(\"legacy\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+        getByName(\"drawable\") {\n+            java.srcDirs(\"src/opengl/java/\")\n+        }\n+    }\n+\n+    // Build native libraries\n+    val nativeTargets = mutableListOf(\"maplibre\")\n+    if (project.hasProperty(\"mapbox.with_test\")) {\n+        nativeTargets.add(\"mbgl-test\")\n+    }\n+    if (project.hasProperty(\"mapbox.with_benchmark\")) {\n+        nativeTargets.add(\"mbgl-benchmark\")\n+    }\n+    nativeBuild(nativeTargets)\n+\n+    // Avoid naming conflicts, force usage of prefix\n+    resourcePrefix(\"maplibre_\")\n+\n+    sourceSets {\n+        getByName(\"main\") {\n+            res.srcDirs(\"src/main/res-public\")\n+        }\n+    }\n+\n+    testOptions {\n+        unitTests {\n+            isReturnDefaultValues = true\n+\n+            // Robolectric 4.0 required config\n+            // http://robolectric.org/migrating/#migrating-to-40\n+            isIncludeAndroidResources = true\n+        }\n+    }\n+\n+    buildTypes {\n+        getByName(\"debug\") {\n+            isTestCoverageEnabled = false\n+            isJniDebuggable = true\n+//            debuggable = true\n+        }\n+    }\n+\n+    namespace = \"org.maplibre.android\"\n+\n+    lint {\n+        checkAllWarnings = true\n+        disable += listOf(\n+            \"MissingTranslation\",\n+            \"TypographyQuotes\",\n+            \"ObsoleteLintCustomCheck\",\n+            \"MissingPermission\",\n+            \"WrongThreadInterprocedural\"\n+        )\n+        warningsAsErrors = false\n+    }\n+\n+    buildFeatures {\n+        buildConfig = true\n+    }\n+\n+    compileOptions {\n+        sourceCompatibility = JavaVersion.VERSION_11\n+        targetCompatibility = JavaVersion.VERSION_11\n+    }\n+\n+    kotlinOptions {\n+        jvmTarget = \"11\"\n+    }\n+}\n+\n+licenseReport {\n+    generateHtmlReport = false\n+    generateJsonReport = true\n+    copyHtmlReportToAssets = false\n+    copyJsonReportToAssets = false\n+}\n+\n+fun getGitRevision(shortRev: Boolean = true): String {\n+    val cmd = if (shortRev) \"git rev-parse --short HEAD\" else \"git rev-parse HEAD\"\n+    val proc = Runtime.getRuntime().exec(cmd)\n+    return proc.inputStream.bufferedReader().readText().trim()\n+}\n+//in gradle kotlin dsl checkstyle is failing due to this\n+/*configurations {\n+    all {\n+        exclude(group = \"commons-logging\", module = \"commons-logging\")\n+        exclude(group = \"commons-collections\", module = \"commons-collections\")\n+    }\n+}*/",
        "comment_created_at": "2024-10-09T16:31:05+00:00",
        "comment_author": "kaushalbx",
        "comment_body": "We can replace it with this then it is not  affecting checkstyle.\r\n\r\nconfigurations {\r\n    getByName(\"implementation\") {\r\n        exclude(group = \"commons-logging\", module = \"commons-logging\")\r\n        exclude(group = \"commons-collections\", module = \"commons-collections\")\r\n    }\r\n}",
        "pr_file_module": null
      }
    ]
  }
]