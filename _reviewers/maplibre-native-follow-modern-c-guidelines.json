[
  {
    "discussion_id": "2107617763",
    "pr_number": 3430,
    "pr_file": "src/mbgl/plugins/plugin_layer_impl.hpp",
    "created_at": "2025-05-26T16:14:13+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/style/layer_impl.hpp>\n+#include <mbgl/plugins/plugin_layer.hpp>\n+// #include <mbgl/style/layers/plugin_layer_properties.hpp>\n+#include <mbgl/style/conversion_impl.hpp>\n+\n+// ---------------------------------------------------\n+// Properties stuff\n+#include <map>\n+#include <vector>\n+#include <mbgl/style/types.hpp>\n+#include <mbgl/style/layer_properties.hpp>\n+// #include <mbgl/style/layers/heatmap_layer.hpp>\n+#include <mbgl/style/layout_property.hpp>\n+#include <mbgl/style/paint_property.hpp>\n+#include <mbgl/style/properties.hpp>\n+#include <mbgl/shaders/attributes.hpp>\n+#include <mbgl/shaders/uniforms.hpp>\n+\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/style/conversion/property_value.hpp>\n+\n+// Property types\n+#include <mbgl/util/color.hpp>\n+\n+/*\n+//#include <mbgl/style/layers/line_layer.hpp>\n+#include <mbgl/style/layer.hpp>\n+#include <mbgl/style/filter.hpp>\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/renderer/render_layer.hpp>\n+*/\n+// ---------------------------------------------------\n+\n+#define INCLUDE_DATA_DRIVEN_COLOR_PROPERTY 1\n+\n+namespace mbgl {\n+namespace style {\n+\n+using namespace conversion;\n+\n+struct SingleFloatProperty : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+    static float defaultValue() { return 1.f; }\n+};\n+\n+#if INCLUDE_DATA_DRIVEN_COLOR_PROPERTY\n+struct DataDrivenColorProperty : DataDrivenPaintProperty<mbgl::Color, attributes::color, uniforms::color> {\n+    static mbgl::Color defaultValue() { return mbgl::Color::black(); }\n+    static constexpr auto expressionType() { return expression::type::ColorType{}; };\n+    using EvaluatorType = DataDrivenPropertyEvaluator<Color, false>;\n+};\n+#endif\n+\n+/*\n+ Unique PluginLayerProperty types for now\n+ SingleFloat:   DataDrivenPaintProperty<float>\n+ Color:         DataDrivenPaintProperty<Color>\n+\n+ Float2:        DataDrivenPaintProperty<std::array<float, 2>>\n+ Alignment:     DataDrivenPaintProperty<AlignmentType>\n+\n+\n+ Unique property types (from Tim)\n+ : DataDrivenLayoutProperty<expression::Formatted>\n+ : DataDrivenLayoutProperty<expression::Image>\n+ : DataDrivenLayoutProperty<float>\n+ : DataDrivenLayoutProperty<LineJoinType>\n+ : DataDrivenLayoutProperty<Padding>\n+ : DataDrivenLayoutProperty<std::array<float, 2>>\n+ : DataDrivenLayoutProperty<std::vector<std::string>>\n+ : DataDrivenLayoutProperty<SymbolAnchorType>\n+ : DataDrivenLayoutProperty<TextJustifyType>\n+ : DataDrivenLayoutProperty<TextTransformType>\n+ : DataDrivenLayoutProperty<VariableAnchorOffsetCollection>\n+ : DataDrivenPaintProperty<Color, attributes::color, uniforms::color>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color, true>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color>\n+ : DataDrivenPaintProperty<Color, attributes::halo_color, uniforms::halo_color>\n+ : DataDrivenPaintProperty<Color, attributes::outline_color, uniforms::outline_color>\n+ : DataDrivenPaintProperty<Color, attributes::stroke_color, uniforms::stroke_color>\n+ : DataDrivenPaintProperty<float, attributes::base, uniforms::base>\n+ : DataDrivenPaintProperty<float, attributes::blur, uniforms::blur>\n+ : DataDrivenPaintProperty<float, attributes::floorwidth, uniforms::floorwidth>\n+ : DataDrivenPaintProperty<float, attributes::gapwidth, uniforms::gapwidth>\n+ : DataDrivenPaintProperty<float, attributes::halo_blur, uniforms::halo_blur>\n+ : DataDrivenPaintProperty<float, attributes::halo_width, uniforms::halo_width>\n+ : DataDrivenPaintProperty<float, attributes::height, uniforms::height>\n+ : DataDrivenPaintProperty<float, attributes::offset, uniforms::offset>\n+ : DataDrivenPaintProperty<float, attributes::opacity, uniforms::opacity>\n+ : DataDrivenPaintProperty<float, attributes::radius, uniforms::radius>\n+ : DataDrivenPaintProperty<float, attributes::stroke_opacity, uniforms::stroke_opacity>\n+ : DataDrivenPaintProperty<float, attributes::stroke_width, uniforms::stroke_width>\n+ : DataDrivenPaintProperty<float, attributes::weight, uniforms::weight>\n+ : DataDrivenPaintProperty<float, attributes::width, uniforms::width>\n+ : LayoutProperty<AlignmentType>\n+ : LayoutProperty<bool>\n+ : LayoutProperty<expression::Image>\n+ : LayoutProperty<float>\n+ : LayoutProperty<IconTextFitType>\n+ : LayoutProperty<LineCapType>\n+ : LayoutProperty<std::array<float, 4>>\n+ : LayoutProperty<std::vector<TextVariableAnchorType>>\n+ : LayoutProperty<std::vector<TextWritingModeType>>\n+ : LayoutProperty<SymbolPlacementType>\n+ : LayoutProperty<SymbolZOrderType>\n+ : PaintProperty<AlignmentType>\n+ : PaintProperty<bool>\n+ : PaintProperty<CirclePitchScaleType>\n+ : PaintProperty<Color>\n+ : PaintProperty<float>\n+ : PaintProperty<HillshadeIlluminationAnchorType>\n+ : PaintProperty<RasterResamplingType>\n+ : PaintProperty<Rotation>\n+ : PaintProperty<std::array<double, 3>>\n+ : PaintProperty<std::array<float, 2>>\n+ : PaintProperty<TranslateAnchorType>\n+ */\n+\n+// struct Scale : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+//     static float defaultValue() { return 1.f; }\n+// };\n+\n+// class PluginPaintProperties : public Properties<Scale> {};\n+\n+// template <>\n+// struct Converter<Scale> {\n+//     std::optional<Scale> operator()(const Convertible& value,\n+//                                     Error& error,\n+//                                     bool /* allowDataExpressions */ = true,\n+//                                     bool /* convertTokens */ = false) const;\n+// };\n+//\n+// template <>\n+// struct Converter<PropertyValue<Scale>> {\n+//     std::optional<PropertyValue<Scale>> operator()(const Convertible& value,\n+//                                                    Error& error,\n+//                                                    bool /* allowDataExpressions */ = true,\n+//                                                    bool /* convertTokens */ = false) const;\n+// };\n+\n+//\n+// template std::optional<PropertyValue<Scale>> Converter<PropertyValue<Scale>>::operator()(conversion::Convertible\n+// const&,\n+//                                                                                         conversion::Error&,\n+//                                                                                         bool,\n+//                                                                                         bool) const;\n+\n+class PluginLayerProperty {\n+public:\n+    typedef enum {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2107617763",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "src/mbgl/plugins/plugin_layer_impl.hpp",
        "discussion_id": "2107617763",
        "commented_code": "@@ -0,0 +1,255 @@\n+#pragma once\n+\n+#include <mbgl/style/layer_impl.hpp>\n+#include <mbgl/plugins/plugin_layer.hpp>\n+// #include <mbgl/style/layers/plugin_layer_properties.hpp>\n+#include <mbgl/style/conversion_impl.hpp>\n+\n+// ---------------------------------------------------\n+// Properties stuff\n+#include <map>\n+#include <vector>\n+#include <mbgl/style/types.hpp>\n+#include <mbgl/style/layer_properties.hpp>\n+// #include <mbgl/style/layers/heatmap_layer.hpp>\n+#include <mbgl/style/layout_property.hpp>\n+#include <mbgl/style/paint_property.hpp>\n+#include <mbgl/style/properties.hpp>\n+#include <mbgl/shaders/attributes.hpp>\n+#include <mbgl/shaders/uniforms.hpp>\n+\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/style/conversion/property_value.hpp>\n+\n+// Property types\n+#include <mbgl/util/color.hpp>\n+\n+/*\n+//#include <mbgl/style/layers/line_layer.hpp>\n+#include <mbgl/style/layer.hpp>\n+#include <mbgl/style/filter.hpp>\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/renderer/render_layer.hpp>\n+*/\n+// ---------------------------------------------------\n+\n+#define INCLUDE_DATA_DRIVEN_COLOR_PROPERTY 1\n+\n+namespace mbgl {\n+namespace style {\n+\n+using namespace conversion;\n+\n+struct SingleFloatProperty : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+    static float defaultValue() { return 1.f; }\n+};\n+\n+#if INCLUDE_DATA_DRIVEN_COLOR_PROPERTY\n+struct DataDrivenColorProperty : DataDrivenPaintProperty<mbgl::Color, attributes::color, uniforms::color> {\n+    static mbgl::Color defaultValue() { return mbgl::Color::black(); }\n+    static constexpr auto expressionType() { return expression::type::ColorType{}; };\n+    using EvaluatorType = DataDrivenPropertyEvaluator<Color, false>;\n+};\n+#endif\n+\n+/*\n+ Unique PluginLayerProperty types for now\n+ SingleFloat:   DataDrivenPaintProperty<float>\n+ Color:         DataDrivenPaintProperty<Color>\n+\n+ Float2:        DataDrivenPaintProperty<std::array<float, 2>>\n+ Alignment:     DataDrivenPaintProperty<AlignmentType>\n+\n+\n+ Unique property types (from Tim)\n+ : DataDrivenLayoutProperty<expression::Formatted>\n+ : DataDrivenLayoutProperty<expression::Image>\n+ : DataDrivenLayoutProperty<float>\n+ : DataDrivenLayoutProperty<LineJoinType>\n+ : DataDrivenLayoutProperty<Padding>\n+ : DataDrivenLayoutProperty<std::array<float, 2>>\n+ : DataDrivenLayoutProperty<std::vector<std::string>>\n+ : DataDrivenLayoutProperty<SymbolAnchorType>\n+ : DataDrivenLayoutProperty<TextJustifyType>\n+ : DataDrivenLayoutProperty<TextTransformType>\n+ : DataDrivenLayoutProperty<VariableAnchorOffsetCollection>\n+ : DataDrivenPaintProperty<Color, attributes::color, uniforms::color>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color, true>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color>\n+ : DataDrivenPaintProperty<Color, attributes::halo_color, uniforms::halo_color>\n+ : DataDrivenPaintProperty<Color, attributes::outline_color, uniforms::outline_color>\n+ : DataDrivenPaintProperty<Color, attributes::stroke_color, uniforms::stroke_color>\n+ : DataDrivenPaintProperty<float, attributes::base, uniforms::base>\n+ : DataDrivenPaintProperty<float, attributes::blur, uniforms::blur>\n+ : DataDrivenPaintProperty<float, attributes::floorwidth, uniforms::floorwidth>\n+ : DataDrivenPaintProperty<float, attributes::gapwidth, uniforms::gapwidth>\n+ : DataDrivenPaintProperty<float, attributes::halo_blur, uniforms::halo_blur>\n+ : DataDrivenPaintProperty<float, attributes::halo_width, uniforms::halo_width>\n+ : DataDrivenPaintProperty<float, attributes::height, uniforms::height>\n+ : DataDrivenPaintProperty<float, attributes::offset, uniforms::offset>\n+ : DataDrivenPaintProperty<float, attributes::opacity, uniforms::opacity>\n+ : DataDrivenPaintProperty<float, attributes::radius, uniforms::radius>\n+ : DataDrivenPaintProperty<float, attributes::stroke_opacity, uniforms::stroke_opacity>\n+ : DataDrivenPaintProperty<float, attributes::stroke_width, uniforms::stroke_width>\n+ : DataDrivenPaintProperty<float, attributes::weight, uniforms::weight>\n+ : DataDrivenPaintProperty<float, attributes::width, uniforms::width>\n+ : LayoutProperty<AlignmentType>\n+ : LayoutProperty<bool>\n+ : LayoutProperty<expression::Image>\n+ : LayoutProperty<float>\n+ : LayoutProperty<IconTextFitType>\n+ : LayoutProperty<LineCapType>\n+ : LayoutProperty<std::array<float, 4>>\n+ : LayoutProperty<std::vector<TextVariableAnchorType>>\n+ : LayoutProperty<std::vector<TextWritingModeType>>\n+ : LayoutProperty<SymbolPlacementType>\n+ : LayoutProperty<SymbolZOrderType>\n+ : PaintProperty<AlignmentType>\n+ : PaintProperty<bool>\n+ : PaintProperty<CirclePitchScaleType>\n+ : PaintProperty<Color>\n+ : PaintProperty<float>\n+ : PaintProperty<HillshadeIlluminationAnchorType>\n+ : PaintProperty<RasterResamplingType>\n+ : PaintProperty<Rotation>\n+ : PaintProperty<std::array<double, 3>>\n+ : PaintProperty<std::array<float, 2>>\n+ : PaintProperty<TranslateAnchorType>\n+ */\n+\n+// struct Scale : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+//     static float defaultValue() { return 1.f; }\n+// };\n+\n+// class PluginPaintProperties : public Properties<Scale> {};\n+\n+// template <>\n+// struct Converter<Scale> {\n+//     std::optional<Scale> operator()(const Convertible& value,\n+//                                     Error& error,\n+//                                     bool /* allowDataExpressions */ = true,\n+//                                     bool /* convertTokens */ = false) const;\n+// };\n+//\n+// template <>\n+// struct Converter<PropertyValue<Scale>> {\n+//     std::optional<PropertyValue<Scale>> operator()(const Convertible& value,\n+//                                                    Error& error,\n+//                                                    bool /* allowDataExpressions */ = true,\n+//                                                    bool /* convertTokens */ = false) const;\n+// };\n+\n+//\n+// template std::optional<PropertyValue<Scale>> Converter<PropertyValue<Scale>>::operator()(conversion::Convertible\n+// const&,\n+//                                                                                         conversion::Error&,\n+//                                                                                         bool,\n+//                                                                                         bool) const;\n+\n+class PluginLayerProperty {\n+public:\n+    typedef enum {",
        "comment_created_at": "2025-05-26T16:14:13+00:00",
        "comment_author": "louwers",
        "comment_body": "Prefer enum class https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Renum-class",
        "pr_file_module": null
      },
      {
        "comment_id": "2109625018",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "src/mbgl/plugins/plugin_layer_impl.hpp",
        "discussion_id": "2107617763",
        "commented_code": "@@ -0,0 +1,255 @@\n+#pragma once\n+\n+#include <mbgl/style/layer_impl.hpp>\n+#include <mbgl/plugins/plugin_layer.hpp>\n+// #include <mbgl/style/layers/plugin_layer_properties.hpp>\n+#include <mbgl/style/conversion_impl.hpp>\n+\n+// ---------------------------------------------------\n+// Properties stuff\n+#include <map>\n+#include <vector>\n+#include <mbgl/style/types.hpp>\n+#include <mbgl/style/layer_properties.hpp>\n+// #include <mbgl/style/layers/heatmap_layer.hpp>\n+#include <mbgl/style/layout_property.hpp>\n+#include <mbgl/style/paint_property.hpp>\n+#include <mbgl/style/properties.hpp>\n+#include <mbgl/shaders/attributes.hpp>\n+#include <mbgl/shaders/uniforms.hpp>\n+\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/style/conversion/property_value.hpp>\n+\n+// Property types\n+#include <mbgl/util/color.hpp>\n+\n+/*\n+//#include <mbgl/style/layers/line_layer.hpp>\n+#include <mbgl/style/layer.hpp>\n+#include <mbgl/style/filter.hpp>\n+#include <mbgl/style/property_value.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/renderer/render_layer.hpp>\n+*/\n+// ---------------------------------------------------\n+\n+#define INCLUDE_DATA_DRIVEN_COLOR_PROPERTY 1\n+\n+namespace mbgl {\n+namespace style {\n+\n+using namespace conversion;\n+\n+struct SingleFloatProperty : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+    static float defaultValue() { return 1.f; }\n+};\n+\n+#if INCLUDE_DATA_DRIVEN_COLOR_PROPERTY\n+struct DataDrivenColorProperty : DataDrivenPaintProperty<mbgl::Color, attributes::color, uniforms::color> {\n+    static mbgl::Color defaultValue() { return mbgl::Color::black(); }\n+    static constexpr auto expressionType() { return expression::type::ColorType{}; };\n+    using EvaluatorType = DataDrivenPropertyEvaluator<Color, false>;\n+};\n+#endif\n+\n+/*\n+ Unique PluginLayerProperty types for now\n+ SingleFloat:   DataDrivenPaintProperty<float>\n+ Color:         DataDrivenPaintProperty<Color>\n+\n+ Float2:        DataDrivenPaintProperty<std::array<float, 2>>\n+ Alignment:     DataDrivenPaintProperty<AlignmentType>\n+\n+\n+ Unique property types (from Tim)\n+ : DataDrivenLayoutProperty<expression::Formatted>\n+ : DataDrivenLayoutProperty<expression::Image>\n+ : DataDrivenLayoutProperty<float>\n+ : DataDrivenLayoutProperty<LineJoinType>\n+ : DataDrivenLayoutProperty<Padding>\n+ : DataDrivenLayoutProperty<std::array<float, 2>>\n+ : DataDrivenLayoutProperty<std::vector<std::string>>\n+ : DataDrivenLayoutProperty<SymbolAnchorType>\n+ : DataDrivenLayoutProperty<TextJustifyType>\n+ : DataDrivenLayoutProperty<TextTransformType>\n+ : DataDrivenLayoutProperty<VariableAnchorOffsetCollection>\n+ : DataDrivenPaintProperty<Color, attributes::color, uniforms::color>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color, true>\n+ : DataDrivenPaintProperty<Color, attributes::fill_color, uniforms::fill_color>\n+ : DataDrivenPaintProperty<Color, attributes::halo_color, uniforms::halo_color>\n+ : DataDrivenPaintProperty<Color, attributes::outline_color, uniforms::outline_color>\n+ : DataDrivenPaintProperty<Color, attributes::stroke_color, uniforms::stroke_color>\n+ : DataDrivenPaintProperty<float, attributes::base, uniforms::base>\n+ : DataDrivenPaintProperty<float, attributes::blur, uniforms::blur>\n+ : DataDrivenPaintProperty<float, attributes::floorwidth, uniforms::floorwidth>\n+ : DataDrivenPaintProperty<float, attributes::gapwidth, uniforms::gapwidth>\n+ : DataDrivenPaintProperty<float, attributes::halo_blur, uniforms::halo_blur>\n+ : DataDrivenPaintProperty<float, attributes::halo_width, uniforms::halo_width>\n+ : DataDrivenPaintProperty<float, attributes::height, uniforms::height>\n+ : DataDrivenPaintProperty<float, attributes::offset, uniforms::offset>\n+ : DataDrivenPaintProperty<float, attributes::opacity, uniforms::opacity>\n+ : DataDrivenPaintProperty<float, attributes::radius, uniforms::radius>\n+ : DataDrivenPaintProperty<float, attributes::stroke_opacity, uniforms::stroke_opacity>\n+ : DataDrivenPaintProperty<float, attributes::stroke_width, uniforms::stroke_width>\n+ : DataDrivenPaintProperty<float, attributes::weight, uniforms::weight>\n+ : DataDrivenPaintProperty<float, attributes::width, uniforms::width>\n+ : LayoutProperty<AlignmentType>\n+ : LayoutProperty<bool>\n+ : LayoutProperty<expression::Image>\n+ : LayoutProperty<float>\n+ : LayoutProperty<IconTextFitType>\n+ : LayoutProperty<LineCapType>\n+ : LayoutProperty<std::array<float, 4>>\n+ : LayoutProperty<std::vector<TextVariableAnchorType>>\n+ : LayoutProperty<std::vector<TextWritingModeType>>\n+ : LayoutProperty<SymbolPlacementType>\n+ : LayoutProperty<SymbolZOrderType>\n+ : PaintProperty<AlignmentType>\n+ : PaintProperty<bool>\n+ : PaintProperty<CirclePitchScaleType>\n+ : PaintProperty<Color>\n+ : PaintProperty<float>\n+ : PaintProperty<HillshadeIlluminationAnchorType>\n+ : PaintProperty<RasterResamplingType>\n+ : PaintProperty<Rotation>\n+ : PaintProperty<std::array<double, 3>>\n+ : PaintProperty<std::array<float, 2>>\n+ : PaintProperty<TranslateAnchorType>\n+ */\n+\n+// struct Scale : DataDrivenPaintProperty<float, attributes::width, uniforms::width> {\n+//     static float defaultValue() { return 1.f; }\n+// };\n+\n+// class PluginPaintProperties : public Properties<Scale> {};\n+\n+// template <>\n+// struct Converter<Scale> {\n+//     std::optional<Scale> operator()(const Convertible& value,\n+//                                     Error& error,\n+//                                     bool /* allowDataExpressions */ = true,\n+//                                     bool /* convertTokens */ = false) const;\n+// };\n+//\n+// template <>\n+// struct Converter<PropertyValue<Scale>> {\n+//     std::optional<PropertyValue<Scale>> operator()(const Convertible& value,\n+//                                                    Error& error,\n+//                                                    bool /* allowDataExpressions */ = true,\n+//                                                    bool /* convertTokens */ = false) const;\n+// };\n+\n+//\n+// template std::optional<PropertyValue<Scale>> Converter<PropertyValue<Scale>>::operator()(conversion::Convertible\n+// const&,\n+//                                                                                         conversion::Error&,\n+//                                                                                         bool,\n+//                                                                                         bool) const;\n+\n+class PluginLayerProperty {\n+public:\n+    typedef enum {",
        "comment_created_at": "2025-05-27T16:10:24+00:00",
        "comment_author": "AtlasProgramming",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1761491060",
    "pr_number": 2836,
    "pr_file": "include/mbgl/shaders/shader_defines.hpp",
    "created_at": "2024-09-16T16:44:17+00:00",
    "commented_code": "collisionTextureCount\n };\n \n+enum {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1761491060",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2836,
        "pr_file": "include/mbgl/shaders/shader_defines.hpp",
        "discussion_id": "1761491060",
        "commented_code": "@@ -62,6 +64,11 @@ enum {\n     collisionTextureCount\n };\n \n+enum {",
        "comment_created_at": "2024-09-16T16:44:17+00:00",
        "comment_author": "louwers",
        "comment_body": "Prefer `enum class`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1773667258",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2836,
        "pr_file": "include/mbgl/shaders/shader_defines.hpp",
        "discussion_id": "1761491060",
        "commented_code": "@@ -62,6 +64,11 @@ enum {\n     collisionTextureCount\n };\n \n+enum {",
        "comment_created_at": "2024-09-24T16:19:33+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Everything else in the file uses `enum`. I would prefer keeping them the same so it's either updating all of them to `enum class` now or later.",
        "pr_file_module": null
      },
      {
        "comment_id": "1783140422",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2836,
        "pr_file": "include/mbgl/shaders/shader_defines.hpp",
        "discussion_id": "1761491060",
        "commented_code": "@@ -62,6 +64,11 @@ enum {\n     collisionTextureCount\n };\n \n+enum {",
        "comment_created_at": "2024-10-01T16:06:50+00:00",
        "comment_author": "louwers",
        "comment_body": "Created an issue.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1752134717",
    "pr_number": 2780,
    "pr_file": "include/mbgl/style/image.hpp",
    "created_at": "2024-09-10T14:47:33+00:00",
    "commented_code": "using ImageStretch = std::pair<float, float>;\n using ImageStretches = std::vector<ImageStretch>;\n \n+enum class TextFit : uint8_t {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1752134717",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "include/mbgl/style/image.hpp",
        "discussion_id": "1752134717",
        "commented_code": "@@ -14,6 +14,12 @@ namespace style {\n using ImageStretch = std::pair<float, float>;\n using ImageStretches = std::vector<ImageStretch>;\n \n+enum class TextFit : uint8_t {",
        "comment_created_at": "2024-09-10T14:47:33+00:00",
        "comment_author": "louwers",
        "comment_body": "We follow the C++ Core Guidelines, which state\r\n\r\n> [Specify the underlying type of an enumeration only when necessary](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Renum-underlying)\r\n\r\nEspecially in this case I think it makes sense to just use the default.",
        "pr_file_module": null
      },
      {
        "comment_id": "1753270232",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "include/mbgl/style/image.hpp",
        "discussion_id": "1752134717",
        "commented_code": "@@ -14,6 +14,12 @@ namespace style {\n using ImageStretch = std::pair<float, float>;\n using ImageStretches = std::vector<ImageStretch>;\n \n+enum class TextFit : uint8_t {",
        "comment_created_at": "2024-09-11T06:50:07+00:00",
        "comment_author": "qqz003",
        "comment_body": "Thanks, actually I wrote it this way by referring to the existing code (like the enums in the file: src/mbgl/style/types.cpp), I thought this could save some space because the default type of the enum in C++ is `int`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1753636912",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "include/mbgl/style/image.hpp",
        "discussion_id": "1752134717",
        "commented_code": "@@ -14,6 +14,12 @@ namespace style {\n using ImageStretch = std::pair<float, float>;\n using ImageStretches = std::vector<ImageStretch>;\n \n+enum class TextFit : uint8_t {",
        "comment_created_at": "2024-09-11T08:44:01+00:00",
        "comment_author": "louwers",
        "comment_body": "There is something to be said for it, but since the space saving is minimal sticking to the default might be better.\r\n\r\nI will leave it up to your judgement!",
        "pr_file_module": null
      },
      {
        "comment_id": "1754100235",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "include/mbgl/style/image.hpp",
        "discussion_id": "1752134717",
        "commented_code": "@@ -14,6 +14,12 @@ namespace style {\n using ImageStretch = std::pair<float, float>;\n using ImageStretches = std::vector<ImageStretch>;\n \n+enum class TextFit : uint8_t {",
        "comment_created_at": "2024-09-11T11:11:29+00:00",
        "comment_author": "qqz003",
        "comment_body": "yeah, you're right, this enum won't be used very frequently, so it won't save too much space, it looks like using default to keep the code clear is better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1583163116",
    "pr_number": 2334,
    "pr_file": "platform/ios/src/MLNMapView+Metal.h",
    "created_at": "2024-04-29T14:13:03+00:00",
    "commented_code": "MLNBackendResource getObject() override;\n     // End implementation of MLNMapViewImpl\n \n+    virtual void setSynchronous(bool value) override { synchronousFrame = value; };",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1583163116",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2334,
        "pr_file": "platform/ios/src/MLNMapView+Metal.h",
        "discussion_id": "1583163116",
        "commented_code": "@@ -50,6 +50,9 @@ class MLNMapViewMetalImpl final : public MLNMapViewImpl,\n     MLNBackendResource getObject() override;\n     // End implementation of MLNMapViewImpl\n \n+    virtual void setSynchronous(bool value) override { synchronousFrame = value; };",
        "comment_created_at": "2024-04-29T14:13:03+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "nit: `virtual` isn't required when the `override` keyword is present, high compiler warning levels can complain if they follow the core guidelines on [virtual, override and final](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1337259207",
    "pr_number": 1690,
    "pr_file": "include/mbgl/shaders/collision_layer_ubo.hpp",
    "created_at": "2023-09-26T13:58:26+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/shaders/layer_ubo.hpp>\n+\n+namespace mbgl {\n+namespace shaders {\n+\n+struct alignas(16) CollisionUBO {\n+    std::array<float, 4 * 4> matrix;\n+    std::array<float, 2> extrude_scale;\n+    float camera_to_center_distance;\n+    float overscale_factor;\n+};\n+static_assert(sizeof(CollisionUBO) % 16 == 0);\n+static_assert(sizeof(CollisionUBO) == 80);\n+\n+typedef CollisionUBO CollisionBoxUBO;\n+typedef CollisionUBO CollisionCircleUBO;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1337259207",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1690,
        "pr_file": "include/mbgl/shaders/collision_layer_ubo.hpp",
        "discussion_id": "1337259207",
        "commented_code": "@@ -0,0 +1,21 @@\n+#pragma once\n+\n+#include <mbgl/shaders/layer_ubo.hpp>\n+\n+namespace mbgl {\n+namespace shaders {\n+\n+struct alignas(16) CollisionUBO {\n+    std::array<float, 4 * 4> matrix;\n+    std::array<float, 2> extrude_scale;\n+    float camera_to_center_distance;\n+    float overscale_factor;\n+};\n+static_assert(sizeof(CollisionUBO) % 16 == 0);\n+static_assert(sizeof(CollisionUBO) == 80);\n+\n+typedef CollisionUBO CollisionBoxUBO;\n+typedef CollisionUBO CollisionCircleUBO;",
        "comment_created_at": "2023-09-26T13:58:26+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Prefer `using` over typedef",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1337364940",
    "pr_number": 1690,
    "pr_file": "include/mbgl/shaders/collision_layer_ubo.hpp",
    "created_at": "2023-09-26T15:04:13+00:00",
    "commented_code": "static_assert(sizeof(CollisionUBO) % 16 == 0);\n static_assert(sizeof(CollisionUBO) == 80);\n \n-typedef CollisionUBO CollisionBoxUBO;\n-typedef CollisionUBO CollisionCircleUBO;\n+using CollisionUBO CollisionBoxUBO;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1337364940",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1690,
        "pr_file": "include/mbgl/shaders/collision_layer_ubo.hpp",
        "discussion_id": "1337364940",
        "commented_code": "@@ -14,8 +14,8 @@ struct alignas(16) CollisionUBO {\n static_assert(sizeof(CollisionUBO) % 16 == 0);\n static_assert(sizeof(CollisionUBO) == 80);\n \n-typedef CollisionUBO CollisionBoxUBO;\n-typedef CollisionUBO CollisionCircleUBO;\n+using CollisionUBO CollisionBoxUBO;",
        "comment_created_at": "2023-09-26T15:04:13+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "syntax: `using CollisionBoxUBO = CollisionUBO;`",
        "pr_file_module": null
      },
      {
        "comment_id": "1337471669",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1690,
        "pr_file": "include/mbgl/shaders/collision_layer_ubo.hpp",
        "discussion_id": "1337364940",
        "commented_code": "@@ -14,8 +14,8 @@ struct alignas(16) CollisionUBO {\n static_assert(sizeof(CollisionUBO) % 16 == 0);\n static_assert(sizeof(CollisionUBO) == 80);\n \n-typedef CollisionUBO CollisionBoxUBO;\n-typedef CollisionUBO CollisionCircleUBO;\n+using CollisionUBO CollisionBoxUBO;",
        "comment_created_at": "2023-09-26T16:15:53+00:00",
        "comment_author": "alexcristici",
        "comment_body": "Yes, sure. I was focused on something else when I corrected this. Now should be fine. \ud83d\ude04",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057126596",
    "pr_number": 3409,
    "pr_file": "include/mbgl/util/action_journal.hpp",
    "created_at": "2025-04-24T00:55:49+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/map/map.hpp>\n+#include <string>\n+#include <vector>\n+#include <memory>\n+#include <filesystem>\n+\n+namespace mbgl {\n+\n+namespace util {\n+\n+class ActionJournalOptions;\n+\n+class ActionJournal {\n+public:\n+    ActionJournal(const Map& map, const ActionJournalOptions& options);\n+    ~ActionJournal() = default;\n+\n+    std::vector<std::string> getLog();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2057126596",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3409,
        "pr_file": "include/mbgl/util/action_journal.hpp",
        "discussion_id": "2057126596",
        "commented_code": "@@ -0,0 +1,28 @@\n+#pragma once\n+\n+#include <mbgl/map/map.hpp>\n+#include <string>\n+#include <vector>\n+#include <memory>\n+#include <filesystem>\n+\n+namespace mbgl {\n+\n+namespace util {\n+\n+class ActionJournalOptions;\n+\n+class ActionJournal {\n+public:\n+    ActionJournal(const Map& map, const ActionJournalOptions& options);\n+    ~ActionJournal() = default;\n+\n+    std::vector<std::string> getLog();",
        "comment_created_at": "2025-04-24T00:55:49+00:00",
        "comment_author": "louwers",
        "comment_body": "Can probably be const.",
        "pr_file_module": null
      },
      {
        "comment_id": "2058480282",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3409,
        "pr_file": "include/mbgl/util/action_journal.hpp",
        "discussion_id": "2057126596",
        "commented_code": "@@ -0,0 +1,28 @@\n+#pragma once\n+\n+#include <mbgl/map/map.hpp>\n+#include <string>\n+#include <vector>\n+#include <memory>\n+#include <filesystem>\n+\n+namespace mbgl {\n+\n+namespace util {\n+\n+class ActionJournalOptions;\n+\n+class ActionJournal {\n+public:\n+    ActionJournal(const Map& map, const ActionJournalOptions& options);\n+    ~ActionJournal() = default;\n+\n+    std::vector<std::string> getLog();",
        "comment_created_at": "2025-04-24T13:40:46+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Mirrors `ActionJournal::Impl::getLog`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058281342",
    "pr_number": 3409,
    "pr_file": "src/mbgl/util/action_journal_impl.hpp",
    "created_at": "2025-04-24T12:29:21+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/util/action_journal.hpp>\n+#include <mbgl/util/action_journal_options.hpp>\n+#include <mbgl/map/map_observer.hpp>\n+\n+#include <fstream>\n+\n+namespace mbgl {\n+\n+class Map;\n+class Scheduler;\n+\n+namespace util {\n+\n+class ActionJournalEvent;\n+\n+class ActionJournal::Impl : public MapObserver {\n+public:\n+    Impl(const Map& map, const ActionJournalOptions& options);\n+    ~Impl() = default;\n+\n+    const Map& getMap() const { return map; }\n+\n+    std::vector<std::string> getLog();\n+    void clearLog();\n+\n+    // MapObserver\n+    void onCameraWillChange(CameraChangeMode) override;\n+    void onCameraIsChanging() override;\n+    void onCameraDidChange(CameraChangeMode) override;\n+    void onWillStartLoadingMap() override;\n+    void onDidFinishLoadingMap() override;\n+    void onDidFailLoadingMap(MapLoadError, const std::string&) override;\n+    void onWillStartRenderingFrame() override;\n+    void onDidFinishRenderingFrame(RenderFrameStatus) override;\n+    void onWillStartRenderingMap() override;\n+    void onDidFinishRenderingMap(RenderMode) override;\n+    void onDidFinishLoadingStyle() override;\n+    void onSourceChanged(style::Source&) override;\n+    void onDidBecomeIdle() override;\n+    void onStyleImageMissing(const std::string&) override;\n+    void onRegisterShaders(gfx::ShaderRegistry&) override;\n+    void onPreCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onPostCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onShaderCompileFailed(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onGlyphsLoaded(const FontStack&, const GlyphRange&) override;\n+    void onGlyphsError(const FontStack&, const GlyphRange&, std::exception_ptr) override;\n+    void onGlyphsRequested(const FontStack&, const GlyphRange&) override;\n+    void onTileAction(TileOperation, const OverscaledTileID&, const std::string&) override;\n+    void onSpriteLoaded(const std::optional<style::Sprite>&) override;\n+    void onSpriteError(const std::optional<style::Sprite>&, std::exception_ptr) override;\n+    void onSpriteRequested(const std::optional<style::Sprite>&) override;\n+\n+    void onMapCreate();\n+    void onMapDestroy();\n+\n+protected:\n+    void log(ActionJournalEvent& value);\n+    void log(ActionJournalEvent&& value);\n+\n+    // file operations\n+    std::string getFilepath(uint32_t fileIndex);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2058281342",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3409,
        "pr_file": "src/mbgl/util/action_journal_impl.hpp",
        "discussion_id": "2058281342",
        "commented_code": "@@ -0,0 +1,85 @@\n+#pragma once\n+\n+#include <mbgl/util/action_journal.hpp>\n+#include <mbgl/util/action_journal_options.hpp>\n+#include <mbgl/map/map_observer.hpp>\n+\n+#include <fstream>\n+\n+namespace mbgl {\n+\n+class Map;\n+class Scheduler;\n+\n+namespace util {\n+\n+class ActionJournalEvent;\n+\n+class ActionJournal::Impl : public MapObserver {\n+public:\n+    Impl(const Map& map, const ActionJournalOptions& options);\n+    ~Impl() = default;\n+\n+    const Map& getMap() const { return map; }\n+\n+    std::vector<std::string> getLog();\n+    void clearLog();\n+\n+    // MapObserver\n+    void onCameraWillChange(CameraChangeMode) override;\n+    void onCameraIsChanging() override;\n+    void onCameraDidChange(CameraChangeMode) override;\n+    void onWillStartLoadingMap() override;\n+    void onDidFinishLoadingMap() override;\n+    void onDidFailLoadingMap(MapLoadError, const std::string&) override;\n+    void onWillStartRenderingFrame() override;\n+    void onDidFinishRenderingFrame(RenderFrameStatus) override;\n+    void onWillStartRenderingMap() override;\n+    void onDidFinishRenderingMap(RenderMode) override;\n+    void onDidFinishLoadingStyle() override;\n+    void onSourceChanged(style::Source&) override;\n+    void onDidBecomeIdle() override;\n+    void onStyleImageMissing(const std::string&) override;\n+    void onRegisterShaders(gfx::ShaderRegistry&) override;\n+    void onPreCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onPostCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onShaderCompileFailed(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onGlyphsLoaded(const FontStack&, const GlyphRange&) override;\n+    void onGlyphsError(const FontStack&, const GlyphRange&, std::exception_ptr) override;\n+    void onGlyphsRequested(const FontStack&, const GlyphRange&) override;\n+    void onTileAction(TileOperation, const OverscaledTileID&, const std::string&) override;\n+    void onSpriteLoaded(const std::optional<style::Sprite>&) override;\n+    void onSpriteError(const std::optional<style::Sprite>&, std::exception_ptr) override;\n+    void onSpriteRequested(const std::optional<style::Sprite>&) override;\n+\n+    void onMapCreate();\n+    void onMapDestroy();\n+\n+protected:\n+    void log(ActionJournalEvent& value);\n+    void log(ActionJournalEvent&& value);\n+\n+    // file operations\n+    std::string getFilepath(uint32_t fileIndex);",
        "comment_created_at": "2025-04-24T12:29:21+00:00",
        "comment_author": "louwers",
        "comment_body": "Can be marked const.",
        "pr_file_module": null
      },
      {
        "comment_id": "2058482517",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3409,
        "pr_file": "src/mbgl/util/action_journal_impl.hpp",
        "discussion_id": "2058281342",
        "commented_code": "@@ -0,0 +1,85 @@\n+#pragma once\n+\n+#include <mbgl/util/action_journal.hpp>\n+#include <mbgl/util/action_journal_options.hpp>\n+#include <mbgl/map/map_observer.hpp>\n+\n+#include <fstream>\n+\n+namespace mbgl {\n+\n+class Map;\n+class Scheduler;\n+\n+namespace util {\n+\n+class ActionJournalEvent;\n+\n+class ActionJournal::Impl : public MapObserver {\n+public:\n+    Impl(const Map& map, const ActionJournalOptions& options);\n+    ~Impl() = default;\n+\n+    const Map& getMap() const { return map; }\n+\n+    std::vector<std::string> getLog();\n+    void clearLog();\n+\n+    // MapObserver\n+    void onCameraWillChange(CameraChangeMode) override;\n+    void onCameraIsChanging() override;\n+    void onCameraDidChange(CameraChangeMode) override;\n+    void onWillStartLoadingMap() override;\n+    void onDidFinishLoadingMap() override;\n+    void onDidFailLoadingMap(MapLoadError, const std::string&) override;\n+    void onWillStartRenderingFrame() override;\n+    void onDidFinishRenderingFrame(RenderFrameStatus) override;\n+    void onWillStartRenderingMap() override;\n+    void onDidFinishRenderingMap(RenderMode) override;\n+    void onDidFinishLoadingStyle() override;\n+    void onSourceChanged(style::Source&) override;\n+    void onDidBecomeIdle() override;\n+    void onStyleImageMissing(const std::string&) override;\n+    void onRegisterShaders(gfx::ShaderRegistry&) override;\n+    void onPreCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onPostCompileShader(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onShaderCompileFailed(shaders::BuiltIn, gfx::Backend::Type, const std::string&) override;\n+    void onGlyphsLoaded(const FontStack&, const GlyphRange&) override;\n+    void onGlyphsError(const FontStack&, const GlyphRange&, std::exception_ptr) override;\n+    void onGlyphsRequested(const FontStack&, const GlyphRange&) override;\n+    void onTileAction(TileOperation, const OverscaledTileID&, const std::string&) override;\n+    void onSpriteLoaded(const std::optional<style::Sprite>&) override;\n+    void onSpriteError(const std::optional<style::Sprite>&, std::exception_ptr) override;\n+    void onSpriteRequested(const std::optional<style::Sprite>&) override;\n+\n+    void onMapCreate();\n+    void onMapDestroy();\n+\n+protected:\n+    void log(ActionJournalEvent& value);\n+    void log(ActionJournalEvent&& value);\n+\n+    // file operations\n+    std::string getFilepath(uint32_t fileIndex);",
        "comment_created_at": "2025-04-24T13:41:49+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1849144843",
    "pr_number": 3030,
    "pr_file": "include/mbgl/util/unique_function.hpp",
    "created_at": "2024-11-19T22:40:48+00:00",
    "commented_code": "+#pragma once\n+\n+#include <functional>\n+\n+namespace mbgl {\n+namespace util {\n+\n+// C++20 non-copying lambda capture, pending C++23 `move_only_function`",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1849144843",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "include/mbgl/util/unique_function.hpp",
        "discussion_id": "1849144843",
        "commented_code": "@@ -0,0 +1,71 @@\n+#pragma once\n+\n+#include <functional>\n+\n+namespace mbgl {\n+namespace util {\n+\n+// C++20 non-copying lambda capture, pending C++23 `move_only_function`",
        "comment_created_at": "2024-11-19T22:40:48+00:00",
        "comment_author": "louwers",
        "comment_body": "Maybe we can use something like https://github.com/zhihaoy/nontype_functional/blob/main/include/std23/move_only_function.h instead so we can more easily migrate to `std::move_only_function` when we can use C++23.\r\n\r\nIt's also better tested.",
        "pr_file_module": null
      },
      {
        "comment_id": "1849148067",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "include/mbgl/util/unique_function.hpp",
        "discussion_id": "1849144843",
        "commented_code": "@@ -0,0 +1,71 @@\n+#pragma once\n+\n+#include <functional>\n+\n+namespace mbgl {\n+namespace util {\n+\n+// C++20 non-copying lambda capture, pending C++23 `move_only_function`",
        "comment_created_at": "2024-11-19T22:44:37+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "I'll give it a try.  Would we add that whole thing as a dependency, or just pull in the one file?",
        "pr_file_module": null
      },
      {
        "comment_id": "1849159157",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "include/mbgl/util/unique_function.hpp",
        "discussion_id": "1849144843",
        "commented_code": "@@ -0,0 +1,71 @@\n+#pragma once\n+\n+#include <functional>\n+\n+namespace mbgl {\n+namespace util {\n+\n+// C++20 non-copying lambda capture, pending C++23 `move_only_function`",
        "comment_created_at": "2024-11-19T22:58:13+00:00",
        "comment_author": "louwers",
        "comment_body": "If it's not too much hassle I would add it to `vendor/nontype_functional`. Could just be the two files we need.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1802068208",
    "pr_number": 2921,
    "pr_file": "include/mbgl/util/interpolate.hpp",
    "created_at": "2024-10-15T22:02:49+00:00",
    "commented_code": "}\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1802068208",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2921,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1802068208",
        "commented_code": "@@ -143,6 +147,37 @@ struct Interpolator<Padding> {\n     }\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) {",
        "comment_created_at": "2024-10-15T22:02:49+00:00",
        "comment_author": "random3940",
        "comment_body": "make the operator() const?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1717511470",
    "pr_number": 2723,
    "pr_file": "src/mbgl/renderer/render_orchestrator.hpp",
    "created_at": "2024-08-14T20:27:49+00:00",
    "commented_code": "const std::optional<std::string>& stateKey);\n \n     void setTileCacheEnabled(bool);\n+    bool getTileCacheEnabled();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1717511470",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2723,
        "pr_file": "src/mbgl/renderer/render_orchestrator.hpp",
        "discussion_id": "1717511470",
        "commented_code": "@@ -93,6 +93,7 @@ class RenderOrchestrator final : public GlyphManagerObserver, public ImageManage\n                             const std::optional<std::string>& stateKey);\n \n     void setTileCacheEnabled(bool);\n+    bool getTileCacheEnabled();",
        "comment_created_at": "2024-08-14T20:27:49+00:00",
        "comment_author": "louwers",
        "comment_body": "Can be const.",
        "pr_file_module": null
      }
    ]
  }
]