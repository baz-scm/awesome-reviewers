[
  {
    "discussion_id": "1089718860",
    "pr_number": 623,
    "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
    "created_at": "2023-01-28T11:19:50+00:00",
    "commented_code": "return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {\n         if (e) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1089718860",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 623,
        "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
        "discussion_id": "1089718860",
        "commented_code": "@@ -140,28 +140,26 @@ PremultipliedImage HeadlessFrontend::readStillImage() {\n     return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {\n         if (e) {",
        "comment_created_at": "2023-01-28T11:19:50+00:00",
        "comment_author": "louwers",
        "comment_body": "What kind of exceptions can `std::exception_ptr` contain? Can all be safely ignored? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1090137112",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 623,
        "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
        "discussion_id": "1089718860",
        "commented_code": "@@ -140,28 +140,26 @@ PremultipliedImage HeadlessFrontend::readStillImage() {\n     return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {\n         if (e) {",
        "comment_created_at": "2023-01-30T03:03:13+00:00",
        "comment_author": "alanchenboy",
        "comment_body": "We ignore the resource error like the font file download failed, you know, HeadlessFrontend::render should handle this kind of error, do you read the unit test it just simulates this condition, the unit test `TEST(Map, ResourceError)` try to take a snapshot, but the font resource download failed at first, and success in the second try.  Before this edition, the snapshot can process success because the render function aborts by resource error(break the render loop and throw the error), and after this edition, the snapshot could succeed.\r\n\r\nerror not be ignored, SDK(Adr, iOS, etc.) also can capture it via parameters.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1089719171",
    "pr_number": 623,
    "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
    "created_at": "2023-01-28T11:23:06+00:00",
    "commented_code": "return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1089719171",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 623,
        "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
        "discussion_id": "1089719171",
        "commented_code": "@@ -140,28 +140,26 @@ PremultipliedImage HeadlessFrontend::readStillImage() {\n     return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {",
        "comment_created_at": "2023-01-28T11:23:06+00:00",
        "comment_author": "louwers",
        "comment_body": "Is the callback passed to `renderStill` called multiple times? In that case the error would get overwritten in the case of multiple errors.",
        "pr_file_module": null
      },
      {
        "comment_id": "1090139213",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 623,
        "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
        "discussion_id": "1089719171",
        "commented_code": "@@ -140,28 +140,26 @@ PremultipliedImage HeadlessFrontend::readStillImage() {\n     return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {",
        "comment_created_at": "2023-01-30T03:10:15+00:00",
        "comment_author": "alanchenboy",
        "comment_body": "Yes, to prevent missing errors, maybe we could use the callback to handle the errors.",
        "pr_file_module": null
      },
      {
        "comment_id": "1092746744",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 623,
        "pr_file": "platform/default/src/mbgl/gfx/headless_frontend.cpp",
        "discussion_id": "1089719171",
        "commented_code": "@@ -140,28 +140,26 @@ PremultipliedImage HeadlessFrontend::readStillImage() {\n     return backend->readStillImage();\n }\n \n-HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map) {\n+HeadlessFrontend::RenderResult HeadlessFrontend::render(Map& map,\n+                                                        std::exception_ptr *error) {\n     HeadlessFrontend::RenderResult result;\n-    std::exception_ptr error;\n     gfx::BackendScope guard { *getBackend() };\n \n     map.renderStill([&](const std::exception_ptr& e) {",
        "comment_created_at": "2023-02-01T04:14:06+00:00",
        "comment_author": "alanchenboy",
        "comment_body": "callback added, all errors could be handled at the endpoint.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647613527",
    "pr_number": 2516,
    "pr_file": "platform/default/src/mbgl/storage/offline_database.cpp",
    "created_at": "2024-06-20T13:49:50+00:00",
    "commented_code": "return unexpected<std::exception_ptr>(std::current_exception());\n }\n \n+expected<OfflineRegion, std::exception_ptr> OfflineDatabase::getRegion(const int64_t regionID) try {\n+    mapbox::sqlite::Query query{getStatement(\"SELECT definition, description FROM regions WHERE id = ?1\")};\n+    query.bind(1, regionID);\n+    query.run();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1647613527",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2516,
        "pr_file": "platform/default/src/mbgl/storage/offline_database.cpp",
        "discussion_id": "1647613527",
        "commented_code": "@@ -835,6 +835,25 @@ expected<OfflineRegions, std::exception_ptr> OfflineDatabase::listRegions() try\n     return unexpected<std::exception_ptr>(std::current_exception());\n }\n \n+expected<OfflineRegion, std::exception_ptr> OfflineDatabase::getRegion(const int64_t regionID) try {\n+    mapbox::sqlite::Query query{getStatement(\"SELECT definition, description FROM regions WHERE id = ?1\")};\n+    query.bind(1, regionID);\n+    query.run();",
        "comment_created_at": "2024-06-20T13:49:50+00:00",
        "comment_author": "louwers",
        "comment_body": "You need to check the return value of `query.run()`. If it returns `false` no row is available and `query.get` will throw.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1690067248",
    "pr_number": 2564,
    "pr_file": "src/mbgl/vulkan/renderer_backend.cpp",
    "created_at": "2024-07-24T15:55:54+00:00",
    "commented_code": "+#include <mbgl/vulkan/renderer_backend.hpp>\n+#include <mbgl/vulkan/context.hpp>\n+#include <mbgl/vulkan/renderable_resource.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/shaders/shader_source.hpp>\n+#include <mbgl/util/logging.hpp>\n+\n+#include <mbgl/shaders/vulkan/shader_group.hpp>\n+#include <mbgl/shaders/vulkan/background.hpp>\n+#include <mbgl/shaders/vulkan/circle.hpp>\n+#include <mbgl/shaders/vulkan/clipping_mask.hpp>\n+#include <mbgl/shaders/vulkan/collision.hpp>\n+#include <mbgl/shaders/vulkan/debug.hpp>\n+#include <mbgl/shaders/vulkan/fill.hpp>\n+#include <mbgl/shaders/vulkan/heatmap.hpp>\n+#include <mbgl/shaders/vulkan/hillshade.hpp>\n+#include <mbgl/shaders/vulkan/line.hpp>\n+#include <mbgl/shaders/vulkan/raster.hpp>\n+#include <mbgl/shaders/vulkan/symbol.hpp>\n+\n+#include <cassert>\n+#include <string>\n+\n+VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE\n+\n+#ifdef ENABLE_VMA_DEBUG\n+\n+#define VMA_DEBUG_MARGIN 16\n+#define VMA_DEBUG_DETECT_CORRUPTION 1\n+#define VMA_DEBUG_INITIALIZE_ALLOCATIONS 1\n+\n+#define VMA_LEAK_LOG_FORMAT(format, ...)              \\\n+    {                                                 \\\n+        char buffer[4096];                            \\\n+        sprintf(buffer, format, __VA_ARGS__);         \\\n+        mbgl::Log::Info(mbgl::Event::Render, buffer); \\\n+    }\n+\n+#endif\n+\n+#define VMA_IMPLEMENTATION\n+#include \"vk_mem_alloc.h\"\n+\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+\n+#include \"renderdoc_app.h\"\n+static RENDERDOC_API_1_1_2* g_rdoc_api = nullptr;\n+\n+#endif\n+\n+namespace mbgl {\n+namespace vulkan {\n+\n+RendererBackend::RendererBackend(const gfx::ContextMode contextMode_)\n+    : gfx::RendererBackend(contextMode_),\n+      allocator(nullptr) {}\n+\n+RendererBackend::~RendererBackend() {\n+    destroyResources();\n+}\n+\n+std::unique_ptr<gfx::Context> RendererBackend::createContext() {\n+    return std::make_unique<vulkan::Context>(*this);\n+}\n+\n+std::vector<const char*> RendererBackend::getLayers() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        \"VK_LAYER_KHRONOS_validation\"\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getInstanceExtensions() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        VK_EXT_DEBUG_UTILS_EXTENSION_NAME\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getDeviceExtensions() {\n+    return getDefaultRenderable().getResource<SurfaceRenderableResource>().getDeviceExtensions();\n+}\n+\n+void RendererBackend::initFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+    if (HMODULE mod = GetModuleHandleA(\"renderdoc.dll\")) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)GetProcAddress(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#elif __unix__\n+    if (void* mod = dlopen(\"librenderdoc.so\", RTLD_NOW | RTLD_NOLOAD)) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)dlsym(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#endif\n+\n+#endif\n+}\n+\n+void RendererBackend::startFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->StartFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+void RendererBackend::endFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->EndFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+template <typename T, typename F>\n+static bool checkAvailability(const std::vector<T>& availableValues,\n+                              const std::vector<const char*>& requiredValues,\n+                              const F& getter) {\n+    for (const auto& requiredValue : requiredValues) {\n+        bool found = false;\n+        for (const auto& availableValue : availableValues) {\n+            if (strcmp(requiredValue, getter(availableValue)) == 0) {\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) return false;\n+    }\n+\n+    return true;\n+}\n+\n+static VKAPI_ATTR VkBool32 VKAPI_CALL vkDebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n+                                                      VkDebugUtilsMessageTypeFlagsEXT,\n+                                                      const VkDebugUtilsMessengerCallbackDataEXT* callbackData,\n+                                                      void*) {\n+    EventSeverity mbglSeverity = EventSeverity::Debug;\n+\n+    switch (messageSeverity) {\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:\n+            mbglSeverity = EventSeverity::Debug;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:\n+            mbglSeverity = EventSeverity::Info;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n+            mbglSeverity = EventSeverity::Warning;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n+            mbglSeverity = EventSeverity::Error;\n+            break;\n+\n+        default:\n+            return VK_FALSE;\n+    }\n+\n+    mbgl::Log::Record(mbglSeverity, mbgl::Event::Render, callbackData->pMessage);\n+\n+    return VK_FALSE;\n+}\n+\n+void RendererBackend::initDebug() {\n+    const vk::DebugUtilsMessageSeverityFlagsEXT severity = vk::DebugUtilsMessageSeverityFlagsEXT() |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eError;\n+\n+    const vk::DebugUtilsMessageTypeFlagsEXT type = vk::DebugUtilsMessageTypeFlagsEXT() |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eDeviceAddressBinding;\n+\n+    const auto createInfo =\n+        vk::DebugUtilsMessengerCreateInfoEXT().setMessageSeverity(severity).setMessageType(type).setPfnUserCallback(\n+            vkDebugCallback);\n+\n+    debugCallback = instance->createDebugUtilsMessengerEXTUnique(createInfo);\n+\n+    if (!debugCallback) mbgl::Log::Error(mbgl::Event::Render, \"Failed to register Vulkan debug callback\");\n+}\n+\n+void RendererBackend::init() {\n+    initFrameCapture();\n+    initInstance();\n+    initSurface();\n+    initDevice();\n+    initAllocator();\n+    initSwapchain();\n+    initCommandPool();\n+}\n+\n+void RendererBackend::initInstance() {\n+    // initialize minimal set of function pointers\n+    PFN_vkGetInstanceProcAddr getInstanceProcAddr = dynamicLoader.getProcAddress<PFN_vkGetInstanceProcAddr>(\n+        \"vkGetInstanceProcAddr\");\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(getInstanceProcAddr);\n+\n+    // Vulkan 1.1 on Android is supported on 71% of devices (compared to 1.3 with 6%) as of April 23 2024\n+    // https://vulkan.gpuinfo.org/\n+    const vk::ApplicationInfo appInfo(\"maplibre-native\", 1, \"maplibre-native\", VK_API_VERSION_1_0);\n+    vk::InstanceCreateInfo createInfo(vk::InstanceCreateFlags(), &appInfo);\n+\n+    const auto& layers = getLayers();\n+\n+    bool layersAvailable = checkAvailability(vk::enumerateInstanceLayerProperties(),\n+                                             layers,\n+                                             [](const vk::LayerProperties& value) { return value.layerName.data(); });\n+\n+    if (layersAvailable) {\n+        createInfo.setPEnabledLayerNames(layers);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan layers not found\");\n+#endif\n+    }\n+\n+    const auto& extensions = getInstanceExtensions();\n+\n+    bool extensionsAvailable = checkAvailability(\n+        vk::enumerateInstanceExtensionProperties(), extensions, [](const vk::ExtensionProperties& value) {\n+            return value.extensionName.data();\n+        });\n+\n+    if (extensionsAvailable) {\n+        createInfo.setPEnabledExtensionNames(extensions);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan extensions not found\");\n+#endif\n+    }\n+\n+    instance = vk::createInstanceUnique(createInfo);\n+\n+    // initialize function pointers for instance\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(instance.get());\n+\n+#ifdef ELABLE_VULKAN_VALIDATION\n+    // enable validation layer callback\n+    initDebug();\n+#endif\n+}\n+\n+void RendererBackend::initSurface() {\n+    getDefaultRenderable().getResource<SurfaceRenderableResource>().createPlatformSurface();\n+}\n+\n+void RendererBackend::initAllocator() {\n+    VmaVulkanFunctions functions = {};\n+\n+    functions.vkGetInstanceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetInstanceProcAddr;\n+    functions.vkGetDeviceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetDeviceProcAddr;\n+\n+    functions.vkGetPhysicalDeviceProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceProperties;\n+    functions.vkGetPhysicalDeviceMemoryProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties;\n+    functions.vkAllocateMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkAllocateMemory;\n+    functions.vkFreeMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkFreeMemory;\n+    functions.vkMapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkMapMemory;\n+    functions.vkUnmapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkUnmapMemory;\n+    functions.vkFlushMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkFlushMappedMemoryRanges;\n+    functions.vkInvalidateMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkInvalidateMappedMemoryRanges;\n+    functions.vkBindBufferMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory;\n+    functions.vkBindImageMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory;\n+    functions.vkGetBufferMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements;\n+    functions.vkGetImageMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements;\n+    functions.vkCreateBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateBuffer;\n+    functions.vkDestroyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyBuffer;\n+    functions.vkCreateImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateImage;\n+    functions.vkDestroyImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyImage;\n+    functions.vkCmdCopyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCmdCopyBuffer;\n+    functions.vkGetBufferMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements2KHR;\n+    functions.vkGetImageMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements2KHR;\n+    functions.vkBindBufferMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory2KHR;\n+    functions.vkBindImageMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory2KHR;\n+    functions.vkGetPhysicalDeviceMemoryProperties2KHR =\n+        VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties2KHR;\n+\n+    VmaAllocatorCreateInfo allocatorCreateInfo = {};\n+\n+    allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_0;\n+    allocatorCreateInfo.physicalDevice = physicalDevice;\n+    allocatorCreateInfo.device = device.get();\n+    allocatorCreateInfo.instance = instance.get();\n+    allocatorCreateInfo.pVulkanFunctions = &functions;\n+\n+    VkResult result = vmaCreateAllocator(&allocatorCreateInfo, &allocator);\n+    if (result != VK_SUCCESS) {\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan allocator init failed\");",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1690067248",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2564,
        "pr_file": "src/mbgl/vulkan/renderer_backend.cpp",
        "discussion_id": "1690067248",
        "commented_code": "@@ -0,0 +1,497 @@\n+#include <mbgl/vulkan/renderer_backend.hpp>\n+#include <mbgl/vulkan/context.hpp>\n+#include <mbgl/vulkan/renderable_resource.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/shaders/shader_source.hpp>\n+#include <mbgl/util/logging.hpp>\n+\n+#include <mbgl/shaders/vulkan/shader_group.hpp>\n+#include <mbgl/shaders/vulkan/background.hpp>\n+#include <mbgl/shaders/vulkan/circle.hpp>\n+#include <mbgl/shaders/vulkan/clipping_mask.hpp>\n+#include <mbgl/shaders/vulkan/collision.hpp>\n+#include <mbgl/shaders/vulkan/debug.hpp>\n+#include <mbgl/shaders/vulkan/fill.hpp>\n+#include <mbgl/shaders/vulkan/heatmap.hpp>\n+#include <mbgl/shaders/vulkan/hillshade.hpp>\n+#include <mbgl/shaders/vulkan/line.hpp>\n+#include <mbgl/shaders/vulkan/raster.hpp>\n+#include <mbgl/shaders/vulkan/symbol.hpp>\n+\n+#include <cassert>\n+#include <string>\n+\n+VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE\n+\n+#ifdef ENABLE_VMA_DEBUG\n+\n+#define VMA_DEBUG_MARGIN 16\n+#define VMA_DEBUG_DETECT_CORRUPTION 1\n+#define VMA_DEBUG_INITIALIZE_ALLOCATIONS 1\n+\n+#define VMA_LEAK_LOG_FORMAT(format, ...)              \\\n+    {                                                 \\\n+        char buffer[4096];                            \\\n+        sprintf(buffer, format, __VA_ARGS__);         \\\n+        mbgl::Log::Info(mbgl::Event::Render, buffer); \\\n+    }\n+\n+#endif\n+\n+#define VMA_IMPLEMENTATION\n+#include \"vk_mem_alloc.h\"\n+\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+\n+#include \"renderdoc_app.h\"\n+static RENDERDOC_API_1_1_2* g_rdoc_api = nullptr;\n+\n+#endif\n+\n+namespace mbgl {\n+namespace vulkan {\n+\n+RendererBackend::RendererBackend(const gfx::ContextMode contextMode_)\n+    : gfx::RendererBackend(contextMode_),\n+      allocator(nullptr) {}\n+\n+RendererBackend::~RendererBackend() {\n+    destroyResources();\n+}\n+\n+std::unique_ptr<gfx::Context> RendererBackend::createContext() {\n+    return std::make_unique<vulkan::Context>(*this);\n+}\n+\n+std::vector<const char*> RendererBackend::getLayers() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        \"VK_LAYER_KHRONOS_validation\"\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getInstanceExtensions() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        VK_EXT_DEBUG_UTILS_EXTENSION_NAME\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getDeviceExtensions() {\n+    return getDefaultRenderable().getResource<SurfaceRenderableResource>().getDeviceExtensions();\n+}\n+\n+void RendererBackend::initFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+    if (HMODULE mod = GetModuleHandleA(\"renderdoc.dll\")) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)GetProcAddress(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#elif __unix__\n+    if (void* mod = dlopen(\"librenderdoc.so\", RTLD_NOW | RTLD_NOLOAD)) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)dlsym(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#endif\n+\n+#endif\n+}\n+\n+void RendererBackend::startFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->StartFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+void RendererBackend::endFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->EndFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+template <typename T, typename F>\n+static bool checkAvailability(const std::vector<T>& availableValues,\n+                              const std::vector<const char*>& requiredValues,\n+                              const F& getter) {\n+    for (const auto& requiredValue : requiredValues) {\n+        bool found = false;\n+        for (const auto& availableValue : availableValues) {\n+            if (strcmp(requiredValue, getter(availableValue)) == 0) {\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) return false;\n+    }\n+\n+    return true;\n+}\n+\n+static VKAPI_ATTR VkBool32 VKAPI_CALL vkDebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n+                                                      VkDebugUtilsMessageTypeFlagsEXT,\n+                                                      const VkDebugUtilsMessengerCallbackDataEXT* callbackData,\n+                                                      void*) {\n+    EventSeverity mbglSeverity = EventSeverity::Debug;\n+\n+    switch (messageSeverity) {\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:\n+            mbglSeverity = EventSeverity::Debug;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:\n+            mbglSeverity = EventSeverity::Info;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n+            mbglSeverity = EventSeverity::Warning;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n+            mbglSeverity = EventSeverity::Error;\n+            break;\n+\n+        default:\n+            return VK_FALSE;\n+    }\n+\n+    mbgl::Log::Record(mbglSeverity, mbgl::Event::Render, callbackData->pMessage);\n+\n+    return VK_FALSE;\n+}\n+\n+void RendererBackend::initDebug() {\n+    const vk::DebugUtilsMessageSeverityFlagsEXT severity = vk::DebugUtilsMessageSeverityFlagsEXT() |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eError;\n+\n+    const vk::DebugUtilsMessageTypeFlagsEXT type = vk::DebugUtilsMessageTypeFlagsEXT() |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eDeviceAddressBinding;\n+\n+    const auto createInfo =\n+        vk::DebugUtilsMessengerCreateInfoEXT().setMessageSeverity(severity).setMessageType(type).setPfnUserCallback(\n+            vkDebugCallback);\n+\n+    debugCallback = instance->createDebugUtilsMessengerEXTUnique(createInfo);\n+\n+    if (!debugCallback) mbgl::Log::Error(mbgl::Event::Render, \"Failed to register Vulkan debug callback\");\n+}\n+\n+void RendererBackend::init() {\n+    initFrameCapture();\n+    initInstance();\n+    initSurface();\n+    initDevice();\n+    initAllocator();\n+    initSwapchain();\n+    initCommandPool();\n+}\n+\n+void RendererBackend::initInstance() {\n+    // initialize minimal set of function pointers\n+    PFN_vkGetInstanceProcAddr getInstanceProcAddr = dynamicLoader.getProcAddress<PFN_vkGetInstanceProcAddr>(\n+        \"vkGetInstanceProcAddr\");\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(getInstanceProcAddr);\n+\n+    // Vulkan 1.1 on Android is supported on 71% of devices (compared to 1.3 with 6%) as of April 23 2024\n+    // https://vulkan.gpuinfo.org/\n+    const vk::ApplicationInfo appInfo(\"maplibre-native\", 1, \"maplibre-native\", VK_API_VERSION_1_0);\n+    vk::InstanceCreateInfo createInfo(vk::InstanceCreateFlags(), &appInfo);\n+\n+    const auto& layers = getLayers();\n+\n+    bool layersAvailable = checkAvailability(vk::enumerateInstanceLayerProperties(),\n+                                             layers,\n+                                             [](const vk::LayerProperties& value) { return value.layerName.data(); });\n+\n+    if (layersAvailable) {\n+        createInfo.setPEnabledLayerNames(layers);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan layers not found\");\n+#endif\n+    }\n+\n+    const auto& extensions = getInstanceExtensions();\n+\n+    bool extensionsAvailable = checkAvailability(\n+        vk::enumerateInstanceExtensionProperties(), extensions, [](const vk::ExtensionProperties& value) {\n+            return value.extensionName.data();\n+        });\n+\n+    if (extensionsAvailable) {\n+        createInfo.setPEnabledExtensionNames(extensions);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan extensions not found\");\n+#endif\n+    }\n+\n+    instance = vk::createInstanceUnique(createInfo);\n+\n+    // initialize function pointers for instance\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(instance.get());\n+\n+#ifdef ELABLE_VULKAN_VALIDATION\n+    // enable validation layer callback\n+    initDebug();\n+#endif\n+}\n+\n+void RendererBackend::initSurface() {\n+    getDefaultRenderable().getResource<SurfaceRenderableResource>().createPlatformSurface();\n+}\n+\n+void RendererBackend::initAllocator() {\n+    VmaVulkanFunctions functions = {};\n+\n+    functions.vkGetInstanceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetInstanceProcAddr;\n+    functions.vkGetDeviceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetDeviceProcAddr;\n+\n+    functions.vkGetPhysicalDeviceProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceProperties;\n+    functions.vkGetPhysicalDeviceMemoryProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties;\n+    functions.vkAllocateMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkAllocateMemory;\n+    functions.vkFreeMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkFreeMemory;\n+    functions.vkMapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkMapMemory;\n+    functions.vkUnmapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkUnmapMemory;\n+    functions.vkFlushMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkFlushMappedMemoryRanges;\n+    functions.vkInvalidateMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkInvalidateMappedMemoryRanges;\n+    functions.vkBindBufferMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory;\n+    functions.vkBindImageMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory;\n+    functions.vkGetBufferMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements;\n+    functions.vkGetImageMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements;\n+    functions.vkCreateBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateBuffer;\n+    functions.vkDestroyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyBuffer;\n+    functions.vkCreateImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateImage;\n+    functions.vkDestroyImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyImage;\n+    functions.vkCmdCopyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCmdCopyBuffer;\n+    functions.vkGetBufferMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements2KHR;\n+    functions.vkGetImageMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements2KHR;\n+    functions.vkBindBufferMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory2KHR;\n+    functions.vkBindImageMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory2KHR;\n+    functions.vkGetPhysicalDeviceMemoryProperties2KHR =\n+        VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties2KHR;\n+\n+    VmaAllocatorCreateInfo allocatorCreateInfo = {};\n+\n+    allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_0;\n+    allocatorCreateInfo.physicalDevice = physicalDevice;\n+    allocatorCreateInfo.device = device.get();\n+    allocatorCreateInfo.instance = instance.get();\n+    allocatorCreateInfo.pVulkanFunctions = &functions;\n+\n+    VkResult result = vmaCreateAllocator(&allocatorCreateInfo, &allocator);\n+    if (result != VK_SUCCESS) {\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan allocator init failed\");",
        "comment_created_at": "2024-07-24T15:55:54+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Should this throw? We need an allocator if we're going to render stuff.",
        "pr_file_module": null
      },
      {
        "comment_id": "1697034488",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2564,
        "pr_file": "src/mbgl/vulkan/renderer_backend.cpp",
        "discussion_id": "1690067248",
        "commented_code": "@@ -0,0 +1,497 @@\n+#include <mbgl/vulkan/renderer_backend.hpp>\n+#include <mbgl/vulkan/context.hpp>\n+#include <mbgl/vulkan/renderable_resource.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/shaders/shader_source.hpp>\n+#include <mbgl/util/logging.hpp>\n+\n+#include <mbgl/shaders/vulkan/shader_group.hpp>\n+#include <mbgl/shaders/vulkan/background.hpp>\n+#include <mbgl/shaders/vulkan/circle.hpp>\n+#include <mbgl/shaders/vulkan/clipping_mask.hpp>\n+#include <mbgl/shaders/vulkan/collision.hpp>\n+#include <mbgl/shaders/vulkan/debug.hpp>\n+#include <mbgl/shaders/vulkan/fill.hpp>\n+#include <mbgl/shaders/vulkan/heatmap.hpp>\n+#include <mbgl/shaders/vulkan/hillshade.hpp>\n+#include <mbgl/shaders/vulkan/line.hpp>\n+#include <mbgl/shaders/vulkan/raster.hpp>\n+#include <mbgl/shaders/vulkan/symbol.hpp>\n+\n+#include <cassert>\n+#include <string>\n+\n+VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE\n+\n+#ifdef ENABLE_VMA_DEBUG\n+\n+#define VMA_DEBUG_MARGIN 16\n+#define VMA_DEBUG_DETECT_CORRUPTION 1\n+#define VMA_DEBUG_INITIALIZE_ALLOCATIONS 1\n+\n+#define VMA_LEAK_LOG_FORMAT(format, ...)              \\\n+    {                                                 \\\n+        char buffer[4096];                            \\\n+        sprintf(buffer, format, __VA_ARGS__);         \\\n+        mbgl::Log::Info(mbgl::Event::Render, buffer); \\\n+    }\n+\n+#endif\n+\n+#define VMA_IMPLEMENTATION\n+#include \"vk_mem_alloc.h\"\n+\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+\n+#include \"renderdoc_app.h\"\n+static RENDERDOC_API_1_1_2* g_rdoc_api = nullptr;\n+\n+#endif\n+\n+namespace mbgl {\n+namespace vulkan {\n+\n+RendererBackend::RendererBackend(const gfx::ContextMode contextMode_)\n+    : gfx::RendererBackend(contextMode_),\n+      allocator(nullptr) {}\n+\n+RendererBackend::~RendererBackend() {\n+    destroyResources();\n+}\n+\n+std::unique_ptr<gfx::Context> RendererBackend::createContext() {\n+    return std::make_unique<vulkan::Context>(*this);\n+}\n+\n+std::vector<const char*> RendererBackend::getLayers() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        \"VK_LAYER_KHRONOS_validation\"\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getInstanceExtensions() {\n+    return {\n+#ifdef ELABLE_VULKAN_VALIDATION\n+        VK_EXT_DEBUG_UTILS_EXTENSION_NAME\n+#endif\n+    };\n+}\n+\n+std::vector<const char*> RendererBackend::getDeviceExtensions() {\n+    return getDefaultRenderable().getResource<SurfaceRenderableResource>().getDeviceExtensions();\n+}\n+\n+void RendererBackend::initFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+\n+#ifdef _WIN32\n+    if (HMODULE mod = GetModuleHandleA(\"renderdoc.dll\")) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)GetProcAddress(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#elif __unix__\n+    if (void* mod = dlopen(\"librenderdoc.so\", RTLD_NOW | RTLD_NOLOAD)) {\n+        pRENDERDOC_GetAPI RENDERDOC_GetAPI = (pRENDERDOC_GetAPI)dlsym(mod, \"RENDERDOC_GetAPI\");\n+        int ret = RENDERDOC_GetAPI(eRENDERDOC_API_Version_1_1_2, (void**)&g_rdoc_api);\n+        assert(ret == 1);\n+    }\n+#endif\n+\n+#endif\n+}\n+\n+void RendererBackend::startFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->StartFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+void RendererBackend::endFrameCapture() {\n+#ifdef ENABLE_RENDERDOC_FRAME_CAPTURE\n+    if (g_rdoc_api) {\n+        g_rdoc_api->EndFrameCapture(nullptr, nullptr);\n+    }\n+#endif\n+}\n+\n+template <typename T, typename F>\n+static bool checkAvailability(const std::vector<T>& availableValues,\n+                              const std::vector<const char*>& requiredValues,\n+                              const F& getter) {\n+    for (const auto& requiredValue : requiredValues) {\n+        bool found = false;\n+        for (const auto& availableValue : availableValues) {\n+            if (strcmp(requiredValue, getter(availableValue)) == 0) {\n+                found = true;\n+                break;\n+            }\n+        }\n+\n+        if (!found) return false;\n+    }\n+\n+    return true;\n+}\n+\n+static VKAPI_ATTR VkBool32 VKAPI_CALL vkDebugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,\n+                                                      VkDebugUtilsMessageTypeFlagsEXT,\n+                                                      const VkDebugUtilsMessengerCallbackDataEXT* callbackData,\n+                                                      void*) {\n+    EventSeverity mbglSeverity = EventSeverity::Debug;\n+\n+    switch (messageSeverity) {\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:\n+            mbglSeverity = EventSeverity::Debug;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:\n+            mbglSeverity = EventSeverity::Info;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:\n+            mbglSeverity = EventSeverity::Warning;\n+            break;\n+\n+        case VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:\n+            mbglSeverity = EventSeverity::Error;\n+            break;\n+\n+        default:\n+            return VK_FALSE;\n+    }\n+\n+    mbgl::Log::Record(mbglSeverity, mbgl::Event::Render, callbackData->pMessage);\n+\n+    return VK_FALSE;\n+}\n+\n+void RendererBackend::initDebug() {\n+    const vk::DebugUtilsMessageSeverityFlagsEXT severity = vk::DebugUtilsMessageSeverityFlagsEXT() |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eVerbose |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eInfo |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |\n+                                                           vk::DebugUtilsMessageSeverityFlagBitsEXT::eError;\n+\n+    const vk::DebugUtilsMessageTypeFlagsEXT type = vk::DebugUtilsMessageTypeFlagsEXT() |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance |\n+                                                   vk::DebugUtilsMessageTypeFlagBitsEXT::eDeviceAddressBinding;\n+\n+    const auto createInfo =\n+        vk::DebugUtilsMessengerCreateInfoEXT().setMessageSeverity(severity).setMessageType(type).setPfnUserCallback(\n+            vkDebugCallback);\n+\n+    debugCallback = instance->createDebugUtilsMessengerEXTUnique(createInfo);\n+\n+    if (!debugCallback) mbgl::Log::Error(mbgl::Event::Render, \"Failed to register Vulkan debug callback\");\n+}\n+\n+void RendererBackend::init() {\n+    initFrameCapture();\n+    initInstance();\n+    initSurface();\n+    initDevice();\n+    initAllocator();\n+    initSwapchain();\n+    initCommandPool();\n+}\n+\n+void RendererBackend::initInstance() {\n+    // initialize minimal set of function pointers\n+    PFN_vkGetInstanceProcAddr getInstanceProcAddr = dynamicLoader.getProcAddress<PFN_vkGetInstanceProcAddr>(\n+        \"vkGetInstanceProcAddr\");\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(getInstanceProcAddr);\n+\n+    // Vulkan 1.1 on Android is supported on 71% of devices (compared to 1.3 with 6%) as of April 23 2024\n+    // https://vulkan.gpuinfo.org/\n+    const vk::ApplicationInfo appInfo(\"maplibre-native\", 1, \"maplibre-native\", VK_API_VERSION_1_0);\n+    vk::InstanceCreateInfo createInfo(vk::InstanceCreateFlags(), &appInfo);\n+\n+    const auto& layers = getLayers();\n+\n+    bool layersAvailable = checkAvailability(vk::enumerateInstanceLayerProperties(),\n+                                             layers,\n+                                             [](const vk::LayerProperties& value) { return value.layerName.data(); });\n+\n+    if (layersAvailable) {\n+        createInfo.setPEnabledLayerNames(layers);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan layers not found\");\n+#endif\n+    }\n+\n+    const auto& extensions = getInstanceExtensions();\n+\n+    bool extensionsAvailable = checkAvailability(\n+        vk::enumerateInstanceExtensionProperties(), extensions, [](const vk::ExtensionProperties& value) {\n+            return value.extensionName.data();\n+        });\n+\n+    if (extensionsAvailable) {\n+        createInfo.setPEnabledExtensionNames(extensions);\n+    } else {\n+#ifndef NDEBUG\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan extensions not found\");\n+#endif\n+    }\n+\n+    instance = vk::createInstanceUnique(createInfo);\n+\n+    // initialize function pointers for instance\n+    VULKAN_HPP_DEFAULT_DISPATCHER.init(instance.get());\n+\n+#ifdef ELABLE_VULKAN_VALIDATION\n+    // enable validation layer callback\n+    initDebug();\n+#endif\n+}\n+\n+void RendererBackend::initSurface() {\n+    getDefaultRenderable().getResource<SurfaceRenderableResource>().createPlatformSurface();\n+}\n+\n+void RendererBackend::initAllocator() {\n+    VmaVulkanFunctions functions = {};\n+\n+    functions.vkGetInstanceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetInstanceProcAddr;\n+    functions.vkGetDeviceProcAddr = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetDeviceProcAddr;\n+\n+    functions.vkGetPhysicalDeviceProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceProperties;\n+    functions.vkGetPhysicalDeviceMemoryProperties = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties;\n+    functions.vkAllocateMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkAllocateMemory;\n+    functions.vkFreeMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkFreeMemory;\n+    functions.vkMapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkMapMemory;\n+    functions.vkUnmapMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkUnmapMemory;\n+    functions.vkFlushMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkFlushMappedMemoryRanges;\n+    functions.vkInvalidateMappedMemoryRanges = VULKAN_HPP_DEFAULT_DISPATCHER.vkInvalidateMappedMemoryRanges;\n+    functions.vkBindBufferMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory;\n+    functions.vkBindImageMemory = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory;\n+    functions.vkGetBufferMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements;\n+    functions.vkGetImageMemoryRequirements = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements;\n+    functions.vkCreateBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateBuffer;\n+    functions.vkDestroyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyBuffer;\n+    functions.vkCreateImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkCreateImage;\n+    functions.vkDestroyImage = VULKAN_HPP_DEFAULT_DISPATCHER.vkDestroyImage;\n+    functions.vkCmdCopyBuffer = VULKAN_HPP_DEFAULT_DISPATCHER.vkCmdCopyBuffer;\n+    functions.vkGetBufferMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetBufferMemoryRequirements2KHR;\n+    functions.vkGetImageMemoryRequirements2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkGetImageMemoryRequirements2KHR;\n+    functions.vkBindBufferMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindBufferMemory2KHR;\n+    functions.vkBindImageMemory2KHR = VULKAN_HPP_DEFAULT_DISPATCHER.vkBindImageMemory2KHR;\n+    functions.vkGetPhysicalDeviceMemoryProperties2KHR =\n+        VULKAN_HPP_DEFAULT_DISPATCHER.vkGetPhysicalDeviceMemoryProperties2KHR;\n+\n+    VmaAllocatorCreateInfo allocatorCreateInfo = {};\n+\n+    allocatorCreateInfo.vulkanApiVersion = VK_API_VERSION_1_0;\n+    allocatorCreateInfo.physicalDevice = physicalDevice;\n+    allocatorCreateInfo.device = device.get();\n+    allocatorCreateInfo.instance = instance.get();\n+    allocatorCreateInfo.pVulkanFunctions = &functions;\n+\n+    VkResult result = vmaCreateAllocator(&allocatorCreateInfo, &allocator);\n+    if (result != VK_SUCCESS) {\n+        mbgl::Log::Error(mbgl::Event::Render, \"Vulkan allocator init failed\");",
        "comment_created_at": "2024-07-30T14:08:52+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "Added exception. Should throw only on VMA misconfiguration at this point (instance creation guarantees vulkan support).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1172431954",
    "pr_number": 1042,
    "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
    "created_at": "2023-04-20T11:05:50+00:00",
    "commented_code": "/* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1172431954",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1042,
        "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
        "discussion_id": "1172431954",
        "commented_code": "@@ -10,278 +10,416 @@ namespace platform {\n /* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
        "comment_created_at": "2023-04-20T11:05:50+00:00",
        "comment_author": "louwers",
        "comment_body": "Maybe it's better to let it crash here instead? If these functions are not initialized MapLibre will not be able to render anything.",
        "pr_file_module": null
      },
      {
        "comment_id": "1172433731",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1042,
        "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
        "discussion_id": "1172431954",
        "commented_code": "@@ -10,278 +10,416 @@ namespace platform {\n /* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
        "comment_created_at": "2023-04-20T11:07:48+00:00",
        "comment_author": "ntadej",
        "comment_body": "Then we can not run unit tests. It seems that some GL calls are done in core after context is cleaned and this is a nice workaround. I'd wait for Metal work to finish to properly fix this.",
        "pr_file_module": null
      },
      {
        "comment_id": "1172442206",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1042,
        "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
        "discussion_id": "1172431954",
        "commented_code": "@@ -10,278 +10,416 @@ namespace platform {\n /* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
        "comment_created_at": "2023-04-20T11:16:38+00:00",
        "comment_author": "louwers",
        "comment_body": "Maybe you could wrap the check in a function that returns a bool and logs a warning if there is no context anymore?\r\n\r\nYour call, but it may save someone a frustrating debugging session.",
        "pr_file_module": null
      },
      {
        "comment_id": "1172445111",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1042,
        "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
        "discussion_id": "1172431954",
        "commented_code": "@@ -10,278 +10,416 @@ namespace platform {\n /* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
        "comment_created_at": "2023-04-20T11:19:50+00:00",
        "comment_author": "ntadej",
        "comment_body": "We can't change return type, but I could add logging, although I'm a bit hesitant. Even this `if` may slow down the code actually.\r\n\r\nLet me see if I can hack the tests then...",
        "pr_file_module": null
      },
      {
        "comment_id": "1174433071",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1042,
        "pr_file": "platform/qt/src/mbgl/gl_functions.cpp",
        "discussion_id": "1172431954",
        "commented_code": "@@ -10,278 +10,416 @@ namespace platform {\n /* OpenGL ES 2.0 */\n \n void (* const glActiveTexture)(GLenum) = [](auto... args) {\n+    if (!QOpenGLContext::currentContext())\n+        return;",
        "comment_created_at": "2023-04-22T16:06:44+00:00",
        "comment_author": "ntadej",
        "comment_body": "OK, I managed to add a functionality to `headless_backend.cpp` to restore the context when doing cleanup so we do not crash. This is a more proper solution.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1289181181",
    "pr_number": 1417,
    "pr_file": "src/mbgl/mtl/upload_pass.cpp",
    "created_at": "2023-08-09T20:50:01+00:00",
    "commented_code": "const void* data,\n                                                                         gfx::TexturePixelType format,\n                                                                         gfx::TextureChannelDataType type) {\n-    //    auto obj = commandEncoder.context.createUniqueTexture();\n-    //    const int textureByteSize = gl::TextureResource::getStorageSize(size, format, type);\n-    //    commandEncoder.context.renderingStats().memTextures += textureByteSize;\n-    //    auto resource = std::make_unique<gl::TextureResource>(std::move(obj), textureByteSize);\n-    //    commandEncoder.context.pixelStoreUnpack = {1};\n-    //    updateTextureResource(*resource, size, data, format, type);\n-    //    // We are using clamp to edge here since OpenGL ES doesn't allow GL_REPEAT\n-    //    // on NPOT textures. We use those when the pixelRatio isn't a power of two,\n-    //    // e.g. on iPhone 6 Plus.\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST));\n-    return std::make_unique<TextureResource>();\n+    assert(false);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1289181181",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1417,
        "pr_file": "src/mbgl/mtl/upload_pass.cpp",
        "discussion_id": "1289181181",
        "commented_code": "@@ -82,35 +82,27 @@ std::unique_ptr<gfx::TextureResource> UploadPass::createTextureResource(const Si\n                                                                         const void* data,\n                                                                         gfx::TexturePixelType format,\n                                                                         gfx::TextureChannelDataType type) {\n-    //    auto obj = commandEncoder.context.createUniqueTexture();\n-    //    const int textureByteSize = gl::TextureResource::getStorageSize(size, format, type);\n-    //    commandEncoder.context.renderingStats().memTextures += textureByteSize;\n-    //    auto resource = std::make_unique<gl::TextureResource>(std::move(obj), textureByteSize);\n-    //    commandEncoder.context.pixelStoreUnpack = {1};\n-    //    updateTextureResource(*resource, size, data, format, type);\n-    //    // We are using clamp to edge here since OpenGL ES doesn't allow GL_REPEAT\n-    //    // on NPOT textures. We use those when the pixelRatio isn't a power of two,\n-    //    // e.g. on iPhone 6 Plus.\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));\n-    //    MBGL_CHECK_ERROR(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST));\n-    return std::make_unique<TextureResource>();\n+    assert(false);",
        "comment_created_at": "2023-08-09T20:50:01+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "We should probably throw since assert will get dropped in release builds. Calling stubs should always terminate.",
        "pr_file_module": null
      }
    ]
  }
]