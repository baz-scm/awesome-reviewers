[
  {
    "discussion_id": "1729451129",
    "pr_number": 2759,
    "pr_file": "platform/android/MapLibreAndroid/src/main/java/org/maplibre/android/storage/FileSource.java",
    "created_at": "2024-08-23T19:54:38+00:00",
    "commented_code": "return new File(path).canWrite();\n   }\n \n-  private static void lockPathLoaders() {\n-    internalCachePathLoaderLock.lock();\n-    resourcesCachePathLoaderLock.lock();\n-  }\n-\n-  private static void unlockPathLoaders() {\n-    resourcesCachePathLoaderLock.unlock();\n-    internalCachePathLoaderLock.unlock();\n-  }\n-",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1729451129",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2759,
        "pr_file": "platform/android/MapLibreAndroid/src/main/java/org/maplibre/android/storage/FileSource.java",
        "discussion_id": "1729451129",
        "commented_code": "@@ -358,16 +340,6 @@ private static boolean isPathWritable(String path) {\n     return new File(path).canWrite();\n   }\n \n-  private static void lockPathLoaders() {\n-    internalCachePathLoaderLock.lock();\n-    resourcesCachePathLoaderLock.lock();\n-  }\n-\n-  private static void unlockPathLoaders() {\n-    resourcesCachePathLoaderLock.unlock();\n-    internalCachePathLoaderLock.unlock();\n-  }\n-",
        "comment_created_at": "2024-08-23T19:54:38+00:00",
        "comment_author": "westnordost",
        "comment_body": "If you wonder where the locking/unlocking is done, it's done in `getResourcesCachePath` and `getInternalCachePath`, respectively. No need to duplicate the code from these methods.\r\nThe behavior-change here is that the locking is done not on the main thread but in the background thread, which is fine, that is what locks are for (locks are thread-safe, duh!).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1465343436",
    "pr_number": 2036,
    "pr_file": "platform/android/MapboxGLAndroidSDK/src/main/java/org/maplibre/android/maps/renderer/glsurfaceview/MapLibreGLSurfaceView.java",
    "created_at": "2024-01-24T17:55:13+00:00",
    "commented_code": "}\n     }\n \n+    /**\n+     * Wait for the queue to become empty\n+     * @param timeoutMillis Timeout in milliseconds\n+     * @return Number of queue items remaining\n+    */\n+    public int waitForEmpty(long timeoutMillis) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1465343436",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2036,
        "pr_file": "platform/android/MapboxGLAndroidSDK/src/main/java/org/maplibre/android/maps/renderer/glsurfaceview/MapLibreGLSurfaceView.java",
        "discussion_id": "1465343436",
        "commented_code": "@@ -1023,6 +1033,31 @@ public void queueEvent(@NonNull Runnable r) {\n       }\n     }\n \n+    /**\n+     * Wait for the queue to become empty\n+     * @param timeoutMillis Timeout in milliseconds\n+     * @return Number of queue items remaining\n+    */\n+    public int waitForEmpty(long timeoutMillis) {",
        "comment_created_at": "2024-01-24T17:55:13+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Can we add an option to wait forever by passing 0? Would it also make sense to reset the timeout if some events in the queue are processed but more are enqueued as a result?",
        "pr_file_module": null
      },
      {
        "comment_id": "1465696545",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2036,
        "pr_file": "platform/android/MapboxGLAndroidSDK/src/main/java/org/maplibre/android/maps/renderer/glsurfaceview/MapLibreGLSurfaceView.java",
        "discussion_id": "1465343436",
        "commented_code": "@@ -1023,6 +1033,31 @@ public void queueEvent(@NonNull Runnable r) {\n       }\n     }\n \n+    /**\n+     * Wait for the queue to become empty\n+     * @param timeoutMillis Timeout in milliseconds\n+     * @return Number of queue items remaining\n+    */\n+    public int waitForEmpty(long timeoutMillis) {",
        "comment_created_at": "2024-01-25T00:11:03+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "I would not expect the timeout to be reset, that could lead to any length of wait when the caller would reasonably expect a best-effort to return within approximately the timeout period.\r\n\r\nIf we are going to handle things being inserted from multiple threads, I think we need to add a way for the caller to make the scheduler reject new tasks, since the point is to know it's empty so you it can be destroyed, and there would always be a window between unlocking and returning where new stuff could sneak in. \r\n\r\nMy impression is that tasks are added on the same thread that creates/destroys the pool, but there's nothing to enforce that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1465706692",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2036,
        "pr_file": "platform/android/MapboxGLAndroidSDK/src/main/java/org/maplibre/android/maps/renderer/glsurfaceview/MapLibreGLSurfaceView.java",
        "discussion_id": "1465343436",
        "commented_code": "@@ -1023,6 +1033,31 @@ public void queueEvent(@NonNull Runnable r) {\n       }\n     }\n \n+    /**\n+     * Wait for the queue to become empty\n+     * @param timeoutMillis Timeout in milliseconds\n+     * @return Number of queue items remaining\n+    */\n+    public int waitForEmpty(long timeoutMillis) {",
        "comment_created_at": "2024-01-25T00:28:15+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Asserting that `schedule` is called on the thread that created the pool or on one of the pooled threads seems to mostly work, but fails from `SnapshotterRenderer` in tests, which apparently runs in a separate thread.\r\n\r\nSo yeah, I guess we need a `Scheduler::close` or something.",
        "pr_file_module": null
      },
      {
        "comment_id": "1467027334",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2036,
        "pr_file": "platform/android/MapboxGLAndroidSDK/src/main/java/org/maplibre/android/maps/renderer/glsurfaceview/MapLibreGLSurfaceView.java",
        "discussion_id": "1465343436",
        "commented_code": "@@ -1023,6 +1033,31 @@ public void queueEvent(@NonNull Runnable r) {\n       }\n     }\n \n+    /**\n+     * Wait for the queue to become empty\n+     * @param timeoutMillis Timeout in milliseconds\n+     * @return Number of queue items remaining\n+    */\n+    public int waitForEmpty(long timeoutMillis) {",
        "comment_created_at": "2024-01-25T22:25:36+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "On reflection, we can't use a `close` in `~Context` because the background scheduler is potentially being used by other things at the same time.\r\n\r\nBut I think it's valid to say that when a `Context` is being destroyed, no new loading should be initiated, so it's enough to wait for all the already-added tasks to complete.  Any other map, etc., using the background scheduler needs to maintain its own reference to keep the pool alive.",
        "pr_file_module": null
      }
    ]
  }
]