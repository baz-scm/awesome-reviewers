[
  {
    "discussion_id": "2107563927",
    "pr_number": 3430,
    "pr_file": "src/mbgl/plugins/plugin_layer.cpp",
    "created_at": "2025-05-26T15:25:28+00:00",
    "commented_code": "+//\n+//  plugin_layer.cpp\n+//  App\n+//\n+//  Created by Malcolm Toon on 4/24/25.\n+//\n+\n+#include <mbgl/plugins/plugin_layer.hpp>\n+#include <mbgl/plugins/plugin_layer_impl.hpp>\n+#include <iostream>\n+#include \"plugin_layer_debug.hpp\"\n+\n+namespace mbgl {\n+namespace style {\n+\n+PluginLayer::PluginLayer(const std::string& layerID,\n+                         const std::string& sourceID,\n+                         const style::LayerTypeInfo layerTypeInfo,\n+                         const std::string& layerProperties\n+\n+                         //,const style::conversion::Convertible& layerProperties\n+                         )\n+    : Layer(makeMutable<Impl>(layerID, sourceID, layerTypeInfo, layerProperties)) {}\n+\n+PluginLayer::PluginLayer(Immutable<Impl> impl_)\n+    : Layer(std::move(impl_)) {}\n+\n+PluginLayer::~PluginLayer() = default;\n+\n+const PluginLayer::Impl& PluginLayer::impl() const {\n+    return static_cast<const Impl&>(*baseImpl);\n+}\n+\n+Mutable<PluginLayer::Impl> PluginLayer::mutableImpl() const {\n+    return makeMutable<Impl>(impl());\n+}\n+\n+std::unique_ptr<Layer> PluginLayer::cloneRef(const std::string& id_) const {\n+    auto impl_ = mutableImpl();\n+    impl_->id = id_;\n+    return std::make_unique<PluginLayer>(std::move(impl_));\n+}\n+\n+void PluginLayer::Impl::stringifyLayout(rapidjson::Writer<rapidjson::StringBuffer>&) const {}\n+\n+Value PluginLayer::serialize() const {\n+    auto result = Layer::serialize();\n+    /*\n+    // TODO: Implement this?\n+    assert(result.getObject());\n+\n+    for (const auto& property : layerProperties) {\n+        auto styleProperty = getLayerProperty(*this, static_cast<Property>(property.second));\n+        if (styleProperty.getKind() == StyleProperty::Kind::Undefined) continue;\n+        serializeProperty(result, styleProperty, property.first.c_str(), property.second < kPaintPropertyCount);\n+    }\n+*/\n+    return result;\n+}\n+\n+std::optional<conversion::Error> PluginLayer::setPropertyInternal(const std::string& name,\n+                                                                  const conversion::Convertible& value) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+    std::cout << \"Property Name: \" << name << \"\n\";\n+#endif\n+\n+    auto i = (mbgl::style::PluginLayer::Impl*)baseImpl.get();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2107563927",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "src/mbgl/plugins/plugin_layer.cpp",
        "discussion_id": "2107563927",
        "commented_code": "@@ -0,0 +1,110 @@\n+//\n+//  plugin_layer.cpp\n+//  App\n+//\n+//  Created by Malcolm Toon on 4/24/25.\n+//\n+\n+#include <mbgl/plugins/plugin_layer.hpp>\n+#include <mbgl/plugins/plugin_layer_impl.hpp>\n+#include <iostream>\n+#include \"plugin_layer_debug.hpp\"\n+\n+namespace mbgl {\n+namespace style {\n+\n+PluginLayer::PluginLayer(const std::string& layerID,\n+                         const std::string& sourceID,\n+                         const style::LayerTypeInfo layerTypeInfo,\n+                         const std::string& layerProperties\n+\n+                         //,const style::conversion::Convertible& layerProperties\n+                         )\n+    : Layer(makeMutable<Impl>(layerID, sourceID, layerTypeInfo, layerProperties)) {}\n+\n+PluginLayer::PluginLayer(Immutable<Impl> impl_)\n+    : Layer(std::move(impl_)) {}\n+\n+PluginLayer::~PluginLayer() = default;\n+\n+const PluginLayer::Impl& PluginLayer::impl() const {\n+    return static_cast<const Impl&>(*baseImpl);\n+}\n+\n+Mutable<PluginLayer::Impl> PluginLayer::mutableImpl() const {\n+    return makeMutable<Impl>(impl());\n+}\n+\n+std::unique_ptr<Layer> PluginLayer::cloneRef(const std::string& id_) const {\n+    auto impl_ = mutableImpl();\n+    impl_->id = id_;\n+    return std::make_unique<PluginLayer>(std::move(impl_));\n+}\n+\n+void PluginLayer::Impl::stringifyLayout(rapidjson::Writer<rapidjson::StringBuffer>&) const {}\n+\n+Value PluginLayer::serialize() const {\n+    auto result = Layer::serialize();\n+    /*\n+    // TODO: Implement this?\n+    assert(result.getObject());\n+\n+    for (const auto& property : layerProperties) {\n+        auto styleProperty = getLayerProperty(*this, static_cast<Property>(property.second));\n+        if (styleProperty.getKind() == StyleProperty::Kind::Undefined) continue;\n+        serializeProperty(result, styleProperty, property.first.c_str(), property.second < kPaintPropertyCount);\n+    }\n+*/\n+    return result;\n+}\n+\n+std::optional<conversion::Error> PluginLayer::setPropertyInternal(const std::string& name,\n+                                                                  const conversion::Convertible& value) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+    std::cout << \"Property Name: \" << name << \"\\n\";\n+#endif\n+\n+    auto i = (mbgl::style::PluginLayer::Impl*)baseImpl.get();",
        "comment_created_at": "2025-05-26T15:25:28+00:00",
        "comment_author": "louwers",
        "comment_body": "Don't use C-style casts.",
        "pr_file_module": null
      },
      {
        "comment_id": "2109606109",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "src/mbgl/plugins/plugin_layer.cpp",
        "discussion_id": "2107563927",
        "commented_code": "@@ -0,0 +1,110 @@\n+//\n+//  plugin_layer.cpp\n+//  App\n+//\n+//  Created by Malcolm Toon on 4/24/25.\n+//\n+\n+#include <mbgl/plugins/plugin_layer.hpp>\n+#include <mbgl/plugins/plugin_layer_impl.hpp>\n+#include <iostream>\n+#include \"plugin_layer_debug.hpp\"\n+\n+namespace mbgl {\n+namespace style {\n+\n+PluginLayer::PluginLayer(const std::string& layerID,\n+                         const std::string& sourceID,\n+                         const style::LayerTypeInfo layerTypeInfo,\n+                         const std::string& layerProperties\n+\n+                         //,const style::conversion::Convertible& layerProperties\n+                         )\n+    : Layer(makeMutable<Impl>(layerID, sourceID, layerTypeInfo, layerProperties)) {}\n+\n+PluginLayer::PluginLayer(Immutable<Impl> impl_)\n+    : Layer(std::move(impl_)) {}\n+\n+PluginLayer::~PluginLayer() = default;\n+\n+const PluginLayer::Impl& PluginLayer::impl() const {\n+    return static_cast<const Impl&>(*baseImpl);\n+}\n+\n+Mutable<PluginLayer::Impl> PluginLayer::mutableImpl() const {\n+    return makeMutable<Impl>(impl());\n+}\n+\n+std::unique_ptr<Layer> PluginLayer::cloneRef(const std::string& id_) const {\n+    auto impl_ = mutableImpl();\n+    impl_->id = id_;\n+    return std::make_unique<PluginLayer>(std::move(impl_));\n+}\n+\n+void PluginLayer::Impl::stringifyLayout(rapidjson::Writer<rapidjson::StringBuffer>&) const {}\n+\n+Value PluginLayer::serialize() const {\n+    auto result = Layer::serialize();\n+    /*\n+    // TODO: Implement this?\n+    assert(result.getObject());\n+\n+    for (const auto& property : layerProperties) {\n+        auto styleProperty = getLayerProperty(*this, static_cast<Property>(property.second));\n+        if (styleProperty.getKind() == StyleProperty::Kind::Undefined) continue;\n+        serializeProperty(result, styleProperty, property.first.c_str(), property.second < kPaintPropertyCount);\n+    }\n+*/\n+    return result;\n+}\n+\n+std::optional<conversion::Error> PluginLayer::setPropertyInternal(const std::string& name,\n+                                                                  const conversion::Convertible& value) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+    std::cout << \"Property Name: \" << name << \"\\n\";\n+#endif\n+\n+    auto i = (mbgl::style::PluginLayer::Impl*)baseImpl.get();",
        "comment_created_at": "2025-05-27T16:01:22+00:00",
        "comment_author": "AtlasProgramming",
        "comment_body": "Changed to static_cast",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077539639",
    "pr_number": 3198,
    "pr_file": "src/mbgl/gfx/dynamic_texture_atlas.cpp",
    "created_at": "2025-05-07T12:42:21+00:00",
    "commented_code": "+#include <mbgl/gfx/dynamic_texture_atlas.hpp>\n+#include <mbgl/gfx/context.hpp>\n+\n+#include <cmath>\n+\n+namespace mbgl {\n+namespace gfx {\n+\n+constexpr const uint16_t padding = ImagePosition::padding;\n+constexpr const Size startSize = {512, 512};\n+\n+GlyphAtlas DynamicTextureAtlas::uploadGlyphs(const GlyphMap& glyphs) {\n+    using GlyphsToUpload = std::vector<std::tuple<TextureHandle, Immutable<Glyph>, FontStackHash>>;\n+    mutex.lock();\n+\n+    GlyphAtlas glyphAtlas;\n+    if (!glyphs.size()) {\n+        glyphAtlas.dynamicTexture = dummyDynamicTexture[TexturePixelType::Alpha];\n+        if (!glyphAtlas.dynamicTexture) {\n+            glyphAtlas.dynamicTexture = std::make_shared<gfx::DynamicTexture>(\n+                context, Size(1, 1), TexturePixelType::Alpha);\n+            dummyDynamicTexture[TexturePixelType::Alpha] = glyphAtlas.dynamicTexture;\n+        }\n+        mutex.unlock();\n+        return glyphAtlas;\n+    }\n+\n+    size_t dynTexIndex = 0;\n+    Size dynTexSize = startSize;\n+    GlyphsToUpload glyphsToUpload;\n+\n+    while (!glyphAtlas.dynamicTexture) {\n+        if (dynTexIndex < dynamicTextures.size()) {\n+            glyphAtlas.dynamicTexture = dynamicTextures[dynTexIndex++];\n+        } else {\n+            glyphAtlas.dynamicTexture = std::make_shared<gfx::DynamicTexture>(\n+                context, dynTexSize, TexturePixelType::Alpha);\n+            dynTexSize = Size(dynTexSize.width * 2, dynTexSize.height * 2);\n+            dynTexIndex++;\n+        }\n+\n+        if (glyphAtlas.dynamicTexture->getPixelFormat() != TexturePixelType::Alpha) {\n+            glyphAtlas.dynamicTexture = nullptr;\n+            continue;\n+        }\n+\n+        bool hasSpace = true;\n+        for (const auto& glyphMapEntry : glyphs) {\n+            FontStackHash fontStack = glyphMapEntry.first;\n+\n+            for (const auto& glyphEntry : glyphMapEntry.second) {\n+                const auto& glyph = glyphEntry.second;\n+\n+                if (glyph.has_value() && glyph.value()->bitmap.valid()) {\n+                    int32_t uniqueId = static_cast<int32_t>(sqrt(fontStack) / 2 + glyph.value()->id);\n+                    const auto size = Size(glyph.value()->bitmap.size.width + 2 * padding,\n+                                           glyph.value()->bitmap.size.height + 2 * padding);\n+                    const auto& texHandle = glyphAtlas.dynamicTexture->reserveSize(size, uniqueId);\n+                    if (!texHandle) {\n+                        hasSpace = false;\n+                        break;\n+                    }\n+                    glyphsToUpload.emplace_back(std::make_tuple(*texHandle, glyph.value(), fontStack));\n+                }\n+            }\n+            if (!hasSpace) {\n+                for (const auto& tuple : glyphsToUpload) {\n+                    const auto& texHandle = std::get<0>(tuple);\n+                    glyphAtlas.dynamicTexture->removeTexture(texHandle);\n+                }\n+                glyphsToUpload.clear();\n+                glyphAtlas.dynamicTexture = nullptr;\n+                break;\n+            }\n+        }\n+    }\n+    if (dynTexIndex > dynamicTextures.size()) {\n+        dynamicTextures.emplace_back(glyphAtlas.dynamicTexture);\n+    }\n+\n+    for (const auto& tuple : glyphsToUpload) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2077539639",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3198,
        "pr_file": "src/mbgl/gfx/dynamic_texture_atlas.cpp",
        "discussion_id": "2077539639",
        "commented_code": "@@ -0,0 +1,260 @@\n+#include <mbgl/gfx/dynamic_texture_atlas.hpp>\n+#include <mbgl/gfx/context.hpp>\n+\n+#include <cmath>\n+\n+namespace mbgl {\n+namespace gfx {\n+\n+constexpr const uint16_t padding = ImagePosition::padding;\n+constexpr const Size startSize = {512, 512};\n+\n+GlyphAtlas DynamicTextureAtlas::uploadGlyphs(const GlyphMap& glyphs) {\n+    using GlyphsToUpload = std::vector<std::tuple<TextureHandle, Immutable<Glyph>, FontStackHash>>;\n+    mutex.lock();\n+\n+    GlyphAtlas glyphAtlas;\n+    if (!glyphs.size()) {\n+        glyphAtlas.dynamicTexture = dummyDynamicTexture[TexturePixelType::Alpha];\n+        if (!glyphAtlas.dynamicTexture) {\n+            glyphAtlas.dynamicTexture = std::make_shared<gfx::DynamicTexture>(\n+                context, Size(1, 1), TexturePixelType::Alpha);\n+            dummyDynamicTexture[TexturePixelType::Alpha] = glyphAtlas.dynamicTexture;\n+        }\n+        mutex.unlock();\n+        return glyphAtlas;\n+    }\n+\n+    size_t dynTexIndex = 0;\n+    Size dynTexSize = startSize;\n+    GlyphsToUpload glyphsToUpload;\n+\n+    while (!glyphAtlas.dynamicTexture) {\n+        if (dynTexIndex < dynamicTextures.size()) {\n+            glyphAtlas.dynamicTexture = dynamicTextures[dynTexIndex++];\n+        } else {\n+            glyphAtlas.dynamicTexture = std::make_shared<gfx::DynamicTexture>(\n+                context, dynTexSize, TexturePixelType::Alpha);\n+            dynTexSize = Size(dynTexSize.width * 2, dynTexSize.height * 2);\n+            dynTexIndex++;\n+        }\n+\n+        if (glyphAtlas.dynamicTexture->getPixelFormat() != TexturePixelType::Alpha) {\n+            glyphAtlas.dynamicTexture = nullptr;\n+            continue;\n+        }\n+\n+        bool hasSpace = true;\n+        for (const auto& glyphMapEntry : glyphs) {\n+            FontStackHash fontStack = glyphMapEntry.first;\n+\n+            for (const auto& glyphEntry : glyphMapEntry.second) {\n+                const auto& glyph = glyphEntry.second;\n+\n+                if (glyph.has_value() && glyph.value()->bitmap.valid()) {\n+                    int32_t uniqueId = static_cast<int32_t>(sqrt(fontStack) / 2 + glyph.value()->id);\n+                    const auto size = Size(glyph.value()->bitmap.size.width + 2 * padding,\n+                                           glyph.value()->bitmap.size.height + 2 * padding);\n+                    const auto& texHandle = glyphAtlas.dynamicTexture->reserveSize(size, uniqueId);\n+                    if (!texHandle) {\n+                        hasSpace = false;\n+                        break;\n+                    }\n+                    glyphsToUpload.emplace_back(std::make_tuple(*texHandle, glyph.value(), fontStack));\n+                }\n+            }\n+            if (!hasSpace) {\n+                for (const auto& tuple : glyphsToUpload) {\n+                    const auto& texHandle = std::get<0>(tuple);\n+                    glyphAtlas.dynamicTexture->removeTexture(texHandle);\n+                }\n+                glyphsToUpload.clear();\n+                glyphAtlas.dynamicTexture = nullptr;\n+                break;\n+            }\n+        }\n+    }\n+    if (dynTexIndex > dynamicTextures.size()) {\n+        dynamicTextures.emplace_back(glyphAtlas.dynamicTexture);\n+    }\n+\n+    for (const auto& tuple : glyphsToUpload) {",
        "comment_created_at": "2025-05-07T12:42:21+00:00",
        "comment_author": "louwers",
        "comment_body": "Do you know structured bindings? I think this would work\r\n\r\n```\r\nfor (auto [texHandle, glyph, fontStack] : glyphsToUpload) {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1752127682",
    "pr_number": 2780,
    "pr_file": "src/mbgl/text/shaping.cpp",
    "created_at": "2024-09-10T14:43:21+00:00",
    "commented_code": "return PositionedIcon{image, top, bottom, left, right, collisionPadding};\n }\n \n+PositionedIcon PositionedIcon::applyTextFit() const {\n+    if (!_image.textFitWidth && !_image.textFitHeight) {\n+        return *this;\n+    }\n+    auto width = _right - _left;\n+    auto height = _bottom - _top;\n+\n+    auto contentWidth = _image.content->right - _image.content->left;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1752127682",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "src/mbgl/text/shaping.cpp",
        "discussion_id": "1752127682",
        "commented_code": "@@ -92,6 +92,45 @@ PositionedIcon PositionedIcon::shapeIcon(const ImagePosition& image,\n     return PositionedIcon{image, top, bottom, left, right, collisionPadding};\n }\n \n+PositionedIcon PositionedIcon::applyTextFit() const {\n+    if (!_image.textFitWidth && !_image.textFitHeight) {\n+        return *this;\n+    }\n+    auto width = _right - _left;\n+    auto height = _bottom - _top;\n+\n+    auto contentWidth = _image.content->right - _image.content->left;",
        "comment_created_at": "2024-09-10T14:43:21+00:00",
        "comment_author": "louwers",
        "comment_body": "Please have a look over all definitions in the PR and make sure that all immutable values are marked `const`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1754094084",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2780,
        "pr_file": "src/mbgl/text/shaping.cpp",
        "discussion_id": "1752127682",
        "commented_code": "@@ -92,6 +92,45 @@ PositionedIcon PositionedIcon::shapeIcon(const ImagePosition& image,\n     return PositionedIcon{image, top, bottom, left, right, collisionPadding};\n }\n \n+PositionedIcon PositionedIcon::applyTextFit() const {\n+    if (!_image.textFitWidth && !_image.textFitHeight) {\n+        return *this;\n+    }\n+    auto width = _right - _left;\n+    auto height = _bottom - _top;\n+\n+    auto contentWidth = _image.content->right - _image.content->left;",
        "comment_created_at": "2024-09-11T11:09:24+00:00",
        "comment_author": "qqz003",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1739037596",
    "pr_number": 2694,
    "pr_file": "test/map/map.test.cpp",
    "created_at": "2024-08-30T16:09:49+00:00",
    "commented_code": "test.runLoop.run();\n }\n+\n+TEST(Map, ObserveTileLifecycle) {\n+    util::RunLoop runLoop;\n+\n+    struct TileEntry {\n+        OverscaledTileID id;\n+        std::string sourceID;\n+        TileOperation op;\n+\n+        bool operator==(const TileEntry& other) const noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1739037596",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2694,
        "pr_file": "test/map/map.test.cpp",
        "discussion_id": "1739037596",
        "commented_code": "@@ -1684,3 +1687,166 @@ TEST(Map, InvalidUTF8InTile) {\n \n     test.runLoop.run();\n }\n+\n+TEST(Map, ObserveTileLifecycle) {\n+    util::RunLoop runLoop;\n+\n+    struct TileEntry {\n+        OverscaledTileID id;\n+        std::string sourceID;\n+        TileOperation op;\n+\n+        bool operator==(const TileEntry& other) const noexcept {",
        "comment_created_at": "2024-08-30T16:09:49+00:00",
        "comment_author": "louwers",
        "comment_body": "You should be able to default this `operator==` since we use C++20 now.",
        "pr_file_module": null
      },
      {
        "comment_id": "1739134234",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2694,
        "pr_file": "test/map/map.test.cpp",
        "discussion_id": "1739037596",
        "commented_code": "@@ -1684,3 +1687,166 @@ TEST(Map, InvalidUTF8InTile) {\n \n     test.runLoop.run();\n }\n+\n+TEST(Map, ObserveTileLifecycle) {\n+    util::RunLoop runLoop;\n+\n+    struct TileEntry {\n+        OverscaledTileID id;\n+        std::string sourceID;\n+        TileOperation op;\n+\n+        bool operator==(const TileEntry& other) const noexcept {",
        "comment_created_at": "2024-08-30T16:57:42+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Yup, looks like I don't even need to specify it with Clang 16.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1717449110",
    "pr_number": 2722,
    "pr_file": "src/mbgl/actor/mailbox.cpp",
    "created_at": "2024-08-14T19:25:16+00:00",
    "commented_code": "}\n     }};\n \n+    MLN_TRACE_ZONE(push lock)\n     std::lock_guard<std::mutex> pushingLock(pushingMutex);\n \n     if (closed) {\n         state = State::Abandoned;\n         return;\n     }\n \n-    std::lock_guard<std::mutex> queueLock(queueMutex);\n-    bool wasEmpty = queue.empty();\n-    queue.push(std::move(message));\n-    auto guard = weakScheduler.lock();\n-    if (wasEmpty && weakScheduler) {\n-        weakScheduler->schedule(schedulerTag, makeClosure(shared_from_this()));\n+    bool wasEmpty;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1717449110",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2722,
        "pr_file": "src/mbgl/actor/mailbox.cpp",
        "discussion_id": "1717449110",
        "commented_code": "@@ -88,19 +90,28 @@ void Mailbox::push(std::unique_ptr<Message> message) {\n         }\n     }};\n \n+    MLN_TRACE_ZONE(push lock)\n     std::lock_guard<std::mutex> pushingLock(pushingMutex);\n \n     if (closed) {\n         state = State::Abandoned;\n         return;\n     }\n \n-    std::lock_guard<std::mutex> queueLock(queueMutex);\n-    bool wasEmpty = queue.empty();\n-    queue.push(std::move(message));\n-    auto guard = weakScheduler.lock();\n-    if (wasEmpty && weakScheduler) {\n-        weakScheduler->schedule(schedulerTag, makeClosure(shared_from_this()));\n+    bool wasEmpty;",
        "comment_created_at": "2024-08-14T19:25:16+00:00",
        "comment_author": "louwers",
        "comment_body": "Should be initialized to something.",
        "pr_file_module": null
      },
      {
        "comment_id": "1717455078",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2722,
        "pr_file": "src/mbgl/actor/mailbox.cpp",
        "discussion_id": "1717449110",
        "commented_code": "@@ -88,19 +90,28 @@ void Mailbox::push(std::unique_ptr<Message> message) {\n         }\n     }};\n \n+    MLN_TRACE_ZONE(push lock)\n     std::lock_guard<std::mutex> pushingLock(pushingMutex);\n \n     if (closed) {\n         state = State::Abandoned;\n         return;\n     }\n \n-    std::lock_guard<std::mutex> queueLock(queueMutex);\n-    bool wasEmpty = queue.empty();\n-    queue.push(std::move(message));\n-    auto guard = weakScheduler.lock();\n-    if (wasEmpty && weakScheduler) {\n-        weakScheduler->schedule(schedulerTag, makeClosure(shared_from_this()));\n+    bool wasEmpty;",
        "comment_created_at": "2024-08-14T19:30:01+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Even though it's unconditionally set?  That will generate \"value is never used\" warnings on some compilers.",
        "pr_file_module": null
      },
      {
        "comment_id": "1717475736",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2722,
        "pr_file": "src/mbgl/actor/mailbox.cpp",
        "discussion_id": "1717449110",
        "commented_code": "@@ -88,19 +90,28 @@ void Mailbox::push(std::unique_ptr<Message> message) {\n         }\n     }};\n \n+    MLN_TRACE_ZONE(push lock)\n     std::lock_guard<std::mutex> pushingLock(pushingMutex);\n \n     if (closed) {\n         state = State::Abandoned;\n         return;\n     }\n \n-    std::lock_guard<std::mutex> queueLock(queueMutex);\n-    bool wasEmpty = queue.empty();\n-    queue.push(std::move(message));\n-    auto guard = weakScheduler.lock();\n-    if (wasEmpty && weakScheduler) {\n-        weakScheduler->schedule(schedulerTag, makeClosure(shared_from_this()));\n+    bool wasEmpty;",
        "comment_created_at": "2024-08-14T19:51:07+00:00",
        "comment_author": "louwers",
        "comment_body": "C++ Code Guidelines say yes. https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es20-always-initialize-an-object",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1690203102",
    "pr_number": 2564,
    "pr_file": "src/mbgl/vulkan/drawable.cpp",
    "created_at": "2024-07-24T17:42:30+00:00",
    "commented_code": "+#include <mbgl/vulkan/drawable.hpp>\n+\n+#include <mbgl/gfx/color_mode.hpp>\n+#include <mbgl/gfx/depth_mode.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/vulkan/command_encoder.hpp>\n+#include <mbgl/vulkan/context.hpp>\n+#include <mbgl/vulkan/drawable_impl.hpp>\n+#include <mbgl/vulkan/render_pass.hpp>\n+#include <mbgl/vulkan/renderable_resource.hpp>\n+#include <mbgl/vulkan/renderer_backend.hpp>\n+#include <mbgl/vulkan/upload_pass.hpp>\n+#include <mbgl/vulkan/index_buffer_resource.hpp>\n+#include <mbgl/vulkan/vertex_buffer_resource.hpp>\n+#include <mbgl/vulkan/texture2d.hpp>\n+#include <mbgl/shaders/vulkan/shader_program.hpp>\n+#include <mbgl/programs/segment.hpp>\n+#include <mbgl/util/logging.hpp>\n+#include <mbgl/util/variant.hpp>\n+#include <mbgl/util/hash.hpp>\n+\n+#include <cassert>\n+#if !defined(NDEBUG)\n+#include <sstream>\n+#endif\n+\n+namespace mbgl {\n+namespace vulkan {\n+\n+struct IndexBuffer : public gfx::IndexBufferBase {\n+    IndexBuffer(std::unique_ptr<gfx::IndexBuffer>&& buffer_)\n+        : buffer(std::move(buffer_)) {}\n+    ~IndexBuffer() override = default;\n+\n+    std::unique_ptr<mbgl::gfx::IndexBuffer> buffer;\n+};\n+\n+#if !defined(NDEBUG)\n+static std::string debugLabel(const gfx::Drawable& drawable) {\n+    std::ostringstream oss;\n+    oss << drawable.getID().id() << \"/\" << drawable.getName() << \"/tile=\";\n+\n+    if (const auto& tileID = drawable.getTileID()) {\n+        oss << util::toString(*tileID);\n+    } else {\n+        oss << \"(none)\";\n+    }\n+\n+    return oss.str();\n+}\n+#endif // !defined(NDEBUG)\n+\n+Drawable::Drawable(std::string name_)\n+    : gfx::Drawable(std::move(name_)),\n+      impl(std::make_unique<Impl>()) {}\n+\n+Drawable::~Drawable() {}\n+\n+void Drawable::setEnableColor(bool value) {\n+    gfx::Drawable::setEnableColor(value);\n+\n+    if (value)",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1690203102",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2564,
        "pr_file": "src/mbgl/vulkan/drawable.cpp",
        "discussion_id": "1690203102",
        "commented_code": "@@ -0,0 +1,452 @@\n+#include <mbgl/vulkan/drawable.hpp>\n+\n+#include <mbgl/gfx/color_mode.hpp>\n+#include <mbgl/gfx/depth_mode.hpp>\n+#include <mbgl/renderer/paint_parameters.hpp>\n+#include <mbgl/vulkan/command_encoder.hpp>\n+#include <mbgl/vulkan/context.hpp>\n+#include <mbgl/vulkan/drawable_impl.hpp>\n+#include <mbgl/vulkan/render_pass.hpp>\n+#include <mbgl/vulkan/renderable_resource.hpp>\n+#include <mbgl/vulkan/renderer_backend.hpp>\n+#include <mbgl/vulkan/upload_pass.hpp>\n+#include <mbgl/vulkan/index_buffer_resource.hpp>\n+#include <mbgl/vulkan/vertex_buffer_resource.hpp>\n+#include <mbgl/vulkan/texture2d.hpp>\n+#include <mbgl/shaders/vulkan/shader_program.hpp>\n+#include <mbgl/programs/segment.hpp>\n+#include <mbgl/util/logging.hpp>\n+#include <mbgl/util/variant.hpp>\n+#include <mbgl/util/hash.hpp>\n+\n+#include <cassert>\n+#if !defined(NDEBUG)\n+#include <sstream>\n+#endif\n+\n+namespace mbgl {\n+namespace vulkan {\n+\n+struct IndexBuffer : public gfx::IndexBufferBase {\n+    IndexBuffer(std::unique_ptr<gfx::IndexBuffer>&& buffer_)\n+        : buffer(std::move(buffer_)) {}\n+    ~IndexBuffer() override = default;\n+\n+    std::unique_ptr<mbgl::gfx::IndexBuffer> buffer;\n+};\n+\n+#if !defined(NDEBUG)\n+static std::string debugLabel(const gfx::Drawable& drawable) {\n+    std::ostringstream oss;\n+    oss << drawable.getID().id() << \"/\" << drawable.getName() << \"/tile=\";\n+\n+    if (const auto& tileID = drawable.getTileID()) {\n+        oss << util::toString(*tileID);\n+    } else {\n+        oss << \"(none)\";\n+    }\n+\n+    return oss.str();\n+}\n+#endif // !defined(NDEBUG)\n+\n+Drawable::Drawable(std::string name_)\n+    : gfx::Drawable(std::move(name_)),\n+      impl(std::make_unique<Impl>()) {}\n+\n+Drawable::~Drawable() {}\n+\n+void Drawable::setEnableColor(bool value) {\n+    gfx::Drawable::setEnableColor(value);\n+\n+    if (value)",
        "comment_created_at": "2024-07-24T17:42:30+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Use braces on multi-line conditionals",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1472962405",
    "pr_number": 1980,
    "pr_file": "src/mbgl/shaders/gl/shader_program_gl.cpp",
    "created_at": "2024-01-31T15:05:56+00:00",
    "commented_code": "MBGL_CHECK_ERROR(glGetProgramiv(program, GL_ACTIVE_UNIFORM_BLOCKS, &count));\n     MBGL_CHECK_ERROR(glGetProgramiv(program, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, &maxLength));\n \n-    auto name = std::vector<GLchar>(maxLength);\n-    for (GLint index = 0; index < count; ++index) {\n-        GLsizei length = 0;\n+    for (const auto& blockInfo : uniformBlocksInfo) {\n+        GLint index = MBGL_CHECK_ERROR(glGetUniformBlockIndex(program, blockInfo.name.data()));\n         GLint size = 0;\n-        GLint binding = index;\n-        MBGL_CHECK_ERROR(glGetActiveUniformBlockName(program, index, maxLength, &length, name.data()));\n         MBGL_CHECK_ERROR(glGetActiveUniformBlockiv(program, index, GL_UNIFORM_BLOCK_DATA_SIZE, &size));\n-        assert(length > 0 && size > 0);\n+        assert(size > 0);\n+        GLint binding = GLint(blockInfo.binding);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1472962405",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1980,
        "pr_file": "src/mbgl/shaders/gl/shader_program_gl.cpp",
        "discussion_id": "1472962405",
        "commented_code": "@@ -149,23 +151,21 @@ std::shared_ptr<ShaderProgramGL> ShaderProgramGL::create(Context& context,\n     MBGL_CHECK_ERROR(glGetProgramiv(program, GL_ACTIVE_UNIFORM_BLOCKS, &count));\n     MBGL_CHECK_ERROR(glGetProgramiv(program, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, &maxLength));\n \n-    auto name = std::vector<GLchar>(maxLength);\n-    for (GLint index = 0; index < count; ++index) {\n-        GLsizei length = 0;\n+    for (const auto& blockInfo : uniformBlocksInfo) {\n+        GLint index = MBGL_CHECK_ERROR(glGetUniformBlockIndex(program, blockInfo.name.data()));\n         GLint size = 0;\n-        GLint binding = index;\n-        MBGL_CHECK_ERROR(glGetActiveUniformBlockName(program, index, maxLength, &length, name.data()));\n         MBGL_CHECK_ERROR(glGetActiveUniformBlockiv(program, index, GL_UNIFORM_BLOCK_DATA_SIZE, &size));\n-        assert(length > 0 && size > 0);\n+        assert(size > 0);\n+        GLint binding = GLint(blockInfo.binding);",
        "comment_created_at": "2024-01-31T15:05:56+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Prefer `static_cast<GLint>`",
        "pr_file_module": null
      }
    ]
  }
]