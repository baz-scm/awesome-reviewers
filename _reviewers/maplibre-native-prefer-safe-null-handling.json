[
  {
    "discussion_id": "1849135631",
    "pr_number": 3030,
    "pr_file": "src/mbgl/tile/tile_cache.cpp",
    "created_at": "2024-11-19T22:29:36+00:00",
    "commented_code": "}\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1849135631",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "src/mbgl/tile/tile_cache.cpp",
        "discussion_id": "1849135631",
        "commented_code": "@@ -26,43 +41,54 @@ void TileCache::setSize(size_t size_) {\n }\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
        "comment_created_at": "2024-11-19T22:29:36+00:00",
        "comment_author": "louwers",
        "comment_body": "You are moving the data member `pendingReleases` here. It's no longer valid after that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1849165118",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "src/mbgl/tile/tile_cache.cpp",
        "discussion_id": "1849135631",
        "commented_code": "@@ -26,43 +41,54 @@ void TileCache::setSize(size_t size_) {\n }\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
        "comment_created_at": "2024-11-19T23:06:23+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Interesting, there used to be language on cppreference implying that was valid, but it's gone now.  Seems like it was removed since 2022, based on [this](https://news.ycombinator.com/item?id=32907069).",
        "pr_file_module": null
      },
      {
        "comment_id": "1849432388",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "src/mbgl/tile/tile_cache.cpp",
        "discussion_id": "1849135631",
        "commented_code": "@@ -26,43 +41,54 @@ void TileCache::setSize(size_t size_) {\n }\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
        "comment_created_at": "2024-11-20T02:57:42+00:00",
        "comment_author": "louwers",
        "comment_body": "<img width=\"659\" alt=\"image\" src=\"https://github.com/user-attachments/assets/2b533993-5a56-4e51-82a7-340d5a5ae186\">\r\n<img width=\"673\" alt=\"image\" src=\"https://github.com/user-attachments/assets/b509f10f-5280-4be1-9006-b3689361f869\">\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1850492328",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "src/mbgl/tile/tile_cache.cpp",
        "discussion_id": "1849135631",
        "commented_code": "@@ -26,43 +41,54 @@ void TileCache::setSize(size_t size_) {\n }\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
        "comment_created_at": "2024-11-20T15:10:18+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "I changed it to move the elements to a temporary yesterday, but it sounds like it's sufficient to use `clear()` to return it to a well-defined valid state, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "1850878834",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3030,
        "pr_file": "src/mbgl/tile/tile_cache.cpp",
        "discussion_id": "1849135631",
        "commented_code": "@@ -26,43 +41,54 @@ void TileCache::setSize(size_t size_) {\n }\n \n namespace {\n-\n-/// This exists solely to prevent a problem where temporary lambda captures\n-/// are retained for the duration of the scope instead of being destroyed immediately.\n-template <typename T>\n+// Capturing `std::vector<std::unique_ptr<Tile>>` directly produces an error related to\n+// copying, but this somehow avoids the same problem.  It may be possible to eliminate it.\n struct CaptureWrapper {\n-    CaptureWrapper(std::unique_ptr<T>&& item_)\n-        : item(std::move(item_)) {}\n-    CaptureWrapper(const CaptureWrapper& other)\n-        : item(other.item) {}\n-    std::shared_ptr<T> item;\n+    std::vector<std::unique_ptr<Tile>> releases;\n+\n+    CaptureWrapper(std::vector<std::unique_ptr<Tile>>&& x)\n+        : releases(std::move(x)) {}\n+    CaptureWrapper(CaptureWrapper&&) = default;\n+    CaptureWrapper& operator=(CaptureWrapper&&) = default;\n+    CaptureWrapper(CaptureWrapper const&) = delete;\n+    CaptureWrapper& operator=(CaptureWrapper const&) = delete;\n };\n } // namespace\n \n void TileCache::deferredRelease(std::unique_ptr<Tile>&& tile) {\n     MLN_TRACE_FUNC();\n \n     tile->cancel();\n+    pendingReleases.push_back(std::move(tile));\n+}\n \n-    // The `std::function` must be created in a separate statement from the `schedule` call.\n-    // Creating a `std::function` from a lambda involves a copy, which is why we must use\n-    // `shared_ptr` rather than `unique_ptr` for the capture.  As a result, a temporary holds\n-    // a reference until the construction is complete and the lambda is destroyed.\n-    // If this temporary outlives the `schedule` call, and the function is executed immediately\n-    // by a waiting thread and is already complete, that temporary reference ends up being the\n-    // last one and the destruction actually occurs here on this thread.\n-    std::function<void()> func{[tile_{CaptureWrapper<Tile>{std::move(tile)}}, this]() mutable {\n-        tile_.item = {};\n-\n-        std::lock_guard<std::mutex> counterLock(deferredSignalLock);\n-        deferredDeletionsPending--;\n-        deferredSignal.notify_all();\n-    }};\n+void TileCache::deferPendingReleases() {\n+    MLN_TRACE_FUNC();\n \n-    std::unique_lock<std::mutex> counterLock(deferredSignalLock);\n-    deferredDeletionsPending++;\n+    constexpr std::size_t scheduleThreshold = 1;\n+    if (pendingReleases.size() < scheduleThreshold) {\n+        return;\n+    }\n+\n+    // Block destruction until the cleanup task is complete\n+    {\n+        std::lock_guard counterLock{deferredSignalLock};\n+        deferredDeletionsPending++;\n+    }\n+\n+    threadPool.schedule(\n+        util::unique_function<void()>{[this, wrap_{CaptureWrapper{std::move(pendingReleases)}}]() mutable {",
        "comment_created_at": "2024-11-20T19:36:13+00:00",
        "comment_author": "louwers",
        "comment_body": "Yes I think that is OK.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1817838951",
    "pr_number": 2968,
    "pr_file": "test/src/mbgl/test/sqlite3_test_fs.cpp",
    "created_at": "2024-10-26T11:58:10+00:00",
    "commented_code": "if (!sqlite3_test_fs_io) {\n         return SQLITE_AUTH;\n     }\n-    auto* unix_fs = (sqlite3_vfs*)vfs->pAppData;\n-    return unix_fs->xAccess(unix_fs, zPath, flags, pResOut);\n+    auto* os_fs = (sqlite3_vfs*)vfs->pAppData;\n+    return os_fs->xAccess(os_fs, zPath, flags, pResOut);\n }\n \n namespace mbgl {\n namespace test {\n \n SQLite3TestFS::SQLite3TestFS() {\n-    sqlite3_vfs* unix_fs = sqlite3_vfs_find(\"unix\");\n-    if (unix_fs == nullptr) {\n+#ifdef WIN32\n+    sqlite3_vfs* os_fs = sqlite3_vfs_find(\"win32\");",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1817838951",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2968,
        "pr_file": "test/src/mbgl/test/sqlite3_test_fs.cpp",
        "discussion_id": "1817838951",
        "commented_code": "@@ -234,16 +234,21 @@ static int sqlite3_test_fs_access(sqlite3_vfs* vfs, const char* zPath, int flags\n     if (!sqlite3_test_fs_io) {\n         return SQLITE_AUTH;\n     }\n-    auto* unix_fs = (sqlite3_vfs*)vfs->pAppData;\n-    return unix_fs->xAccess(unix_fs, zPath, flags, pResOut);\n+    auto* os_fs = (sqlite3_vfs*)vfs->pAppData;\n+    return os_fs->xAccess(os_fs, zPath, flags, pResOut);\n }\n \n namespace mbgl {\n namespace test {\n \n SQLite3TestFS::SQLite3TestFS() {\n-    sqlite3_vfs* unix_fs = sqlite3_vfs_find(\"unix\");\n-    if (unix_fs == nullptr) {\n+#ifdef WIN32\n+    sqlite3_vfs* os_fs = sqlite3_vfs_find(\"win32\");",
        "comment_created_at": "2024-10-26T11:58:10+00:00",
        "comment_author": "louwers",
        "comment_body": "Maybe try passing `nullptr` here?\r\n\r\n> If zVfsName is NULL then the default VFS is returned.\r\n\r\nhttps://www.sqlite.org/c3ref/vfs_find.html",
        "pr_file_module": null
      },
      {
        "comment_id": "1817873230",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2968,
        "pr_file": "test/src/mbgl/test/sqlite3_test_fs.cpp",
        "discussion_id": "1817838951",
        "commented_code": "@@ -234,16 +234,21 @@ static int sqlite3_test_fs_access(sqlite3_vfs* vfs, const char* zPath, int flags\n     if (!sqlite3_test_fs_io) {\n         return SQLITE_AUTH;\n     }\n-    auto* unix_fs = (sqlite3_vfs*)vfs->pAppData;\n-    return unix_fs->xAccess(unix_fs, zPath, flags, pResOut);\n+    auto* os_fs = (sqlite3_vfs*)vfs->pAppData;\n+    return os_fs->xAccess(os_fs, zPath, flags, pResOut);\n }\n \n namespace mbgl {\n namespace test {\n \n SQLite3TestFS::SQLite3TestFS() {\n-    sqlite3_vfs* unix_fs = sqlite3_vfs_find(\"unix\");\n-    if (unix_fs == nullptr) {\n+#ifdef WIN32\n+    sqlite3_vfs* os_fs = sqlite3_vfs_find(\"win32\");",
        "comment_created_at": "2024-10-26T15:41:20+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "Yes, much better this way! Correcting now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647816123",
    "pr_number": 2520,
    "pr_file": "platform/default/src/mbgl/storage/mbtiles_file_source.cpp",
    "created_at": "2024-06-20T16:04:35+00:00",
    "commented_code": "response.noContent = false;\n                 response.expires = Timestamp::max();\n                 response.etag = resource.url;\n+                response.error.release();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1647816123",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2520,
        "pr_file": "platform/default/src/mbgl/storage/mbtiles_file_source.cpp",
        "discussion_id": "1647816123",
        "commented_code": "@@ -209,6 +211,7 @@ class MBTilesFileSource::Impl {\n                 response.noContent = false;\n                 response.expires = Timestamp::max();\n                 response.etag = resource.url;\n+                response.error.release();",
        "comment_created_at": "2024-06-20T16:04:35+00:00",
        "comment_author": "louwers",
        "comment_body": "The memory pointed to by the unique_ptr is not cleaned up after `.release()`.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1647980110",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2520,
        "pr_file": "platform/default/src/mbgl/storage/mbtiles_file_source.cpp",
        "discussion_id": "1647816123",
        "commented_code": "@@ -209,6 +211,7 @@ class MBTilesFileSource::Impl {\n                 response.noContent = false;\n                 response.expires = Timestamp::max();\n                 response.etag = resource.url;\n+                response.error.release();",
        "comment_created_at": "2024-06-20T18:29:00+00:00",
        "comment_author": "nnhubbard",
        "comment_body": "I guess I don't know how to do that. Any tips?",
        "pr_file_module": null
      },
      {
        "comment_id": "1647982395",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2520,
        "pr_file": "platform/default/src/mbgl/storage/mbtiles_file_source.cpp",
        "discussion_id": "1647816123",
        "commented_code": "@@ -209,6 +211,7 @@ class MBTilesFileSource::Impl {\n                 response.noContent = false;\n                 response.expires = Timestamp::max();\n                 response.etag = resource.url;\n+                response.error.release();",
        "comment_created_at": "2024-06-20T18:31:17+00:00",
        "comment_author": "louwers",
        "comment_body": "I think you can just `reset()` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "1647982975",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2520,
        "pr_file": "platform/default/src/mbgl/storage/mbtiles_file_source.cpp",
        "discussion_id": "1647816123",
        "commented_code": "@@ -209,6 +211,7 @@ class MBTilesFileSource::Impl {\n                 response.noContent = false;\n                 response.expires = Timestamp::max();\n                 response.etag = resource.url;\n+                response.error.release();",
        "comment_created_at": "2024-06-20T18:31:47+00:00",
        "comment_author": "nnhubbard",
        "comment_body": "Use `response.error.reset();` ?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1551422227",
    "pr_number": 2202,
    "pr_file": "src/mbgl/style/property_expression.cpp",
    "created_at": "2024-04-04T10:34:40+00:00",
    "commented_code": "#include <mbgl/style/property_expression.hpp>\n \n+#include <mbgl/renderer/paint_property_binder.hpp>\n+#include <mbgl/util/convert.hpp>\n+\n+#if MLN_DRAWABLE_RENDERER\n+#include <mbgl/gfx/gpu_expression.hpp>\n+#endif // MLN_DRAWABLE_RENDERER\n+\n namespace mbgl {\n namespace style {\n \n+namespace {\n+\n+using namespace expression;\n+bool checkGPUCapable(const Expression& expression, const ZoomCurvePtr& zoomCurve) {\n+    return (expression.dependencies == Dependency::Zoom) && !zoomCurve.is<std::nullptr_t>() &&\n+           (expression.getType().is<type::NumberType>() || expression.getType().is<type::ColorType>());\n+}\n+} // namespace\n+\n PropertyExpressionBase::PropertyExpressionBase(std::unique_ptr<expression::Expression> expression_)\n     : expression(std::move(expression_)),\n-      isZoomConstant_(expression::isZoomConstant(*expression)),\n-      isFeatureConstant_(expression::isFeatureConstant(*expression)),\n-      isRuntimeConstant_(expression::isRuntimeConstant(*expression)),\n-      zoomCurve(isZoomConstant_ ? nullptr : expression::findZoomCurveChecked(*expression)) {}\n+      zoomCurve(expression->has(Dependency::Zoom) ? expression::findZoomCurveChecked(*expression) : nullptr),\n+      useIntegerZoom_(false),\n+      isZoomConstant_(!expression->has(Dependency::Zoom)),\n+      isFeatureConstant_(!expression->has(Dependency::Feature)),\n+      isRuntimeConstant_(!expression->has(Dependency::Image)),\n+      isGPUCapable_(checkGPUCapable(*expression, zoomCurve)) {\n+    assert(isZoomConstant_ == expression::isZoomConstant(*expression));\n+    assert(isFeatureConstant_ == expression::isFeatureConstant(*expression));\n+    assert(isRuntimeConstant_ == expression::isRuntimeConstant(*expression));\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(PropertyExpressionBase&& other)\n+    : expression(std::move(other.expression)),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(std::move(other.gpuExpression)),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(std::move(other.zoomCurve)),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(const PropertyExpressionBase& other)\n+    : expression(other.expression),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(other.zoomCurve),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(PropertyExpressionBase&& other) {\n+    expression = std::move(other.expression);\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression = std::move(other.gpuExpression);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(const PropertyExpressionBase& other) {\n+    expression = other.expression;\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression.reset(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+const gfx::GPUExpression* PropertyExpressionBase::getGPUExpression([[maybe_unused]] bool intZoom) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1551422227",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2202,
        "pr_file": "src/mbgl/style/property_expression.cpp",
        "discussion_id": "1551422227",
        "commented_code": "@@ -1,14 +1,100 @@\n #include <mbgl/style/property_expression.hpp>\n \n+#include <mbgl/renderer/paint_property_binder.hpp>\n+#include <mbgl/util/convert.hpp>\n+\n+#if MLN_DRAWABLE_RENDERER\n+#include <mbgl/gfx/gpu_expression.hpp>\n+#endif // MLN_DRAWABLE_RENDERER\n+\n namespace mbgl {\n namespace style {\n \n+namespace {\n+\n+using namespace expression;\n+bool checkGPUCapable(const Expression& expression, const ZoomCurvePtr& zoomCurve) {\n+    return (expression.dependencies == Dependency::Zoom) && !zoomCurve.is<std::nullptr_t>() &&\n+           (expression.getType().is<type::NumberType>() || expression.getType().is<type::ColorType>());\n+}\n+} // namespace\n+\n PropertyExpressionBase::PropertyExpressionBase(std::unique_ptr<expression::Expression> expression_)\n     : expression(std::move(expression_)),\n-      isZoomConstant_(expression::isZoomConstant(*expression)),\n-      isFeatureConstant_(expression::isFeatureConstant(*expression)),\n-      isRuntimeConstant_(expression::isRuntimeConstant(*expression)),\n-      zoomCurve(isZoomConstant_ ? nullptr : expression::findZoomCurveChecked(*expression)) {}\n+      zoomCurve(expression->has(Dependency::Zoom) ? expression::findZoomCurveChecked(*expression) : nullptr),\n+      useIntegerZoom_(false),\n+      isZoomConstant_(!expression->has(Dependency::Zoom)),\n+      isFeatureConstant_(!expression->has(Dependency::Feature)),\n+      isRuntimeConstant_(!expression->has(Dependency::Image)),\n+      isGPUCapable_(checkGPUCapable(*expression, zoomCurve)) {\n+    assert(isZoomConstant_ == expression::isZoomConstant(*expression));\n+    assert(isFeatureConstant_ == expression::isFeatureConstant(*expression));\n+    assert(isRuntimeConstant_ == expression::isRuntimeConstant(*expression));\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(PropertyExpressionBase&& other)\n+    : expression(std::move(other.expression)),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(std::move(other.gpuExpression)),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(std::move(other.zoomCurve)),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(const PropertyExpressionBase& other)\n+    : expression(other.expression),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(other.zoomCurve),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(PropertyExpressionBase&& other) {\n+    expression = std::move(other.expression);\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression = std::move(other.gpuExpression);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(const PropertyExpressionBase& other) {\n+    expression = other.expression;\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression.reset(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+const gfx::GPUExpression* PropertyExpressionBase::getGPUExpression([[maybe_unused]] bool intZoom) {",
        "comment_created_at": "2024-04-04T10:34:40+00:00",
        "comment_author": "louwers",
        "comment_body": "Can you avoid using raw pointers?",
        "pr_file_module": null
      },
      {
        "comment_id": "1556127476",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2202,
        "pr_file": "src/mbgl/style/property_expression.cpp",
        "discussion_id": "1551422227",
        "commented_code": "@@ -1,14 +1,100 @@\n #include <mbgl/style/property_expression.hpp>\n \n+#include <mbgl/renderer/paint_property_binder.hpp>\n+#include <mbgl/util/convert.hpp>\n+\n+#if MLN_DRAWABLE_RENDERER\n+#include <mbgl/gfx/gpu_expression.hpp>\n+#endif // MLN_DRAWABLE_RENDERER\n+\n namespace mbgl {\n namespace style {\n \n+namespace {\n+\n+using namespace expression;\n+bool checkGPUCapable(const Expression& expression, const ZoomCurvePtr& zoomCurve) {\n+    return (expression.dependencies == Dependency::Zoom) && !zoomCurve.is<std::nullptr_t>() &&\n+           (expression.getType().is<type::NumberType>() || expression.getType().is<type::ColorType>());\n+}\n+} // namespace\n+\n PropertyExpressionBase::PropertyExpressionBase(std::unique_ptr<expression::Expression> expression_)\n     : expression(std::move(expression_)),\n-      isZoomConstant_(expression::isZoomConstant(*expression)),\n-      isFeatureConstant_(expression::isFeatureConstant(*expression)),\n-      isRuntimeConstant_(expression::isRuntimeConstant(*expression)),\n-      zoomCurve(isZoomConstant_ ? nullptr : expression::findZoomCurveChecked(*expression)) {}\n+      zoomCurve(expression->has(Dependency::Zoom) ? expression::findZoomCurveChecked(*expression) : nullptr),\n+      useIntegerZoom_(false),\n+      isZoomConstant_(!expression->has(Dependency::Zoom)),\n+      isFeatureConstant_(!expression->has(Dependency::Feature)),\n+      isRuntimeConstant_(!expression->has(Dependency::Image)),\n+      isGPUCapable_(checkGPUCapable(*expression, zoomCurve)) {\n+    assert(isZoomConstant_ == expression::isZoomConstant(*expression));\n+    assert(isFeatureConstant_ == expression::isFeatureConstant(*expression));\n+    assert(isRuntimeConstant_ == expression::isRuntimeConstant(*expression));\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(PropertyExpressionBase&& other)\n+    : expression(std::move(other.expression)),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(std::move(other.gpuExpression)),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(std::move(other.zoomCurve)),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(const PropertyExpressionBase& other)\n+    : expression(other.expression),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(other.zoomCurve),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(PropertyExpressionBase&& other) {\n+    expression = std::move(other.expression);\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression = std::move(other.gpuExpression);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(const PropertyExpressionBase& other) {\n+    expression = other.expression;\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression.reset(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+const gfx::GPUExpression* PropertyExpressionBase::getGPUExpression([[maybe_unused]] bool intZoom) {",
        "comment_created_at": "2024-04-08T16:35:01+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "`shared_ptr` seems excessive here, as if it ever kept something alive it would be a bug, and a `reference_wrapper` or something doesn't seem to really add anything.\r\n\r\nBut mulling this over the weekend, I think it might work out better to create them in the `PropertyExpression` but storing/caching them elsewhere...",
        "pr_file_module": null
      },
      {
        "comment_id": "1556520114",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2202,
        "pr_file": "src/mbgl/style/property_expression.cpp",
        "discussion_id": "1551422227",
        "commented_code": "@@ -1,14 +1,100 @@\n #include <mbgl/style/property_expression.hpp>\n \n+#include <mbgl/renderer/paint_property_binder.hpp>\n+#include <mbgl/util/convert.hpp>\n+\n+#if MLN_DRAWABLE_RENDERER\n+#include <mbgl/gfx/gpu_expression.hpp>\n+#endif // MLN_DRAWABLE_RENDERER\n+\n namespace mbgl {\n namespace style {\n \n+namespace {\n+\n+using namespace expression;\n+bool checkGPUCapable(const Expression& expression, const ZoomCurvePtr& zoomCurve) {\n+    return (expression.dependencies == Dependency::Zoom) && !zoomCurve.is<std::nullptr_t>() &&\n+           (expression.getType().is<type::NumberType>() || expression.getType().is<type::ColorType>());\n+}\n+} // namespace\n+\n PropertyExpressionBase::PropertyExpressionBase(std::unique_ptr<expression::Expression> expression_)\n     : expression(std::move(expression_)),\n-      isZoomConstant_(expression::isZoomConstant(*expression)),\n-      isFeatureConstant_(expression::isFeatureConstant(*expression)),\n-      isRuntimeConstant_(expression::isRuntimeConstant(*expression)),\n-      zoomCurve(isZoomConstant_ ? nullptr : expression::findZoomCurveChecked(*expression)) {}\n+      zoomCurve(expression->has(Dependency::Zoom) ? expression::findZoomCurveChecked(*expression) : nullptr),\n+      useIntegerZoom_(false),\n+      isZoomConstant_(!expression->has(Dependency::Zoom)),\n+      isFeatureConstant_(!expression->has(Dependency::Feature)),\n+      isRuntimeConstant_(!expression->has(Dependency::Image)),\n+      isGPUCapable_(checkGPUCapable(*expression, zoomCurve)) {\n+    assert(isZoomConstant_ == expression::isZoomConstant(*expression));\n+    assert(isFeatureConstant_ == expression::isFeatureConstant(*expression));\n+    assert(isRuntimeConstant_ == expression::isRuntimeConstant(*expression));\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(PropertyExpressionBase&& other)\n+    : expression(std::move(other.expression)),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(std::move(other.gpuExpression)),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(std::move(other.zoomCurve)),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase::PropertyExpressionBase(const PropertyExpressionBase& other)\n+    : expression(other.expression),\n+#if MLN_DRAWABLE_RENDERER\n+      gpuExpression(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr),\n+#endif // MLN_DRAWABLE_RENDERER\n+      zoomCurve(other.zoomCurve),\n+      useIntegerZoom_(other.useIntegerZoom_),\n+      isZoomConstant_(other.isZoomConstant_),\n+      isFeatureConstant_(other.isFeatureConstant_),\n+      isRuntimeConstant_(other.isRuntimeConstant_),\n+      isGPUCapable_(other.isGPUCapable_) {\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(PropertyExpressionBase&& other) {\n+    expression = std::move(other.expression);\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression = std::move(other.gpuExpression);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+PropertyExpressionBase& PropertyExpressionBase::operator=(const PropertyExpressionBase& other) {\n+    expression = other.expression;\n+#if MLN_DRAWABLE_RENDERER\n+    gpuExpression.reset(other.gpuExpression ? new gfx::GPUExpression(*(other.gpuExpression)) : nullptr);\n+#endif // MLN_DRAWABLE_RENDERER\n+    zoomCurve = other.zoomCurve;\n+    useIntegerZoom_ = other.useIntegerZoom_;\n+    isZoomConstant_ = other.isZoomConstant_;\n+    isFeatureConstant_ = other.isFeatureConstant_;\n+    isRuntimeConstant_ = other.isRuntimeConstant_;\n+    isGPUCapable_ = other.isGPUCapable_;\n+    return *this;\n+}\n+\n+const gfx::GPUExpression* PropertyExpressionBase::getGPUExpression([[maybe_unused]] bool intZoom) {",
        "comment_created_at": "2024-04-08T23:04:26+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "I moved the ownership to the layer tweaker, passing them by reference to the property expression for potential updates, and that cleans up the semantics somewhat, though it makes the templates a little uglier.  Still needs some more cleanup, I think.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1264649016",
    "pr_number": 1383,
    "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
    "created_at": "2023-07-16T09:33:50+00:00",
    "commented_code": "class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1264649016",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1383,
        "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
        "discussion_id": "1264649016",
        "commented_code": "@@ -14,19 +14,23 @@ namespace gl {\n \n class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
        "comment_created_at": "2023-07-16T09:33:50+00:00",
        "comment_author": "louwers",
        "comment_body": "```suggestion\r\n                                             nullptr)) {}\r\n```\r\n\r\nMight as well update this as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1264726558",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1383,
        "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
        "discussion_id": "1264649016",
        "commented_code": "@@ -14,19 +14,23 @@ namespace gl {\n \n class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
        "comment_created_at": "2023-07-16T18:32:52+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "I'm calling a C function. Should I use `nullptr` instead `NULL` anyway?",
        "pr_file_module": null
      },
      {
        "comment_id": "1265259335",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1383,
        "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
        "discussion_id": "1264649016",
        "commented_code": "@@ -14,19 +14,23 @@ namespace gl {\n \n class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
        "comment_created_at": "2023-07-17T12:12:03+00:00",
        "comment_author": "louwers",
        "comment_body": "Yes I don't think there's a good reason to use `NULL` in C++ code, even when calling C libraries.",
        "pr_file_module": null
      },
      {
        "comment_id": "1265744173",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1383,
        "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
        "discussion_id": "1264649016",
        "commented_code": "@@ -14,19 +14,23 @@ namespace gl {\n \n class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
        "comment_created_at": "2023-07-17T18:20:06+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "They ultimately mean the same thing, and at least in MSVC/Windows land, NULL is still used in a lot of places. I do agree though a chance to modernize while we're in here is good.",
        "pr_file_module": null
      },
      {
        "comment_id": "1269737982",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1383,
        "pr_file": "platform/windows/src/headless_backend_osmesa.cpp",
        "discussion_id": "1264649016",
        "commented_code": "@@ -14,19 +14,23 @@ namespace gl {\n \n class OSMesaBackendImpl final : public HeadlessBackend::Impl {\n public:\n-    OSMesaBackendImpl() {\n-        context = OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n+    OSMesaBackendImpl()\n+        : buffer(std::make_unique<uint8_t[]>(2048 * 2048 * 4)),\n+          context(OSMesaCreateContextAttribs(std::initializer_list<int>({OSMESA_FORMAT,\n                                                                          OSMESA_RGBA,\n                                                                          OSMESA_DEPTH_BITS,\n                                                                          24,\n                                                                          OSMESA_STENCIL_BITS,\n                                                                          8,\n                                                                          OSMESA_PROFILE,\n                                                                          OSMESA_COMPAT_PROFILE,\n+                                                                         OSMESA_CONTEXT_MAJOR_VERSION,\n+                                                                         3,\n+                                                                         OSMESA_CONTEXT_MINOR_VERSION,\n+                                                                         0,\n                                                                          NULL})\n                                                  .begin(),\n-                                             NULL);\n-    }\n+                                             NULL)) {}",
        "comment_created_at": "2023-07-20T17:03:07+00:00",
        "comment_author": "tdcosta100",
        "comment_body": "Nice. I pushed a new version of this commit with `nullptr` instead of `NULL`.",
        "pr_file_module": null
      }
    ]
  }
]