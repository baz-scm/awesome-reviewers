[
  {
    "discussion_id": "1391127059",
    "pr_number": 1858,
    "pr_file": "src/mbgl/style/parser.hpp",
    "created_at": "2023-11-13T13:38:21+00:00",
    "commented_code": "StyleParseResult parse(const std::string&);\n \n-    std::string spriteURL;\n+    std::vector<std::unique_ptr<Sprite>> sprites;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1391127059",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1858,
        "pr_file": "src/mbgl/style/parser.hpp",
        "discussion_id": "1391127059",
        "commented_code": "@@ -27,7 +27,7 @@ class Parser {\n \n     StyleParseResult parse(const std::string&);\n \n-    std::string spriteURL;\n+    std::vector<std::unique_ptr<Sprite>> sprites;",
        "comment_created_at": "2023-11-13T13:38:21+00:00",
        "comment_author": "louwers",
        "comment_body": "I think using unique pointers but then using `.get()` to get a raw pointer is dangerous because now someone might hold onto a dangling pointer.\r\n\r\nI would try to avoid using raw pointers as much as possible, in this case since `Sprite` is such a lightweight object copying is probably even OK.",
        "pr_file_module": null
      },
      {
        "comment_id": "1403098364",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1858,
        "pr_file": "src/mbgl/style/parser.hpp",
        "discussion_id": "1391127059",
        "commented_code": "@@ -27,7 +27,7 @@ class Parser {\n \n     StyleParseResult parse(const std::string&);\n \n-    std::string spriteURL;\n+    std::vector<std::unique_ptr<Sprite>> sprites;",
        "comment_created_at": "2023-11-23T09:10:57+00:00",
        "comment_author": "geolives-contact",
        "comment_body": "I rewrited `Sprite` to be used as single objets and not references. Sprites are no longer stored into `std::unique_ptr` and are passed by copy. I think also for 2 strings it's not worth using `std::unique_ptr` and potentially struggle with references.\r\nBy copying, we don't use raw pointers from `.get()` anymore.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077524002",
    "pr_number": 3198,
    "pr_file": "include/mbgl/gfx/dynamic_texture_atlas.hpp",
    "created_at": "2025-05-07T12:35:01+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/gfx/dynamic_texture.hpp>\n+#include <mbgl/text/glyph.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+\n+namespace mbgl {\n+\n+namespace gfx {\n+\n+using DynamicTexturePtr = std::shared_ptr<gfx::DynamicTexture>;\n+\n+class GlyphAtlas {\n+public:\n+    GlyphPositions glyphPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class ImageAtlas {\n+public:\n+    ImagePositions iconPositions;\n+    ImagePositions patternPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class DynamicTextureAtlas {\n+public:\n+    DynamicTextureAtlas(Context& context_)\n+        : context(context_) {}\n+    ~DynamicTextureAtlas() = default;\n+\n+    GlyphAtlas uploadGlyphs(const GlyphMap& glyphs);\n+    ImageAtlas uploadIconsAndPatterns(const ImageMap& icons,\n+                                      const ImageMap& patterns,\n+                                      const ImageVersionMap& versionMap);\n+\n+    void removeTextures(const std::vector<TextureHandle>& textureHandles, const DynamicTexturePtr& dynamicTexture);\n+\n+private:\n+    Context& context;\n+    std::vector<DynamicTexturePtr> dynamicTextures;\n+    std::unordered_map<TexturePixelType, DynamicTexturePtr> dummyDynamicTexture;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2077524002",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3198,
        "pr_file": "include/mbgl/gfx/dynamic_texture_atlas.hpp",
        "discussion_id": "2077524002",
        "commented_code": "@@ -0,0 +1,49 @@\n+#pragma once\n+\n+#include <mbgl/gfx/dynamic_texture.hpp>\n+#include <mbgl/text/glyph.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+\n+namespace mbgl {\n+\n+namespace gfx {\n+\n+using DynamicTexturePtr = std::shared_ptr<gfx::DynamicTexture>;\n+\n+class GlyphAtlas {\n+public:\n+    GlyphPositions glyphPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class ImageAtlas {\n+public:\n+    ImagePositions iconPositions;\n+    ImagePositions patternPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class DynamicTextureAtlas {\n+public:\n+    DynamicTextureAtlas(Context& context_)\n+        : context(context_) {}\n+    ~DynamicTextureAtlas() = default;\n+\n+    GlyphAtlas uploadGlyphs(const GlyphMap& glyphs);\n+    ImageAtlas uploadIconsAndPatterns(const ImageMap& icons,\n+                                      const ImageMap& patterns,\n+                                      const ImageVersionMap& versionMap);\n+\n+    void removeTextures(const std::vector<TextureHandle>& textureHandles, const DynamicTexturePtr& dynamicTexture);\n+\n+private:\n+    Context& context;\n+    std::vector<DynamicTexturePtr> dynamicTextures;\n+    std::unordered_map<TexturePixelType, DynamicTexturePtr> dummyDynamicTexture;",
        "comment_created_at": "2025-05-07T12:35:01+00:00",
        "comment_author": "louwers",
        "comment_body": "What is this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2077753095",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3198,
        "pr_file": "include/mbgl/gfx/dynamic_texture_atlas.hpp",
        "discussion_id": "2077524002",
        "commented_code": "@@ -0,0 +1,49 @@\n+#pragma once\n+\n+#include <mbgl/gfx/dynamic_texture.hpp>\n+#include <mbgl/text/glyph.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+\n+namespace mbgl {\n+\n+namespace gfx {\n+\n+using DynamicTexturePtr = std::shared_ptr<gfx::DynamicTexture>;\n+\n+class GlyphAtlas {\n+public:\n+    GlyphPositions glyphPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class ImageAtlas {\n+public:\n+    ImagePositions iconPositions;\n+    ImagePositions patternPositions;\n+    std::vector<TextureHandle> textureHandles;\n+    DynamicTexturePtr dynamicTexture;\n+};\n+\n+class DynamicTextureAtlas {\n+public:\n+    DynamicTextureAtlas(Context& context_)\n+        : context(context_) {}\n+    ~DynamicTextureAtlas() = default;\n+\n+    GlyphAtlas uploadGlyphs(const GlyphMap& glyphs);\n+    ImageAtlas uploadIconsAndPatterns(const ImageMap& icons,\n+                                      const ImageMap& patterns,\n+                                      const ImageVersionMap& versionMap);\n+\n+    void removeTextures(const std::vector<TextureHandle>& textureHandles, const DynamicTexturePtr& dynamicTexture);\n+\n+private:\n+    Context& context;\n+    std::vector<DynamicTexturePtr> dynamicTextures;\n+    std::unordered_map<TexturePixelType, DynamicTexturePtr> dummyDynamicTexture;",
        "comment_created_at": "2025-05-07T14:22:18+00:00",
        "comment_author": "alexcristici",
        "comment_body": "GlyphAtlas and ImageAtlas needs to have a valid texture always in order to pass a transparent render test. When there is a missing texture it should draw nothing = transparent, instead of black, null pointer for texture.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2050447805",
    "pr_number": 3240,
    "pr_file": "platform/ios/src/MLNMapView.mm",
    "created_at": "2025-04-18T10:08:27+00:00",
    "commented_code": "return self.residualStyleURL;\n     }\n \n+    // If style was initialized with JSON, return nil\n+    if (self.mbglMap.getStyle().getJSON().length() > 0 &&\n+        self.mbglMap.getStyle().getURL().empty()) {\n+        return nil;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2050447805",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3240,
        "pr_file": "platform/ios/src/MLNMapView.mm",
        "discussion_id": "2050447805",
        "commented_code": "@@ -552,6 +568,12 @@ - (nonnull NSURL *)styleURL\n         return self.residualStyleURL;\n     }\n \n+    // If style was initialized with JSON, return nil\n+    if (self.mbglMap.getStyle().getJSON().length() > 0 &&\n+        self.mbglMap.getStyle().getURL().empty()) {\n+        return nil;",
        "comment_created_at": "2025-04-18T10:08:27+00:00",
        "comment_author": "louwers",
        "comment_body": "The return type is marked with `nonnull` and the interface with `null_resettable`, which means this getter should not return null if I understand it correctly. We should not modify this, because I think it would change the Swift API.\r\n\r\nMaybe you can return `[NSURL URLWithString:@\"local://style.json\"]` instead?",
        "pr_file_module": null
      }
    ]
  }
]