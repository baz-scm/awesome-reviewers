[
  {
    "discussion_id": "1711762108",
    "pr_number": 2709,
    "pr_file": "include/mbgl/util/lru_cache.hpp",
    "created_at": "2024-08-09T16:25:23+00:00",
    "commented_code": "+#pragma once\n+\n+#include <list>\n+#include <stdexcept>\n+#include <unordered_map>\n+\n+namespace mbgl {\n+\n+// Simple non-thread-safe LRU cache\n+// Item must be hashable\n+template <typename Item>\n+class LRU {\n+public:\n+    // Number of cached items\n+    size_t size() const { return list.size(); }\n+\n+    // Check if cache is empty\n+    bool empty() const { return list.empty(); }\n+",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1711762108",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2709,
        "pr_file": "include/mbgl/util/lru_cache.hpp",
        "discussion_id": "1711762108",
        "commented_code": "@@ -0,0 +1,61 @@\n+#pragma once\n+\n+#include <list>\n+#include <stdexcept>\n+#include <unordered_map>\n+\n+namespace mbgl {\n+\n+// Simple non-thread-safe LRU cache\n+// Item must be hashable\n+template <typename Item>\n+class LRU {\n+public:\n+    // Number of cached items\n+    size_t size() const { return list.size(); }\n+\n+    // Check if cache is empty\n+    bool empty() const { return list.empty(); }\n+",
        "comment_created_at": "2024-08-09T16:25:23+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Consider adding a `reserve` to bypass map rebuilds",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1711770853",
    "pr_number": 2709,
    "pr_file": "src/mbgl/gl/resource_pool.hpp",
    "created_at": "2024-08-09T16:31:15+00:00",
    "commented_code": "+#pragma once\n+\n+#include <cstddef>\n+#include <functional>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include <mbgl/gfx/types.hpp>\n+#include <mbgl/gl/types.hpp>\n+#include <mbgl/util/lru_cache.hpp>\n+#include <mbgl/util/size.hpp>\n+\n+namespace mbgl {\n+namespace gl {\n+\n+class Context;\n+\n+struct Texture2DDesc {\n+    Size size;\n+    gfx::TexturePixelType pixelFormat;\n+    gfx::TextureChannelDataType channelType;\n+};\n+\n+struct Texture2DDescHash {\n+    std::size_t operator()(const Texture2DDesc& desc) const;\n+};\n+\n+inline bool operator==(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return desc1.size == desc2.size && desc1.pixelFormat == desc2.pixelFormat && desc1.channelType == desc2.channelType;\n+}\n+\n+inline bool operator!=(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return !(desc1 == desc2);\n+}\n+\n+class Texture2DPool {\n+public:\n+    // Create a texture pool with a maximum storage size maxPoolStorage in bytes\n+    // If maxPoolStorage is 0, pooling will disabled\n+    Texture2DPool(Context* context, size_t maxPoolStorage = 32 * 1024 * 1024);\n+\n+    // Deallocate all storage\n+    ~Texture2DPool();\n+\n+    // Allocate a texture with the given size, pixel format, and channel type\n+    // If the texture is already allocated in the pool, the existing texture ID will be returned\n+    TextureID alloc(const Size& size, gfx::TexturePixelType pixelFormat, gfx::TextureChannelDataType channelType) {\n+        return alloc({size, pixelFormat, channelType});\n+    }\n+\n+    TextureID alloc(const Texture2DDesc& desc);\n+\n+    // Release the texture but keep it in the pool\n+    void release(TextureID id);\n+\n+    // Free all unused textures\n+    void shrink();\n+\n+    // Get the description of a texture\n+    const Texture2DDesc& desc(TextureID id) const;\n+\n+    // Get the storage size in byte of a texture\n+    size_t storage(TextureID id) const;\n+\n+    // Get the storage size in byte of all textures being used\n+    size_t usedStorage() const;\n+\n+    // Get the storage size in byte of all unused textures\n+    size_t unusedStorage() const;\n+\n+    // Get the storage size in byte of all textures in the pool\n+    size_t storage() const { return poolStorage; }\n+\n+    // Get the maximum storage size before starting to evict unused textures\n+    size_t maxStorage() const { return maxPoolStorage; }\n+\n+    bool empty() const { return poolStorage == 0; }\n+\n+    // Check if a texture is pooled\n+    bool isPooled(TextureID id) const;\n+\n+    // Check if a texture is pooled and being used\n+    bool isUsed(TextureID id) const;\n+\n+    // Check if a texture is pooled but released\n+    bool isUnused(TextureID id) const;\n+\n+private:\n+    struct TextureSet {\n+        std::unordered_set<TextureID> free;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1711770853",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2709,
        "pr_file": "src/mbgl/gl/resource_pool.hpp",
        "discussion_id": "1711770853",
        "commented_code": "@@ -0,0 +1,118 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <functional>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include <mbgl/gfx/types.hpp>\n+#include <mbgl/gl/types.hpp>\n+#include <mbgl/util/lru_cache.hpp>\n+#include <mbgl/util/size.hpp>\n+\n+namespace mbgl {\n+namespace gl {\n+\n+class Context;\n+\n+struct Texture2DDesc {\n+    Size size;\n+    gfx::TexturePixelType pixelFormat;\n+    gfx::TextureChannelDataType channelType;\n+};\n+\n+struct Texture2DDescHash {\n+    std::size_t operator()(const Texture2DDesc& desc) const;\n+};\n+\n+inline bool operator==(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return desc1.size == desc2.size && desc1.pixelFormat == desc2.pixelFormat && desc1.channelType == desc2.channelType;\n+}\n+\n+inline bool operator!=(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return !(desc1 == desc2);\n+}\n+\n+class Texture2DPool {\n+public:\n+    // Create a texture pool with a maximum storage size maxPoolStorage in bytes\n+    // If maxPoolStorage is 0, pooling will disabled\n+    Texture2DPool(Context* context, size_t maxPoolStorage = 32 * 1024 * 1024);\n+\n+    // Deallocate all storage\n+    ~Texture2DPool();\n+\n+    // Allocate a texture with the given size, pixel format, and channel type\n+    // If the texture is already allocated in the pool, the existing texture ID will be returned\n+    TextureID alloc(const Size& size, gfx::TexturePixelType pixelFormat, gfx::TextureChannelDataType channelType) {\n+        return alloc({size, pixelFormat, channelType});\n+    }\n+\n+    TextureID alloc(const Texture2DDesc& desc);\n+\n+    // Release the texture but keep it in the pool\n+    void release(TextureID id);\n+\n+    // Free all unused textures\n+    void shrink();\n+\n+    // Get the description of a texture\n+    const Texture2DDesc& desc(TextureID id) const;\n+\n+    // Get the storage size in byte of a texture\n+    size_t storage(TextureID id) const;\n+\n+    // Get the storage size in byte of all textures being used\n+    size_t usedStorage() const;\n+\n+    // Get the storage size in byte of all unused textures\n+    size_t unusedStorage() const;\n+\n+    // Get the storage size in byte of all textures in the pool\n+    size_t storage() const { return poolStorage; }\n+\n+    // Get the maximum storage size before starting to evict unused textures\n+    size_t maxStorage() const { return maxPoolStorage; }\n+\n+    bool empty() const { return poolStorage == 0; }\n+\n+    // Check if a texture is pooled\n+    bool isPooled(TextureID id) const;\n+\n+    // Check if a texture is pooled and being used\n+    bool isUsed(TextureID id) const;\n+\n+    // Check if a texture is pooled but released\n+    bool isUnused(TextureID id) const;\n+\n+private:\n+    struct TextureSet {\n+        std::unordered_set<TextureID> free;",
        "comment_created_at": "2024-08-09T16:31:15+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Use `mbgl::unordered_set`, consider using `reserve`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1714083686",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2709,
        "pr_file": "src/mbgl/gl/resource_pool.hpp",
        "discussion_id": "1711770853",
        "commented_code": "@@ -0,0 +1,118 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <functional>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include <mbgl/gfx/types.hpp>\n+#include <mbgl/gl/types.hpp>\n+#include <mbgl/util/lru_cache.hpp>\n+#include <mbgl/util/size.hpp>\n+\n+namespace mbgl {\n+namespace gl {\n+\n+class Context;\n+\n+struct Texture2DDesc {\n+    Size size;\n+    gfx::TexturePixelType pixelFormat;\n+    gfx::TextureChannelDataType channelType;\n+};\n+\n+struct Texture2DDescHash {\n+    std::size_t operator()(const Texture2DDesc& desc) const;\n+};\n+\n+inline bool operator==(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return desc1.size == desc2.size && desc1.pixelFormat == desc2.pixelFormat && desc1.channelType == desc2.channelType;\n+}\n+\n+inline bool operator!=(const Texture2DDesc& desc1, const Texture2DDesc& desc2) {\n+    return !(desc1 == desc2);\n+}\n+\n+class Texture2DPool {\n+public:\n+    // Create a texture pool with a maximum storage size maxPoolStorage in bytes\n+    // If maxPoolStorage is 0, pooling will disabled\n+    Texture2DPool(Context* context, size_t maxPoolStorage = 32 * 1024 * 1024);\n+\n+    // Deallocate all storage\n+    ~Texture2DPool();\n+\n+    // Allocate a texture with the given size, pixel format, and channel type\n+    // If the texture is already allocated in the pool, the existing texture ID will be returned\n+    TextureID alloc(const Size& size, gfx::TexturePixelType pixelFormat, gfx::TextureChannelDataType channelType) {\n+        return alloc({size, pixelFormat, channelType});\n+    }\n+\n+    TextureID alloc(const Texture2DDesc& desc);\n+\n+    // Release the texture but keep it in the pool\n+    void release(TextureID id);\n+\n+    // Free all unused textures\n+    void shrink();\n+\n+    // Get the description of a texture\n+    const Texture2DDesc& desc(TextureID id) const;\n+\n+    // Get the storage size in byte of a texture\n+    size_t storage(TextureID id) const;\n+\n+    // Get the storage size in byte of all textures being used\n+    size_t usedStorage() const;\n+\n+    // Get the storage size in byte of all unused textures\n+    size_t unusedStorage() const;\n+\n+    // Get the storage size in byte of all textures in the pool\n+    size_t storage() const { return poolStorage; }\n+\n+    // Get the maximum storage size before starting to evict unused textures\n+    size_t maxStorage() const { return maxPoolStorage; }\n+\n+    bool empty() const { return poolStorage == 0; }\n+\n+    // Check if a texture is pooled\n+    bool isPooled(TextureID id) const;\n+\n+    // Check if a texture is pooled and being used\n+    bool isUsed(TextureID id) const;\n+\n+    // Check if a texture is pooled but released\n+    bool isUnused(TextureID id) const;\n+\n+private:\n+    struct TextureSet {\n+        std::unordered_set<TextureID> free;",
        "comment_created_at": "2024-08-12T16:33:00+00:00",
        "comment_author": "alasram",
        "comment_body": "The cache is very sparse with many sets containing a single texture",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1336173473",
    "pr_number": 1678,
    "pr_file": "include/mbgl/renderer/layer_tweaker.hpp",
    "created_at": "2023-09-25T17:07:30+00:00",
    "commented_code": "protected:\n     std::string id;\n     Immutable<style::LayerProperties> evaluatedProperties;\n-    bool propertiesUpdated = true;\n \n #if MLN_RENDER_BACKEND_METAL\n     // For Metal, whether a property is provided through attribtues or uniforms is specified in\n     // a uniform buffer rather than by a shader compiled with different preprocessor definitions.\n     std::vector<std::string> propertiesAsUniforms;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1336173473",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1678,
        "pr_file": "include/mbgl/renderer/layer_tweaker.hpp",
        "discussion_id": "1336173473",
        "commented_code": "@@ -78,14 +86,15 @@ class LayerTweaker {\n protected:\n     std::string id;\n     Immutable<style::LayerProperties> evaluatedProperties;\n-    bool propertiesUpdated = true;\n \n #if MLN_RENDER_BACKEND_METAL\n     // For Metal, whether a property is provided through attribtues or uniforms is specified in\n     // a uniform buffer rather than by a shader compiled with different preprocessor definitions.\n     std::vector<std::string> propertiesAsUniforms;",
        "comment_created_at": "2023-09-25T17:07:30+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "This could benefit from `StringIndexer`, and could become a `std::unordered_set<StringIdentity>` and that could help with performance in `LayerTweaker::hasPropertyAsUniform` which is called per frame to build the `permutationUBO`",
        "pr_file_module": null
      },
      {
        "comment_id": "1336219921",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1678,
        "pr_file": "include/mbgl/renderer/layer_tweaker.hpp",
        "discussion_id": "1336173473",
        "commented_code": "@@ -78,14 +86,15 @@ class LayerTweaker {\n protected:\n     std::string id;\n     Immutable<style::LayerProperties> evaluatedProperties;\n-    bool propertiesUpdated = true;\n \n #if MLN_RENDER_BACKEND_METAL\n     // For Metal, whether a property is provided through attribtues or uniforms is specified in\n     // a uniform buffer rather than by a shader compiled with different preprocessor definitions.\n     std::vector<std::string> propertiesAsUniforms;",
        "comment_created_at": "2023-09-25T17:56:29+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "This PR doesn't add `propertiesAsUniforms`, so I'd suggest that should be in a separate one.  \r\nThat optimization should apply all the way through, including the return of `readDataDrivenPaintProperties` and the arguments of `getOrCreateShader`",
        "pr_file_module": null
      },
      {
        "comment_id": "1336230172",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1678,
        "pr_file": "include/mbgl/renderer/layer_tweaker.hpp",
        "discussion_id": "1336173473",
        "commented_code": "@@ -78,14 +86,15 @@ class LayerTweaker {\n protected:\n     std::string id;\n     Immutable<style::LayerProperties> evaluatedProperties;\n-    bool propertiesUpdated = true;\n \n #if MLN_RENDER_BACKEND_METAL\n     // For Metal, whether a property is provided through attribtues or uniforms is specified in\n     // a uniform buffer rather than by a shader compiled with different preprocessor definitions.\n     std::vector<std::string> propertiesAsUniforms;",
        "comment_created_at": "2023-09-25T18:07:06+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "Correct. I created an issue for that. #1687 ",
        "pr_file_module": null
      }
    ]
  }
]