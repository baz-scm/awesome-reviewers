[
  {
    "discussion_id": "2167124941",
    "pr_number": 3576,
    "pr_file": "include/mbgl/shaders/mtl/symbol.hpp",
    "created_at": "2025-06-25T16:20:44+00:00",
    "commented_code": "device const SymbolDrawableUBO& drawable = drawableVector[uboIndex];\n \n+    const float2 fade_opacity = unpack_opacity(vertx.fade_opacity);\n+    const float fade_change = (fade_opacity[1] > 0.5) ? paintParams.symbol_fade_change : -paintParams.symbol_fade_change;\n+    const half fo = half(max(0.0, min(1.0, fade_opacity[0] + fade_change)));\n+\n+)\"\n+#if MTL_SDF_SHADER_VERTEX_CULLING_ENABLED\n+                                   R\"(\n+    if (fo == 0.0) {\n+        return {\n+            .position     = float4(-2.0, -2.0, -2.0, 1.0),",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2167124941",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3576,
        "pr_file": "include/mbgl/shaders/mtl/symbol.hpp",
        "discussion_id": "2167124941",
        "commented_code": "@@ -493,6 +523,22 @@ FragmentStage vertex vertexMain(thread const VertexStage vertx [[stage_in]],\n \n     device const SymbolDrawableUBO& drawable = drawableVector[uboIndex];\n \n+    const float2 fade_opacity = unpack_opacity(vertx.fade_opacity);\n+    const float fade_change = (fade_opacity[1] > 0.5) ? paintParams.symbol_fade_change : -paintParams.symbol_fade_change;\n+    const half fo = half(max(0.0, min(1.0, fade_opacity[0] + fade_change)));\n+\n+)\"\n+#if MTL_SDF_SHADER_VERTEX_CULLING_ENABLED\n+                                   R\"(\n+    if (fo == 0.0) {\n+        return {\n+            .position     = float4(-2.0, -2.0, -2.0, 1.0),",
        "comment_created_at": "2025-06-25T16:20:44+00:00",
        "comment_author": "alexcristici",
        "comment_body": "Let's name this position `(-2.0, -2.0, -2.0, 1.0)` in a constant for an easier understanding in the future.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2059904008",
    "pr_number": 3401,
    "pr_file": "platform/ios/src/MLNMapView.mm",
    "created_at": "2025-04-25T09:36:06+00:00",
    "commented_code": "if (headingDirection >= 0 && self.userTrackingMode == MLNUserTrackingModeFollowWithHeading\n             && self.userTrackingState != MLNUserTrackingStateBegan)\n         {\n-            [self _setDirection:headingDirection animated:YES];\n+            [self _setDirection:headingDirection shouldCenter:YES animated:YES];",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2059904008",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3401,
        "pr_file": "platform/ios/src/MLNMapView.mm",
        "discussion_id": "2059904008",
        "commented_code": "@@ -6428,7 +6445,7 @@ - (void)locationManager:(__unused id<MLNLocationManager>)manager didUpdateHeadin\n         if (headingDirection >= 0 && self.userTrackingMode == MLNUserTrackingModeFollowWithHeading\n             && self.userTrackingState != MLNUserTrackingStateBegan)\n         {\n-            [self _setDirection:headingDirection animated:YES];\n+            [self _setDirection:headingDirection shouldCenter:YES animated:YES];",
        "comment_created_at": "2025-04-25T09:36:06+00:00",
        "comment_author": "louwers",
        "comment_body": "I understand `_setDirection` needs the current location so that it can do the animation in one go, but maybe consider passing the center instead of a boolean. I don't think the `_setDirection` method should have anything to do with the location manager.",
        "pr_file_module": null
      },
      {
        "comment_id": "2059992337",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3401,
        "pr_file": "platform/ios/src/MLNMapView.mm",
        "discussion_id": "2059904008",
        "commented_code": "@@ -6428,7 +6445,7 @@ - (void)locationManager:(__unused id<MLNLocationManager>)manager didUpdateHeadin\n         if (headingDirection >= 0 && self.userTrackingMode == MLNUserTrackingModeFollowWithHeading\n             && self.userTrackingState != MLNUserTrackingStateBegan)\n         {\n-            [self _setDirection:headingDirection animated:YES];\n+            [self _setDirection:headingDirection shouldCenter:YES animated:YES];",
        "comment_created_at": "2025-04-25T10:34:39+00:00",
        "comment_author": "GenChe",
        "comment_body": "I changed parameter from `shouldCenter` to `center`. And so public `setDirection` method passes `kCLLocationCoordinate2DInvalid` to private `_setDirection` to avoid centering.",
        "pr_file_module": null
      },
      {
        "comment_id": "2071237232",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3401,
        "pr_file": "platform/ios/src/MLNMapView.mm",
        "discussion_id": "2059904008",
        "commented_code": "@@ -6428,7 +6445,7 @@ - (void)locationManager:(__unused id<MLNLocationManager>)manager didUpdateHeadin\n         if (headingDirection >= 0 && self.userTrackingMode == MLNUserTrackingModeFollowWithHeading\n             && self.userTrackingState != MLNUserTrackingStateBegan)\n         {\n-            [self _setDirection:headingDirection animated:YES];\n+            [self _setDirection:headingDirection shouldCenter:YES animated:YES];",
        "comment_created_at": "2025-05-02T07:51:09+00:00",
        "comment_author": "GenChe",
        "comment_body": "@louwers is there anything else that needs to be changed or you are fine with it? \r\n\r\nThis is a quite important feature for us, and we want to have it merged (and released) as soon as possible.",
        "pr_file_module": null
      },
      {
        "comment_id": "2071348706",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3401,
        "pr_file": "platform/ios/src/MLNMapView.mm",
        "discussion_id": "2059904008",
        "commented_code": "@@ -6428,7 +6445,7 @@ - (void)locationManager:(__unused id<MLNLocationManager>)manager didUpdateHeadin\n         if (headingDirection >= 0 && self.userTrackingMode == MLNUserTrackingModeFollowWithHeading\n             && self.userTrackingState != MLNUserTrackingStateBegan)\n         {\n-            [self _setDirection:headingDirection animated:YES];\n+            [self _setDirection:headingDirection shouldCenter:YES animated:YES];",
        "comment_created_at": "2025-05-02T09:26:32+00:00",
        "comment_author": "louwers",
        "comment_body": "Looks good now, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1673113013",
    "pr_number": 2590,
    "pr_file": "include/mbgl/renderer/renderer.hpp",
    "created_at": "2024-07-10T22:16:10+00:00",
    "commented_code": "const std::vector<PlacedSymbolData>& getPlacedSymbolsData() const;\n \n     // Memory\n+    void enableTileCache(bool);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1673113013",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2590,
        "pr_file": "include/mbgl/renderer/renderer.hpp",
        "discussion_id": "1673113013",
        "commented_code": "@@ -108,6 +108,7 @@ class Renderer {\n     const std::vector<PlacedSymbolData>& getPlacedSymbolsData() const;\n \n     // Memory\n+    void enableTileCache(bool);",
        "comment_created_at": "2024-07-10T22:16:10+00:00",
        "comment_author": "louwers",
        "comment_body": "Perhaps this should (also) be called `setTileCacheEnabled(bool)` because it is a bit clearer that it actually disables the tile cache when passing `false`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1676120059",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2590,
        "pr_file": "include/mbgl/renderer/renderer.hpp",
        "discussion_id": "1673113013",
        "commented_code": "@@ -108,6 +108,7 @@ class Renderer {\n     const std::vector<PlacedSymbolData>& getPlacedSymbolsData() const;\n \n     // Memory\n+    void enableTileCache(bool);",
        "comment_created_at": "2024-07-12T15:40:05+00:00",
        "comment_author": "alexcristici",
        "comment_body": "Renamed. üëç ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1291445147",
    "pr_number": 1455,
    "pr_file": "platform/ios/src/MLNMapView.h",
    "created_at": "2023-08-11T14:58:27+00:00",
    "commented_code": "*/\n - (CGPoint)anchorPointForGesture:(UIGestureRecognizer *)gesture;\n \n+\n+/**\n+ * Sets a LatLngBounds that constraints map transformations to this bounds.\n+ * @param latLngBounds the bounds to constrain the map with\n+ */\n+- (void)setLatLngBounds:(MLNCoordinateBounds)latLngBounds;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1291445147",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1455,
        "pr_file": "platform/ios/src/MLNMapView.h",
        "discussion_id": "1291445147",
        "commented_code": "@@ -1364,6 +1364,18 @@ MLN_EXPORT\n  */\n - (CGPoint)anchorPointForGesture:(UIGestureRecognizer *)gesture;\n \n+\n+/**\n+ * Sets a LatLngBounds that constraints map transformations to this bounds.\n+ * @param latLngBounds the bounds to constrain the map with\n+ */\n+- (void)setLatLngBounds:(MLNCoordinateBounds)latLngBounds;",
        "comment_created_at": "2023-08-11T14:58:27+00:00",
        "comment_author": "1ec5",
        "comment_body": "Can it be called something other than `setLatLngBounds`? The iOS/macOS SDK now has a method named after the Android SDK‚Äôs `LatLngBounds` class, which makes little sense. That class is analogous to the `MLNCoordinateBounds` struct on iOS/macOS, so it should be called something like `setCoordinateBounds`.\r\n\r\nBetter yet, it should be modeled as a property called something more descriptive like `viewableCoordinateBounds`. As it is, this is a write-only property, nearly unprecedented in any Objective-C framework. ‚ÄúClearing‚Äù the coordinate bounds could be tricky because `MLNCoordinateBounds` is a struct, which can‚Äôt nullable (optional) in Objective-C. Typically, this library has dealt with that issue by allowing the property to be set to a magic value of some kind. In this case, MLNGeometry.h could define a constant `MLNCoordinateBoundsWorld` that encompasses the entire coordinate system.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1269711729",
    "pr_number": 1355,
    "pr_file": "include/mbgl/renderer/layer_group.hpp",
    "created_at": "2023-07-20T16:36:24+00:00",
    "commented_code": "+#pragma once\n+\n+#include <mbgl/renderer/render_pass.hpp>\n+#include <mbgl/tile/tile_id.hpp>\n+#include <mbgl/util/identity.hpp>\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace mbgl {\n+class LayerGroupBase;\n+class PaintParameters;\n+class RenderOrchestrator;\n+class TileLayerGroup;\n+\n+using LayerGroupBasePtr = std::shared_ptr<LayerGroupBase>;\n+\n+namespace gfx {\n+class Context;\n+class Drawable;\n+class UploadPass;\n+\n+using DrawablePtr = std::shared_ptr<Drawable>;\n+using UniqueDrawable = std::unique_ptr<Drawable>;\n+} // namespace gfx\n+\n+class LayerTweaker;\n+using LayerTweakerPtr = std::shared_ptr<LayerTweaker>;\n+\n+/**\n+    A layer-like group of drawables, not a group of layers.\n+ */\n+class LayerGroupBase : public util::SimpleIdentifiable {\n+protected:\n+    LayerGroupBase(int32_t layerIndex, std::string name = std::string());\n+\n+public:\n+    LayerGroupBase(const LayerGroupBase&) = delete;\n+    LayerGroupBase& operator=(const LayerGroupBase&) = delete;\n+    ~LayerGroupBase() override = default;\n+\n+    /// Whether the drawables should be drawn\n+    bool getEnabled() const { return enabled; }\n+    void setEnabled(bool value) { enabled = value; }\n+\n+    const std::string& getName() const { return name; }\n+    void setName(std::string value) { name = std::move(value); }\n+\n+    int32_t getLayerIndex() const { return layerIndex; }\n+\n+    void updateLayerIndex(int32_t value) { layerIndex = value; }\n+\n+    virtual std::size_t getDrawableCount() const = 0;\n+    bool empty() const { return getDrawableCount() == 0; }\n+\n+    virtual std::size_t clearDrawables() = 0;\n+\n+    /// Add a drawable\n+    void addDrawable(gfx::UniqueDrawable&);\n+\n+    /// Called before starting each frame\n+    virtual void preRender(RenderOrchestrator&, PaintParameters&) {}\n+    /// Called during the upload pass\n+    virtual void upload(gfx::UploadPass&) {}\n+    /// Called during each render pass\n+    virtual void render(RenderOrchestrator&, PaintParameters&) {}\n+    /// Called at the end of each frame\n+    virtual void postRender(RenderOrchestrator&, PaintParameters&) {}\n+\n+    /// Call the provided function for each drawable in priority order\n+    virtual std::size_t observeDrawables(const std::function<void(gfx::Drawable&)>&&) = 0;\n+    virtual std::size_t observeDrawables(const std::function<void(const gfx::Drawable&)>&&) const = 0;\n+\n+    /// Call the provided function for each drawable in undefined order, allowing for removal.\n+    /// @param f A function called with each drawable, returning true to keep and false to discard it.\n+    /// @return The number of items removed\n+    virtual std::size_t observeDrawablesRemove(const std::function<bool(gfx::Drawable&)>&& f) = 0;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1269711729",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1355,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1269711729",
        "commented_code": "@@ -0,0 +1,152 @@\n+#pragma once\n+\n+#include <mbgl/renderer/render_pass.hpp>\n+#include <mbgl/tile/tile_id.hpp>\n+#include <mbgl/util/identity.hpp>\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace mbgl {\n+class LayerGroupBase;\n+class PaintParameters;\n+class RenderOrchestrator;\n+class TileLayerGroup;\n+\n+using LayerGroupBasePtr = std::shared_ptr<LayerGroupBase>;\n+\n+namespace gfx {\n+class Context;\n+class Drawable;\n+class UploadPass;\n+\n+using DrawablePtr = std::shared_ptr<Drawable>;\n+using UniqueDrawable = std::unique_ptr<Drawable>;\n+} // namespace gfx\n+\n+class LayerTweaker;\n+using LayerTweakerPtr = std::shared_ptr<LayerTweaker>;\n+\n+/**\n+    A layer-like group of drawables, not a group of layers.\n+ */\n+class LayerGroupBase : public util::SimpleIdentifiable {\n+protected:\n+    LayerGroupBase(int32_t layerIndex, std::string name = std::string());\n+\n+public:\n+    LayerGroupBase(const LayerGroupBase&) = delete;\n+    LayerGroupBase& operator=(const LayerGroupBase&) = delete;\n+    ~LayerGroupBase() override = default;\n+\n+    /// Whether the drawables should be drawn\n+    bool getEnabled() const { return enabled; }\n+    void setEnabled(bool value) { enabled = value; }\n+\n+    const std::string& getName() const { return name; }\n+    void setName(std::string value) { name = std::move(value); }\n+\n+    int32_t getLayerIndex() const { return layerIndex; }\n+\n+    void updateLayerIndex(int32_t value) { layerIndex = value; }\n+\n+    virtual std::size_t getDrawableCount() const = 0;\n+    bool empty() const { return getDrawableCount() == 0; }\n+\n+    virtual std::size_t clearDrawables() = 0;\n+\n+    /// Add a drawable\n+    void addDrawable(gfx::UniqueDrawable&);\n+\n+    /// Called before starting each frame\n+    virtual void preRender(RenderOrchestrator&, PaintParameters&) {}\n+    /// Called during the upload pass\n+    virtual void upload(gfx::UploadPass&) {}\n+    /// Called during each render pass\n+    virtual void render(RenderOrchestrator&, PaintParameters&) {}\n+    /// Called at the end of each frame\n+    virtual void postRender(RenderOrchestrator&, PaintParameters&) {}\n+\n+    /// Call the provided function for each drawable in priority order\n+    virtual std::size_t observeDrawables(const std::function<void(gfx::Drawable&)>&&) = 0;\n+    virtual std::size_t observeDrawables(const std::function<void(const gfx::Drawable&)>&&) const = 0;\n+\n+    /// Call the provided function for each drawable in undefined order, allowing for removal.\n+    /// @param f A function called with each drawable, returning true to keep and false to discard it.\n+    /// @return The number of items removed\n+    virtual std::size_t observeDrawablesRemove(const std::function<bool(gfx::Drawable&)>&& f) = 0;",
        "comment_created_at": "2023-07-20T16:36:24+00:00",
        "comment_author": "louwers",
        "comment_body": "`removeDrawablesIf` sounds like a much better name here.",
        "pr_file_module": null
      }
    ]
  }
]