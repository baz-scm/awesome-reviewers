[
  {
    "discussion_id": "1408411079",
    "pr_number": 1897,
    "pr_file": "include/mbgl/gfx/polyline_generator.hpp",
    "created_at": "2023-11-28T20:56:42+00:00",
    "commented_code": "#include <mbgl/gfx/index_vector.hpp>\n #include <mbgl/programs/segment.hpp>\n #include <mbgl/util/math.hpp>\n+#include <mbgl/util/constants.hpp>\n+#include <mbgl/programs/line_program.hpp>\n \n #include <cstdint>\n #include <cstddef>\n #include <memory>\n #include <vector>\n-#include <functional>\n #include <optional>\n \n namespace mbgl {\n namespace gfx {\n \n-class PolylineGeneratorDistances {\n+namespace PolylineGenerator {\n+/*\n+ * Sharp corners cause dashed lines to tilt because the distance along the line\n+ * is the same at both the inner and outer corners. To improve the appearance of\n+ * dashed lines we add extra points near sharp corners so that a smaller part\n+ * of the line is tilted.\n+ *\n+ * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an\n+ * extra vertex. The default is 75 degrees.\n+ *\n+ * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.\n+ */\n+const float COS_HALF_SHARP_CORNER = std::cos(75.0f / 2.0f * (static_cast<float>(M_PI) / 180.0f));\n+constexpr float SHARP_CORNER_OFFSET = 15.0f;\n+\n+// Angle per triangle for approximating round line joins.\n+constexpr float DEG_PER_TRIANGLE = 20.0f;\n+\n+// The number of bits that is used to store the line distance in the buffer.\n+constexpr int LINE_DISTANCE_BUFFER_BITS = 14;\n+\n+// We don't have enough bits for the line distance as we'd like to have, so\n+// use this value to scale the line distance (in tile units) down to a smaller\n+// value. This lets us store longer distances while sacrificing precision.\n+constexpr float LINE_DISTANCE_SCALE = 1.0 / 2.0;\n+\n+// The maximum line distance, in tile units, that fits in the buffer.\n+constexpr auto MAX_LINE_DISTANCE = static_cast<float>((1u << LINE_DISTANCE_BUFFER_BITS) / LINE_DISTANCE_SCALE);\n+\n+class Distances {\n+private:\n public:\n-    PolylineGeneratorDistances(double clipStart_, double clipEnd_, double total_)\n+    Distances(double clipStart_, double clipEnd_, double total_)\n         : clipStart(clipStart_),\n           clipEnd(clipEnd_),\n           total(total_) {}\n \n     // Scale line distance from tile units to [0, 2^15).\n-    double scaleToMaxLineDistance(double tileDistance) const;\n+    double scaleToMaxLineDistance(double tileDistance) const {\n+        double relativeTileDistance = tileDistance / total;\n+        if (std::isinf(relativeTileDistance) || std::isnan(relativeTileDistance)) {\n+            assert(false);\n+            relativeTileDistance = 0.0;\n+        }\n+        return (relativeTileDistance * (clipEnd - clipStart) + clipStart) * (MAX_LINE_DISTANCE - 1);\n+    }\n \n private:\n     double clipStart;\n     double clipEnd;\n     double total;\n };\n \n-struct PolylineGeneratorOptions {\n+struct Options {\n     FeatureType type{FeatureType::LineString};\n     style::LineJoinType joinType{style::LineJoinType::Miter};\n     float miterLimit{2.f};\n     style::LineCapType beginCap{style::LineCapType::Butt};\n     style::LineCapType endCap{style::LineCapType::Butt};\n     float roundLimit{1.f};\n     uint32_t overscaling{1};\n-    std::optional<PolylineGeneratorDistances> clipDistances;\n+    std::optional<Distances> clipDistances;\n };\n \n-template <class PolylineLayoutVertex, class PolylineSegment>\n-class PolylineGenerator {\n-public:\n-    using Vertices = gfx::VertexVector<PolylineLayoutVertex>;\n-    using Segments = std::vector<PolylineSegment>;\n-    using LayoutVertexFunc = std::function<PolylineLayoutVertex(\n-        Point<int16_t> p, Point<double> e, bool round, bool up, int8_t dir, int32_t linesofar /*= 0*/)>;\n-    using CreateSegmentFunc = std::function<PolylineSegment(std::size_t vertexOffset, std::size_t indexOffset)>;\n-    using GetSegmentFunc = std::function<mbgl::SegmentBase&(PolylineSegment& segment)>;\n-    using Indexes = gfx::IndexVector<gfx::Triangles>;\n+template <class Vertices,\n+          class LayoutVertexFunc,\n+          class Segments,\n+          class CreateSegmentFunc,\n+          class GetSegmentFunc,\n+          class Indexes>\n+static void generate(Vertices& vertices,\n+                     LayoutVertexFunc layoutVertex,\n+                     Segments& segments,\n+                     CreateSegmentFunc createSegment,\n+                     GetSegmentFunc getSegment,\n+                     Indexes& indexes,\n+                     const GeometryCoordinates& coordinates,\n+                     const Options& options);\n \n-public:\n-    PolylineGenerator(Vertices& polylineVertices,\n-                      LayoutVertexFunc layoutVertexFunc,\n-                      Segments& polylineSegments,\n-                      CreateSegmentFunc createSegmentFunc,\n-                      GetSegmentFunc getSegmentFunc,\n-                      Indexes& polylineIndexes);\n-    ~PolylineGenerator() = default;\n+namespace detail {\n+template <class Vertices, class LayoutVertexFunc, class TriangleElement, class Distances>\n+void addCurrentVertex(const std::size_t index,\n+                      Vertices& vertices,\n+                      LayoutVertexFunc layoutVertex,\n+                      const GeometryCoordinate& currentCoordinate,\n+                      double& distance,\n+                      const Point<double>& normal,\n+                      double endLeft,\n+                      double endRight,\n+                      bool round,\n+                      std::size_t startVertex,\n+                      std::vector<TriangleElement>& triangleStore,\n+                      std::optional<Distances> lineDistances,\n+                      std::ptrdiff_t& e1,\n+                      std::ptrdiff_t& e2,\n+                      std::ptrdiff_t& e3);\n \n-    void generate(const GeometryCoordinates& coordinates, const PolylineGeneratorOptions& options);\n+template <class Vertices, class LayoutVertexFunc, class TriangleElement, class Distances>\n+void addPieSliceVertex([[maybe_unused]] const std::size_t index,\n+                       Vertices& vertices,\n+                       LayoutVertexFunc layoutVertex,\n+                       const GeometryCoordinate& currentVertex,\n+                       double distance,\n+                       const Point<double>& extrude,\n+                       bool lineTurnsLeft,\n+                       std::size_t startVertex,\n+                       std::vector<TriangleElement>& triangleStore,\n+                       std::optional<Distances> lineDistances,\n+                       std::ptrdiff_t& e1,\n+                       std::ptrdiff_t& e2,\n+                       std::ptrdiff_t& e3);\n+} // namespace detail\n \n-private:\n-    struct TriangleElement;\n-\n-    void addCurrentVertex(const GeometryCoordinate& currentCoordinate,\n-                          double& distance,\n-                          const Point<double>& normal,\n-                          double endLeft,\n-                          double endRight,\n-                          bool round,\n-                          std::size_t startVertex,\n-                          std::vector<TriangleElement>& triangleStore,\n-                          std::optional<PolylineGeneratorDistances> lineDistances);\n-    void addPieSliceVertex(const GeometryCoordinate& currentVertex,\n-                           double distance,\n-                           const Point<double>& extrude,\n-                           bool lineTurnsLeft,\n-                           std::size_t startVertex,\n-                           std::vector<TriangleElement>& triangleStore,\n-                           std::optional<PolylineGeneratorDistances> lineDistances);\n+} // namespace PolylineGenerator\n \n-private:\n-    Vertices& vertices;\n-    LayoutVertexFunc layoutVertex;\n-    Segments& segments;\n-    CreateSegmentFunc createSegment;\n-    GetSegmentFunc getSegment;\n-    Indexes& indexes;\n+template <class Vertices,\n+          class LayoutVertexFunc,\n+          class Segments,\n+          class CreateSegmentFunc,\n+          class GetSegmentFunc,\n+          class Indexes>\n+void PolylineGenerator::generate(Vertices& vertices,\n+                                 LayoutVertexFunc layoutVertex,",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1408411079",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1897,
        "pr_file": "include/mbgl/gfx/polyline_generator.hpp",
        "discussion_id": "1408411079",
        "commented_code": "@@ -7,97 +7,823 @@\n #include <mbgl/gfx/index_vector.hpp>\n #include <mbgl/programs/segment.hpp>\n #include <mbgl/util/math.hpp>\n+#include <mbgl/util/constants.hpp>\n+#include <mbgl/programs/line_program.hpp>\n \n #include <cstdint>\n #include <cstddef>\n #include <memory>\n #include <vector>\n-#include <functional>\n #include <optional>\n \n namespace mbgl {\n namespace gfx {\n \n-class PolylineGeneratorDistances {\n+namespace PolylineGenerator {\n+/*\n+ * Sharp corners cause dashed lines to tilt because the distance along the line\n+ * is the same at both the inner and outer corners. To improve the appearance of\n+ * dashed lines we add extra points near sharp corners so that a smaller part\n+ * of the line is tilted.\n+ *\n+ * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an\n+ * extra vertex. The default is 75 degrees.\n+ *\n+ * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.\n+ */\n+const float COS_HALF_SHARP_CORNER = std::cos(75.0f / 2.0f * (static_cast<float>(M_PI) / 180.0f));\n+constexpr float SHARP_CORNER_OFFSET = 15.0f;\n+\n+// Angle per triangle for approximating round line joins.\n+constexpr float DEG_PER_TRIANGLE = 20.0f;\n+\n+// The number of bits that is used to store the line distance in the buffer.\n+constexpr int LINE_DISTANCE_BUFFER_BITS = 14;\n+\n+// We don't have enough bits for the line distance as we'd like to have, so\n+// use this value to scale the line distance (in tile units) down to a smaller\n+// value. This lets us store longer distances while sacrificing precision.\n+constexpr float LINE_DISTANCE_SCALE = 1.0 / 2.0;\n+\n+// The maximum line distance, in tile units, that fits in the buffer.\n+constexpr auto MAX_LINE_DISTANCE = static_cast<float>((1u << LINE_DISTANCE_BUFFER_BITS) / LINE_DISTANCE_SCALE);\n+\n+class Distances {\n+private:\n public:\n-    PolylineGeneratorDistances(double clipStart_, double clipEnd_, double total_)\n+    Distances(double clipStart_, double clipEnd_, double total_)\n         : clipStart(clipStart_),\n           clipEnd(clipEnd_),\n           total(total_) {}\n \n     // Scale line distance from tile units to [0, 2^15).\n-    double scaleToMaxLineDistance(double tileDistance) const;\n+    double scaleToMaxLineDistance(double tileDistance) const {\n+        double relativeTileDistance = tileDistance / total;\n+        if (std::isinf(relativeTileDistance) || std::isnan(relativeTileDistance)) {\n+            assert(false);\n+            relativeTileDistance = 0.0;\n+        }\n+        return (relativeTileDistance * (clipEnd - clipStart) + clipStart) * (MAX_LINE_DISTANCE - 1);\n+    }\n \n private:\n     double clipStart;\n     double clipEnd;\n     double total;\n };\n \n-struct PolylineGeneratorOptions {\n+struct Options {\n     FeatureType type{FeatureType::LineString};\n     style::LineJoinType joinType{style::LineJoinType::Miter};\n     float miterLimit{2.f};\n     style::LineCapType beginCap{style::LineCapType::Butt};\n     style::LineCapType endCap{style::LineCapType::Butt};\n     float roundLimit{1.f};\n     uint32_t overscaling{1};\n-    std::optional<PolylineGeneratorDistances> clipDistances;\n+    std::optional<Distances> clipDistances;\n };\n \n-template <class PolylineLayoutVertex, class PolylineSegment>\n-class PolylineGenerator {\n-public:\n-    using Vertices = gfx::VertexVector<PolylineLayoutVertex>;\n-    using Segments = std::vector<PolylineSegment>;\n-    using LayoutVertexFunc = std::function<PolylineLayoutVertex(\n-        Point<int16_t> p, Point<double> e, bool round, bool up, int8_t dir, int32_t linesofar /*= 0*/)>;\n-    using CreateSegmentFunc = std::function<PolylineSegment(std::size_t vertexOffset, std::size_t indexOffset)>;\n-    using GetSegmentFunc = std::function<mbgl::SegmentBase&(PolylineSegment& segment)>;\n-    using Indexes = gfx::IndexVector<gfx::Triangles>;\n+template <class Vertices,\n+          class LayoutVertexFunc,\n+          class Segments,\n+          class CreateSegmentFunc,\n+          class GetSegmentFunc,\n+          class Indexes>\n+static void generate(Vertices& vertices,\n+                     LayoutVertexFunc layoutVertex,\n+                     Segments& segments,\n+                     CreateSegmentFunc createSegment,\n+                     GetSegmentFunc getSegment,\n+                     Indexes& indexes,\n+                     const GeometryCoordinates& coordinates,\n+                     const Options& options);\n \n-public:\n-    PolylineGenerator(Vertices& polylineVertices,\n-                      LayoutVertexFunc layoutVertexFunc,\n-                      Segments& polylineSegments,\n-                      CreateSegmentFunc createSegmentFunc,\n-                      GetSegmentFunc getSegmentFunc,\n-                      Indexes& polylineIndexes);\n-    ~PolylineGenerator() = default;\n+namespace detail {\n+template <class Vertices, class LayoutVertexFunc, class TriangleElement, class Distances>\n+void addCurrentVertex(const std::size_t index,\n+                      Vertices& vertices,\n+                      LayoutVertexFunc layoutVertex,\n+                      const GeometryCoordinate& currentCoordinate,\n+                      double& distance,\n+                      const Point<double>& normal,\n+                      double endLeft,\n+                      double endRight,\n+                      bool round,\n+                      std::size_t startVertex,\n+                      std::vector<TriangleElement>& triangleStore,\n+                      std::optional<Distances> lineDistances,\n+                      std::ptrdiff_t& e1,\n+                      std::ptrdiff_t& e2,\n+                      std::ptrdiff_t& e3);\n \n-    void generate(const GeometryCoordinates& coordinates, const PolylineGeneratorOptions& options);\n+template <class Vertices, class LayoutVertexFunc, class TriangleElement, class Distances>\n+void addPieSliceVertex([[maybe_unused]] const std::size_t index,\n+                       Vertices& vertices,\n+                       LayoutVertexFunc layoutVertex,\n+                       const GeometryCoordinate& currentVertex,\n+                       double distance,\n+                       const Point<double>& extrude,\n+                       bool lineTurnsLeft,\n+                       std::size_t startVertex,\n+                       std::vector<TriangleElement>& triangleStore,\n+                       std::optional<Distances> lineDistances,\n+                       std::ptrdiff_t& e1,\n+                       std::ptrdiff_t& e2,\n+                       std::ptrdiff_t& e3);\n+} // namespace detail\n \n-private:\n-    struct TriangleElement;\n-\n-    void addCurrentVertex(const GeometryCoordinate& currentCoordinate,\n-                          double& distance,\n-                          const Point<double>& normal,\n-                          double endLeft,\n-                          double endRight,\n-                          bool round,\n-                          std::size_t startVertex,\n-                          std::vector<TriangleElement>& triangleStore,\n-                          std::optional<PolylineGeneratorDistances> lineDistances);\n-    void addPieSliceVertex(const GeometryCoordinate& currentVertex,\n-                           double distance,\n-                           const Point<double>& extrude,\n-                           bool lineTurnsLeft,\n-                           std::size_t startVertex,\n-                           std::vector<TriangleElement>& triangleStore,\n-                           std::optional<PolylineGeneratorDistances> lineDistances);\n+} // namespace PolylineGenerator\n \n-private:\n-    Vertices& vertices;\n-    LayoutVertexFunc layoutVertex;\n-    Segments& segments;\n-    CreateSegmentFunc createSegment;\n-    GetSegmentFunc getSegment;\n-    Indexes& indexes;\n+template <class Vertices,\n+          class LayoutVertexFunc,\n+          class Segments,\n+          class CreateSegmentFunc,\n+          class GetSegmentFunc,\n+          class Indexes>\n+void PolylineGenerator::generate(Vertices& vertices,\n+                                 LayoutVertexFunc layoutVertex,",
        "comment_created_at": "2023-11-28T20:56:42+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "I think in this case (and for `addCurrentVertex`), it's probably preferable to stick with `std::function`. What I expect to happen here is each unique lambda instantiates a new instance of this template. Since there is a lot of code in this template function, each new lambda given duplicates all this code. That quickly sends the trade-off in the other direction towards `std::function` the moment more than one lambda is passed to this template. Since each lambda is unique and the template approach is an almost certain inline, that prevents the compiler from de-duping the 95+% of the function body that is otherwise identical.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1402373198",
    "pr_number": 1883,
    "pr_file": "include/mbgl/renderer/layer_group.hpp",
    "created_at": "2023-11-22T16:27:49+00:00",
    "commented_code": "std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1402373198",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-22T16:27:49+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "I'm not super happy with this, but I can't specialize a template member function that also accepts a lambda without using `std::function` to erase the lambda type.",
        "pr_file_module": null
      },
      {
        "comment_id": "1402390202",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-22T16:41:09+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "maybe something like this would work?\r\n\r\n```\r\n        if constexpr (!std::is_invocable<Func, gfx::Drawable&>::value) {\r\n               static_assert(...)\r\n        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1402422457",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-22T17:07:26+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "The problem stems from the polymorphism of LayerGroupBase - a template virtual function isn't possible, so we need to know what kind of layer group we're dealing with to then invoke the right instance's visit template.",
        "pr_file_module": null
      },
      {
        "comment_id": "1402488879",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-22T18:01:42+00:00",
        "comment_author": "louwers",
        "comment_body": "Are there more lightweight `std::function` alternatives?",
        "pr_file_module": null
      },
      {
        "comment_id": "1402682833",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-22T20:26:51+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "I don't think so. There are two aspects to overhead with `std::function`, allocation and indirection. We probably weren't incurring allocation overhead in any of these changes, but we were paying the indirection cost.\r\n\r\n`std::function`'s type erasure works by using virtual dispatch. The compiler can't inline these virtual function calls as the functions provided could vary and *possibly* carry an allocated closure.",
        "pr_file_module": null
      },
      {
        "comment_id": "1406227939",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1883,
        "pr_file": "include/mbgl/renderer/layer_group.hpp",
        "discussion_id": "1402373198",
        "commented_code": "@@ -154,15 +203,78 @@ class LayerGroup : public LayerGroupBase {\n     std::vector<gfx::UniqueDrawable> removeDrawables(mbgl::RenderPass);\n     void addDrawable(gfx::UniqueDrawable&&);\n \n-    std::size_t visitDrawables(const std::function<void(gfx::Drawable&)>&&) override;\n-    std::size_t visitDrawables(const std::function<void(const gfx::Drawable&)>&&) const override;\n-    std::size_t removeDrawablesIf(const std::function<bool(gfx::Drawable&)>&&) override;\n+    template <typename Func /* void(gfx::Drawable&) */>\n+    std::size_t visitDrawables(Func f) {\n+        for (const auto& item : drawables) {\n+            if (item) {\n+                f(*item);\n+            }\n+        }\n+        return drawables.size();\n+    }\n+\n+    template <typename Func /* bool(gfx::Drawable&) */>\n+    std::size_t removeDrawablesIf(Func f) {\n+        decltype(drawables) newSet;\n+        const auto oldSize = drawables.size();\n+        while (!drawables.empty()) {\n+            // set members are immutable, since changes could affect its position, so extract each item\n+            gfx::UniqueDrawable drawable = std::move(drawables.extract(drawables.begin()).value());\n+            if (!f(*drawable)) {\n+                // Not removed, keep it, but in a new set so that if the key value\n+                // has increased, we don't see it again during this iteration.\n+                newSet.emplace_hint(newSet.end(), std::move(drawable));\n+            }\n+        }\n+        std::swap(drawables, newSet);\n+        return (oldSize - drawables.size());\n+    }\n \n     std::size_t clearDrawables() override;\n \n protected:\n-    struct Impl;\n-    std::unique_ptr<Impl> impl;\n+    using DrawableCollection = std::set<gfx::UniqueDrawable, gfx::DrawableLessByPriority>;\n+    DrawableCollection drawables;\n };\n \n+template <typename Func /* void(gfx::Drawable&) */>\n+void visitLayerGroupDrawables(mbgl::LayerGroupBase& layerGroup, Func dg) {\n+    switch (layerGroup.getType()) {",
        "comment_created_at": "2023-11-27T14:16:48+00:00",
        "comment_author": "louwers",
        "comment_body": "This solution is pretty easy to understand. There may be a fancier solution but looks OK to me.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1340107836",
    "pr_number": 1697,
    "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
    "created_at": "2023-09-28T12:56:23+00:00",
    "commented_code": "public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1340107836",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1697,
        "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
        "discussion_id": "1340107836",
        "commented_code": "@@ -13,36 +15,54 @@ class ShaderGroupGL final : public gfx::ShaderGroup {\n public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
        "comment_created_at": "2023-09-28T12:56:23+00:00",
        "comment_author": "louwers",
        "comment_body": "I guess nameIDs are small so this doens't overflow right?\r\n\r\nShould this maybe be extracted in a function? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1340183846",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1697,
        "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
        "discussion_id": "1340107836",
        "commented_code": "@@ -13,36 +15,54 @@ class ShaderGroupGL final : public gfx::ShaderGroup {\n public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
        "comment_created_at": "2023-09-28T13:46:08+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "+1 extract this to a function. In particular, comment the usage of `somePrime` as the FNV prime (assuming this is where it came from).",
        "pr_file_module": null
      },
      {
        "comment_id": "1340217220",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1697,
        "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
        "discussion_id": "1340107836",
        "commented_code": "@@ -13,36 +15,54 @@ class ShaderGroupGL final : public gfx::ShaderGroup {\n public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
        "comment_created_at": "2023-09-28T14:09:27+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "There's probably a better way to do this and I'd rather replace it entirely, but I don't disagree.  It'll overflow, but that's fine; the results don't need to be ordered, just unique, and come out the same regardless of the input ordering.\r\n\r\nThis seems a bit lame, especially with the possibility of a collision, but using a `std::set` where each element is allocated separately is also bad.  I was thinking about using a custom class instead of `unordered_set<StringIdentity>` that wraps a vector, since we have ~10-ish elements max, but I'm not sure it's worth the effort.",
        "pr_file_module": null
      },
      {
        "comment_id": "1340490577",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1697,
        "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
        "discussion_id": "1340107836",
        "commented_code": "@@ -13,36 +15,54 @@ class ShaderGroupGL final : public gfx::ShaderGroup {\n public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
        "comment_created_at": "2023-09-28T17:48:32+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Done.  Thoughts?",
        "pr_file_module": null
      },
      {
        "comment_id": "1340495720",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1697,
        "pr_file": "include/mbgl/shaders/gl/shader_group_gl.hpp",
        "discussion_id": "1340107836",
        "commented_code": "@@ -13,36 +15,54 @@ class ShaderGroupGL final : public gfx::ShaderGroup {\n public:\n     ShaderGroupGL(const ProgramParameters& programParameters_)\n         : ShaderGroup(),\n-          programParameters(programParameters_){};\n+          programParameters(programParameters_) {}\n     ~ShaderGroupGL() noexcept override = default;\n \n     gfx::ShaderPtr getOrCreateShader(gfx::Context& context,\n-                                     const std::vector<std::string>& propertiesAsUniforms,\n+                                     const std::unordered_set<StringIdentity>& propertiesAsUniforms,\n                                      std::string_view firstAttribName) override {\n         constexpr auto& name = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::name;\n         constexpr auto& vert = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::vertex;\n         constexpr auto& frag = shaders::ShaderSource<ShaderID, gfx::Backend::Type::OpenGL>::fragment;\n \n-        uint32_t key = 0;\n+        // quick-n-dirty order-indepdendent hash combine\n+        size_t sum = 0, product = 1;\n+        for (const auto nameID : propertiesAsUniforms) {\n+            constexpr auto somePrime = 1099511628211ll;\n+            sum += nameID;\n+            product *= nameID * somePrime;",
        "comment_created_at": "2023-09-28T17:53:27+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "Looks good.",
        "pr_file_module": null
      }
    ]
  }
]