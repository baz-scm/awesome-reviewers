[
  {
    "discussion_id": "2126930701",
    "pr_number": 3430,
    "pr_file": "src/mbgl/plugin/plugin_layer_factory.cpp",
    "created_at": "2025-06-04T15:48:27+00:00",
    "commented_code": "+#include \"plugin_layer_factory.hpp\"\n+#include \"plugin_layer.hpp\"\n+#include \"plugin_layer_impl.hpp\"\n+#include \"plugin_layer_render.hpp\"\n+// #include \"plugin_layer_bucket.hpp\"\n+#include <mbgl/style/conversion_impl.hpp>\n+#include <iostream>\n+#include <string>\n+#include \"plugin_layer_debug.hpp\"\n+\n+namespace mbgl {\n+\n+namespace plugins {\n+\n+// This is really hacky, but wanted to do it here to discuss if the\n+// const can be removed from teh regular LayerTypeInfo\n+struct NonConstLayerTypeInfo {\n+    const char* type;\n+    enum class Source {\n+        Required,\n+        NotRequired\n+    } source;\n+    enum class Pass3D {\n+        Required,\n+        NotRequired\n+    } pass3d;\n+    enum class Layout {\n+        Required,\n+        NotRequired\n+    } layout;\n+    enum class FadingTiles {\n+        Required,\n+        NotRequired\n+    } fadingTiles;\n+    enum class CrossTileIndex {\n+        Required,\n+        NotRequired\n+    } crossTileIndex;\n+    enum class TileKind : uint8_t {\n+        Geometry,\n+        Raster,\n+        RasterDEM,\n+        NotRequired\n+    } tileKind;\n+};\n+\n+} // namespace plugins\n+\n+style::LayerTypeInfo getDefaultInfo() {\n+    style::LayerTypeInfo tempResult = {.type = \"unknown\",\n+                                       .source = style::LayerTypeInfo::Source::Required,\n+                                       .pass3d = style::LayerTypeInfo::Pass3D::Required,\n+                                       .layout = style::LayerTypeInfo::Layout::NotRequired,\n+                                       .fadingTiles = style::LayerTypeInfo::FadingTiles::NotRequired,\n+                                       .crossTileIndex = style::LayerTypeInfo::CrossTileIndex::NotRequired,\n+                                       .tileKind = style::LayerTypeInfo::TileKind::Geometry};\n+    return tempResult;\n+}\n+\n+PluginLayerFactory::PluginLayerFactory(std::string& layerType,\n+                                       mbgl::style::LayerTypeInfo::Source source,\n+                                       mbgl::style::LayerTypeInfo::Pass3D pass3D,\n+                                       mbgl::style::LayerTypeInfo::Layout layout,\n+                                       mbgl::style::LayerTypeInfo::FadingTiles fadingTiles,\n+                                       mbgl::style::LayerTypeInfo::CrossTileIndex crossTileIndex,\n+                                       mbgl::style::LayerTypeInfo::TileKind tileKind)\n+    : _layerTypeInfo(getDefaultInfo()),\n+      _layerType(layerType) {\n+    _layerTypeInfo.type = layerType.c_str();\n+    plugins::NonConstLayerTypeInfo* lti = (plugins::NonConstLayerTypeInfo*)&_layerTypeInfo;\n+    lti->source = (plugins::NonConstLayerTypeInfo::Source)((int)source);\n+    lti->pass3d = (plugins::NonConstLayerTypeInfo::Pass3D)((int)pass3D);\n+    lti->layout = (plugins::NonConstLayerTypeInfo::Layout)((int)layout);\n+    lti->fadingTiles = (plugins::NonConstLayerTypeInfo::FadingTiles)((int)fadingTiles);\n+    lti->crossTileIndex = (plugins::NonConstLayerTypeInfo::CrossTileIndex)((int)crossTileIndex);\n+    lti->tileKind = (plugins::NonConstLayerTypeInfo::TileKind)((int)tileKind);\n+}\n+\n+const style::LayerTypeInfo* PluginLayerFactory::getTypeInfo() const noexcept {\n+    return &_layerTypeInfo;\n+}\n+\n+void jsonStringFromConvertible(const style::conversion::Convertible& value, std::string& output) {\n+    if (isObject(value)) {\n+        output.append(\"{\");\n+        bool firstItem = true;\n+        eachMember(value,\n+                   [&output, &firstItem](const std::string& name, const style::conversion::Convertible& value)\n+                       -> std::optional<style::conversion::Error> {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+                       std::cout << \"Working on: \" << name << \"\n\";\n+#endif\n+\n+                       if (!firstItem) {\n+                           output.append(\",\");\n+                       }\n+                       firstItem = false;\n+                       output.append(\"\\\"\");\n+                       output.append(name);\n+                       output.append(\"\\\":\");\n+\n+                       jsonStringFromConvertible(value, output);\n+\n+                       return std::nullopt;\n+                   });\n+        output.append(\"}\");\n+    } else if (isArray(value)) {\n+        output.append(\"[\");\n+        bool firstItem = true;\n+\n+        for (size_t i = 0; i < arrayLength(value); i++) {\n+            if (!firstItem) {\n+                output.append(\",\");\n+            }\n+            firstItem = false;\n+\n+            auto itemValue = arrayMember(value, i);\n+            jsonStringFromConvertible(itemValue, output);\n+        }\n+\n+        output.append(\"]\");\n+    } else {\n+        /*\n+         DECLARE_VALUE_TYPE_ACCESOR(Int, int64_t)\n+         DECLARE_VALUE_TYPE_ACCESOR(Uint, uint64_t)\n+         DECLARE_VALUE_TYPE_ACCESOR(Bool, bool)\n+         DECLARE_VALUE_TYPE_ACCESOR(Double, double)\n+         DECLARE_VALUE_TYPE_ACCESOR(Array, array_type)\n+         DECLARE_VALUE_TYPE_ACCESOR(Object, object_type)\n+         DECLARE_VALUE_TYPE_ACCESOR(String, std::string)\n+\n+         */\n+        auto v = toValue(value);\n+        if (auto i = v.value().getInt()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Int: \" << i << \"\n\";\n+#endif\n+            std::string tempResult = std::to_string(*i);\n+            output.append(tempResult);\n+        } else if (auto i = v.value().getUint()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Int: \" << i << \"\n\";\n+#endif\n+            std::string tempResult = std::to_string(*i);\n+            output.append(tempResult);\n+\n+        } else if (auto s = v.value().getString()) {\n+            output.append(\"\\\"\");\n+            output.append(v.value().getString()->c_str());\n+            output.append(\"\\\"\");\n+\n+            //  std::cout << \"String: \" << v.value().getString()->c_str() << \"\n\";\n+        } else if (auto d = v.value().getDouble()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Double: \" << d << \"\n\";\n+#endif\n+\n+            output.append(std::to_string(*d));\n+        }\n+        //        std::cout << v.value().getInt() << \"\n\";\n+        //        if (v == std::nullopt) {\n+        //            // This means there's no value.. skip\n+        //        } else if (v.has_value()) {\n+        //\n+        //        }\n+    }\n+}\n+\n+std::unique_ptr<style::Layer> PluginLayerFactory::createLayer(const std::string& id,\n+                                                              const style::conversion::Convertible& value) noexcept {\n+    // TODO: What is this and how does it fit in\n+    //    const auto source = getSource(value);\n+    //    if (!source) {\n+    //        return nullptr;\n+    //    }\n+\n+    std::string layerProperties;\n+\n+    if (auto memberValue = objectMember(value, \"properties\")) {\n+        jsonStringFromConvertible(*memberValue, layerProperties);\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+        std::cout << \"Properties: \" << layerProperties << \"\n\";\n+#endif\n+        if (isObject(*memberValue)) {\n+            eachMember(*memberValue,\n+                       [](const std::string& name, const style::conversion::Convertible& value)\n+                           -> std::optional<style::conversion::Error> { return std::nullopt; });\n+        }\n+\n+        // if (isArray(memberValue)) {\n+        //            for (size_t i=0; i < arrayLength(memberValue); i++) {\n+        //                auto itemValue = arrayMember(memberValue, i);\n+        //            }\n+        //}\n+        //        if (auto error_ = layer->setProperty(member, *memberValue)) {\n+        //            error = *error_;\n+        //            return false;\n+        //        }\n+    }\n+\n+    std::string source = \"source\";\n+\n+    auto tempResult = std::unique_ptr<style::Layer>(new (std::nothrow)\n+                                                        style::PluginLayer(id, source, _layerTypeInfo, layerProperties\n+                                                                           //,*customProperties\n+                                                                           ));\n+\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2126930701",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "src/mbgl/plugin/plugin_layer_factory.cpp",
        "discussion_id": "2126930701",
        "commented_code": "@@ -0,0 +1,263 @@\n+#include \"plugin_layer_factory.hpp\"\n+#include \"plugin_layer.hpp\"\n+#include \"plugin_layer_impl.hpp\"\n+#include \"plugin_layer_render.hpp\"\n+// #include \"plugin_layer_bucket.hpp\"\n+#include <mbgl/style/conversion_impl.hpp>\n+#include <iostream>\n+#include <string>\n+#include \"plugin_layer_debug.hpp\"\n+\n+namespace mbgl {\n+\n+namespace plugins {\n+\n+// This is really hacky, but wanted to do it here to discuss if the\n+// const can be removed from teh regular LayerTypeInfo\n+struct NonConstLayerTypeInfo {\n+    const char* type;\n+    enum class Source {\n+        Required,\n+        NotRequired\n+    } source;\n+    enum class Pass3D {\n+        Required,\n+        NotRequired\n+    } pass3d;\n+    enum class Layout {\n+        Required,\n+        NotRequired\n+    } layout;\n+    enum class FadingTiles {\n+        Required,\n+        NotRequired\n+    } fadingTiles;\n+    enum class CrossTileIndex {\n+        Required,\n+        NotRequired\n+    } crossTileIndex;\n+    enum class TileKind : uint8_t {\n+        Geometry,\n+        Raster,\n+        RasterDEM,\n+        NotRequired\n+    } tileKind;\n+};\n+\n+} // namespace plugins\n+\n+style::LayerTypeInfo getDefaultInfo() {\n+    style::LayerTypeInfo tempResult = {.type = \"unknown\",\n+                                       .source = style::LayerTypeInfo::Source::Required,\n+                                       .pass3d = style::LayerTypeInfo::Pass3D::Required,\n+                                       .layout = style::LayerTypeInfo::Layout::NotRequired,\n+                                       .fadingTiles = style::LayerTypeInfo::FadingTiles::NotRequired,\n+                                       .crossTileIndex = style::LayerTypeInfo::CrossTileIndex::NotRequired,\n+                                       .tileKind = style::LayerTypeInfo::TileKind::Geometry};\n+    return tempResult;\n+}\n+\n+PluginLayerFactory::PluginLayerFactory(std::string& layerType,\n+                                       mbgl::style::LayerTypeInfo::Source source,\n+                                       mbgl::style::LayerTypeInfo::Pass3D pass3D,\n+                                       mbgl::style::LayerTypeInfo::Layout layout,\n+                                       mbgl::style::LayerTypeInfo::FadingTiles fadingTiles,\n+                                       mbgl::style::LayerTypeInfo::CrossTileIndex crossTileIndex,\n+                                       mbgl::style::LayerTypeInfo::TileKind tileKind)\n+    : _layerTypeInfo(getDefaultInfo()),\n+      _layerType(layerType) {\n+    _layerTypeInfo.type = layerType.c_str();\n+    plugins::NonConstLayerTypeInfo* lti = (plugins::NonConstLayerTypeInfo*)&_layerTypeInfo;\n+    lti->source = (plugins::NonConstLayerTypeInfo::Source)((int)source);\n+    lti->pass3d = (plugins::NonConstLayerTypeInfo::Pass3D)((int)pass3D);\n+    lti->layout = (plugins::NonConstLayerTypeInfo::Layout)((int)layout);\n+    lti->fadingTiles = (plugins::NonConstLayerTypeInfo::FadingTiles)((int)fadingTiles);\n+    lti->crossTileIndex = (plugins::NonConstLayerTypeInfo::CrossTileIndex)((int)crossTileIndex);\n+    lti->tileKind = (plugins::NonConstLayerTypeInfo::TileKind)((int)tileKind);\n+}\n+\n+const style::LayerTypeInfo* PluginLayerFactory::getTypeInfo() const noexcept {\n+    return &_layerTypeInfo;\n+}\n+\n+void jsonStringFromConvertible(const style::conversion::Convertible& value, std::string& output) {\n+    if (isObject(value)) {\n+        output.append(\"{\");\n+        bool firstItem = true;\n+        eachMember(value,\n+                   [&output, &firstItem](const std::string& name, const style::conversion::Convertible& value)\n+                       -> std::optional<style::conversion::Error> {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+                       std::cout << \"Working on: \" << name << \"\\n\";\n+#endif\n+\n+                       if (!firstItem) {\n+                           output.append(\",\");\n+                       }\n+                       firstItem = false;\n+                       output.append(\"\\\"\");\n+                       output.append(name);\n+                       output.append(\"\\\":\");\n+\n+                       jsonStringFromConvertible(value, output);\n+\n+                       return std::nullopt;\n+                   });\n+        output.append(\"}\");\n+    } else if (isArray(value)) {\n+        output.append(\"[\");\n+        bool firstItem = true;\n+\n+        for (size_t i = 0; i < arrayLength(value); i++) {\n+            if (!firstItem) {\n+                output.append(\",\");\n+            }\n+            firstItem = false;\n+\n+            auto itemValue = arrayMember(value, i);\n+            jsonStringFromConvertible(itemValue, output);\n+        }\n+\n+        output.append(\"]\");\n+    } else {\n+        /*\n+         DECLARE_VALUE_TYPE_ACCESOR(Int, int64_t)\n+         DECLARE_VALUE_TYPE_ACCESOR(Uint, uint64_t)\n+         DECLARE_VALUE_TYPE_ACCESOR(Bool, bool)\n+         DECLARE_VALUE_TYPE_ACCESOR(Double, double)\n+         DECLARE_VALUE_TYPE_ACCESOR(Array, array_type)\n+         DECLARE_VALUE_TYPE_ACCESOR(Object, object_type)\n+         DECLARE_VALUE_TYPE_ACCESOR(String, std::string)\n+\n+         */\n+        auto v = toValue(value);\n+        if (auto i = v.value().getInt()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Int: \" << i << \"\\n\";\n+#endif\n+            std::string tempResult = std::to_string(*i);\n+            output.append(tempResult);\n+        } else if (auto i = v.value().getUint()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Int: \" << i << \"\\n\";\n+#endif\n+            std::string tempResult = std::to_string(*i);\n+            output.append(tempResult);\n+\n+        } else if (auto s = v.value().getString()) {\n+            output.append(\"\\\"\");\n+            output.append(v.value().getString()->c_str());\n+            output.append(\"\\\"\");\n+\n+            //  std::cout << \"String: \" << v.value().getString()->c_str() << \"\\n\";\n+        } else if (auto d = v.value().getDouble()) {\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+            std::cout << \"Double: \" << d << \"\\n\";\n+#endif\n+\n+            output.append(std::to_string(*d));\n+        }\n+        //        std::cout << v.value().getInt() << \"\\n\";\n+        //        if (v == std::nullopt) {\n+        //            // This means there's no value.. skip\n+        //        } else if (v.has_value()) {\n+        //\n+        //        }\n+    }\n+}\n+\n+std::unique_ptr<style::Layer> PluginLayerFactory::createLayer(const std::string& id,\n+                                                              const style::conversion::Convertible& value) noexcept {\n+    // TODO: What is this and how does it fit in\n+    //    const auto source = getSource(value);\n+    //    if (!source) {\n+    //        return nullptr;\n+    //    }\n+\n+    std::string layerProperties;\n+\n+    if (auto memberValue = objectMember(value, \"properties\")) {\n+        jsonStringFromConvertible(*memberValue, layerProperties);\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED\n+        std::cout << \"Properties: \" << layerProperties << \"\\n\";\n+#endif\n+        if (isObject(*memberValue)) {\n+            eachMember(*memberValue,\n+                       [](const std::string& name, const style::conversion::Convertible& value)\n+                           -> std::optional<style::conversion::Error> { return std::nullopt; });\n+        }\n+\n+        // if (isArray(memberValue)) {\n+        //            for (size_t i=0; i < arrayLength(memberValue); i++) {\n+        //                auto itemValue = arrayMember(memberValue, i);\n+        //            }\n+        //}\n+        //        if (auto error_ = layer->setProperty(member, *memberValue)) {\n+        //            error = *error_;\n+        //            return false;\n+        //        }\n+    }\n+\n+    std::string source = \"source\";\n+\n+    auto tempResult = std::unique_ptr<style::Layer>(new (std::nothrow)\n+                                                        style::PluginLayer(id, source, _layerTypeInfo, layerProperties\n+                                                                           //,*customProperties\n+                                                                           ));\n+\n+#if MLN_PLUGIN_LAYER_LOGGING_ENABLED",
        "comment_created_at": "2025-06-04T15:48:27+00:00",
        "comment_author": "louwers",
        "comment_body": "use mbgl::Log, remove macro",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1506783368",
    "pr_number": 1959,
    "pr_file": "platform/default/src/mbgl/storage/offline_database.cpp",
    "created_at": "2024-02-28T23:09:53+00:00",
    "commented_code": "size = data->length();\n     }\n \n-    return std::make_pair(response, size);\n+    return std::make_pair(response, size); // Return the response and data size\n }\n \n std::optional<int64_t> OfflineDatabase::hasTile(const Resource::TileData& tile) {\n-    // clang-format off\n-    mapbox::sqlite::Query size{ getStatement(\n-        \"SELECT length(data) \"\n-        \"FROM tiles \"\n-        \"WHERE url_template = ?1 \"\n-        \"  AND pixel_ratio  = ?2 \"\n-        \"  AND x            = ?3 \"\n-        \"  AND y            = ?4 \"\n-        \"  AND z            = ?5 \") };\n-    // clang-format on\n+    // First, try to find the tile in the 'tiles' table\n+    std::optional<int64_t> selectTilesResult = extractTileDataSize(\n+        tile,\n+        \"SELECT length(data) FROM tiles WHERE url_template = ?1 AND pixel_ratio = ?2 AND x = ?3 AND y = ?4 AND z = ?5\");\n+    if (selectTilesResult) {\n+        // std::cout << \"-------- HASTILE - FOUND IN TILES\n\";\n+        return selectTilesResult;\n+    } else {\n+        // If not found in 'tiles', try the 'ambient_tiles' table\n+        std::optional<int64_t> selectAmbientTilesResult = extractTileDataSize(\n+            tile,\n+            \"SELECT length(data) FROM ambient_tiles WHERE url_template = ?1 AND pixel_ratio = ?2 AND x = ?3 AND y = ?4 \"\n+            \"AND z = ?5\");\n+        if (selectAmbientTilesResult) {\n+            // std::cout << \"-------- HASTILE - FOUND IN AMBIENT_TILES\n\";",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1506783368",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1959,
        "pr_file": "platform/default/src/mbgl/storage/offline_database.cpp",
        "discussion_id": "1506783368",
        "commented_code": "@@ -574,135 +735,178 @@ std::optional<std::pair<Response, uint64_t>> OfflineDatabase::getTile(const Reso\n         size = data->length();\n     }\n \n-    return std::make_pair(response, size);\n+    return std::make_pair(response, size); // Return the response and data size\n }\n \n std::optional<int64_t> OfflineDatabase::hasTile(const Resource::TileData& tile) {\n-    // clang-format off\n-    mapbox::sqlite::Query size{ getStatement(\n-        \"SELECT length(data) \"\n-        \"FROM tiles \"\n-        \"WHERE url_template = ?1 \"\n-        \"  AND pixel_ratio  = ?2 \"\n-        \"  AND x            = ?3 \"\n-        \"  AND y            = ?4 \"\n-        \"  AND z            = ?5 \") };\n-    // clang-format on\n+    // First, try to find the tile in the 'tiles' table\n+    std::optional<int64_t> selectTilesResult = extractTileDataSize(\n+        tile,\n+        \"SELECT length(data) FROM tiles WHERE url_template = ?1 AND pixel_ratio = ?2 AND x = ?3 AND y = ?4 AND z = ?5\");\n+    if (selectTilesResult) {\n+        // std::cout << \"-------- HASTILE - FOUND IN TILES\\n\";\n+        return selectTilesResult;\n+    } else {\n+        // If not found in 'tiles', try the 'ambient_tiles' table\n+        std::optional<int64_t> selectAmbientTilesResult = extractTileDataSize(\n+            tile,\n+            \"SELECT length(data) FROM ambient_tiles WHERE url_template = ?1 AND pixel_ratio = ?2 AND x = ?3 AND y = ?4 \"\n+            \"AND z = ?5\");\n+        if (selectAmbientTilesResult) {\n+            // std::cout << \"-------- HASTILE - FOUND IN AMBIENT_TILES\\n\";",
        "comment_created_at": "2024-02-28T23:09:53+00:00",
        "comment_author": "louwers",
        "comment_body": "There are commented out lines that print used for debugging throughout this file.\r\n\r\nPlease remove them or change them to (debug) logging.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1350053979",
    "pr_number": 1699,
    "pr_file": "src/mbgl/gfx/drawable_builder.cpp",
    "created_at": "2023-10-09T09:21:46+00:00",
    "commented_code": "}\n \n void DrawableBuilder::addTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2) {\n+    // check and set the current mode\n+    if (!checkAndSetMode(Mode::Primitives)) return;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1350053979",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1699,
        "pr_file": "src/mbgl/gfx/drawable_builder.cpp",
        "discussion_id": "1350053979",
        "commented_code": "@@ -101,6 +110,9 @@ void DrawableBuilder::setTexture(const std::shared_ptr<gfx::Texture2D>& texture,\n }\n \n void DrawableBuilder::addTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2) {\n+    // check and set the current mode\n+    if (!checkAndSetMode(Mode::Primitives)) return;",
        "comment_created_at": "2023-10-09T09:21:46+00:00",
        "comment_author": "louwers",
        "comment_body": "Should some logging be added in these cases?",
        "pr_file_module": null
      },
      {
        "comment_id": "1350401810",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1699,
        "pr_file": "src/mbgl/gfx/drawable_builder.cpp",
        "discussion_id": "1350053979",
        "commented_code": "@@ -101,6 +110,9 @@ void DrawableBuilder::setTexture(const std::shared_ptr<gfx::Texture2D>& texture,\n }\n \n void DrawableBuilder::addTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2) {\n+    // check and set the current mode\n+    if (!checkAndSetMode(Mode::Primitives)) return;",
        "comment_created_at": "2023-10-09T14:41:53+00:00",
        "comment_author": "stefankarschti",
        "comment_body": "I moved the mode checking into `DrawableBuilder::Impl` and logged an error there if the expected `mode` doesn't match the `target`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1284724081",
    "pr_number": 1464,
    "pr_file": "platform/linux/src/headless_backend_glx.cpp",
    "created_at": "2023-08-04T18:24:23+00:00",
    "commented_code": "if (xDisplay != nullptr) {\n                 break;\n             }\n-            Log::Debug(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");\n+            Log::Error(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1284724081",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1464,
        "pr_file": "platform/linux/src/headless_backend_glx.cpp",
        "discussion_id": "1284724081",
        "commented_code": "@@ -39,7 +39,7 @@ class GLXDisplayConfig {\n             if (xDisplay != nullptr) {\n                 break;\n             }\n-            Log::Debug(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");\n+            Log::Error(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");",
        "comment_created_at": "2023-08-04T18:24:23+00:00",
        "comment_author": "mwilsnd",
        "comment_body": "This was changed from Error to Debug intentionally, some of the tests use a [log observer](https://github.com/maplibre/maplibre-native/blob/88917b18065f6c7ee5d11ab2e109e0fab7af6edf/src/mbgl/util/logging.cpp#L53-L56) and only [Debug is omitted](https://github.com/maplibre/maplibre-native/blob/88917b18065f6c7ee5d11ab2e109e0fab7af6edf/src/mbgl/util/logging.cpp#L79). If XOpenDisplay fails during a test using the [FixtureLogObserver](https://github.com/maplibre/maplibre-native/blob/main/test/src/mbgl/test/fixture_log_observer.hpp), the test will fail because of the error level used in this retry message.",
        "pr_file_module": null
      },
      {
        "comment_id": "1284826887",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 1464,
        "pr_file": "platform/linux/src/headless_backend_glx.cpp",
        "discussion_id": "1284724081",
        "commented_code": "@@ -39,7 +39,7 @@ class GLXDisplayConfig {\n             if (xDisplay != nullptr) {\n                 break;\n             }\n-            Log::Debug(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");\n+            Log::Error(Event::OpenGL, \"[CI] Failed to open X display, retrying...\");",
        "comment_created_at": "2023-08-04T20:32:38+00:00",
        "comment_author": "louwers",
        "comment_body": "Thanks for clarifying.\r\n\r\nI didn't see any retry messages in the logs, so I didn't know if it was actually retrying.",
        "pr_file_module": null
      }
    ]
  }
]