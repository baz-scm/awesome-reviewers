[
  {
    "discussion_id": "2151881724",
    "pr_number": 3430,
    "pr_file": "test/plugin/plugin.test.cpp",
    "created_at": "2025-06-17T10:10:32+00:00",
    "commented_code": "+#include <gmock/gmock.h>\n+\n+#include <mbgl/test/util.hpp>\n+#include <mbgl/test/stub_file_source.hpp>\n+#include <mbgl/test/stub_map_observer.hpp>\n+#include <mbgl/test/fake_file_source.hpp>\n+#include <mbgl/test/fixture_log_observer.hpp>\n+#include <mbgl/test/map_adapter.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/headless_frontend.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/map/map_options.hpp>\n+#include <mbgl/math/log2.hpp>\n+#include <mbgl/renderer/renderer.hpp>\n+#include <mbgl/renderer/update_parameters.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/main_resource_loader.hpp>\n+#include <mbgl/storage/network_status.hpp>\n+#include <mbgl/storage/online_file_source.hpp>\n+#include <mbgl/storage/resource_options.hpp>\n+#include <mbgl/style/expression/dsl.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+#include <mbgl/style/image.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/fill_layer.hpp>\n+#include <mbgl/style/layers/raster_layer.hpp>\n+#include <mbgl/style/layers/symbol_layer.hpp>\n+#include <mbgl/style/sources/custom_geometry_source.hpp>\n+#include <mbgl/style/sources/geojson_source.hpp>\n+#include <mbgl/style/sources/image_source.hpp>\n+#include <mbgl/style/sources/vector_source.hpp>\n+#include <mbgl/style/style_impl.hpp>\n+#include <mbgl/style/style.hpp>\n+#include <mbgl/util/async_task.hpp>\n+#include <mbgl/util/client_options.hpp>\n+#include <mbgl/util/color.hpp>\n+#include <mbgl/util/image.hpp>\n+#include <mbgl/util/io.hpp>\n+#include <mbgl/util/logging.hpp>\n+#include <mbgl/util/run_loop.hpp>\n+\n+#include <mbgl/layermanager/layer_manager.hpp>\n+#include <mbgl/plugin/plugin_layer_factory.hpp>\n+#include <mbgl/plugin/plugin_layer.hpp>\n+#include <mbgl/plugin/plugin_layer_impl.hpp>\n+\n+#include <atomic>\n+\n+using namespace mbgl;\n+using namespace mbgl::style;\n+using namespace std::literals::string_literals;\n+\n+template <class FileSource = StubFileSource, class Frontend = HeadlessFrontend>\n+class MapTest {\n+public:\n+    util::RunLoop runLoop;\n+    std::shared_ptr<FileSource> fileSource;\n+    StubMapObserver observer;\n+    Frontend frontend;\n+    MapAdapter map;\n+\n+    MapTest(float pixelRatio = 1, MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<FileSource>(ResourceOptions::Default(), ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    explicit MapTest(MapOptions options)\n+        : fileSource(std::make_shared<FileSource>()),\n+          frontend(options.pixelRatio()),\n+          map(frontend, observer, fileSource, options.withSize(frontend.getSize())) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const std::string& cachePath,\n+            const std::string& assetPath,\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static,\n+            typename std::enable_if_t<std::is_same_v<T, MainResourceLoader>>* = nullptr)\n+        : fileSource(std::make_shared<T>(ResourceOptions().withCachePath(cachePath).withAssetPath(assetPath),\n+                                         ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const ResourceOptions& resourceOptions,\n+            const ClientOptions& clientOptions = ClientOptions(),\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<T>(resourceOptions, clientOptions)),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+};\n+\n+TEST(Plugin, PluginLayerProperty) {\n+    bool _singleFloatValid = false;\n+    bool _colorValid = false;\n+\n+    std::cout << \"Test: Plugin.PluginLayerProperty\n\";\n+\n+    {\n+        PluginLayerProperty p;\n+        p._propertyType = PluginLayerProperty::PropertyType::SingleFloat;\n+        p._singleFloatValue = 1.0;\n+        auto json = p.asJSON();\n+        std::string testValue = R\"(\"\":1.000000)\";\n+        std::cout << \"   _singleFloatValid: \" << json << \";|\" << testValue << \"|\n\";\n+        _singleFloatValid = json == testValue;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "2151881724",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "test/plugin/plugin.test.cpp",
        "discussion_id": "2151881724",
        "commented_code": "@@ -0,0 +1,233 @@\n+#include <gmock/gmock.h>\n+\n+#include <mbgl/test/util.hpp>\n+#include <mbgl/test/stub_file_source.hpp>\n+#include <mbgl/test/stub_map_observer.hpp>\n+#include <mbgl/test/fake_file_source.hpp>\n+#include <mbgl/test/fixture_log_observer.hpp>\n+#include <mbgl/test/map_adapter.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/headless_frontend.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/map/map_options.hpp>\n+#include <mbgl/math/log2.hpp>\n+#include <mbgl/renderer/renderer.hpp>\n+#include <mbgl/renderer/update_parameters.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/main_resource_loader.hpp>\n+#include <mbgl/storage/network_status.hpp>\n+#include <mbgl/storage/online_file_source.hpp>\n+#include <mbgl/storage/resource_options.hpp>\n+#include <mbgl/style/expression/dsl.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+#include <mbgl/style/image.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/fill_layer.hpp>\n+#include <mbgl/style/layers/raster_layer.hpp>\n+#include <mbgl/style/layers/symbol_layer.hpp>\n+#include <mbgl/style/sources/custom_geometry_source.hpp>\n+#include <mbgl/style/sources/geojson_source.hpp>\n+#include <mbgl/style/sources/image_source.hpp>\n+#include <mbgl/style/sources/vector_source.hpp>\n+#include <mbgl/style/style_impl.hpp>\n+#include <mbgl/style/style.hpp>\n+#include <mbgl/util/async_task.hpp>\n+#include <mbgl/util/client_options.hpp>\n+#include <mbgl/util/color.hpp>\n+#include <mbgl/util/image.hpp>\n+#include <mbgl/util/io.hpp>\n+#include <mbgl/util/logging.hpp>\n+#include <mbgl/util/run_loop.hpp>\n+\n+#include <mbgl/layermanager/layer_manager.hpp>\n+#include <mbgl/plugin/plugin_layer_factory.hpp>\n+#include <mbgl/plugin/plugin_layer.hpp>\n+#include <mbgl/plugin/plugin_layer_impl.hpp>\n+\n+#include <atomic>\n+\n+using namespace mbgl;\n+using namespace mbgl::style;\n+using namespace std::literals::string_literals;\n+\n+template <class FileSource = StubFileSource, class Frontend = HeadlessFrontend>\n+class MapTest {\n+public:\n+    util::RunLoop runLoop;\n+    std::shared_ptr<FileSource> fileSource;\n+    StubMapObserver observer;\n+    Frontend frontend;\n+    MapAdapter map;\n+\n+    MapTest(float pixelRatio = 1, MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<FileSource>(ResourceOptions::Default(), ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    explicit MapTest(MapOptions options)\n+        : fileSource(std::make_shared<FileSource>()),\n+          frontend(options.pixelRatio()),\n+          map(frontend, observer, fileSource, options.withSize(frontend.getSize())) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const std::string& cachePath,\n+            const std::string& assetPath,\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static,\n+            typename std::enable_if_t<std::is_same_v<T, MainResourceLoader>>* = nullptr)\n+        : fileSource(std::make_shared<T>(ResourceOptions().withCachePath(cachePath).withAssetPath(assetPath),\n+                                         ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const ResourceOptions& resourceOptions,\n+            const ClientOptions& clientOptions = ClientOptions(),\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<T>(resourceOptions, clientOptions)),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+};\n+\n+TEST(Plugin, PluginLayerProperty) {\n+    bool _singleFloatValid = false;\n+    bool _colorValid = false;\n+\n+    std::cout << \"Test: Plugin.PluginLayerProperty\\n\";\n+\n+    {\n+        PluginLayerProperty p;\n+        p._propertyType = PluginLayerProperty::PropertyType::SingleFloat;\n+        p._singleFloatValue = 1.0;\n+        auto json = p.asJSON();\n+        std::string testValue = R\"(\"\":1.000000)\";\n+        std::cout << \"   _singleFloatValid: \" << json << \";|\" << testValue << \"|\\n\";\n+        _singleFloatValid = json == testValue;",
        "comment_created_at": "2025-06-17T10:10:32+00:00",
        "comment_author": "adrian-cojocaru",
        "comment_body": "`EXPECT_STREQ` can be used instead of `ASSERT_TRUE` and will print the strings when false. Same for multiple checks in this file.",
        "pr_file_module": null
      },
      {
        "comment_id": "2159162411",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 3430,
        "pr_file": "test/plugin/plugin.test.cpp",
        "discussion_id": "2151881724",
        "commented_code": "@@ -0,0 +1,233 @@\n+#include <gmock/gmock.h>\n+\n+#include <mbgl/test/util.hpp>\n+#include <mbgl/test/stub_file_source.hpp>\n+#include <mbgl/test/stub_map_observer.hpp>\n+#include <mbgl/test/fake_file_source.hpp>\n+#include <mbgl/test/fixture_log_observer.hpp>\n+#include <mbgl/test/map_adapter.hpp>\n+\n+#include <mbgl/gfx/backend_scope.hpp>\n+#include <mbgl/gfx/headless_frontend.hpp>\n+#include <mbgl/gfx/shader_registry.hpp>\n+#include <mbgl/map/map_options.hpp>\n+#include <mbgl/math/log2.hpp>\n+#include <mbgl/renderer/renderer.hpp>\n+#include <mbgl/renderer/update_parameters.hpp>\n+#include <mbgl/storage/file_source_manager.hpp>\n+#include <mbgl/storage/main_resource_loader.hpp>\n+#include <mbgl/storage/network_status.hpp>\n+#include <mbgl/storage/online_file_source.hpp>\n+#include <mbgl/storage/resource_options.hpp>\n+#include <mbgl/style/expression/dsl.hpp>\n+#include <mbgl/style/image_impl.hpp>\n+#include <mbgl/style/image.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/background_layer.hpp>\n+#include <mbgl/style/layers/fill_layer.hpp>\n+#include <mbgl/style/layers/raster_layer.hpp>\n+#include <mbgl/style/layers/symbol_layer.hpp>\n+#include <mbgl/style/sources/custom_geometry_source.hpp>\n+#include <mbgl/style/sources/geojson_source.hpp>\n+#include <mbgl/style/sources/image_source.hpp>\n+#include <mbgl/style/sources/vector_source.hpp>\n+#include <mbgl/style/style_impl.hpp>\n+#include <mbgl/style/style.hpp>\n+#include <mbgl/util/async_task.hpp>\n+#include <mbgl/util/client_options.hpp>\n+#include <mbgl/util/color.hpp>\n+#include <mbgl/util/image.hpp>\n+#include <mbgl/util/io.hpp>\n+#include <mbgl/util/logging.hpp>\n+#include <mbgl/util/run_loop.hpp>\n+\n+#include <mbgl/layermanager/layer_manager.hpp>\n+#include <mbgl/plugin/plugin_layer_factory.hpp>\n+#include <mbgl/plugin/plugin_layer.hpp>\n+#include <mbgl/plugin/plugin_layer_impl.hpp>\n+\n+#include <atomic>\n+\n+using namespace mbgl;\n+using namespace mbgl::style;\n+using namespace std::literals::string_literals;\n+\n+template <class FileSource = StubFileSource, class Frontend = HeadlessFrontend>\n+class MapTest {\n+public:\n+    util::RunLoop runLoop;\n+    std::shared_ptr<FileSource> fileSource;\n+    StubMapObserver observer;\n+    Frontend frontend;\n+    MapAdapter map;\n+\n+    MapTest(float pixelRatio = 1, MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<FileSource>(ResourceOptions::Default(), ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    explicit MapTest(MapOptions options)\n+        : fileSource(std::make_shared<FileSource>()),\n+          frontend(options.pixelRatio()),\n+          map(frontend, observer, fileSource, options.withSize(frontend.getSize())) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const std::string& cachePath,\n+            const std::string& assetPath,\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static,\n+            typename std::enable_if_t<std::is_same_v<T, MainResourceLoader>>* = nullptr)\n+        : fileSource(std::make_shared<T>(ResourceOptions().withCachePath(cachePath).withAssetPath(assetPath),\n+                                         ClientOptions())),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+\n+    template <typename T = FileSource>\n+    MapTest(const ResourceOptions& resourceOptions,\n+            const ClientOptions& clientOptions = ClientOptions(),\n+            float pixelRatio = 1,\n+            MapMode mode = MapMode::Static)\n+        : fileSource(std::make_shared<T>(resourceOptions, clientOptions)),\n+          frontend(pixelRatio),\n+          map(frontend,\n+              observer,\n+              fileSource,\n+              MapOptions().withMapMode(mode).withSize(frontend.getSize()).withPixelRatio(pixelRatio)) {}\n+};\n+\n+TEST(Plugin, PluginLayerProperty) {\n+    bool _singleFloatValid = false;\n+    bool _colorValid = false;\n+\n+    std::cout << \"Test: Plugin.PluginLayerProperty\\n\";\n+\n+    {\n+        PluginLayerProperty p;\n+        p._propertyType = PluginLayerProperty::PropertyType::SingleFloat;\n+        p._singleFloatValue = 1.0;\n+        auto json = p.asJSON();\n+        std::string testValue = R\"(\"\":1.000000)\";\n+        std::cout << \"   _singleFloatValid: \" << json << \";|\" << testValue << \"|\\n\";\n+        _singleFloatValid = json == testValue;",
        "comment_created_at": "2025-06-20T14:53:44+00:00",
        "comment_author": "AtlasProgramming",
        "comment_body": "cool.  I added those",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1717575792",
    "pr_number": 2709,
    "pr_file": "test/util/lru_cache.test.cpp",
    "created_at": "2024-08-14T21:31:18+00:00",
    "commented_code": "+#include <mbgl/util/lru_cache.hpp>\n+\n+#include <gtest/gtest.h>\n+\n+using namespace mbgl;\n+\n+TEST(LRU, LRU) {\n+    LRU<int> lru;\n+    EXPECT_TRUE(lru.empty());\n+\n+    lru.touch(1);\n+    lru.touch(2);\n+    lru.touch(3);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 3);\n+\n+    lru.remove(2);\n+    lru.remove(77);\n+    EXPECT_EQ(lru.evict(), 1);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 1);\n+\n+    lru.touch(4);\n+    EXPECT_EQ(lru.evict(), 3);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 1);\n+\n+    EXPECT_FALSE(lru.isHit(3));\n+    EXPECT_FALSE(lru.isHit(33));\n+    EXPECT_TRUE(lru.isHit(4));\n+\n+    EXPECT_EQ(lru.evict(), 4);\n+    EXPECT_TRUE(lru.empty());\n+    EXPECT_FALSE(lru.isHit(4));\n+    try {\n+        lru.evict();",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1717575792",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2709,
        "pr_file": "test/util/lru_cache.test.cpp",
        "discussion_id": "1717575792",
        "commented_code": "@@ -0,0 +1,40 @@\n+#include <mbgl/util/lru_cache.hpp>\n+\n+#include <gtest/gtest.h>\n+\n+using namespace mbgl;\n+\n+TEST(LRU, LRU) {\n+    LRU<int> lru;\n+    EXPECT_TRUE(lru.empty());\n+\n+    lru.touch(1);\n+    lru.touch(2);\n+    lru.touch(3);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 3);\n+\n+    lru.remove(2);\n+    lru.remove(77);\n+    EXPECT_EQ(lru.evict(), 1);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 1);\n+\n+    lru.touch(4);\n+    EXPECT_EQ(lru.evict(), 3);\n+    EXPECT_FALSE(lru.empty());\n+    EXPECT_EQ(lru.size(), 1);\n+\n+    EXPECT_FALSE(lru.isHit(3));\n+    EXPECT_FALSE(lru.isHit(33));\n+    EXPECT_TRUE(lru.isHit(4));\n+\n+    EXPECT_EQ(lru.evict(), 4);\n+    EXPECT_TRUE(lru.empty());\n+    EXPECT_FALSE(lru.isHit(4));\n+    try {\n+        lru.evict();",
        "comment_created_at": "2024-08-14T21:31:18+00:00",
        "comment_author": "louwers",
        "comment_body": "Needs to use `EXPECT_THROW` otherwise the test will fail it doesn't throw.",
        "pr_file_module": null
      }
    ]
  }
]