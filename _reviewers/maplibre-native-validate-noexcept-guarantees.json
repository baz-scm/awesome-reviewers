[
  {
    "discussion_id": "1811329623",
    "pr_number": 2921,
    "pr_file": "include/mbgl/util/interpolate.hpp",
    "created_at": "2024-10-22T20:17:06+00:00",
    "commented_code": "}\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) const noexcept {\n+        assert(a.size() == b.size());\n+        std::vector<AnchorOffsetPair> offsetMap;\n+        for (size_t index = 0; index < a.size(); index++) {\n+            const auto& aPair = a[index];\n+            const auto& bPair = b[index];\n+            assert(aPair.anchorType == bPair.anchorType);\n+            auto offset = std::array<float, 2>{interpolate(aPair.offset[0], bPair.offset[0], t),\n+                                               interpolate(aPair.offset[1], bPair.offset[1], t)};\n+            offsetMap.emplace_back(aPair.anchorType, offset);",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1811329623",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2921,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1811329623",
        "commented_code": "@@ -143,6 +147,27 @@ struct Interpolator<Padding> {\n     }\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) const noexcept {\n+        assert(a.size() == b.size());\n+        std::vector<AnchorOffsetPair> offsetMap;\n+        for (size_t index = 0; index < a.size(); index++) {\n+            const auto& aPair = a[index];\n+            const auto& bPair = b[index];\n+            assert(aPair.anchorType == bPair.anchorType);\n+            auto offset = std::array<float, 2>{interpolate(aPair.offset[0], bPair.offset[0], t),\n+                                               interpolate(aPair.offset[1], bPair.offset[1], t)};\n+            offsetMap.emplace_back(aPair.anchorType, offset);",
        "comment_created_at": "2024-10-22T20:17:06+00:00",
        "comment_author": "louwers",
        "comment_body": "This can throw which would crash the program (because of `noexcept`). Is it possible to avoid allocation?",
        "pr_file_module": null
      },
      {
        "comment_id": "1811611575",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2921,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1811329623",
        "commented_code": "@@ -143,6 +147,27 @@ struct Interpolator<Padding> {\n     }\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) const noexcept {\n+        assert(a.size() == b.size());\n+        std::vector<AnchorOffsetPair> offsetMap;\n+        for (size_t index = 0; index < a.size(); index++) {\n+            const auto& aPair = a[index];\n+            const auto& bPair = b[index];\n+            assert(aPair.anchorType == bPair.anchorType);\n+            auto offset = std::array<float, 2>{interpolate(aPair.offset[0], bPair.offset[0], t),\n+                                               interpolate(aPair.offset[1], bPair.offset[1], t)};\n+            offsetMap.emplace_back(aPair.anchorType, offset);",
        "comment_created_at": "2024-10-23T00:56:57+00:00",
        "comment_author": "random3940",
        "comment_body": "Uhm, I also didn't like the idea of vector in this type, but I don't know how to avoid it. It's a collection without static size limit, so we have to allocate it on heap. \r\n\r\nI guess it's possible to do some shenanigans with inline storage for cases when there are only few elements. But this wouldn't fix the issue, it will just make it less probable. We are open to try ideas if you have some!",
        "pr_file_module": null
      },
      {
        "comment_id": "1813115316",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2921,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1811329623",
        "commented_code": "@@ -143,6 +147,27 @@ struct Interpolator<Padding> {\n     }\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) const noexcept {\n+        assert(a.size() == b.size());\n+        std::vector<AnchorOffsetPair> offsetMap;\n+        for (size_t index = 0; index < a.size(); index++) {\n+            const auto& aPair = a[index];\n+            const auto& bPair = b[index];\n+            assert(aPair.anchorType == bPair.anchorType);\n+            auto offset = std::array<float, 2>{interpolate(aPair.offset[0], bPair.offset[0], t),\n+                                               interpolate(aPair.offset[1], bPair.offset[1], t)};\n+            offsetMap.emplace_back(aPair.anchorType, offset);",
        "comment_created_at": "2024-10-23T16:10:29+00:00",
        "comment_author": "louwers",
        "comment_body": "If it is unavoidable we should remove `noexcept` here (and from the base class), otherwise the program will crash when an exception is thrown here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1814974565",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2921,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1811329623",
        "commented_code": "@@ -143,6 +147,27 @@ struct Interpolator<Padding> {\n     }\n };\n \n+template <>\n+struct Interpolator<VariableAnchorOffsetCollection> {\n+public:\n+    VariableAnchorOffsetCollection operator()(const VariableAnchorOffsetCollection& a,\n+                                              const VariableAnchorOffsetCollection& b,\n+                                              const float t) const noexcept {\n+        assert(a.size() == b.size());\n+        std::vector<AnchorOffsetPair> offsetMap;\n+        for (size_t index = 0; index < a.size(); index++) {\n+            const auto& aPair = a[index];\n+            const auto& bPair = b[index];\n+            assert(aPair.anchorType == bPair.anchorType);\n+            auto offset = std::array<float, 2>{interpolate(aPair.offset[0], bPair.offset[0], t),\n+                                               interpolate(aPair.offset[1], bPair.offset[1], t)};\n+            offsetMap.emplace_back(aPair.anchorType, offset);",
        "comment_created_at": "2024-10-24T13:16:53+00:00",
        "comment_author": "wangyingfang",
        "comment_body": "Add runtime error as JS",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1497744870",
    "pr_number": 2119,
    "pr_file": "include/mbgl/style/expression/expression.hpp",
    "created_at": "2024-02-21T15:03:05+00:00",
    "commented_code": "class Expression {\n public:\n-    Expression(Kind kind_, type::Type type_)\n+    Expression(Kind kind_, type::Type type_) noexcept",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1497744870",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/style/expression/expression.hpp",
        "discussion_id": "1497744870",
        "commented_code": "@@ -185,18 +185,19 @@ enum class Kind : int32_t {\n \n class Expression {\n public:\n-    Expression(Kind kind_, type::Type type_)\n+    Expression(Kind kind_, type::Type type_) noexcept",
        "comment_created_at": "2024-02-21T15:03:05+00:00",
        "comment_author": "louwers",
        "comment_body": "The move constructor of `type::Type` is not `noexcept`.\r\n\r\nbecause `mapbox::util::recursive_wrapper<Array>` is part of the variant\r\n\r\n```cpp\r\n    recursive_wrapper(recursive_wrapper&& operand)\r\n        : p_(new T(std::move(operand.get()))) {}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1497790459",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/style/expression/expression.hpp",
        "discussion_id": "1497744870",
        "commented_code": "@@ -185,18 +185,19 @@ enum class Kind : int32_t {\n \n class Expression {\n public:\n-    Expression(Kind kind_, type::Type type_)\n+    Expression(Kind kind_, type::Type type_) noexcept",
        "comment_created_at": "2024-02-21T15:28:41+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Good catch, do you have some way to validate these or are you just scanning through them manually?",
        "pr_file_module": null
      },
      {
        "comment_id": "1497882034",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/style/expression/expression.hpp",
        "discussion_id": "1497744870",
        "commented_code": "@@ -185,18 +185,19 @@ enum class Kind : int32_t {\n \n class Expression {\n public:\n-    Expression(Kind kind_, type::Type type_)\n+    Expression(Kind kind_, type::Type type_) noexcept",
        "comment_created_at": "2024-02-21T16:24:53+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "It's safe to mark a derived class noexcept if it's using a type literal that doesn't involve `recursive_wrapper<Array>`, right?  e.g.:\r\n\r\n```\r\n    Any(std::vector<std::unique_ptr<Expression>> inputs_) noexcept\r\n        : Expression(Kind::Any, type::Boolean),\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1497942966",
    "pr_number": 2119,
    "pr_file": "include/mbgl/gfx/vertex_attribute.hpp",
    "created_at": "2024-02-21T17:06:52+00:00",
    "commented_code": "protected:\n     template <typename DataDrivenPaintProperty, typename Evaluated>\n-    static bool isConstant(const Evaluated& evaluated) {\n+    static bool isConstant(const Evaluated& evaluated) noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1497942966",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/gfx/vertex_attribute.hpp",
        "discussion_id": "1497942966",
        "commented_code": "@@ -389,7 +389,7 @@ class VertexAttributeArray {\n \n protected:\n     template <typename DataDrivenPaintProperty, typename Evaluated>\n-    static bool isConstant(const Evaluated& evaluated) {\n+    static bool isConstant(const Evaluated& evaluated) noexcept {",
        "comment_created_at": "2024-02-21T17:06:52+00:00",
        "comment_author": "louwers",
        "comment_body": "When adding `noexcept` to a templated function, the compiler won't check that the methods called on that type are really `noexcept`. It will just crash on runtime.\r\n\r\nIt is really hard to verify yourself as well (with all the deeply nested templates).\r\n\r\nWith long, complicated, templated functions, it may be worth leaving out `noexcept`. In this case we can maybe use something like:\r\n\r\n```cpp\r\n    using ReturnType = decltype(evaluated.template get<DataDrivenPaintProperty>());\r\n    static_assert(std::is_nothrow_invocable_v<decltype(&ReturnType::isConstant), ReturnType&>,\r\n                  \"isConstant() must be noexcept\");\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1498443265",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/gfx/vertex_attribute.hpp",
        "discussion_id": "1497942966",
        "commented_code": "@@ -389,7 +389,7 @@ class VertexAttributeArray {\n \n protected:\n     template <typename DataDrivenPaintProperty, typename Evaluated>\n-    static bool isConstant(const Evaluated& evaluated) {\n+    static bool isConstant(const Evaluated& evaluated) noexcept {",
        "comment_created_at": "2024-02-21T23:40:28+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "Agreed, any compile-time checking we can do would be great.\r\n\r\nThis is a relatively easy case because `DataDrivenPaintProperty` isn't really an arbitrary type, it's always a `PossiblyEvaluatedPropertyValue<T>` implementations of which have a simple `isConstant` that doesn't use `T`, just checks which variant alternative is present.",
        "pr_file_module": null
      },
      {
        "comment_id": "1498497887",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/gfx/vertex_attribute.hpp",
        "discussion_id": "1497942966",
        "commented_code": "@@ -389,7 +389,7 @@ class VertexAttributeArray {\n \n protected:\n     template <typename DataDrivenPaintProperty, typename Evaluated>\n-    static bool isConstant(const Evaluated& evaluated) {\n+    static bool isConstant(const Evaluated& evaluated) noexcept {",
        "comment_created_at": "2024-02-22T01:14:49+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "I got it to work locally, but it needs more work for other platforms, apparently.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1497947401",
    "pr_number": 2119,
    "pr_file": "include/mbgl/map/camera.hpp",
    "created_at": "2024-02-21T17:10:23+00:00",
    "commented_code": "std::optional<vec4> orientation = std::nullopt;\n \n     /** Helper function for setting the mercator position as Lat&Lng and altitude in meters */\n-    void setLocation(const LatLngAltitude& location);\n+    void setLocation(const LatLngAltitude& location) noexcept;",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1497947401",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/map/camera.hpp",
        "discussion_id": "1497947401",
        "commented_code": "@@ -139,21 +139,21 @@ struct FreeCameraOptions {\n     std::optional<vec4> orientation = std::nullopt;\n \n     /** Helper function for setting the mercator position as Lat&Lng and altitude in meters */\n-    void setLocation(const LatLngAltitude& location);\n+    void setLocation(const LatLngAltitude& location) noexcept;",
        "comment_created_at": "2024-02-21T17:10:23+00:00",
        "comment_author": "louwers",
        "comment_body": "`mbgl::util::clamp` (called somewhere down) is not `noexcept`. But it can be made `noexcept`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1546708301",
    "pr_number": 2119,
    "pr_file": "include/mbgl/util/interpolate.hpp",
    "created_at": "2024-04-01T18:44:55+00:00",
    "commented_code": "struct Uninterpolated {\n     template <class T>\n-    T operator()(const T& a, const T&, const double) const {\n+    T operator()(const T& a, const T&, const double) const noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1546708301",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1546708301",
        "commented_code": "@@ -148,7 +148,7 @@ struct Interpolator<style::Rotation> {\n \n struct Uninterpolated {\n     template <class T>\n-    T operator()(const T& a, const T&, const double) const {\n+    T operator()(const T& a, const T&, const double) const noexcept {",
        "comment_created_at": "2024-04-01T18:44:55+00:00",
        "comment_author": "louwers",
        "comment_body": "```suggestion\r\n    T operator()(const T& a, const T&, const double) const {\r\n```\r\n\r\nmay call throwing copy constructor",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1546713260",
    "pr_number": 2119,
    "pr_file": "include/mbgl/util/interpolate.hpp",
    "created_at": "2024-04-01T18:48:54+00:00",
    "commented_code": "namespace mbgl {\n namespace util {\n \n-float interpolationFactor(float base, Range<float> range, float z);\n+float interpolationFactor(float base, Range<float> range, float z) noexcept;\n \n template <class T, class Enabled = void>\n struct Interpolator;\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const double t) {\n+T interpolate(const T& a, const T& b, const double t) noexcept {\n     return Interpolator<T>()(a, b, t);\n }\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const float t) {\n+T interpolate(const T& a, const T& b, const float t) noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1546713260",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1546713260",
        "commented_code": "@@ -15,31 +15,31 @@\n namespace mbgl {\n namespace util {\n \n-float interpolationFactor(float base, Range<float> range, float z);\n+float interpolationFactor(float base, Range<float> range, float z) noexcept;\n \n template <class T, class Enabled = void>\n struct Interpolator;\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const double t) {\n+T interpolate(const T& a, const T& b, const double t) noexcept {\n     return Interpolator<T>()(a, b, t);\n }\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const float t) {\n+T interpolate(const T& a, const T& b, const float t) noexcept {",
        "comment_created_at": "2024-04-01T18:48:54+00:00",
        "comment_author": "louwers",
        "comment_body": "```suggestion\r\nT interpolate(const T& a, const T& b, const float t) {\r\n```\r\n\r\nmay call throwing copy constructor",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1546713497",
    "pr_number": 2119,
    "pr_file": "include/mbgl/util/interpolate.hpp",
    "created_at": "2024-04-01T18:49:05+00:00",
    "commented_code": "namespace mbgl {\n namespace util {\n \n-float interpolationFactor(float base, Range<float> range, float z);\n+float interpolationFactor(float base, Range<float> range, float z) noexcept;\n \n template <class T, class Enabled = void>\n struct Interpolator;\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const double t) {\n+T interpolate(const T& a, const T& b, const double t) noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1546713497",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2119,
        "pr_file": "include/mbgl/util/interpolate.hpp",
        "discussion_id": "1546713497",
        "commented_code": "@@ -15,31 +15,31 @@\n namespace mbgl {\n namespace util {\n \n-float interpolationFactor(float base, Range<float> range, float z);\n+float interpolationFactor(float base, Range<float> range, float z) noexcept;\n \n template <class T, class Enabled = void>\n struct Interpolator;\n \n template <typename T>\n-T interpolate(const T& a, const T& b, const double t) {\n+T interpolate(const T& a, const T& b, const double t) noexcept {",
        "comment_created_at": "2024-04-01T18:49:05+00:00",
        "comment_author": "louwers",
        "comment_body": "```suggestion\r\nT interpolate(const T& a, const T& b, const double t) {\r\n```\r\n\r\nmay call throwing copy constructor",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1504970685",
    "pr_number": 2113,
    "pr_file": "src/mbgl/style/properties.hpp",
    "created_at": "2024-02-27T20:52:17+00:00",
    "commented_code": "other.template get<Ps>().value))...});\n             return result;\n         }\n+\n+        Dependency getDependencies() const noexcept {",
    "repo_full_name": "maplibre/maplibre-native",
    "discussion_comments": [
      {
        "comment_id": "1504970685",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2113,
        "pr_file": "src/mbgl/style/properties.hpp",
        "discussion_id": "1504970685",
        "commented_code": "@@ -298,6 +339,23 @@ class Properties {\n                                other.template get<Ps>().value))...});\n             return result;\n         }\n+\n+        Dependency getDependencies() const noexcept {",
        "comment_created_at": "2024-02-27T20:52:17+00:00",
        "comment_author": "louwers",
        "comment_body": "`std::make_tuple` is not `noexcept`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1505078016",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2113,
        "pr_file": "src/mbgl/style/properties.hpp",
        "discussion_id": "1504970685",
        "commented_code": "@@ -298,6 +339,23 @@ class Properties {\n                                other.template get<Ps>().value))...});\n             return result;\n         }\n+\n+        Dependency getDependencies() const noexcept {",
        "comment_created_at": "2024-02-27T22:12:28+00:00",
        "comment_author": "TimSylvester",
        "comment_body": "This is evaluated at compile time, though I forgot to put `constexpr` on it.  But I can do it more manually to eliminate any ambiguity.\r\n\r\n<img width=\"500\" alt=\"image\" src=\"https://github.com/maplibre/maplibre-native/assets/71895881/2e4a4437-7c7e-40eb-9dfb-3d0434ad4c2b\">\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1505147688",
        "repo_full_name": "maplibre/maplibre-native",
        "pr_number": 2113,
        "pr_file": "src/mbgl/style/properties.hpp",
        "discussion_id": "1504970685",
        "commented_code": "@@ -298,6 +339,23 @@ class Properties {\n                                other.template get<Ps>().value))...});\n             return result;\n         }\n+\n+        Dependency getDependencies() const noexcept {",
        "comment_created_at": "2024-02-27T23:38:23+00:00",
        "comment_author": "louwers",
        "comment_body": "Ah OK, but this is one compiler.\r\n\r\nI would err on the side of safety in general when it comes to `noexcept`. If it is not immediately obvious something is `noexcept`, I would not use it.",
        "pr_file_module": null
      }
    ]
  }
]