[
  {
    "discussion_id": "1982190798",
    "pr_number": 1088,
    "pr_file": "packages/markitdown/src/markitdown/_base_converter.py",
    "created_at": "2025-03-05T21:11:35+00:00",
    "commented_code": "+import os\n+import tempfile\n+from warnings import warn\n+from typing import Any, Union, BinaryIO, Optional, List\n+from ._stream_info import StreamInfo\n+\n+\n+class DocumentConverterResult:\n+    \"\"\"The result of converting a document to Markdown.\"\"\"\n+\n+    def __init__(\n+        self,\n+        markdown: str,\n+        *,\n+        title: Optional[str] = None,\n+    ):\n+        \"\"\"\n+        Initialize the DocumentConverterResult.\n+\n+        The only required parameter is the converted Markdown text.\n+        The title, and any other metadata that may be added in the future, are optional.\n+\n+        Parameters:\n+        - markdown: The converted Markdown text.\n+        - title: Optional title of the document.\n+        \"\"\"\n+        self.markdown = markdown\n+        self.title = title\n+\n+    @property\n+    def text_content(self) -> str:\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        return self.markdown\n+\n+    @text_content.setter\n+    def text_content(self, markdown: str):\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        self.markdown = markdown\n+\n+    def __str__(self) -> str:\n+        \"\"\"Return the converted Markdown text.\"\"\"\n+        return self.markdown\n+\n+\n+class DocumentConverter:\n+    \"\"\"Abstract superclass of all DocumentConverters.\"\"\"\n+\n+    # Lower priority values are tried first.\n+    PRIORITY_SPECIFIC_FILE_FORMAT = (\n+        0.0  # e.g., .docx, .pdf, .xlsx, Or specific pages, e.g., wikipedia\n+    )\n+    PRIORITY_GENERIC_FILE_FORMAT = (\n+        10.0  # Near catch-all converters for mimetypes like text/*, etc.\n+    )\n+\n+    def __init__(self, priority: float = PRIORITY_SPECIFIC_FILE_FORMAT):\n+        \"\"\"\n+        Initialize the DocumentConverter with a given priority.\n+\n+        Priorities work as follows: By default, most converters get priority\n+        DocumentConverter.PRIORITY_SPECIFIC_FILE_FORMAT (== 0). The exception\n+        is the PlainTextConverter, which gets priority PRIORITY_SPECIFIC_FILE_FORMAT (== 10),\n+        with lower values being tried first (i.e., higher priority).\n+\n+        Just prior to conversion, the converters are sorted by priority, using\n+        a stable sort. This means that converters with the same priority will\n+        remain in the same order, with the most recently registered converters\n+        appearing first.\n+\n+        We have tight control over the order of built-in converters, but\n+        plugins can register converters in any order. A converter's priority\n+        field reasserts some control over the order of converters.\n+\n+        Plugins can register converters with any priority, to appear before or\n+        after the built-ins. For example, a plugin with priority 9 will run\n+        before the PlainTextConverter, but after the built-in converters.\n+        \"\"\"\n+        self._priority = priority\n+\n+    def accepts(\n+        self,\n+        file_stream: BinaryIO,\n+        stream_info: StreamInfo,\n+        **kwargs: Any,  # Options to pass to the converter\n+    ) -> bool:\n+        \"\"\"\n+        Return a quick determination on if the converter should attempt converting the document.\n+        This is primarily based `stream_info` (typically, `stream_info.mimetype`, `stream_info.extension`).\n+        In cases where the data is retreived via HTTP, the `steam_info.url` might also be referenced to\n+        make a determination (e.g., special converters for Wikipedia, YouTube etc).\n+        Finally, it is conceivable that the `stream_info.filename` might be used to in cases\n+        where the filename is well-known (e.g., `Dockerfile`, `Makefile`, etc)\n+\n+        NOTE: The method signature is designed to match that of the convert() method. This provides some\n+        assurance that, if accepts() returns True, the convert() method will also be able to handle the document.\n+\n+        IMPORTANT: If this method advances the position in file_stream, it must also reset the position before\n+        returning. This is because the convert() method may be called immediately after accepts().\n+",
    "repo_full_name": "microsoft/markitdown",
    "discussion_comments": [
      {
        "comment_id": "1982190798",
        "repo_full_name": "microsoft/markitdown",
        "pr_number": 1088,
        "pr_file": "packages/markitdown/src/markitdown/_base_converter.py",
        "discussion_id": "1982190798",
        "commented_code": "@@ -0,0 +1,142 @@\n+import os\n+import tempfile\n+from warnings import warn\n+from typing import Any, Union, BinaryIO, Optional, List\n+from ._stream_info import StreamInfo\n+\n+\n+class DocumentConverterResult:\n+    \"\"\"The result of converting a document to Markdown.\"\"\"\n+\n+    def __init__(\n+        self,\n+        markdown: str,\n+        *,\n+        title: Optional[str] = None,\n+    ):\n+        \"\"\"\n+        Initialize the DocumentConverterResult.\n+\n+        The only required parameter is the converted Markdown text.\n+        The title, and any other metadata that may be added in the future, are optional.\n+\n+        Parameters:\n+        - markdown: The converted Markdown text.\n+        - title: Optional title of the document.\n+        \"\"\"\n+        self.markdown = markdown\n+        self.title = title\n+\n+    @property\n+    def text_content(self) -> str:\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        return self.markdown\n+\n+    @text_content.setter\n+    def text_content(self, markdown: str):\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        self.markdown = markdown\n+\n+    def __str__(self) -> str:\n+        \"\"\"Return the converted Markdown text.\"\"\"\n+        return self.markdown\n+\n+\n+class DocumentConverter:\n+    \"\"\"Abstract superclass of all DocumentConverters.\"\"\"\n+\n+    # Lower priority values are tried first.\n+    PRIORITY_SPECIFIC_FILE_FORMAT = (\n+        0.0  # e.g., .docx, .pdf, .xlsx, Or specific pages, e.g., wikipedia\n+    )\n+    PRIORITY_GENERIC_FILE_FORMAT = (\n+        10.0  # Near catch-all converters for mimetypes like text/*, etc.\n+    )\n+\n+    def __init__(self, priority: float = PRIORITY_SPECIFIC_FILE_FORMAT):\n+        \"\"\"\n+        Initialize the DocumentConverter with a given priority.\n+\n+        Priorities work as follows: By default, most converters get priority\n+        DocumentConverter.PRIORITY_SPECIFIC_FILE_FORMAT (== 0). The exception\n+        is the PlainTextConverter, which gets priority PRIORITY_SPECIFIC_FILE_FORMAT (== 10),\n+        with lower values being tried first (i.e., higher priority).\n+\n+        Just prior to conversion, the converters are sorted by priority, using\n+        a stable sort. This means that converters with the same priority will\n+        remain in the same order, with the most recently registered converters\n+        appearing first.\n+\n+        We have tight control over the order of built-in converters, but\n+        plugins can register converters in any order. A converter's priority\n+        field reasserts some control over the order of converters.\n+\n+        Plugins can register converters with any priority, to appear before or\n+        after the built-ins. For example, a plugin with priority 9 will run\n+        before the PlainTextConverter, but after the built-in converters.\n+        \"\"\"\n+        self._priority = priority\n+\n+    def accepts(\n+        self,\n+        file_stream: BinaryIO,\n+        stream_info: StreamInfo,\n+        **kwargs: Any,  # Options to pass to the converter\n+    ) -> bool:\n+        \"\"\"\n+        Return a quick determination on if the converter should attempt converting the document.\n+        This is primarily based `stream_info` (typically, `stream_info.mimetype`, `stream_info.extension`).\n+        In cases where the data is retreived via HTTP, the `steam_info.url` might also be referenced to\n+        make a determination (e.g., special converters for Wikipedia, YouTube etc).\n+        Finally, it is conceivable that the `stream_info.filename` might be used to in cases\n+        where the filename is well-known (e.g., `Dockerfile`, `Makefile`, etc)\n+\n+        NOTE: The method signature is designed to match that of the convert() method. This provides some\n+        assurance that, if accepts() returns True, the convert() method will also be able to handle the document.\n+\n+        IMPORTANT: If this method advances the position in file_stream, it must also reset the position before\n+        returning. This is because the convert() method may be called immediately after accepts().\n+",
        "comment_created_at": "2025-03-05T21:11:35+00:00",
        "comment_author": "gagb",
        "comment_body": "I am not sure what this is.",
        "pr_file_module": null
      },
      {
        "comment_id": "1982206108",
        "repo_full_name": "microsoft/markitdown",
        "pr_number": 1088,
        "pr_file": "packages/markitdown/src/markitdown/_base_converter.py",
        "discussion_id": "1982190798",
        "commented_code": "@@ -0,0 +1,142 @@\n+import os\n+import tempfile\n+from warnings import warn\n+from typing import Any, Union, BinaryIO, Optional, List\n+from ._stream_info import StreamInfo\n+\n+\n+class DocumentConverterResult:\n+    \"\"\"The result of converting a document to Markdown.\"\"\"\n+\n+    def __init__(\n+        self,\n+        markdown: str,\n+        *,\n+        title: Optional[str] = None,\n+    ):\n+        \"\"\"\n+        Initialize the DocumentConverterResult.\n+\n+        The only required parameter is the converted Markdown text.\n+        The title, and any other metadata that may be added in the future, are optional.\n+\n+        Parameters:\n+        - markdown: The converted Markdown text.\n+        - title: Optional title of the document.\n+        \"\"\"\n+        self.markdown = markdown\n+        self.title = title\n+\n+    @property\n+    def text_content(self) -> str:\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        return self.markdown\n+\n+    @text_content.setter\n+    def text_content(self, markdown: str):\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        self.markdown = markdown\n+\n+    def __str__(self) -> str:\n+        \"\"\"Return the converted Markdown text.\"\"\"\n+        return self.markdown\n+\n+\n+class DocumentConverter:\n+    \"\"\"Abstract superclass of all DocumentConverters.\"\"\"\n+\n+    # Lower priority values are tried first.\n+    PRIORITY_SPECIFIC_FILE_FORMAT = (\n+        0.0  # e.g., .docx, .pdf, .xlsx, Or specific pages, e.g., wikipedia\n+    )\n+    PRIORITY_GENERIC_FILE_FORMAT = (\n+        10.0  # Near catch-all converters for mimetypes like text/*, etc.\n+    )\n+\n+    def __init__(self, priority: float = PRIORITY_SPECIFIC_FILE_FORMAT):\n+        \"\"\"\n+        Initialize the DocumentConverter with a given priority.\n+\n+        Priorities work as follows: By default, most converters get priority\n+        DocumentConverter.PRIORITY_SPECIFIC_FILE_FORMAT (== 0). The exception\n+        is the PlainTextConverter, which gets priority PRIORITY_SPECIFIC_FILE_FORMAT (== 10),\n+        with lower values being tried first (i.e., higher priority).\n+\n+        Just prior to conversion, the converters are sorted by priority, using\n+        a stable sort. This means that converters with the same priority will\n+        remain in the same order, with the most recently registered converters\n+        appearing first.\n+\n+        We have tight control over the order of built-in converters, but\n+        plugins can register converters in any order. A converter's priority\n+        field reasserts some control over the order of converters.\n+\n+        Plugins can register converters with any priority, to appear before or\n+        after the built-ins. For example, a plugin with priority 9 will run\n+        before the PlainTextConverter, but after the built-in converters.\n+        \"\"\"\n+        self._priority = priority\n+\n+    def accepts(\n+        self,\n+        file_stream: BinaryIO,\n+        stream_info: StreamInfo,\n+        **kwargs: Any,  # Options to pass to the converter\n+    ) -> bool:\n+        \"\"\"\n+        Return a quick determination on if the converter should attempt converting the document.\n+        This is primarily based `stream_info` (typically, `stream_info.mimetype`, `stream_info.extension`).\n+        In cases where the data is retreived via HTTP, the `steam_info.url` might also be referenced to\n+        make a determination (e.g., special converters for Wikipedia, YouTube etc).\n+        Finally, it is conceivable that the `stream_info.filename` might be used to in cases\n+        where the filename is well-known (e.g., `Dockerfile`, `Makefile`, etc)\n+\n+        NOTE: The method signature is designed to match that of the convert() method. This provides some\n+        assurance that, if accepts() returns True, the convert() method will also be able to handle the document.\n+\n+        IMPORTANT: If this method advances the position in file_stream, it must also reset the position before\n+        returning. This is because the convert() method may be called immediately after accepts().\n+",
        "comment_created_at": "2025-03-05T21:25:21+00:00",
        "comment_author": "afourney",
        "comment_body": "`file_stream` is a file-like object, and every read operation advances its position internally (like file.read()). In some cases -- like the OutlookMessageConverter -- additional stream read operations are needed to decide if the file is indeed an outlook message (the mimeype and extension are overly generic). If you read from the stream in the `accept()` methodm you need to return to the original position before exiting to leave the stream intact. \r\n\r\nE.g., \r\n```python\r\ncur_pos = file_stream.tell()\r\ndata = file_stream.read()\r\nfile_stream.seek(cur_pos)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1982243982",
        "repo_full_name": "microsoft/markitdown",
        "pr_number": 1088,
        "pr_file": "packages/markitdown/src/markitdown/_base_converter.py",
        "discussion_id": "1982190798",
        "commented_code": "@@ -0,0 +1,142 @@\n+import os\n+import tempfile\n+from warnings import warn\n+from typing import Any, Union, BinaryIO, Optional, List\n+from ._stream_info import StreamInfo\n+\n+\n+class DocumentConverterResult:\n+    \"\"\"The result of converting a document to Markdown.\"\"\"\n+\n+    def __init__(\n+        self,\n+        markdown: str,\n+        *,\n+        title: Optional[str] = None,\n+    ):\n+        \"\"\"\n+        Initialize the DocumentConverterResult.\n+\n+        The only required parameter is the converted Markdown text.\n+        The title, and any other metadata that may be added in the future, are optional.\n+\n+        Parameters:\n+        - markdown: The converted Markdown text.\n+        - title: Optional title of the document.\n+        \"\"\"\n+        self.markdown = markdown\n+        self.title = title\n+\n+    @property\n+    def text_content(self) -> str:\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        return self.markdown\n+\n+    @text_content.setter\n+    def text_content(self, markdown: str):\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        self.markdown = markdown\n+\n+    def __str__(self) -> str:\n+        \"\"\"Return the converted Markdown text.\"\"\"\n+        return self.markdown\n+\n+\n+class DocumentConverter:\n+    \"\"\"Abstract superclass of all DocumentConverters.\"\"\"\n+\n+    # Lower priority values are tried first.\n+    PRIORITY_SPECIFIC_FILE_FORMAT = (\n+        0.0  # e.g., .docx, .pdf, .xlsx, Or specific pages, e.g., wikipedia\n+    )\n+    PRIORITY_GENERIC_FILE_FORMAT = (\n+        10.0  # Near catch-all converters for mimetypes like text/*, etc.\n+    )\n+\n+    def __init__(self, priority: float = PRIORITY_SPECIFIC_FILE_FORMAT):\n+        \"\"\"\n+        Initialize the DocumentConverter with a given priority.\n+\n+        Priorities work as follows: By default, most converters get priority\n+        DocumentConverter.PRIORITY_SPECIFIC_FILE_FORMAT (== 0). The exception\n+        is the PlainTextConverter, which gets priority PRIORITY_SPECIFIC_FILE_FORMAT (== 10),\n+        with lower values being tried first (i.e., higher priority).\n+\n+        Just prior to conversion, the converters are sorted by priority, using\n+        a stable sort. This means that converters with the same priority will\n+        remain in the same order, with the most recently registered converters\n+        appearing first.\n+\n+        We have tight control over the order of built-in converters, but\n+        plugins can register converters in any order. A converter's priority\n+        field reasserts some control over the order of converters.\n+\n+        Plugins can register converters with any priority, to appear before or\n+        after the built-ins. For example, a plugin with priority 9 will run\n+        before the PlainTextConverter, but after the built-in converters.\n+        \"\"\"\n+        self._priority = priority\n+\n+    def accepts(\n+        self,\n+        file_stream: BinaryIO,\n+        stream_info: StreamInfo,\n+        **kwargs: Any,  # Options to pass to the converter\n+    ) -> bool:\n+        \"\"\"\n+        Return a quick determination on if the converter should attempt converting the document.\n+        This is primarily based `stream_info` (typically, `stream_info.mimetype`, `stream_info.extension`).\n+        In cases where the data is retreived via HTTP, the `steam_info.url` might also be referenced to\n+        make a determination (e.g., special converters for Wikipedia, YouTube etc).\n+        Finally, it is conceivable that the `stream_info.filename` might be used to in cases\n+        where the filename is well-known (e.g., `Dockerfile`, `Makefile`, etc)\n+\n+        NOTE: The method signature is designed to match that of the convert() method. This provides some\n+        assurance that, if accepts() returns True, the convert() method will also be able to handle the document.\n+\n+        IMPORTANT: If this method advances the position in file_stream, it must also reset the position before\n+        returning. This is because the convert() method may be called immediately after accepts().\n+",
        "comment_created_at": "2025-03-05T21:54:16+00:00",
        "comment_author": "gagb",
        "comment_body": "It would be great to add this sentence that you just said \"In some cases -- like the OutlookMessageConverter -- additional stream read operations are needed to decide if the file is indeed an outlook message\"",
        "pr_file_module": null
      },
      {
        "comment_id": "1982385801",
        "repo_full_name": "microsoft/markitdown",
        "pr_number": 1088,
        "pr_file": "packages/markitdown/src/markitdown/_base_converter.py",
        "discussion_id": "1982190798",
        "commented_code": "@@ -0,0 +1,142 @@\n+import os\n+import tempfile\n+from warnings import warn\n+from typing import Any, Union, BinaryIO, Optional, List\n+from ._stream_info import StreamInfo\n+\n+\n+class DocumentConverterResult:\n+    \"\"\"The result of converting a document to Markdown.\"\"\"\n+\n+    def __init__(\n+        self,\n+        markdown: str,\n+        *,\n+        title: Optional[str] = None,\n+    ):\n+        \"\"\"\n+        Initialize the DocumentConverterResult.\n+\n+        The only required parameter is the converted Markdown text.\n+        The title, and any other metadata that may be added in the future, are optional.\n+\n+        Parameters:\n+        - markdown: The converted Markdown text.\n+        - title: Optional title of the document.\n+        \"\"\"\n+        self.markdown = markdown\n+        self.title = title\n+\n+    @property\n+    def text_content(self) -> str:\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        return self.markdown\n+\n+    @text_content.setter\n+    def text_content(self, markdown: str):\n+        \"\"\"Soft-deprecated alias for `markdown`. New code should migrate to using `markdown` or __str__.\"\"\"\n+        self.markdown = markdown\n+\n+    def __str__(self) -> str:\n+        \"\"\"Return the converted Markdown text.\"\"\"\n+        return self.markdown\n+\n+\n+class DocumentConverter:\n+    \"\"\"Abstract superclass of all DocumentConverters.\"\"\"\n+\n+    # Lower priority values are tried first.\n+    PRIORITY_SPECIFIC_FILE_FORMAT = (\n+        0.0  # e.g., .docx, .pdf, .xlsx, Or specific pages, e.g., wikipedia\n+    )\n+    PRIORITY_GENERIC_FILE_FORMAT = (\n+        10.0  # Near catch-all converters for mimetypes like text/*, etc.\n+    )\n+\n+    def __init__(self, priority: float = PRIORITY_SPECIFIC_FILE_FORMAT):\n+        \"\"\"\n+        Initialize the DocumentConverter with a given priority.\n+\n+        Priorities work as follows: By default, most converters get priority\n+        DocumentConverter.PRIORITY_SPECIFIC_FILE_FORMAT (== 0). The exception\n+        is the PlainTextConverter, which gets priority PRIORITY_SPECIFIC_FILE_FORMAT (== 10),\n+        with lower values being tried first (i.e., higher priority).\n+\n+        Just prior to conversion, the converters are sorted by priority, using\n+        a stable sort. This means that converters with the same priority will\n+        remain in the same order, with the most recently registered converters\n+        appearing first.\n+\n+        We have tight control over the order of built-in converters, but\n+        plugins can register converters in any order. A converter's priority\n+        field reasserts some control over the order of converters.\n+\n+        Plugins can register converters with any priority, to appear before or\n+        after the built-ins. For example, a plugin with priority 9 will run\n+        before the PlainTextConverter, but after the built-in converters.\n+        \"\"\"\n+        self._priority = priority\n+\n+    def accepts(\n+        self,\n+        file_stream: BinaryIO,\n+        stream_info: StreamInfo,\n+        **kwargs: Any,  # Options to pass to the converter\n+    ) -> bool:\n+        \"\"\"\n+        Return a quick determination on if the converter should attempt converting the document.\n+        This is primarily based `stream_info` (typically, `stream_info.mimetype`, `stream_info.extension`).\n+        In cases where the data is retreived via HTTP, the `steam_info.url` might also be referenced to\n+        make a determination (e.g., special converters for Wikipedia, YouTube etc).\n+        Finally, it is conceivable that the `stream_info.filename` might be used to in cases\n+        where the filename is well-known (e.g., `Dockerfile`, `Makefile`, etc)\n+\n+        NOTE: The method signature is designed to match that of the convert() method. This provides some\n+        assurance that, if accepts() returns True, the convert() method will also be able to handle the document.\n+\n+        IMPORTANT: If this method advances the position in file_stream, it must also reset the position before\n+        returning. This is because the convert() method may be called immediately after accepts().\n+",
        "comment_created_at": "2025-03-06T00:41:41+00:00",
        "comment_author": "afourney",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1902177646",
    "pr_number": 223,
    "pr_file": "src/markitdown/_markitdown.py",
    "created_at": "2025-01-03T21:22:34+00:00",
    "commented_code": "result = None\n         try:\n             # Write to the temporary file\n-            content = stream.read()\n+            content = self._strip_leading_blanks(stream.read())",
    "repo_full_name": "microsoft/markitdown",
    "discussion_comments": [
      {
        "comment_id": "1902177646",
        "repo_full_name": "microsoft/markitdown",
        "pr_number": 223,
        "pr_file": "src/markitdown/_markitdown.py",
        "discussion_id": "1902177646",
        "commented_code": "@@ -1344,7 +1344,7 @@ def convert_stream(\n         result = None\n         try:\n             # Write to the temporary file\n-            content = stream.read()\n+            content = self._strip_leading_blanks(stream.read())",
        "comment_created_at": "2025-01-03T21:22:34+00:00",
        "comment_author": "afourney",
        "comment_body": "The stream might not be text -- in which case stripping characters could be very problematic. Suggest we move this to the inside of the if statement below.",
        "pr_file_module": null
      }
    ]
  }
]