[
  {
    "discussion_id": "2163366096",
    "pr_number": 35133,
    "pr_file": "app/controllers/filters_controller.rb",
    "created_at": "2025-06-24T09:00:56+00:00",
    "commented_code": "def new\n     @filter = current_account.custom_filters.build(action: :warn)\n-    @filter.keywords.build\n+    @filter.keywords.build(params.dig(:custom_filter, :keywords_attributes))",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2163366096",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35133,
        "pr_file": "app/controllers/filters_controller.rb",
        "discussion_id": "2163366096",
        "commented_code": "@@ -12,7 +12,7 @@ def index\n \n   def new\n     @filter = current_account.custom_filters.build(action: :warn)\n-    @filter.keywords.build\n+    @filter.keywords.build(params.dig(:custom_filter, :keywords_attributes))",
        "comment_created_at": "2025-06-24T09:00:56+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "If you wanted to do it like that, you'd need:\r\n```suggestion\r\n    @filter.keywords.build(resource_params.dig(:keywords_attributes, '0'))\r\n```\r\n\r\nIndeed, using `params` would raise `ActiveModel::ForbiddenAttributesError` as the params would not be vetted through `StrongParameters` (that's what `params.expect` does), and `resource_params.dig(:keywords)` is an array (well, a hash) for multiple keywords, while you are setting up only one.\r\n\r\nThat being said, this is a lot of work for just a few attributes. I wonder if we shouldn't use some bespoke parameter instead, e.g. have `/filters/new?hashtag=blah`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2163719008",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35133,
        "pr_file": "app/controllers/filters_controller.rb",
        "discussion_id": "2163366096",
        "commented_code": "@@ -12,7 +12,7 @@ def index\n \n   def new\n     @filter = current_account.custom_filters.build(action: :warn)\n-    @filter.keywords.build\n+    @filter.keywords.build(params.dig(:custom_filter, :keywords_attributes))",
        "comment_created_at": "2025-06-24T11:34:41+00:00",
        "comment_author": "shaedrich",
        "comment_body": "Thanks for the explanation \ud83d\udc4d\ud83c\udffb \r\n\r\n> That being said, this is a lot of work for just a few attributes. I wonder if we shouldn't use some bespoke parameter instead, e.g. have `/filters/new?hashtag=blah`.\r\n\r\nAnd said parameter would then be handled client-side?",
        "pr_file_module": null
      },
      {
        "comment_id": "2163867854",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35133,
        "pr_file": "app/controllers/filters_controller.rb",
        "discussion_id": "2163366096",
        "commented_code": "@@ -12,7 +12,7 @@ def index\n \n   def new\n     @filter = current_account.custom_filters.build(action: :warn)\n-    @filter.keywords.build\n+    @filter.keywords.build(params.dig(:custom_filter, :keywords_attributes))",
        "comment_created_at": "2025-06-24T12:32:51+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "You would need to add handling just like you did there, e.g. `@filter.keywords.build({ 'keyword' => \"##{params['hashtag']}\", 'whole_word' => true }) if params['hashtag'].present?`",
        "pr_file_module": null
      },
      {
        "comment_id": "2164332231",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35133,
        "pr_file": "app/controllers/filters_controller.rb",
        "discussion_id": "2163366096",
        "commented_code": "@@ -12,7 +12,7 @@ def index\n \n   def new\n     @filter = current_account.custom_filters.build(action: :warn)\n-    @filter.keywords.build\n+    @filter.keywords.build(params.dig(:custom_filter, :keywords_attributes))",
        "comment_created_at": "2025-06-24T15:31:01+00:00",
        "comment_author": "shaedrich",
        "comment_body": "Ah, okay\u2014gotcha \ud83d\udc4d\ud83c\udffb  Maybe, I'm missing something but that doesn't look like significantly less work",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1742702656",
    "pr_number": 31706,
    "pr_file": "app/services/report_service.rb",
    "created_at": "2024-09-03T21:18:14+00:00",
    "commented_code": "notify_staff!\n \n     if forward?\n-      forward_to_origin!\n-      forward_to_replied_to!\n+      ReportForwardingService.new.call(@report, @source_account, {\n+        forward_to_domains: @options[:forward_to_domains] || [@report.target_account.domain],",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1742702656",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31706,
        "pr_file": "app/services/report_service.rb",
        "discussion_id": "1742702656",
        "commented_code": "@@ -19,8 +19,9 @@ def call(source_account, target_account, options = {})\n     notify_staff!\n \n     if forward?\n-      forward_to_origin!\n-      forward_to_replied_to!\n+      ReportForwardingService.new.call(@report, @source_account, {\n+        forward_to_domains: @options[:forward_to_domains] || [@report.target_account.domain],",
        "comment_created_at": "2024-09-03T21:18:14+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "If I'm understanding what this code did correctly, then if the `forward_to_domains` option wasn't specified, then it'd always forward to the target_account's domain. We may want to reassess that, and instead rely on manual forwarding \u2014 I don't know if a missing API parameter should be seen as \"yes, let's forward this to a remote instance\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1967471780",
    "pr_number": 33988,
    "pr_file": "spec/requests/api/v1/statuses_spec.rb",
    "created_at": "2025-02-24T11:33:31+00:00",
    "commented_code": "let(:scopes) { 'write:statuses' }\n       let(:status) { Fabricate(:status, account: user.account) }\n+      let(:media_attachment) { Fabricate(:media_attachment, account: user.account) }\n+\n+      before do\n+        status.media_attachments << media_attachment\n+      end\n \n       it_behaves_like 'forbidden for wrong scope', 'read read:statuses'\n \n-      it 'removes the status', :aggregate_failures do\n+      it 'removes the status but not the attachment', :aggregate_failures do\n         subject\n \n         expect(response).to have_http_status(200)\n         expect(response.content_type)\n           .to start_with('application/json')\n         expect(Status.find_by(id: status.id)).to be_nil\n+        expect(MediaAttachment.find_by(id: media_attachment.id)).to_not be_nil\n+      end\n+\n+      context 'when called with truthy delete_media' do\n+        subject do\n+          delete \"/api/v1/statuses/#{status.id}?delete_media=true\", headers: headers\n+        end\n+\n+        it 'removes the status but not the attachment', :aggregate_failures do",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1967471780",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33988,
        "pr_file": "spec/requests/api/v1/statuses_spec.rb",
        "discussion_id": "1967471780",
        "commented_code": "@@ -254,16 +254,38 @@\n \n       let(:scopes) { 'write:statuses' }\n       let(:status) { Fabricate(:status, account: user.account) }\n+      let(:media_attachment) { Fabricate(:media_attachment, account: user.account) }\n+\n+      before do\n+        status.media_attachments << media_attachment\n+      end\n \n       it_behaves_like 'forbidden for wrong scope', 'read read:statuses'\n \n-      it 'removes the status', :aggregate_failures do\n+      it 'removes the status but not the attachment', :aggregate_failures do\n         subject\n \n         expect(response).to have_http_status(200)\n         expect(response.content_type)\n           .to start_with('application/json')\n         expect(Status.find_by(id: status.id)).to be_nil\n+        expect(MediaAttachment.find_by(id: media_attachment.id)).to_not be_nil\n+      end\n+\n+      context 'when called with truthy delete_media' do\n+        subject do\n+          delete \"/api/v1/statuses/#{status.id}?delete_media=true\", headers: headers\n+        end\n+\n+        it 'removes the status but not the attachment', :aggregate_failures do",
        "comment_created_at": "2025-02-24T11:33:31+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "```suggestion\r\n        it 'removes the status and the attachment', :aggregate_failures do\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1719164428",
    "pr_number": 31449,
    "pr_file": "app/controllers/admin/reports_controller.rb",
    "created_at": "2024-08-16T01:00:09+00:00",
    "commented_code": "def index\n       authorize :report, :index?\n+\n+      # We previously only supported searching by target account domain for\n+      # reports, we now have more search options, but it's important that we\n+      # don't break any saved queries people may have:\n+      if params.include? :by_target_domain\n+        redirect_to admin_reports_path({\n+          search_type: 'target',\n+          search_term: params[:by_target_domain],\n+        })\n+      end",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1719164428",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31449,
        "pr_file": "app/controllers/admin/reports_controller.rb",
        "discussion_id": "1719164428",
        "commented_code": "@@ -6,6 +6,17 @@ class ReportsController < BaseController\n \n     def index\n       authorize :report, :index?\n+\n+      # We previously only supported searching by target account domain for\n+      # reports, we now have more search options, but it's important that we\n+      # don't break any saved queries people may have:\n+      if params.include? :by_target_domain\n+        redirect_to admin_reports_path({\n+          search_type: 'target',\n+          search_term: params[:by_target_domain],\n+        })\n+      end",
        "comment_created_at": "2024-08-16T01:00:09+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "This doesn't keep the report status filter, but probably should",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1615205220",
    "pr_number": 24987,
    "pr_file": "app/controllers/api/v1/accounts/statuses_controller.rb",
    "created_at": "2024-05-26T13:37:35+00:00",
    "commented_code": "def index\n     cache_if_unauthenticated!\n     @statuses = load_statuses\n-    render json: @statuses, each_serializer: REST::StatusSerializer, relationships: StatusRelationshipsPresenter.new(@statuses, current_user&.account_id)\n+    return_source = params[:client_type] == 'editor'",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1615205220",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 24987,
        "pr_file": "app/controllers/api/v1/accounts/statuses_controller.rb",
        "discussion_id": "1615205220",
        "commented_code": "@@ -9,7 +9,8 @@ class Api::V1::Accounts::StatusesController < Api::BaseController\n   def index\n     cache_if_unauthenticated!\n     @statuses = load_statuses\n-    render json: @statuses, each_serializer: REST::StatusSerializer, relationships: StatusRelationshipsPresenter.new(@statuses, current_user&.account_id)\n+    return_source = params[:client_type] == 'editor'",
        "comment_created_at": "2024-05-26T13:37:35+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Minor naming/style things...\r\n\r\n- Instead of a local var, move this to a `return_source?` query method elsewhere in controller, and use that to pass bool value to serializer\r\n- I'd probably name this after the desired additional output, not where the request is being made from. Something like `params[:include_original] == true` or something.\r\n- Exception to that would be if we foresee *many* other fields also being required only for editors\r\n- Another avenue is that we do have 1 or 2 places where we pass in the desired fields to a serializer. Could do some sort of graphql-style ability here to ask for specific fields (from an allowed list) in a more general way for clients.",
        "pr_file_module": null
      }
    ]
  }
]