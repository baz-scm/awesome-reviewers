[
  {
    "discussion_id": "1845655532",
    "pr_number": 31529,
    "pr_file": "app/models/instance.rb",
    "created_at": "2024-11-17T21:23:11+00:00",
    "commented_code": "scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1845655532",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2024-11-17T21:23:11+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "I don't think this is really the right error to raise here, open to suggestions. Would it be worth adding something more specific to `lib/exceptions.rb` ? e.g., `Mastodon::InvalidDomainError` or something?\r\n\r\nThis should probably also raise if the normalized domain is invalid, though it looks like `Addressable::URI::InvalidURIError` will be raised from `TagManager.instance.normalize_domain` in that case?",
        "pr_file_module": null
      },
      {
        "comment_id": "1845656640",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2024-11-17T21:26:57+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "oddly enough, `TagManager.instance.normalize_domain` doesn't raise if the domain is blank or otherwise malformed..\r\n\r\nSo these are currently \"valid\" domains:\r\n- `''` (returns an empty string)\r\n- `.` (returns `.`)\r\n- `a.` (returns `a`)\r\n- `.a` (returns `.a`)",
        "pr_file_module": null
      },
      {
        "comment_id": "1854278498",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2024-11-22T16:48:52+00:00",
        "comment_author": "mjankowski",
        "comment_body": "I'd have to contemplate whether this is viable ... but I've been meaning to look at the normalizes API for some of these ... would give us cleaner inbound normalization and help w/ some of the queries as well",
        "pr_file_module": null
      },
      {
        "comment_id": "2140300194",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-11T14:09:52+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Having something called `find_or_initialize_by_*` raise an error (especially an `ActiveRecord::RecordInvalid` error) is pretty surprising, as `find_or_initialize_by` does not perform validation and does not raise.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140394290",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-11T14:45:39+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "So should we allow it and just kick the problem down the road to when the person using the admin panel goes to save the note? It will error at some point.\r\n\r\nMaybe we should have the validation actually be on the router? Ideally reusable by all the instance admin routes?",
        "pr_file_module": null
      },
      {
        "comment_id": "2150028286",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-16T13:34:35+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think I would be in favor of either ignoring the issue and only errorring on save, or further restrict the existing `constraints: { id: %r{[^/]+} }` constraint in the router (which I think would look like something like `constraints: ->(req) { TagManager.instance.normalize_domain(req.params['id']).present? }`), though that is a little awkward as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "2152927437",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-17T18:37:34+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "Could we maybe do a constrain that's just `\\w+(.\\w+)+` or something? i.e., any word character? Though arguably that wouldn't work with non-normalized IDN",
        "pr_file_module": null
      },
      {
        "comment_id": "2163886592",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-24T12:41:59+00:00",
        "comment_author": "oneiros",
        "comment_body": "FWIW, I think good old `ArgumentError` would have been the best error to raise here.\r\n\r\nBut I agree with Claire, that this behavior is a bit surprising. I would opt to just remove this method altogether.\r\n\r\nI also like the idea of the routing constraints, but those can be its own PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2164017575",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-24T13:30:12+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "How would we feel if I kept the method but removed the exception being thrown?",
        "pr_file_module": null
      },
      {
        "comment_id": "2164036572",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-24T13:38:50+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think I would just use `find_or_initialize_by(domain: )`, I don't really see the value of the method otherwise.",
        "pr_file_module": null
      },
      {
        "comment_id": "2164186928",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31529,
        "pr_file": "app/models/instance.rb",
        "discussion_id": "1845655532",
        "commented_code": "@@ -29,6 +30,14 @@ class Instance < ApplicationRecord\n   scope :by_domain_and_subdomains, ->(domain) { where(\"reverse('.' || domain) LIKE reverse(?)\", \"%.#{domain}\") }\n   scope :with_domain_follows, ->(domains) { where(domain: domains).where(domain_account_follows) }\n \n+  def self.find_or_initialize_by_domain(domain)\n+    normalized_domain = TagManager.instance.normalize_domain(domain&.strip)\n+\n+    raise ActiveRecord::RecordInvalid if normalized_domain.blank?",
        "comment_created_at": "2025-06-24T14:30:32+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "Have removed the method.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060206810",
    "pr_number": 34489,
    "pr_file": "app/models/featured_tag.rb",
    "created_at": "2025-04-25T13:06:20+00:00",
    "commented_code": "private\n \n   def set_tag\n-    self.tag = Tag.find_or_create_by_names(name)&.first\n+    if tag.nil?\n+      self.tag = Tag.find_or_create_by_names(name)&.first\n+    elsif tag&.new_record?\n+      tag.save!",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2060206810",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34489,
        "pr_file": "app/models/featured_tag.rb",
        "discussion_id": "2060206810",
        "commented_code": "@@ -59,7 +59,11 @@ def decrement(deleted_status)\n   private\n \n   def set_tag\n-    self.tag = Tag.find_or_create_by_names(name)&.first\n+    if tag.nil?\n+      self.tag = Tag.find_or_create_by_names(name)&.first\n+    elsif tag&.new_record?\n+      tag.save!",
        "comment_created_at": "2025-04-25T13:06:20+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think this `save!` is what causes the settings page to return a bogus 422 by raising a `ActiveRecord::RecordInvalid` instead of properly annotating the model with an error.",
        "pr_file_module": null
      },
      {
        "comment_id": "2060220992",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34489,
        "pr_file": "app/models/featured_tag.rb",
        "discussion_id": "2060206810",
        "commented_code": "@@ -59,7 +59,11 @@ def decrement(deleted_status)\n   private\n \n   def set_tag\n-    self.tag = Tag.find_or_create_by_names(name)&.first\n+    if tag.nil?\n+      self.tag = Tag.find_or_create_by_names(name)&.first\n+    elsif tag&.new_record?\n+      tag.save!",
        "comment_created_at": "2025-04-25T13:13:48+00:00",
        "comment_author": "Gargron",
        "comment_body": "Thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1759534176",
    "pr_number": 31910,
    "pr_file": "app/controllers/api/v1/accounts_controller.rb",
    "created_at": "2024-09-13T21:22:02+00:00",
    "commented_code": "options = @account.locked? || current_user.account.silenced? ? {} : { following_map: { @account.id => { reblogs: follow.show_reblogs?, notify: follow.notify?, languages: follow.languages } }, requested_map: { @account.id => false } }\n \n     render json: @account, serializer: REST::RelationshipSerializer, relationships: relationships(**options)\n+  rescue FollowService::SelfFollowError",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1759534176",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31910,
        "pr_file": "app/controllers/api/v1/accounts_controller.rb",
        "discussion_id": "1759534176",
        "commented_code": "@@ -47,6 +47,8 @@ def follow\n     options = @account.locked? || current_user.account.silenced? ? {} : { following_map: { @account.id => { reblogs: follow.show_reblogs?, notify: follow.notify?, languages: follow.languages } }, requested_map: { @account.id => false } }\n \n     render json: @account, serializer: REST::RelationshipSerializer, relationships: relationships(**options)\n+  rescue FollowService::SelfFollowError",
        "comment_created_at": "2024-09-13T21:22:02+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Is this ever actually raised?",
        "pr_file_module": null
      },
      {
        "comment_id": "1761468052",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31910,
        "pr_file": "app/controllers/api/v1/accounts_controller.rb",
        "discussion_id": "1759534176",
        "commented_code": "@@ -47,6 +47,8 @@ def follow\n     options = @account.locked? || current_user.account.silenced? ? {} : { following_map: { @account.id => { reblogs: follow.show_reblogs?, notify: follow.notify?, languages: follow.languages } }, requested_map: { @account.id => false } }\n \n     render json: @account, serializer: REST::RelationshipSerializer, relationships: relationships(**options)\n+  rescue FollowService::SelfFollowError",
        "comment_created_at": "2024-09-16T16:26:56+00:00",
        "comment_author": "lenikadali",
        "comment_body": "Good catch. Let me go over it and make sure that it is raised \ud83d\udc4d\ud83c\udfff ",
        "pr_file_module": null
      },
      {
        "comment_id": "1767536660",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31910,
        "pr_file": "app/controllers/api/v1/accounts_controller.rb",
        "discussion_id": "1759534176",
        "commented_code": "@@ -47,6 +47,8 @@ def follow\n     options = @account.locked? || current_user.account.silenced? ? {} : { following_map: { @account.id => { reblogs: follow.show_reblogs?, notify: follow.notify?, languages: follow.languages } }, requested_map: { @account.id => false } }\n \n     render json: @account, serializer: REST::RelationshipSerializer, relationships: relationships(**options)\n+  rescue FollowService::SelfFollowError",
        "comment_created_at": "2024-09-19T20:11:20+00:00",
        "comment_author": "mjankowski",
        "comment_body": "One idea here -- could we re-use `Mastodon::ValidatorError` (with a custom string)?\r\n\r\nI think this could keep the entire check at the controller level, would match existing style, and would let you remove all the new error classes, along with the changes to the service and service spec.\r\n\r\nFor an example of what I mean - look at `api/v1/filters#update` and how it raises that class (or `check_accounts_limit` in this controller, though it does not have a custom message).\r\n\r\nI suspect you could keep your request spec changes here, but move the actual check to a `before_action` in the controller (since it knows what accounts are relevant before passing in).",
        "pr_file_module": null
      }
    ]
  }
]