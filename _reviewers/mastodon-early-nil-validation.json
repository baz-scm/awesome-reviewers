[
  {
    "discussion_id": "2230498623",
    "pr_number": 35355,
    "pr_file": "app/lib/activitypub/activity/accept.rb",
    "created_at": "2025-07-25T08:27:39+00:00",
    "commented_code": "RemoteAccountRefreshWorker.perform_async(request.target_account_id) if is_first_follow\n   end\n \n+  def accept_embedded_quote_request\n+    quoted_status_uri = value_or_id(@object['object'])\n+    quoting_status_uri = value_or_id(@object['instrument'])\n+    approval_uri = value_or_id(first_of_value(@json['result']))\n+    return if quoted_status_uri.nil? || quoting_status_uri.nil? || approval_uri.nil?\n+\n+    quoting_status = status_from_uri(quoting_status_uri)\n+    return unless quoting_status.local?\n+\n+    quoted_status = status_from_uri(quoted_status_uri)",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2230498623",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/activity/accept.rb",
        "discussion_id": "2230498623",
        "commented_code": "@@ -31,6 +34,32 @@ def accept_follow!(request)\n     RemoteAccountRefreshWorker.perform_async(request.target_account_id) if is_first_follow\n   end\n \n+  def accept_embedded_quote_request\n+    quoted_status_uri = value_or_id(@object['object'])\n+    quoting_status_uri = value_or_id(@object['instrument'])\n+    approval_uri = value_or_id(first_of_value(@json['result']))\n+    return if quoted_status_uri.nil? || quoting_status_uri.nil? || approval_uri.nil?\n+\n+    quoting_status = status_from_uri(quoting_status_uri)\n+    return unless quoting_status.local?\n+\n+    quoted_status = status_from_uri(quoted_status_uri)",
        "comment_created_at": "2025-07-25T08:27:39+00:00",
        "comment_author": "oneiros",
        "comment_body": "I realize this is probably an extremely unlikely edge case, but could this status be missing and should this method account for that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2230682776",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/activity/accept.rb",
        "discussion_id": "2230498623",
        "commented_code": "@@ -31,6 +34,32 @@ def accept_follow!(request)\n     RemoteAccountRefreshWorker.perform_async(request.target_account_id) if is_first_follow\n   end\n \n+  def accept_embedded_quote_request\n+    quoted_status_uri = value_or_id(@object['object'])\n+    quoting_status_uri = value_or_id(@object['instrument'])\n+    approval_uri = value_or_id(first_of_value(@json['result']))\n+    return if quoted_status_uri.nil? || quoting_status_uri.nil? || approval_uri.nil?\n+\n+    quoting_status = status_from_uri(quoting_status_uri)\n+    return unless quoting_status.local?\n+\n+    quoted_status = status_from_uri(quoted_status_uri)",
        "comment_created_at": "2025-07-25T09:54:58+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Good catch, this would indeed be a weird edge case, but it should probably be gracefully handled rather than raising an exception and clogging queues with retried jobs which are extremely unlikely to ever proceed. Will have a look!",
        "pr_file_module": null
      },
      {
        "comment_id": "2230756367",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/activity/accept.rb",
        "discussion_id": "2230498623",
        "commented_code": "@@ -31,6 +34,32 @@ def accept_follow!(request)\n     RemoteAccountRefreshWorker.perform_async(request.target_account_id) if is_first_follow\n   end\n \n+  def accept_embedded_quote_request\n+    quoted_status_uri = value_or_id(@object['object'])\n+    quoting_status_uri = value_or_id(@object['instrument'])\n+    approval_uri = value_or_id(first_of_value(@json['result']))\n+    return if quoted_status_uri.nil? || quoting_status_uri.nil? || approval_uri.nil?\n+\n+    quoting_status = status_from_uri(quoting_status_uri)\n+    return unless quoting_status.local?\n+\n+    quoted_status = status_from_uri(quoted_status_uri)",
        "comment_created_at": "2025-07-25T10:34:08+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I changed it to silently return if the post is missing.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1969848253",
    "pr_number": 33993,
    "pr_file": "app/models/terms_of_service.rb",
    "created_at": "2025-02-25T14:04:08+00:00",
    "commented_code": "#\n #  id                   :bigint(8)        not null, primary key\n #  changelog            :text             default(\"\"), not null\n+#  effective_date       :date\n #  notification_sent_at :datetime\n #  published_at         :datetime\n #  text                 :text             default(\"\"), not null\n #  created_at           :datetime         not null\n #  updated_at           :datetime         not null\n #\n class TermsOfService < ApplicationRecord\n-  scope :published, -> { where.not(published_at: nil).order(published_at: :desc) }\n-  scope :live, -> { published.limit(1) }\n+  scope :published, -> { where.not(published_at: nil).order(effective_date: :desc) }\n+  scope :live, -> { published.where('effective_date < now()').limit(1) }\n   scope :draft, -> { where(published_at: nil).order(id: :desc).limit(1) }\n \n   validates :text, presence: true\n-  validates :changelog, presence: true, if: -> { published? }\n+  validates :changelog, :effective_date, presence: true, if: -> { published? }\n+\n+  validate :effective_date_cannot_be_in_the_past\n \n   def published?\n     published_at.present?\n   end\n \n+  def effective?\n+    published? && effective_date.past?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1969848253",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33993,
        "pr_file": "app/models/terms_of_service.rb",
        "discussion_id": "1969848253",
        "commented_code": "@@ -6,29 +6,50 @@\n #\n #  id                   :bigint(8)        not null, primary key\n #  changelog            :text             default(\"\"), not null\n+#  effective_date       :date\n #  notification_sent_at :datetime\n #  published_at         :datetime\n #  text                 :text             default(\"\"), not null\n #  created_at           :datetime         not null\n #  updated_at           :datetime         not null\n #\n class TermsOfService < ApplicationRecord\n-  scope :published, -> { where.not(published_at: nil).order(published_at: :desc) }\n-  scope :live, -> { published.limit(1) }\n+  scope :published, -> { where.not(published_at: nil).order(effective_date: :desc) }\n+  scope :live, -> { published.where('effective_date < now()').limit(1) }\n   scope :draft, -> { where(published_at: nil).order(id: :desc).limit(1) }\n \n   validates :text, presence: true\n-  validates :changelog, presence: true, if: -> { published? }\n+  validates :changelog, :effective_date, presence: true, if: -> { published? }\n+\n+  validate :effective_date_cannot_be_in_the_past\n \n   def published?\n     published_at.present?\n   end\n \n+  def effective?\n+    published? && effective_date.past?",
        "comment_created_at": "2025-02-25T14:04:08+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "`effective_date` can be `nil`, for instance for ToS entries created before this PR. In such cases, this will raise `NoMethodError (undefined method 'past?' for nil)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1913144867",
    "pr_number": 33570,
    "pr_file": "app/lib/activitypub/activity/announce.rb",
    "created_at": "2025-01-13T12:50:52+00:00",
    "commented_code": "return reject_payload! if delete_arrived_first?(@json['id']) || !related_to_local_activity?\n \n     with_redis_lock(\"announce:#{value_or_id(@object)}\") do\n+      return reject_payload! if @object.nil?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1913144867",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33570,
        "pr_file": "app/lib/activitypub/activity/announce.rb",
        "discussion_id": "1913144867",
        "commented_code": "@@ -5,6 +5,8 @@ def perform\n     return reject_payload! if delete_arrived_first?(@json['id']) || !related_to_local_activity?\n \n     with_redis_lock(\"announce:#{value_or_id(@object)}\") do\n+      return reject_payload! if @object.nil?",
        "comment_created_at": "2025-01-13T12:50:52+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think this should go even earlier, you can avoid the Redis lock.",
        "pr_file_module": null
      },
      {
        "comment_id": "1913182263",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33570,
        "pr_file": "app/lib/activitypub/activity/announce.rb",
        "discussion_id": "1913144867",
        "commented_code": "@@ -5,6 +5,8 @@ def perform\n     return reject_payload! if delete_arrived_first?(@json['id']) || !related_to_local_activity?\n \n     with_redis_lock(\"announce:#{value_or_id(@object)}\") do\n+      return reject_payload! if @object.nil?",
        "comment_created_at": "2025-01-13T13:20:11+00:00",
        "comment_author": "ShadowJonathan",
        "comment_body": "Done, placed it before the redis lock",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2099665570",
    "pr_number": 34749,
    "pr_file": "app/lib/entity_cache.rb",
    "created_at": "2025-05-21T08:17:57+00:00",
    "commented_code": "uncached.each_value { |item| Rails.cache.write(to_key(:emoji, item.shortcode, domain), item, expires_in: MAX_EXPIRATION) }\n     end\n \n-    shortcodes.filter_map { |shortcode| cached[to_key(:emoji, shortcode, domain)] || uncached[shortcode] }\n+    shortcodes.filter_map { |shortcode| cached[to_key(:emoji, shortcode, domain)] || (uncached[shortcode] if uncached) }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2099665570",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34749,
        "pr_file": "app/lib/entity_cache.rb",
        "discussion_id": "2099665570",
        "commented_code": "@@ -31,7 +31,7 @@ def emoji(shortcodes, domain)\n       uncached.each_value { |item| Rails.cache.write(to_key(:emoji, item.shortcode, domain), item, expires_in: MAX_EXPIRATION) }\n     end\n \n-    shortcodes.filter_map { |shortcode| cached[to_key(:emoji, shortcode, domain)] || uncached[shortcode] }\n+    shortcodes.filter_map { |shortcode| cached[to_key(:emoji, shortcode, domain)] || (uncached[shortcode] if uncached) }",
        "comment_created_at": "2025-05-21T08:17:57+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "What about just defining `uncached = {}` just a few lines above, so that it's never `nil`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1930806926",
    "pr_number": 33746,
    "pr_file": "lib/devise/strategies/two_factor_pam_authenticatable.rb",
    "created_at": "2025-01-27T16:19:58+00:00",
    "commented_code": "protected\n \n       def valid_params?\n-        params[scope] && params[scope][:password].present?\n+        params[scope].respond_to?(:[]) && params[scope][:password].present?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1930806926",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33746,
        "pr_file": "lib/devise/strategies/two_factor_pam_authenticatable.rb",
        "discussion_id": "1930806926",
        "commented_code": "@@ -22,7 +22,7 @@ def authenticate!\n       protected\n \n       def valid_params?\n-        params[scope] && params[scope][:password].present?\n+        params[scope].respond_to?(:[]) && params[scope][:password].present?",
        "comment_created_at": "2025-01-27T16:19:58+00:00",
        "comment_author": "oneiros",
        "comment_body": "Would\r\n\r\n```ruby\r\nparams.dig(scope, :password).present?\r\n```\r\n\r\nwork as well? That is a bit more succinct and imo even a bit more readable.",
        "pr_file_module": null
      },
      {
        "comment_id": "1930811228",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33746,
        "pr_file": "lib/devise/strategies/two_factor_pam_authenticatable.rb",
        "discussion_id": "1930806926",
        "commented_code": "@@ -22,7 +22,7 @@ def authenticate!\n       protected\n \n       def valid_params?\n-        params[scope] && params[scope][:password].present?\n+        params[scope].respond_to?(:[]) && params[scope][:password].present?",
        "comment_created_at": "2025-01-27T16:22:51+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "No! This would precisely not work, because the failing test passes an array as `scope`, which causes `no implicit conversion of Symbol into Integer`, an error that would remain the same with `dig`!",
        "pr_file_module": null
      },
      {
        "comment_id": "1930817531",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33746,
        "pr_file": "lib/devise/strategies/two_factor_pam_authenticatable.rb",
        "discussion_id": "1930806926",
        "commented_code": "@@ -22,7 +22,7 @@ def authenticate!\n       protected\n \n       def valid_params?\n-        params[scope] && params[scope][:password].present?\n+        params[scope].respond_to?(:[]) && params[scope][:password].present?",
        "comment_created_at": "2025-01-27T16:26:57+00:00",
        "comment_author": "oneiros",
        "comment_body": "Ah, OK. Thanks for clarifying!",
        "pr_file_module": null
      }
    ]
  }
]