[
  {
    "discussion_id": "1194195396",
    "pr_number": 24981,
    "pr_file": "app/views/shared/_web_app.html.haml",
    "created_at": "2023-05-15T18:15:02+00:00",
    "commented_code": "- content_for :header_tags do\n   - if user_signed_in?\n-    = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1194195396",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 24981,
        "pr_file": "app/views/shared/_web_app.html.haml",
        "discussion_id": "1194195396",
        "commented_code": "@@ -1,17 +1,17 @@\n - content_for :header_tags do\n   - if user_signed_in?\n-    = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'",
        "comment_created_at": "2023-05-15T18:15:02+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "My understanding is that these maybe could be deleted because Vite automatically preloads? (assuming the application was structured in a way to code-split effectively)",
        "pr_file_module": null
      },
      {
        "comment_id": "1194457091",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 24981,
        "pr_file": "app/views/shared/_web_app.html.haml",
        "discussion_id": "1194195396",
        "commented_code": "@@ -1,17 +1,17 @@\n - content_for :header_tags do\n   - if user_signed_in?\n-    = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n-    = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/compose.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/home_timeline.js', crossorigin: 'anonymous'\n+    -# = preload_pack_asset 'features/notifications.js', crossorigin: 'anonymous'",
        "comment_created_at": "2023-05-15T23:41:15+00:00",
        "comment_author": "ElMassimo",
        "comment_body": "That's correct. Any chunks that the entrypoint depends on would be preloaded (even with early hints, when available).\r\n\r\nAn exception would be dynamically imported scripts, which are not preloaded by default (but can be preloaded manually, as the information is available in the manifest).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077896180",
    "pr_number": 34450,
    "pr_file": "vite.config.mts",
    "created_at": "2025-05-07T15:15:04+00:00",
    "commented_code": "+import fs from 'node:fs/promises';\n+import path from 'node:path';\n+\n+import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\n+import react from '@vitejs/plugin-react';\n+import { PluginOption } from 'vite';\n+import svgr from 'vite-plugin-svgr';\n+import { analyzer } from 'vite-bundle-analyzer';\n+import RailsPlugin from 'vite-plugin-rails';\n+import { VitePWA } from 'vite-plugin-pwa';\n+\n+import { defineConfig, UserConfigFnPromise, UserConfig } from 'vite';\n+import postcssPresetEnv from 'postcss-preset-env';\n+\n+import { MastodonServiceWorkerLocales } from './config/vite/plugin-sw-locales';\n+\n+const jsRoot = path.resolve(__dirname, 'app/javascript');\n+const entrypointRoot = path.resolve(jsRoot, 'entrypoints');\n+\n+export const config: UserConfigFnPromise = async ({ mode, command }) => {\n+  const entrypointFiles = await fs.readdir(entrypointRoot);\n+  const entrypoints: Record<string, string> = entrypointFiles.reduce(\n+    (acc, file) => {\n+      const name = path.basename(file).replace(/\\.tsx?$/, '');\n+      acc[name] = path.resolve(entrypointRoot, file);\n+      return acc;\n+    },\n+    {} as Record<string, string>,\n+  );\n+  return {\n+    root: jsRoot,\n+    css: {\n+      postcss: {\n+        plugins: [\n+          postcssPresetEnv({\n+            features: {\n+              'logical-properties-and-values': false,\n+            },\n+          }),\n+        ],\n+      },\n+    },\n+    resolve: {\n+      alias: {\n+        mastodon: path.resolve(jsRoot, 'mastodon'),\n+        '@': jsRoot,\n+      },\n+    },\n+    server: {\n+      headers: {\n+        // This is needed in dev environment because we load the worker from `/dev-sw/dev-sw.js`,\n+        // but it needs to be scoped to the whole domain\n+        'Service-Worker-Allowed': '/',\n+      },\n+    },\n+    build: {\n+      commonjsOptions: { transformMixedEsModules: true },\n+      chunkSizeWarningLimit: 1 * 1024 * 1024, // 1MB\n+      manifest: 'manifest.json',\n+      sourcemap: true,\n+      rollupOptions: {\n+        input: entrypoints,\n+        output: {\n+          chunkFileNames(chunkInfo) {\n+            if (!chunkInfo.facadeModuleId) {\n+              return '[name]-[hash].js';\n+            }\n+            if (\n+              /mastodon\\/locales\\/[a-zA-Z-]+\\.json/.exec(\n+                chunkInfo.facadeModuleId,\n+              )\n+            ) {\n+              // put all locale files in `intl/`\n+              return `intl/[name]-[hash].js`;\n+            } else if (\n+              /node_modules\\/@formatjs\\//.exec(chunkInfo.facadeModuleId)\n+            ) {\n+              // use a custom name for formatjs polyfill files\n+              const name = /node_modules\\/@formatjs\\/([^/]+)\\//.exec(\n+                chunkInfo.facadeModuleId,\n+              );\n+\n+              if (name?.[1]) {\n+                return `intl/[name]-${name[1]}-[hash].js`;\n+              }\n+            } else if (chunkInfo.name === 'index' && chunkInfo.facadeModuleId) {\n+              // Use a custom name for chunks, to avoid having too many of them called \"index\"\n+              const parts = chunkInfo.facadeModuleId.split('/');\n+\n+              const parent = parts.at(-2);\n+\n+              if (parent) {\n+                return `${parent}-[name]-[hash].js`;\n+              }\n+            }\n+            return `[name]-[hash].js`;\n+          },\n+        },\n+      },\n+    },\n+    plugins: [\n+      RailsPlugin({\n+        compress: mode !== 'production' && command === 'build',\n+      }),\n+      react({\n+        babel: {\n+          plugins: ['formatjs', 'transform-react-remove-prop-types', 'preval'],\n+        },\n+      }),\n+      MastodonServiceWorkerLocales(),\n+      VitePWA({\n+        srcDir: 'mastodon/service_worker',\n+        // We need to use injectManifest because we use our own service worker\n+        strategies: 'injectManifest',\n+        manifest: false,\n+        injectRegister: false,\n+        injectManifest: {\n+          // Do not inject a manifest, we dont use precache\n+          injectionPoint: undefined,\n+          buildPlugins: {\n+            vite: [\n+              // Provide a virtual import with only the locales used in the ServiceWorker\n+              MastodonServiceWorkerLocales(),\n+            ],\n+          },\n+          // Force the output location, because we have a symlink in `public/sw.js`\n+        },\n+        outDir: path.resolve(__dirname, 'public/packs'),\n+        devOptions: {\n+          enabled: true,\n+          type: 'module',\n+        },\n+      }),\n+      svgr(),\n+      // Old library types need to be converted\n+      optimizeLodashImports() as PluginOption,\n+      !!process.env.ANALYZE_BUNDLE_SIZE && analyzer({ analyzerMode: 'static' }),",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2077896180",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "vite.config.mts",
        "discussion_id": "2077896180",
        "commented_code": "@@ -0,0 +1,142 @@\n+import fs from 'node:fs/promises';\n+import path from 'node:path';\n+\n+import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\n+import react from '@vitejs/plugin-react';\n+import { PluginOption } from 'vite';\n+import svgr from 'vite-plugin-svgr';\n+import { analyzer } from 'vite-bundle-analyzer';\n+import RailsPlugin from 'vite-plugin-rails';\n+import { VitePWA } from 'vite-plugin-pwa';\n+\n+import { defineConfig, UserConfigFnPromise, UserConfig } from 'vite';\n+import postcssPresetEnv from 'postcss-preset-env';\n+\n+import { MastodonServiceWorkerLocales } from './config/vite/plugin-sw-locales';\n+\n+const jsRoot = path.resolve(__dirname, 'app/javascript');\n+const entrypointRoot = path.resolve(jsRoot, 'entrypoints');\n+\n+export const config: UserConfigFnPromise = async ({ mode, command }) => {\n+  const entrypointFiles = await fs.readdir(entrypointRoot);\n+  const entrypoints: Record<string, string> = entrypointFiles.reduce(\n+    (acc, file) => {\n+      const name = path.basename(file).replace(/\\.tsx?$/, '');\n+      acc[name] = path.resolve(entrypointRoot, file);\n+      return acc;\n+    },\n+    {} as Record<string, string>,\n+  );\n+  return {\n+    root: jsRoot,\n+    css: {\n+      postcss: {\n+        plugins: [\n+          postcssPresetEnv({\n+            features: {\n+              'logical-properties-and-values': false,\n+            },\n+          }),\n+        ],\n+      },\n+    },\n+    resolve: {\n+      alias: {\n+        mastodon: path.resolve(jsRoot, 'mastodon'),\n+        '@': jsRoot,\n+      },\n+    },\n+    server: {\n+      headers: {\n+        // This is needed in dev environment because we load the worker from `/dev-sw/dev-sw.js`,\n+        // but it needs to be scoped to the whole domain\n+        'Service-Worker-Allowed': '/',\n+      },\n+    },\n+    build: {\n+      commonjsOptions: { transformMixedEsModules: true },\n+      chunkSizeWarningLimit: 1 * 1024 * 1024, // 1MB\n+      manifest: 'manifest.json',\n+      sourcemap: true,\n+      rollupOptions: {\n+        input: entrypoints,\n+        output: {\n+          chunkFileNames(chunkInfo) {\n+            if (!chunkInfo.facadeModuleId) {\n+              return '[name]-[hash].js';\n+            }\n+            if (\n+              /mastodon\\/locales\\/[a-zA-Z-]+\\.json/.exec(\n+                chunkInfo.facadeModuleId,\n+              )\n+            ) {\n+              // put all locale files in `intl/`\n+              return `intl/[name]-[hash].js`;\n+            } else if (\n+              /node_modules\\/@formatjs\\//.exec(chunkInfo.facadeModuleId)\n+            ) {\n+              // use a custom name for formatjs polyfill files\n+              const name = /node_modules\\/@formatjs\\/([^/]+)\\//.exec(\n+                chunkInfo.facadeModuleId,\n+              );\n+\n+              if (name?.[1]) {\n+                return `intl/[name]-${name[1]}-[hash].js`;\n+              }\n+            } else if (chunkInfo.name === 'index' && chunkInfo.facadeModuleId) {\n+              // Use a custom name for chunks, to avoid having too many of them called \"index\"\n+              const parts = chunkInfo.facadeModuleId.split('/');\n+\n+              const parent = parts.at(-2);\n+\n+              if (parent) {\n+                return `${parent}-[name]-[hash].js`;\n+              }\n+            }\n+            return `[name]-[hash].js`;\n+          },\n+        },\n+      },\n+    },\n+    plugins: [\n+      RailsPlugin({\n+        compress: mode !== 'production' && command === 'build',\n+      }),\n+      react({\n+        babel: {\n+          plugins: ['formatjs', 'transform-react-remove-prop-types', 'preval'],\n+        },\n+      }),\n+      MastodonServiceWorkerLocales(),\n+      VitePWA({\n+        srcDir: 'mastodon/service_worker',\n+        // We need to use injectManifest because we use our own service worker\n+        strategies: 'injectManifest',\n+        manifest: false,\n+        injectRegister: false,\n+        injectManifest: {\n+          // Do not inject a manifest, we dont use precache\n+          injectionPoint: undefined,\n+          buildPlugins: {\n+            vite: [\n+              // Provide a virtual import with only the locales used in the ServiceWorker\n+              MastodonServiceWorkerLocales(),\n+            ],\n+          },\n+          // Force the output location, because we have a symlink in `public/sw.js`\n+        },\n+        outDir: path.resolve(__dirname, 'public/packs'),\n+        devOptions: {\n+          enabled: true,\n+          type: 'module',\n+        },\n+      }),\n+      svgr(),\n+      // Old library types need to be converted\n+      optimizeLodashImports() as PluginOption,\n+      !!process.env.ANALYZE_BUNDLE_SIZE && analyzer({ analyzerMode: 'static' }),",
        "comment_created_at": "2025-05-07T15:15:04+00:00",
        "comment_author": "renchap",
        "comment_body": "`rollup-plugin-visualizer` is a better plugin for this from what I tested",
        "pr_file_module": null
      }
    ]
  }
]