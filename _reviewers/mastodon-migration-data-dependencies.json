[
  {
    "discussion_id": "2220246141",
    "pr_number": 35407,
    "pr_file": "db/migrate/20250717003848_create_username_blocks.rb",
    "created_at": "2025-07-21T20:29:08+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class CreateUsernameBlocks < ActiveRecord::Migration[8.0]\n+  def change\n+    create_table :username_blocks do |t|\n+      t.string :username, null: false\n+      t.boolean :exact, null: false, default: false\n+      t.boolean :allow_with_approval, null: false, default: false\n+\n+      t.timestamps\n+    end\n+\n+    add_index :username_blocks, 'lower(username)', unique: true, opclass: :text_pattern_ops, name: 'index_username_blocks_on_username_lower_btree'\n+\n+    reversible do |dir|\n+      dir.up do\n+        load Rails.root.join('db', 'seeds', '05_blocked_usernames.rb')",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2220246141",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "db/migrate/20250717003848_create_username_blocks.rb",
        "discussion_id": "2220246141",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class CreateUsernameBlocks < ActiveRecord::Migration[8.0]\n+  def change\n+    create_table :username_blocks do |t|\n+      t.string :username, null: false\n+      t.boolean :exact, null: false, default: false\n+      t.boolean :allow_with_approval, null: false, default: false\n+\n+      t.timestamps\n+    end\n+\n+    add_index :username_blocks, 'lower(username)', unique: true, opclass: :text_pattern_ops, name: 'index_username_blocks_on_username_lower_btree'\n+\n+    reversible do |dir|\n+      dir.up do\n+        load Rails.root.join('db', 'seeds', '05_blocked_usernames.rb')",
        "comment_created_at": "2025-07-21T20:29:08+00:00",
        "comment_author": "mjankowski",
        "comment_body": "I see this new seed file brings in the previous list from config/settings ... I think the scenarios are:\n\n- New/fresh installs ... would either load full db structure and load from seeds, or would run full migrate and then load from seeds, which in both cases would leave them with that full set in place\n- Existing installs ... previously were relying on the default settings from yaml, would run this migration and load all those into new db table\n\nIs there an issue if that seed file changes? If we added a username to that seed file, would we need to also add a migration to add the new value? (assuming existing installs are not re-running seed load on upgrades)",
        "pr_file_module": null
      },
      {
        "comment_id": "2224984715",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "db/migrate/20250717003848_create_username_blocks.rb",
        "discussion_id": "2220246141",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class CreateUsernameBlocks < ActiveRecord::Migration[8.0]\n+  def change\n+    create_table :username_blocks do |t|\n+      t.string :username, null: false\n+      t.boolean :exact, null: false, default: false\n+      t.boolean :allow_with_approval, null: false, default: false\n+\n+      t.timestamps\n+    end\n+\n+    add_index :username_blocks, 'lower(username)', unique: true, opclass: :text_pattern_ops, name: 'index_username_blocks_on_username_lower_btree'\n+\n+    reversible do |dir|\n+      dir.up do\n+        load Rails.root.join('db', 'seeds', '05_blocked_usernames.rb')",
        "comment_created_at": "2025-07-23T09:37:31+00:00",
        "comment_author": "Gargron",
        "comment_body": "I'm not sure how much it makes sense to modify people's blocks after the initial import. We can't really ever remove anything, right? There's something similar for user roles.",
        "pr_file_module": null
      },
      {
        "comment_id": "2225497696",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "db/migrate/20250717003848_create_username_blocks.rb",
        "discussion_id": "2220246141",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class CreateUsernameBlocks < ActiveRecord::Migration[8.0]\n+  def change\n+    create_table :username_blocks do |t|\n+      t.string :username, null: false\n+      t.boolean :exact, null: false, default: false\n+      t.boolean :allow_with_approval, null: false, default: false\n+\n+      t.timestamps\n+    end\n+\n+    add_index :username_blocks, 'lower(username)', unique: true, opclass: :text_pattern_ops, name: 'index_username_blocks_on_username_lower_btree'\n+\n+    reversible do |dir|\n+      dir.up do\n+        load Rails.root.join('db', 'seeds', '05_blocked_usernames.rb')",
        "comment_created_at": "2025-07-23T12:49:42+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Yeah - was sort of thinking out loud there, and I guess it would be similar to the user role scenario.\n\nIf we ever added a new user role, we presumably would both add it to the seeds file and then run a migration to add the role. Though those are a little different because the app is more depending on all the (core) roles existing in order to function correctly, whereas the username block list is more of a default/sugggested list sort of thing, but not required to function.\n\nI guess the question is if we JUST want to correctly migrate all existing installs to preserve the list they currently have, this could just live in the migration and not a seeds file. If we also want to provide this list as starting data to every new/future install, seeds (or some other re-runnable tootctl or something) is fine.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1720803347",
    "pr_number": 31471,
    "pr_file": "db/migrate/20240817155611_split_public_timelines_setting.rb",
    "created_at": "2024-08-17T16:53:06+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class SplitPublicTimelinesSetting < ActiveRecord::Migration[7.1]",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1720803347",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31471,
        "pr_file": "db/migrate/20240817155611_split_public_timelines_setting.rb",
        "discussion_id": "1720803347",
        "commented_code": "@@ -0,0 +1,25 @@\n+# frozen_string_literal: true\n+\n+class SplitPublicTimelinesSetting < ActiveRecord::Migration[7.1]",
        "comment_created_at": "2024-08-17T16:53:06+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "I wasn't sure on the exact way to do this migration, but I've tested it locally a bunch and it appears to work.\r\n\r\nThe goal is to inherit the previous setting for both, if a previous setting existed, otherwise use the defaults (allow timeline_preview_local, prevent timeline_preview_remote).\r\n\r\nReverting the setting in the down is also a bit chaotic, and also kinda unneeded because, well, do we ever do down migrations post-merge of a migration?",
        "pr_file_module": null
      },
      {
        "comment_id": "1861239461",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31471,
        "pr_file": "db/migrate/20240817155611_split_public_timelines_setting.rb",
        "discussion_id": "1720803347",
        "commented_code": "@@ -0,0 +1,25 @@\n+# frozen_string_literal: true\n+\n+class SplitPublicTimelinesSetting < ActiveRecord::Migration[7.1]",
        "comment_created_at": "2024-11-27T20:58:34+00:00",
        "comment_author": "mjankowski",
        "comment_body": "> The goal is to inherit the previous setting for both, if a previous setting existed, otherwise use the defaults (allow timeline_preview_local, prevent timeline_preview_remote).\r\n\r\nThe logic looks more/less correct to me ... I do wonder for perf reasons if a) should be \"post migrate\"? b) it might be gnarly with the settings hash storage, but could we this via direct sql w/out needing the AR class in the migration?\r\n\r\n> Reverting the setting in the down is also a bit chaotic, and also kinda unneeded because, well, do we ever do down migrations post-merge of a migration?\r\n\r\nIf the data is truly destroyed and not recoverable/rebuildable, it should raise the irreversible migration error and not just approximate something. I'd say this case we can (at least if done immediately) in fact reconstruct the before state from the after state, so its fine to keep it.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1861310614",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31471,
        "pr_file": "db/migrate/20240817155611_split_public_timelines_setting.rb",
        "discussion_id": "1720803347",
        "commented_code": "@@ -0,0 +1,25 @@\n+# frozen_string_literal: true\n+\n+class SplitPublicTimelinesSetting < ActiveRecord::Migration[7.1]",
        "comment_created_at": "2024-11-27T22:35:44+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "I've been having a think about this further, and I'm not sure we actually even want these routes, instead I think we'd want like `GET /api/v1/timelines/preview/local` or something. That way we avoid all this complicated boolean logic.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1871270517",
    "pr_number": 31971,
    "pr_file": "db/post_migrate/20240918170954_remove_settings_thing.rb",
    "created_at": "2024-12-05T12:10:59+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class RemoveSettingsThing < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  def change\n+    connection.execute(<<~SQL.squish)\n+      DELETE FROM settings WHERE thing_type IS NOT NULL and thing_id IS NOT NULL\n+    SQL",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1871270517",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31971,
        "pr_file": "db/post_migrate/20240918170954_remove_settings_thing.rb",
        "discussion_id": "1871270517",
        "commented_code": "@@ -0,0 +1,19 @@\n+# frozen_string_literal: true\n+\n+class RemoveSettingsThing < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  def change\n+    connection.execute(<<~SQL.squish)\n+      DELETE FROM settings WHERE thing_type IS NOT NULL and thing_id IS NOT NULL\n+    SQL",
        "comment_created_at": "2024-12-05T12:10:59+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think this needs to be moved to a pre-deployment migration. And now that we have migration breakpoints, it should be safe to do so.",
        "pr_file_module": null
      },
      {
        "comment_id": "1871382667",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31971,
        "pr_file": "db/post_migrate/20240918170954_remove_settings_thing.rb",
        "discussion_id": "1871270517",
        "commented_code": "@@ -0,0 +1,19 @@\n+# frozen_string_literal: true\n+\n+class RemoveSettingsThing < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  def change\n+    connection.execute(<<~SQL.squish)\n+      DELETE FROM settings WHERE thing_type IS NOT NULL and thing_id IS NOT NULL\n+    SQL",
        "comment_created_at": "2024-12-05T13:26:15+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Will do -- just to confirm, move **JUST** the delete line to new migration in `db/migrate`, but leave the rest (add index, remove index, remove columns) as-is in this `db/post_migrate` one?",
        "pr_file_module": null
      },
      {
        "comment_id": "1871417808",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31971,
        "pr_file": "db/post_migrate/20240918170954_remove_settings_thing.rb",
        "discussion_id": "1871270517",
        "commented_code": "@@ -0,0 +1,19 @@\n+# frozen_string_literal: true\n+\n+class RemoveSettingsThing < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  def change\n+    connection.execute(<<~SQL.squish)\n+      DELETE FROM settings WHERE thing_type IS NOT NULL and thing_id IS NOT NULL\n+    SQL",
        "comment_created_at": "2024-12-05T13:47:28+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "That is a good question. I guess the assumption now is that anyone running those will be on 4.3.0 or newer, or will have the services stopped while running the migrations. This means they should normally not lead to new entries with `thing_id` and `thing_type`. Just to be safe we could do the deletion in both a pre and post-deployment migration.\r\n\r\nThe columns removal still need to be in a post-deployment migration because the 4.3.0 code does not ignore those columns. Index changes should be safe either way I suppose, but if we are re-deleting stuff out of cautiousness in the post-deployment migrations, this means we would do the index changes there too.",
        "pr_file_module": null
      },
      {
        "comment_id": "1871472639",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31971,
        "pr_file": "db/post_migrate/20240918170954_remove_settings_thing.rb",
        "discussion_id": "1871270517",
        "commented_code": "@@ -0,0 +1,19 @@\n+# frozen_string_literal: true\n+\n+class RemoveSettingsThing < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  def change\n+    connection.execute(<<~SQL.squish)\n+      DELETE FROM settings WHERE thing_type IS NOT NULL and thing_id IS NOT NULL\n+    SQL",
        "comment_created_at": "2024-12-05T14:21:14+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Rebased, pushed another update...\r\n\r\n- Remove previous single migration doing everything\r\n- Added new db/migrate migration to do just the delete\r\n- Added new db/post_migrate to repeat the delete and do the other ops\r\n- Other changes are same\r\n\r\nConverted to ready for review as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1700097858",
    "pr_number": 31241,
    "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
    "created_at": "2024-08-01T12:58:34+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1700097858",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T12:58:34+00:00",
        "comment_author": "mjankowski",
        "comment_body": "I feel like I'm missing something obvious, but -- shouldnt this role already exist from the seeds?",
        "pr_file_module": null
      },
      {
        "comment_id": "1700142219",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T13:24:46+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Those are loaded in a post-deployment migration (not sure why we did it that way), which means there is no guarantee the role exists at runtime (or in pre-deployment migrations).",
        "pr_file_module": null
      },
      {
        "comment_id": "1700229340",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T13:51:53+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Interesting ... I'd never noticed that migration before. So currently if someone runs `bin/rails db:migrate:setup` (or some variation of \"run migrations and seeds\" via whatever commands you might use), they wind up loading all the seeds once, and then the roles seed specifically a second time during that one migration. This is basically harmless since the seed files are all idempotent and will just not do anything after the first run.\r\n\r\nI assume the reason for this migration then is that if we're going to keep the FK constraint and also have a default value, we need to be sure the row exists _before_ the migration adding the default is run, and thus can't rely on a post-migrations-run or post-schema-load db seed load?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1700298681",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T14:25:39+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Yes, that's it!\r\n\r\nThough, once again, taking a step back, I would be happy with a migration-less approach that may do a N+1 once if the default role doesn't exist yet at runtime, as long as we can avoid N+1s when the role does exist.",
        "pr_file_module": null
      },
      {
        "comment_id": "1700311161",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T14:32:59+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Yeah, agreed on that ... I think we safely can assume that during app runtime all migrations have been run and the seeds have been loaded? So for the purposes of \"try to stop the N+1 on users with null role values\", we can assume that the everyone user role (since loaded by seeds) does exist?\r\n\r\nIf we CANT assume that ... that's rough. Maybe an initializer or something similar to the RAILS_ENV check on boot that would just abort/warn if the record is not there (with a message to run the seeds?).\r\n\r\nIf we can assume that, I think that path of trying to mitigate with after_initialize or some other migration-less approach is at least worth trying first before resorting to this migration approach.",
        "pr_file_module": null
      },
      {
        "comment_id": "1700321815",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-08-01T14:39:14+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "The main issue with `after_initialize` is that it would set the value to `-99` in the database, while we ideally do not want that to be persisted in the database, for index size reasons mainly.",
        "pr_file_module": null
      },
      {
        "comment_id": "1861228469",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31241,
        "pr_file": "db/migrate/20240801094244_populate_everyone_role.rb",
        "discussion_id": "1700097858",
        "commented_code": "@@ -0,0 +1,21 @@\n+# frozen_string_literal: true\n+\n+class PopulateEveryoneRole < ActiveRecord::Migration[7.1]\n+  disable_ddl_transaction!\n+\n+  class UserRole < ApplicationRecord\n+    EVERYONE_ROLE_ID = -99\n+\n+    FLAGS = {\n+      invite_users: (1 << 16),\n+    }.freeze\n+  end\n+\n+  def up\n+    UserRole.create!(id: UserRole::EVERYONE_ROLE_ID, permissions: UserRole::FLAGS[:invite_users])",
        "comment_created_at": "2024-11-27T20:45:46+00:00",
        "comment_author": "mjankowski",
        "comment_body": "This preference (of preferring nil in DB with model level defaults) is sort of similar to https://github.com/mastodon/mastodon/pull/31908 ... if that's truly a team pref in a general sense rather than case by case, might be good to capture that somewhere.\r\n\r\nIt's also not 100% clear to me whether the DB index issue is the prime driver on the other linked one, or if that's more about \"preserve the ability to change defaults for users who have never set something\", or something else.",
        "pr_file_module": null
      }
    ]
  }
]