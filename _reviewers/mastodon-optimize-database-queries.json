[
  {
    "discussion_id": "2224928716",
    "pr_number": 35407,
    "pr_file": "app/models/username_block.rb",
    "created_at": "2025-07-23T09:13:34+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: username_blocks\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  allow_with_approval :boolean          default(FALSE), not null\n+#  exact               :boolean          default(FALSE), not null\n+#  username            :string           not null\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#\n+\n+class UsernameBlock < ApplicationRecord\n+  HOMOGLYPHS = {\n+    '1' => 'i',\n+    '2' => 'z',\n+    '3' => 'e',\n+    '4' => 'a',\n+    '5' => 's',\n+    '7' => 't',\n+    '8' => 'b',\n+    '9' => 'g',\n+    '0' => 'o',\n+  }.freeze\n+\n+  validates :username, presence: true, uniqueness: true\n+\n+  scope :matches_exactly, ->(str) { where(exact: true).where(arel_table[:username].lower.eq(arel_table.lower(str))) }\n+  scope :matches_partially, ->(str) { where(exact: false).where(Arel::Nodes.build_quoted(str).matches(Arel::Nodes.build_quoted('%').concat(arel_table[:username]).concat(Arel::Nodes.build_quoted('%')))) }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2224928716",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "app/models/username_block.rb",
        "discussion_id": "2224928716",
        "commented_code": "@@ -0,0 +1,41 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: username_blocks\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  allow_with_approval :boolean          default(FALSE), not null\n+#  exact               :boolean          default(FALSE), not null\n+#  username            :string           not null\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#\n+\n+class UsernameBlock < ApplicationRecord\n+  HOMOGLYPHS = {\n+    '1' => 'i',\n+    '2' => 'z',\n+    '3' => 'e',\n+    '4' => 'a',\n+    '5' => 's',\n+    '7' => 't',\n+    '8' => 'b',\n+    '9' => 'g',\n+    '0' => 'o',\n+  }.freeze\n+\n+  validates :username, presence: true, uniqueness: true\n+\n+  scope :matches_exactly, ->(str) { where(exact: true).where(arel_table[:username].lower.eq(arel_table.lower(str))) }\n+  scope :matches_partially, ->(str) { where(exact: false).where(Arel::Nodes.build_quoted(str).matches(Arel::Nodes.build_quoted('%').concat(arel_table[:username]).concat(Arel::Nodes.build_quoted('%')))) }",
        "comment_created_at": "2025-07-23T09:13:34+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I wonder if we wouldn't be better off using raw SQL here:\r\n```suggestion\r\n  scope :matches_partially, ->(str) { where(exact: false).where(\"'%' || username || '%'\") }\r\n```\r\n\r\nI'm also slightly worried about the performance implications: if the table of blocked usernames grows big, looking up with partial matches is going to be increasingly expensive, as it will require going through the whole table. Unfortunately, I do not have any suggestion how to improve that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224968053",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "app/models/username_block.rb",
        "discussion_id": "2224928716",
        "commented_code": "@@ -0,0 +1,41 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: username_blocks\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  allow_with_approval :boolean          default(FALSE), not null\n+#  exact               :boolean          default(FALSE), not null\n+#  username            :string           not null\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#\n+\n+class UsernameBlock < ApplicationRecord\n+  HOMOGLYPHS = {\n+    '1' => 'i',\n+    '2' => 'z',\n+    '3' => 'e',\n+    '4' => 'a',\n+    '5' => 's',\n+    '7' => 't',\n+    '8' => 'b',\n+    '9' => 'g',\n+    '0' => 'o',\n+  }.freeze\n+\n+  validates :username, presence: true, uniqueness: true\n+\n+  scope :matches_exactly, ->(str) { where(exact: true).where(arel_table[:username].lower.eq(arel_table.lower(str))) }\n+  scope :matches_partially, ->(str) { where(exact: false).where(Arel::Nodes.build_quoted(str).matches(Arel::Nodes.build_quoted('%').concat(arel_table[:username]).concat(Arel::Nodes.build_quoted('%')))) }",
        "comment_created_at": "2025-07-23T09:29:56+00:00",
        "comment_author": "Gargron",
        "comment_body": "Another alternative is fetching all partial words from the table and building a regex from them, this is what we do for IP blocks. Let me know what you'd prefer. Neither option seems super optimized for very large numbers of blocks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2225502510",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "app/models/username_block.rb",
        "discussion_id": "2224928716",
        "commented_code": "@@ -0,0 +1,41 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: username_blocks\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  allow_with_approval :boolean          default(FALSE), not null\n+#  exact               :boolean          default(FALSE), not null\n+#  username            :string           not null\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#\n+\n+class UsernameBlock < ApplicationRecord\n+  HOMOGLYPHS = {\n+    '1' => 'i',\n+    '2' => 'z',\n+    '3' => 'e',\n+    '4' => 'a',\n+    '5' => 's',\n+    '7' => 't',\n+    '8' => 'b',\n+    '9' => 'g',\n+    '0' => 'o',\n+  }.freeze\n+\n+  validates :username, presence: true, uniqueness: true\n+\n+  scope :matches_exactly, ->(str) { where(exact: true).where(arel_table[:username].lower.eq(arel_table.lower(str))) }\n+  scope :matches_partially, ->(str) { where(exact: false).where(Arel::Nodes.build_quoted(str).matches(Arel::Nodes.build_quoted('%').concat(arel_table[:username]).concat(Arel::Nodes.build_quoted('%')))) }",
        "comment_created_at": "2025-07-23T12:51:12+00:00",
        "comment_author": "mjankowski",
        "comment_body": "I wonder if an easier-to-review and easier-to-merge \"v1\" of this might be to bring over JUST the exact match feature as it currently works, and have the initial change just be the \"settings yaml hash config is migrated to db backed model\" portion? (ie, leave out partial match, homoglyphs, approval allow, etc - and work through that stuff in future PRs)",
        "pr_file_module": null
      },
      {
        "comment_id": "2225923980",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35407,
        "pr_file": "app/models/username_block.rb",
        "discussion_id": "2224928716",
        "commented_code": "@@ -0,0 +1,41 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: username_blocks\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  allow_with_approval :boolean          default(FALSE), not null\n+#  exact               :boolean          default(FALSE), not null\n+#  username            :string           not null\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#\n+\n+class UsernameBlock < ApplicationRecord\n+  HOMOGLYPHS = {\n+    '1' => 'i',\n+    '2' => 'z',\n+    '3' => 'e',\n+    '4' => 'a',\n+    '5' => 's',\n+    '7' => 't',\n+    '8' => 'b',\n+    '9' => 'g',\n+    '0' => 'o',\n+  }.freeze\n+\n+  validates :username, presence: true, uniqueness: true\n+\n+  scope :matches_exactly, ->(str) { where(exact: true).where(arel_table[:username].lower.eq(arel_table.lower(str))) }\n+  scope :matches_partially, ->(str) { where(exact: false).where(Arel::Nodes.build_quoted(str).matches(Arel::Nodes.build_quoted('%').concat(arel_table[:username]).concat(Arel::Nodes.build_quoted('%')))) }",
        "comment_created_at": "2025-07-23T15:16:24+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "@Gargron both would need to go through the whole table\u2026 I guess I'd stick with the current approach for now\r\n\r\n@mjankowski I'm not against that, but it would just move those decisions to later, and my first review pass is already done, so while it would have helped, it's now a bit late.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "985301778",
    "pr_number": 19059,
    "pr_file": "db/schema.rb",
    "created_at": "2022-10-02T21:52:09+00:00",
    "commented_code": "t.index [\"target_account_id\"], name: \"index_follows_on_target_account_id\"\n   end\n \n+  create_table \"group_account_blocks\", force: :cascade do |t|\n+    t.bigint \"account_id\", null: false\n+    t.bigint \"group_id\", null: false\n+    t.datetime \"created_at\", precision: 6, null: false\n+    t.datetime \"updated_at\", precision: 6, null: false\n+    t.index [\"account_id\", \"group_id\"], name: \"index_group_account_blocks_on_account_id_and_group_id\", unique: true\n+    t.index [\"account_id\"], name: \"index_group_account_blocks_on_account_id\"",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "985301778",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 19059,
        "pr_file": "db/schema.rb",
        "discussion_id": "985301778",
        "commented_code": "@@ -478,6 +478,93 @@\n     t.index [\"target_account_id\"], name: \"index_follows_on_target_account_id\"\n   end\n \n+  create_table \"group_account_blocks\", force: :cascade do |t|\n+    t.bigint \"account_id\", null: false\n+    t.bigint \"group_id\", null: false\n+    t.datetime \"created_at\", precision: 6, null: false\n+    t.datetime \"updated_at\", precision: 6, null: false\n+    t.index [\"account_id\", \"group_id\"], name: \"index_group_account_blocks_on_account_id_and_group_id\", unique: true\n+    t.index [\"account_id\"], name: \"index_group_account_blocks_on_account_id\"",
        "comment_created_at": "2022-10-02T21:52:09+00:00",
        "comment_author": "Gargron",
        "comment_body": "I believe this index is not needed, as the index above will be used since it begins with `account_id`",
        "pr_file_module": null
      },
      {
        "comment_id": "987755116",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 19059,
        "pr_file": "db/schema.rb",
        "discussion_id": "985301778",
        "commented_code": "@@ -478,6 +478,93 @@\n     t.index [\"target_account_id\"], name: \"index_follows_on_target_account_id\"\n   end\n \n+  create_table \"group_account_blocks\", force: :cascade do |t|\n+    t.bigint \"account_id\", null: false\n+    t.bigint \"group_id\", null: false\n+    t.datetime \"created_at\", precision: 6, null: false\n+    t.datetime \"updated_at\", precision: 6, null: false\n+    t.index [\"account_id\", \"group_id\"], name: \"index_group_account_blocks_on_account_id_and_group_id\", unique: true\n+    t.index [\"account_id\"], name: \"index_group_account_blocks_on_account_id\"",
        "comment_created_at": "2022-10-05T10:09:11+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Good catch. Fixed!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "880610618",
    "pr_number": 18468,
    "pr_file": "app/lib/activitypub/activity/create.rb",
    "created_at": "2022-05-24T14:46:38+00:00",
    "commented_code": "return false if local_usernames.empty?\n \n-    Account.local.where(username: local_usernames).exists?\n+    scope = Account.local.where(Account.arel_table[:username].lower.in(local_usernames.map(&:downcase)))\n+    scope = scope.where.not('EXISTS (SELECT 1 FROM blocks WHERE account_id = accounts.id AND target_account_id = ?)', @account.id)\n+    scope.exists?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "880610618",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 18468,
        "pr_file": "app/lib/activitypub/activity/create.rb",
        "discussion_id": "880610618",
        "commented_code": "@@ -402,15 +406,17 @@ def addresses_local_accounts?\n \n     return false if local_usernames.empty?\n \n-    Account.local.where(username: local_usernames).exists?\n+    scope = Account.local.where(Account.arel_table[:username].lower.in(local_usernames.map(&:downcase)))\n+    scope = scope.where.not('EXISTS (SELECT 1 FROM blocks WHERE account_id = accounts.id AND target_account_id = ?)', @account.id)\n+    scope.exists?",
        "comment_created_at": "2022-05-24T14:46:38+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "There is a slight (probably pretty much unobservable) overhead to checking for blocks, but the overall query is actually much faster by avoiding a sequential scan (`Account.local.where(username: local_usernames)` did not use the index we have, because the index is on lowered usernames).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1988971968",
    "pr_number": 32615,
    "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
    "created_at": "2025-03-11T10:55:46+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_COOLDOWN_MINUTES = (ENV['FETCH_REPLIES_COOLDOWN_MINUTES'] || 15).to_i.minutes\n+  FETCH_REPLIES_INITIAL_WAIT_MINUTES = (ENV['FETCH_REPLIES_INITIAL_WAIT_MINUTES'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_COOLDOWN_MINUTES.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: [nil, ..FETCH_REPLIES_COOLDOWN_MINUTES.ago]) }\n+\n+    scope :should_not_fetch_replies, -> { local.or(created_recently.or(fetched_recently)) }\n+    scope :should_fetch_replies, -> { remote.merge(not_created_recently).merge(not_fetched_recently) }\n+\n+    # statuses for which we won't receive update or deletion actions,\n+    # and should update when fetching replies\n+    # Status from an account which either\n+    # a) has only remote followers\n+    # b) has local follows that were created after the last update time, or\n+    # c) has no known followers\n+    scope :unsubscribed, lambda {\n+      remote.merge(\n+        Status.left_outer_joins(account: :followers).where.not(followers_accounts: { domain: nil })\n+              .or(where.not('follows.created_at < statuses.updated_at'))\n+              .or(where(follows: { id: nil }))\n+      )\n+    }\n+  end\n+\n+  def should_fetch_replies?\n+    # we aren't brand new, and we haven't fetched replies since the debounce window\n+    FETCH_REPLIES_ENABLED && !local? && created_at <= FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago && (\n+      fetched_replies_at.nil? || fetched_replies_at <= FETCH_REPLIES_COOLDOWN_MINUTES.ago\n+    )\n+  end\n+\n+  def unsubscribed?\n+    return false if local?\n+\n+    Follow.joins(:account).where(\n+      target_account: account.id,\n+      account: { domain: nil },\n+      created_at: ..updated_at\n+    ).count.zero?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1988971968",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 32615,
        "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
        "discussion_id": "1988971968",
        "commented_code": "@@ -0,0 +1,53 @@\n+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_COOLDOWN_MINUTES = (ENV['FETCH_REPLIES_COOLDOWN_MINUTES'] || 15).to_i.minutes\n+  FETCH_REPLIES_INITIAL_WAIT_MINUTES = (ENV['FETCH_REPLIES_INITIAL_WAIT_MINUTES'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_COOLDOWN_MINUTES.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: [nil, ..FETCH_REPLIES_COOLDOWN_MINUTES.ago]) }\n+\n+    scope :should_not_fetch_replies, -> { local.or(created_recently.or(fetched_recently)) }\n+    scope :should_fetch_replies, -> { remote.merge(not_created_recently).merge(not_fetched_recently) }\n+\n+    # statuses for which we won't receive update or deletion actions,\n+    # and should update when fetching replies\n+    # Status from an account which either\n+    # a) has only remote followers\n+    # b) has local follows that were created after the last update time, or\n+    # c) has no known followers\n+    scope :unsubscribed, lambda {\n+      remote.merge(\n+        Status.left_outer_joins(account: :followers).where.not(followers_accounts: { domain: nil })\n+              .or(where.not('follows.created_at < statuses.updated_at'))\n+              .or(where(follows: { id: nil }))\n+      )\n+    }\n+  end\n+\n+  def should_fetch_replies?\n+    # we aren't brand new, and we haven't fetched replies since the debounce window\n+    FETCH_REPLIES_ENABLED && !local? && created_at <= FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago && (\n+      fetched_replies_at.nil? || fetched_replies_at <= FETCH_REPLIES_COOLDOWN_MINUTES.ago\n+    )\n+  end\n+\n+  def unsubscribed?\n+    return false if local?\n+\n+    Follow.joins(:account).where(\n+      target_account: account.id,\n+      account: { domain: nil },\n+      created_at: ..updated_at\n+    ).count.zero?",
        "comment_created_at": "2025-03-11T10:55:46+00:00",
        "comment_author": "Gargron",
        "comment_body": "This could be rewritten with `exists?` without having to perform a `COUNT()`",
        "pr_file_module": null
      },
      {
        "comment_id": "1990193334",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 32615,
        "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
        "discussion_id": "1988971968",
        "commented_code": "@@ -0,0 +1,53 @@\n+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_COOLDOWN_MINUTES = (ENV['FETCH_REPLIES_COOLDOWN_MINUTES'] || 15).to_i.minutes\n+  FETCH_REPLIES_INITIAL_WAIT_MINUTES = (ENV['FETCH_REPLIES_INITIAL_WAIT_MINUTES'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_COOLDOWN_MINUTES.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: [nil, ..FETCH_REPLIES_COOLDOWN_MINUTES.ago]) }\n+\n+    scope :should_not_fetch_replies, -> { local.or(created_recently.or(fetched_recently)) }\n+    scope :should_fetch_replies, -> { remote.merge(not_created_recently).merge(not_fetched_recently) }\n+\n+    # statuses for which we won't receive update or deletion actions,\n+    # and should update when fetching replies\n+    # Status from an account which either\n+    # a) has only remote followers\n+    # b) has local follows that were created after the last update time, or\n+    # c) has no known followers\n+    scope :unsubscribed, lambda {\n+      remote.merge(\n+        Status.left_outer_joins(account: :followers).where.not(followers_accounts: { domain: nil })\n+              .or(where.not('follows.created_at < statuses.updated_at'))\n+              .or(where(follows: { id: nil }))\n+      )\n+    }\n+  end\n+\n+  def should_fetch_replies?\n+    # we aren't brand new, and we haven't fetched replies since the debounce window\n+    FETCH_REPLIES_ENABLED && !local? && created_at <= FETCH_REPLIES_INITIAL_WAIT_MINUTES.ago && (\n+      fetched_replies_at.nil? || fetched_replies_at <= FETCH_REPLIES_COOLDOWN_MINUTES.ago\n+    )\n+  end\n+\n+  def unsubscribed?\n+    return false if local?\n+\n+    Follow.joins(:account).where(\n+      target_account: account.id,\n+      account: { domain: nil },\n+      created_at: ..updated_at\n+    ).count.zero?",
        "comment_created_at": "2025-03-11T22:12:40+00:00",
        "comment_author": "sneakers-the-rat",
        "comment_body": "Done in https://github.com/mastodon/mastodon/pull/32615/commits/f304bbd812e90780b8b6407b0a36cd07913d76dc",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1909111852",
    "pr_number": 33531,
    "pr_file": "app/models/trends/query.rb",
    "created_at": "2025-01-09T16:19:58+00:00",
    "commented_code": "to_arel.to_a\n   end\n \n+  def language_order_for(trend_class)\n+    trend_class\n+      .reorder(nil)",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1909111852",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33531,
        "pr_file": "app/models/trends/query.rb",
        "discussion_id": "1909111852",
        "commented_code": "@@ -94,6 +94,13 @@ def perform_queries\n     to_arel.to_a\n   end\n \n+  def language_order_for(trend_class)\n+    trend_class\n+      .reorder(nil)",
        "comment_created_at": "2025-01-09T16:19:58+00:00",
        "comment_author": "mjankowski",
        "comment_body": "This `reorder(nil)` is needed because all of the initial scope creation starts with `score: :desc` and if we don't remove it, the eventual query does score, then language, then score again - and the results are wrong. Another option here would be to not start the scope with an order, and add the score desc only after this language block is handled.",
        "pr_file_module": null
      },
      {
        "comment_id": "1910078800",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33531,
        "pr_file": "app/models/trends/query.rb",
        "discussion_id": "1909111852",
        "commented_code": "@@ -94,6 +94,13 @@ def perform_queries\n     to_arel.to_a\n   end\n \n+  def language_order_for(trend_class)\n+    trend_class\n+      .reorder(nil)",
        "comment_created_at": "2025-01-10T09:32:50+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I suppose we could do that in a follow-up PR, yeah.",
        "pr_file_module": null
      }
    ]
  }
]