[
  {
    "discussion_id": "2057792952",
    "pr_number": 34528,
    "pr_file": "streaming/database.js",
    "created_at": "2025-04-24T08:02:36+00:00",
    "commented_code": "import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2057792952",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34528,
        "pr_file": "streaming/database.js",
        "discussion_id": "2057792952",
        "commented_code": "@@ -1,107 +1,91 @@\n import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
        "comment_created_at": "2025-04-24T08:02:36+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "This is still a discrepancy with the Ruby handling, isn't it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2057858761",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34528,
        "pr_file": "streaming/database.js",
        "discussion_id": "2057792952",
        "commented_code": "@@ -1,107 +1,91 @@\n import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
        "comment_created_at": "2025-04-24T08:36:50+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "This entire switch is \u2014 basically the environment variables to find the root cert don't exist here (or aren't documented) so there's no way to align with ruby via DB_SSLMODE, because we require the root certificate to actually properly do this.\r\n\r\nDATABASE_URL can encode the path to that root certificate and automatically load it, which enables us to have a checkServerIdentity function ",
        "pr_file_module": null
      },
      {
        "comment_id": "2082768610",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34528,
        "pr_file": "streaming/database.js",
        "discussion_id": "2057792952",
        "commented_code": "@@ -1,107 +1,91 @@\n import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
        "comment_created_at": "2025-05-10T02:33:41+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "We could maybe grab the certificate path from `PGSSLROOTCERT` if set \u2014 it'd still be different, but at least then we'd be able grab it if defined.\r\n\r\nOtherwise we'd need to load from either `PGSSLROOTCERT`, or `~/.postgresql/root.crt` in the user's home directory on unix/mac, or on Microsoft Windows from `%APPDATA%\\postgresql\\root.crt`. (`%APPDATA%` may be [`os.homedir()`](https://nodejs.org/docs/latest/api/os.html#oshomedir) though I'm not sure sure).\r\n\r\nThis is based on https://www.postgresql.org/docs/current/libpq-ssl.html",
        "pr_file_module": null
      },
      {
        "comment_id": "2082770419",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34528,
        "pr_file": "streaming/database.js",
        "discussion_id": "2057792952",
        "commented_code": "@@ -1,107 +1,91 @@\n import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
        "comment_created_at": "2025-05-10T02:40:30+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "If none of those options exist (none are a readable file by the current user) then we would have to abort with an error, but otherwise we could \"discover\" the root certification just like libpq does.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083227645",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34528,
        "pr_file": "streaming/database.js",
        "discussion_id": "2057792952",
        "commented_code": "@@ -1,107 +1,91 @@\n import pg from 'pg';\n-import pgConnectionString from 'pg-connection-string';\n+import { parse, toClientConfig } from 'pg-connection-string';\n \n import { parseIntFromEnvValue } from './utils.js';\n \n /**\n  * @param {NodeJS.ProcessEnv} env the `process.env` value to read configuration from\n  * @param {string} environment\n+ * @param {import('pino').Logger} logger\n  * @returns {pg.PoolConfig} the configuration for the PostgreSQL connection\n  */\n-export function configFromEnv(env, environment) {\n+export function configFromEnv(env, environment, logger) {\n   /** @type {Record<string, pg.PoolConfig>} */\n   const pgConfigs = {\n     development: {\n       user: env.DB_USER || pg.defaults.user,\n       password: env.DB_PASS || pg.defaults.password,\n       database: env.DB_NAME || 'mastodon_development',\n       host: env.DB_HOST || pg.defaults.host,\n-      port: parseIntFromEnvValue(env.DB_PORT, pg.defaults.port ?? 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(\n+        env.DB_PORT,\n+        pg.defaults.port ?? 5432,\n+        'DB_PORT',\n+      ),\n     },\n \n     production: {\n       user: env.DB_USER || 'mastodon',\n       password: env.DB_PASS || '',\n       database: env.DB_NAME || 'mastodon_production',\n       host: env.DB_HOST || 'localhost',\n-      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT')\n+      port: parseIntFromEnvValue(env.DB_PORT, 5432, 'DB_PORT'),\n     },\n   };\n \n   /**\n    * @type {pg.PoolConfig}\n    */\n-  let baseConfig = {};\n+  let config = {};\n \n   if (env.DATABASE_URL) {\n-    const parsedUrl = pgConnectionString.parse(env.DATABASE_URL);\n-\n-    // The result of dbUrlToConfig from pg-connection-string is not type\n-    // compatible with pg.PoolConfig, since parts of the connection URL may be\n-    // `null` when pg.PoolConfig expects `undefined`, as such we have to\n-    // manually create the baseConfig object from the properties of the\n-    // parsedUrl.\n-    //\n-    // For more information see:\n-    // https://github.com/brianc/node-postgres/issues/2280\n-    //\n-    // FIXME: clean up once brianc/node-postgres#3128 lands\n-    if (typeof parsedUrl.password === 'string') baseConfig.password = parsedUrl.password;\n-    if (typeof parsedUrl.host === 'string') baseConfig.host = parsedUrl.host;\n-    if (typeof parsedUrl.user === 'string') baseConfig.user = parsedUrl.user;\n-    if (typeof parsedUrl.port === 'string' && parsedUrl.port) {\n-      const parsedPort = parseInt(parsedUrl.port, 10);\n-      if (isNaN(parsedPort)) {\n-        throw new Error('Invalid port specified in DATABASE_URL environment variable');\n-      }\n-      baseConfig.port = parsedPort;\n-    }\n-    if (typeof parsedUrl.database === 'string') baseConfig.database = parsedUrl.database;\n-    if (typeof parsedUrl.options === 'string') baseConfig.options = parsedUrl.options;\n-\n-    // The pg-connection-string type definition isn't correct, as parsedUrl.ssl\n-    // can absolutely be an Object, this is to work around these incorrect\n-    // types, including the casting of parsedUrl.ssl to Record<string, any>\n-    if (typeof parsedUrl.ssl === 'boolean') {\n-      baseConfig.ssl = parsedUrl.ssl;\n-    } else if (typeof parsedUrl.ssl === 'object' && !Array.isArray(parsedUrl.ssl) && parsedUrl.ssl !== null) {\n-      /** @type {Record<string, any>} */\n-      const sslOptions = parsedUrl.ssl;\n-      baseConfig.ssl = {};\n-\n-      baseConfig.ssl.cert = sslOptions.cert;\n-      baseConfig.ssl.key = sslOptions.key;\n-      baseConfig.ssl.ca = sslOptions.ca;\n-      baseConfig.ssl.rejectUnauthorized = sslOptions.rejectUnauthorized;\n+    // parse will throw if both useLibpqCompat option is true and the\n+    // DATABASE_URL includes uselibpqcompat, so we're handling that case ahead\n+    // of time to give a more specific error message:\n+    if (env.DATABASE_URL.includes('uselibpqcompat')) {\n+      throw new Error(\n+        'SECURITY WARNING: Mastodon forces uselibpqcompat mode, do not include it in DATABASE_URL',\n+      );\n     }\n \n-    // Support overriding the database password in the connection URL\n-    if (!baseConfig.password && env.DB_PASS) {\n-      baseConfig.password = env.DB_PASS;\n-    }\n+    config = toClientConfig(parse(env.DATABASE_URL, { useLibpqCompat: true }));\n   } else if (Object.hasOwn(pgConfigs, environment)) {\n-    baseConfig = pgConfigs[environment];\n+    config = pgConfigs[environment];\n \n     if (env.DB_SSLMODE) {\n-      switch(env.DB_SSLMODE) {\n-      case 'disable':\n-      case '':\n-        baseConfig.ssl = false;\n-        break;\n-      case 'no-verify':\n-        baseConfig.ssl = { rejectUnauthorized: false };\n-        break;\n-      default:\n-        baseConfig.ssl = {};\n-        break;\n+      logger.warn(\n+        'Using DB_SSLMODE is not recommended, instead use DATABASE_URL with SSL options',\n+      );\n+\n+      switch (env.DB_SSLMODE) {\n+        case 'disable': {\n+          config.ssl = false;\n+          break;\n+        }\n+        case 'prefer': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }\n+        case 'require': {\n+          config.ssl.rejectUnauthorized = false;\n+          break;\n+        }",
        "comment_created_at": "2025-05-10T16:01:25+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "Yeah, so my understanding above was correct, here's the function in libpq that's called if `PGSSLROOTCERT` is not defined, to discover the default path of `~/.postgresql/` or `%APPDATA%\\postgresql\\`:\r\n\r\nhttps://github.com/postgres/postgres/blob/master/src/interfaces/libpq/fe-connect.c#L8123-L8175\r\n\r\nAnd then where it's called to load up the root certificate:\r\n\r\nhttps://github.com/postgres/postgres/blob/master/src/interfaces/libpq/fe-secure-openssl.c#L866-L969\r\n\r\n**Essentially let `rootCert` be `PGSSLROOTCERT` if defined, else construct a path to `/.postgresql/root.crt` relative to the home directory or `\\postgresql\\root.crt` relative to `%APPDATA%` (dependent on operating system)**\r\n\r\nFrom what I can tell `%APPDATA%` may have a few different locations, and there's no node.js API to resolve this as it's a C call to [`SHGetKnownFolderPath`](https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath) (as of windows vista). I have had someone suggest that there may be a `process.env.APPDATA` or `process.env.APP_DATA` value on windows, but I cannot verify this as I don't have a windows computer nor can I get a windows developer VM to test in (they've been unavailable on the microsoft website \"temporarily\" for the past 6 months)\r\n\r\nIf `rootCert` is `\"system\"` then that triggers using all of openssl's root certificate logic.\r\n\r\nElse, if `rootCert` has a value, do a `stats` syscall on `rootCert` and if it exists and is readable (I think the `stats` syscall returns non-zero if it's unreadable by the current user), then load that certificate via [`SSL_CTX_load_verify_locations`](https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/).\r\n\r\nNode.js's crypto internals for tls do certificate loading slightly differently because they requiring loading the certifcate as a buffer from the filesystem first, before adding the buffer as a root cert if it's a valid certificate. But for all intents and purposes, I think these would be equivalent.\r\n\r\nSo if we just do the part in bold above, then we would have parity with libpq entirely, beyond what `pg-connection-string` offers with regards to compatibility when using just `DB_SSLMODE` without specifying a root certificate some how.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077854902",
    "pr_number": 34450,
    "pr_file": "babel.config.js",
    "created_at": "2025-05-07T15:03:05+00:00",
    "commented_code": "-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2077854902",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "babel.config.js",
        "discussion_id": "2077854902",
        "commented_code": "@@ -1,80 +0,0 @@\n-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
        "comment_created_at": "2025-05-07T15:03:05+00:00",
        "comment_author": "renchap",
        "comment_body": "I did not check, but iirc there was a reason for those to be here so old browsers do not choke on those syntaxes. Maybe its no longer needed with Vite, but I remember that we had to add those explicitely to have babel transform those features.",
        "pr_file_module": null
      },
      {
        "comment_id": "2081355883",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "babel.config.js",
        "discussion_id": "2077854902",
        "commented_code": "@@ -1,80 +0,0 @@\n-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
        "comment_created_at": "2025-05-09T09:59:31+00:00",
        "comment_author": "ChaosExAnima",
        "comment_body": "i checked the output, and it looks like Vite rewrites the numbers by default, so this:\r\n```ts\r\nconst TEST = 100_000_000;\r\nconst TEST2 = 1_0;\r\n```\r\nbecomes:\r\n```js\r\nconst T=1e8;\r\nconst T2=10;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2081441605",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "babel.config.js",
        "discussion_id": "2077854902",
        "commented_code": "@@ -1,80 +0,0 @@\n-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
        "comment_created_at": "2025-05-09T10:57:29+00:00",
        "comment_author": "renchap",
        "comment_body": "Ok, can you check for the other ones as well? I remember that we had issues because the nullish coalescing operator (`??`) was not properly transpiled in some browsers.\r\n\r\nBut if this is no longer the case, then maybe it means we need to update our `browserlistrc` to include those browsers rather than manually picking things to transpile?",
        "pr_file_module": null
      },
      {
        "comment_id": "2081554361",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "babel.config.js",
        "discussion_id": "2077854902",
        "commented_code": "@@ -1,80 +0,0 @@\n-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
        "comment_created_at": "2025-05-09T12:20:46+00:00",
        "comment_author": "ChaosExAnima",
        "comment_body": "that seems untouched. if we want to support this, we should update our `browserlistrc` as all the things mentioned in this config have been supported for a while:\r\n\r\n* https://caniuse.com/mdn-javascript_operators_nullish_coalescing\r\n* https://caniuse.com/mdn-javascript_operators_optional_chaining\r\n* https://caniuse.com/mdn-javascript_classes_private_class_methods\r\n\r\nunless we we want to support IE11 i think it's fine to drop these.",
        "pr_file_module": null
      },
      {
        "comment_id": "2081753457",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34450,
        "pr_file": "babel.config.js",
        "discussion_id": "2077854902",
        "commented_code": "@@ -1,80 +0,0 @@\n-module.exports = (api) => {\n-  const env = api.env();\n-\n-  const reactOptions = {\n-    development: false,\n-    runtime: 'automatic',\n-  };\n-\n-  const envOptions = {\n-    useBuiltIns: \"usage\",\n-    corejs: { version: \"3.30\" },\n-    debug: false,\n-    include: [\n-      'transform-numeric-separator',",
        "comment_created_at": "2025-05-09T13:58:09+00:00",
        "comment_author": "renchap",
        "comment_body": "Ok I looked back at the git history, and those were here because webpack or the minifier did not understood those syntaxes, so we needed to transpile them.\r\n\r\nNow its all supported by Vite, so we can drop those plugins.",
        "pr_file_module": null
      }
    ]
  }
]