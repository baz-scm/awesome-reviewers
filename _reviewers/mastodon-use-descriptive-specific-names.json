[
  {
    "discussion_id": "2230543839",
    "pr_number": 35355,
    "pr_file": "app/lib/activitypub/case_transform.rb",
    "created_at": "2025-07-25T08:49:49+00:00",
    "commented_code": "when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2230543839",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T08:49:49+00:00",
        "comment_author": "oneiros",
        "comment_body": "I am lacking a lot of context here, but on the surface this seems like a breaking change. Are values starting with an underscore already guaranteed to be properly \"camelized\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "2230694223",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T09:59:53+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "We have only briefly used values starting with `_:` and stopped doing so years ago, so the `value.start_with?('_:')` case would actually never occur afaik.\r\n\r\nAs for values starting with `_`, we currently have none, and would start using `_misskey_quote`, which needs to *not* be camelized.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230707931",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T10:06:58+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "For context, this was added in #4585 for the `_:locked` attribute, which was dropped in #4767, and then renamed in #4779.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230729787",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T10:19:06+00:00",
        "comment_author": "oneiros",
        "comment_body": "Thanks for the context. That is really interesting.\r\n\r\nIf this is only an exception for `_misskey_quote`, would it maybe make sense to make this explicit here? Not camelizing anything that starts with an underscore seems a bit broad to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230823919",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T11:12:14+00:00",
        "comment_author": "oneiros",
        "comment_body": "(Also I guess `value.start_with?('_misskey')` would work if this is a recurring pattern for \"private\" properties from misskey.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2230931512",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35355,
        "pr_file": "app/lib/activitypub/case_transform.rb",
        "discussion_id": "2230543839",
        "commented_code": "@@ -12,9 +12,7 @@ def camel_lower(value)\n       when Hash then value.deep_transform_keys! { |key| camel_lower(key) }\n       when Symbol then camel_lower(value.to_s).to_sym\n       when String\n-        camel_lower_cache[value] ||= if value.start_with?('_:')\n-                                       \"_:#{value.delete_prefix('_:').underscore.camelize(:lower)}\"\n-                                     elsif LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)\n+        camel_lower_cache[value] ||= if value.start_with?('_') || LanguagesHelper::ISO_639_1_REGIONAL.key?(value.to_sym)",
        "comment_created_at": "2025-07-25T12:12:10+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Ok, why not, changed it to `start_with?('_misskey')`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2048803927",
    "pr_number": 34415,
    "pr_file": "app/models/fasp/subscription.rb",
    "created_at": "2025-04-17T12:02:59+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: fasp_subscriptions\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  category            :string           not null\n+#  max_batch_size      :integer          not null\n+#  subscription_type   :string           not null\n+#  threshold_likes     :integer\n+#  threshold_replies   :integer\n+#  threshold_shares    :integer\n+#  threshold_timeframe :integer\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#  fasp_provider_id    :bigint(8)        not null\n+#\n+class Fasp::Subscription < ApplicationRecord\n+  TYPES = %w(lifecycle trends).freeze\n+\n+  belongs_to :fasp_provider, class_name: 'Fasp::Provider'\n+\n+  validates :category, presence: true, inclusion: Fasp::DATA_CATEGORIES\n+  validates :subscription_type, presence: true,\n+                                inclusion: TYPES\n+\n+  scope :content, -> { where(category: 'content') }\n+  scope :account, -> { where(category: 'account') }\n+  scope :lifecycle, -> { where(subscription_type: 'lifecycle') }\n+  scope :trends, -> { where(subscription_type: 'trends') }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2048803927",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34415,
        "pr_file": "app/models/fasp/subscription.rb",
        "discussion_id": "2048803927",
        "commented_code": "@@ -0,0 +1,43 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: fasp_subscriptions\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  category            :string           not null\n+#  max_batch_size      :integer          not null\n+#  subscription_type   :string           not null\n+#  threshold_likes     :integer\n+#  threshold_replies   :integer\n+#  threshold_shares    :integer\n+#  threshold_timeframe :integer\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#  fasp_provider_id    :bigint(8)        not null\n+#\n+class Fasp::Subscription < ApplicationRecord\n+  TYPES = %w(lifecycle trends).freeze\n+\n+  belongs_to :fasp_provider, class_name: 'Fasp::Provider'\n+\n+  validates :category, presence: true, inclusion: Fasp::DATA_CATEGORIES\n+  validates :subscription_type, presence: true,\n+                                inclusion: TYPES\n+\n+  scope :content, -> { where(category: 'content') }\n+  scope :account, -> { where(category: 'account') }\n+  scope :lifecycle, -> { where(subscription_type: 'lifecycle') }\n+  scope :trends, -> { where(subscription_type: 'trends') }",
        "comment_created_at": "2025-04-17T12:02:59+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Maybe those scopes could use some renaming. `Fasp::Subscription.account` was a bit confusing, as on first read I did not think this was a scope, but an Account attribute.",
        "pr_file_module": null
      },
      {
        "comment_id": "2071667333",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34415,
        "pr_file": "app/models/fasp/subscription.rb",
        "discussion_id": "2048803927",
        "commented_code": "@@ -0,0 +1,43 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: fasp_subscriptions\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  category            :string           not null\n+#  max_batch_size      :integer          not null\n+#  subscription_type   :string           not null\n+#  threshold_likes     :integer\n+#  threshold_replies   :integer\n+#  threshold_shares    :integer\n+#  threshold_timeframe :integer\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#  fasp_provider_id    :bigint(8)        not null\n+#\n+class Fasp::Subscription < ApplicationRecord\n+  TYPES = %w(lifecycle trends).freeze\n+\n+  belongs_to :fasp_provider, class_name: 'Fasp::Provider'\n+\n+  validates :category, presence: true, inclusion: Fasp::DATA_CATEGORIES\n+  validates :subscription_type, presence: true,\n+                                inclusion: TYPES\n+\n+  scope :content, -> { where(category: 'content') }\n+  scope :account, -> { where(category: 'account') }\n+  scope :lifecycle, -> { where(subscription_type: 'lifecycle') }\n+  scope :trends, -> { where(subscription_type: 'trends') }",
        "comment_created_at": "2025-05-02T14:07:08+00:00",
        "comment_author": "oneiros",
        "comment_body": "As this is a method on the class I had not thought about this potential for confusion.\r\n\r\nHow about `Fasp::Subscription.to_accounts` and `Fasp::Subscription.to_content`? Or rather `Fasp::Subscription.category_account` and `Fasp::Subscription.category_content`?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2084661447",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34415,
        "pr_file": "app/models/fasp/subscription.rb",
        "discussion_id": "2048803927",
        "commented_code": "@@ -0,0 +1,43 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: fasp_subscriptions\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  category            :string           not null\n+#  max_batch_size      :integer          not null\n+#  subscription_type   :string           not null\n+#  threshold_likes     :integer\n+#  threshold_replies   :integer\n+#  threshold_shares    :integer\n+#  threshold_timeframe :integer\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#  fasp_provider_id    :bigint(8)        not null\n+#\n+class Fasp::Subscription < ApplicationRecord\n+  TYPES = %w(lifecycle trends).freeze\n+\n+  belongs_to :fasp_provider, class_name: 'Fasp::Provider'\n+\n+  validates :category, presence: true, inclusion: Fasp::DATA_CATEGORIES\n+  validates :subscription_type, presence: true,\n+                                inclusion: TYPES\n+\n+  scope :content, -> { where(category: 'content') }\n+  scope :account, -> { where(category: 'account') }\n+  scope :lifecycle, -> { where(subscription_type: 'lifecycle') }\n+  scope :trends, -> { where(subscription_type: 'trends') }",
        "comment_created_at": "2025-05-12T13:19:48+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I think `category_account` and `category_content` are ever so slightly less confusing. But I don't have any better suggestion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2092610420",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34415,
        "pr_file": "app/models/fasp/subscription.rb",
        "discussion_id": "2048803927",
        "commented_code": "@@ -0,0 +1,43 @@\n+# frozen_string_literal: true\n+\n+# == Schema Information\n+#\n+# Table name: fasp_subscriptions\n+#\n+#  id                  :bigint(8)        not null, primary key\n+#  category            :string           not null\n+#  max_batch_size      :integer          not null\n+#  subscription_type   :string           not null\n+#  threshold_likes     :integer\n+#  threshold_replies   :integer\n+#  threshold_shares    :integer\n+#  threshold_timeframe :integer\n+#  created_at          :datetime         not null\n+#  updated_at          :datetime         not null\n+#  fasp_provider_id    :bigint(8)        not null\n+#\n+class Fasp::Subscription < ApplicationRecord\n+  TYPES = %w(lifecycle trends).freeze\n+\n+  belongs_to :fasp_provider, class_name: 'Fasp::Provider'\n+\n+  validates :category, presence: true, inclusion: Fasp::DATA_CATEGORIES\n+  validates :subscription_type, presence: true,\n+                                inclusion: TYPES\n+\n+  scope :content, -> { where(category: 'content') }\n+  scope :account, -> { where(category: 'account') }\n+  scope :lifecycle, -> { where(subscription_type: 'lifecycle') }\n+  scope :trends, -> { where(subscription_type: 'trends') }",
        "comment_created_at": "2025-05-16T08:41:54+00:00",
        "comment_author": "oneiros",
        "comment_body": "OK. I renamed the scopes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161512406",
    "pr_number": 35098,
    "pr_file": "app/models/rule_translation.rb",
    "created_at": "2025-06-23T12:32:18+00:00",
    "commented_code": "validates :language, presence: true, uniqueness: { scope: :rule_id }\n   validates :text, presence: true, length: { maximum: Rule::TEXT_SIZE_LIMIT }\n+\n+  scope :for_locale, ->(locale) { where(language: I18n::Locale::Tag.tag(locale).to_a.first) }\n+  scope :by_language, -> { order(language_length.desc) }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2161512406",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35098,
        "pr_file": "app/models/rule_translation.rb",
        "discussion_id": "2161512406",
        "commented_code": "@@ -17,4 +17,13 @@ class RuleTranslation < ApplicationRecord\n \n   validates :language, presence: true, uniqueness: { scope: :rule_id }\n   validates :text, presence: true, length: { maximum: Rule::TEXT_SIZE_LIMIT }\n+\n+  scope :for_locale, ->(locale) { where(language: I18n::Locale::Tag.tag(locale).to_a.first) }\n+  scope :by_language, -> { order(language_length.desc) }",
        "comment_created_at": "2025-06-23T12:32:18+00:00",
        "comment_author": "oneiros",
        "comment_body": "I would not expect `::by_language` to sort by the length of the locale name. I do not really have a better name for this scope, but if we cannot come up with one, we could maybe call it `::by_language_length`? Just to make it clear that this is not the most commonplace way to sort things.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161538652",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 35098,
        "pr_file": "app/models/rule_translation.rb",
        "discussion_id": "2161512406",
        "commented_code": "@@ -17,4 +17,13 @@ class RuleTranslation < ApplicationRecord\n \n   validates :language, presence: true, uniqueness: { scope: :rule_id }\n   validates :text, presence: true, length: { maximum: Rule::TEXT_SIZE_LIMIT }\n+\n+  scope :for_locale, ->(locale) { where(language: I18n::Locale::Tag.tag(locale).to_a.first) }\n+  scope :by_language, -> { order(language_length.desc) }",
        "comment_created_at": "2025-06-23T12:46:11+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Updated to use `by_language_length`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066721381",
    "pr_number": 34576,
    "pr_file": "app/serializers/rest/instance_serializer.rb",
    "created_at": "2025-04-29T14:37:57+00:00",
    "commented_code": "translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "2066721381",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34576,
        "pr_file": "app/serializers/rest/instance_serializer.rb",
        "discussion_id": "2066721381",
        "commented_code": "@@ -99,6 +99,8 @@ def configuration\n       translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
        "comment_created_at": "2025-04-29T14:37:57+00:00",
        "comment_author": "oneiros",
        "comment_body": "Any reason not to call this `limited_federation`? I feel like I have never seen the term `closed_federation` and it also does not describe the situation very well imho (as such servers can and probably will federate at least with some servers).",
        "pr_file_module": null
      },
      {
        "comment_id": "2066723306",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34576,
        "pr_file": "app/serializers/rest/instance_serializer.rb",
        "discussion_id": "2066721381",
        "commented_code": "@@ -99,6 +99,8 @@ def configuration\n       translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
        "comment_created_at": "2025-04-29T14:38:44+00:00",
        "comment_author": "Gargron",
        "comment_body": "I would suggest `silo` as well...",
        "pr_file_module": null
      },
      {
        "comment_id": "2066744543",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34576,
        "pr_file": "app/serializers/rest/instance_serializer.rb",
        "discussion_id": "2066721381",
        "commented_code": "@@ -99,6 +99,8 @@ def configuration\n       translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
        "comment_created_at": "2025-04-29T14:49:29+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "I chose \u201cclosed federation\u201d in opposition of \u201copen federation\u201d, but I have no strong feeling. I also considered `limited_federation` and `allowlist_federation` (possibly the most descriptive one here).",
        "pr_file_module": null
      },
      {
        "comment_id": "2075886369",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34576,
        "pr_file": "app/serializers/rest/instance_serializer.rb",
        "discussion_id": "2066721381",
        "commented_code": "@@ -99,6 +99,8 @@ def configuration\n       translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
        "comment_created_at": "2025-05-06T16:43:29+00:00",
        "comment_author": "renchap",
        "comment_body": "I would use either `limited_federation` (consistency with the docs / config variable), or `restricted_federation`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2077484283",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 34576,
        "pr_file": "app/serializers/rest/instance_serializer.rb",
        "discussion_id": "2066721381",
        "commented_code": "@@ -99,6 +99,8 @@ def configuration\n       translation: {\n         enabled: TranslationService.configured?,\n       },\n+\n+      closed_federation: limited_federation?,",
        "comment_created_at": "2025-05-07T12:10:42+00:00",
        "comment_author": "ClearlyClaire",
        "comment_body": "Changed to `limited_federation`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1758847481",
    "pr_number": 31804,
    "pr_file": "app/mailers/application_mailer.rb",
    "created_at": "2024-09-13T13:13:13+00:00",
    "commented_code": "protected\n \n-  def locale_for_account(account, &block)\n-    I18n.with_locale(account.user_locale || I18n.default_locale, &block)\n+  def with_user(user, &block)",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1758847481",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31804,
        "pr_file": "app/mailers/application_mailer.rb",
        "discussion_id": "1758847481",
        "commented_code": "@@ -11,8 +11,10 @@ class ApplicationMailer < ActionMailer::Base\n \n   protected\n \n-  def locale_for_account(account, &block)\n-    I18n.with_locale(account.user_locale || I18n.default_locale, &block)\n+  def with_user(user, &block)",
        "comment_created_at": "2024-09-13T13:13:13+00:00",
        "comment_author": "mjankowski",
        "comment_body": "Maybe `with_user_settings` or `user_preferences..` or something to capture that it's about something the user selected and not just to them? Minor thing...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1741145277",
    "pr_number": 31706,
    "pr_file": "app/models/report.rb",
    "created_at": "2024-09-02T17:27:51+00:00",
    "commented_code": "Rule.with_discarded.where(id: rule_ids)\n   end\n \n+  def can_forward?",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1741145277",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31706,
        "pr_file": "app/models/report.rb",
        "discussion_id": "1741145277",
        "commented_code": "@@ -99,6 +102,10 @@ def rules\n     Rule.with_discarded.where(id: rule_ids)\n   end\n \n+  def can_forward?",
        "comment_created_at": "2024-09-02T17:27:51+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "```suggestion\r\n  def forwardable?\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1742700709",
    "pr_number": 31706,
    "pr_file": "app/services/report_forwarding_service.rb",
    "created_at": "2024-09-03T21:15:58+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class ReportForwardingService < BaseService\n+  include Payloadable\n+\n+  def call(report, forwarder, options = {})",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1742700709",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 31706,
        "pr_file": "app/services/report_forwarding_service.rb",
        "discussion_id": "1742700709",
        "commented_code": "@@ -0,0 +1,60 @@\n+# frozen_string_literal: true\n+\n+class ReportForwardingService < BaseService\n+  include Payloadable\n+\n+  def call(report, forwarder, options = {})",
        "comment_created_at": "2024-09-03T21:15:58+00:00",
        "comment_author": "ThisIsMissEm",
        "comment_body": "Arguably we could change this signature to:\r\n```suggestion\r\n  def call(report, forwarder, forward_to_domains = [])\r\n```\r\n\r\nThe options usage is just from moving code across from ReportService",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1845593064",
    "pr_number": 32615,
    "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
    "created_at": "2024-11-17T19:35:53+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_DEBOUNCE = (ENV['FETCH_REPLIES_DEBOUNCE'] || 15).to_i.minutes\n+  CREATED_RECENTLY_DEBOUNCE = (ENV['FETCH_REPLIES_CREATED_RECENTLY'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: CREATED_RECENTLY_DEBOUNCE.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..CREATED_RECENTLY_DEBOUNCE.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_DEBOUNCE.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: ..FETCH_REPLIES_DEBOUNCE.ago).or(where(fetched_replies_at: nil)) }\n+\n+    scope :shouldnt_fetch_replies, -> { local.merge(created_recently).merge(fetched_recently) }",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1845593064",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 32615,
        "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
        "discussion_id": "1845593064",
        "commented_code": "@@ -0,0 +1,29 @@\n+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_DEBOUNCE = (ENV['FETCH_REPLIES_DEBOUNCE'] || 15).to_i.minutes\n+  CREATED_RECENTLY_DEBOUNCE = (ENV['FETCH_REPLIES_CREATED_RECENTLY'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: CREATED_RECENTLY_DEBOUNCE.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..CREATED_RECENTLY_DEBOUNCE.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_DEBOUNCE.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: ..FETCH_REPLIES_DEBOUNCE.ago).or(where(fetched_replies_at: nil)) }\n+\n+    scope :shouldnt_fetch_replies, -> { local.merge(created_recently).merge(fetched_recently) }",
        "comment_created_at": "2024-11-17T19:35:53+00:00",
        "comment_author": "kouhaidev",
        "comment_body": "```suggestion\r\n    scope :should_not_fetch_replies, -> { local.merge(created_recently).merge(fetched_recently) }\r\n```\r\n\r\nfor clarity, slightly more standard name",
        "pr_file_module": null
      },
      {
        "comment_id": "1855652238",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 32615,
        "pr_file": "app/models/concerns/status/fetch_replies_concern.rb",
        "discussion_id": "1845593064",
        "commented_code": "@@ -0,0 +1,29 @@\n+# frozen_string_literal: true\n+\n+module Status::FetchRepliesConcern\n+  extend ActiveSupport::Concern\n+\n+  # enable/disable fetching all replies\n+  FETCH_REPLIES_ENABLED = ENV.key?('FETCH_REPLIES_ENABLED') ? ENV['FETCH_REPLIES_ENABLED'] == 'true' : true\n+\n+  # debounce fetching all replies to minimize DoS\n+  FETCH_REPLIES_DEBOUNCE = (ENV['FETCH_REPLIES_DEBOUNCE'] || 15).to_i.minutes\n+  CREATED_RECENTLY_DEBOUNCE = (ENV['FETCH_REPLIES_CREATED_RECENTLY'] || 5).to_i.minutes\n+\n+  included do\n+    scope :created_recently, -> { where(created_at: CREATED_RECENTLY_DEBOUNCE.ago..) }\n+    scope :not_created_recently, -> { where(created_at: ..CREATED_RECENTLY_DEBOUNCE.ago) }\n+    scope :fetched_recently, -> { where(fetched_replies_at: FETCH_REPLIES_DEBOUNCE.ago..) }\n+    scope :not_fetched_recently, -> { where(fetched_replies_at: ..FETCH_REPLIES_DEBOUNCE.ago).or(where(fetched_replies_at: nil)) }\n+\n+    scope :shouldnt_fetch_replies, -> { local.merge(created_recently).merge(fetched_recently) }",
        "comment_created_at": "2024-11-25T01:00:54+00:00",
        "comment_author": "sneakers-the-rat",
        "comment_body": "making a separate co-authored commit bc also need to change name in the service https://github.com/mastodon/mastodon/pull/32615/commits/cd4dde36be7ad4c663932973b34f961a56614d09",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1908788372",
    "pr_number": 33271,
    "pr_file": "app/controllers/api/v2/notifications_controller.rb",
    "created_at": "2025-01-09T13:21:01+00:00",
    "commented_code": "return [] if @notifications.empty?\n \n     MastodonOTELTracer.in_span('Api::V2::NotificationsController#load_grouped_notifications') do\n-      NotificationGroup.from_notifications(@notifications, pagination_range: (@notifications.last.id)..(@notifications.first.id), grouped_types: params[:grouped_types])\n+      pagination_range = (@notifications.last.id)..@notifications.first.id\n+\n+      if @notifications.size < limit_param(DEFAULT_NOTIFICATIONS_LIMIT)\n+        if params[:min_id].present?\n+          pagination_range = @notifications.last.id...(params[:max_id]&.to_i)\n+        else\n+          range_start = params[:since_id]&.to_i\n+          range_start += 1 unless range_start.nil?\n+          pagination_range = range_start..(@notifications.first.id)\n+        end\n+      end",
    "repo_full_name": "mastodon/mastodon",
    "discussion_comments": [
      {
        "comment_id": "1908788372",
        "repo_full_name": "mastodon/mastodon",
        "pr_number": 33271,
        "pr_file": "app/controllers/api/v2/notifications_controller.rb",
        "discussion_id": "1908788372",
        "commented_code": "@@ -80,7 +80,19 @@ def load_grouped_notifications\n     return [] if @notifications.empty?\n \n     MastodonOTELTracer.in_span('Api::V2::NotificationsController#load_grouped_notifications') do\n-      NotificationGroup.from_notifications(@notifications, pagination_range: (@notifications.last.id)..(@notifications.first.id), grouped_types: params[:grouped_types])\n+      pagination_range = (@notifications.last.id)..@notifications.first.id\n+\n+      if @notifications.size < limit_param(DEFAULT_NOTIFICATIONS_LIMIT)\n+        if params[:min_id].present?\n+          pagination_range = @notifications.last.id...(params[:max_id]&.to_i)\n+        else\n+          range_start = params[:since_id]&.to_i\n+          range_start += 1 unless range_start.nil?\n+          pagination_range = range_start..(@notifications.first.id)\n+        end\n+      end",
        "comment_created_at": "2025-01-09T13:21:01+00:00",
        "comment_author": "oneiros",
        "comment_body": "I found this to be really hard to follow. A little thing that might have helped me would have been to extract the conditions into helper methods that are named in a way that makes it clearer what cases these are.\r\n\r\nSo something like:\r\n\r\n```ruby\r\nif last_page?\r\n  if paginating_down?\r\n    # ...\r\n  elsif paginating_up?\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\n(I am not totally sure the naming makes sense, but I hope you get my meaning.)",
        "pr_file_module": null
      }
    ]
  }
]