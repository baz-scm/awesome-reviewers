[
  {
    "discussion_id": "1770436230",
    "pr_number": 43318,
    "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
    "created_at": "2024-09-22T10:14:35+00:00",
    "commented_code": "return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   show: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  // In theory this should not happen anymore.\n+  // in some cases the container and previous element still\n+  // could end up being the same, in this case we just go up 1\n+  if (current === previousElement) {\n+    current = current.parentElement;\n+  }\n \n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, show);\n+  while (!!current && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any of the ancestors have aria-hidden applied (e.g. by another Modal)\n+          // there is a chance that we end up with nothing accessible in the element tree.\n+          // So we remove the aria-hidden tag from ancestors so at least the current modal is accessible,\n+          // even tho it's probably undesirable when aria-hidden is not coming from another modal.\n+          if (show) {\n+            ariaHidden(element, !show);\n+          }\n+          // we restore it if it was originally hidden\n+          else {\n+            ariaHidden(element, show);\n+          }\n+        }",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "1770436230",
        "repo_full_name": "mui/material-ui",
        "pr_number": 43318,
        "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
        "discussion_id": "1770436230",
        "commented_code": "@@ -56,22 +56,56 @@ function isAriaHiddenForbiddenOnElement(element: Element): boolean {\n   return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   show: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  // In theory this should not happen anymore.\n+  // in some cases the container and previous element still\n+  // could end up being the same, in this case we just go up 1\n+  if (current === previousElement) {\n+    current = current.parentElement;\n+  }\n \n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, show);\n+  while (!!current && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any of the ancestors have aria-hidden applied (e.g. by another Modal)\n+          // there is a chance that we end up with nothing accessible in the element tree.\n+          // So we remove the aria-hidden tag from ancestors so at least the current modal is accessible,\n+          // even tho it's probably undesirable when aria-hidden is not coming from another modal.\n+          if (show) {\n+            ariaHidden(element, !show);\n+          }\n+          // we restore it if it was originally hidden\n+          else {\n+            ariaHidden(element, show);\n+          }\n+        }",
        "comment_created_at": "2024-09-22T10:14:35+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "Can you explain this part of the logic with an example? It's a little hard to follow.",
        "pr_file_module": null
      },
      {
        "comment_id": "1770523566",
        "repo_full_name": "mui/material-ui",
        "pr_number": 43318,
        "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
        "discussion_id": "1770436230",
        "commented_code": "@@ -56,22 +56,56 @@ function isAriaHiddenForbiddenOnElement(element: Element): boolean {\n   return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   show: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  // In theory this should not happen anymore.\n+  // in some cases the container and previous element still\n+  // could end up being the same, in this case we just go up 1\n+  if (current === previousElement) {\n+    current = current.parentElement;\n+  }\n \n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, show);\n+  while (!!current && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any of the ancestors have aria-hidden applied (e.g. by another Modal)\n+          // there is a chance that we end up with nothing accessible in the element tree.\n+          // So we remove the aria-hidden tag from ancestors so at least the current modal is accessible,\n+          // even tho it's probably undesirable when aria-hidden is not coming from another modal.\n+          if (show) {\n+            ariaHidden(element, !show);\n+          }\n+          // we restore it if it was originally hidden\n+          else {\n+            ariaHidden(element, show);\n+          }\n+        }",
        "comment_created_at": "2024-09-22T11:03:41+00:00",
        "comment_author": "Gr3q",
        "comment_body": "Before this function it only hid siblings. Now it traverses up the html tree from the modal mount location, hiding every sibling and removing aria-hidden from every ancestor of the modal (if needed).\r\n\r\nThis because models can be mounted anywhere, and we always want to only allow the latest open modal to be accessible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936204376",
    "pr_number": 43318,
    "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
    "created_at": "2025-01-30T19:57:36+00:00",
    "commented_code": "return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   hide: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n-\n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, hide);\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  while (current != null && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any ancestor has aria-hidden applied (e.g. by another modal), the current modal could become inaccessible.\n+          // We remove aria-hidden from ancestors to ensure the current modal is accessible, even though this might not be ideal if aria-hidden wasn't added by another modal (For example, if a developer manually applied aria-hidden to hide certain content, removing it could lead to unintended accessibility issues.).",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "1936204376",
        "repo_full_name": "mui/material-ui",
        "pr_number": 43318,
        "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
        "discussion_id": "1936204376",
        "commented_code": "@@ -56,22 +58,47 @@ function isAriaHiddenForbiddenOnElement(element: Element): boolean {\n   return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   hide: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n-\n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, hide);\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  while (current != null && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any ancestor has aria-hidden applied (e.g. by another modal), the current modal could become inaccessible.\n+          // We remove aria-hidden from ancestors to ensure the current modal is accessible, even though this might not be ideal if aria-hidden wasn't added by another modal (For example, if a developer manually applied aria-hidden to hide certain content, removing it could lead to unintended accessibility issues.).",
        "comment_created_at": "2025-01-30T19:57:36+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "We shouldn't do this:\r\n\r\nIf multiple modals are open, or the developer applied `aria-hidden` to one of the modal's ancestors, it's the developer responsibility to fix it.\r\n\r\nThis is not an acceptable side-effect:\r\n\r\n> [...] if a developer manually applied aria-hidden to hide certain content, removing it could lead to unintended accessibility issues.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2145125601",
        "repo_full_name": "mui/material-ui",
        "pr_number": 43318,
        "pr_file": "packages/mui-material/src/Modal/ModalManager.ts",
        "discussion_id": "1936204376",
        "commented_code": "@@ -56,22 +58,47 @@ function isAriaHiddenForbiddenOnElement(element: Element): boolean {\n   return isForbiddenTagName || isInputHidden;\n }\n \n-function ariaHiddenSiblings(\n+function ariaHiddenElements(\n   container: Element,\n-  mountElement: Element,\n+  mountElement: Element | null,\n   currentElement: Element,\n   elementsToExclude: readonly Element[],\n   hide: boolean,\n ): void {\n-  const blacklist = [mountElement, currentElement, ...elementsToExclude];\n-\n-  [].forEach.call(container.children, (element: Element) => {\n-    const isNotExcludedElement = !blacklist.includes(element);\n-    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n-    if (isNotExcludedElement && isNotForbiddenElement) {\n-      ariaHidden(element, hide);\n+  let current: Element | null = container;\n+  let previousElement: Element =\n+    container === mountElement ? currentElement : (mountElement ?? currentElement);\n+  const html = ownerDocument(container).body.parentElement;\n+  const blacklist = [mountElement, ...elementsToExclude];\n+\n+  while (current != null && html !== current) {\n+    for (let i = 0; i < current.children.length; i += 1) {\n+      const element = current.children[i];\n+      const isNotExcludedElement = blacklist.indexOf(element) === -1;\n+      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);\n+      const isPreviousElement = element === previousElement;\n+\n+      // We came from here\n+      if (isPreviousElement) {\n+        if (!isNotExcludedElement) {\n+          // If any ancestor has aria-hidden applied (e.g. by another modal), the current modal could become inaccessible.\n+          // We remove aria-hidden from ancestors to ensure the current modal is accessible, even though this might not be ideal if aria-hidden wasn't added by another modal (For example, if a developer manually applied aria-hidden to hide certain content, removing it could lead to unintended accessibility issues.).",
        "comment_created_at": "2025-06-13T13:38:34+00:00",
        "comment_author": "Gr3q",
        "comment_body": "This is the most important part of the fix. How do you propose me fixing this problem:\r\n1. Open a Modal with `disablePortal`\r\n2. Open another Modal with **no** `disablePortal`\r\n\r\nNo need for nesting modals etc, just do it programmatically. Now step one applied `aria-hidden` to the ModalManager's parent container, step 2 will apply `aria-hidden` to the parent of step one's Modal. Without that part it's completely inaccessible, no need for developer error.\r\n\r\n> If multiple modals are open ~, or the developer applied aria-hidden to one of the modal's ancestors,~ it's the developer responsibility to fix it.\r\n\r\nWhy would you expect the dev's to fix something that the library is doing to itself? How the hell would you fix this as a dev? `ModalManager` is not exposed, you can't replace it with something that actually works.\r\n\r\n> If ~multiple modals are open, or~ the developer applied aria-hidden to one of the modal's ancestors, it's the developer responsibility to fix it.\r\n\r\nThis one makes sense. Tell me, how would I go about tracking which ones were added by ModalManager, which ones are added by the dev, or my favorite case: when both are true? ",
        "pr_file_module": null
      }
    ]
  }
]