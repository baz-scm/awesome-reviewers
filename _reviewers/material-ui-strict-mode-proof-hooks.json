[
  {
    "discussion_id": "2151387517",
    "pr_number": 46333,
    "pr_file": "packages/mui-material/src/Tab/Tab.js",
    "created_at": "2025-06-17T06:00:10+00:00",
    "commented_code": "className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "2151387517",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-17T06:00:10+00:00",
        "comment_author": "sai6855",
        "comment_body": "function block inside useState hook runs only once through out component lifecycle (it doesn't run when component re-renders). So curious to understand the purpose of `hasRegisteredRef`, as it will always be false when this code runs",
        "pr_file_module": null
      },
      {
        "comment_id": "2153856996",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-18T07:29:01+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "You're right that the initializer inside `useState` only runs once per mount. However, in React\u2019s Strict Mode (development only), it's **intentionally called twice** to detect impure logic. Since `registerTab` mutates internal state, calling it twice would incorrectly register the tab multiple times, shifting tab indices and breaking the selection or indicator logic.\r\n\r\nTo avoid this, we guard it with `hasRegisteredRef`, ensuring `registerTab` runs only once \u2014 even in development. In production, the guard has no effect because the initializer runs only once as expected.\r\n\r\nIdeally, the initializer should be pure (per [React docs](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice)), but we intentionally break that rule here to **support SSR** \u2014 specifically, to precompute tab metadata so that the correct tab is marked selected on the first render (see [test case](https://github.com/mui/material-ui/blob/6c0f14b50dc7c86134b8bb549da47dc33bf8b06a/packages/mui-material/src/Tabs/Tabs.test.js#L901-L912)). Without it, we get hydration mismatches..\r\n\r\nI considered making `registerTab` idempotent, but that\u2019s not feasible when we need to assign an implicit `value` based on the tab's render order. That requires incrementing a shared index counter (`childIndexRef`) \u2014 and we can\u2019t require users to always provide explicit values to `Tab` without introducing a breaking change.\r\n\r\nThis approach strikes a balance: it ensures SSR correctness, avoids hydration issues, and works with wrapper components like `<Tooltip><Tab /></Tooltip>`, while remaining safe under React\u2019s development behavior.\r\n\r\nOpen to suggestions if you think there's a cleaner way to achieve this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2154723881",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-18T14:13:33+00:00",
        "comment_author": "michaldudak",
        "comment_body": "If I understand it correctly this won't work well if you remove a tab dynamically (as there's no unregister function)",
        "pr_file_module": null
      },
      {
        "comment_id": "2156211289",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-19T06:18:34+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "> If I understand it correctly this won't work well if you remove a tab dynamically (as there's no unregister function)\r\n\r\nIt won't. But it isn't supported even in latest version.\r\n\r\nThis PR: https://stackblitz.com/edit/ry4fan5c-t3b4771r\r\nMaster: https://stackblitz.com/edit/ry4fan5c-oqugmytq",
        "pr_file_module": null
      },
      {
        "comment_id": "2159375000",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-20T16:54:19+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "Using the register pattern without an unregister function sounds to me like it can introduce weird edge cases. Did you consider registering/unregistering on an effect instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159530342",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-20T19:01:47+00:00",
        "comment_author": "michaldudak",
        "comment_body": "Registering during an effect phase will prevent it from running on the server. Perhaps  we could register both during rendering and in an effect and make the register operation idempotent (or register conditionally if it hasn't been registered yet). This will allow the use of the unregister function in the effect cleanup.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161001985",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-23T08:18:02+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "Yes, registering during the effect phase would prevent it from running on the server, which breaks SSR.\r\n\r\n> Perhaps we could register both during rendering and in an effect and make the register operation idempotent (or register conditionally if it hasn't been registered yet). This will allow the use of the unregister function in the effect cleanup.\r\n\r\nThat could work well only if tabs always have explicit `value` props. But in our case, we also support implicit values based on render order, like this:\r\n\r\n```tsx\r\nconst [tab, setTab] = React.useState(1);\r\n\r\nconst handleChange = (event, newValue) => {\r\n  setTab(newValue);\r\n};\r\n\r\nreturn (\r\n  <Tabs value={tab} onChange={handleChange}>\r\n    <Tab label=\"one\" />\r\n    <Tooltip title=\"two helper\">\r\n      <Tab label=\"two\" />\r\n    </Tooltip>\r\n  </Tabs>\r\n);\r\n```\r\n\r\nHere, tabs derive their `value` from their render position (i.e., first tab = 0, second = 1), using an internal `childIndexRef`.\r\n\r\nIf we register both during render and in an effect:\r\n\r\n* In React Strict Mode (dev only), render and effect each run twice i.e total of 4 registrations.\r\n* Even without Strict Mode, a single tab would be registered twice. (one in first render and second in effect).\r\n\r\nSo, there would be 4 child indexes.\r\n\r\nWhile `registerTab` is already idempotent when used with explicit values (via `valueToIndex.has(finalValue)`), we can't enforce `value` on Tab without introducing a breaking change.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2162713451",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-24T00:03:25+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "Deriving the `value` from the position sounds good to me \ud83d\udc4d\ud83c\udffc \r\n\r\n> While registerTab is already idempotent when used with explicit values (via valueToIndex.has(finalValue)), we can't enforce value on Tab without introducing a breaking change.\r\n\r\nBut if we create a `value` for the position on our side, then we would have a `finalValue`, no? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2163187949",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-24T07:38:37+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "> Deriving the value from the position sounds good to me \ud83d\udc4d\ud83c\udffc\r\n\r\nThis logic was already present when `cloneElement` was used. Just picked that up here.\r\n\r\n> But if we create a `value` for the position on our side, then we would have a `finalValue`, no?\r\n\r\nYes, we do generate a `finalValue` based on position internally when value isn't provided. The issue is that this implicit value depends on render order and a shared index (`childIndexRef`), which is incremented during registration.\r\n\r\nIf we allow `registerTab` to run multiple times \u2014 as suggested above, in both render and effect \u2014 the index keeps increasing, and the same tab ends up with different `finalValue`s across renders. That breaks selection and causes hydration mismatches.\r\n\r\nWith explicit `value`, we don\u2019t rely on index state, so idempotency is safe. But for implicit values, the act of generating `finalValue` is tied to mutable state \u2014 so calling `registerTab` multiple times isn\u2019t safe unless we move to require explicit values, which would be a breaking change.",
        "pr_file_module": null
      },
      {
        "comment_id": "2164810445",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-24T20:11:28+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "> Yes, we do generate a finalValue based on position internally when value isn't provided. The issue is that this implicit value depends on render order and a shared index (childIndexRef), which is incremented during registration.\r\n\r\nBut what if we \"store\" that value in the Tab, to be used in subsequent registrations? Wouldn't that remove the issue?\r\n\r\nSomething like:\r\n1. Tab runs register for the first time. There's no value, so we store `finalValue`\r\n2. In any subsequent register call, we use `finalValue` to identify the Tab, and thus we don't have to calculate a new `finalValue`.\r\n\r\nWould this work?",
        "pr_file_module": null
      },
      {
        "comment_id": "2166656133",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-25T12:57:56+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "I don't think this will work.\r\n\r\n> In any subsequent register call, we use `finalValue` to identify the Tab\r\n\r\nWhy do we want to pass the same `finalValue` to the next registration call? If we want to pass this stored `finalValue`, we shouldn't call `registerTab` again in the first place (supposedly in the effect).\r\n\r\nFeel free to edit the code if you have any ideas.\r\n\r\n----\r\n\r\nEven in Base UI, they are making the `value` prop required on Tab: https://github.com/mui/base-ui/pull/2124. \r\n\r\nSupporting implicit `value` in Tab cause them issues like https://github.com/mui/base-ui/issues/1880.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166911852",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-25T14:43:16+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "> Why do we want to pass the same finalValue to the next registration call? If we want to pass this stored finalValue, we shouldn't call registerTab again in the first place (supposedly in the effect).\r\n\r\nBecause we want to return the unregistering callback from the effect, so it's run on unmount.\r\n\r\n> Even in Base UI, they are making the value prop required on Tab\r\n\r\nThis is not an option for us unless we want to wait for a new major.\r\n\r\n> Supporting implicit value in Tab cause them issues like\r\n\r\nWe're already supporting implicit value, aren't we? With or without my suggestion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167014735",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-25T15:29:17+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "> Because we want to return the unregistering callback from the effect, so it's run on unmount.\r\n\r\nBut wouldn't the useEffect's setup function do nothing? It would simply return the output given as an input **always** when doing `registerTab(finalValue)`.\r\n\r\n> This is not an option for us unless we want to wait for a new major.\r\n\r\nYes, not an option now.\r\n\r\n> We're already supporting implicit value, aren't we? With or without my suggestion.\r\n\r\nYes, we are already. Just wanted to point out some issues. I thought it would help us to understand.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167528576",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-25T20:03:27+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "> But wouldn't the useEffect's setup function do nothing?\r\n\r\nOnly on the first run of the effect. Subsequent runs would unregister (cleanup) and register back. This is the same as having register/unregister in an effect, except that the very first time we already registered inside `useState`. I don't see an issue with it if register is idempotent \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2169042932",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-26T13:12:41+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "I tried doing this in https://github.com/mui/material-ui/pull/46333/commits/7221ea83aeb156e555c031bd9b0062124a1971b6 but the tests fail. Any idea why? However, it works locally on browser.",
        "pr_file_module": null
      },
      {
        "comment_id": "2169299284",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-26T15:07:43+00:00",
        "comment_author": "DiegoAndai",
        "comment_body": "Which test failed? What was the message?",
        "pr_file_module": null
      },
      {
        "comment_id": "2172282767",
        "repo_full_name": "mui/material-ui",
        "pr_number": 46333,
        "pr_file": "packages/mui-material/src/Tab/Tab.js",
        "discussion_id": "2151387517",
        "commented_code": "@@ -193,27 +194,43 @@ const Tab = React.forwardRef(function Tab(inProps, ref) {\n     className,\n     disabled = false,\n     disableFocusRipple = false,\n-    // eslint-disable-next-line react/prop-types\n-    fullWidth,\n     icon: iconProp,\n     iconPosition = 'top',\n-    // eslint-disable-next-line react/prop-types\n-    indicator,\n     label,\n-    onChange,\n     onClick,\n     onFocus,\n-    // eslint-disable-next-line react/prop-types\n-    selected,\n-    // eslint-disable-next-line react/prop-types\n-    selectionFollowsFocus,\n-    // eslint-disable-next-line react/prop-types\n-    textColor = 'inherit',\n-    value,\n+    tabIndex: tabIndexProp,\n+    value: valueProp,\n     wrapped = false,\n     ...other\n   } = props;\n \n+  const {\n+    fullWidth,\n+    indicator: indicatorContext,\n+    mounted,\n+    selectionFollowsFocus,\n+    onChange,\n+    textColor = 'inherit',\n+    tabsValue,\n+    registerTab,\n+  } = useTabsContext();\n+\n+  const hasRegisteredRef = React.useRef(false);\n+\n+  const [{ finalValue: value, assignedIndex }] = React.useState(() => {\n+    if (!hasRegisteredRef.current) {\n+      hasRegisteredRef.current = true;",
        "comment_created_at": "2025-06-27T15:25:20+00:00",
        "comment_author": "ZeeshanTamboli",
        "comment_body": "Tests pass now. The tests run with Strict Mode, which helped me catch the issue that I wasn\u2019t decrementing the child index on tab unregistration.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "699997616",
    "pr_number": 28070,
    "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
    "created_at": "2021-09-01T08:29:41+00:00",
    "commented_code": "return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{\n-          '@keyframes mui-auto-fill': {},\n-          '@keyframes mui-auto-fill-cancel': {},\n-        }}\n-      />\n+      <InputGlobalStyles />",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "699997616",
        "repo_full_name": "mui/material-ui",
        "pr_number": 28070,
        "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
        "discussion_id": "699997616",
        "commented_code": "@@ -483,12 +493,7 @@ const InputBase = React.forwardRef(function InputBase(inProps, ref) {\n \n   return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{\n-          '@keyframes mui-auto-fill': {},\n-          '@keyframes mui-auto-fill-cancel': {},\n-        }}\n-      />\n+      <InputGlobalStyles />",
        "comment_created_at": "2021-09-01T08:29:41+00:00",
        "comment_author": "eps1lon",
        "comment_body": "Was this not subject to hoisting of static elements and therefore automatic memoization by React?\r\n\r\nIf it wasn't (maybe the inline object is the culprit) I would just hoist it manually. I think this should work as well without the need for an additional component:\r\n\r\n```diff\r\n-<InputGlobalStyles />\r\n+{inputGlobalStyles}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "700027258",
        "repo_full_name": "mui/material-ui",
        "pr_number": 28070,
        "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
        "discussion_id": "699997616",
        "commented_code": "@@ -483,12 +493,7 @@ const InputBase = React.forwardRef(function InputBase(inProps, ref) {\n \n   return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{\n-          '@keyframes mui-auto-fill': {},\n-          '@keyframes mui-auto-fill-cancel': {},\n-        }}\n-      />\n+      <InputGlobalStyles />",
        "comment_created_at": "2021-09-01T09:08:26+00:00",
        "comment_author": "mnajdova",
        "comment_body": "Would the `inputGlobalStyles` in this case be:\r\n```diff\r\n-const InputGlobalStyles = React.memo(() => (\r\n+const inputGlobalStyles = (\r\n  <GlobalStyles\r\n    styles={{\r\n      '@keyframes mui-auto-fill': { from: { display: 'block' } },\r\n      '@keyframes mui-auto-fill-cancel': { from: { display: 'block' } },\r\n    }}\r\n  />\r\n-));\r\n+);\r\n```\r\n\r\nLet me try this locally\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "700041878",
        "repo_full_name": "mui/material-ui",
        "pr_number": 28070,
        "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
        "discussion_id": "699997616",
        "commented_code": "@@ -483,12 +493,7 @@ const InputBase = React.forwardRef(function InputBase(inProps, ref) {\n \n   return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{\n-          '@keyframes mui-auto-fill': {},\n-          '@keyframes mui-auto-fill-cancel': {},\n-        }}\n-      />\n+      <InputGlobalStyles />",
        "comment_created_at": "2021-09-01T09:27:51+00:00",
        "comment_author": "mnajdova",
        "comment_body": "Yep, it works. I've pushed the changes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "700101925",
    "pr_number": 28070,
    "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
    "created_at": "2021-09-01T10:54:28+00:00",
    "commented_code": "return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "700101925",
        "repo_full_name": "mui/material-ui",
        "pr_number": 28070,
        "pr_file": "packages/material-ui/src/InputBase/InputBase.js",
        "discussion_id": "700101925",
        "commented_code": "@@ -483,12 +493,7 @@ const InputBase = React.forwardRef(function InputBase(inProps, ref) {\n \n   return (\n     <React.Fragment>\n-      <GlobalStyles\n-        styles={{",
        "comment_created_at": "2021-09-01T10:54:28+00:00",
        "comment_author": "eps1lon",
        "comment_body": "Just learned that [`@babel/plugin-transform-constant-elements` deopts mutable props](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements). This unlocks a bunch of optimizations actually since we treat props as immutable all the time. Will investigate in a follow-up.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2050149098",
    "pr_number": 45943,
    "pr_file": "packages/mui-system/src/useThemeProps/useThemeProps.js",
    "created_at": "2025-04-18T06:40:00+00:00",
    "commented_code": "if (themeId) {\n     theme = theme[themeId] || theme;\n   }\n-  return getThemeProps({ theme, name, props });\n+  return React.useMemo(() => getThemeProps({ theme, name, props }), [theme, name, props]);",
    "repo_full_name": "mui/material-ui",
    "discussion_comments": [
      {
        "comment_id": "2050149098",
        "repo_full_name": "mui/material-ui",
        "pr_number": 45943,
        "pr_file": "packages/mui-system/src/useThemeProps/useThemeProps.js",
        "discussion_id": "2050149098",
        "commented_code": "@@ -7,5 +8,5 @@ export default function useThemeProps({ props, name, defaultTheme, themeId }) {\n   if (themeId) {\n     theme = theme[themeId] || theme;\n   }\n-  return getThemeProps({ theme, name, props });\n+  return React.useMemo(() => getThemeProps({ theme, name, props }), [theme, name, props]);",
        "comment_created_at": "2025-04-18T06:40:00+00:00",
        "comment_author": "siriwatknp",
        "comment_body": "I doubt that `props` will always be a new object on every render?\r\nsee this sandbox https://codesandbox.io/p/sandbox/react-new\r\n\r\nReact.useMemo would not help.",
        "pr_file_module": null
      },
      {
        "comment_id": "2053745928",
        "repo_full_name": "mui/material-ui",
        "pr_number": 45943,
        "pr_file": "packages/mui-system/src/useThemeProps/useThemeProps.js",
        "discussion_id": "2050149098",
        "commented_code": "@@ -7,5 +8,5 @@ export default function useThemeProps({ props, name, defaultTheme, themeId }) {\n   if (themeId) {\n     theme = theme[themeId] || theme;\n   }\n-  return getThemeProps({ theme, name, props });\n+  return React.useMemo(() => getThemeProps({ theme, name, props }), [theme, name, props]);",
        "comment_created_at": "2025-04-22T09:37:11+00:00",
        "comment_author": "KenanYusuf",
        "comment_body": "> React.useMemo would not help.\r\n\r\nMemoizing the return value of `getThemeProps` does fix this specific issue we're seeing, see https://github.com/mui/mui-x/pull/17490\r\n\r\nMore context here: https://github.com/mui/material-ui/pull/43120#discussion_r1699131698",
        "pr_file_module": null
      }
    ]
  }
]