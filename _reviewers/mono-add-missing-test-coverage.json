[
  {
    "discussion_id": "2285964350",
    "pr_number": 4771,
    "pr_file": "packages/zql/src/query/named.test.ts",
    "created_at": "2025-08-19T18:05:19+00:00",
    "commented_code": "}[]\n     >\n   >();\n-  check(x.myName);\n \n-  // define many at once\n-  const y = queries({\n-    myName: (id: string) => queryBuilder.issue.where('id', id),\n-    myOtherName: (id: string) => queryBuilder.issue.where('id', id),\n-    myThirdName: (id: string) => queryBuilder.issue.where('id', id),\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const defWithFakeContext = withContext(def);\n+  q = defWithFakeContext('1', '321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n   });\n-  check(y.myName, 'myName');\n-  check(y.myOtherName, 'myOtherName');\n-  check(y.myThirdName, 'myThirdName');\n-  const q1 = y.myName('123');\n-  const q2 = y.myOtherName('123');\n-  const q3 = y.myThirdName('123');\n-  expectTypeOf<ReturnType<typeof q1.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with context', () => {\n+  const def = syncedQueryWithContext('myQuery', (_c: unknown, id: string) =>\n+    builder.issue.where('id', id),\n+  );\n+  const q = def(1, '123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q2.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with validation', () => {\n+  const def = syncedQuery(\n+    'myQuery',\n+    (id: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      return [id] as const;\n+    },\n+    (id: string) => builder.issue.where('id', id),",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2285964350",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4771,
        "pr_file": "packages/zql/src/query/named.test.ts",
        "discussion_id": "2285964350",
        "commented_code": "@@ -27,64 +29,141 @@ test('defining a named query', () => {\n       }[]\n     >\n   >();\n-  check(x.myName);\n \n-  // define many at once\n-  const y = queries({\n-    myName: (id: string) => queryBuilder.issue.where('id', id),\n-    myOtherName: (id: string) => queryBuilder.issue.where('id', id),\n-    myThirdName: (id: string) => queryBuilder.issue.where('id', id),\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const defWithFakeContext = withContext(def);\n+  q = defWithFakeContext('1', '321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n   });\n-  check(y.myName, 'myName');\n-  check(y.myOtherName, 'myOtherName');\n-  check(y.myThirdName, 'myThirdName');\n-  const q1 = y.myName('123');\n-  const q2 = y.myOtherName('123');\n-  const q3 = y.myThirdName('123');\n-  expectTypeOf<ReturnType<typeof q1.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with context', () => {\n+  const def = syncedQueryWithContext('myQuery', (_c: unknown, id: string) =>\n+    builder.issue.where('id', id),\n+  );\n+  const q = def(1, '123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q2.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with validation', () => {\n+  const def = syncedQuery(\n+    'myQuery',\n+    (id: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      return [id] as const;\n+    },\n+    (id: string) => builder.issue.where('id', id),",
        "comment_created_at": "2025-08-19T18:05:19+00:00",
        "comment_author": "aboodman",
        "comment_body": "Can you add a test that the inference works? Should not need to provide type on `id` in query func.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2285969350",
    "pr_number": 4771,
    "pr_file": "packages/zql/src/query/named.test.ts",
    "created_at": "2025-08-19T18:07:06+00:00",
    "commented_code": "}[]\n     >\n   >();\n-  check(x.myName);\n \n-  // define many at once\n-  const y = queries({\n-    myName: (id: string) => queryBuilder.issue.where('id', id),\n-    myOtherName: (id: string) => queryBuilder.issue.where('id', id),\n-    myThirdName: (id: string) => queryBuilder.issue.where('id', id),\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const defWithFakeContext = withContext(def);\n+  q = defWithFakeContext('1', '321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n   });\n-  check(y.myName, 'myName');\n-  check(y.myOtherName, 'myOtherName');\n-  check(y.myThirdName, 'myThirdName');\n-  const q1 = y.myName('123');\n-  const q2 = y.myOtherName('123');\n-  const q3 = y.myThirdName('123');\n-  expectTypeOf<ReturnType<typeof q1.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with context', () => {\n+  const def = syncedQueryWithContext('myQuery', (_c: unknown, id: string) =>\n+    builder.issue.where('id', id),\n+  );\n+  const q = def(1, '123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q2.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with validation', () => {\n+  const def = syncedQuery(\n+    'myQuery',\n+    (id: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      return [id] as const;\n+    },\n+    (id: string) => builder.issue.where('id', id),\n+  );\n+\n+  let q = def('123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q3.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const {validator} = def;\n+  expectTypeOf<ReturnType<typeof validator>>().toEqualTypeOf<\n+    readonly [string] | [string]\n   >();\n-});\n \n-function check(\n-  named: NamedQuery<[string], any>,\n-  expectedName: string = 'myName',\n-) {\n-  const r = named('123');\n+  const validated = withValidation(def);\n+  q = validated('321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n+  });\n \n-  const id = r.customQueryID;\n-  expect(id?.name).toBe(expectedName);\n-  expect(id?.args).toEqual(['123']);\n-  expect(ast(r)).toMatchInlineSnapshot(`\n-    {\n-      \"table\": \"issue\",\n-      \"where\": {\n-        \"left\": {\n-          \"name\": \"id\",\n-          \"type\": \"column\",\n-        },\n-        \"op\": \"=\",\n-        \"right\": {\n-          \"type\": \"literal\",\n-          \"value\": \"123\",\n-        },\n-        \"type\": \"simple\",\n-      },\n-    }\n-  `);\n+  expect(() => validated(1)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: id must be a string]`,\n+  );\n+});\n \n-  // see comment on `r.hash()`\n-  expect(r.hash()).not.toEqual(hashOfNameAndArgs('issue', ['123']));\n-  expect(r.hash()).toEqual(\n-    hashOfAST((r as StaticQuery<typeof schema, 'issue'>).ast),\n+test('defining a synced query with validation and context', () => {\n+  const def = syncedQueryWithContext(\n+    'myQuery',\n+    (id: unknown, createdAt: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      assert(typeof createdAt === 'number', 'createdAt must be a number');\n+      return [id, createdAt] as const;\n+    },\n+    (ctx: object, ownerId: string, createdAt: number) => {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2285969350",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4771,
        "pr_file": "packages/zql/src/query/named.test.ts",
        "discussion_id": "2285969350",
        "commented_code": "@@ -27,64 +29,141 @@ test('defining a named query', () => {\n       }[]\n     >\n   >();\n-  check(x.myName);\n \n-  // define many at once\n-  const y = queries({\n-    myName: (id: string) => queryBuilder.issue.where('id', id),\n-    myOtherName: (id: string) => queryBuilder.issue.where('id', id),\n-    myThirdName: (id: string) => queryBuilder.issue.where('id', id),\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const defWithFakeContext = withContext(def);\n+  q = defWithFakeContext('1', '321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n   });\n-  check(y.myName, 'myName');\n-  check(y.myOtherName, 'myOtherName');\n-  check(y.myThirdName, 'myThirdName');\n-  const q1 = y.myName('123');\n-  const q2 = y.myOtherName('123');\n-  const q3 = y.myThirdName('123');\n-  expectTypeOf<ReturnType<typeof q1.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with context', () => {\n+  const def = syncedQueryWithContext('myQuery', (_c: unknown, id: string) =>\n+    builder.issue.where('id', id),\n+  );\n+  const q = def(1, '123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q2.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  // no validator was defined\n+  expect(() => withValidation(def)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: ret does not have a validator defined]`,\n+  );\n+});\n+\n+test('defining a synced query with validation', () => {\n+  const def = syncedQuery(\n+    'myQuery',\n+    (id: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      return [id] as const;\n+    },\n+    (id: string) => builder.issue.where('id', id),\n+  );\n+\n+  let q = def('123');\n+  expectTypeOf<ReturnType<typeof q.run>>().toEqualTypeOf<\n+    Promise<\n+      {\n+        readonly id: string;\n+        readonly title: string;\n+        readonly description: string;\n+        readonly closed: boolean;\n+        readonly ownerId: string | null;\n+        readonly createdAt: number;\n+      }[]\n+    >\n   >();\n-  expectTypeOf<ReturnType<typeof q3.run>>().toEqualTypeOf<\n-    ReturnType<typeof q.run>\n+\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['123'],\n+  });\n+\n+  const {validator} = def;\n+  expectTypeOf<ReturnType<typeof validator>>().toEqualTypeOf<\n+    readonly [string] | [string]\n   >();\n-});\n \n-function check(\n-  named: NamedQuery<[string], any>,\n-  expectedName: string = 'myName',\n-) {\n-  const r = named('123');\n+  const validated = withValidation(def);\n+  q = validated('321');\n+  expect(q.customQueryID).toEqual({\n+    name: 'myQuery',\n+    args: ['321'],\n+  });\n \n-  const id = r.customQueryID;\n-  expect(id?.name).toBe(expectedName);\n-  expect(id?.args).toEqual(['123']);\n-  expect(ast(r)).toMatchInlineSnapshot(`\n-    {\n-      \"table\": \"issue\",\n-      \"where\": {\n-        \"left\": {\n-          \"name\": \"id\",\n-          \"type\": \"column\",\n-        },\n-        \"op\": \"=\",\n-        \"right\": {\n-          \"type\": \"literal\",\n-          \"value\": \"123\",\n-        },\n-        \"type\": \"simple\",\n-      },\n-    }\n-  `);\n+  expect(() => validated(1)).toThrowErrorMatchingInlineSnapshot(\n+    `[Error: id must be a string]`,\n+  );\n+});\n \n-  // see comment on `r.hash()`\n-  expect(r.hash()).not.toEqual(hashOfNameAndArgs('issue', ['123']));\n-  expect(r.hash()).toEqual(\n-    hashOfAST((r as StaticQuery<typeof schema, 'issue'>).ast),\n+test('defining a synced query with validation and context', () => {\n+  const def = syncedQueryWithContext(\n+    'myQuery',\n+    (id: unknown, createdAt: unknown) => {\n+      assert(typeof id === 'string', 'id must be a string');\n+      assert(typeof createdAt === 'number', 'createdAt must be a number');\n+      return [id, createdAt] as const;\n+    },\n+    (ctx: object, ownerId: string, createdAt: number) => {",
        "comment_created_at": "2025-08-19T18:07:06+00:00",
        "comment_author": "aboodman",
        "comment_body": "Can you add a test with the form: `syncedWithContext<string>(\"foo\", validator, fn)` where the signature of fn doesn't need to include types for args or auth.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2220650727",
    "pr_number": 4651,
    "pr_file": "packages/zero-client/src/client/zero-poke-handler.test.ts",
    "created_at": "2025-07-22T00:24:49+00:00",
    "commented_code": "clientID,\n     schema,\n     logContext,\n+    new MutationTracker(logContext),",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2220650727",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4651,
        "pr_file": "packages/zero-client/src/client/zero-poke-handler.test.ts",
        "discussion_id": "2220650727",
        "commented_code": "@@ -842,6 +849,7 @@ test('replicachePoke throwing error calls onPokeError and clears', async () => {\n     clientID,\n     schema,\n     logContext,\n+    new MutationTracker(logContext),",
        "comment_created_at": "2025-07-22T00:24:49+00:00",
        "comment_author": "grgbkr",
        "comment_body": "Would be good to add a basic test of the interaction with MutationTracker, probably using a mock.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014539861",
    "pr_number": 4103,
    "pr_file": "apps/zbugs/shared/auth.ts",
    "created_at": "2025-03-26T16:17:09+00:00",
    "commented_code": "+import type {Query, Transaction} from '@rocicorp/zero';\n+import type {schema} from './schema.ts';\n+import {must} from '../../../packages/shared/src/must.ts';\n+import {assert} from '../../../packages/shared/src/asserts.ts';\n+import * as v from '../../../packages/shared/src/valita.ts';\n+\n+/** The contents of the zbugs JWT */\n+export const authDataSchema = v.object({\n+  sub: v.string(),\n+  role: v.union(v.literal('crew'), v.literal('user')),\n+  name: v.string(),\n+  iat: v.number(),\n+  exp: v.number(),\n+});\n+\n+export type AuthData = v.Infer<typeof authDataSchema>;\n+\n+export function assertIsLoggedIn(\n+  authData: AuthData | undefined,\n+): asserts authData {\n+  assert(authData, 'user must be logged in for this operation');\n+}\n+\n+export function isAdmin(token: AuthData | undefined) {\n+  assertIsLoggedIn(token);\n+  return token.role === 'crew';\n+}\n+\n+export async function assertIsCreatorOrAdmin(\n+  authData: AuthData | undefined,\n+  query: Query<typeof schema, 'comment' | 'issue' | 'emoji'>,\n+  id: string,\n+) {\n+  assertIsLoggedIn(authData);\n+  if (isAdmin(authData)) {\n+    return;\n+  }\n+  const creatorID = must(\n+    await query.where('id', id).one().run(),\n+    `entity ${id} does not exist`,\n+  ).creatorID;\n+  assert(\n+    authData.sub === creatorID,\n+    `User ${authData.sub} is not an admin or the creator of the target entity`,\n+  );\n+}\n+\n+export async function assertUserCanSeeIssue(",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2014539861",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4103,
        "pr_file": "apps/zbugs/shared/auth.ts",
        "discussion_id": "2014539861",
        "commented_code": "@@ -0,0 +1,73 @@\n+import type {Query, Transaction} from '@rocicorp/zero';\n+import type {schema} from './schema.ts';\n+import {must} from '../../../packages/shared/src/must.ts';\n+import {assert} from '../../../packages/shared/src/asserts.ts';\n+import * as v from '../../../packages/shared/src/valita.ts';\n+\n+/** The contents of the zbugs JWT */\n+export const authDataSchema = v.object({\n+  sub: v.string(),\n+  role: v.union(v.literal('crew'), v.literal('user')),\n+  name: v.string(),\n+  iat: v.number(),\n+  exp: v.number(),\n+});\n+\n+export type AuthData = v.Infer<typeof authDataSchema>;\n+\n+export function assertIsLoggedIn(\n+  authData: AuthData | undefined,\n+): asserts authData {\n+  assert(authData, 'user must be logged in for this operation');\n+}\n+\n+export function isAdmin(token: AuthData | undefined) {\n+  assertIsLoggedIn(token);\n+  return token.role === 'crew';\n+}\n+\n+export async function assertIsCreatorOrAdmin(\n+  authData: AuthData | undefined,\n+  query: Query<typeof schema, 'comment' | 'issue' | 'emoji'>,\n+  id: string,\n+) {\n+  assertIsLoggedIn(authData);\n+  if (isAdmin(authData)) {\n+    return;\n+  }\n+  const creatorID = must(\n+    await query.where('id', id).one().run(),\n+    `entity ${id} does not exist`,\n+  ).creatorID;\n+  assert(\n+    authData.sub === creatorID,\n+    `User ${authData.sub} is not an admin or the creator of the target entity`,\n+  );\n+}\n+\n+export async function assertUserCanSeeIssue(",
        "comment_created_at": "2025-03-26T16:17:09+00:00",
        "comment_author": "tantaman",
        "comment_body": "we should really add tests for these. And when the product is more mature, some harness that allows a user to test their mutators (and/or mutator helpers) in both the browser and server environment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1857259579",
    "pr_number": 3085,
    "pr_file": "packages/zql/src/ivm/take.push.test.ts",
    "created_at": "2024-11-25T19:50:20+00:00",
    "commented_code": "{id: 'c5', issueID: 'i2', created: 500, text: 'e'},\n       ],\n       partition: {\n-        key: 'issueID',\n-        values: ['i1', 'i2'],\n+        key: ['issueID'],\n+        values: [['i1'], ['i2']],\n       },\n     } as const;\n \n     takeTest({\n       ...base,\n       name: 'limit 0',\n       partition: {\n-        key: 'issueID',\n-        values: ['i1', 'i2'],\n+        key: ['issueID'],",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1857259579",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3085,
        "pr_file": "packages/zql/src/ivm/take.push.test.ts",
        "discussion_id": "1857259579",
        "commented_code": "@@ -1523,17 +1524,17 @@ suite('take with partition', () => {\n         {id: 'c5', issueID: 'i2', created: 500, text: 'e'},\n       ],\n       partition: {\n-        key: 'issueID',\n-        values: ['i1', 'i2'],\n+        key: ['issueID'],\n+        values: [['i1'], ['i2']],\n       },\n     } as const;\n \n     takeTest({\n       ...base,\n       name: 'limit 0',\n       partition: {\n-        key: 'issueID',\n-        values: ['i1', 'i2'],\n+        key: ['issueID'],",
        "comment_created_at": "2024-11-25T19:50:20+00:00",
        "comment_author": "grgbkr",
        "comment_body": "Please add a test case for push with a compound partition key.",
        "pr_file_module": null
      }
    ]
  }
]