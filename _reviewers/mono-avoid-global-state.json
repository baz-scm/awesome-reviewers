[
  {
    "discussion_id": "2246724954",
    "pr_number": 4669,
    "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
    "created_at": "2025-08-01T02:01:33+00:00",
    "commented_code": "+import {RWLock} from '@rocicorp/lock';\n+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {\n+  promiseUndefined,\n+  promiseVoid,\n+} from '../../../shared/src/resolved-promises.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Read, Store, Write} from './store.ts';\n+\n+/**\n+ * A SQLite prepared statement.\n+ *\n+ * `run` executes the statement with optional parameters.\n+ * `all` executes the statement and returns the result rows.\n+ * `finalize` releases the statement.\n+ */\n+export interface PreparedStatement {\n+  run(...params: unknown[]): void;\n+  all<T>(...params: unknown[]): T[];\n+  finalize(): void;\n+}\n+\n+export interface SQLiteDatabase {\n+  /**\n+   * Close the database connection.\n+   */\n+  close(): void;\n+\n+  /**\n+   * Destroy or delete the database (e.g. delete file).\n+   */\n+  destroy(): void;\n+\n+  /**\n+   * Prepare a SQL string, returning a statement you can execute.\n+   * E.g. `const stmt = db.prepare(\"SELECT * FROM todos WHERE id=?\");`\n+   */\n+  prepare(sql: string): PreparedStatement;\n+\n+  /**\n+   * Check if the database is in a transaction.\n+   */\n+  isInTransaction(): boolean;\n+}\n+\n+type SQLitePreparedStatements = {\n+  begin: PreparedStatement;\n+  beginImmediate: PreparedStatement;\n+  commit: PreparedStatement;\n+  rollback: PreparedStatement;\n+\n+  savepoint: PreparedStatement;\n+  release: PreparedStatement;\n+\n+  get: PreparedStatement;\n+  put: PreparedStatement;\n+  del: PreparedStatement;\n+};\n+\n+const getPreparedStatementsForSQLiteDatabase = (\n+  db: SQLiteDatabase,\n+): SQLitePreparedStatements => ({\n+  begin: db.prepare('BEGIN'),\n+  beginImmediate: db.prepare('BEGIN IMMEDIATE'),\n+  commit: db.prepare('COMMIT'),\n+  rollback: db.prepare('ROLLBACK'),\n+\n+  // Similar to https://github.com/WiseLibs/better-sqlite3/blob/674ce6be68a26742d9e24f8672da7888cea0aebb/lib/methods/transaction.js#L35-L39\n+  savepoint: db.prepare('SAVEPOINT `\\t_rc.\\t`'),\n+  release: db.prepare('RELEASE `\\t_rc.\\t`'),\n+\n+  get: db.prepare('SELECT value FROM entry WHERE key = ?'),\n+  put: db.prepare('INSERT OR REPLACE INTO entry (key, value) VALUES (?, ?)'),\n+  del: db.prepare('DELETE FROM entry WHERE key = ?'),\n+});\n+\n+const rwLocks = new Map<string, RWLock>();",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2246724954",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4669,
        "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
        "discussion_id": "2246724954",
        "commented_code": "@@ -0,0 +1,376 @@\n+import {RWLock} from '@rocicorp/lock';\n+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {\n+  promiseUndefined,\n+  promiseVoid,\n+} from '../../../shared/src/resolved-promises.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Read, Store, Write} from './store.ts';\n+\n+/**\n+ * A SQLite prepared statement.\n+ *\n+ * `run` executes the statement with optional parameters.\n+ * `all` executes the statement and returns the result rows.\n+ * `finalize` releases the statement.\n+ */\n+export interface PreparedStatement {\n+  run(...params: unknown[]): void;\n+  all<T>(...params: unknown[]): T[];\n+  finalize(): void;\n+}\n+\n+export interface SQLiteDatabase {\n+  /**\n+   * Close the database connection.\n+   */\n+  close(): void;\n+\n+  /**\n+   * Destroy or delete the database (e.g. delete file).\n+   */\n+  destroy(): void;\n+\n+  /**\n+   * Prepare a SQL string, returning a statement you can execute.\n+   * E.g. `const stmt = db.prepare(\"SELECT * FROM todos WHERE id=?\");`\n+   */\n+  prepare(sql: string): PreparedStatement;\n+\n+  /**\n+   * Check if the database is in a transaction.\n+   */\n+  isInTransaction(): boolean;\n+}\n+\n+type SQLitePreparedStatements = {\n+  begin: PreparedStatement;\n+  beginImmediate: PreparedStatement;\n+  commit: PreparedStatement;\n+  rollback: PreparedStatement;\n+\n+  savepoint: PreparedStatement;\n+  release: PreparedStatement;\n+\n+  get: PreparedStatement;\n+  put: PreparedStatement;\n+  del: PreparedStatement;\n+};\n+\n+const getPreparedStatementsForSQLiteDatabase = (\n+  db: SQLiteDatabase,\n+): SQLitePreparedStatements => ({\n+  begin: db.prepare('BEGIN'),\n+  beginImmediate: db.prepare('BEGIN IMMEDIATE'),\n+  commit: db.prepare('COMMIT'),\n+  rollback: db.prepare('ROLLBACK'),\n+\n+  // Similar to https://github.com/WiseLibs/better-sqlite3/blob/674ce6be68a26742d9e24f8672da7888cea0aebb/lib/methods/transaction.js#L35-L39\n+  savepoint: db.prepare('SAVEPOINT `\\t_rc.\\t`'),\n+  release: db.prepare('RELEASE `\\t_rc.\\t`'),\n+\n+  get: db.prepare('SELECT value FROM entry WHERE key = ?'),\n+  put: db.prepare('INSERT OR REPLACE INTO entry (key, value) VALUES (?, ?)'),\n+  del: db.prepare('DELETE FROM entry WHERE key = ?'),\n+});\n+\n+const rwLocks = new Map<string, RWLock>();",
        "comment_created_at": "2025-08-01T02:01:33+00:00",
        "comment_author": "aboodman",
        "comment_body": "It's unfortunate to need multiple levels of locking but I guess it is needed so we dont' have to create a connection per read/write.",
        "pr_file_module": null
      },
      {
        "comment_id": "2246730754",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4669,
        "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
        "discussion_id": "2246724954",
        "commented_code": "@@ -0,0 +1,376 @@\n+import {RWLock} from '@rocicorp/lock';\n+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {\n+  promiseUndefined,\n+  promiseVoid,\n+} from '../../../shared/src/resolved-promises.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Read, Store, Write} from './store.ts';\n+\n+/**\n+ * A SQLite prepared statement.\n+ *\n+ * `run` executes the statement with optional parameters.\n+ * `all` executes the statement and returns the result rows.\n+ * `finalize` releases the statement.\n+ */\n+export interface PreparedStatement {\n+  run(...params: unknown[]): void;\n+  all<T>(...params: unknown[]): T[];\n+  finalize(): void;\n+}\n+\n+export interface SQLiteDatabase {\n+  /**\n+   * Close the database connection.\n+   */\n+  close(): void;\n+\n+  /**\n+   * Destroy or delete the database (e.g. delete file).\n+   */\n+  destroy(): void;\n+\n+  /**\n+   * Prepare a SQL string, returning a statement you can execute.\n+   * E.g. `const stmt = db.prepare(\"SELECT * FROM todos WHERE id=?\");`\n+   */\n+  prepare(sql: string): PreparedStatement;\n+\n+  /**\n+   * Check if the database is in a transaction.\n+   */\n+  isInTransaction(): boolean;\n+}\n+\n+type SQLitePreparedStatements = {\n+  begin: PreparedStatement;\n+  beginImmediate: PreparedStatement;\n+  commit: PreparedStatement;\n+  rollback: PreparedStatement;\n+\n+  savepoint: PreparedStatement;\n+  release: PreparedStatement;\n+\n+  get: PreparedStatement;\n+  put: PreparedStatement;\n+  del: PreparedStatement;\n+};\n+\n+const getPreparedStatementsForSQLiteDatabase = (\n+  db: SQLiteDatabase,\n+): SQLitePreparedStatements => ({\n+  begin: db.prepare('BEGIN'),\n+  beginImmediate: db.prepare('BEGIN IMMEDIATE'),\n+  commit: db.prepare('COMMIT'),\n+  rollback: db.prepare('ROLLBACK'),\n+\n+  // Similar to https://github.com/WiseLibs/better-sqlite3/blob/674ce6be68a26742d9e24f8672da7888cea0aebb/lib/methods/transaction.js#L35-L39\n+  savepoint: db.prepare('SAVEPOINT `\\t_rc.\\t`'),\n+  release: db.prepare('RELEASE `\\t_rc.\\t`'),\n+\n+  get: db.prepare('SELECT value FROM entry WHERE key = ?'),\n+  put: db.prepare('INSERT OR REPLACE INTO entry (key, value) VALUES (?, ?)'),\n+  del: db.prepare('DELETE FROM entry WHERE key = ?'),\n+});\n+\n+const rwLocks = new Map<string, RWLock>();",
        "comment_created_at": "2025-08-01T02:08:27+00:00",
        "comment_author": "aboodman",
        "comment_body": "I do not think we need a global map of locks though. Each SQLiteStore can own a connection to SQLite which uses SQLite's built-in file based locking. We don't expect lots of instances of SQLiteStore for the same name (or really any?) in the same js context. Each SQLiteStore can then also own a RWLock for in-memory queuing.",
        "pr_file_module": null
      },
      {
        "comment_id": "2246874709",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4669,
        "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
        "discussion_id": "2246724954",
        "commented_code": "@@ -0,0 +1,376 @@\n+import {RWLock} from '@rocicorp/lock';\n+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {\n+  promiseUndefined,\n+  promiseVoid,\n+} from '../../../shared/src/resolved-promises.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Read, Store, Write} from './store.ts';\n+\n+/**\n+ * A SQLite prepared statement.\n+ *\n+ * `run` executes the statement with optional parameters.\n+ * `all` executes the statement and returns the result rows.\n+ * `finalize` releases the statement.\n+ */\n+export interface PreparedStatement {\n+  run(...params: unknown[]): void;\n+  all<T>(...params: unknown[]): T[];\n+  finalize(): void;\n+}\n+\n+export interface SQLiteDatabase {\n+  /**\n+   * Close the database connection.\n+   */\n+  close(): void;\n+\n+  /**\n+   * Destroy or delete the database (e.g. delete file).\n+   */\n+  destroy(): void;\n+\n+  /**\n+   * Prepare a SQL string, returning a statement you can execute.\n+   * E.g. `const stmt = db.prepare(\"SELECT * FROM todos WHERE id=?\");`\n+   */\n+  prepare(sql: string): PreparedStatement;\n+\n+  /**\n+   * Check if the database is in a transaction.\n+   */\n+  isInTransaction(): boolean;\n+}\n+\n+type SQLitePreparedStatements = {\n+  begin: PreparedStatement;\n+  beginImmediate: PreparedStatement;\n+  commit: PreparedStatement;\n+  rollback: PreparedStatement;\n+\n+  savepoint: PreparedStatement;\n+  release: PreparedStatement;\n+\n+  get: PreparedStatement;\n+  put: PreparedStatement;\n+  del: PreparedStatement;\n+};\n+\n+const getPreparedStatementsForSQLiteDatabase = (\n+  db: SQLiteDatabase,\n+): SQLitePreparedStatements => ({\n+  begin: db.prepare('BEGIN'),\n+  beginImmediate: db.prepare('BEGIN IMMEDIATE'),\n+  commit: db.prepare('COMMIT'),\n+  rollback: db.prepare('ROLLBACK'),\n+\n+  // Similar to https://github.com/WiseLibs/better-sqlite3/blob/674ce6be68a26742d9e24f8672da7888cea0aebb/lib/methods/transaction.js#L35-L39\n+  savepoint: db.prepare('SAVEPOINT `\\t_rc.\\t`'),\n+  release: db.prepare('RELEASE `\\t_rc.\\t`'),\n+\n+  get: db.prepare('SELECT value FROM entry WHERE key = ?'),\n+  put: db.prepare('INSERT OR REPLACE INTO entry (key, value) VALUES (?, ?)'),\n+  del: db.prepare('DELETE FROM entry WHERE key = ?'),\n+});\n+\n+const rwLocks = new Map<string, RWLock>();",
        "comment_created_at": "2025-08-01T04:34:12+00:00",
        "comment_author": "0xcadams",
        "comment_body": "Yeah that makes sense. This was for safety but I will remove if there's that guarantee. Yeah, exactly, the alternative was spinning up many connections.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1206080237",
    "pr_number": 546,
    "pr_file": "packages/reflect/src/client/metrics.ts",
    "created_at": "2023-05-25T23:12:41+00:00",
    "commented_code": "export const REPORT_INTERVAL_MS = 5_000;\n \n-type MetricsReporter = (metrics: Series[]) => MaybePromise<void>;\n-\n-export type MetricManagerOptions = {\n-  reportIntervalMs: number;\n-  host: string;\n-  source: string;\n-  reporter: MetricsReporter;\n-  lc: Promise<LogContext>;\n-};\n-\n-/**\n- * MetricManager keeps track of the set of metrics in use and flushes them\n- * to a format suitable for reporting.\n- */\n-export class MetricManager {\n-  private _reportIntervalMs: number;\n-  private _host: string;\n-  private _reporter: MetricsReporter;\n-  private _lc: Promise<LogContext>;\n-  private _timerID: number | null;\n-\n-  constructor(opts: MetricManagerOptions) {\n-    this._reportIntervalMs = opts.reportIntervalMs;\n-    this._host = opts.host;\n-    this._reporter = opts.reporter;\n-    this._lc = opts.lc;\n-\n-    this.tags.push(`source:${opts.source}`);\n-\n-    this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n-\n-    this._timerID = setInterval(() => {\n-      void this.flush();\n-    }, this._reportIntervalMs);\n-  }\n-\n-  private _metrics: Flushable[] = [];\n-\n+// We use Gauges to sample at the client. If we are interested in tracking\n+// a metric value *per client*, the client can note the latest value in\n+// a Gauge metric. The metric is periodically reported via Reporter. On the\n+// server, we graph the value of the metric rolled up over the periodic\n+// reporting period, that is, counted over a span of time equal to the\n+// reporting period. The result is ~one point per client per reporting\n+// period.\n+export const ClientMetrics = {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1206080237",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 546,
        "pr_file": "packages/reflect/src/client/metrics.ts",
        "discussion_id": "1206080237",
        "commented_code": "@@ -14,44 +13,14 @@ export const DID_NOT_CONNECT_VALUE = 100 * 1000;\n \n export const REPORT_INTERVAL_MS = 5_000;\n \n-type MetricsReporter = (metrics: Series[]) => MaybePromise<void>;\n-\n-export type MetricManagerOptions = {\n-  reportIntervalMs: number;\n-  host: string;\n-  source: string;\n-  reporter: MetricsReporter;\n-  lc: Promise<LogContext>;\n-};\n-\n-/**\n- * MetricManager keeps track of the set of metrics in use and flushes them\n- * to a format suitable for reporting.\n- */\n-export class MetricManager {\n-  private _reportIntervalMs: number;\n-  private _host: string;\n-  private _reporter: MetricsReporter;\n-  private _lc: Promise<LogContext>;\n-  private _timerID: number | null;\n-\n-  constructor(opts: MetricManagerOptions) {\n-    this._reportIntervalMs = opts.reportIntervalMs;\n-    this._host = opts.host;\n-    this._reporter = opts.reporter;\n-    this._lc = opts.lc;\n-\n-    this.tags.push(`source:${opts.source}`);\n-\n-    this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n-\n-    this._timerID = setInterval(() => {\n-      void this.flush();\n-    }, this._reportIntervalMs);\n-  }\n-\n-  private _metrics: Flushable[] = [];\n-\n+// We use Gauges to sample at the client. If we are interested in tracking\n+// a metric value *per client*, the client can note the latest value in\n+// a Gauge metric. The metric is periodically reported via Reporter. On the\n+// server, we graph the value of the metric rolled up over the periodic\n+// reporting period, that is, counted over a span of time equal to the\n+// reporting period. The result is ~one point per client per reporting\n+// period.\n+export const ClientMetrics = {",
        "comment_created_at": "2023-05-25T23:12:41+00:00",
        "comment_author": "aboodman",
        "comment_body": "Only types and classes should start with an initial capital. This is an object value, so the naming should be `clientMetrics`. Surprised eslint didn't complain about this @arv.\r\n\r\nMore importantly we just can't have any global state in the server due to the issues Greg has been fighting with. Everything has to be properly owned by one of the durable object clases, or local state owned by the worker fetch function. This global state here will get confused because it will be shared btwn the authdo, worker, and roomdo (and multiple instances of each).\r\n\r\nThese metrics need to be fields (directly or indirectly) of the room/authdo classes, as does the metrics manager -- see notes further in this PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "1206095495",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 546,
        "pr_file": "packages/reflect/src/client/metrics.ts",
        "discussion_id": "1206080237",
        "commented_code": "@@ -14,44 +13,14 @@ export const DID_NOT_CONNECT_VALUE = 100 * 1000;\n \n export const REPORT_INTERVAL_MS = 5_000;\n \n-type MetricsReporter = (metrics: Series[]) => MaybePromise<void>;\n-\n-export type MetricManagerOptions = {\n-  reportIntervalMs: number;\n-  host: string;\n-  source: string;\n-  reporter: MetricsReporter;\n-  lc: Promise<LogContext>;\n-};\n-\n-/**\n- * MetricManager keeps track of the set of metrics in use and flushes them\n- * to a format suitable for reporting.\n- */\n-export class MetricManager {\n-  private _reportIntervalMs: number;\n-  private _host: string;\n-  private _reporter: MetricsReporter;\n-  private _lc: Promise<LogContext>;\n-  private _timerID: number | null;\n-\n-  constructor(opts: MetricManagerOptions) {\n-    this._reportIntervalMs = opts.reportIntervalMs;\n-    this._host = opts.host;\n-    this._reporter = opts.reporter;\n-    this._lc = opts.lc;\n-\n-    this.tags.push(`source:${opts.source}`);\n-\n-    this.timeToConnectMs.set(DID_NOT_CONNECT_VALUE);\n-\n-    this._timerID = setInterval(() => {\n-      void this.flush();\n-    }, this._reportIntervalMs);\n-  }\n-\n-  private _metrics: Flushable[] = [];\n-\n+// We use Gauges to sample at the client. If we are interested in tracking\n+// a metric value *per client*, the client can note the latest value in\n+// a Gauge metric. The metric is periodically reported via Reporter. On the\n+// server, we graph the value of the metric rolled up over the periodic\n+// reporting period, that is, counted over a span of time equal to the\n+// reporting period. The result is ~one point per client per reporting\n+// period.\n+export const ClientMetrics = {",
        "comment_created_at": "2023-05-25T23:49:54+00:00",
        "comment_author": "aboodman",
        "comment_body": "OK I'm an idiot this is in the client.\r\n\r\nThinking...\r\n\r\nI think this still doesn't work. We can (and usually do) have multiple Reflect clients running in a page at the same time. I believe they will share these constants leading to wackiness. Each `Reflect` instance should have its own copy of its metrics (and I would probably say its own `MetricsManager` with its own flush loop, though that's debatable).",
        "pr_file_module": null
      }
    ]
  }
]