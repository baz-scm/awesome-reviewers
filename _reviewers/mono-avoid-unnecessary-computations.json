[
  {
    "discussion_id": "2125339223",
    "pr_number": 4454,
    "pr_file": "packages/zero-cache/src/services/view-syncer/pipeline-driver.ts",
    "created_at": "2025-06-04T02:23:24+00:00",
    "commented_code": "switch (type) {\n         case 'add':\n         case 'remove': {\n-          yield* this.#streamNodes(queryHash, schema, type, [change.node]);",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2125339223",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4454,
        "pr_file": "packages/zero-cache/src/services/view-syncer/pipeline-driver.ts",
        "discussion_id": "2125339223",
        "commented_code": "@@ -571,7 +571,9 @@ class Streamer {\n       switch (type) {\n         case 'add':\n         case 'remove': {\n-          yield* this.#streamNodes(queryHash, schema, type, [change.node]);",
        "comment_created_at": "2025-06-04T02:23:24+00:00",
        "comment_author": "aboodman",
        "comment_body": "Are you sure this is even necessary? I haven't looked at impl of `streamNodes` but in similar code I remember realizing/proving to myself that the sql execute never even happens if nobody ever iterates the first time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2125340808",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4454,
        "pr_file": "packages/zero-cache/src/services/view-syncer/pipeline-driver.ts",
        "discussion_id": "2125339223",
        "commented_code": "@@ -571,7 +571,9 @@ class Streamer {\n       switch (type) {\n         case 'add':\n         case 'remove': {\n-          yield* this.#streamNodes(queryHash, schema, type, [change.node]);",
        "comment_created_at": "2025-06-04T02:24:22+00:00",
        "comment_author": "aboodman",
        "comment_body": "That's why, for example, we just went ahead and setup the child relationships for each row \"eagerly\". Because we knew the sql statement to actually get them would never happen unless some downstream operator needed them.",
        "pr_file_module": null
      },
      {
        "comment_id": "2126559362",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4454,
        "pr_file": "packages/zero-cache/src/services/view-syncer/pipeline-driver.ts",
        "discussion_id": "2125339223",
        "commented_code": "@@ -571,7 +571,9 @@ class Streamer {\n       switch (type) {\n         case 'add':\n         case 'remove': {\n-          yield* this.#streamNodes(queryHash, schema, type, [change.node]);",
        "comment_created_at": "2025-06-04T13:08:29+00:00",
        "comment_author": "tantaman",
        "comment_body": "This might avoid the work of creating the query plan since we do not prepare the statement.\r\n\r\n@grgbkr - was there a measurable difference with this change?",
        "pr_file_module": null
      },
      {
        "comment_id": "2126563014",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4454,
        "pr_file": "packages/zero-cache/src/services/view-syncer/pipeline-driver.ts",
        "discussion_id": "2125339223",
        "commented_code": "@@ -571,7 +571,9 @@ class Streamer {\n       switch (type) {\n         case 'add':\n         case 'remove': {\n-          yield* this.#streamNodes(queryHash, schema, type, [change.node]);",
        "comment_created_at": "2025-06-04T13:10:08+00:00",
        "comment_author": "tantaman",
        "comment_body": "I checked in some example \"notebook style\" analyses that explore perf if you need to gather metrics on this.\r\n\r\nhttps://github.com/rocicorp/mono/blob/57a9aa52674e6e12aeb3f84007bf1e0fa0fbf997/packages/zql-benchmarks/src/frontend-analysis.pg-test.ts#L31-L40",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1941605131",
    "pr_number": 3702,
    "pr_file": "packages/zero-solid/src/solid-view.ts",
    "created_at": "2025-02-04T17:33:01+00:00",
    "commented_code": "}\n }\n \n-function materializeNodesRelationships(node: Node): Node {\n+function materializeNodeRelationships(node: Node): Node {\n   return {\n     row: node.row,\n     relationships: Object.fromEntries(\n       Object.entries(node.relationships).map(([relationship, stream]) => {\n-        const drained = [...stream()].map(materializeNodesRelationships);\n-        return [relationship, () => drained];\n+        const materialized = [...stream()].map(materializeNodeRelationships);",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1941605131",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3702,
        "pr_file": "packages/zero-solid/src/solid-view.ts",
        "discussion_id": "1941605131",
        "commented_code": "@@ -164,18 +180,23 @@ function materializeRelationships(change: Change): ViewChange {\n   }\n }\n \n-function materializeNodesRelationships(node: Node): Node {\n+function materializeNodeRelationships(node: Node): Node {\n   return {\n     row: node.row,\n     relationships: Object.fromEntries(\n       Object.entries(node.relationships).map(([relationship, stream]) => {\n-        const drained = [...stream()].map(materializeNodesRelationships);\n-        return [relationship, () => drained];\n+        const materialized = [...stream()].map(materializeNodeRelationships);",
        "comment_created_at": "2025-02-04T17:33:01+00:00",
        "comment_author": "arv",
        "comment_body": "This function was the one that stood out to me.\r\n\r\nIf you write in a non functional style there are no extra arrays created.\r\n\r\n```ts\r\nexport function materializeNodeRelationships(node: Node): Node {\r\n  const relationships: Record<string, () => Stream<Node>> = {};\r\n  for (const relationship in node.relationships) {\r\n    const materialized: Node[] = [];\r\n    for (const n of node.relationships[relationship]()) {\r\n      materialized.push(materializeNodeRelationships(n));\r\n    }\r\n    relationships[relationship] = () => materialized;\r\n  }\r\n  return {\r\n    row: node.row,\r\n    relationships,\r\n  };\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1941692171",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3702,
        "pr_file": "packages/zero-solid/src/solid-view.ts",
        "discussion_id": "1941605131",
        "commented_code": "@@ -164,18 +180,23 @@ function materializeRelationships(change: Change): ViewChange {\n   }\n }\n \n-function materializeNodesRelationships(node: Node): Node {\n+function materializeNodeRelationships(node: Node): Node {\n   return {\n     row: node.row,\n     relationships: Object.fromEntries(\n       Object.entries(node.relationships).map(([relationship, stream]) => {\n-        const drained = [...stream()].map(materializeNodesRelationships);\n-        return [relationship, () => drained];\n+        const materialized = [...stream()].map(materializeNodeRelationships);",
        "comment_created_at": "2025-02-04T18:20:22+00:00",
        "comment_author": "grgbkr",
        "comment_body": "doing a quick follow up for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "1941697117",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3702,
        "pr_file": "packages/zero-solid/src/solid-view.ts",
        "discussion_id": "1941605131",
        "commented_code": "@@ -164,18 +180,23 @@ function materializeRelationships(change: Change): ViewChange {\n   }\n }\n \n-function materializeNodesRelationships(node: Node): Node {\n+function materializeNodeRelationships(node: Node): Node {\n   return {\n     row: node.row,\n     relationships: Object.fromEntries(\n       Object.entries(node.relationships).map(([relationship, stream]) => {\n-        const drained = [...stream()].map(materializeNodesRelationships);\n-        return [relationship, () => drained];\n+        const materialized = [...stream()].map(materializeNodeRelationships);",
        "comment_created_at": "2025-02-04T18:24:43+00:00",
        "comment_author": "grgbkr",
        "comment_body": "https://github.com/rocicorp/mono/pull/3703",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1857477345",
    "pr_number": 3101,
    "pr_file": "packages/zql/src/ivm/memory-source.ts",
    "created_at": "2024-11-25T23:40:55+00:00",
    "commented_code": "}\n     }\n \n-    const matchesConstraint = req.constraint\n-      ? (row: Row) => constraintMatchesRow(req.constraint!, row)\n+    const {constraint} = req;\n+    const matchesConstraint = constraint\n+      ? (row: Row) => constraintMatchesRow(constraint, row)\n       : (_: Row) => true;\n \n-    const matchesConstraintAndFilters = (row: Row) =>\n-      matchesConstraint(row) && (conn.filters?.predicate(row) ?? true);\n+    const predicate = conn.filters?.predicate;\n+    const matchesConstraintAndFilters = predicate\n+      ? (row: Row) => matchesConstraint(row) && predicate(row)\n+      : (row: Row) => matchesConstraint(row);",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1857477345",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3101,
        "pr_file": "packages/zql/src/ivm/memory-source.ts",
        "discussion_id": "1857477345",
        "commented_code": "@@ -256,12 +256,15 @@ export class MemorySource implements Source {\n       }\n     }\n \n-    const matchesConstraint = req.constraint\n-      ? (row: Row) => constraintMatchesRow(req.constraint!, row)\n+    const {constraint} = req;\n+    const matchesConstraint = constraint\n+      ? (row: Row) => constraintMatchesRow(constraint, row)\n       : (_: Row) => true;\n \n-    const matchesConstraintAndFilters = (row: Row) =>\n-      matchesConstraint(row) && (conn.filters?.predicate(row) ?? true);\n+    const predicate = conn.filters?.predicate;\n+    const matchesConstraintAndFilters = predicate\n+      ? (row: Row) => matchesConstraint(row) && predicate(row)\n+      : (row: Row) => matchesConstraint(row);",
        "comment_created_at": "2024-11-25T23:40:55+00:00",
        "comment_author": "grgbkr",
        "comment_body": "```\r\npredicate\r\n      ? (row: Row) => matchesConstraint(row) && predicate(row)\r\n      : matchesConstraint;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2248560264",
    "pr_number": 4677,
    "pr_file": "packages/zero-client/src/client/mutation-tracker.ts",
    "created_at": "2025-08-01T18:02:39+00:00",
    "commented_code": "/**\n    * Used when zero-cache pokes down mutation results.\n    */\n-  processMutationResponses(patches: MutationPatch[]) {\n-    try {\n-      for (const patch of patches) {\n-        if (patch.mutation.id.clientID !== this.#clientID) {\n-          continue; // Mutation for a different client. We will not have its promise.\n-        }\n-\n-        if ('error' in patch.mutation.result) {\n-          this.#processMutationError(patch.mutation.id, patch.mutation.result);\n-        } else {\n-          this.#processMutationOk(patch.mutation.id, patch.mutation.result);\n+  #processMutationResponses(diffs: NoIndexDiff): void {\n+    const clientID = must(this.#clientID);\n+    let largestLmid = 0;\n+    for (const diff of diffs) {\n+      const mutationID = Number(\n+        diff.key.slice(MUTATIONS_KEY_PREFIX.length + clientID.length + 1),\n+      );\n+      assert(\n+        !isNaN(mutationID),\n+        `MutationTracker received a diff with an invalid mutation ID: ${diff.key}`,\n+      );\n+      largestLmid = Math.max(largestLmid, mutationID);\n+      switch (diff.op) {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2248560264",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4677,
        "pr_file": "packages/zero-client/src/client/mutation-tracker.ts",
        "discussion_id": "2248560264",
        "commented_code": "@@ -110,25 +115,40 @@ export class MutationTracker {\n   /**\n    * Used when zero-cache pokes down mutation results.\n    */\n-  processMutationResponses(patches: MutationPatch[]) {\n-    try {\n-      for (const patch of patches) {\n-        if (patch.mutation.id.clientID !== this.#clientID) {\n-          continue; // Mutation for a different client. We will not have its promise.\n-        }\n-\n-        if ('error' in patch.mutation.result) {\n-          this.#processMutationError(patch.mutation.id, patch.mutation.result);\n-        } else {\n-          this.#processMutationOk(patch.mutation.id, patch.mutation.result);\n+  #processMutationResponses(diffs: NoIndexDiff): void {\n+    const clientID = must(this.#clientID);\n+    let largestLmid = 0;\n+    for (const diff of diffs) {\n+      const mutationID = Number(\n+        diff.key.slice(MUTATIONS_KEY_PREFIX.length + clientID.length + 1),\n+      );\n+      assert(\n+        !isNaN(mutationID),\n+        `MutationTracker received a diff with an invalid mutation ID: ${diff.key}`,\n+      );\n+      largestLmid = Math.max(largestLmid, mutationID);\n+      switch (diff.op) {",
        "comment_created_at": "2025-08-01T18:02:39+00:00",
        "comment_author": "grgbkr",
        "comment_body": "I think it would be ideal if mutations resolved in order.  Seems like a nice invariant that will make debugging issues easier. \r\n\r\nSo we'd need to sort these by lmid, and then resolve gaps between them as we loop through them.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1701480654",
    "pr_number": 2103,
    "pr_file": "packages/zql/src/iterable-explore.test.ts",
    "created_at": "2024-08-02T08:16:33+00:00",
    "commented_code": "+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;\n+  [event]: Event;\n+  [children: string]: Iterable<Entry>;\n+};\n+\n+const issueSource: Entry<Issue>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      title: 'issue 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      title: 'issue 2',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type Comment = {id: number; issueId: number; text: string};\n+const commentSource: Entry<Comment>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      issueId: 1,\n+      text: 'comment 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      issueId: 1,\n+      text: 'comment 2',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 3,\n+      issueId: 2,\n+      text: 'comment 3',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type CommentRevision = {id: number; commentId: number; text: string};\n+const commentRevisionSource: Entry<CommentRevision>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      commentId: 1,\n+      text: 'comment revision 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      commentId: 1,\n+      text: 'comment revision 2',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 3,\n+      commentId: 2,\n+      text: 'comment revision 3',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type ResultType = {\n+  [table: string]: JSONObject | ResultType;\n+}[];\n+\n+function* filter(\n+  path: (string | typeof node)[],\n+  iterable: Iterable<Entry>,\n+  cb: (v: unknown) => boolean,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  for (const row of iterable) {\n+    if (tail.length === 0) {\n+      if (cb(row[head])) {\n+        yield row;\n+      }\n+    } else {\n+      yield {\n+        ...row,\n+        [head]: filter(tail, row[head] as Iterable<Entry>, cb),\n+      } as Entry;\n+    }\n+  }\n+}\n+\n+function* map(\n+  path: (string | typeof node)[],\n+  iterable: Iterable<Entry>,\n+  cb: (v: unknown) => unknown,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  for (const row of iterable) {\n+    if (tail.length === 0) {\n+      yield {\n+        ...row,\n+        [head]: cb(row[head]) as TODO,\n+      };\n+    } else {\n+      yield {\n+        ...row,\n+        [head]: map(tail, row[head] as Iterable<Entry>, cb),\n+      };\n+    }\n+  }\n+}\n+\n+function* loopJoin(\n+  left: Iterable<Entry>,\n+  right: Iterable<Entry>,\n+  leftItemPath: (string | typeof node)[],\n+  insertAs: string,\n+  cb: (left: unknown, right: unknown) => boolean,\n+): IterableIterator<Entry> {\n+  // We only ever get the parent most thing of the right, correct?\n+  // I think so.. since a query with a sub-query is a leftJoin(parent, child).\n+  // So we're always operating on the top level result of the child, right?\n+\n+  const [leftHead, ...leftTail] = leftItemPath;\n+  for (const leftRow of left) {\n+    if (leftTail.length === 0) {\n+      // nest the right into the left\n+      yield {\n+        ...leftRow,\n+        [insertAs]: (function* () {\n+          for (const rightRow of right) {\n+            if (cb(leftRow[leftHead], rightRow[node])) {\n+              yield rightRow;\n+            }\n+          }\n+        })(),\n+      } as Entry;\n+    } else {\n+      yield {\n+        ...leftRow,\n+        [leftHead]: loopJoin(\n+          leftRow[leftHead] as Iterable<Entry>,\n+          right,\n+          leftTail,\n+          insertAs,\n+          cb,\n+        ),\n+      } as Entry;\n+    }\n+  }\n+}\n+\n+function* topk(\n+  items: Iterable<Entry>,\n+  path: string[],\n+  comparator: (l: unknown, r: unknown) => number,\n+  k: number,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  if (head === undefined) {\n+    const sorted = [...items].sort(comparator);\n+    for (let i = 0; i < k; i++) {\n+      yield sorted[i];\n+    }",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1701480654",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701480654",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;\n+  [event]: Event;\n+  [children: string]: Iterable<Entry>;\n+};\n+\n+const issueSource: Entry<Issue>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      title: 'issue 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      title: 'issue 2',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type Comment = {id: number; issueId: number; text: string};\n+const commentSource: Entry<Comment>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      issueId: 1,\n+      text: 'comment 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      issueId: 1,\n+      text: 'comment 2',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 3,\n+      issueId: 2,\n+      text: 'comment 3',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type CommentRevision = {id: number; commentId: number; text: string};\n+const commentRevisionSource: Entry<CommentRevision>[] = [\n+  {\n+    [node]: {\n+      id: 1,\n+      commentId: 1,\n+      text: 'comment revision 1',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 2,\n+      commentId: 1,\n+      text: 'comment revision 2',\n+    },\n+    [event]: ADD,\n+  },\n+  {\n+    [node]: {\n+      id: 3,\n+      commentId: 2,\n+      text: 'comment revision 3',\n+    },\n+    [event]: ADD,\n+  },\n+];\n+\n+type ResultType = {\n+  [table: string]: JSONObject | ResultType;\n+}[];\n+\n+function* filter(\n+  path: (string | typeof node)[],\n+  iterable: Iterable<Entry>,\n+  cb: (v: unknown) => boolean,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  for (const row of iterable) {\n+    if (tail.length === 0) {\n+      if (cb(row[head])) {\n+        yield row;\n+      }\n+    } else {\n+      yield {\n+        ...row,\n+        [head]: filter(tail, row[head] as Iterable<Entry>, cb),\n+      } as Entry;\n+    }\n+  }\n+}\n+\n+function* map(\n+  path: (string | typeof node)[],\n+  iterable: Iterable<Entry>,\n+  cb: (v: unknown) => unknown,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  for (const row of iterable) {\n+    if (tail.length === 0) {\n+      yield {\n+        ...row,\n+        [head]: cb(row[head]) as TODO,\n+      };\n+    } else {\n+      yield {\n+        ...row,\n+        [head]: map(tail, row[head] as Iterable<Entry>, cb),\n+      };\n+    }\n+  }\n+}\n+\n+function* loopJoin(\n+  left: Iterable<Entry>,\n+  right: Iterable<Entry>,\n+  leftItemPath: (string | typeof node)[],\n+  insertAs: string,\n+  cb: (left: unknown, right: unknown) => boolean,\n+): IterableIterator<Entry> {\n+  // We only ever get the parent most thing of the right, correct?\n+  // I think so.. since a query with a sub-query is a leftJoin(parent, child).\n+  // So we're always operating on the top level result of the child, right?\n+\n+  const [leftHead, ...leftTail] = leftItemPath;\n+  for (const leftRow of left) {\n+    if (leftTail.length === 0) {\n+      // nest the right into the left\n+      yield {\n+        ...leftRow,\n+        [insertAs]: (function* () {\n+          for (const rightRow of right) {\n+            if (cb(leftRow[leftHead], rightRow[node])) {\n+              yield rightRow;\n+            }\n+          }\n+        })(),\n+      } as Entry;\n+    } else {\n+      yield {\n+        ...leftRow,\n+        [leftHead]: loopJoin(\n+          leftRow[leftHead] as Iterable<Entry>,\n+          right,\n+          leftTail,\n+          insertAs,\n+          cb,\n+        ),\n+      } as Entry;\n+    }\n+  }\n+}\n+\n+function* topk(\n+  items: Iterable<Entry>,\n+  path: string[],\n+  comparator: (l: unknown, r: unknown) => number,\n+  k: number,\n+): IterableIterator<Entry> {\n+  const [head, ...tail] = path;\n+  if (head === undefined) {\n+    const sorted = [...items].sort(comparator);\n+    for (let i = 0; i < k; i++) {\n+      yield sorted[i];\n+    }",
        "comment_created_at": "2024-08-02T08:16:33+00:00",
        "comment_author": "arv",
        "comment_body": "or `yield* sorted.slice(0, k)`",
        "pr_file_module": null
      }
    ]
  }
]