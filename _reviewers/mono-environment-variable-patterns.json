[
  {
    "discussion_id": "2211700117",
    "pr_number": 4624,
    "pr_file": "apps/zbugs/vite.config.ts",
    "created_at": "2025-07-16T22:04:52+00:00",
    "commented_code": "import react from '@vitejs/plugin-react';\n-import {defineConfig, type ViteDevServer} from 'vite';\n+import {defineConfig, loadEnv, type ViteDevServer} from 'vite';",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2211700117",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4624,
        "pr_file": "apps/zbugs/vite.config.ts",
        "discussion_id": "2211700117",
        "commented_code": "@@ -1,5 +1,5 @@\n import react from '@vitejs/plugin-react';\n-import {defineConfig, type ViteDevServer} from 'vite';\n+import {defineConfig, loadEnv, type ViteDevServer} from 'vite';",
        "comment_created_at": "2025-07-16T22:04:52+00:00",
        "comment_author": "aboodman",
        "comment_body": "It should not be necessary to load env vars here. See how `DISCORD_WEBHOOK_URL` works? It's not loaded here but is still accessible from `discord.ts`. Just using `process.env` inside the `upload.ts` file should be sufficient.\r\n\r\nAlso please add these env vars to `.env.example`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012616948",
    "pr_number": 4093,
    "pr_file": "packages/zero/src/zero-cache-dev.ts",
    "created_at": "2025-03-25T17:41:32+00:00",
    "commented_code": "} from '../../zero-cache/src/config/zero-config.ts';\n import {deployPermissionsOptions} from '../../zero-cache/src/scripts/permissions.ts';\n \n-const deployPermissionsScript = 'zero-deploy-permissions';\n+const deployPermissionsScript = 'zero-deploy-permissions -p shared/schema.ts';",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2012616948",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4093,
        "pr_file": "packages/zero/src/zero-cache-dev.ts",
        "discussion_id": "2012616948",
        "commented_code": "@@ -13,7 +13,7 @@ import {\n } from '../../zero-cache/src/config/zero-config.ts';\n import {deployPermissionsOptions} from '../../zero-cache/src/scripts/permissions.ts';\n \n-const deployPermissionsScript = 'zero-deploy-permissions';\n+const deployPermissionsScript = 'zero-deploy-permissions -p shared/schema.ts';",
        "comment_created_at": "2025-03-25T17:41:32+00:00",
        "comment_author": "tantaman",
        "comment_body": "Should this change? `shared/schema.ts` is a zbugs specific path.",
        "pr_file_module": null
      },
      {
        "comment_id": "2013236329",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4093,
        "pr_file": "packages/zero/src/zero-cache-dev.ts",
        "discussion_id": "2012616948",
        "commented_code": "@@ -13,7 +13,7 @@ import {\n } from '../../zero-cache/src/config/zero-config.ts';\n import {deployPermissionsOptions} from '../../zero-cache/src/scripts/permissions.ts';\n \n-const deployPermissionsScript = 'zero-deploy-permissions';\n+const deployPermissionsScript = 'zero-deploy-permissions -p shared/schema.ts';",
        "comment_created_at": "2025-03-26T01:24:42+00:00",
        "comment_author": "darkgnotic",
        "comment_body": "Agree, this should be reverted.\r\n\r\nThe caller should instead pass in the environment variable `ZERO_SCHEMA_PATH=shared/schema.ts`",
        "pr_file_module": null
      },
      {
        "comment_id": "2014836486",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4093,
        "pr_file": "packages/zero/src/zero-cache-dev.ts",
        "discussion_id": "2012616948",
        "commented_code": "@@ -13,7 +13,7 @@ import {\n } from '../../zero-cache/src/config/zero-config.ts';\n import {deployPermissionsOptions} from '../../zero-cache/src/scripts/permissions.ts';\n \n-const deployPermissionsScript = 'zero-deploy-permissions';\n+const deployPermissionsScript = 'zero-deploy-permissions -p shared/schema.ts';",
        "comment_created_at": "2025-03-26T19:05:11+00:00",
        "comment_author": "cesara",
        "comment_body": "ok i'll fix in a seperate PR",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936545281",
    "pr_number": 3661,
    "pr_file": "prod/sst/sst.config.ts",
    "created_at": "2025-01-31T01:28:34+00:00",
    "commented_code": "+/* eslint-disable */\n+/// <reference path=\"./.sst/platform/config.d.ts\" />\n+import { readFileSync } from \"fs\";\n+// Load .env file\n+require(\"dotenv\").config();\n+\n+export default $config({\n+  app(input) {\n+    return {\n+      name: process.env.APP_NAME || \"zero\",\n+      removal: input?.stage === \"production\" ? \"retain\" : \"remove\",\n+      home: \"aws\",\n+      region: process.env.AWS_REGION || \"us-east-1\",\n+    };\n+  },\n+  async run() {\n+\n+\n+    const loadSchemaJson = () => {\n+      if (process.env.ZERO_SCHEMA_JSON) {\n+        return process.env.ZERO_SCHEMA_JSON;\n+      }\n+\n+      try {\n+        const schema = readFileSync(\"zero-schema.json\", \"utf8\");",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1936545281",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3661,
        "pr_file": "prod/sst/sst.config.ts",
        "discussion_id": "1936545281",
        "commented_code": "@@ -0,0 +1,203 @@\n+/* eslint-disable */\n+/// <reference path=\"./.sst/platform/config.d.ts\" />\n+import { readFileSync } from \"fs\";\n+// Load .env file\n+require(\"dotenv\").config();\n+\n+export default $config({\n+  app(input) {\n+    return {\n+      name: process.env.APP_NAME || \"zero\",\n+      removal: input?.stage === \"production\" ? \"retain\" : \"remove\",\n+      home: \"aws\",\n+      region: process.env.AWS_REGION || \"us-east-1\",\n+    };\n+  },\n+  async run() {\n+\n+\n+    const loadSchemaJson = () => {\n+      if (process.env.ZERO_SCHEMA_JSON) {\n+        return process.env.ZERO_SCHEMA_JSON;\n+      }\n+\n+      try {\n+        const schema = readFileSync(\"zero-schema.json\", \"utf8\");",
        "comment_created_at": "2025-01-31T01:28:34+00:00",
        "comment_author": "darkgnotic",
        "comment_body": "what's the intention here? is the idea that this deploy script would be run with a zero-schema.json in the same directory?",
        "pr_file_module": null
      },
      {
        "comment_id": "1936591431",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3661,
        "pr_file": "prod/sst/sst.config.ts",
        "discussion_id": "1936545281",
        "commented_code": "@@ -0,0 +1,203 @@\n+/* eslint-disable */\n+/// <reference path=\"./.sst/platform/config.d.ts\" />\n+import { readFileSync } from \"fs\";\n+// Load .env file\n+require(\"dotenv\").config();\n+\n+export default $config({\n+  app(input) {\n+    return {\n+      name: process.env.APP_NAME || \"zero\",\n+      removal: input?.stage === \"production\" ? \"retain\" : \"remove\",\n+      home: \"aws\",\n+      region: process.env.AWS_REGION || \"us-east-1\",\n+    };\n+  },\n+  async run() {\n+\n+\n+    const loadSchemaJson = () => {\n+      if (process.env.ZERO_SCHEMA_JSON) {\n+        return process.env.ZERO_SCHEMA_JSON;\n+      }\n+\n+      try {\n+        const schema = readFileSync(\"zero-schema.json\", \"utf8\");",
        "comment_created_at": "2025-01-31T02:19:48+00:00",
        "comment_author": "cesara",
        "comment_body": "ya the idea is that the sst deploy would read the zero-schema.json. in the same directory you are deploying from and use that value for the env variable. now that i think of it i should probably allow this to be an env variable also.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936546538",
    "pr_number": 3661,
    "pr_file": "prod/sst/sst.config.ts",
    "created_at": "2025-01-31T01:30:32+00:00",
    "commented_code": "+/* eslint-disable */\n+/// <reference path=\"./.sst/platform/config.d.ts\" />\n+import { readFileSync } from \"fs\";\n+// Load .env file\n+require(\"dotenv\").config();\n+\n+export default $config({\n+  app(input) {\n+    return {\n+      name: process.env.APP_NAME || \"zero\",\n+      removal: input?.stage === \"production\" ? \"retain\" : \"remove\",\n+      home: \"aws\",\n+      region: process.env.AWS_REGION || \"us-east-1\",\n+    };\n+  },\n+  async run() {\n+\n+\n+    const loadSchemaJson = () => {\n+      if (process.env.ZERO_SCHEMA_JSON) {\n+        return process.env.ZERO_SCHEMA_JSON;\n+      }\n+\n+      try {\n+        const schema = readFileSync(\"zero-schema.json\", \"utf8\");\n+        // Parse and stringify to ensure single line\n+        return JSON.stringify(JSON.parse(schema));\n+      } catch (error) {\n+        const e = error as Error;\n+        console.error(`Failed to read schema file: ${e.message}`);\n+        throw new Error(\n+          \"Schema must be provided via ZERO_SCHEMA_JSON env var or zero-schema.json file\",\n+        );\n+      }\n+    };\n+\n+    const schemaJson = loadSchemaJson();\n+\n+    // S3 Bucket\n+    const replicationBucket = new sst.aws.Bucket(`replication-bucket`, {\n+      public: false,\n+    });\n+\n+    // VPC Configuration\n+    const vpc = new sst.aws.Vpc(`vpc`, {\n+      az: 2,\n+    });\n+\n+    // ECS Cluster\n+    const cluster = new sst.aws.Cluster(`cluster`, {\n+      vpc,\n+      transform: {\n+        cluster: {\n+          settings: [\n+            {\n+              name: \"containerInsights\",\n+              value: \"enhanced\",\n+            },\n+          ],\n+        },\n+      },\n+    });\n+\n+    // Common environment variables\n+    const commonEnv = {\n+      AWS_REGION: process.env.AWS_REGION!,\n+      ZERO_UPSTREAM_DB: process.env.ZERO_UPSTREAM_DB!,\n+      ZERO_CVR_DB: process.env.ZERO_CVR_DB!,\n+      ZERO_CHANGE_DB: process.env.ZERO_CHANGE_DB!,\n+      ZERO_AUTH_SECRET: process.env.ZERO_AUTH_SECRET!,\n+      AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID!,\n+      AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY!,\n+      ZERO_SCHEMA_JSON: schemaJson,\n+      ZERO_LOG_FORMAT: \"json\",\n+      ZERO_REPLICA_FILE: \"sync-replica.db\",\n+      ZERO_LITESTREAM_BACKUP_URL: $interpolate`s3://${replicationBucket.name}/backup`,\n+      ZERO_IMAGE_URL:\n+        process.env.ZERO_IMAGE_URL ||\n+        `${process.env.AWS_ACCOUNT_ID}.dkr.ecr.${process.env.AWS_REGION}.amazonaws.com/${process.env.ECR_IMAGE_ZERO_CACHE}:latest`,\n+    };\n+\n+    if (!commonEnv.ZERO_IMAGE_URL) {\n+      throw new Error(\n+        \"ZERO_IMAGE_URL is required. Either provide it directly or ensure AWS_ACCOUNT_ID, AWS_REGION, and ECR_IMAGE_ZERO_CACHE are set.\",\n+      );\n+    }\n+\n+    // Replication Manager Service\n+    const replicationManager = cluster.addService(`replication-manager`, {\n+      cpu: \"2 vCPU\",\n+      memory: \"8 GB\",\n+      image: commonEnv.ZERO_IMAGE_URL,\n+      health: {\n+        command: [\"CMD-SHELL\", \"curl -f http://localhost:4849/ || exit 1\"],\n+        interval: \"5 seconds\",\n+        retries: 3,\n+        startPeriod: \"300 seconds\",\n+      },\n+      environment: {\n+        ...commonEnv,\n+        ZERO_CHANGE_MAX_CONNS: \"3\",\n+        ZERO_NUM_SYNC_WORKERS: \"0\",\n+      },\n+      logging: {\n+        retention: \"1 month\",\n+      },\n+      loadBalancer: {\n+        public: false,\n+        ports: [\n+          {\n+            listen: \"80/http\",\n+            forward: \"4849/http\",\n+          },\n+        ],\n+      },\n+      transform: {\n+        target: {\n+          healthCheck: {\n+            enabled: true,\n+            path: \"/keepalive\",\n+            protocol: \"HTTP\",\n+            interval: 5,\n+            healthyThreshold: 2,\n+            timeout: 3,\n+          },\n+        },\n+      },\n+    });\n+\n+    // View Syncer Service\n+    cluster.addService(`view-syncer`, {\n+      cpu: \"2 vCPU\",\n+      memory: \"8 GB\",\n+      image: commonEnv.ZERO_IMAGE_URL,\n+      health: {\n+        command: [\"CMD-SHELL\", \"curl -f http://localhost:4848/ || exit 1\"],\n+        interval: \"5 seconds\",\n+        retries: 3,\n+        startPeriod: \"300 seconds\",\n+      },\n+      environment: {\n+        ...commonEnv,\n+        ZERO_CHANGE_STREAMER_URI: replicationManager.url,\n+        ZERO_UPSTREAM_MAX_CONNS: \"15\",\n+        ZERO_CVR_MAX_CONNS: \"160\",",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1936546538",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3661,
        "pr_file": "prod/sst/sst.config.ts",
        "discussion_id": "1936546538",
        "commented_code": "@@ -0,0 +1,203 @@\n+/* eslint-disable */\n+/// <reference path=\"./.sst/platform/config.d.ts\" />\n+import { readFileSync } from \"fs\";\n+// Load .env file\n+require(\"dotenv\").config();\n+\n+export default $config({\n+  app(input) {\n+    return {\n+      name: process.env.APP_NAME || \"zero\",\n+      removal: input?.stage === \"production\" ? \"retain\" : \"remove\",\n+      home: \"aws\",\n+      region: process.env.AWS_REGION || \"us-east-1\",\n+    };\n+  },\n+  async run() {\n+\n+\n+    const loadSchemaJson = () => {\n+      if (process.env.ZERO_SCHEMA_JSON) {\n+        return process.env.ZERO_SCHEMA_JSON;\n+      }\n+\n+      try {\n+        const schema = readFileSync(\"zero-schema.json\", \"utf8\");\n+        // Parse and stringify to ensure single line\n+        return JSON.stringify(JSON.parse(schema));\n+      } catch (error) {\n+        const e = error as Error;\n+        console.error(`Failed to read schema file: ${e.message}`);\n+        throw new Error(\n+          \"Schema must be provided via ZERO_SCHEMA_JSON env var or zero-schema.json file\",\n+        );\n+      }\n+    };\n+\n+    const schemaJson = loadSchemaJson();\n+\n+    // S3 Bucket\n+    const replicationBucket = new sst.aws.Bucket(`replication-bucket`, {\n+      public: false,\n+    });\n+\n+    // VPC Configuration\n+    const vpc = new sst.aws.Vpc(`vpc`, {\n+      az: 2,\n+    });\n+\n+    // ECS Cluster\n+    const cluster = new sst.aws.Cluster(`cluster`, {\n+      vpc,\n+      transform: {\n+        cluster: {\n+          settings: [\n+            {\n+              name: \"containerInsights\",\n+              value: \"enhanced\",\n+            },\n+          ],\n+        },\n+      },\n+    });\n+\n+    // Common environment variables\n+    const commonEnv = {\n+      AWS_REGION: process.env.AWS_REGION!,\n+      ZERO_UPSTREAM_DB: process.env.ZERO_UPSTREAM_DB!,\n+      ZERO_CVR_DB: process.env.ZERO_CVR_DB!,\n+      ZERO_CHANGE_DB: process.env.ZERO_CHANGE_DB!,\n+      ZERO_AUTH_SECRET: process.env.ZERO_AUTH_SECRET!,\n+      AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID!,\n+      AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY!,\n+      ZERO_SCHEMA_JSON: schemaJson,\n+      ZERO_LOG_FORMAT: \"json\",\n+      ZERO_REPLICA_FILE: \"sync-replica.db\",\n+      ZERO_LITESTREAM_BACKUP_URL: $interpolate`s3://${replicationBucket.name}/backup`,\n+      ZERO_IMAGE_URL:\n+        process.env.ZERO_IMAGE_URL ||\n+        `${process.env.AWS_ACCOUNT_ID}.dkr.ecr.${process.env.AWS_REGION}.amazonaws.com/${process.env.ECR_IMAGE_ZERO_CACHE}:latest`,\n+    };\n+\n+    if (!commonEnv.ZERO_IMAGE_URL) {\n+      throw new Error(\n+        \"ZERO_IMAGE_URL is required. Either provide it directly or ensure AWS_ACCOUNT_ID, AWS_REGION, and ECR_IMAGE_ZERO_CACHE are set.\",\n+      );\n+    }\n+\n+    // Replication Manager Service\n+    const replicationManager = cluster.addService(`replication-manager`, {\n+      cpu: \"2 vCPU\",\n+      memory: \"8 GB\",\n+      image: commonEnv.ZERO_IMAGE_URL,\n+      health: {\n+        command: [\"CMD-SHELL\", \"curl -f http://localhost:4849/ || exit 1\"],\n+        interval: \"5 seconds\",\n+        retries: 3,\n+        startPeriod: \"300 seconds\",\n+      },\n+      environment: {\n+        ...commonEnv,\n+        ZERO_CHANGE_MAX_CONNS: \"3\",\n+        ZERO_NUM_SYNC_WORKERS: \"0\",\n+      },\n+      logging: {\n+        retention: \"1 month\",\n+      },\n+      loadBalancer: {\n+        public: false,\n+        ports: [\n+          {\n+            listen: \"80/http\",\n+            forward: \"4849/http\",\n+          },\n+        ],\n+      },\n+      transform: {\n+        target: {\n+          healthCheck: {\n+            enabled: true,\n+            path: \"/keepalive\",\n+            protocol: \"HTTP\",\n+            interval: 5,\n+            healthyThreshold: 2,\n+            timeout: 3,\n+          },\n+        },\n+      },\n+    });\n+\n+    // View Syncer Service\n+    cluster.addService(`view-syncer`, {\n+      cpu: \"2 vCPU\",\n+      memory: \"8 GB\",\n+      image: commonEnv.ZERO_IMAGE_URL,\n+      health: {\n+        command: [\"CMD-SHELL\", \"curl -f http://localhost:4848/ || exit 1\"],\n+        interval: \"5 seconds\",\n+        retries: 3,\n+        startPeriod: \"300 seconds\",\n+      },\n+      environment: {\n+        ...commonEnv,\n+        ZERO_CHANGE_STREAMER_URI: replicationManager.url,\n+        ZERO_UPSTREAM_MAX_CONNS: \"15\",\n+        ZERO_CVR_MAX_CONNS: \"160\",",
        "comment_created_at": "2025-01-31T01:30:32+00:00",
        "comment_author": "darkgnotic",
        "comment_body": "At some point I'd like to make these numbers automatically calculate based on higher level configuration that we pass into a library. Like `maxTotalConnections` that gets divvied up according to the task scaling options. This is where it's really nice to have a turing complete language for the configuration (as opposed to Yaml).\r\n\r\nExcited about evolving this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1857169283",
    "pr_number": 3019,
    "pr_file": "packages/zero-cache/src/server/change-streamer.ts",
    "created_at": "2024-11-25T18:36:37+00:00",
    "commented_code": "),\n   );\n \n-  // Note: This performs initial sync of the replica if necessary.\n-  const {changeSource, replicationConfig} = await initializeChangeSource(\n-    lc,\n-    config.upstream.db,\n-    config.shard,\n-    config.replicaFile,\n-  );\n+  let {autoReset} = config;\n+  if (autoReset && config.litestream) {\n+    lc.warn?.(",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1857169283",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3019,
        "pr_file": "packages/zero-cache/src/server/change-streamer.ts",
        "discussion_id": "1857169283",
        "commented_code": "@@ -28,20 +32,45 @@ export default async function runWorker(parent: Worker): Promise<void> {\n     ),\n   );\n \n-  // Note: This performs initial sync of the replica if necessary.\n-  const {changeSource, replicationConfig} = await initializeChangeSource(\n-    lc,\n-    config.upstream.db,\n-    config.shard,\n-    config.replicaFile,\n-  );\n+  let {autoReset} = config;\n+  if (autoReset && config.litestream) {\n+    lc.warn?.(",
        "comment_created_at": "2024-11-25T18:36:37+00:00",
        "comment_author": "grgbkr",
        "comment_body": "I think it would be better to hard fail startup. People will tend to ignore warnings, and it would be best to force them to address this misconfiguration IMHO.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1852612004",
    "pr_number": 3081,
    "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
    "created_at": "2024-11-21T17:54:40+00:00",
    "commented_code": "}>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1852612004",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3081,
        "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
        "discussion_id": "1852612004",
        "commented_code": "@@ -12,36 +16,54 @@ let loadedConfig:\n     }>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
        "comment_created_at": "2024-11-21T17:54:40+00:00",
        "comment_author": "tantaman",
        "comment_body": "I think this should be gotten from `config` as it was previously: `config.schemaFile`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1852655905",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3081,
        "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
        "discussion_id": "1852612004",
        "commented_code": "@@ -12,36 +16,54 @@ let loadedConfig:\n     }>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
        "comment_created_at": "2024-11-21T18:27:50+00:00",
        "comment_author": "tantaman",
        "comment_body": "like: `config.schemaJson` which loads from `ZERO_SCHEMA_JSON`",
        "pr_file_module": null
      },
      {
        "comment_id": "1852657866",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3081,
        "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
        "discussion_id": "1852612004",
        "commented_code": "@@ -12,36 +16,54 @@ let loadedConfig:\n     }>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
        "comment_created_at": "2024-11-21T18:29:23+00:00",
        "comment_author": "tantaman",
        "comment_body": "Eh, I guess that doesn't make sense. This isn't a config option we expose to user. Ignore the 2 comments above.",
        "pr_file_module": null
      },
      {
        "comment_id": "1852665765",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3081,
        "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
        "discussion_id": "1852612004",
        "commented_code": "@@ -12,36 +16,54 @@ let loadedConfig:\n     }>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
        "comment_created_at": "2024-11-21T18:36:03+00:00",
        "comment_author": "darkgnotic",
        "comment_body": "Agree. I might have to be better about documentation, but the config / Options library supports both flag and environment variables.\r\n\r\nSo an options object like:\r\n\r\n```ts\r\n{\r\n  port: ...\r\n  schema: {\r\n    file: ...\r\n    json: ...\r\n  }\r\n}\r\n```\r\n\r\nwill be settable by `--port` or `ZERO_PORT`, `--schema-json` or `ZERO_SCHEMA_JSON`, `--schema-file` or `ZERO_SCHEMA_FILE`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1853222204",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3081,
        "pr_file": "packages/zero-cache/src/auth/load-schema.ts",
        "discussion_id": "1852612004",
        "commented_code": "@@ -12,36 +16,54 @@ let loadedConfig:\n     }>\n   | undefined;\n \n-export function getSchema(config: ZeroConfig): Promise<{\n+function parseAuthConfig(\n+  input: string,\n+  source: string,\n+): {\n+  schema: Schema;\n+  authorization: AuthorizationConfig;\n+} {\n+  try {\n+    const config = JSON.parse(input);\n+    return {\n+      authorization: v.parse(\n+        config.authorization,\n+        authorizationConfigSchema,\n+        'strict',\n+      ),\n+      schema: config.schema as Schema,\n+    };\n+  } catch (e) {\n+    throw new Error(\n+      `Failed to parse authorization config from ${source}: ${e}`,\n+    );\n+  }\n+}\n+\n+export async function getSchema(): Promise<{\n   schema: Schema;\n   authorization: AuthorizationConfig;\n }> {\n   if (loadedConfig) {\n     return loadedConfig;\n   }\n \n-  const dirname = path.dirname(fileURLToPath(import.meta.url));\n-  const absoluteConfigPath = path.resolve(config.schemaFile);\n-  const relativePath = path.join(\n-    path.relative(dirname, path.dirname(absoluteConfigPath)),\n-    path.basename(absoluteConfigPath),\n-  );\n-\n-  loadedConfig = tsImport(relativePath, import.meta.url)\n-    .then(async module => {\n-      const schema = module.default.schema as Schema;\n-      const authorization = (await module.default\n-        .authorization) as AuthorizationConfig;\n-      return {\n-        schema,\n-        authorization,\n-      } as const;\n-    })\n-    .catch(e => {\n-      console.error(\n-        `Failed to load zero schema from ${absoluteConfigPath}: ${e}`,\n-      );\n-      throw e;\n-    });\n+  const jsonConfig = process.env[`${ENV_VAR_PREFIX}JSON`];",
        "comment_created_at": "2024-11-22T03:02:41+00:00",
        "comment_author": "cesara",
        "comment_body": "im using ZeroConfig now, thanks",
        "pr_file_module": null
      }
    ]
  }
]