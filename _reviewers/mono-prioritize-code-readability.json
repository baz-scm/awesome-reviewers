[
  {
    "discussion_id": "2304955747",
    "pr_number": 4747,
    "pr_file": "packages/zero-react/src/use-query.tsx",
    "created_at": "2025-08-27T18:20:10+00:00",
    "commented_code": "#snapshot: QueryResult<TReturn>;\n   #reactInternals: Set<() => void>;\n   #ttl: TTL;\n+  #completeResolver: Resolver<void> | undefined;",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2304955747",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4747,
        "pr_file": "packages/zero-react/src/use-query.tsx",
        "discussion_id": "2304955747",
        "commented_code": "@@ -274,6 +351,10 @@ class ViewWrapper<\n   #snapshot: QueryResult<TReturn>;\n   #reactInternals: Set<() => void>;\n   #ttl: TTL;\n+  #completeResolver: Resolver<void> | undefined;",
        "comment_created_at": "2025-08-27T18:20:10+00:00",
        "comment_author": "grgbkr",
        "comment_body": "I think this can be simplified a little bit. \r\n\r\n```\r\n#complete = false;  // set to true when you resolve #completeResolver\r\n#completeResolver = resolver<void>();\r\n#nonEmpty = false; // set to true when you resolve #nonEmptyResolver\r\n#nonEmptyResolver = resolver<void>();\r\n\r\n// use these when checking if useSuspenseQuery\r\n// should suspend\r\nget complete() {\r\n  return this.#complete;\r\n}\r\nget nonEmpty() {\r\n  return this.#nonEmpty;\r\n}\r\n```\r\n\r\nWhere you need the promise just do\r\n`this.#completeResolver.promise;`\r\n\r\nFinally, I think the most correct place to reset these resolvers is where we destroy the view / dematerialize (see the callback returned from `subscribeReactInternals`).  \r\n\r\nWe can do \r\n```\r\n // We already destroyed the view\r\nif (this.#view === undefined) {\r\n  return;\r\n}\r\nthis.#view?.destroy();\r\nthis.#view = undefined;\r\nthis.#complete = false;\r\nthis.#completeResolver = resolver();\r\nthis.#nonEmpty = false;\r\nthis.#nonEmptyResolver = resolver();\r\n```\r\n\r\nThis also means #completeResolver and #nonEmptyResolver are never undefined so some of the `?.`s can go away.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212028550",
    "pr_number": 4624,
    "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
    "created_at": "2025-07-17T02:38:44+00:00",
    "commented_code": "+import {useRef, useState, useEffect, type ChangeEvent} from 'react';\n+import type {ReactNode} from 'react';\n+import {useImageUpload} from '../hooks/use-image-upload.ts';\n+import {Button} from './button.tsx';\n+\n+interface ImageUploadAreaProps {\n+  onUpload: (markdown: string) => void;\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  onUpload,\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {isUploading, uploadFiles} = useImageUpload({onUpload});\n+\n+  const handleFileSelect = async (e: ChangeEvent<HTMLInputElement>) => {\n+    const files = [...(e.target.files ?? [])];\n+    if (files.length > 0) {\n+      await uploadFiles(files);\n+    }\n+    // Reset the input so the same file can be selected again\n+    if (fileInputRef.current) {\n+      fileInputRef.current.value = '';\n+    }\n+  };\n+\n+  const handleButtonClick = () => {\n+    fileInputRef.current?.click();\n+  };\n+\n+  // Update textarea rect when drag starts or component mounts\n+  useEffect(() => {\n+    const updateRect = () => {\n+      if (wrapperRef.current) {\n+        // Find textarea within the wrapper\n+        const textarea = wrapperRef.current.querySelector('textarea');\n+        if (textarea) {\n+          // Get the textarea's position relative to the wrapper using offsetTop/offsetLeft\n+          setTextareaRect({\n+            top: textarea.offsetTop,\n+            left: textarea.offsetLeft,\n+            width: textarea.offsetWidth,\n+            height: textarea.offsetHeight,\n+          } as DOMRect);\n+        }\n+      }\n+    };\n+\n+    updateRect();\n+  }, [isDragOver]);\n+\n+  const handleDragEnter = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+\n+    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n+      setIsDragOver(true);\n+    }\n+  };\n+\n+  const handleDragLeave = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+\n+    // Only clear drag state if we're leaving the wrapper entirely\n+    // Check if the relatedTarget (where we're going) is outside our wrapper\n+    const wrapper = e.currentTarget as HTMLElement;\n+    const relatedTarget = e.relatedTarget as HTMLElement;\n+\n+    if (!relatedTarget || !wrapper.contains(relatedTarget)) {\n+      setIsDragOver(false);\n+    }\n+  };\n+\n+  const handleDragOver = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+  };\n+\n+  const handleDrop = async (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+    setIsDragOver(false);\n+\n+    const files = [...e.dataTransfer.files].filter(file =>\n+      file.type.startsWith('image/'),\n+    );\n+\n+    if (files.length > 0) {\n+      await uploadFiles(files);\n+    }\n+  };\n+\n+  const handlePaste = async (e: React.ClipboardEvent) => {\n+    const items = [...e.clipboardData.items];\n+    const imageItems = items.filter(item => item.type.startsWith('image/'));\n+\n+    if (imageItems.length > 0) {\n+      e.preventDefault();\n+\n+      const files: File[] = [];\n+      for (const item of imageItems) {\n+        const file = item.getAsFile();\n+        if (file) {\n+          files.push(file);\n+        }\n+      }\n+\n+      if (files.length > 0) {\n+        await uploadFiles(files);\n+      }\n+    }\n+  };\n+\n+  const dropZoneClasses = `\n+    ${className}\n+    ${isDragOver ? 'drag-over' : ''}\n+    ${isUploading ? 'uploading' : ''}\n+  `.trim();\n+\n+  return (\n+    <div\n+      ref={wrapperRef}\n+      className={dropZoneClasses}\n+      onDragEnter={handleDragEnter}\n+      onDragLeave={handleDragLeave}\n+      onDragOver={handleDragOver}\n+      onDrop={handleDrop}\n+      onPaste={handlePaste}\n+      style={{\n+        position: 'relative',\n+      }}\n+    >\n+      {children}\n+      {isDragOver && textareaRect && (\n+        <div\n+          style={{",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2212028550",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4624,
        "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
        "discussion_id": "2212028550",
        "commented_code": "@@ -0,0 +1,215 @@\n+import {useRef, useState, useEffect, type ChangeEvent} from 'react';\n+import type {ReactNode} from 'react';\n+import {useImageUpload} from '../hooks/use-image-upload.ts';\n+import {Button} from './button.tsx';\n+\n+interface ImageUploadAreaProps {\n+  onUpload: (markdown: string) => void;\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  onUpload,\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {isUploading, uploadFiles} = useImageUpload({onUpload});\n+\n+  const handleFileSelect = async (e: ChangeEvent<HTMLInputElement>) => {\n+    const files = [...(e.target.files ?? [])];\n+    if (files.length > 0) {\n+      await uploadFiles(files);\n+    }\n+    // Reset the input so the same file can be selected again\n+    if (fileInputRef.current) {\n+      fileInputRef.current.value = '';\n+    }\n+  };\n+\n+  const handleButtonClick = () => {\n+    fileInputRef.current?.click();\n+  };\n+\n+  // Update textarea rect when drag starts or component mounts\n+  useEffect(() => {\n+    const updateRect = () => {\n+      if (wrapperRef.current) {\n+        // Find textarea within the wrapper\n+        const textarea = wrapperRef.current.querySelector('textarea');\n+        if (textarea) {\n+          // Get the textarea's position relative to the wrapper using offsetTop/offsetLeft\n+          setTextareaRect({\n+            top: textarea.offsetTop,\n+            left: textarea.offsetLeft,\n+            width: textarea.offsetWidth,\n+            height: textarea.offsetHeight,\n+          } as DOMRect);\n+        }\n+      }\n+    };\n+\n+    updateRect();\n+  }, [isDragOver]);\n+\n+  const handleDragEnter = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+\n+    if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {\n+      setIsDragOver(true);\n+    }\n+  };\n+\n+  const handleDragLeave = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+\n+    // Only clear drag state if we're leaving the wrapper entirely\n+    // Check if the relatedTarget (where we're going) is outside our wrapper\n+    const wrapper = e.currentTarget as HTMLElement;\n+    const relatedTarget = e.relatedTarget as HTMLElement;\n+\n+    if (!relatedTarget || !wrapper.contains(relatedTarget)) {\n+      setIsDragOver(false);\n+    }\n+  };\n+\n+  const handleDragOver = (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+  };\n+\n+  const handleDrop = async (e: React.DragEvent) => {\n+    e.preventDefault();\n+    e.stopPropagation();\n+    setIsDragOver(false);\n+\n+    const files = [...e.dataTransfer.files].filter(file =>\n+      file.type.startsWith('image/'),\n+    );\n+\n+    if (files.length > 0) {\n+      await uploadFiles(files);\n+    }\n+  };\n+\n+  const handlePaste = async (e: React.ClipboardEvent) => {\n+    const items = [...e.clipboardData.items];\n+    const imageItems = items.filter(item => item.type.startsWith('image/'));\n+\n+    if (imageItems.length > 0) {\n+      e.preventDefault();\n+\n+      const files: File[] = [];\n+      for (const item of imageItems) {\n+        const file = item.getAsFile();\n+        if (file) {\n+          files.push(file);\n+        }\n+      }\n+\n+      if (files.length > 0) {\n+        await uploadFiles(files);\n+      }\n+    }\n+  };\n+\n+  const dropZoneClasses = `\n+    ${className}\n+    ${isDragOver ? 'drag-over' : ''}\n+    ${isUploading ? 'uploading' : ''}\n+  `.trim();\n+\n+  return (\n+    <div\n+      ref={wrapperRef}\n+      className={dropZoneClasses}\n+      onDragEnter={handleDragEnter}\n+      onDragLeave={handleDragLeave}\n+      onDragOver={handleDragOver}\n+      onDrop={handleDrop}\n+      onPaste={handlePaste}\n+      style={{\n+        position: 'relative',\n+      }}\n+    >\n+      {children}\n+      {isDragOver && textareaRect && (\n+        <div\n+          style={{",
        "comment_created_at": "2025-07-17T02:38:44+00:00",
        "comment_author": "aboodman",
        "comment_body": "Maybe pull out the constant styles in either a module css or css file so that it's easier to see the logic?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214085251",
    "pr_number": 4624,
    "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
    "created_at": "2025-07-17T19:06:53+00:00",
    "commented_code": "+import {\n+  useRef,\n+  useState,\n+  useEffect,\n+  useCallback,\n+  type ChangeEvent,\n+} from 'react';\n+import type {ReactNode} from 'react';\n+import classNames from 'classnames';\n+import {useLogin} from '../hooks/use-login.tsx';\n+import {Button} from './button.tsx';\n+import styles from './image-upload-area.module.css';\n+\n+interface ImageUploadAreaProps {\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const [isUploading, setIsUploading] = useState(false);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {loginState} = useLogin();\n+\n+  // Image upload logic (from use-image-upload.ts)\n+  const validateFile = (file: File): string | null => {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2214085251",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4624,
        "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
        "discussion_id": "2214085251",
        "commented_code": "@@ -0,0 +1,330 @@\n+import {\n+  useRef,\n+  useState,\n+  useEffect,\n+  useCallback,\n+  type ChangeEvent,\n+} from 'react';\n+import type {ReactNode} from 'react';\n+import classNames from 'classnames';\n+import {useLogin} from '../hooks/use-login.tsx';\n+import {Button} from './button.tsx';\n+import styles from './image-upload-area.module.css';\n+\n+interface ImageUploadAreaProps {\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const [isUploading, setIsUploading] = useState(false);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {loginState} = useLogin();\n+\n+  // Image upload logic (from use-image-upload.ts)\n+  const validateFile = (file: File): string | null => {",
        "comment_created_at": "2025-07-17T19:06:53+00:00",
        "comment_author": "aboodman",
        "comment_body": "These functions that do not rely on any variables from within the component should be moved out to bare functions in the same file (`function validateFile(...) { .... }`) so that it's clear they are static. (Also just to reduce the size of this function).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214088738",
    "pr_number": 4624,
    "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
    "created_at": "2025-07-17T19:08:38+00:00",
    "commented_code": "+import {\n+  useRef,\n+  useState,\n+  useEffect,\n+  useCallback,\n+  type ChangeEvent,\n+} from 'react';\n+import type {ReactNode} from 'react';\n+import classNames from 'classnames';\n+import {useLogin} from '../hooks/use-login.tsx';\n+import {Button} from './button.tsx';\n+import styles from './image-upload-area.module.css';\n+\n+interface ImageUploadAreaProps {\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const [isUploading, setIsUploading] = useState(false);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {loginState} = useLogin();\n+\n+  // Image upload logic (from use-image-upload.ts)\n+  const validateFile = (file: File): string | null => {\n+    const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];\n+    if (!validTypes.includes(file.type)) {\n+      return 'Invalid file type. Please select a JPG, PNG, WEBP, or GIF image.';\n+    }\n+\n+    if (file.size > 10 * 1024 * 1024) {\n+      return 'File is too large. Maximum size is 10MB.';\n+    }\n+\n+    return null;\n+  };\n+\n+  const getPresignedUrl = async (\n+    contentType: string,\n+  ): Promise<{url: string; key: string}> => {\n+    const response = await fetch('/api/upload/presigned-url', {\n+      method: 'POST',\n+      headers: {\n+        'Content-Type': 'application/json',\n+        'Authorization': `Bearer ${loginState?.encoded}`,\n+      },\n+      body: JSON.stringify({contentType}),\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(`Failed to get presigned URL: ${response.statusText}`);\n+    }\n+\n+    return response.json();\n+  };\n+\n+  // Textarea image insert logic (from use-textarea-image-insert.ts)\n+  const insertMarkdown = useCallback((markdown: string) => {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2214088738",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4624,
        "pr_file": "apps/zbugs/src/components/image-upload-area.tsx",
        "discussion_id": "2214088738",
        "commented_code": "@@ -0,0 +1,330 @@\n+import {\n+  useRef,\n+  useState,\n+  useEffect,\n+  useCallback,\n+  type ChangeEvent,\n+} from 'react';\n+import type {ReactNode} from 'react';\n+import classNames from 'classnames';\n+import {useLogin} from '../hooks/use-login.tsx';\n+import {Button} from './button.tsx';\n+import styles from './image-upload-area.module.css';\n+\n+interface ImageUploadAreaProps {\n+  children: ReactNode;\n+  className?: string;\n+}\n+\n+export function ImageUploadArea({\n+  children,\n+  className = '',\n+}: ImageUploadAreaProps) {\n+  const [isDragOver, setIsDragOver] = useState(false);\n+  const [textareaRect, setTextareaRect] = useState<DOMRect | null>(null);\n+  const [isUploading, setIsUploading] = useState(false);\n+  const wrapperRef = useRef<HTMLDivElement>(null);\n+  const fileInputRef = useRef<HTMLInputElement>(null);\n+  const {loginState} = useLogin();\n+\n+  // Image upload logic (from use-image-upload.ts)\n+  const validateFile = (file: File): string | null => {\n+    const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];\n+    if (!validTypes.includes(file.type)) {\n+      return 'Invalid file type. Please select a JPG, PNG, WEBP, or GIF image.';\n+    }\n+\n+    if (file.size > 10 * 1024 * 1024) {\n+      return 'File is too large. Maximum size is 10MB.';\n+    }\n+\n+    return null;\n+  };\n+\n+  const getPresignedUrl = async (\n+    contentType: string,\n+  ): Promise<{url: string; key: string}> => {\n+    const response = await fetch('/api/upload/presigned-url', {\n+      method: 'POST',\n+      headers: {\n+        'Content-Type': 'application/json',\n+        'Authorization': `Bearer ${loginState?.encoded}`,\n+      },\n+      body: JSON.stringify({contentType}),\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(`Failed to get presigned URL: ${response.statusText}`);\n+    }\n+\n+    return response.json();\n+  };\n+\n+  // Textarea image insert logic (from use-textarea-image-insert.ts)\n+  const insertMarkdown = useCallback((markdown: string) => {",
        "comment_created_at": "2025-07-17T19:08:38+00:00",
        "comment_author": "aboodman",
        "comment_body": "This one could arguably stay inline since it is relying on `wrapperRef`. But you could also move it out into its own function and pass `wrapperRef.current` in. I would probably do that, again to make the react component smaller and easier to read.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211721811",
    "pr_number": 4641,
    "pr_file": "apps/zbugs/src/pages/issue/issue-page.tsx",
    "created_at": "2025-07-16T22:22:51+00:00",
    "commented_code": "useEmojiDataSourcePreload();\n   useShowToastForNewComment(comments, virtualizer, highlightComment);\n \n+  useEffect(() => {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2211721811",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4641,
        "pr_file": "apps/zbugs/src/pages/issue/issue-page.tsx",
        "discussion_id": "2211721811",
        "commented_code": "@@ -352,6 +357,28 @@ export function IssuePage({onReady}: {onReady: () => void}) {\n   useEmojiDataSourcePreload();\n   useShowToastForNewComment(comments, virtualizer, highlightComment);\n \n+  useEffect(() => {",
        "comment_created_at": "2025-07-16T22:22:51+00:00",
        "comment_author": "aboodman",
        "comment_body": "The toast is very cute idea but I think I would prefer to save the complexity budget on this page for other things. How about we just print out \"OK! You are unsubscribed to <issue link>\" in the api response as plain text.",
        "pr_file_module": null
      },
      {
        "comment_id": "2211744889",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4641,
        "pr_file": "apps/zbugs/src/pages/issue/issue-page.tsx",
        "discussion_id": "2211721811",
        "commented_code": "@@ -352,6 +357,28 @@ export function IssuePage({onReady}: {onReady: () => void}) {\n   useEmojiDataSourcePreload();\n   useShowToastForNewComment(comments, virtualizer, highlightComment);\n \n+  useEffect(() => {",
        "comment_created_at": "2025-07-16T22:39:50+00:00",
        "comment_author": "aboodman",
        "comment_body": "(this page just already has a *lot* going on and I want to make sure we're using our complexity for things that are important/unique to Zero)",
        "pr_file_module": null
      },
      {
        "comment_id": "2211842446",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4641,
        "pr_file": "apps/zbugs/src/pages/issue/issue-page.tsx",
        "discussion_id": "2211721811",
        "commented_code": "@@ -352,6 +357,28 @@ export function IssuePage({onReady}: {onReady: () => void}) {\n   useEmojiDataSourcePreload();\n   useShowToastForNewComment(comments, virtualizer, highlightComment);\n \n+  useEffect(() => {",
        "comment_created_at": "2025-07-16T23:47:06+00:00",
        "comment_author": "0xcadams",
        "comment_body": "Sounds good",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2078170376",
    "pr_number": 4343,
    "pr_file": "apps/zbugs/src/pages/list/list-page.tsx",
    "created_at": "2025-05-07T17:48:02+00:00",
    "commented_code": "qs.get('sort')?.toLowerCase() === 'created' ? 'created' : 'modified';\n   const sortDirection =\n     qs.get('sortDir')?.toLowerCase() === 'asc' ? 'asc' : 'desc';\n+  const open =\n+    status === 'open' ? true : status === 'closed' ? false : undefined;\n+  const pageSize = 10;\n+  const [limit, setLimit] = useState(pageSize);\n \n-  let q = z.query.issue\n+  const q = z.query.issue\n     .orderBy(sortField, sortDirection)\n     .orderBy('id', sortDirection)\n     .related('labels')\n-    .related('viewState', q => q.where('userID', z.userID).one());\n-\n-  const open =\n-    status === 'open' ? true : status === 'closed' ? false : undefined;\n-\n-  if (open !== undefined) {\n-    q = q.where('open', open);\n-  }\n-\n-  if (creator) {\n-    q = q.whereExists('creator', q => q.where('login', creator));\n-  }\n-\n-  if (assignee) {\n-    q = q.whereExists('assignee', q => q.where('login', assignee));\n-  }\n-\n-  if (textFilter) {\n-    q = q.where(({or, cmp, exists}) =>\n-      or(\n-        cmp('title', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        cmp('description', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        exists('comments', q =>\n-          q.where('body', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        ),\n+    .related('viewState', q => q.where('userID', z.userID).one())",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2078170376",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4343,
        "pr_file": "apps/zbugs/src/pages/list/list-page.tsx",
        "discussion_id": "2078170376",
        "commented_code": "@@ -56,54 +56,42 @@ export function ListPage({onReady}: {onReady: () => void}) {\n     qs.get('sort')?.toLowerCase() === 'created' ? 'created' : 'modified';\n   const sortDirection =\n     qs.get('sortDir')?.toLowerCase() === 'asc' ? 'asc' : 'desc';\n+  const open =\n+    status === 'open' ? true : status === 'closed' ? false : undefined;\n+  const pageSize = 10;\n+  const [limit, setLimit] = useState(pageSize);\n \n-  let q = z.query.issue\n+  const q = z.query.issue\n     .orderBy(sortField, sortDirection)\n     .orderBy('id', sortDirection)\n     .related('labels')\n-    .related('viewState', q => q.where('userID', z.userID).one());\n-\n-  const open =\n-    status === 'open' ? true : status === 'closed' ? false : undefined;\n-\n-  if (open !== undefined) {\n-    q = q.where('open', open);\n-  }\n-\n-  if (creator) {\n-    q = q.whereExists('creator', q => q.where('login', creator));\n-  }\n-\n-  if (assignee) {\n-    q = q.whereExists('assignee', q => q.where('login', assignee));\n-  }\n-\n-  if (textFilter) {\n-    q = q.where(({or, cmp, exists}) =>\n-      or(\n-        cmp('title', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        cmp('description', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        exists('comments', q =>\n-          q.where('body', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        ),\n+    .related('viewState', q => q.where('userID', z.userID).one())",
        "comment_created_at": "2025-05-07T17:48:02+00:00",
        "comment_author": "aboodman",
        "comment_body": "It's a cool pattern, and this is the best \"one-line\" version of this that I've seen so far, but honestly I prefer the code as multiple statements.\r\n\r\nI like that the query system is composable so that you can construct the query iteratively with normal, simple procedural code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2078172357",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4343,
        "pr_file": "apps/zbugs/src/pages/list/list-page.tsx",
        "discussion_id": "2078170376",
        "commented_code": "@@ -56,54 +56,42 @@ export function ListPage({onReady}: {onReady: () => void}) {\n     qs.get('sort')?.toLowerCase() === 'created' ? 'created' : 'modified';\n   const sortDirection =\n     qs.get('sortDir')?.toLowerCase() === 'asc' ? 'asc' : 'desc';\n+  const open =\n+    status === 'open' ? true : status === 'closed' ? false : undefined;\n+  const pageSize = 10;\n+  const [limit, setLimit] = useState(pageSize);\n \n-  let q = z.query.issue\n+  const q = z.query.issue\n     .orderBy(sortField, sortDirection)\n     .orderBy('id', sortDirection)\n     .related('labels')\n-    .related('viewState', q => q.where('userID', z.userID).one());\n-\n-  const open =\n-    status === 'open' ? true : status === 'closed' ? false : undefined;\n-\n-  if (open !== undefined) {\n-    q = q.where('open', open);\n-  }\n-\n-  if (creator) {\n-    q = q.whereExists('creator', q => q.where('login', creator));\n-  }\n-\n-  if (assignee) {\n-    q = q.whereExists('assignee', q => q.where('login', assignee));\n-  }\n-\n-  if (textFilter) {\n-    q = q.where(({or, cmp, exists}) =>\n-      or(\n-        cmp('title', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        cmp('description', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        exists('comments', q =>\n-          q.where('body', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        ),\n+    .related('viewState', q => q.where('userID', z.userID).one())",
        "comment_created_at": "2025-05-07T17:49:27+00:00",
        "comment_author": "aboodman",
        "comment_body": "PS you could probably make this even more \"elegant\" (\ud83d\ude02) by changing `and()` to filter other falsey values, so you can say `open && cmp('open', open)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2078174167",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4343,
        "pr_file": "apps/zbugs/src/pages/list/list-page.tsx",
        "discussion_id": "2078170376",
        "commented_code": "@@ -56,54 +56,42 @@ export function ListPage({onReady}: {onReady: () => void}) {\n     qs.get('sort')?.toLowerCase() === 'created' ? 'created' : 'modified';\n   const sortDirection =\n     qs.get('sortDir')?.toLowerCase() === 'asc' ? 'asc' : 'desc';\n+  const open =\n+    status === 'open' ? true : status === 'closed' ? false : undefined;\n+  const pageSize = 10;\n+  const [limit, setLimit] = useState(pageSize);\n \n-  let q = z.query.issue\n+  const q = z.query.issue\n     .orderBy(sortField, sortDirection)\n     .orderBy('id', sortDirection)\n     .related('labels')\n-    .related('viewState', q => q.where('userID', z.userID).one());\n-\n-  const open =\n-    status === 'open' ? true : status === 'closed' ? false : undefined;\n-\n-  if (open !== undefined) {\n-    q = q.where('open', open);\n-  }\n-\n-  if (creator) {\n-    q = q.whereExists('creator', q => q.where('login', creator));\n-  }\n-\n-  if (assignee) {\n-    q = q.whereExists('assignee', q => q.where('login', assignee));\n-  }\n-\n-  if (textFilter) {\n-    q = q.where(({or, cmp, exists}) =>\n-      or(\n-        cmp('title', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        cmp('description', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        exists('comments', q =>\n-          q.where('body', 'ILIKE', `%${escapeLike(textFilter)}%`),\n-        ),\n+    .related('viewState', q => q.where('userID', z.userID).one())",
        "comment_created_at": "2025-05-07T17:50:47+00:00",
        "comment_author": "aboodman",
        "comment_body": "With that I would *almost* be on your side. That's pretty compact.\r\n\r\nI think I would still probably write it as multiple statements myself but not certain.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1876100841",
    "pr_number": 3229,
    "pr_file": "packages/zero-react/src/use-query.tsx",
    "created_at": "2024-12-09T14:44:21+00:00",
    "commented_code": "const emptyArray: unknown[] = [];\n const disabledSubscriber = () => () => {};\n \n+const defaultSnapshots = {\n+  singular: [undefined, {type: 'unknown'}] as const,\n+  plural: [emptyArray, {type: 'unknown'}] as const,\n+};",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1876100841",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3229,
        "pr_file": "packages/zero-react/src/use-query.tsx",
        "discussion_id": "1876100841",
        "commented_code": "@@ -29,6 +39,19 @@ export function useQuery<\n const emptyArray: unknown[] = [];\n const disabledSubscriber = () => () => {};\n \n+const defaultSnapshots = {\n+  singular: [undefined, {type: 'unknown'}] as const,\n+  plural: [emptyArray, {type: 'unknown'}] as const,\n+};",
        "comment_created_at": "2024-12-09T14:44:21+00:00",
        "comment_author": "arv",
        "comment_body": "There is really no reason to put this in an object.\r\n\r\n```ts\r\nconst defaultSnaphotSingular = [undefined, {type: 'unknown'}] as const;\r\nconst defaultSnaphotPlural = [emptyArray, {type: 'unknown'}] as const;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]