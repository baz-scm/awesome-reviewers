[
  {
    "discussion_id": "1969553084",
    "pr_number": 3841,
    "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
    "created_at": "2025-02-25T11:09:20+00:00",
    "commented_code": "+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Store as KVStore} from './store.ts';\n+\n+export interface SQLResultSetRowList {\n+  length: number;\n+  item(index: number): {value: string}; // TODO: confirm this is correct, this was typed as `any` in the original code\n+}\n+\n+export abstract class SQLiteTransaction {\n+  abstract start(readonly?: boolean): Promise<void>;\n+\n+  abstract execute(\n+    sqlStatement: string,\n+    args?: (string | number | null)[] | undefined,\n+  ): Promise<SQLResultSetRowList>;\n+\n+  abstract commit(): Promise<void>;\n+}\n+\n+export interface SQLDatabase {\n+  transaction: () => SQLiteTransaction;\n+  destroy: () => Promise<void>;\n+  close: () => Promise<void>;\n+}\n+\n+export interface GenericSQLiteDatabaseManager {\n+  open: (name: string) => Promise<SQLDatabase>;\n+}\n+\n+/**\n+ * A SQLite-based Store implementation.\n+ *\n+ * This store provides a generic SQLite implementation that can be used with different\n+ * SQLite providers (like expo-sqlite, better-sqlite3, etc). It implements the Store\n+ * interface using a single 'entry' table with key-value pairs.\n+ *\n+ * The store ensures strict serializable transactions by using SQLite's native\n+ * transaction support. Read transactions use SQLite's READ mode while write\n+ * transactions use the default mode.\n+ */\n+export class ReplicacheGenericStore implements KVStore {\n+  readonly #name: string;\n+  readonly #dbm: SQLiteDatabaseManager;\n+  #closed = false;\n+\n+  constructor(name: string, dbm: SQLiteDatabaseManager) {\n+    this.#name = name;\n+    this.#dbm = dbm;\n+  }\n+\n+  async read() {\n+    const db = await this._getDb();\n+    const tx = db.transaction();\n+    await tx.start(true);\n+    return new SQLiteStoreRead(tx);\n+  }\n+\n+  async withRead<R>(\n+    fn: (read: Awaited<ReturnType<KVStore['read']>>) => R | Promise<R>,\n+  ): Promise<R> {\n+    const read = await this.read();\n+    try {\n+      return await fn(read);\n+    } finally {\n+      await read.release();\n+    }\n+  }\n+\n+  async write(): Promise<Awaited<ReturnType<KVStore['write']>>> {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1969553084",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3841,
        "pr_file": "packages/replicache/src/kv/sqlite-store.ts",
        "discussion_id": "1969553084",
        "commented_code": "@@ -0,0 +1,249 @@\n+import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';\n+import {deepFreeze} from '../frozen-json.ts';\n+import type {Store as KVStore} from './store.ts';\n+\n+export interface SQLResultSetRowList {\n+  length: number;\n+  item(index: number): {value: string}; // TODO: confirm this is correct, this was typed as `any` in the original code\n+}\n+\n+export abstract class SQLiteTransaction {\n+  abstract start(readonly?: boolean): Promise<void>;\n+\n+  abstract execute(\n+    sqlStatement: string,\n+    args?: (string | number | null)[] | undefined,\n+  ): Promise<SQLResultSetRowList>;\n+\n+  abstract commit(): Promise<void>;\n+}\n+\n+export interface SQLDatabase {\n+  transaction: () => SQLiteTransaction;\n+  destroy: () => Promise<void>;\n+  close: () => Promise<void>;\n+}\n+\n+export interface GenericSQLiteDatabaseManager {\n+  open: (name: string) => Promise<SQLDatabase>;\n+}\n+\n+/**\n+ * A SQLite-based Store implementation.\n+ *\n+ * This store provides a generic SQLite implementation that can be used with different\n+ * SQLite providers (like expo-sqlite, better-sqlite3, etc). It implements the Store\n+ * interface using a single 'entry' table with key-value pairs.\n+ *\n+ * The store ensures strict serializable transactions by using SQLite's native\n+ * transaction support. Read transactions use SQLite's READ mode while write\n+ * transactions use the default mode.\n+ */\n+export class ReplicacheGenericStore implements KVStore {\n+  readonly #name: string;\n+  readonly #dbm: SQLiteDatabaseManager;\n+  #closed = false;\n+\n+  constructor(name: string, dbm: SQLiteDatabaseManager) {\n+    this.#name = name;\n+    this.#dbm = dbm;\n+  }\n+\n+  async read() {\n+    const db = await this._getDb();\n+    const tx = db.transaction();\n+    await tx.start(true);\n+    return new SQLiteStoreRead(tx);\n+  }\n+\n+  async withRead<R>(\n+    fn: (read: Awaited<ReturnType<KVStore['read']>>) => R | Promise<R>,\n+  ): Promise<R> {\n+    const read = await this.read();\n+    try {\n+      return await fn(read);\n+    } finally {\n+      await read.release();\n+    }\n+  }\n+\n+  async write(): Promise<Awaited<ReturnType<KVStore['write']>>> {",
        "comment_created_at": "2025-02-25T11:09:20+00:00",
        "comment_author": "arv",
        "comment_body": "This can now reference the type in store.ts\r\n\r\n```suggestion\r\n  async write(): Promise<Write> {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135729806",
    "pr_number": 4474,
    "pr_file": "packages/zero-solid/src/create-query.ts",
    "created_at": "2025-06-09T13:30:34+00:00",
    "commented_code": "querySignal: () => Query<TSchema, TTable, TReturn>,\n   options?: CreateQueryOptions | Accessor<CreateQueryOptions>,\n ): QueryResult<TReturn> {\n+  const [state, setState] = createStore<State>([\n+    {\n+      '': undefined,\n+    },\n+    unknown,\n+  ]);\n+\n+  const z = useZero();\n+\n   // Wrap in in createMemo to ensure a new view is created if the querySignal changes.\n-  const view = createMemo(() => {\n+  createComputed(() => {\n     const query = querySignal();\n     const ttl = normalize(options)?.ttl ?? DEFAULT_TTL;\n-    const view = getView(query, ttl);\n-\n-    // Use queueMicrotask to allow cleanup/create in the current microtask to\n-    // reuse the view.\n-    onCleanup(() => queueMicrotask(() => releaseView(query, view)));\n-    return view;\n+    getView(z().clientID, query, ttl, setState);",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2135729806",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4474,
        "pr_file": "packages/zero-solid/src/create-query.ts",
        "discussion_id": "2135729806",
        "commented_code": "@@ -38,25 +38,25 @@ export function createQuery<\n   querySignal: () => Query<TSchema, TTable, TReturn>,\n   options?: CreateQueryOptions | Accessor<CreateQueryOptions>,\n ): QueryResult<TReturn> {\n+  const [state, setState] = createStore<State>([\n+    {\n+      '': undefined,\n+    },\n+    unknown,\n+  ]);\n+\n+  const z = useZero();\n+\n   // Wrap in in createMemo to ensure a new view is created if the querySignal changes.\n-  const view = createMemo(() => {\n+  createComputed(() => {\n     const query = querySignal();\n     const ttl = normalize(options)?.ttl ?? DEFAULT_TTL;\n-    const view = getView(query, ttl);\n-\n-    // Use queueMicrotask to allow cleanup/create in the current microtask to\n-    // reuse the view.\n-    onCleanup(() => queueMicrotask(() => releaseView(query, view)));\n-    return view;\n+    getView(z().clientID, query, ttl, setState);",
        "comment_created_at": "2025-06-09T13:30:34+00:00",
        "comment_author": "arv",
        "comment_body": "The name getView is kind of misleading now since we no longer care about the return value. It would be better to rename getView and make it return void... I'm not sure what to name it... maybe useView?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2025486055",
    "pr_number": 4165,
    "pr_file": "packages/zero-pg/src/schema.ts",
    "created_at": "2025-04-02T19:48:18+00:00",
    "commented_code": "};\n   }\n \n-  // Validate that schema.ts is a valid subset of serverSchema and\n-  // types are compatible.\n+  const errors = checkSchemasAreCompatible(schema, serverSchema);\n+  assert(errors.length === 0, () => makeSchemaIncompatibleErrorMessage(errors));\n \n   return serverSchema;\n }\n+\n+function makeSchemaIncompatibleErrorMessage(\n+  errors: SchemaIncompatibilityError[],\n+) {\n+  if (errors.length === 0) {\n+    return 'No schema incompatibilities found.';\n+  }\n+\n+  const messages: string[] = [];\n+\n+  for (const error of errors) {\n+    switch (error.type) {\n+      case 'missingTable':\n+        messages.push(\n+          `Table \"${error.table}\" is defined in your zero schema but does not exist in the database.`,\n+        );\n+        break;\n+      case 'missingColumn':\n+        messages.push(\n+          `Column \"${error.column}\" in table \"${error.table}\" is defined in your zero schema but does not exist in the database.`,\n+        );\n+        break;\n+      case 'typeError':\n+        messages.push(\n+          `Type mismatch for column \"${error.column}\" in table \"${error.table}\": ${error.requiredType === undefined ? `${error.pgType} is currently unsupported in Zero. Please file a bug at https://bugs.rocicorp.dev/` : `${error.pgType} should be mapped to ${error.requiredType} in Zero not ${error.declaredType}.`}`,\n+        );\n+        break;\n+    }\n+  }\n+\n+  return [\n+    'Schema incompatibility detected between your zero schema definition and the database:',\n+    '',\n+    ...messages.map(msg => `  - ${msg}`),\n+    '',\n+    'Please update your schema definition to match the database or migrate your database to match the schema.',\n+  ].join('\n');\n+}\n+\n+export type SchemaIncompatibilityError =\n+  | {\n+      type: 'typeError';\n+      table: string;\n+      column: string;\n+      pgType: string;\n+      declaredType: string;\n+      requiredType: string | undefined;\n+    }\n+  | {\n+      type: 'missingColumn';\n+      table: string;\n+      column: string;\n+    }\n+  | {\n+      type: 'missingTable';\n+      table: string;\n+    };\n+\n+export function checkSchemasAreCompatible(\n+  schema: Schema,\n+  serverSchema: ServerSchema,\n+): SchemaIncompatibilityError[] {\n+  const errors: SchemaIncompatibilityError[] = [];\n+  // Check that all tables in schema exist in serverSchema\n+  for (const table of Object.values(schema.tables)) {\n+    const tableName = table.serverName ?? table.name;",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2025486055",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4165,
        "pr_file": "packages/zero-pg/src/schema.ts",
        "discussion_id": "2025486055",
        "commented_code": "@@ -84,8 +86,116 @@ export async function getServerSchema<S extends Schema>(\n     };\n   }\n \n-  // Validate that schema.ts is a valid subset of serverSchema and\n-  // types are compatible.\n+  const errors = checkSchemasAreCompatible(schema, serverSchema);\n+  assert(errors.length === 0, () => makeSchemaIncompatibleErrorMessage(errors));\n \n   return serverSchema;\n }\n+\n+function makeSchemaIncompatibleErrorMessage(\n+  errors: SchemaIncompatibilityError[],\n+) {\n+  if (errors.length === 0) {\n+    return 'No schema incompatibilities found.';\n+  }\n+\n+  const messages: string[] = [];\n+\n+  for (const error of errors) {\n+    switch (error.type) {\n+      case 'missingTable':\n+        messages.push(\n+          `Table \"${error.table}\" is defined in your zero schema but does not exist in the database.`,\n+        );\n+        break;\n+      case 'missingColumn':\n+        messages.push(\n+          `Column \"${error.column}\" in table \"${error.table}\" is defined in your zero schema but does not exist in the database.`,\n+        );\n+        break;\n+      case 'typeError':\n+        messages.push(\n+          `Type mismatch for column \"${error.column}\" in table \"${error.table}\": ${error.requiredType === undefined ? `${error.pgType} is currently unsupported in Zero. Please file a bug at https://bugs.rocicorp.dev/` : `${error.pgType} should be mapped to ${error.requiredType} in Zero not ${error.declaredType}.`}`,\n+        );\n+        break;\n+    }\n+  }\n+\n+  return [\n+    'Schema incompatibility detected between your zero schema definition and the database:',\n+    '',\n+    ...messages.map(msg => `  - ${msg}`),\n+    '',\n+    'Please update your schema definition to match the database or migrate your database to match the schema.',\n+  ].join('\\n');\n+}\n+\n+export type SchemaIncompatibilityError =\n+  | {\n+      type: 'typeError';\n+      table: string;\n+      column: string;\n+      pgType: string;\n+      declaredType: string;\n+      requiredType: string | undefined;\n+    }\n+  | {\n+      type: 'missingColumn';\n+      table: string;\n+      column: string;\n+    }\n+  | {\n+      type: 'missingTable';\n+      table: string;\n+    };\n+\n+export function checkSchemasAreCompatible(\n+  schema: Schema,\n+  serverSchema: ServerSchema,\n+): SchemaIncompatibilityError[] {\n+  const errors: SchemaIncompatibilityError[] = [];\n+  // Check that all tables in schema exist in serverSchema\n+  for (const table of Object.values(schema.tables)) {\n+    const tableName = table.serverName ?? table.name;",
        "comment_created_at": "2025-04-02T19:48:18+00:00",
        "comment_author": "grgbkr",
        "comment_body": "s/tableName/serverTableName/",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1701053843",
    "pr_number": 2103,
    "pr_file": "packages/zql/src/iterable-explore.test.ts",
    "created_at": "2024-08-02T00:52:48+00:00",
    "commented_code": "+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1701053843",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701053843",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
        "comment_created_at": "2024-08-02T00:52:48+00:00",
        "comment_author": "aboodman",
        "comment_body": "If we're going to use a symbol here let's try to pick a unique name. How about `Entity` that is the name we used before. Or `Row`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1701054050",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701053843",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
        "comment_created_at": "2024-08-02T00:53:18+00:00",
        "comment_author": "aboodman",
        "comment_body": "Also is it enforced that every value flowing through the pipeline has a unique ID as it does today?",
        "pr_file_module": null
      },
      {
        "comment_id": "1701091296",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701053843",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
        "comment_created_at": "2024-08-02T01:58:04+00:00",
        "comment_author": "tantaman",
        "comment_body": "every row will have a primary key and we can't mix rows from different tables in the same iterable level so I think this is true.",
        "pr_file_module": null
      },
      {
        "comment_id": "1701137796",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701053843",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
        "comment_created_at": "2024-08-02T03:01:14+00:00",
        "comment_author": "aboodman",
        "comment_body": "Sorry I pressed publish on this review too quickly and my comments were kind of cryptic. Here's what I should have said:\r\n\r\n1. It's better if we pick names for things in the system that are unique and not already used by other concepts. The name \"node\" is already often used to refer to pipeline nodes. So what about using a different name like \"row\" or \"entity\"? The reason this is important is so that when talking about the system we can just use a short name for a concept rather than having to qualify it. Like we can say \"entity\" rather than \"pipeline entry node\".\r\n2. In the existing ivm, we require all things flowing through the pipeline to have a unique ID. Are we going to in the new system too? If we are then how come there's no id field here? is it just because this is a sketch and the id wasn't required, or is its absence important somehow? If there's going to be an ID for each of the thingies flowing through the pipeline, then the name \"entity\" or \"PipelineEntity\" makes even more sense.\r\n\r\nSorry for obsessing so much about names, but I think a big part of system design is just choosing good names.",
        "pr_file_module": null
      },
      {
        "comment_id": "1701881933",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 2103,
        "pr_file": "packages/zql/src/iterable-explore.test.ts",
        "discussion_id": "1701053843",
        "commented_code": "@@ -0,0 +1,614 @@\n+import {expect, test} from 'vitest';\n+import type {JSONObject} from '../../shared/src/json.js';\n+\n+// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+type TODO = any;\n+type Issue = {\n+  id: number;\n+  title: string;\n+};\n+const event = Symbol();\n+const node = Symbol();\n+type Event = Add | Remove | NoOp;\n+const ADD = 1;\n+const REMOVE = -1;\n+const NO_OP = 0;\n+\n+type Add = typeof ADD;\n+type Remove = typeof REMOVE;\n+type NoOp = typeof NO_OP;\n+type Entry<Type = JSONObject> = {\n+  [node]: Type;",
        "comment_created_at": "2024-08-02T13:53:17+00:00",
        "comment_author": "tantaman",
        "comment_body": "I've renamed things in the PR that is meant to be merged into main:\r\n\r\n- https://github.com/rocicorp/mono/pull/2109/files : packages/zql/src/zql/ivm-2/iterable-tree.ts\r\n\r\nI've also gone back to requiring all `Entity` types to have an `id` field. We'll need to revisit this when we add compound primary keys which we've discussed before.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2007894397",
    "pr_number": 4066,
    "pr_file": "packages/zero-cache/src/config/zero-config.test.ts",
    "created_at": "2025-03-21T16:09:01+00:00",
    "commented_code": "to reduce the amount of heap memory used during initial sync (e.g. for tables                     \n                                                                 with large rows).                                                                                 \n                                                                                                                                                                   \n+     --max-row-count number                                     optional",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "2007894397",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4066,
        "pr_file": "packages/zero-cache/src/config/zero-config.test.ts",
        "discussion_id": "2007894397",
        "commented_code": "@@ -289,6 +289,11 @@ test('zero-cache --help', () => {\n                                                                 to reduce the amount of heap memory used during initial sync (e.g. for tables                     \n                                                                 with large rows).                                                                                 \n                                                                                                                                                                   \n+     --max-row-count number                                     optional                                                                                          ",
        "comment_created_at": "2025-03-21T16:09:01+00:00",
        "comment_author": "darkgnotic",
        "comment_body": "Some suggestions for names that might be clearer to the reader:\r\n* `--target-client-row-count`\r\n* `--max-client-row-count`\r\n\r\nA couple of concepts that would be good to convey are (1) this is a per-client parameter and not global to the server, and (2) it's not a hard max, and clients can go over it if all of the queries are active.\r\n\r\nThoughts?",
        "pr_file_module": null
      },
      {
        "comment_id": "2009753730",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 4066,
        "pr_file": "packages/zero-cache/src/config/zero-config.test.ts",
        "discussion_id": "2007894397",
        "commented_code": "@@ -289,6 +289,11 @@ test('zero-cache --help', () => {\n                                                                 to reduce the amount of heap memory used during initial sync (e.g. for tables                     \n                                                                 with large rows).                                                                                 \n                                                                                                                                                                   \n+     --max-row-count number                                     optional                                                                                          ",
        "comment_created_at": "2025-03-24T09:05:59+00:00",
        "comment_author": "arv",
        "comment_body": "I like `--target-client-row-count`\r\n\r\nI will also take another stab the description",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1890343306",
    "pr_number": 3409,
    "pr_file": "packages/zero-client/src/client/zero.ts",
    "created_at": "2024-12-18T14:35:18+00:00",
    "commented_code": "// overwriting location fields for security reasons.\n   #reload = () => getBrowserGlobal('location')?.reload();\n \n+  /**\n+   * Whether the Zero instance was configured with a valid server URL\n+   * and is enabled.\n+   */\n+  get enabled(): boolean {",
    "repo_full_name": "rocicorp/mono",
    "discussion_comments": [
      {
        "comment_id": "1890343306",
        "repo_full_name": "rocicorp/mono",
        "pr_number": 3409,
        "pr_file": "packages/zero-client/src/client/zero.ts",
        "discussion_id": "1890343306",
        "commented_code": "@@ -362,6 +362,14 @@ export class Zero<const S extends Schema> {\n   // overwriting location fields for security reasons.\n   #reload = () => getBrowserGlobal('location')?.reload();\n \n+  /**\n+   * Whether the Zero instance was configured with a valid server URL\n+   * and is enabled.\n+   */\n+  get enabled(): boolean {",
        "comment_created_at": "2024-12-18T14:35:18+00:00",
        "comment_author": "tantaman",
        "comment_body": "enabled is a bit vague. Something more descriptive about the feature this supports would be better.",
        "pr_file_module": null
      }
    ]
  }
]