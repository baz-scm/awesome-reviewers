[
  {
    "discussion_id": "2179967684",
    "pr_number": 12546,
    "pr_file": "packages/cli/src/chat/chat-service.ts",
    "created_at": "2025-07-02T12:47:57+00:00",
    "commented_code": "+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));\n+\n+\t\tif (message.files) {\n+\t\t\tmessage.files = message.files.map((file) => ({\n+\t\t\t\t...file,\n+\t\t\t\tdata: file.data.includes('base64,') ? file.data.split('base64,')[1] : file.data,\n+\t\t\t}));\n+\t\t}\n+\n+\t\treturn message;\n+\t}\n+\n+\tprivate async checkHeartbeats() {\n+\t\ttry {\n+\t\t\tconst now = Date.now();\n+\t\t\tconst disconnected: string[] = [];\n+\n+\t\t\tfor (const [key, session] of this.sessions.entries()) {\n+\t\t\t\tif (!session) continue;\n+\n+\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat || 0);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2179967684",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 12546,
        "pr_file": "packages/cli/src/chat/chat-service.ts",
        "discussion_id": "2179967684",
        "commented_code": "@@ -0,0 +1,298 @@\n+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));\n+\n+\t\tif (message.files) {\n+\t\t\tmessage.files = message.files.map((file) => ({\n+\t\t\t\t...file,\n+\t\t\t\tdata: file.data.includes('base64,') ? file.data.split('base64,')[1] : file.data,\n+\t\t\t}));\n+\t\t}\n+\n+\t\treturn message;\n+\t}\n+\n+\tprivate async checkHeartbeats() {\n+\t\ttry {\n+\t\t\tconst now = Date.now();\n+\t\t\tconst disconnected: string[] = [];\n+\n+\t\t\tfor (const [key, session] of this.sessions.entries()) {\n+\t\t\t\tif (!session) continue;\n+\n+\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat || 0);",
        "comment_created_at": "2025-07-02T12:47:57+00:00",
        "comment_author": "tomi",
        "comment_body": "\n```suggestion\n\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat ?? 0);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180007686",
    "pr_number": 12546,
    "pr_file": "packages/cli/src/chat/__tests__/utils.test.ts",
    "created_at": "2025-07-02T13:00:35+00:00",
    "commented_code": "+import type { IExecutionResponse } from '@n8n/db';\n+import type { IDataObject, INode } from 'n8n-workflow';\n+import {\n+\tCHAT_TRIGGER_NODE_TYPE,\n+\tCHAT_WAIT_USER_REPLY,\n+\tRESPOND_TO_WEBHOOK_NODE_TYPE,\n+} from 'n8n-workflow';\n+\n+import {\n+\tgetMessage,\n+\tgetLastNodeExecuted,\n+\tprepareMessageFromLastNode,\n+\tisResponseNodeMode,\n+\tshouldResumeImmediately,\n+} from '../utils';\n+\n+// helpers --------------------------------------------------------\n+const createMockExecution = (\n+\toverrides: IDataObject = {},\n+\tfirstExecutionData?: IDataObject,\n+\tnodeData?: IDataObject[],\n+): IExecutionResponse => {\n+\tconst firstItem = firstExecutionData || {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2180007686",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 12546,
        "pr_file": "packages/cli/src/chat/__tests__/utils.test.ts",
        "discussion_id": "2180007686",
        "commented_code": "@@ -0,0 +1,522 @@\n+import type { IExecutionResponse } from '@n8n/db';\n+import type { IDataObject, INode } from 'n8n-workflow';\n+import {\n+\tCHAT_TRIGGER_NODE_TYPE,\n+\tCHAT_WAIT_USER_REPLY,\n+\tRESPOND_TO_WEBHOOK_NODE_TYPE,\n+} from 'n8n-workflow';\n+\n+import {\n+\tgetMessage,\n+\tgetLastNodeExecuted,\n+\tprepareMessageFromLastNode,\n+\tisResponseNodeMode,\n+\tshouldResumeImmediately,\n+} from '../utils';\n+\n+// helpers --------------------------------------------------------\n+const createMockExecution = (\n+\toverrides: IDataObject = {},\n+\tfirstExecutionData?: IDataObject,\n+\tnodeData?: IDataObject[],\n+): IExecutionResponse => {\n+\tconst firstItem = firstExecutionData || {",
        "comment_created_at": "2025-07-02T13:00:35+00:00",
        "comment_author": "tomi",
        "comment_body": "Use ?? instead of ||. Applies to other places too in here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215780798",
    "pr_number": 17121,
    "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts",
    "created_at": "2025-07-18T11:11:52+00:00",
    "commented_code": "+import type { IDataObject } from 'n8n-workflow';\n+import type { JsonSchema7Type } from 'zod-to-json-schema';\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: 'base64';\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'url';\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'file';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: 'text';\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'image';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'document';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_use';\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_result';\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'container_upload';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: 'user' | 'assistant';\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: 'file';\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: 'custom';\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'web_search_20250305';\n+\t\t\tname: 'web_search';\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: 'code_execution_20250522';\n+\t\t\tname: 'code_execution';\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2215823147",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts",
        "discussion_id": "2215780798",
        "commented_code": "@@ -0,0 +1,94 @@\n+import type { IDataObject } from 'n8n-workflow';\n+import type { JsonSchema7Type } from 'zod-to-json-schema';\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: 'base64';\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'url';\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'file';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: 'text';\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'image';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'document';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_use';\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_result';\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'container_upload';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: 'user' | 'assistant';\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: 'file';\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: 'custom';\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'web_search_20250305';\n+\t\t\tname: 'web_search';\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: 'code_execution_20250522';\n+\t\t\tname: 'code_execution';\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;",
        "comment_created_at": "2025-07-18T11:33:38+00:00",
        "comment_author": "RomanDavydchuk",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  }
]