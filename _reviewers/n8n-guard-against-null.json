[
  {
    "discussion_id": "2204727080",
    "pr_number": 17297,
    "pr_file": "packages/nodes-base/nodes/Microsoft/Teams/v2/transport/index.ts",
    "created_at": "2025-07-14T12:01:47+00:00",
    "commented_code": "uri?: string,\n \theaders: IDataObject = {},\n ): Promise<any> {\n+\tconst credentials = (await this.getCredentials('microsoftTeamsOAuth2Api')) as IDataObject;",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2204727080",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17297,
        "pr_file": "packages/nodes-base/nodes/Microsoft/Teams/v2/transport/index.ts",
        "discussion_id": "2204727080",
        "commented_code": "@@ -20,14 +20,18 @@ export async function microsoftApiRequest(\n \turi?: string,\n \theaders: IDataObject = {},\n ): Promise<any> {\n+\tconst credentials = (await this.getCredentials('microsoftTeamsOAuth2Api')) as IDataObject;",
        "comment_created_at": "2025-07-14T12:01:47+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nIf getCredentials returns undefined (for example when credentials are not configured), subsequent access to credentials.baseUrl will throw a runtime TypeError, causing the node to fail before the existing error-handling logic can run.\n\n```suggestion\n\tconst credentials = ((await this.getCredentials('microsoftTeamsOAuth2Api')) as IDataObject) || {};\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2225902434",
    "pr_number": 17590,
    "pr_file": "packages/frontend/editor-ui/src/stores/settings.store.ts",
    "created_at": "2025-07-23T15:08:40+00:00",
    "commented_code": "const isDevRelease = computed(() => settings.value.releaseChannel === 'dev');\n \n-\tconst activeModules = computed(() => settings.value.activeModules);\n+\t// TODO: Hard-coding this for now until back-end is merged\n+\tconst activeModules = computed(() => [...settings.value.activeModules, 'data-store']);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2225902434",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17590,
        "pr_file": "packages/frontend/editor-ui/src/stores/settings.store.ts",
        "discussion_id": "2225902434",
        "commented_code": "@@ -178,7 +178,12 @@ export const useSettingsStore = defineStore(STORES.SETTINGS, () => {\n \n \tconst isDevRelease = computed(() => settings.value.releaseChannel === 'dev');\n \n-\tconst activeModules = computed(() => settings.value.activeModules);\n+\t// TODO: Hard-coding this for now until back-end is merged\n+\tconst activeModules = computed(() => [...settings.value.activeModules, 'data-store']);",
        "comment_created_at": "2025-07-23T15:08:40+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[]} -->\nSpreading settings.value.activeModules without a null-check will throw if the property is undefined during store initialization\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/frontend/editor-ui/src/stores/settings.store.ts at line 182:\n\n<comment>Spreading settings.value.activeModules without a null-check will throw if the property is undefined during store initialization</comment>\n\n<file context>\n@@ -178,7 +178,12 @@ export const useSettingsStore = defineStore(STORES.SETTINGS, () =&gt; {\n \n \tconst isDevRelease = computed(() =&gt; settings.value.releaseChannel === &#39;dev&#39;);\n \n-\tconst activeModules = computed(() =&gt; settings.value.activeModules);\n+\t// TODO: Hard-coding this for now until back-end is merged\n+\tconst activeModules = computed(() =&gt; [...settings.value.activeModules, &#39;data-store&#39;]);\n+\n+\tconst isModuleActive = (moduleName: string) =&gt; {\n</file context>\n```\n\n</details>\n\n```suggestion\n\tconst activeModules = computed(() => [...(settings.value.activeModules ?? []), 'data-store']);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216136549",
    "pr_number": 17404,
    "pr_file": "packages/cli/src/evaluation.ee/test-runner/test-runner.service.ee.ts",
    "created_at": "2025-07-18T14:09:13+00:00",
    "commented_code": "return triggerOutput;\n \t}\n \n+\tprivate getEvaluationData(\n+\t\texecution: IRun,\n+\t\tworkflow: IWorkflowBase,\n+\t\toperation: 'setInputs' | 'setOutputs',\n+\t): IDataObject {\n+\t\tconst evalNodes = TestRunnerService.getEvaluationNodes(workflow, operation);\n+\n+\t\treturn evalNodes.reduce((accu: IDataObject, node: INode) => {\n+\t\t\tconst runs = execution.data.resultData.runData[node.name];\n+\t\t\tconst data = runs[0]?.data?.[NodeConnectionTypes.Main]?.[0]?.[0]?.evaluationData ?? {};",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2216136549",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17404,
        "pr_file": "packages/cli/src/evaluation.ee/test-runner/test-runner.service.ee.ts",
        "discussion_id": "2216136549",
        "commented_code": "@@ -401,6 +410,24 @@ export class TestRunnerService {\n \t\treturn triggerOutput;\n \t}\n \n+\tprivate getEvaluationData(\n+\t\texecution: IRun,\n+\t\tworkflow: IWorkflowBase,\n+\t\toperation: 'setInputs' | 'setOutputs',\n+\t): IDataObject {\n+\t\tconst evalNodes = TestRunnerService.getEvaluationNodes(workflow, operation);\n+\n+\t\treturn evalNodes.reduce((accu: IDataObject, node: INode) => {\n+\t\t\tconst runs = execution.data.resultData.runData[node.name];\n+\t\t\tconst data = runs[0]?.data?.[NodeConnectionTypes.Main]?.[0]?.[0]?.evaluationData ?? {};",
        "comment_created_at": "2025-07-18T14:09:13+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"export enum NodeConnectionTypes\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"enum NodeConnectionTypes\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"NodeConnectionTypes\\\" --include='*.ts'\"},\"toolName\":\"executeCommand\"}]}]} -->\nIf `runs` is undefined (e.g., when an evaluation node did not execute), attempting to access `runs[0]` throws a TypeError before optional chaining is applied, breaking the whole evaluation run.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/cli/src/evaluation.ee/test-runner/test-runner.service.ee.ts at line 422:\n\n<comment>If `runs` is undefined (e.g., when an evaluation node did not execute), attempting to access `runs[0]` throws a TypeError before optional chaining is applied, breaking the whole evaluation run.</comment>\n\n<file context>\n@@ -7,6 +7,7 @@ import {\n \tEVALUATION_NODE_TYPE,\n \tEVALUATION_TRIGGER_NODE_TYPE,\n \tExecutionCancelledError,\n+\tNodeConnectionTypes,\n } from &#39;n8n-workflow&#39;;\n import type {\n \tIDataObject,\n@@ -17,6 +18,7 @@ import type {\n \tAssignmentCollectionValue,\n \tGenericValue,\n \tIExecuteData,\n+\tINode,\n } from &#39;n8n-workflow&#39;;\n import assert from &#39;node:assert&#39;;\n \n@@ -360,21 +362,28 @@ export class TestRunnerService {\n \t/**\n \t * Get the evaluation set metrics nodes from a workflow.\n \t */\n-\tstatic getEvaluationMetricsNodes(workflow: IWorkflowBase) {\n+\tstatic getEvaluationNodes(workflow: IWorkflowBase, operation: string, defaultOption = false) {\n \t\treturn workflow.nodes.filter(\n-\t\t\t(node) =&gt; node.type === EVALUATION_NODE_TYPE &amp;&amp; node.parameters.operation === &#39;setMetrics&#39;,\n+\t\t\t(node) =&gt;\n+\t\t\t\tnode.type === EVALUATION_NODE_TYPE &amp;&amp;\n+\t\t\t\tnode.disabled !== true &amp;&amp;\n+\t\t\t\t(node.parameters.operation === operation ||\n+\t\t\t\t\t(defaultOption &amp;&amp; node.parameters.operation === undefined)),\n \t\t);\n \t}\n \n+\t/**\n+\t * Get the evaluation set metrics nodes from a workflow.\n+\t */\n+\tstatic getEvaluationMetricsNodes(workflow: IWorkflowBase) {\n+\t\treturn this.getEvaluationNodes(workflow, &#39;setMetrics&#39;);\n+\t}\n+\n \t/**\n \t * Get the evaluation set outputs nodes from a workflow.\n \t */\n \tstatic getEvaluationSetOutputsNodes(workflow: IWorkflowBase) {\n-\t\treturn workflow.nodes.filter(\n-\t\t\t(node) =&gt;\n-\t\t\t\tnode.type === EVALUATION_NODE_TYPE &amp;&amp;\n-\t\t\t\t(node.parameters.operation === &#39;setOutputs&#39; || node.parameters.operation === undefined),\n-\t\t);\n+\t\treturn this.getEvaluationNodes(workflow, &#39;setOutputs&#39;, true);\n \t}\n \n \t/**\n@@ -392,7 +401,7 @@ export class TestRunnerService {\n \t\t\t});\n \t\t}\n \n-\t\tconst triggerOutput = triggerOutputData?.data?.main?.[0];\n+\t\tconst triggerOutput = triggerOutputData?.data?.[NodeConnectionTypes.Main]?.[0];\n \n \t\tif (!triggerOutput || triggerOutput.length === 0) {\n \t\t\tthrow new TestRunError(&#39;TEST_CASES_NOT_FOUND&#39;);\n@@ -401,6 +410,24 @@ export class TestRunnerService {\n \t\treturn triggerOutput;\n \t}\n \n+\tprivate getEvaluationData(\n+\t\texecution: IRun,\n+\t\tworkflow: IWorkflowBase,\n+\t\toperation: &#39;setInputs&#39; | &#39;setOutputs&#39;,\n+\t): IDataObject {\n+\t\tconst evalNodes = TestRunnerService.getEvaluationNodes(workflow, operation);\n+\n+\t\treturn evalNodes.reduce((accu: IDataObject, node: INode) =&gt; {\n+\t\t\tconst runs = execution.data.resultData.runData[node.name];\n+\t\t\tconst data = runs[0]?.data?.[NodeConnectionTypes.Main]?.[0]?.[0]?.evaluationData ?? {};\n+\n+\t\t\treturn {\n+\t\t\t\t...accu,\n+\t\t\t\t...data,\n+\t\t\t};\n+\t\t}, {} as IDataObject);\n+\t}\n+\n \t/**\n \t * Evaluation result is collected from all Evaluation Metrics nodes\n \t */\n@@ -594,6 +621,9 @@ export class TestRunnerService {\n \t\t\t\t\t\t\t...addedPredefinedMetrics,\n \t\t\t\t\t\t};\n \n+\t\t\t\t\t\tconst inputs = this.getEvaluationData(testCaseExecution, workflow, &#39;setInputs&#39;);\n+\t\t\t\t\t\tconst outputs = this.getEvaluationData(testCaseExecution, workflow, &#39;setOutputs&#39;);\n+\n \t\t\t\t\t\tthis.logger.debug(\n \t\t\t\t\t\t\t&#39;Test case metrics extracted (user-defined)&#39;,\n \t\t\t\t\t\t\taddedUserDefinedMetrics,\n@@ -609,6 +639,8 @@ export class TestRunnerService {\n \t\t\t\t\t\t\tcompletedAt,\n \t\t\t\t\t\t\tstatus: &#39;success&#39;,\n \t\t\t\t\t\t\tmetrics: combinedMetrics,\n+\t\t\t\t\t\t\tinputs,\n+\t\t\t\t\t\t\toutputs,\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t} catch (e) {\n</file context>\n```\n\n</details>\n\n```suggestion\n\t\t\tconst data = runs?.[0]?.data?.[NodeConnectionTypes.Main]?.[0]?.[0]?.evaluationData ?? {};\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179967684",
    "pr_number": 12546,
    "pr_file": "packages/cli/src/chat/chat-service.ts",
    "created_at": "2025-07-02T12:47:57+00:00",
    "commented_code": "+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));\n+\n+\t\tif (message.files) {\n+\t\t\tmessage.files = message.files.map((file) => ({\n+\t\t\t\t...file,\n+\t\t\t\tdata: file.data.includes('base64,') ? file.data.split('base64,')[1] : file.data,\n+\t\t\t}));\n+\t\t}\n+\n+\t\treturn message;\n+\t}\n+\n+\tprivate async checkHeartbeats() {\n+\t\ttry {\n+\t\t\tconst now = Date.now();\n+\t\t\tconst disconnected: string[] = [];\n+\n+\t\t\tfor (const [key, session] of this.sessions.entries()) {\n+\t\t\t\tif (!session) continue;\n+\n+\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat || 0);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2179967684",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 12546,
        "pr_file": "packages/cli/src/chat/chat-service.ts",
        "discussion_id": "2179967684",
        "commented_code": "@@ -0,0 +1,298 @@\n+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));\n+\n+\t\tif (message.files) {\n+\t\t\tmessage.files = message.files.map((file) => ({\n+\t\t\t\t...file,\n+\t\t\t\tdata: file.data.includes('base64,') ? file.data.split('base64,')[1] : file.data,\n+\t\t\t}));\n+\t\t}\n+\n+\t\treturn message;\n+\t}\n+\n+\tprivate async checkHeartbeats() {\n+\t\ttry {\n+\t\t\tconst now = Date.now();\n+\t\t\tconst disconnected: string[] = [];\n+\n+\t\t\tfor (const [key, session] of this.sessions.entries()) {\n+\t\t\t\tif (!session) continue;\n+\n+\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat || 0);",
        "comment_created_at": "2025-07-02T12:47:57+00:00",
        "comment_author": "tomi",
        "comment_body": "\n```suggestion\n\t\t\t\tconst timeSinceLastHeartbeat = now - (session.lastHeartbeat ?? 0);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180007686",
    "pr_number": 12546,
    "pr_file": "packages/cli/src/chat/__tests__/utils.test.ts",
    "created_at": "2025-07-02T13:00:35+00:00",
    "commented_code": "+import type { IExecutionResponse } from '@n8n/db';\n+import type { IDataObject, INode } from 'n8n-workflow';\n+import {\n+\tCHAT_TRIGGER_NODE_TYPE,\n+\tCHAT_WAIT_USER_REPLY,\n+\tRESPOND_TO_WEBHOOK_NODE_TYPE,\n+} from 'n8n-workflow';\n+\n+import {\n+\tgetMessage,\n+\tgetLastNodeExecuted,\n+\tprepareMessageFromLastNode,\n+\tisResponseNodeMode,\n+\tshouldResumeImmediately,\n+} from '../utils';\n+\n+// helpers --------------------------------------------------------\n+const createMockExecution = (\n+\toverrides: IDataObject = {},\n+\tfirstExecutionData?: IDataObject,\n+\tnodeData?: IDataObject[],\n+): IExecutionResponse => {\n+\tconst firstItem = firstExecutionData || {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2180007686",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 12546,
        "pr_file": "packages/cli/src/chat/__tests__/utils.test.ts",
        "discussion_id": "2180007686",
        "commented_code": "@@ -0,0 +1,522 @@\n+import type { IExecutionResponse } from '@n8n/db';\n+import type { IDataObject, INode } from 'n8n-workflow';\n+import {\n+\tCHAT_TRIGGER_NODE_TYPE,\n+\tCHAT_WAIT_USER_REPLY,\n+\tRESPOND_TO_WEBHOOK_NODE_TYPE,\n+} from 'n8n-workflow';\n+\n+import {\n+\tgetMessage,\n+\tgetLastNodeExecuted,\n+\tprepareMessageFromLastNode,\n+\tisResponseNodeMode,\n+\tshouldResumeImmediately,\n+} from '../utils';\n+\n+// helpers --------------------------------------------------------\n+const createMockExecution = (\n+\toverrides: IDataObject = {},\n+\tfirstExecutionData?: IDataObject,\n+\tnodeData?: IDataObject[],\n+): IExecutionResponse => {\n+\tconst firstItem = firstExecutionData || {",
        "comment_created_at": "2025-07-02T13:00:35+00:00",
        "comment_author": "tomi",
        "comment_body": "Use ?? instead of ||. Applies to other places too in here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218883922",
    "pr_number": 17499,
    "pr_file": "packages/frontend/editor-ui/src/stores/cloudPlan.store.ts",
    "created_at": "2025-07-21T11:18:49+00:00",
    "commented_code": "const currentUsageData = computed(() => state.usage);\n \n+\tconst selectedApps = computed(() => currentUserCloudInfo.value?.selectedApps?.split(',') ?? []);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2218883922",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17499,
        "pr_file": "packages/frontend/editor-ui/src/stores/cloudPlan.store.ts",
        "discussion_id": "2218883922",
        "commented_code": "@@ -41,6 +41,26 @@ export const useCloudPlanStore = defineStore(STORES.CLOUD_PLAN, () => {\n \n \tconst currentUsageData = computed(() => state.usage);\n \n+\tconst selectedApps = computed(() => currentUserCloudInfo.value?.selectedApps?.split(',') ?? []);",
        "comment_created_at": "2025-07-21T11:18:49+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"selectedApps\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"export const useCloudPlanStore\\\" -n packages/frontend/editor-ui/src/stores\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '450,520p' packages/frontend/editor-ui/src/stores/templates.store.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"selectedApps = computed\\\" -R packages/frontend/editor-ui/src/stores | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"codingSkill\\\" packages/frontend/editor-ui/src | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"selectedApps = computed\\\" packages/frontend/editor-ui/src/stores/cloudPlan.store.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"cloudPlanStore\\\\.selectedApps\\\" -n packages/frontend/editor-ui/src/stores/templates.store.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nsplit(&#39;,&#39;) returns [&quot;&quot;] for an empty string, so selectedApps may contain a spurious empty element. Filter out falsy items to ensure the array is truly empty when no apps are selected.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/frontend/editor-ui/src/stores/cloudPlan.store.ts at line 44:\n\n<comment>split(&#39;,&#39;) returns [&quot;&quot;] for an empty string, so selectedApps may contain a spurious empty element. Filter out falsy items to ensure the array is truly empty when no apps are selected.</comment>\n\n<file context>\n@@ -41,6 +41,26 @@ export const useCloudPlanStore = defineStore(STORES.CLOUD_PLAN, () =&gt; {\n \n \tconst currentUsageData = computed(() =&gt; state.usage);\n \n+\tconst selectedApps = computed(() =&gt; currentUserCloudInfo.value?.selectedApps?.split(&#39;,&#39;) ?? []);\n+\tconst codingSkill = computed(() =&gt; {\n+\t\tconst information = currentUserCloudInfo.value?.information;\n+\t\tif (!information) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tif (\n+\t\t\t!(\n+\t\t\t\t&#39;which_of_these_do_you_feel_comfortable_doing&#39; in information &amp;&amp;\n+\t\t\t\tinformation.which_of_these_do_you_feel_comfortable_doing &amp;&amp;\n+\t\t\t\tArray.isArray(information.which_of_these_do_you_feel_comfortable_doing)\n+\t\t\t)\n+\t\t) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\treturn information.which_of_these_do_you_feel_comfortable_doing.length;\n+\t});\n+\n \tconst trialExpired = computed(\n \t\t() =&gt;\n \t\t\tstate.data?.metadata?.group === &#39;trial&#39; &amp;&amp;\n@@ -195,5 +215,7 @@ export const useCloudPlanStore = defineStore(STORES.CLOUD_PLAN, () =&gt; {\n \t\tcheckForCloudPlanData,\n \t\tfetchUserCloudAccount,\n \t\tgetAutoLoginCode,\n+\t\tselectedApps,\n+\t\tcodingSkill,\n \t};\n });\n</file context>\n```\n\n</details>\n\n```suggestion\n\tconst selectedApps = computed(() => currentUserCloudInfo.value?.selectedApps?.split(',').filter(Boolean) ?? []);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214077260",
    "pr_number": 17423,
    "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/utils/tool-executor.ts",
    "created_at": "2025-07-17T19:02:33+00:00",
    "commented_code": "+import type { BaseMessage } from '@langchain/core/messages';\n+import { isAIMessage, ToolMessage } from '@langchain/core/messages';\n+import { ToolInputParsingException } from '@langchain/core/tools';\n+import { isCommand } from '@langchain/langgraph';\n+\n+import { ToolExecutionError, WorkflowStateError } from '../errors';\n+import type { ToolExecutorOptions } from '../types/config';\n+import type { WorkflowOperation } from '../types/workflow';\n+import type { WorkflowState } from '../workflow-state';\n+\n+/**\n+ * PARALLEL TOOL EXECUTION\n+ *\n+ * This executor handles running multiple tools in parallel and collecting their results.\n+ * All workflow modifications are done through operations that are processed by the\n+ * operations processor node.\n+ *\n+ * This executor:\n+ * 1. Executes all tools in parallel\n+ * 2. Collects their operations and messages\n+ * 3. Returns a single update with all operations to be processed\n+ */\n+\n+/**\n+ * Execute multiple tools in parallel and collect their state updates\n+ *\n+ * Tools return operations that will be processed by the operations processor node.\n+ * This function executes tools and collects all their operations and messages.\n+ *\n+ * @param options - Contains the current state and tool map\n+ * @returns Combined state updates from all tool executions\n+ */\n+export async function executeToolsInParallel(\n+\toptions: ToolExecutorOptions,\n+): Promise<Partial<typeof WorkflowState.State>> {\n+\tconst { state, toolMap } = options;\n+\tconst lastMessage = state.messages.at(-1);\n+\n+\tif (!lastMessage || !isAIMessage(lastMessage)) {\n+\t\tconst error = new WorkflowStateError(\n+\t\t\t'Most recent message must be an AIMessage with tool calls',\n+\t\t);\n+\t\tthrow error;\n+\t}\n+\n+\tconst aiMessage = lastMessage;\n+\tif (!aiMessage.tool_calls?.length) {\n+\t\tconst error = new WorkflowStateError('AIMessage must have tool calls');\n+\t\tthrow error;\n+\t}\n+\n+\t// Execute all tools in parallel\n+\tconst toolResults = await Promise.all(\n+\t\taiMessage.tool_calls.map(async (toolCall) => {\n+\t\t\tconst tool = toolMap.get(toolCall.name);\n+\t\t\tif (!tool) {\n+\t\t\t\tthrow new ToolExecutionError(`Tool ${toolCall.name} not found`, {\n+\t\t\t\t\ttoolName: toolCall.name,\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tconst result: unknown = await tool.invoke(toolCall.args ?? {}, {\n+\t\t\t\t\ttoolCall: {\n+\t\t\t\t\t\tid: toolCall.id,\n+\t\t\t\t\t\tname: toolCall.name,\n+\t\t\t\t\t\targs: toolCall.args ?? {},\n+\t\t\t\t\t},\n+\t\t\t\t});\n+\n+\t\t\t\treturn result;\n+\t\t\t} catch (error) {\n+\t\t\t\t// Handle tool invocation errors by returning a ToolMessage with error\n+\t\t\t\t// This ensures the conversation history remains valid (every tool_use has a tool_result)\n+\t\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n+\n+\t\t\t\t// Create error message content\n+\t\t\t\tlet errorContent: string;\n+\t\t\t\tif (\n+\t\t\t\t\terror instanceof ToolInputParsingException ||\n+\t\t\t\t\terrorMessage.includes('expected schema')\n+\t\t\t\t) {\n+\t\t\t\t\terrorContent = `Invalid input for tool ${toolCall.name}: ${errorMessage}`;\n+\t\t\t\t} else {\n+\t\t\t\t\terrorContent = `Tool ${toolCall.name} failed: ${errorMessage}`;\n+\t\t\t\t}\n+\n+\t\t\t\t// Return a ToolMessage with the error to maintain conversation continuity\n+\t\t\t\treturn new ToolMessage({\n+\t\t\t\t\tcontent: errorContent,\n+\t\t\t\t\ttool_call_id: toolCall.id!,",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2214077260",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17423,
        "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/utils/tool-executor.ts",
        "discussion_id": "2214077260",
        "commented_code": "@@ -0,0 +1,142 @@\n+import type { BaseMessage } from '@langchain/core/messages';\n+import { isAIMessage, ToolMessage } from '@langchain/core/messages';\n+import { ToolInputParsingException } from '@langchain/core/tools';\n+import { isCommand } from '@langchain/langgraph';\n+\n+import { ToolExecutionError, WorkflowStateError } from '../errors';\n+import type { ToolExecutorOptions } from '../types/config';\n+import type { WorkflowOperation } from '../types/workflow';\n+import type { WorkflowState } from '../workflow-state';\n+\n+/**\n+ * PARALLEL TOOL EXECUTION\n+ *\n+ * This executor handles running multiple tools in parallel and collecting their results.\n+ * All workflow modifications are done through operations that are processed by the\n+ * operations processor node.\n+ *\n+ * This executor:\n+ * 1. Executes all tools in parallel\n+ * 2. Collects their operations and messages\n+ * 3. Returns a single update with all operations to be processed\n+ */\n+\n+/**\n+ * Execute multiple tools in parallel and collect their state updates\n+ *\n+ * Tools return operations that will be processed by the operations processor node.\n+ * This function executes tools and collects all their operations and messages.\n+ *\n+ * @param options - Contains the current state and tool map\n+ * @returns Combined state updates from all tool executions\n+ */\n+export async function executeToolsInParallel(\n+\toptions: ToolExecutorOptions,\n+): Promise<Partial<typeof WorkflowState.State>> {\n+\tconst { state, toolMap } = options;\n+\tconst lastMessage = state.messages.at(-1);\n+\n+\tif (!lastMessage || !isAIMessage(lastMessage)) {\n+\t\tconst error = new WorkflowStateError(\n+\t\t\t'Most recent message must be an AIMessage with tool calls',\n+\t\t);\n+\t\tthrow error;\n+\t}\n+\n+\tconst aiMessage = lastMessage;\n+\tif (!aiMessage.tool_calls?.length) {\n+\t\tconst error = new WorkflowStateError('AIMessage must have tool calls');\n+\t\tthrow error;\n+\t}\n+\n+\t// Execute all tools in parallel\n+\tconst toolResults = await Promise.all(\n+\t\taiMessage.tool_calls.map(async (toolCall) => {\n+\t\t\tconst tool = toolMap.get(toolCall.name);\n+\t\t\tif (!tool) {\n+\t\t\t\tthrow new ToolExecutionError(`Tool ${toolCall.name} not found`, {\n+\t\t\t\t\ttoolName: toolCall.name,\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tconst result: unknown = await tool.invoke(toolCall.args ?? {}, {\n+\t\t\t\t\ttoolCall: {\n+\t\t\t\t\t\tid: toolCall.id,\n+\t\t\t\t\t\tname: toolCall.name,\n+\t\t\t\t\t\targs: toolCall.args ?? {},\n+\t\t\t\t\t},\n+\t\t\t\t});\n+\n+\t\t\t\treturn result;\n+\t\t\t} catch (error) {\n+\t\t\t\t// Handle tool invocation errors by returning a ToolMessage with error\n+\t\t\t\t// This ensures the conversation history remains valid (every tool_use has a tool_result)\n+\t\t\t\tconst errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n+\n+\t\t\t\t// Create error message content\n+\t\t\t\tlet errorContent: string;\n+\t\t\t\tif (\n+\t\t\t\t\terror instanceof ToolInputParsingException ||\n+\t\t\t\t\terrorMessage.includes('expected schema')\n+\t\t\t\t) {\n+\t\t\t\t\terrorContent = `Invalid input for tool ${toolCall.name}: ${errorMessage}`;\n+\t\t\t\t} else {\n+\t\t\t\t\terrorContent = `Tool ${toolCall.name} failed: ${errorMessage}`;\n+\t\t\t\t}\n+\n+\t\t\t\t// Return a ToolMessage with the error to maintain conversation continuity\n+\t\t\t\treturn new ToolMessage({\n+\t\t\t\t\tcontent: errorContent,\n+\t\t\t\t\ttool_call_id: toolCall.id!,",
        "comment_created_at": "2025-07-17T19:02:33+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"export class WorkflowState\\\" -R packages/@n8n/ai-workflow-builder.ee/src | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/@n8n/ai-workflow-builder.ee/src/workflow-state.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '60,120p' packages/@n8n/ai-workflow-builder.ee/src/utils/tool-executor.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"nl -ba packages/@n8n/ai-workflow-builder.ee/src/utils/tool-executor.ts | head -n 200\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function messagesStateReducer\\\" $(npm root) || true\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"interface ToolCall\\\" $(npm root)/@langchain | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function messagesStateReducer\\\" $(pwd) | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"\\\\.State\\\" packages/@n8n/ai-workflow-builder.ee/src | head\"},\"toolName\":\"executeCommand\"}]}]} -->\nThe non-null assertion `!` assumes `toolCall.id` is always defined. If the ID is missing, this will throw at runtime when the message is serialized. Use a safe fallback or validate before use.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/@n8n/ai-workflow-builder.ee/src/utils/tool-executor.ts at line 91:\n\n<comment>The non-null assertion `!` assumes `toolCall.id` is always defined. If the ID is missing, this will throw at runtime when the message is serialized. Use a safe fallback or validate before use.</comment>\n\n<file context>\n@@ -0,0 +1,142 @@\n+import type { BaseMessage } from &#39;@langchain/core/messages&#39;;\n+import { isAIMessage, ToolMessage } from &#39;@langchain/core/messages&#39;;\n+import { ToolInputParsingException } from &#39;@langchain/core/tools&#39;;\n+import { isCommand } from &#39;@langchain/langgraph&#39;;\n+\n+import { ToolExecutionError, WorkflowStateError } from &#39;../errors&#39;;\n+import type { ToolExecutorOptions } from &#39;../types/config&#39;;\n+import type { WorkflowOperation } from &#39;../types/workflow&#39;;\n+import type { WorkflowState } from &#39;../workflow-state&#39;;\n+\n+/**\n+ * PARALLEL TOOL EXECUTION\n+ *\n+ * This executor handles running multiple tools in parallel and collecting their results.\n+ * All workflow modifications are done through operations that are processed by the\n+ * operations processor node.\n+ *\n+ * This executor:\n+ * 1. Executes all tools in parallel\n+ * 2. Collects their operations and messages\n+ * 3. Returns a single update with all operations to be processed\n+ */\n+\n+/**\n+ * Execute multiple tools in parallel and collect their state updates\n+ *\n+ * Tools return operations that will be processed by the operations processor node.\n+ * This function executes tools and collects all their operations and messages.\n+ *\n+ * @param options - Contains the current state and tool map\n+ * @returns Combined state updates from all tool executions\n+ */\n+export async function executeToolsInParallel(\n+\toptions: ToolExecutorOptions,\n+): Promise&lt;Partial&lt;typeof WorkflowState.State&gt;&gt; {\n+\tconst { state, toolMap } = options;\n+\tconst lastMessage = state.messages.at(-1);\n+\n+\tif (!lastMessage || !isAIMessage(lastMessage)) {\n+\t\tconst error = new WorkflowStateError(\n+\t\t\t&#39;Most recent message must be an AIMessage with tool calls&#39;,\n+\t\t);\n+\t\tthrow error;\n+\t}\n+\n+\tconst aiMessage = lastMessage;\n+\tif (!aiMessage.tool_calls?.length) {\n+\t\tconst error = new WorkflowStateError(&#39;AIMessage must have tool calls&#39;);\n+\t\tthrow error;\n+\t}\n+\n+\t// Execute all tools in parallel\n+\tconst toolResults = await Promise.all(\n+\t\taiMessage.tool_calls.map(async (toolCall) =&gt; {\n+\t\t\tconst tool = toolMap.get(toolCall.name);\n+\t\t\tif (!tool) {\n+\t\t\t\tthrow new ToolExecutionError(`Tool ${toolCall.name} not found`, {\n+\t\t\t\t\ttoolName: toolCall.name,\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\tconst result: unknown = await tool.invoke(toolCall.args ?? {}, {\n+\t\t\t\t\ttoolCall: {\n+\t\t\t\t\t\tid: toolCall.id,\n+\t\t\t\t\t\tname: toolCall.name,\n+\t\t\t\t\t\targs: toolCall.args ?? {},\n+\t\t\t\t\t},\n+\t\t\t\t});\n+\n+\t\t\t\treturn result;\n+\t\t\t} catch (error) {\n+\t\t\t\t// Handle tool invocation errors by returning a ToolMessage with error\n+\t\t\t\t// This ensures the conversation history remains valid (every tool_use has a tool_result)\n+\t\t\t\tconst errorMessage = error instanceof Error ? error.message : &#39;Unknown error occurred&#39;;\n+\n+\t\t\t\t// Create error message content\n+\t\t\t\tlet errorContent: string;\n+\t\t\t\tif (\n+\t\t\t\t\terror instanceof ToolInputParsingException ||\n+\t\t\t\t\terrorMessage.includes(&#39;expected schema&#39;)\n+\t\t\t\t) {\n+\t\t\t\t\terrorContent = `Invalid input for tool ${toolCall.name}: ${errorMessage}`;\n+\t\t\t\t} else {\n+\t\t\t\t\terrorContent = `Tool ${toolCall.name} failed: ${errorMessage}`;\n+\t\t\t\t}\n+\n+\t\t\t\t// Return a ToolMessage with the error to maintain conversation continuity\n+\t\t\t\treturn new ToolMessage({\n+\t\t\t\t\tcontent: errorContent,\n+\t\t\t\t\ttool_call_id: toolCall.id!,\n+\t\t\t\t\t// Include error flag so tools can handle errors appropriately\n+\t\t\t\t\tadditional_kwargs: { error: true },\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}),\n+\t);\n+\n+\t// Collect all messages and state updates\n+\tconst allMessages: BaseMessage[] = [];\n+\tconst stateUpdates: Array&lt;Partial&lt;typeof WorkflowState.State&gt;&gt; = [];\n+\n+\ttoolResults.forEach((result) =&gt; {\n+\t\tif (isCommand(result)) {\n+\t\t\t// Tool returned a Command with state updates\n+\t\t\tconst update = result.update as Partial&lt;typeof WorkflowState.State&gt;;\n+\t\t\tif (update) {\n+\t\t\t\tstateUpdates.push(update);\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Tool returned a regular message\n+\t\t\tallMessages.push(result as BaseMessage);\n+\t\t}\n+\t});\n+\n+\t// Collect all messages from state updates\n+\tstateUpdates.forEach((update) =&gt; {\n+\t\tif (update.messages &amp;&amp; Array.isArray(update.messages)) {\n+\t\t\tallMessages.push(...update.messages);\n+\t\t}\n+\t});\n+\n+\t// Collect all workflow operations\n+\tconst allOperations: WorkflowOperation[] = [];\n+\n+\tfor (const update of stateUpdates) {\n+\t\tif (update.workflowOperations &amp;&amp; Array.isArray(update.workflowOperations)) {\n+\t\t\tallOperations.push(...update.workflowOperations);\n+\t\t}\n+\t}\n+\n+\t// Return the combined update\n+\tconst finalUpdate: Partial&lt;typeof WorkflowState.State&gt; = {\n+\t\tmessages: allMessages,\n+\t};\n+\n+\tif (allOperations.length &gt; 0) {\n+\t\tfinalUpdate.workflowOperations = allOperations;\n+\t}\n+\n+\treturn finalUpdate;\n+}\n</file context>\n```\n\n</details>\n\n```suggestion\n\t\t\t\t\ttool_call_id: toolCall.id ?? '',\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215780798",
    "pr_number": 17121,
    "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts",
    "created_at": "2025-07-18T11:11:52+00:00",
    "commented_code": "+import type { IDataObject } from 'n8n-workflow';\n+import type { JsonSchema7Type } from 'zod-to-json-schema';\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: 'base64';\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'url';\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'file';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: 'text';\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'image';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'document';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_use';\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_result';\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'container_upload';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: 'user' | 'assistant';\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: 'file';\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: 'custom';\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'web_search_20250305';\n+\t\t\tname: 'web_search';\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: 'code_execution_20250522';\n+\t\t\tname: 'code_execution';\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2215780798",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts",
        "discussion_id": "2215780798",
        "commented_code": "@@ -0,0 +1,94 @@\n+import type { IDataObject } from 'n8n-workflow';\n+import type { JsonSchema7Type } from 'zod-to-json-schema';\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: 'base64';\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'url';\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'file';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: 'text';\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'image';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'document';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_use';\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_result';\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'container_upload';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: 'user' | 'assistant';\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: 'file';\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: 'custom';\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'web_search_20250305';\n+\t\t\tname: 'web_search';\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: 'code_execution_20250522';\n+\t\t\tname: 'code_execution';\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;",
        "comment_created_at": "2025-07-18T11:11:52+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -r \\\"interface File\\\" --line-number --include='*.ts'\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -r \\\"\\\" tsconfig*\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,120p' packages/@n8n/nodes-langchain/nodes/vendors/GoogleGemini/helpers/utils.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"cat packages/@n8n/typescript-config/tsconfig.common.json\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"JsonSchema7Type\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"interface Message\\\" -n packages/@n8n/nodes-langchain | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"interface File extends\\\" --line-number\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts\",\"line\":52,\"symbol\":\"File\"},\"toolName\":\"findReferences\"}]}]} -->\nAnthropic API can return null for stop_reason (e.g. while streaming or for unfinished conversations), but the type is constrained to string only, which will break type-checking where a null value is received.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts at line 84:\n\n<comment>Anthropic API can return null for stop_reason (e.g. while streaming or for unfinished conversations), but the type is constrained to string only, which will break type-checking where a null value is received.</comment>\n\n<file context>\n@@ -0,0 +1,94 @@\n+import type { IDataObject } from &#39;n8n-workflow&#39;;\n+import type { JsonSchema7Type } from &#39;zod-to-json-schema&#39;;\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: &#39;base64&#39;;\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;url&#39;;\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;file&#39;;\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: &#39;text&#39;;\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;image&#39;;\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;document&#39;;\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;tool_use&#39;;\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;tool_result&#39;;\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;container_upload&#39;;\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: &#39;user&#39; | &#39;assistant&#39;;\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: &#39;file&#39;;\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: &#39;custom&#39;;\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;web_search_20250305&#39;;\n+\t\t\tname: &#39;web_search&#39;;\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: &#39;code_execution_20250522&#39;;\n+\t\t\tname: &#39;code_execution&#39;;\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;\n+}\n+\n+export interface PromptResponse {\n+\tmessages: Message[];\n+\tsystem: string;\n+}\n+\n+export interface TemplatizeResponse extends PromptResponse {\n+\tvariable_values: IDataObject;\n+}\n</file context>\n```\n\n</details>\n\n```suggestion\n\tstop_reason: string | null;\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2215823147",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/interfaces.ts",
        "discussion_id": "2215780798",
        "commented_code": "@@ -0,0 +1,94 @@\n+import type { IDataObject } from 'n8n-workflow';\n+import type { JsonSchema7Type } from 'zod-to-json-schema';\n+\n+export type FileSource =\n+\t| {\n+\t\t\ttype: 'base64';\n+\t\t\tmedia_type: string;\n+\t\t\tdata: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'url';\n+\t\t\turl: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'file';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export type Content =\n+\t| {\n+\t\t\ttype: 'text';\n+\t\t\ttext: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'image';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'document';\n+\t\t\tsource: FileSource;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_use';\n+\t\t\tid: string;\n+\t\t\tname: string;\n+\t\t\tinput: IDataObject;\n+\t  }\n+\t| {\n+\t\t\ttype: 'tool_result';\n+\t\t\ttool_use_id: string;\n+\t\t\tcontent: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'container_upload';\n+\t\t\tfile_id: string;\n+\t  };\n+\n+export interface Message {\n+\trole: 'user' | 'assistant';\n+\tcontent: string | Content[];\n+}\n+\n+export interface File {\n+\tcreated_at: string;\n+\tdownloadable: boolean;\n+\tfilename: string;\n+\tid: string;\n+\tmime_type: string;\n+\tsize_bytes: number;\n+\ttype: 'file';\n+}\n+\n+export type Tool =\n+\t| {\n+\t\t\ttype: 'custom';\n+\t\t\tname: string;\n+\t\t\tinput_schema: JsonSchema7Type;\n+\t\t\tdescription: string;\n+\t  }\n+\t| {\n+\t\t\ttype: 'web_search_20250305';\n+\t\t\tname: 'web_search';\n+\t\t\tmax_uses?: number;\n+\t\t\tallowed_domains?: string[];\n+\t\t\tblocked_domains?: string[];\n+\t  }\n+\t| {\n+\t\t\ttype: 'code_execution_20250522';\n+\t\t\tname: 'code_execution';\n+\t  };\n+\n+export interface MessagesResponse {\n+\tcontent: Content[];\n+\tstop_reason: string;",
        "comment_created_at": "2025-07-18T11:33:38+00:00",
        "comment_author": "RomanDavydchuk",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2191934454",
    "pr_number": 17103,
    "pr_file": "packages/cli/src/sso.ee/oidc/oidc.service.ee.ts",
    "created_at": "2025-07-08T09:12:21+00:00",
    "commented_code": "if (currentConfig) {\n \t\t\ttry {\n \t\t\t\tconst oidcConfig = jsonParse<OidcConfigDto>(currentConfig.value);\n+\n+\t\t\t\tif (oidcConfig.discoveryEndpoint === '') return DEFAULT_OIDC_RUNTIME_CONFIG;",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2191934454",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17103,
        "pr_file": "packages/cli/src/sso.ee/oidc/oidc.service.ee.ts",
        "discussion_id": "2191934454",
        "commented_code": "@@ -156,6 +156,9 @@ export class OidcService {\n \t\tif (currentConfig) {\n \t\t\ttry {\n \t\t\t\tconst oidcConfig = jsonParse<OidcConfigDto>(currentConfig.value);\n+\n+\t\t\t\tif (oidcConfig.discoveryEndpoint === '') return DEFAULT_OIDC_RUNTIME_CONFIG;",
        "comment_created_at": "2025-07-08T09:12:21+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A3 -B3 -E \\\"if \\\\(oidcConfig.discoveryEndpoint === ''\\\" -n packages/cli/src/sso.ee/oidc/oidc.service.ee.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -r -n \\\"loadConfig(true\\\" -n packages/cli | head\"},\"toolName\":\"executeCommand\"}]}]} -->\nThe check only guards against an *empty string*, so `undefined`, `null`, or whitespace-only values for `discoveryEndpoint` will still reach the subsequent `new URL(...)` call and throw `TypeError: Invalid URL`, recreating the warning this PR intends to fix.\n\n```suggestion\n\t\t\t\tif (!oidcConfig.discoveryEndpoint) return DEFAULT_OIDC_RUNTIME_CONFIG;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198654848",
    "pr_number": 17210,
    "pr_file": "packages/@n8n/nodes-langchain/utils/helpers.ts",
    "created_at": "2025-07-10T20:26:14+00:00",
    "commented_code": "((await ctx.getInputConnectionData(NodeConnectionTypes.AiTool, 0)) as Array<Toolkit | Tool>) ??\n \t\t[]\n \t).flatMap((toolOrToolkit) => {\n-\t\tif (toolOrToolkit instanceof Toolkit) {\n-\t\t\treturn toolOrToolkit.getTools() as Tool[];\n+\t\tif (typeof (toolOrToolkit as Toolkit).getTools === 'function') {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2198654848",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17210,
        "pr_file": "packages/@n8n/nodes-langchain/utils/helpers.ts",
        "discussion_id": "2198654848",
        "commented_code": "@@ -195,11 +195,11 @@ export const getConnectedTools = async (\n \t\t((await ctx.getInputConnectionData(NodeConnectionTypes.AiTool, 0)) as Array<Toolkit | Tool>) ??\n \t\t[]\n \t).flatMap((toolOrToolkit) => {\n-\t\tif (toolOrToolkit instanceof Toolkit) {\n-\t\t\treturn toolOrToolkit.getTools() as Tool[];\n+\t\tif (typeof (toolOrToolkit as Toolkit).getTools === 'function') {",
        "comment_created_at": "2025-07-10T20:26:14+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A2 -B2 \\\"typeof (toolOrToolkit as Toolkit).getTools\\\" -r\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"Toolkit\\\" packages/@n8n/nodes-langchain/utils/helpers.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nAccessing `(toolOrToolkit as Toolkit).getTools` before verifying that `toolOrToolkit` is neither `null` nor `undefined` can throw a runtime `TypeError`. The property access is evaluated before the `typeof` check, so if an upstream node accidentally passes `null`/`undefined`, the helper will crash instead of safely skipping the branch.\n\n```suggestion\n\t\tif (toolOrToolkit && typeof (toolOrToolkit as Toolkit).getTools === 'function') {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179344951",
    "pr_number": 16897,
    "pr_file": "packages/core/src/execution-engine/node-execution-context/execute-context.ts",
    "created_at": "2025-07-02T07:35:55+00:00",
    "commented_code": "timestamp: Date.now(),\n \t\t};\n \n+\t\tconst parsedContent: string = typeof content === 'string' ? content : JSON.stringify(content);\n+\n \t\tconst message: StructuredChunk = {\n \t\t\ttype,\n-\t\t\tcontent: content ? JSON.stringify(content) : undefined,\n+\t\t\tcontent: parsedContent ?? undefined,",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2179344951",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16897,
        "pr_file": "packages/core/src/execution-engine/node-execution-context/execute-context.ts",
        "discussion_id": "2179344951",
        "commented_code": "@@ -139,9 +139,11 @@ export class ExecuteContext extends BaseExecuteContext implements IExecuteFuncti\n \t\t\ttimestamp: Date.now(),\n \t\t};\n \n+\t\tconst parsedContent: string = typeof content === 'string' ? content : JSON.stringify(content);\n+\n \t\tconst message: StructuredChunk = {\n \t\t\ttype,\n-\t\t\tcontent: content ? JSON.stringify(content) : undefined,\n+\t\t\tcontent: parsedContent ?? undefined,",
        "comment_created_at": "2025-07-02T07:35:55+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nThe nullish coalescing to undefined is redundant; \"x ?? undefined\" always evaluates to x. Removing the operator simplifies the code without changing behaviour.\n\n```suggestion\n\t\t\tcontent: parsedContent,\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179344953",
    "pr_number": 16897,
    "pr_file": "packages/core/src/execution-engine/node-execution-context/execute-context.ts",
    "created_at": "2025-07-02T07:35:55+00:00",
    "commented_code": "timestamp: Date.now(),\n \t\t};\n \n+\t\tconst parsedContent: string = typeof content === 'string' ? content : JSON.stringify(content);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2179344953",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16897,
        "pr_file": "packages/core/src/execution-engine/node-execution-context/execute-context.ts",
        "discussion_id": "2179344953",
        "commented_code": "@@ -139,9 +139,11 @@ export class ExecuteContext extends BaseExecuteContext implements IExecuteFuncti\n \t\t\ttimestamp: Date.now(),\n \t\t};\n \n+\t\tconst parsedContent: string = typeof content === 'string' ? content : JSON.stringify(content);",
        "comment_created_at": "2025-07-02T07:35:55+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[]} -->\nJSON.stringify can return undefined (e.g. when content is undefined) but the variable is annotated as string, so TypeScript will flag a type error. Broaden the type or remove the explicit annotation.\n\n```suggestion\n\t\tconst parsedContent: string | undefined = typeof content === 'string' ? content : JSON.stringify(content);\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169320108",
    "pr_number": 16556,
    "pr_file": "packages/frontend/editor-ui/src/stores/settings.store.ts",
    "created_at": "2025-06-26T15:17:49+00:00",
    "commented_code": "() => settings.value.telemetry && settings.value.telemetry.enabled,\n \t);\n \n+\tconst isMFAEnforcementLicensed = computed(() => {\n+\t\treturn settings.value.enterprise.mfaEnforcement;",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2169320108",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16556,
        "pr_file": "packages/frontend/editor-ui/src/stores/settings.store.ts",
        "discussion_id": "2169320108",
        "commented_code": "@@ -130,6 +131,10 @@ export const useSettingsStore = defineStore(STORES.SETTINGS, () => {\n \t\t() => settings.value.telemetry && settings.value.telemetry.enabled,\n \t);\n \n+\tconst isMFAEnforcementLicensed = computed(() => {\n+\t\treturn settings.value.enterprise.mfaEnforcement;",
        "comment_created_at": "2025-06-26T15:17:49+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"interface FrontendSettings\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"mfa.*enforced\\\" -R\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"packages/@n8n/api-types/src/frontend-settings.ts\",\"line\":32,\"symbol\":\"FrontendSettings\"},\"toolName\":\"goToDefinition\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"isMFAEnforcementLicensed\\\" -n packages/frontend/editor-ui/src/stores/settings.store.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '120,150p' packages/frontend/editor-ui/src/stores/settings.store.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nDereferencing settings.value.enterprise without a null/undefined guard will throw during store initialization when settings.value is still an empty object.\n\n```suggestion\n\t\treturn settings.value.enterprise?.mfaEnforcement ?? false;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178044451",
    "pr_number": 16896,
    "pr_file": "packages/frontend/editor-ui/src/utils/executionUtils.ts",
    "created_at": "2025-07-01T16:28:42+00:00",
    "commented_code": "for (const node of nodes) {\n \t\tif (triggerNode !== undefined && triggerNode !== node.name) continue;\n \n-\t\tconst hasNodeRun = runData && runData?.hasOwnProperty(node.name);\n+\t\tconst hasNodeRun = runData?.hasOwnProperty(node.name);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2178044451",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16896,
        "pr_file": "packages/frontend/editor-ui/src/utils/executionUtils.ts",
        "discussion_id": "2178044451",
        "commented_code": "@@ -146,7 +146,7 @@ export async function displayForm({\n \tfor (const node of nodes) {\n \t\tif (triggerNode !== undefined && triggerNode !== node.name) continue;\n \n-\t\tconst hasNodeRun = runData && runData?.hasOwnProperty(node.name);\n+\t\tconst hasNodeRun = runData?.hasOwnProperty(node.name);",
        "comment_created_at": "2025-07-01T16:28:42+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"hasNodeRun = runData?\\\" -n packages/frontend/editor-ui/src/utils/executionUtils.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -r \\\"const hasNodeRun = runData?\\\\.hasOwnProperty\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A2 -B2 \\\"const hasNodeRun = runData?\\\\.hasOwnProperty\\\" packages/frontend/editor-ui/src/utils/executionUtils.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nCalling hasOwnProperty directly on runData can throw if the object defines its own hasOwnProperty property that is not a function. Use Object.prototype.hasOwnProperty.call to avoid this edge-case.\n\n```suggestion\n\t\tconst hasNodeRun = Object.prototype.hasOwnProperty.call(runData ?? {}, node.name);\n```",
        "pr_file_module": null
      }
    ]
  }
]