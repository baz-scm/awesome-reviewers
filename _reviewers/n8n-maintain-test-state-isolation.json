[
  {
    "discussion_id": "2215780803",
    "pr_number": 17121,
    "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts",
    "created_at": "2025-07-18T11:11:52+00:00",
    "commented_code": "+import { mockDeep } from 'jest-mock-extended';\n+import type { IExecuteFunctions } from 'n8n-workflow';\n+\n+import { downloadFile, getBaseUrl, getMimeType, splitByComma, uploadFile } from './utils';\n+import * as transport from '../transport';\n+\n+describe('Anthropic -> utils', () => {\n+\tconst mockExecuteFunctions = mockDeep<IExecuteFunctions>();\n+\tconst apiRequestMock = jest.spyOn(transport, 'apiRequest');",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2215780803",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts",
        "discussion_id": "2215780803",
        "commented_code": "@@ -0,0 +1,196 @@\n+import { mockDeep } from 'jest-mock-extended';\n+import type { IExecuteFunctions } from 'n8n-workflow';\n+\n+import { downloadFile, getBaseUrl, getMimeType, splitByComma, uploadFile } from './utils';\n+import * as transport from '../transport';\n+\n+describe('Anthropic -> utils', () => {\n+\tconst mockExecuteFunctions = mockDeep<IExecuteFunctions>();\n+\tconst apiRequestMock = jest.spyOn(transport, 'apiRequest');",
        "comment_created_at": "2025-07-18T11:11:52+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function apiRequest\\\" -n packages | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A5 -B5 \\\"function getMimeType\\\" -R packages/@n8n/nodes-langchain/nodes/vendors/Anthropic | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/*.ts\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,220p' packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"toHaveBeenCalledWith({\\\" -R packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,120p' packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/transport/index.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A5 -B5 \\\"helpers.httpRequest({\\\" packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nThe spy created on transport.apiRequest is never restored, so it remains active beyond this test suite and can unintentionally affect other tests executed in the same Jest environment. Add an afterEach with apiRequestMock.mockRestore() to avoid leaking spies.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts at line 9:\n\n<comment>The spy created on transport.apiRequest is never restored, so it remains active beyond this test suite and can unintentionally affect other tests executed in the same Jest environment. Add an afterEach with apiRequestMock.mockRestore() to avoid leaking spies.</comment>\n\n<file context>\n@@ -0,0 +1,196 @@\n+import { mockDeep } from &#39;jest-mock-extended&#39;;\n+import type { IExecuteFunctions } from &#39;n8n-workflow&#39;;\n+\n+import { downloadFile, getBaseUrl, getMimeType, splitByComma, uploadFile } from &#39;./utils&#39;;\n+import * as transport from &#39;../transport&#39;;\n+\n+describe(&#39;Anthropic -&gt; utils&#39;, () =&gt; {\n+\tconst mockExecuteFunctions = mockDeep&lt;IExecuteFunctions&gt;();\n+\tconst apiRequestMock = jest.spyOn(transport, &#39;apiRequest&#39;);\n+\n+\tbeforeEach(() =&gt; {\n+\t\tjest.clearAllMocks();\n+\t});\n+\n+\tdescribe(&#39;getMimeType&#39;, () =&gt; {\n+\t\tit(&#39;should extract mime type from content type string&#39;, () =&gt; {\n+\t\t\tconst result = getMimeType(&#39;application/pdf; q=0.9&#39;);\n+\t\t\texpect(result).toBe(&#39;application/pdf&#39;);\n+\t\t});\n+\n+\t\tit(&#39;should return full string if no semicolon&#39;, () =&gt; {\n+\t\t\tconst result = getMimeType(&#39;application/pdf&#39;);\n+\t\t\texpect(result).toBe(&#39;application/pdf&#39;);\n+\t\t});\n+\n+\t\tit(&#39;should return undefined for undefined input&#39;, () =&gt; {\n+\t\t\tconst result = getMimeType(undefined);\n+\t\t\texpect(result).toBeUndefined();\n+\t\t});\n+\n+\t\tit(&#39;should handle empty string&#39;, () =&gt; {\n+\t\t\tconst result = getMimeType(&#39;&#39;);\n+\t\t\texpect(result).toBe(&#39;&#39;);\n+\t\t});\n+\t});\n+\n+\tdescribe(&#39;downloadFile&#39;, () =&gt; {\n+\t\tit(&#39;should download file&#39;, async () =&gt; {\n+\t\t\tmockExecuteFunctions.helpers.httpRequest.mockResolvedValue({\n+\t\t\t\tbody: new ArrayBuffer(10),\n+\t\t\t\theaders: {\n+\t\t\t\t\t&#39;content-type&#39;: &#39;application/pdf&#39;,\n+\t\t\t\t},\n+\t\t\t});\n+\n+\t\t\tconst file = await downloadFile.call(mockExecuteFunctions, &#39;https://example.com/file.pdf&#39;);\n+\n+\t\t\texpect(file).toEqual({\n+\t\t\t\tfileContent: Buffer.from(new ArrayBuffer(10)),\n+\t\t\t\tmimeType: &#39;application/pdf&#39;,\n+\t\t\t});\n+\t\t\texpect(mockExecuteFunctions.helpers.httpRequest).toHaveBeenCalledWith({\n+\t\t\t\tmethod: &#39;GET&#39;,\n+\t\t\t\turl: &#39;https://example.com/file.pdf&#39;,\n+\t\t\t\treturnFullResponse: true,\n+\t\t\t\tencoding: &#39;arraybuffer&#39;,\n+\t\t\t});\n+\t\t});\n+\n+\t\tit(&#39;should use fallback mime type if content type header is not present&#39;, async () =&gt; {\n+\t\t\tmockExecuteFunctions.helpers.httpRequest.mockResolvedValue({\n+\t\t\t\tbody: new ArrayBuffer(10),\n+\t\t\t\theaders: {},\n+\t\t\t});\n+\n+\t\t\tconst file = await downloadFile.call(mockExecuteFunctions, &#39;https://example.com/file.pdf&#39;);\n+\n+\t\t\texpect(file).toEqual({\n+\t\t\t\tfileContent: Buffer.from(new ArrayBuffer(10)),\n+\t\t\t\tmimeType: &#39;application/octet-stream&#39;,\n+\t\t\t});\n+\t\t});\n+\t});\n+\n+\tdescribe(&#39;uploadFile&#39;, () =&gt; {\n+\t\tit(&#39;should upload file&#39;, async () =&gt; {\n+\t\t\tconst fileContent = Buffer.from(&#39;test file content&#39;);\n+\t\t\tconst mimeType = &#39;text/plain&#39;;\n+\t\t\tconst fileName = &#39;test.txt&#39;;\n+\n+\t\t\tapiRequestMock.mockResolvedValue({\n+\t\t\t\tcreated_at: &#39;2025-01-01T10:00:00Z&#39;,\n+\t\t\t\tdownloadable: true,\n+\t\t\t\tfilename: fileName,\n+\t\t\t\tid: &#39;file_123&#39;,\n+\t\t\t\tmime_type: mimeType,\n+\t\t\t\tsize_bytes: fileContent.length,\n+\t\t\t\ttype: &#39;file&#39;,\n+\t\t\t});\n+\n+\t\t\tconst result = await uploadFile.call(mockExecuteFunctions, fileContent, mimeType, fileName);\n+\n+\t\t\texpect(apiRequestMock).toHaveBeenCalledWith(&#39;POST&#39;, &#39;/v1/files&#39;, {\n+\t\t\t\theaders: expect.objectContaining({\n+\t\t\t\t\t&#39;content-type&#39;: expect.stringContaining(&#39;multipart/form-data&#39;),\n+\t\t\t\t}),\n+\t\t\t\tbody: expect.any(Object),\n+\t\t\t});\n+\t\t\texpect(result).toEqual({\n+\t\t\t\tcreated_at: &#39;2025-01-01T10:00:00Z&#39;,\n+\t\t\t\tdownloadable: true,\n+\t\t\t\tfilename: fileName,\n+\t\t\t\tid: &#39;file_123&#39;,\n+\t\t\t\tmime_type: mimeType,\n+\t\t\t\tsize_bytes: fileContent.length,\n+\t\t\t\ttype: &#39;file&#39;,\n+\t\t\t});\n+\t\t});\n+\n+\t\tit(&#39;should upload file with default filename when not provided&#39;, async () =&gt; {\n+\t\t\tconst fileContent = Buffer.from(&#39;test file content&#39;);\n+\t\t\tconst mimeType = &#39;application/pdf&#39;;\n+\n+\t\t\tapiRequestMock.mockResolvedValue({\n+\t\t\t\tcreated_at: &#39;2025-01-01T10:00:00Z&#39;,\n+\t\t\t\tdownloadable: true,\n+\t\t\t\tfilename: &#39;file&#39;,\n+\t\t\t\tid: &#39;file_456&#39;,\n+\t\t\t\tmime_type: mimeType,\n+\t\t\t\tsize_bytes: fileContent.length,\n+\t\t\t\ttype: &#39;file&#39;,\n+\t\t\t});\n+\n+\t\t\tconst result = await uploadFile.call(mockExecuteFunctions, fileContent, mimeType);\n+\n+\t\t\texpect(apiRequestMock).toHaveBeenCalledWith(&#39;POST&#39;, &#39;/v1/files&#39;, {\n+\t\t\t\theaders: expect.objectContaining({\n+\t\t\t\t\t&#39;content-type&#39;: expect.stringContaining(&#39;multipart/form-data&#39;),\n+\t\t\t\t}),\n+\t\t\t\tbody: expect.any(Object),\n+\t\t\t});\n+\t\t\texpect(result).toEqual({\n+\t\t\t\tcreated_at: &#39;2025-01-01T10:00:00Z&#39;,\n+\t\t\t\tdownloadable: true,\n+\t\t\t\tfilename: &#39;file&#39;,\n+\t\t\t\tid: &#39;file_456&#39;,\n+\t\t\t\tmime_type: mimeType,\n+\t\t\t\tsize_bytes: fileContent.length,\n+\t\t\t\ttype: &#39;file&#39;,\n+\t\t\t});\n+\t\t});\n+\t});\n+\n+\tdescribe(&#39;splitByComma&#39;, () =&gt; {\n+\t\tit(&#39;should split string by comma and trim&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39;apple, banana, cherry&#39;);\n+\t\t\texpect(result).toEqual([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]);\n+\t\t});\n+\n+\t\tit(&#39;should handle string with extra spaces&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39;  apple  ,  banana  ,  cherry  &#39;);\n+\t\t\texpect(result).toEqual([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]);\n+\t\t});\n+\n+\t\tit(&#39;should filter out empty strings&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39;apple,, banana, , cherry,&#39;);\n+\t\t\texpect(result).toEqual([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;]);\n+\t\t});\n+\n+\t\tit(&#39;should handle single item&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39;apple&#39;);\n+\t\t\texpect(result).toEqual([&#39;apple&#39;]);\n+\t\t});\n+\n+\t\tit(&#39;should handle empty string&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39;&#39;);\n+\t\t\texpect(result).toEqual([]);\n+\t\t});\n+\n+\t\tit(&#39;should handle string with only commas and spaces&#39;, () =&gt; {\n+\t\t\tconst result = splitByComma(&#39; , , , &#39;);\n+\t\t\texpect(result).toEqual([]);\n+\t\t});\n+\t});\n+\n+\tdescribe(&#39;getBaseUrl&#39;, () =&gt; {\n+\t\tit(&#39;should return custom URL from credentials&#39;, async () =&gt; {\n+\t\t\tmockExecuteFunctions.getCredentials.mockResolvedValue({\n+\t\t\t\turl: &#39;https://custom-anthropic-api.com&#39;,\n+\t\t\t});\n+\n+\t\t\tconst result = await getBaseUrl.call(mockExecuteFunctions);\n+\n+\t\t\texpect(result).toBe(&#39;https://custom-anthropic-api.com&#39;);\n+\t\t\texpect(mockExecuteFunctions.getCredentials).toHaveBeenCalledWith(&#39;anthropicApi&#39;);\n+\t\t});\n+\n+\t\tit(&#39;should return default URL when no custom URL in credentials&#39;, async () =&gt; {\n+\t\t\tmockExecuteFunctions.getCredentials.mockResolvedValue({});\n+\n+\t\t\tconst result = await getBaseUrl.call(mockExecuteFunctions);\n+\n+\t\t\texpect(result).toBe(&#39;https://api.anthropic.com&#39;);\n+\t\t});\n+\t});\n+});\n</file context>\n```\n\n</details>",
        "pr_file_module": null
      },
      {
        "comment_id": "2215825034",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/helpers/utils.test.ts",
        "discussion_id": "2215780803",
        "commented_code": "@@ -0,0 +1,196 @@\n+import { mockDeep } from 'jest-mock-extended';\n+import type { IExecuteFunctions } from 'n8n-workflow';\n+\n+import { downloadFile, getBaseUrl, getMimeType, splitByComma, uploadFile } from './utils';\n+import * as transport from '../transport';\n+\n+describe('Anthropic -> utils', () => {\n+\tconst mockExecuteFunctions = mockDeep<IExecuteFunctions>();\n+\tconst apiRequestMock = jest.spyOn(transport, 'apiRequest');",
        "comment_created_at": "2025-07-18T11:34:20+00:00",
        "comment_author": "RomanDavydchuk",
        "comment_body": "This actually won't work",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190634671",
    "pr_number": 17079,
    "pr_file": "packages/frontend/editor-ui/src/composables/useNodeSettingsParameters.test.ts",
    "created_at": "2025-07-07T16:55:06+00:00",
    "commented_code": "import type { MockedStore } from '@/__tests__/utils';\n import { mockedStore } from '@/__tests__/utils';\n import type { INodeUi } from '@/Interface';\n+import { CUSTOM_API_CALL_KEY } from '@/constants';\n \n describe('useNodeSettingsParameters', () => {\n-\tdescribe('setValue', () => {\n-\t\tbeforeEach(() => {\n-\t\t\tsetActivePinia(createTestingPinia());\n-\t\t});\n+\tbeforeAll(() => {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2190634671",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17079,
        "pr_file": "packages/frontend/editor-ui/src/composables/useNodeSettingsParameters.test.ts",
        "discussion_id": "2190634671",
        "commented_code": "@@ -7,13 +7,14 @@ import type { INodeProperties } from 'n8n-workflow';\n import type { MockedStore } from '@/__tests__/utils';\n import { mockedStore } from '@/__tests__/utils';\n import type { INodeUi } from '@/Interface';\n+import { CUSTOM_API_CALL_KEY } from '@/constants';\n \n describe('useNodeSettingsParameters', () => {\n-\tdescribe('setValue', () => {\n-\t\tbeforeEach(() => {\n-\t\t\tsetActivePinia(createTestingPinia());\n-\t\t});\n+\tbeforeAll(() => {",
        "comment_created_at": "2025-07-07T16:55:06+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"CUSTOM_API_CALL_KEY\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"beforeAll(() => {\\\\s*setActivePinia(createTestingPinia())\\\" packages/frontend/editor-ui/src/composables | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"node_modules/n8n-workflow/index.d.ts\",\"line\":1,\"symbol\":\"INodeProperties\"},\"toolName\":\"goToDefinition\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"packages/frontend/editor-ui/src/composables/useNodeSettingsParameters.ts\",\"line\":1,\"symbol\":\"useNodeSettingsParameters\"},\"toolName\":\"goToDefinition\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,40p' packages/frontend/editor-ui/src/composables/useNodeSettingsParameters.test.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nInitializing Pinia once with beforeAll means every test in this suite shares the same store instance, so state mutations in one test can leak into subsequent tests and create flaky results. Create a fresh Pinia instance for each test instead.\n\n```suggestion\n\tbeforeEach(() => {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212714102",
    "pr_number": 17406,
    "pr_file": "packages/nodes-base/nodes/Slack/test/v2/node/channel/history.test.ts",
    "created_at": "2025-07-17T08:43:43+00:00",
    "commented_code": "describe('Test SlackV2, channel => history', () => {\n \tnock('https://slack.com')\n-\t\t.get('/api/conversations.history?channel=C08514ZPKB8&inclusive=true&page=1&limit=100')\n+\t\t.get(\n+\t\t\t'/api/conversations.history?channel=C08514ZPKB8&inclusive=true&latest=1734322597.935429&oldest=1734321942.689159&page=1&limit=100',",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2212714102",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17406,
        "pr_file": "packages/nodes-base/nodes/Slack/test/v2/node/channel/history.test.ts",
        "discussion_id": "2212714102",
        "commented_code": "@@ -167,7 +167,9 @@ const API_RESPONSE = {\n \n describe('Test SlackV2, channel => history', () => {\n \tnock('https://slack.com')\n-\t\t.get('/api/conversations.history?channel=C08514ZPKB8&inclusive=true&page=1&limit=100')\n+\t\t.get(\n+\t\t\t'/api/conversations.history?channel=C08514ZPKB8&inclusive=true&latest=1734322597.935429&oldest=1734321942.689159&page=1&limit=100',",
        "comment_created_at": "2025-07-17T08:43:43+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[]} -->\nHard-coding the entire query string in a single path makes the nock expectation depend on the exact order of parameters, so the test will break if the implementation changes the ordering (which is not guaranteed by `URLSearchParams`). Use `nock(...).get('/api/conversations.history').query({...})` or `query(true)` to make the test order-independent.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200763979",
    "pr_number": 17237,
    "pr_file": "packages/cli/src/webhooks/__tests__/webhook-last-node-response-extractor.test.ts",
    "created_at": "2025-07-11T13:32:40+00:00",
    "commented_code": "+import { Container } from '@n8n/di';\n+import { mock, type MockProxy } from 'jest-mock-extended';\n+import { BinaryDataService } from 'n8n-core';\n+import type {\n+\tINode,\n+\tITaskData,\n+\tIWebhookData,\n+\tWorkflow,\n+\tIWorkflowDataProxyAdditionalKeys,\n+\tINodeExecutionData,\n+\tIBinaryData,\n+\tExpression,\n+} from 'n8n-workflow';\n+import { BINARY_ENCODING, OperationalError } from 'n8n-workflow';\n+import assert from 'node:assert';\n+import { Readable } from 'node:stream';\n+\n+import { extractWebhookLastNodeResponse } from '../webhook-last-node-response-extractor';\n+\n+describe('extractWebhookLastNodeResponse', () => {\n+\tlet mockWorkflow: MockProxy<Workflow>;\n+\tlet mockWorkflowStartNode: MockProxy<INode>;\n+\tlet mockWebhookData: MockProxy<IWebhookData>;\n+\tlet mockLastNodeRunData: MockProxy<ITaskData>;\n+\tlet mockBinaryDataService: MockProxy<BinaryDataService>;\n+\tlet mockAdditionalKeys: MockProxy<IWorkflowDataProxyAdditionalKeys>;\n+\n+\tbeforeEach(() => {\n+\t\tmockWorkflow = mock<Workflow>();\n+\t\tmockWorkflowStartNode = mock<INode>();\n+\t\tmockWebhookData = mock<IWebhookData>({\n+\t\t\twebhookDescription: {\n+\t\t\t\tresponsePropertyName: undefined,\n+\t\t\t\tresponseContentType: undefined,\n+\t\t\t\tresponseBinaryPropertyName: undefined,\n+\t\t\t},\n+\t\t});\n+\t\tmockLastNodeRunData = mock<ITaskData>();\n+\t\tmockBinaryDataService = mock<BinaryDataService>();\n+\t\tmockAdditionalKeys = mock<IWorkflowDataProxyAdditionalKeys>();\n+\n+\t\tmockWorkflow.expression = mock<Expression>({\n+\t\t\tgetSimpleParameterValue: jest.fn(),\n+\t\t});\n+\n+\t\tContainer.set(BinaryDataService, mockBinaryDataService);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2200763979",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17237,
        "pr_file": "packages/cli/src/webhooks/__tests__/webhook-last-node-response-extractor.test.ts",
        "discussion_id": "2200763979",
        "commented_code": "@@ -0,0 +1,443 @@\n+import { Container } from '@n8n/di';\n+import { mock, type MockProxy } from 'jest-mock-extended';\n+import { BinaryDataService } from 'n8n-core';\n+import type {\n+\tINode,\n+\tITaskData,\n+\tIWebhookData,\n+\tWorkflow,\n+\tIWorkflowDataProxyAdditionalKeys,\n+\tINodeExecutionData,\n+\tIBinaryData,\n+\tExpression,\n+} from 'n8n-workflow';\n+import { BINARY_ENCODING, OperationalError } from 'n8n-workflow';\n+import assert from 'node:assert';\n+import { Readable } from 'node:stream';\n+\n+import { extractWebhookLastNodeResponse } from '../webhook-last-node-response-extractor';\n+\n+describe('extractWebhookLastNodeResponse', () => {\n+\tlet mockWorkflow: MockProxy<Workflow>;\n+\tlet mockWorkflowStartNode: MockProxy<INode>;\n+\tlet mockWebhookData: MockProxy<IWebhookData>;\n+\tlet mockLastNodeRunData: MockProxy<ITaskData>;\n+\tlet mockBinaryDataService: MockProxy<BinaryDataService>;\n+\tlet mockAdditionalKeys: MockProxy<IWorkflowDataProxyAdditionalKeys>;\n+\n+\tbeforeEach(() => {\n+\t\tmockWorkflow = mock<Workflow>();\n+\t\tmockWorkflowStartNode = mock<INode>();\n+\t\tmockWebhookData = mock<IWebhookData>({\n+\t\t\twebhookDescription: {\n+\t\t\t\tresponsePropertyName: undefined,\n+\t\t\t\tresponseContentType: undefined,\n+\t\t\t\tresponseBinaryPropertyName: undefined,\n+\t\t\t},\n+\t\t});\n+\t\tmockLastNodeRunData = mock<ITaskData>();\n+\t\tmockBinaryDataService = mock<BinaryDataService>();\n+\t\tmockAdditionalKeys = mock<IWorkflowDataProxyAdditionalKeys>();\n+\n+\t\tmockWorkflow.expression = mock<Expression>({\n+\t\t\tgetSimpleParameterValue: jest.fn(),\n+\t\t});\n+\n+\t\tContainer.set(BinaryDataService, mockBinaryDataService);",
        "comment_created_at": "2025-07-11T13:32:40+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"Container.remove(BinaryDataService\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"packages/cli/src/webhooks/__tests__/webhook-last-node-response-extractor.test.ts\",\"line\":1,\"symbol\":\"Container\"},\"toolName\":\"findReferences\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"class Container\\\" $(git ls-files | tr '\\n' ' ') | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"describe('extractWebhookLastNodeResponse'\\\" -n packages/cli/src/webhooks/__tests__/webhook-last-node-response-extractor.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/@n8n/di/src/di.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"export const BINARY_ENCODING\\\" $(git ls-files | tr '\\n' ' ') | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"Container.set(BinaryDataService\\\" packages/cli/src/webhooks | head\"},\"toolName\":\"executeCommand\"}]}]} -->\nThe test injects a mocked BinaryDataService into the global DI container but never removes or resets it afterwards. This leaked singleton can persist across test files and cause cross-test interference. Ensure the container is reset (e.g., Container.reset()) or the original instance is restored in an afterEach/afterAll hook.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193454967",
    "pr_number": 17137,
    "pr_file": "packages/cli/src/__tests__/workflow-runner.test.ts",
    "created_at": "2025-07-08T21:14:46+00:00",
    "commented_code": "});\n });\n \n+describe('workflow timeout with startedAt', () => {\n+\tit('should calculate timeout based on startedAt date when provided', async () => {\n+\t\t// ARRANGE\n+\t\tconst activeExecutions = Container.get(ActiveExecutions);\n+\t\tjest.spyOn(activeExecutions, 'add').mockResolvedValue('1');\n+\t\tjest.spyOn(activeExecutions, 'attachWorkflowExecution').mockReturnValueOnce();\n+\t\tconst permissionChecker = Container.get(CredentialsPermissionChecker);\n+\t\tjest.spyOn(permissionChecker, 'check').mockResolvedValueOnce();\n+\n+\t\tconst mockStopExecution = jest.spyOn(activeExecutions, 'stopExecution');\n+\n+\t\t// Mock setTimeout to capture the adjusted timeout value\n+\t\tconst mockSetTimeout = jest.spyOn(global, 'setTimeout').mockImplementation(() => {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2193454967",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17137,
        "pr_file": "packages/cli/src/__tests__/workflow-runner.test.ts",
        "discussion_id": "2193454967",
        "commented_code": "@@ -301,6 +301,170 @@ describe('enqueueExecution', () => {\n \t});\n });\n \n+describe('workflow timeout with startedAt', () => {\n+\tit('should calculate timeout based on startedAt date when provided', async () => {\n+\t\t// ARRANGE\n+\t\tconst activeExecutions = Container.get(ActiveExecutions);\n+\t\tjest.spyOn(activeExecutions, 'add').mockResolvedValue('1');\n+\t\tjest.spyOn(activeExecutions, 'attachWorkflowExecution').mockReturnValueOnce();\n+\t\tconst permissionChecker = Container.get(CredentialsPermissionChecker);\n+\t\tjest.spyOn(permissionChecker, 'check').mockResolvedValueOnce();\n+\n+\t\tconst mockStopExecution = jest.spyOn(activeExecutions, 'stopExecution');\n+\n+\t\t// Mock setTimeout to capture the adjusted timeout value\n+\t\tconst mockSetTimeout = jest.spyOn(global, 'setTimeout').mockImplementation(() => {",
        "comment_created_at": "2025-07-08T21:14:46+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"spyOn(global, 'setTimeout'\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"setTimeout(\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"node -e \\\"const obj={fn(){}}; const jest=require('jest-mock'); const spy=jest.spyOn(obj,'fn'); const spy2=jest.spyOn(obj,'fn');\\\"\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"workflow timeout with startedAt\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"setTimeout(.*unref\\\" -n packages | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function getEnv(\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"^+\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts | head\"},\"toolName\":\"executeCommand\"}]}]} -->\nMocking the global setTimeout here is never restored, so the stub persists for every following test in the same file. Since beforeEach only calls jest.clearAllMocks(), the original implementation is not reinstated, risking cross-test contamination and masking timing-related bugs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2193454967",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17137,
        "pr_file": "packages/cli/src/__tests__/workflow-runner.test.ts",
        "discussion_id": "2193454967",
        "commented_code": "@@ -301,6 +301,170 @@ describe('enqueueExecution', () => {\n \t});\n });\n \n+describe('workflow timeout with startedAt', () => {\n+\tit('should calculate timeout based on startedAt date when provided', async () => {\n+\t\t// ARRANGE\n+\t\tconst activeExecutions = Container.get(ActiveExecutions);\n+\t\tjest.spyOn(activeExecutions, 'add').mockResolvedValue('1');\n+\t\tjest.spyOn(activeExecutions, 'attachWorkflowExecution').mockReturnValueOnce();\n+\t\tconst permissionChecker = Container.get(CredentialsPermissionChecker);\n+\t\tjest.spyOn(permissionChecker, 'check').mockResolvedValueOnce();\n+\n+\t\tconst mockStopExecution = jest.spyOn(activeExecutions, 'stopExecution');\n+\n+\t\t// Mock setTimeout to capture the adjusted timeout value\n+\t\tconst mockSetTimeout = jest.spyOn(global, 'setTimeout').mockImplementation(() => {",
        "comment_created_at": "2025-07-08T21:14:46+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"spyOn(global, 'setTimeout'\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"setTimeout(\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"node -e \\\"const obj={fn(){}}; const jest=require('jest-mock'); const spy=jest.spyOn(obj,'fn'); const spy2=jest.spyOn(obj,'fn');\\\"\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"workflow timeout with startedAt\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"setTimeout(.*unref\\\" -n packages | head\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function getEnv(\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"^+\\\" -n packages/cli/src/__tests__/workflow-runner.test.ts | head\"},\"toolName\":\"executeCommand\"}]}]} -->\nMocking the global setTimeout here is never restored, so the stub persists for every following test in the same file. Since beforeEach only calls jest.clearAllMocks(), the original implementation is not reinstated, risking cross-test contamination and masking timing-related bugs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2189193892",
    "pr_number": 17006,
    "pr_file": "packages/frontend/@n8n/chat/src/__tests__/utils/streamingHandlers.spec.ts",
    "created_at": "2025-07-07T07:24:21+00:00",
    "commented_code": "+import { describe, expect, it, vi, beforeEach } from 'vitest';\n+import { ref, type Ref } from 'vue';\n+\n+import type { ChatMessageText } from '@n8n/chat/types';\n+import { StreamingMessageManager } from '@n8n/chat/utils/streaming';\n+import {\n+\thandleStreamingChunk,\n+\thandleNodeStart,\n+\thandleNodeComplete,\n+} from '@n8n/chat/utils/streamingHandlers';\n+\n+// Mock the chatEventBus\n+vi.mock('@n8n/chat/event-buses', () => ({",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2189193892",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17006,
        "pr_file": "packages/frontend/@n8n/chat/src/__tests__/utils/streamingHandlers.spec.ts",
        "discussion_id": "2189193892",
        "commented_code": "@@ -0,0 +1,201 @@\n+import { describe, expect, it, vi, beforeEach } from 'vitest';\n+import { ref, type Ref } from 'vue';\n+\n+import type { ChatMessageText } from '@n8n/chat/types';\n+import { StreamingMessageManager } from '@n8n/chat/utils/streaming';\n+import {\n+\thandleStreamingChunk,\n+\thandleNodeStart,\n+\thandleNodeComplete,\n+} from '@n8n/chat/utils/streamingHandlers';\n+\n+// Mock the chatEventBus\n+vi.mock('@n8n/chat/event-buses', () => ({",
        "comment_created_at": "2025-07-07T07:24:21+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"function handleStreamingChunk\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/frontend/@n8n/chat/src/utils/streamingHandlers.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,200p' packages/frontend/@n8n/chat/src/utils/streaming.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"waitingForResponse\\\" -n packages/frontend/@n8n/chat/src/__tests__/utils/streamingHandlers.spec.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"git diff --name-only HEAD\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"waitingForResponse\\\" packages/frontend/@n8n/chat/src/__tests__/utils/streamingHandlers.spec.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"export.*chatEventBus\\\" packages/frontend --line-number\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,120p' packages/frontend/@n8n/chat/src/event-buses/chatEventBus.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,260p' packages/frontend/@n8n/chat/src/__tests__/utils/streamingHandlers.spec.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nThe mock is registered after the module under test (`streamingHandlers`) has already been imported, so the real `chatEventBus` instance is still captured inside the functions being tested. This makes the mock ineffective and can introduce unintended side-effects or flaky tests.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198004630",
    "pr_number": 17201,
    "pr_file": "packages/@n8n/nodes-langchain/utils/tests/tiktoken.test.ts",
    "created_at": "2025-07-10T15:06:22+00:00",
    "commented_code": "getEncodingNameForModel: jest.fn(),\n }));\n \n-jest.mock('../tokenizer/cl100k_base.json', () => ({ mockCl100kBase: 'data' }), { virtual: true });\n-jest.mock('../tokenizer/o200k_base.json', () => ({ mockO200kBase: 'data' }), { virtual: true });\n+jest.mock('fs', () => ({\n+\treadFileSync: jest.fn(),\n+}));\n+\n+jest.mock('n8n-workflow', () => ({\n+\tjsonParse: jest.fn(),\n+}));\n \n describe('tiktoken utils', () => {\n+\tconst mockReadFileSync = require('fs').readFileSync;\n+\tconst mockJsonParse = require('n8n-workflow').jsonParse;\n+\n \tbeforeEach(() => {\n \t\tjest.clearAllMocks();\n+\n+\t\t// Set up mock implementations\n+\t\tmockReadFileSync.mockImplementation((path: string) => {\n+\t\t\tif (path.includes('cl100k_base.json')) {\n+\t\t\t\treturn JSON.stringify({ mockCl100kBase: 'data' });\n+\t\t\t}\n+\t\t\tif (path.includes('o200k_base.json')) {\n+\t\t\t\treturn JSON.stringify({ mockO200kBase: 'data' });\n+\t\t\t}\n+\t\t\tthrow new Error(`Unexpected file path: ${path}`);\n+\t\t});\n+\n+\t\tmockJsonParse.mockImplementation((content: string) => JSON.parse(content));\n \t});\n \n \tdescribe('getEncoding', () => {\n-\t\tit('should return Tiktoken instance for cl100k_base encoding', async () => {\n+\t\tit('should return Tiktoken instance for cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('cl100k_base');\n+\t\t\tconst result = getEncoding('cl100k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should return Tiktoken instance for o200k_base encoding', async () => {\n+\t\tit('should return Tiktoken instance for o200k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('o200k_base');\n+\t\t\tconst result = getEncoding('o200k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockO200kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map p50k_base to cl100k_base encoding', async () => {\n+\t\tit('should map p50k_base to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('p50k_base');\n+\t\t\tconst result = getEncoding('p50k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map r50k_base to cl100k_base encoding', async () => {\n+\t\tit('should map r50k_base to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('r50k_base');\n+\t\t\tconst result = getEncoding('r50k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map gpt2 to cl100k_base encoding', async () => {\n+\t\tit('should map gpt2 to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('gpt2');\n+\t\t\tconst result = getEncoding('gpt2');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map p50k_edit to cl100k_base encoding', async () => {\n+\t\tit('should map p50k_edit to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('p50k_edit');\n+\t\t\tconst result = getEncoding('p50k_edit');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should return cl100k_base for unknown encoding', async () => {\n+\t\tit('should return cl100k_base for unknown encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('unknown_encoding' as unknown as TiktokenEncoding);\n+\t\t\tconst result = getEncoding('unknown_encoding' as unknown as TiktokenEncoding);\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n+\n+\t\tit('should use cache for repeated calls with same encoding', () => {\n+\t\t\tconst mockTiktoken = {};\n+\t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n+\n+\t\t\t// Clear any previous calls to isolate this test\n+\t\t\tjest.clearAllMocks();\n+\n+\t\t\t// Use a unique encoding that hasn't been cached yet\n+\t\t\tconst uniqueEncoding = 'test_encoding' as TiktokenEncoding;\n+\n+\t\t\t// First call\n+\t\t\tconst result1 = getEncoding(uniqueEncoding);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledTimes(1);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' }); // Falls back to cl100k_base\n+\n+\t\t\t// Second call - should use cache\n+\t\t\tconst result2 = getEncoding(uniqueEncoding);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledTimes(1); // Still only called once\n+\t\t\texpect(result1).toBe(result2);\n+\t\t});\n \t});\n \n \tdescribe('encodingForModel', () => {\n-\t\tit('should call getEncodingNameForModel and return encoding for cl100k_base', async () => {\n+\t\tit('should call getEncodingNameForModel and return encoding for cl100k_base', () => {\n \t\t\tconst mockGetEncodingNameForModel = require('js-tiktoken/lite').getEncodingNameForModel;\n \t\t\tconst mockTiktoken = {};\n \n \t\t\tmockGetEncodingNameForModel.mockReturnValue('cl100k_base');\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await encodingForModel('gpt-3.5-turbo');\n+\t\t\t// Clear previous calls since cl100k_base might be cached from previous tests\n+\t\t\tjest.clearAllMocks();\n+\t\t\tmockGetEncodingNameForModel.mockReturnValue('cl100k_base');\n+\n+\t\t\tconst result = encodingForModel('gpt-3.5-turbo');\n \n \t\t\texpect(mockGetEncodingNameForModel).toHaveBeenCalledWith('gpt-3.5-turbo');\n-\t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n-\t\t\texpect(result).toBe(mockTiktoken);\n+\t\t\t// Since cl100k_base was already loaded in previous tests, Tiktoken constructor",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2198004630",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17201,
        "pr_file": "packages/@n8n/nodes-langchain/utils/tests/tiktoken.test.ts",
        "discussion_id": "2198004630",
        "commented_code": "@@ -13,113 +13,165 @@ jest.mock('js-tiktoken/lite', () => ({\n \tgetEncodingNameForModel: jest.fn(),\n }));\n \n-jest.mock('../tokenizer/cl100k_base.json', () => ({ mockCl100kBase: 'data' }), { virtual: true });\n-jest.mock('../tokenizer/o200k_base.json', () => ({ mockO200kBase: 'data' }), { virtual: true });\n+jest.mock('fs', () => ({\n+\treadFileSync: jest.fn(),\n+}));\n+\n+jest.mock('n8n-workflow', () => ({\n+\tjsonParse: jest.fn(),\n+}));\n \n describe('tiktoken utils', () => {\n+\tconst mockReadFileSync = require('fs').readFileSync;\n+\tconst mockJsonParse = require('n8n-workflow').jsonParse;\n+\n \tbeforeEach(() => {\n \t\tjest.clearAllMocks();\n+\n+\t\t// Set up mock implementations\n+\t\tmockReadFileSync.mockImplementation((path: string) => {\n+\t\t\tif (path.includes('cl100k_base.json')) {\n+\t\t\t\treturn JSON.stringify({ mockCl100kBase: 'data' });\n+\t\t\t}\n+\t\t\tif (path.includes('o200k_base.json')) {\n+\t\t\t\treturn JSON.stringify({ mockO200kBase: 'data' });\n+\t\t\t}\n+\t\t\tthrow new Error(`Unexpected file path: ${path}`);\n+\t\t});\n+\n+\t\tmockJsonParse.mockImplementation((content: string) => JSON.parse(content));\n \t});\n \n \tdescribe('getEncoding', () => {\n-\t\tit('should return Tiktoken instance for cl100k_base encoding', async () => {\n+\t\tit('should return Tiktoken instance for cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('cl100k_base');\n+\t\t\tconst result = getEncoding('cl100k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should return Tiktoken instance for o200k_base encoding', async () => {\n+\t\tit('should return Tiktoken instance for o200k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('o200k_base');\n+\t\t\tconst result = getEncoding('o200k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockO200kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map p50k_base to cl100k_base encoding', async () => {\n+\t\tit('should map p50k_base to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('p50k_base');\n+\t\t\tconst result = getEncoding('p50k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map r50k_base to cl100k_base encoding', async () => {\n+\t\tit('should map r50k_base to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('r50k_base');\n+\t\t\tconst result = getEncoding('r50k_base');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map gpt2 to cl100k_base encoding', async () => {\n+\t\tit('should map gpt2 to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('gpt2');\n+\t\t\tconst result = getEncoding('gpt2');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should map p50k_edit to cl100k_base encoding', async () => {\n+\t\tit('should map p50k_edit to cl100k_base encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('p50k_edit');\n+\t\t\tconst result = getEncoding('p50k_edit');\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n \n-\t\tit('should return cl100k_base for unknown encoding', async () => {\n+\t\tit('should return cl100k_base for unknown encoding', () => {\n \t\t\tconst mockTiktoken = {};\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await getEncoding('unknown_encoding' as unknown as TiktokenEncoding);\n+\t\t\tconst result = getEncoding('unknown_encoding' as unknown as TiktokenEncoding);\n \n \t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n \t\t\texpect(result).toBe(mockTiktoken);\n \t\t});\n+\n+\t\tit('should use cache for repeated calls with same encoding', () => {\n+\t\t\tconst mockTiktoken = {};\n+\t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n+\n+\t\t\t// Clear any previous calls to isolate this test\n+\t\t\tjest.clearAllMocks();\n+\n+\t\t\t// Use a unique encoding that hasn't been cached yet\n+\t\t\tconst uniqueEncoding = 'test_encoding' as TiktokenEncoding;\n+\n+\t\t\t// First call\n+\t\t\tconst result1 = getEncoding(uniqueEncoding);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledTimes(1);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' }); // Falls back to cl100k_base\n+\n+\t\t\t// Second call - should use cache\n+\t\t\tconst result2 = getEncoding(uniqueEncoding);\n+\t\t\texpect(Tiktoken).toHaveBeenCalledTimes(1); // Still only called once\n+\t\t\texpect(result1).toBe(result2);\n+\t\t});\n \t});\n \n \tdescribe('encodingForModel', () => {\n-\t\tit('should call getEncodingNameForModel and return encoding for cl100k_base', async () => {\n+\t\tit('should call getEncodingNameForModel and return encoding for cl100k_base', () => {\n \t\t\tconst mockGetEncodingNameForModel = require('js-tiktoken/lite').getEncodingNameForModel;\n \t\t\tconst mockTiktoken = {};\n \n \t\t\tmockGetEncodingNameForModel.mockReturnValue('cl100k_base');\n \t\t\t(Tiktoken as unknown as jest.Mock).mockReturnValue(mockTiktoken);\n \n-\t\t\tconst result = await encodingForModel('gpt-3.5-turbo');\n+\t\t\t// Clear previous calls since cl100k_base might be cached from previous tests\n+\t\t\tjest.clearAllMocks();\n+\t\t\tmockGetEncodingNameForModel.mockReturnValue('cl100k_base');\n+\n+\t\t\tconst result = encodingForModel('gpt-3.5-turbo');\n \n \t\t\texpect(mockGetEncodingNameForModel).toHaveBeenCalledWith('gpt-3.5-turbo');\n-\t\t\texpect(Tiktoken).toHaveBeenCalledWith({ mockCl100kBase: 'data' });\n-\t\t\texpect(result).toBe(mockTiktoken);\n+\t\t\t// Since cl100k_base was already loaded in previous tests, Tiktoken constructor",
        "comment_created_at": "2025-07-10T15:06:22+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"**/tokenizer/tiktoken.ts\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/@n8n/nodes-langchain/utils/tokenizer/tiktoken.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nThis test explicitly relies on state (the tokenizer cache) that was populated by earlier tests, making the suite order-dependent and potentially flaky when tests are run in isolation or with parallelisation.",
        "pr_file_module": null
      }
    ]
  }
]