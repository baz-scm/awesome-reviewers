[
  {
    "discussion_id": "2214412961",
    "pr_number": 17430,
    "pr_file": "packages/frontend/@n8n/design-system/src/components/AskAssistantChat/AskAssistantChat.vue",
    "created_at": "2025-07-17T22:19:41+00:00",
    "commented_code": "chatInput.value.style.height = `${Math.min(scrollHeight, MAX_CHAT_INPUT_HEIGHT)}px`;\n }\n \n-function onThumbsUp() {\n-\temit('thumbsUp');\n-}\n-\n-function onThumbsDown() {\n-\temit('thumbsDown');\n+function onRateMessage(rating: 'up' | 'down', feedback?: string) {\n+\tif (rating === 'up') {\n+\t\temit('thumbsUp');\n+\t} else {\n+\t\temit('thumbsDown');\n+\t}\n+\tif (feedback) {\n+\t\temit('submitFeedback', { feedback, rating });\n+\t}\n }\n \n-function onSubmitFeedback(feedback: string) {\n-\temit('submitFeedback', feedback);\n+function scrollToBottom() {\n+\tif (messagesRef.value) {\n+\t\tmessagesRef.value?.scrollTo({\n+\t\t\ttop: messagesRef.value.scrollHeight,\n+\t\t\tbehavior: 'smooth',\n+\t\t});\n+\t}\n }\n+watch(sendDisabled, () => {\n+\tchatInput.value?.focus();\n+});\n+watch(\n+\t() => props.messages,\n+\tasync (messages) => {\n+\t\t// Check if the last message is user and scroll to bottom of the chat\n+\t\tif (props.scrollOnNewMessage && messages.length > 0) {\n+\t\t\t// Wait for DOM updates before scrolling\n+\t\t\tawait nextTick();\n+\t\t\t// Check if messagesRef is available after nextTick\n+\t\t\tif (messagesRef.value) {\n+\t\t\t\tscrollToBottom();\n+\t\t\t}\n+\t\t}\n+\t},\n+\t{ immediate: true },",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2214412961",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17430,
        "pr_file": "packages/frontend/@n8n/design-system/src/components/AskAssistantChat/AskAssistantChat.vue",
        "discussion_id": "2214412961",
        "commented_code": "@@ -101,17 +104,43 @@ function growInput() {\n \tchatInput.value.style.height = `${Math.min(scrollHeight, MAX_CHAT_INPUT_HEIGHT)}px`;\n }\n \n-function onThumbsUp() {\n-\temit('thumbsUp');\n-}\n-\n-function onThumbsDown() {\n-\temit('thumbsDown');\n+function onRateMessage(rating: 'up' | 'down', feedback?: string) {\n+\tif (rating === 'up') {\n+\t\temit('thumbsUp');\n+\t} else {\n+\t\temit('thumbsDown');\n+\t}\n+\tif (feedback) {\n+\t\temit('submitFeedback', { feedback, rating });\n+\t}\n }\n \n-function onSubmitFeedback(feedback: string) {\n-\temit('submitFeedback', feedback);\n+function scrollToBottom() {\n+\tif (messagesRef.value) {\n+\t\tmessagesRef.value?.scrollTo({\n+\t\t\ttop: messagesRef.value.scrollHeight,\n+\t\t\tbehavior: 'smooth',\n+\t\t});\n+\t}\n }\n+watch(sendDisabled, () => {\n+\tchatInput.value?.focus();\n+});\n+watch(\n+\t() => props.messages,\n+\tasync (messages) => {\n+\t\t// Check if the last message is user and scroll to bottom of the chat\n+\t\tif (props.scrollOnNewMessage && messages.length > 0) {\n+\t\t\t// Wait for DOM updates before scrolling\n+\t\t\tawait nextTick();\n+\t\t\t// Check if messagesRef is available after nextTick\n+\t\t\tif (messagesRef.value) {\n+\t\t\t\tscrollToBottom();\n+\t\t\t}\n+\t\t}\n+\t},\n+\t{ immediate: true },",
        "comment_created_at": "2025-07-17T22:19:41+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nThe watcher will not react when messages are appended or modified in-place because it only observes the array reference. This means scrollOnNewMessage will fail if the parent pushes to the same array instance, which is the usual Vue pattern for lists. Add deep: true (or watch the length) so the watcher triggers on pushes/pops.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/frontend/@n8n/design-system/src/components/AskAssistantChat/AskAssistantChat.vue at line 142:\n\n<comment>The watcher will not react when messages are appended or modified in-place because it only observes the array reference. This means scrollOnNewMessage will fail if the parent pushes to the same array instance, which is the usual Vue pattern for lists. Add deep: true (or watch the length) so the watcher triggers on pushes/pops.</comment>\n\n<file context>\n@@ -1,16 +1,7 @@\n &lt;script setup lang=&quot;ts&quot;&gt;\n-import { computed, ref } from &#39;vue&#39;;\n-\n-import BlockMessage from &#39;./messages/BlockMessage.vue&#39;;\n-import CodeDiffMessage from &#39;./messages/CodeDiffMessage.vue&#39;;\n-import ErrorMessage from &#39;./messages/ErrorMessage.vue&#39;;\n-import EventMessage from &#39;./messages/EventMessage.vue&#39;;\n-import TextMessage from &#39;./messages/TextMessage.vue&#39;;\n-import ComposedNodesMessage from &#39;./messages/workflow/ComposedNodesMessage.vue&#39;;\n-import RateWorkflowMessage from &#39;./messages/workflow/RateWorkflowMessage.vue&#39;;\n-import WorkflowGeneratedMessage from &#39;./messages/workflow/WorkflowGeneratedMessage.vue&#39;;\n-import WorkflowNodesMessage from &#39;./messages/workflow/WorkflowNodesMessage.vue&#39;;\n-import WorkflowStepsMessage from &#39;./messages/workflow/WorkflowStepsMessage.vue&#39;;\n+import { computed, nextTick, ref, watch } from &#39;vue&#39;;\n+\n+import MessageWrapper from &#39;./messages/MessageWrapper.vue&#39;;\n import { useI18n } from &#39;../../composables/useI18n&#39;;\n import type { ChatUI } from &#39;../../types/assistant&#39;;\n import AssistantIcon from &#39;../AskAssistantIcon/AssistantIcon.vue&#39;;\n@@ -36,6 +27,7 @@ interface Props {\n \tsessionId?: string;\n \ttitle?: string;\n \tplaceholder?: string;\n+\tscrollOnNewMessage?: boolean;\n }\n \n const emit = defineEmits&lt;{\n@@ -45,7 +37,7 @@ const emit = defineEmits&lt;{\n \tcodeUndo: [number];\n \tthumbsUp: [];\n \tthumbsDown: [];\n-\tsubmitFeedback: [string];\n+\tsubmitFeedback: [{ feedback: string; rating: &#39;up&#39; | &#39;down&#39; }];\n }&gt;();\n \n const onClose = () =&gt; emit(&#39;close&#39;);\n@@ -59,11 +51,22 @@ const props = withDefaults(defineProps&lt;Props&gt;(), {\n \tmessages: () =&gt; [],\n \tloadingMessage: undefined,\n \tsessionId: undefined,\n+\tscrollOnNewMessage: false,\n+});\n+\n+// Ensure all messages have required id and read properties\n+const normalizedMessages = computed(() =&gt; {\n+\treturn props.messages.map((msg, index) =&gt; ({\n+\t\t...msg,\n+\t\tid: msg.id || `msg-${index}`,\n+\t\tread: msg.read ?? true,\n+\t}));\n });\n \n const textInputValue = ref&lt;string&gt;(&#39;&#39;);\n \n const chatInput = ref&lt;HTMLTextAreaElement | null&gt;(null);\n+const messagesRef = ref&lt;HTMLDivElement | null&gt;(null);\n \n const sessionEnded = computed(() =&gt; {\n \treturn isEndOfSessionEvent(props.messages?.[props.messages.length - 1]);\n@@ -101,17 +104,43 @@ function growInput() {\n \tchatInput.value.style.height = `${Math.min(scrollHeight, MAX_CHAT_INPUT_HEIGHT)}px`;\n }\n \n-function onThumbsUp() {\n-\temit(&#39;thumbsUp&#39;);\n-}\n-\n-function onThumbsDown() {\n-\temit(&#39;thumbsDown&#39;);\n+function onRateMessage(rating: &#39;up&#39; | &#39;down&#39;, feedback?: string) {\n+\tif (rating === &#39;up&#39;) {\n+\t\temit(&#39;thumbsUp&#39;);\n+\t} else {\n+\t\temit(&#39;thumbsDown&#39;);\n+\t}\n+\tif (feedback) {\n+\t\temit(&#39;submitFeedback&#39;, { feedback, rating });\n+\t}\n }\n \n-function onSubmitFeedback(feedback: string) {\n-\temit(&#39;submitFeedback&#39;, feedback);\n+function scrollToBottom() {\n+\tif (messagesRef.value) {\n+\t\tmessagesRef.value?.scrollTo({\n+\t\t\ttop: messagesRef.value.scrollHeight,\n+\t\t\tbehavior: &#39;smooth&#39;,\n+\t\t});\n+\t}\n }\n+watch(sendDisabled, () =&gt; {\n+\tchatInput.value?.focus();\n+});\n+watch(\n+\t() =&gt; props.messages,\n+\tasync (messages) =&gt; {\n+\t\t// Check if the last message is user and scroll to bottom of the chat\n+\t\tif (props.scrollOnNewMessage &amp;&amp; messages.length &gt; 0) {\n+\t\t\t// Wait for DOM updates before scrolling\n+\t\t\tawait nextTick();\n+\t\t\t// Check if messagesRef is available after nextTick\n+\t\t\tif (messagesRef.value) {\n+\t\t\t\tscrollToBottom();\n+\t\t\t}\n+\t\t}\n+\t},\n+\t{ immediate: true },\n+);\n &lt;/script&gt;\n \n &lt;template&gt;\n@@ -129,93 +158,36 @@ function onSubmitFeedback(feedback: string) {\n \t\t\t&lt;/div&gt;\n \t\t&lt;/div&gt;\n \t\t&lt;div :class=&quot;$style.body&quot;&gt;\n-\t\t\t&lt;div v-if=&quot;messages?.length || loadingMessage&quot; :class=&quot;$style.messages&quot;&gt;\n-\t\t\t\t&lt;div v-if=&quot;messages?.length&quot;&gt;\n+\t\t\t&lt;div\n+\t\t\t\tv-if=&quot;normalizedMessages?.length || loadingMessage&quot;\n+\t\t\t\tref=&quot;messagesRef&quot;\n+\t\t\t\t:class=&quot;$style.messages&quot;\n+\t\t\t&gt;\n+\t\t\t\t&lt;div v-if=&quot;normalizedMessages?.length&quot;&gt;\n \t\t\t\t\t&lt;data\n-\t\t\t\t\t\tv-for=&quot;(message, i) in messages&quot;\n-\t\t\t\t\t\t:key=&quot;i&quot;\n+\t\t\t\t\t\tv-for=&quot;(message, i) in normalizedMessages&quot;\n+\t\t\t\t\t\t:key=&quot;message.id&quot;\n \t\t\t\t\t\t:data-test-id=&quot;\n \t\t\t\t\t\t\tmessage.role === &#39;assistant&#39; ? &#39;chat-message-assistant&#39; : &#39;chat-message-user&#39;\n \t\t\t\t\t\t&quot;\n \t\t\t\t\t&gt;\n-\t\t\t\t\t\t&lt;TextMessage\n-\t\t\t\t\t\t\tv-if=&quot;message.type === &#39;text&#39;&quot;\n+\t\t\t\t\t\t&lt;MessageWrapper\n \t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n+\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== normalizedMessages[i - 1].role&quot;\n \t\t\t\t\t\t\t:user=&quot;user&quot;\n \t\t\t\t\t\t\t:streaming=&quot;streaming&quot;\n-\t\t\t\t\t\t\t:is-last-message=&quot;i === messages.length - 1&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;BlockMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;block&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t\t:streaming=&quot;streaming&quot;\n-\t\t\t\t\t\t\t:is-last-message=&quot;i === messages.length - 1&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;ErrorMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;error&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;EventMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;event&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;CodeDiffMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;code-diff&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t\t:streaming=&quot;streaming&quot;\n-\t\t\t\t\t\t\t:is-last-message=&quot;i === messages.length - 1&quot;\n+\t\t\t\t\t\t\t:is-last-message=&quot;i === normalizedMessages.length - 1&quot;\n \t\t\t\t\t\t\t@code-replace=&quot;() =&gt; emit(&#39;codeReplace&#39;, i)&quot;\n \t\t\t\t\t\t\t@code-undo=&quot;() =&gt; emit(&#39;codeUndo&#39;, i)&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;WorkflowStepsMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;workflow-step&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;WorkflowNodesMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;workflow-node&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;ComposedNodesMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;workflow-composed&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;WorkflowGeneratedMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;workflow-generated&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t/&gt;\n-\t\t\t\t\t\t&lt;RateWorkflowMessage\n-\t\t\t\t\t\t\tv-else-if=&quot;message.type === &#39;rate-workflow&#39;&quot;\n-\t\t\t\t\t\t\t:message=&quot;message&quot;\n-\t\t\t\t\t\t\t:is-first-of-role=&quot;i === 0 || message.role !== messages[i - 1].role&quot;\n-\t\t\t\t\t\t\t:user=&quot;user&quot;\n-\t\t\t\t\t\t\t@thumbs-up=&quot;onThumbsUp&quot;\n-\t\t\t\t\t\t\t@thumbs-down=&quot;onThumbsDown&quot;\n-\t\t\t\t\t\t\t@submit-feedback=&quot;onSubmitFeedback&quot;\n+\t\t\t\t\t\t\t@rate=&quot;onRateMessage&quot;\n \t\t\t\t\t\t/&gt;\n \n \t\t\t\t\t\t&lt;div\n \t\t\t\t\t\t\tv-if=&quot;\n \t\t\t\t\t\t\t\t!streaming &amp;&amp;\n \t\t\t\t\t\t\t\t&#39;quickReplies&#39; in message &amp;&amp;\n \t\t\t\t\t\t\t\tmessage.quickReplies?.length &amp;&amp;\n-\t\t\t\t\t\t\t\ti === messages.length - 1\n+\t\t\t\t\t\t\t\ti === normalizedMessages.length - 1\n \t\t\t\t\t\t\t&quot;\n \t\t\t\t\t\t\t:class=&quot;$style.quickReplies&quot;\n \t\t\t\t\t\t&gt;\n@@ -237,7 +209,7 @@ function onSubmitFeedback(feedback: string) {\n \t\t\t\t&lt;/div&gt;\n \t\t\t\t&lt;div\n \t\t\t\t\tv-if=&quot;loadingMessage&quot;\n-\t\t\t\t\t:class=&quot;{ [$style.message]: true, [$style.loading]: messages?.length }&quot;\n+\t\t\t\t\t:class=&quot;{ [$style.message]: true, [$style.loading]: normalizedMessages?.length }&quot;\n \t\t\t\t&gt;\n \t\t\t\t\t&lt;AssistantLoadingMessage :message=&quot;loadingMessage&quot; /&gt;\n \t\t\t\t&lt;/div&gt;\n@@ -355,6 +327,20 @@ function onSubmitFeedback(feedback: string) {\n \tpadding: var(--spacing-xs);\n \toverflow-y: auto;\n \n+\t@supports not (selector(::-webkit-scrollbar)) {\n+\t\tscrollbar-width: thin;\n+\t}\n+\t@supports selector(::-webkit-scrollbar) {\n+\t\t&amp;::-webkit-scrollbar {\n+\t\t\twidth: var(--spacing-2xs);\n+\t\t}\n+\t\t&amp;::-webkit-scrollbar-thumb {\n+\t\t\tborder-radius: var(--spacing-xs);\n+\t\t\tbackground: var(--color-foreground-dark);\n+\t\t\tborder: var(--spacing-5xs) solid white;\n+\t\t}\n+\t}\n+\n \t&amp; + &amp; {\n \t\tpadding-top: 0;\n \t}\n</file context>\n```\n\n</details>\n\n```suggestion\n\t{ immediate: true, deep: true },\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166092501",
    "pr_number": 16489,
    "pr_file": "packages/frontend/editor-ui/src/features/logs/components/LogsOverviewPanel.vue",
    "created_at": "2025-06-25T08:15:10+00:00",
    "commented_code": "}\n }\n \n+function isExpanded(treeNode: LogEntry): boolean {\n+\tconst index = flatLogEntries.findIndex((e) => e.id === treeNode.id);\n+\n+\treturn index >= 0 ? flatLogEntries[index + 1]?.parent?.id === treeNode.id : false;\n+}\n+\n+// While executing, scroll to the bottom if there's no selection\n+watch(\n+\t[() => execution?.status === 'running', () => flatLogEntries.length],\n+\tasync ([isRunning, flatEntryCount], [wasRunning]) => {\n+\t\tawait nextTick(() => {\n+\t\t\tif (selected === undefined && (isRunning || wasRunning)) {\n+\t\t\t\tvirtualList.scrollTo(flatEntryCount - 1);\n+\t\t\t}\n+\t\t});\n+\t},\n+\t{ immediate: true },\n+);\n+\n // Scroll selected row into view\n watch(\n-\t() => selected,\n-\tasync (selection) => {\n-\t\tif (selection && virtualList.list.value.every((e) => e.data.id !== selection.id)) {\n-\t\t\tconst index = flatLogEntries.findIndex((e) => e.id === selection?.id);\n+\t() => selected?.id,",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2166092501",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16489,
        "pr_file": "packages/frontend/editor-ui/src/features/logs/components/LogsOverviewPanel.vue",
        "discussion_id": "2166092501",
        "commented_code": "@@ -98,18 +85,42 @@ async function handleTriggerPartialExecution(treeNode: LogEntry) {\n \t}\n }\n \n+function isExpanded(treeNode: LogEntry): boolean {\n+\tconst index = flatLogEntries.findIndex((e) => e.id === treeNode.id);\n+\n+\treturn index >= 0 ? flatLogEntries[index + 1]?.parent?.id === treeNode.id : false;\n+}\n+\n+// While executing, scroll to the bottom if there's no selection\n+watch(\n+\t[() => execution?.status === 'running', () => flatLogEntries.length],\n+\tasync ([isRunning, flatEntryCount], [wasRunning]) => {\n+\t\tawait nextTick(() => {\n+\t\t\tif (selected === undefined && (isRunning || wasRunning)) {\n+\t\t\t\tvirtualList.scrollTo(flatEntryCount - 1);\n+\t\t\t}\n+\t\t});\n+\t},\n+\t{ immediate: true },\n+);\n+\n // Scroll selected row into view\n watch(\n-\t() => selected,\n-\tasync (selection) => {\n-\t\tif (selection && virtualList.list.value.every((e) => e.data.id !== selection.id)) {\n-\t\t\tconst index = flatLogEntries.findIndex((e) => e.id === selection?.id);\n+\t() => selected?.id,",
        "comment_created_at": "2025-06-25T08:15:10+00:00",
        "comment_author": "autologie",
        "comment_body": "Changing watch target from object to string, so that it's more stable (doesn't fire more than necessary). This fixes the bug where scroll position changes unwantedly",
        "pr_file_module": null
      }
    ]
  }
]