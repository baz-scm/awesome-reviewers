[
  {
    "discussion_id": "2214077232",
    "pr_number": 17423,
    "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts",
    "created_at": "2025-07-17T19:02:32+00:00",
    "commented_code": "+import { tool } from '@langchain/core/tools';\n+import type { Logger } from '@n8n/backend-common';\n+import type { IConnections } from 'n8n-workflow';\n+import { z } from 'zod';\n+\n+import { ValidationError, ToolExecutionError } from '../errors';\n+import { createProgressReporter, reportProgress } from './helpers/progress';\n+import { createSuccessResponse, createErrorResponse } from './helpers/response';\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from './helpers/state';\n+import { validateNodeExists, createNodeNotFoundError } from './helpers/validation';\n+import type { RemoveNodeOutput } from '../types/tools';\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe('The ID of the node to remove from the workflow'),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2214077232",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17423,
        "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts",
        "discussion_id": "2214077232",
        "commented_code": "@@ -0,0 +1,155 @@\n+import { tool } from '@langchain/core/tools';\n+import type { Logger } from '@n8n/backend-common';\n+import type { IConnections } from 'n8n-workflow';\n+import { z } from 'zod';\n+\n+import { ValidationError, ToolExecutionError } from '../errors';\n+import { createProgressReporter, reportProgress } from './helpers/progress';\n+import { createSuccessResponse, createErrorResponse } from './helpers/response';\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from './helpers/state';\n+import { validateNodeExists, createNodeNotFoundError } from './helpers/validation';\n+import type { RemoveNodeOutput } from '../types/tools';\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe('The ID of the node to remove from the workflow'),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {",
        "comment_created_at": "2025-07-17T19:02:32+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[]} -->\nOutgoing connections to the same node are counted once in the \u201coutgoing\u201d loop and again in the \u201cincoming\u201d loop, so self-loop connections will be double-counted, leading to an incorrect `connectionsRemoved` value that is shown to users.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts at line 23:\n\n<comment>Outgoing connections to the same node are counted once in the \u201coutgoing\u201d loop and again in the \u201cincoming\u201d loop, so self-loop connections will be double-counted, leading to an incorrect `connectionsRemoved` value that is shown to users.</comment>\n\n<file context>\n@@ -0,0 +1,155 @@\n+import { tool } from &#39;@langchain/core/tools&#39;;\n+import type { Logger } from &#39;@n8n/backend-common&#39;;\n+import type { IConnections } from &#39;n8n-workflow&#39;;\n+import { z } from &#39;zod&#39;;\n+\n+import { ValidationError, ToolExecutionError } from &#39;../errors&#39;;\n+import { createProgressReporter, reportProgress } from &#39;./helpers/progress&#39;;\n+import { createSuccessResponse, createErrorResponse } from &#39;./helpers/response&#39;;\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from &#39;./helpers/state&#39;;\n+import { validateNodeExists, createNodeNotFoundError } from &#39;./helpers/validation&#39;;\n+import type { RemoveNodeOutput } from &#39;../types/tools&#39;;\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe(&#39;The ID of the node to remove from the workflow&#39;),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {\n+\tlet count = 0;\n+\n+\t// Count outgoing connections\n+\tif (connections[nodeId]) {\n+\t\tfor (const connectionType of Object.values(connections[nodeId])) {\n+\t\t\tif (Array.isArray(connectionType)) {\n+\t\t\t\tfor (const outputs of connectionType) {\n+\t\t\t\t\tif (Array.isArray(outputs)) {\n+\t\t\t\t\t\tcount += outputs.length;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Count incoming connections\n+\tfor (const [_sourceNodeId, nodeConnections] of Object.entries(connections)) {\n+\t\tfor (const outputs of Object.values(nodeConnections)) {\n+\t\t\tif (Array.isArray(outputs)) {\n+\t\t\t\tfor (const outputConnections of outputs) {\n+\t\t\t\t\tif (Array.isArray(outputConnections)) {\n+\t\t\t\t\t\tcount += outputConnections.filter((conn) =&gt; conn.node === nodeId).length;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn count;\n+}\n+\n+/**\n+ * Build the response message for the removed node\n+ */\n+function buildResponseMessage(\n+\tnodeName: string,\n+\tnodeType: string,\n+\tconnectionsRemoved: number,\n+): string {\n+\tconst parts: string[] = [`Successfully removed node &quot;${nodeName}&quot; (${nodeType})`];\n+\n+\tif (connectionsRemoved &gt; 0) {\n+\t\tparts.push(`Removed ${connectionsRemoved} connection${connectionsRemoved &gt; 1 ? &#39;s&#39; : &#39;&#39;}`);\n+\t}\n+\n+\treturn parts.join(&#39;\\n&#39;);\n+}\n+\n+/**\n+ * Factory function to create the remove node tool\n+ */\n+export function createRemoveNodeTool(_logger?: Logger) {\n+\treturn tool(\n+\t\t(input, config) =&gt; {\n+\t\t\tconst reporter = createProgressReporter(config, &#39;remove_node&#39;);\n+\n+\t\t\ttry {\n+\t\t\t\t// Validate input using Zod schema\n+\t\t\t\tconst validatedInput = removeNodeSchema.parse(input);\n+\t\t\t\tconst { nodeId } = validatedInput;\n+\n+\t\t\t\t// Report tool start\n+\t\t\t\treporter.start(validatedInput);\n+\n+\t\t\t\t// Get current state\n+\t\t\t\tconst state = getWorkflowState();\n+\t\t\t\tconst workflow = getCurrentWorkflow(state);\n+\n+\t\t\t\t// Report progress\n+\t\t\t\treportProgress(reporter, `Removing node ${nodeId}`);\n+\n+\t\t\t\t// Find the node to remove\n+\t\t\t\tconst nodeToRemove = validateNodeExists(nodeId, workflow.nodes);\n+\n+\t\t\t\tif (!nodeToRemove) {\n+\t\t\t\t\tconst error = createNodeNotFoundError(nodeId);\n+\t\t\t\t\treporter.error(error);\n+\t\t\t\t\treturn createErrorResponse(config, error);\n+\t\t\t\t}\n+\n+\t\t\t\t// Count connections that will be removed\n+\t\t\t\tconst connectionsRemoved = countNodeConnections(nodeId, workflow.connections);\n+\n+\t\t\t\t// Build success message\n+\t\t\t\tconst message = buildResponseMessage(\n+\t\t\t\t\tnodeToRemove.name,\n+\t\t\t\t\tnodeToRemove.type,\n+\t\t\t\t\tconnectionsRemoved,\n+\t\t\t\t);\n+\n+\t\t\t\t// Report completion\n+\t\t\t\tconst output: RemoveNodeOutput = {\n+\t\t\t\t\tremovedNodeId: nodeId,\n+\t\t\t\t\tremovedNodeName: nodeToRemove.name,\n+\t\t\t\t\tremovedNodeType: nodeToRemove.type,\n+\t\t\t\t\tconnectionsRemoved,\n+\t\t\t\t\tmessage,\n+\t\t\t\t};\n+\t\t\t\treporter.complete(output);\n+\n+\t\t\t\t// Return success with state updates\n+\t\t\t\tconst stateUpdates = removeNodeFromWorkflow(nodeId);\n+\t\t\t\treturn createSuccessResponse(config, message, stateUpdates);\n+\t\t\t} catch (error) {\n+\t\t\t\t// Handle validation or unexpected errors\n+\t\t\t\tif (error instanceof z.ZodError) {\n+\t\t\t\t\tconst validationError = new ValidationError(&#39;Invalid input parameters&#39;, {\n+\t\t\t\t\t\textra: { errors: error.errors },\n+\t\t\t\t\t});\n+\t\t\t\t\treporter.error(validationError);\n+\t\t\t\t\treturn createErrorResponse(config, validationError);\n+\t\t\t\t}\n+\n+\t\t\t\tconst toolError = new ToolExecutionError(\n+\t\t\t\t\terror instanceof Error ? error.message : &#39;Unknown error occurred&#39;,\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttoolName: &#39;remove_node&#39;,\n+\t\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\t\t\t\treporter.error(toolError);\n+\t\t\t\treturn createErrorResponse(config, toolError);\n+\t\t\t}\n+\t\t},\n+\t\t{\n+\t\t\tname: &#39;remove_node&#39;,\n+\t\t\tdescription:\n+\t\t\t\t&#39;Remove a node from the workflow by its ID. This will also remove all connections to and from the node. Use this tool when you need to delete a node that is no longer needed in the workflow.&#39;,\n+\t\t\tschema: removeNodeSchema,\n+\t\t},\n+\t);\n+}\n</file context>\n```\n\n</details>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214086429",
    "pr_number": 17423,
    "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts",
    "created_at": "2025-07-17T19:07:33+00:00",
    "commented_code": "+import { tool } from '@langchain/core/tools';\n+import type { Logger } from '@n8n/backend-common';\n+import type { IConnections } from 'n8n-workflow';\n+import { z } from 'zod';\n+\n+import { ValidationError, ToolExecutionError } from '../errors';\n+import { createProgressReporter, reportProgress } from './helpers/progress';\n+import { createSuccessResponse, createErrorResponse } from './helpers/response';\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from './helpers/state';\n+import { validateNodeExists, createNodeNotFoundError } from './helpers/validation';\n+import type { RemoveNodeOutput } from '../types/tools';\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe('The ID of the node to remove from the workflow'),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2214086429",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17423,
        "pr_file": "packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts",
        "discussion_id": "2214086429",
        "commented_code": "@@ -0,0 +1,155 @@\n+import { tool } from '@langchain/core/tools';\n+import type { Logger } from '@n8n/backend-common';\n+import type { IConnections } from 'n8n-workflow';\n+import { z } from 'zod';\n+\n+import { ValidationError, ToolExecutionError } from '../errors';\n+import { createProgressReporter, reportProgress } from './helpers/progress';\n+import { createSuccessResponse, createErrorResponse } from './helpers/response';\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from './helpers/state';\n+import { validateNodeExists, createNodeNotFoundError } from './helpers/validation';\n+import type { RemoveNodeOutput } from '../types/tools';\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe('The ID of the node to remove from the workflow'),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {",
        "comment_created_at": "2025-07-17T19:07:33+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[]} -->\nOutgoing connections to the same node are counted once in the \u201coutgoing\u201d loop and again in the \u201cincoming\u201d loop, so self-loop connections will be double-counted, leading to an incorrect `connectionsRemoved` value that is shown to users.\n\n<details>\n<summary>Prompt for AI agents</summary>\n\n```\nAddress the following comment on packages/@n8n/ai-workflow-builder.ee/src/tools/remove-node.tool.ts at line 23:\n\n<comment>Outgoing connections to the same node are counted once in the \u201coutgoing\u201d loop and again in the \u201cincoming\u201d loop, so self-loop connections will be double-counted, leading to an incorrect `connectionsRemoved` value that is shown to users.</comment>\n\n<file context>\n@@ -0,0 +1,155 @@\n+import { tool } from &#39;@langchain/core/tools&#39;;\n+import type { Logger } from &#39;@n8n/backend-common&#39;;\n+import type { IConnections } from &#39;n8n-workflow&#39;;\n+import { z } from &#39;zod&#39;;\n+\n+import { ValidationError, ToolExecutionError } from &#39;../errors&#39;;\n+import { createProgressReporter, reportProgress } from &#39;./helpers/progress&#39;;\n+import { createSuccessResponse, createErrorResponse } from &#39;./helpers/response&#39;;\n+import { getCurrentWorkflow, getWorkflowState, removeNodeFromWorkflow } from &#39;./helpers/state&#39;;\n+import { validateNodeExists, createNodeNotFoundError } from &#39;./helpers/validation&#39;;\n+import type { RemoveNodeOutput } from &#39;../types/tools&#39;;\n+\n+/**\n+ * Schema for the remove node tool\n+ */\n+const removeNodeSchema = z.object({\n+\tnodeId: z.string().describe(&#39;The ID of the node to remove from the workflow&#39;),\n+});\n+\n+/**\n+ * Count connections that will be removed for a node\n+ */\n+function countNodeConnections(nodeId: string, connections: IConnections): number {\n+\tlet count = 0;\n+\n+\t// Count outgoing connections\n+\tif (connections[nodeId]) {\n+\t\tfor (const connectionType of Object.values(connections[nodeId])) {\n+\t\t\tif (Array.isArray(connectionType)) {\n+\t\t\t\tfor (const outputs of connectionType) {\n+\t\t\t\t\tif (Array.isArray(outputs)) {\n+\t\t\t\t\t\tcount += outputs.length;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Count incoming connections\n+\tfor (const [_sourceNodeId, nodeConnections] of Object.entries(connections)) {\n+\t\tfor (const outputs of Object.values(nodeConnections)) {\n+\t\t\tif (Array.isArray(outputs)) {\n+\t\t\t\tfor (const outputConnections of outputs) {\n+\t\t\t\t\tif (Array.isArray(outputConnections)) {\n+\t\t\t\t\t\tcount += outputConnections.filter((conn) =&gt; conn.node === nodeId).length;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn count;\n+}\n+\n+/**\n+ * Build the response message for the removed node\n+ */\n+function buildResponseMessage(\n+\tnodeName: string,\n+\tnodeType: string,\n+\tconnectionsRemoved: number,\n+): string {\n+\tconst parts: string[] = [`Successfully removed node &quot;${nodeName}&quot; (${nodeType})`];\n+\n+\tif (connectionsRemoved &gt; 0) {\n+\t\tparts.push(`Removed ${connectionsRemoved} connection${connectionsRemoved &gt; 1 ? &#39;s&#39; : &#39;&#39;}`);\n+\t}\n+\n+\treturn parts.join(&#39;\\n&#39;);\n+}\n+\n+/**\n+ * Factory function to create the remove node tool\n+ */\n+export function createRemoveNodeTool(_logger?: Logger) {\n+\treturn tool(\n+\t\t(input, config) =&gt; {\n+\t\t\tconst reporter = createProgressReporter(config, &#39;remove_node&#39;);\n+\n+\t\t\ttry {\n+\t\t\t\t// Validate input using Zod schema\n+\t\t\t\tconst validatedInput = removeNodeSchema.parse(input);\n+\t\t\t\tconst { nodeId } = validatedInput;\n+\n+\t\t\t\t// Report tool start\n+\t\t\t\treporter.start(validatedInput);\n+\n+\t\t\t\t// Get current state\n+\t\t\t\tconst state = getWorkflowState();\n+\t\t\t\tconst workflow = getCurrentWorkflow(state);\n+\n+\t\t\t\t// Report progress\n+\t\t\t\treportProgress(reporter, `Removing node ${nodeId}`);\n+\n+\t\t\t\t// Find the node to remove\n+\t\t\t\tconst nodeToRemove = validateNodeExists(nodeId, workflow.nodes);\n+\n+\t\t\t\tif (!nodeToRemove) {\n+\t\t\t\t\tconst error = createNodeNotFoundError(nodeId);\n+\t\t\t\t\treporter.error(error);\n+\t\t\t\t\treturn createErrorResponse(config, error);\n+\t\t\t\t}\n+\n+\t\t\t\t// Count connections that will be removed\n+\t\t\t\tconst connectionsRemoved = countNodeConnections(nodeId, workflow.connections);\n+\n+\t\t\t\t// Build success message\n+\t\t\t\tconst message = buildResponseMessage(\n+\t\t\t\t\tnodeToRemove.name,\n+\t\t\t\t\tnodeToRemove.type,\n+\t\t\t\t\tconnectionsRemoved,\n+\t\t\t\t);\n+\n+\t\t\t\t// Report completion\n+\t\t\t\tconst output: RemoveNodeOutput = {\n+\t\t\t\t\tremovedNodeId: nodeId,\n+\t\t\t\t\tremovedNodeName: nodeToRemove.name,\n+\t\t\t\t\tremovedNodeType: nodeToRemove.type,\n+\t\t\t\t\tconnectionsRemoved,\n+\t\t\t\t\tmessage,\n+\t\t\t\t};\n+\t\t\t\treporter.complete(output);\n+\n+\t\t\t\t// Return success with state updates\n+\t\t\t\tconst stateUpdates = removeNodeFromWorkflow(nodeId);\n+\t\t\t\treturn createSuccessResponse(config, message, stateUpdates);\n+\t\t\t} catch (error) {\n+\t\t\t\t// Handle validation or unexpected errors\n+\t\t\t\tif (error instanceof z.ZodError) {\n+\t\t\t\t\tconst validationError = new ValidationError(&#39;Invalid input parameters&#39;, {\n+\t\t\t\t\t\textra: { errors: error.errors },\n+\t\t\t\t\t});\n+\t\t\t\t\treporter.error(validationError);\n+\t\t\t\t\treturn createErrorResponse(config, validationError);\n+\t\t\t\t}\n+\n+\t\t\t\tconst toolError = new ToolExecutionError(\n+\t\t\t\t\terror instanceof Error ? error.message : &#39;Unknown error occurred&#39;,\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttoolName: &#39;remove_node&#39;,\n+\t\t\t\t\t\tcause: error instanceof Error ? error : undefined,\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\t\t\t\treporter.error(toolError);\n+\t\t\t\treturn createErrorResponse(config, toolError);\n+\t\t\t}\n+\t\t},\n+\t\t{\n+\t\t\tname: &#39;remove_node&#39;,\n+\t\t\tdescription:\n+\t\t\t\t&#39;Remove a node from the workflow by its ID. This will also remove all connections to and from the node. Use this tool when you need to delete a node that is no longer needed in the workflow.&#39;,\n+\t\t\tschema: removeNodeSchema,\n+\t\t},\n+\t);\n+}\n</file context>\n```\n\n</details>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207228719",
    "pr_number": 17330,
    "pr_file": "packages/frontend/@n8n/chat/src/utils/streaming.ts",
    "created_at": "2025-07-15T11:29:45+00:00",
    "commented_code": "return this.nodeRuns.get(runKey)!.message;\n \t}\n \n+\tinitializeRichRun(nodeId: string, richContent: RichContent, runIndex?: number): ChatMessageRich {\n+\t\tconst runKey = this.getRunKey(nodeId, runIndex);\n+\t\tif (!this.richNodeRuns.has(runKey)) {\n+\t\t\tconst message = createRichBotMessage(richContent);\n+\t\t\tthis.richNodeRuns.set(runKey, {\n+\t\t\t\tcontent: richContent,\n+\t\t\t\tisComplete: false,\n+\t\t\t\tmessage,\n+\t\t\t});\n+\t\t\tthis.runOrder.push(runKey);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2207228719",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17330,
        "pr_file": "packages/frontend/@n8n/chat/src/utils/streaming.ts",
        "discussion_id": "2207228719",
        "commented_code": "@@ -43,6 +50,21 @@ export class StreamingMessageManager {\n \t\treturn this.nodeRuns.get(runKey)!.message;\n \t}\n \n+\tinitializeRichRun(nodeId: string, richContent: RichContent, runIndex?: number): ChatMessageRich {\n+\t\tconst runKey = this.getRunKey(nodeId, runIndex);\n+\t\tif (!this.richNodeRuns.has(runKey)) {\n+\t\t\tconst message = createRichBotMessage(richContent);\n+\t\t\tthis.richNodeRuns.set(runKey, {\n+\t\t\t\tcontent: richContent,\n+\t\t\t\tisComplete: false,\n+\t\t\t\tmessage,\n+\t\t\t});\n+\t\t\tthis.runOrder.push(runKey);",
        "comment_created_at": "2025-07-15T11:29:45+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[]} -->\nPushing runKey unconditionally risks inserting duplicate entries in runOrder when a text and a rich run share the same key, resulting in duplicate messages being returned by getAllMessages().\n\n```suggestion\n\t\t\tif (!this.runOrder.includes(runKey)) this.runOrder.push(runKey);\n```",
        "pr_file_module": null
      }
    ]
  }
]