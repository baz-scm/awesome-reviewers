[
  {
    "discussion_id": "2212485480",
    "pr_number": 17401,
    "pr_file": "packages/frontend/@n8n/chat/src/components/HtmlParse.vue",
    "created_at": "2025-07-17T07:12:59+00:00",
    "commented_code": "+<script setup lang=\"ts\">\n+import { computed } from 'vue';\n+import type { Component } from 'vue';\n+import Highlight from './Highlight.vue';\n+import isEmpty from 'lodash/isEmpty';\n+\n+interface TextNode {\n+\ttype: 'text';\n+\tcontent: string;\n+}\n+\n+interface ElementNode {\n+\ttype: 'element';\n+\ttag: string;\n+\tattributes: Record<string, string>;\n+\tchildren: ParsedNode[];\n+}\n+\n+interface ComponentNode {\n+\ttype: 'component';\n+\ttag: string;\n+\tprops: Record<string, any>;\n+}\n+\n+interface RenderHtmlNode {\n+\ttype: 'renderHtml';\n+\ttag: string;\n+\tprops?: Record<string, any>;\n+\thtml: string;\n+}\n+\n+type ParsedNode = TextNode | ElementNode | ComponentNode | RenderHtmlNode;\n+\n+// Configuration for different tag types\n+const TAG_CONFIG = {\n+\t// Tags that should be rendered as components\n+\tCOMPONENT_TAGS: new Set(['pre']),\n+\n+\t// Tags that should be rendered as HTML with special props\n+\tRENDER_HTML_WITH_PROPS: new Set(['code']),\n+\n+\t// Tags that should be rendered as pure HTML\n+\tRENDER_HTML_TAGS: new Set(['mjx-container', 'img', 'video', 'audio', 'table', 'hr']),\n+\n+\t// Tags that need special security attributes\n+\tSECURITY_TAGS: new Set(['a']),\n+\n+\t// Tags that should be processed as regular elements (recursive)\n+\tELEMENT_TAGS: new Set([\n+\t\t'strong',\n+\t\t'em',\n+\t\t's',\n+\t\t'b',\n+\t\t'i',\n+\t\t'u',\n+\t\t'span',\n+\t\t'div',\n+\t\t'p',\n+\t\t'h1',\n+\t\t'h2',\n+\t\t'h3',\n+\t\t'h4',\n+\t\t'h5',\n+\t\t'h6',\n+\t\t'ul',\n+\t\t'ol',\n+\t\t'li',\n+\t\t'blockquote',\n+\t]),\n+} as const;\n+\n+// Security attributes for specific tags\n+const SECURITY_ATTRIBUTES = {\n+\ta: {\n+\t\ttarget: '_blank',\n+\t\trel: 'noopener',\n+\t},\n+} as const;\n+\n+// Component mapping\n+const COMPONENT_MAP: Record<string, Component> = {\n+\thighlight: Highlight,\n+};\n+\n+// Resolve component name\n+const resolveComponent = (name: string): Component | string => {\n+\treturn COMPONENT_MAP[name] || name;\n+};\n+\n+const props = defineProps<{\n+\thtml?: string;\n+\tnode?: ParsedNode[];\n+}>();\n+\n+/**\n+ * Parse attributes from DOM element\n+ * @param element - DOM element to parse attributes from\n+ * @returns Record of attribute name-value pairs\n+ */\n+function parseAttributes(element: Element): Record<string, string> {\n+\tconst attributes: Record<string, string> = {};\n+\tArray.from(element.attributes).forEach((attr) => {\n+\t\tattributes[attr.name] = attr.value;\n+\t});\n+\treturn attributes;\n+}\n+\n+/**\n+ * Add security attributes to element attributes\n+ * @param tagName - Tag name to check for security attributes\n+ * @param attributes - Existing attributes\n+ * @returns Attributes with security attributes added\n+ */\n+function addSecurityAttributes(\n+\ttagName: string,\n+\tattributes: Record<string, string>,\n+): Record<string, string> {\n+\tconst securityAttrs = SECURITY_ATTRIBUTES[tagName as keyof typeof SECURITY_ATTRIBUTES];\n+\tif (securityAttrs) {\n+\t\treturn { ...attributes, ...securityAttrs };\n+\t}\n+\treturn attributes;\n+}\n+\n+/**\n+ * Create a component node for special tags like 'pre'\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @returns ComponentNode or null\n+ */\n+function createComponentNode(element: Element, tagName: string): ComponentNode | null {\n+\tif (tagName === 'pre') {\n+\t\tconst codeElement = element.querySelector(':scope > code');\n+\t\tconst className = codeElement?.className || '';\n+\t\tconst lang = className.split('-')[1];\n+\t\treturn {\n+\t\t\ttype: 'component',\n+\t\t\ttag: 'highlight',\n+\t\t\tprops: {\n+\t\t\t\tdata: codeElement?.textContent || '',\n+\t\t\t\tlanguage: lang,\n+\t\t\t},\n+\t\t};\n+\t}\n+\treturn null;\n+}\n+\n+/**\n+ * Create a render HTML node\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @param props - Additional props to add\n+ * @returns RenderHtmlNode\n+ */\n+function createRenderHtmlNode(\n+\telement: Element,\n+\ttagName: string,\n+\tprops?: Record<string, any>,\n+): RenderHtmlNode {\n+\treturn {\n+\t\ttype: 'renderHtml',\n+\t\ttag: tagName,\n+\t\tprops,\n+\t\thtml: element.innerHTML,\n+\t};\n+}\n+\n+/**\n+ * Create an element node with recursive child parsing\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @param attributes - Element attributes\n+ * @returns ElementNode\n+ */\n+function createElementNode(\n+\telement: Element,\n+\ttagName: string,\n+\tattributes: Record<string, string>,\n+): ElementNode {\n+\tconst elementNode: ElementNode = {\n+\t\ttype: 'element',\n+\t\ttag: tagName,\n+\t\tattributes,\n+\t\tchildren: [],\n+\t};\n+\n+\t// Parse child nodes recursively\n+\telement.childNodes.forEach((childNode) => {\n+\t\tconst child = parseNode(childNode);\n+\t\tif (child) {\n+\t\t\telementNode.children.push(child);\n+\t\t}\n+\t});\n+\n+\treturn elementNode;\n+}\n+\n+/**\n+ * Parse a single DOM node\n+ * @param node - DOM node to parse\n+ * @returns ParsedNode or null\n+ */\n+function parseNode(node: Node): ParsedNode | null {\n+\t// Handle text nodes\n+\tif (node.nodeType === Node.TEXT_NODE) {\n+\t\tconst content = node.nodeValue?.trim();\n+\t\treturn content ? { type: 'text', content } : null;\n+\t}\n+\n+\t// Handle element nodes\n+\tif (node.nodeType === Node.ELEMENT_NODE) {\n+\t\tconst element = node as Element;\n+\t\tconst tagName = element.tagName?.toLowerCase() || 'p';\n+\n+\t\t// Check if it's a component tag\n+\t\tif (TAG_CONFIG.COMPONENT_TAGS.has(tagName)) {\n+\t\t\treturn createComponentNode(element, tagName);\n+\t\t}\n+\n+\t\t// Check if it's a render HTML tag with props\n+\t\tif (TAG_CONFIG.RENDER_HTML_WITH_PROPS.has(tagName)) {\n+\t\t\tconst props = tagName === 'code' ? { class: 'code' } : undefined;\n+\t\t\treturn createRenderHtmlNode(element, tagName, props);\n+\t\t}\n+\n+\t\t// Check if it's a pure render HTML tag\n+\t\tif (TAG_CONFIG.RENDER_HTML_TAGS.has(tagName)) {\n+\t\t\treturn createRenderHtmlNode(element, tagName);\n+\t\t}\n+\n+\t\t// Handle security tags (like 'a')\n+\t\tif (TAG_CONFIG.SECURITY_TAGS.has(tagName)) {\n+\t\t\tconst attributes = parseAttributes(element);",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2212485480",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17401,
        "pr_file": "packages/frontend/@n8n/chat/src/components/HtmlParse.vue",
        "discussion_id": "2212485480",
        "commented_code": "@@ -0,0 +1,308 @@\n+<script setup lang=\"ts\">\n+import { computed } from 'vue';\n+import type { Component } from 'vue';\n+import Highlight from './Highlight.vue';\n+import isEmpty from 'lodash/isEmpty';\n+\n+interface TextNode {\n+\ttype: 'text';\n+\tcontent: string;\n+}\n+\n+interface ElementNode {\n+\ttype: 'element';\n+\ttag: string;\n+\tattributes: Record<string, string>;\n+\tchildren: ParsedNode[];\n+}\n+\n+interface ComponentNode {\n+\ttype: 'component';\n+\ttag: string;\n+\tprops: Record<string, any>;\n+}\n+\n+interface RenderHtmlNode {\n+\ttype: 'renderHtml';\n+\ttag: string;\n+\tprops?: Record<string, any>;\n+\thtml: string;\n+}\n+\n+type ParsedNode = TextNode | ElementNode | ComponentNode | RenderHtmlNode;\n+\n+// Configuration for different tag types\n+const TAG_CONFIG = {\n+\t// Tags that should be rendered as components\n+\tCOMPONENT_TAGS: new Set(['pre']),\n+\n+\t// Tags that should be rendered as HTML with special props\n+\tRENDER_HTML_WITH_PROPS: new Set(['code']),\n+\n+\t// Tags that should be rendered as pure HTML\n+\tRENDER_HTML_TAGS: new Set(['mjx-container', 'img', 'video', 'audio', 'table', 'hr']),\n+\n+\t// Tags that need special security attributes\n+\tSECURITY_TAGS: new Set(['a']),\n+\n+\t// Tags that should be processed as regular elements (recursive)\n+\tELEMENT_TAGS: new Set([\n+\t\t'strong',\n+\t\t'em',\n+\t\t's',\n+\t\t'b',\n+\t\t'i',\n+\t\t'u',\n+\t\t'span',\n+\t\t'div',\n+\t\t'p',\n+\t\t'h1',\n+\t\t'h2',\n+\t\t'h3',\n+\t\t'h4',\n+\t\t'h5',\n+\t\t'h6',\n+\t\t'ul',\n+\t\t'ol',\n+\t\t'li',\n+\t\t'blockquote',\n+\t]),\n+} as const;\n+\n+// Security attributes for specific tags\n+const SECURITY_ATTRIBUTES = {\n+\ta: {\n+\t\ttarget: '_blank',\n+\t\trel: 'noopener',\n+\t},\n+} as const;\n+\n+// Component mapping\n+const COMPONENT_MAP: Record<string, Component> = {\n+\thighlight: Highlight,\n+};\n+\n+// Resolve component name\n+const resolveComponent = (name: string): Component | string => {\n+\treturn COMPONENT_MAP[name] || name;\n+};\n+\n+const props = defineProps<{\n+\thtml?: string;\n+\tnode?: ParsedNode[];\n+}>();\n+\n+/**\n+ * Parse attributes from DOM element\n+ * @param element - DOM element to parse attributes from\n+ * @returns Record of attribute name-value pairs\n+ */\n+function parseAttributes(element: Element): Record<string, string> {\n+\tconst attributes: Record<string, string> = {};\n+\tArray.from(element.attributes).forEach((attr) => {\n+\t\tattributes[attr.name] = attr.value;\n+\t});\n+\treturn attributes;\n+}\n+\n+/**\n+ * Add security attributes to element attributes\n+ * @param tagName - Tag name to check for security attributes\n+ * @param attributes - Existing attributes\n+ * @returns Attributes with security attributes added\n+ */\n+function addSecurityAttributes(\n+\ttagName: string,\n+\tattributes: Record<string, string>,\n+): Record<string, string> {\n+\tconst securityAttrs = SECURITY_ATTRIBUTES[tagName as keyof typeof SECURITY_ATTRIBUTES];\n+\tif (securityAttrs) {\n+\t\treturn { ...attributes, ...securityAttrs };\n+\t}\n+\treturn attributes;\n+}\n+\n+/**\n+ * Create a component node for special tags like 'pre'\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @returns ComponentNode or null\n+ */\n+function createComponentNode(element: Element, tagName: string): ComponentNode | null {\n+\tif (tagName === 'pre') {\n+\t\tconst codeElement = element.querySelector(':scope > code');\n+\t\tconst className = codeElement?.className || '';\n+\t\tconst lang = className.split('-')[1];\n+\t\treturn {\n+\t\t\ttype: 'component',\n+\t\t\ttag: 'highlight',\n+\t\t\tprops: {\n+\t\t\t\tdata: codeElement?.textContent || '',\n+\t\t\t\tlanguage: lang,\n+\t\t\t},\n+\t\t};\n+\t}\n+\treturn null;\n+}\n+\n+/**\n+ * Create a render HTML node\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @param props - Additional props to add\n+ * @returns RenderHtmlNode\n+ */\n+function createRenderHtmlNode(\n+\telement: Element,\n+\ttagName: string,\n+\tprops?: Record<string, any>,\n+): RenderHtmlNode {\n+\treturn {\n+\t\ttype: 'renderHtml',\n+\t\ttag: tagName,\n+\t\tprops,\n+\t\thtml: element.innerHTML,\n+\t};\n+}\n+\n+/**\n+ * Create an element node with recursive child parsing\n+ * @param element - DOM element\n+ * @param tagName - Tag name\n+ * @param attributes - Element attributes\n+ * @returns ElementNode\n+ */\n+function createElementNode(\n+\telement: Element,\n+\ttagName: string,\n+\tattributes: Record<string, string>,\n+): ElementNode {\n+\tconst elementNode: ElementNode = {\n+\t\ttype: 'element',\n+\t\ttag: tagName,\n+\t\tattributes,\n+\t\tchildren: [],\n+\t};\n+\n+\t// Parse child nodes recursively\n+\telement.childNodes.forEach((childNode) => {\n+\t\tconst child = parseNode(childNode);\n+\t\tif (child) {\n+\t\t\telementNode.children.push(child);\n+\t\t}\n+\t});\n+\n+\treturn elementNode;\n+}\n+\n+/**\n+ * Parse a single DOM node\n+ * @param node - DOM node to parse\n+ * @returns ParsedNode or null\n+ */\n+function parseNode(node: Node): ParsedNode | null {\n+\t// Handle text nodes\n+\tif (node.nodeType === Node.TEXT_NODE) {\n+\t\tconst content = node.nodeValue?.trim();\n+\t\treturn content ? { type: 'text', content } : null;\n+\t}\n+\n+\t// Handle element nodes\n+\tif (node.nodeType === Node.ELEMENT_NODE) {\n+\t\tconst element = node as Element;\n+\t\tconst tagName = element.tagName?.toLowerCase() || 'p';\n+\n+\t\t// Check if it's a component tag\n+\t\tif (TAG_CONFIG.COMPONENT_TAGS.has(tagName)) {\n+\t\t\treturn createComponentNode(element, tagName);\n+\t\t}\n+\n+\t\t// Check if it's a render HTML tag with props\n+\t\tif (TAG_CONFIG.RENDER_HTML_WITH_PROPS.has(tagName)) {\n+\t\t\tconst props = tagName === 'code' ? { class: 'code' } : undefined;\n+\t\t\treturn createRenderHtmlNode(element, tagName, props);\n+\t\t}\n+\n+\t\t// Check if it's a pure render HTML tag\n+\t\tif (TAG_CONFIG.RENDER_HTML_TAGS.has(tagName)) {\n+\t\t\treturn createRenderHtmlNode(element, tagName);\n+\t\t}\n+\n+\t\t// Handle security tags (like 'a')\n+\t\tif (TAG_CONFIG.SECURITY_TAGS.has(tagName)) {\n+\t\t\tconst attributes = parseAttributes(element);",
        "comment_created_at": "2025-07-17T07:12:59+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nAll tags not explicitly whitelisted are rendered directly, and the collected attributes are bound to the component without any sanitization. This means an attacker could inject <script>, <iframe>, or event-handler attributes (e.g., onclick) into props.html and achieve XSS when the component renders.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212485484",
    "pr_number": 17401,
    "pr_file": "packages/frontend/@n8n/chat/src/components/Message.vue",
    "created_at": "2025-07-17T07:13:00+00:00",
    "commented_code": "<script lang=\"ts\" setup>\n /* eslint-disable @typescript-eslint/naming-convention */\n-import hljs from 'highlight.js/lib/core';\n-import bash from 'highlight.js/lib/languages/bash';\n-import javascript from 'highlight.js/lib/languages/javascript';\n-import python from 'highlight.js/lib/languages/python';\n-import typescript from 'highlight.js/lib/languages/typescript';\n-import xml from 'highlight.js/lib/languages/xml';\n-import type MarkdownIt from 'markdown-it';\n-import markdownLink from 'markdown-it-link-attributes';\n+import markdownIt from 'markdown-it';\n+import mathjax3 from 'markdown-it-mathjax3';\n+const md = markdownIt({\n+\thtml: true,",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2212485484",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17401,
        "pr_file": "packages/frontend/@n8n/chat/src/components/Message.vue",
        "discussion_id": "2212485484",
        "commented_code": "@@ -1,31 +1,25 @@\n <script lang=\"ts\" setup>\n /* eslint-disable @typescript-eslint/naming-convention */\n-import hljs from 'highlight.js/lib/core';\n-import bash from 'highlight.js/lib/languages/bash';\n-import javascript from 'highlight.js/lib/languages/javascript';\n-import python from 'highlight.js/lib/languages/python';\n-import typescript from 'highlight.js/lib/languages/typescript';\n-import xml from 'highlight.js/lib/languages/xml';\n-import type MarkdownIt from 'markdown-it';\n-import markdownLink from 'markdown-it-link-attributes';\n+import markdownIt from 'markdown-it';\n+import mathjax3 from 'markdown-it-mathjax3';\n+const md = markdownIt({\n+\thtml: true,",
        "comment_created_at": "2025-07-17T07:13:00+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"**/HtmlParse.vue\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/frontend/@n8n/chat/src/components/HtmlParse.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' packages/frontend/@n8n/chat/src/components/Highlight.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"function parseHTML\\\" -n packages/frontend/@n8n/chat/src/components/HtmlParse.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"RENDER_HTML_TAGS\\\" -n packages/frontend/@n8n/chat/src/components/HtmlParse.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"case ELEMENT_NODE\\\" -n packages/frontend/@n8n/chat/src/components/HtmlParse.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '220,340p' packages/frontend/@n8n/chat/src/components/HtmlParse.vue\"},\"toolName\":\"executeCommand\"}]}]} -->\nEnabling raw HTML rendering without any sanitization exposes the component to XSS. User-provided markdown can inject <script> or other malicious tags, and HtmlParse does not strip unknown or dangerous tags.\n\n```suggestion\n\thtml: false,\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207738522",
    "pr_number": 17338,
    "pr_file": "packages/cli/templates/form-trigger-completion.handlebars",
    "created_at": "2025-07-15T14:52:49+00:00",
    "commented_code": "<div class='card'>\n \t\t\t\t\t\t<div class='header'>\n \t\t\t\t\t\t\t<h1>{{title}}</h1>\n-\t\t\t\t\t\t\t<p>{{message}}</p>\n+\t\t\t\t\t\t\t<p>{{{message}}}</p>",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2207738522",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17338,
        "pr_file": "packages/cli/templates/form-trigger-completion.handlebars",
        "discussion_id": "2207738522",
        "commented_code": "@@ -115,7 +115,7 @@\n \t\t\t\t\t<div class='card'>\n \t\t\t\t\t\t<div class='header'>\n \t\t\t\t\t\t\t<h1>{{title}}</h1>\n-\t\t\t\t\t\t\t<p>{{message}}</p>\n+\t\t\t\t\t\t\t<p>{{{message}}}</p>",
        "comment_created_at": "2025-07-15T14:52:49+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[]} -->\nUsing triple mustache ({{{message}}}) in Handlebars renders raw HTML, which can introduce XSS vulnerabilities if 'message' contains untrusted user input. Ensure that 'message' is properly sanitized before rendering, or document the security implications clearly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207228730",
    "pr_number": 17330,
    "pr_file": "packages/frontend/editor-ui/src/components/RunDataHtml.vue",
    "created_at": "2025-07-15T11:29:45+00:00",
    "commented_code": "import sanitizeHtml, { defaults, type IOptions as SanitizeOptions } from 'sanitize-html';\n \n const sanitizeOptions: SanitizeOptions = {\n-\tallowVulnerableTags: false,\n+\tallowVulnerableTags: ['style'],",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2207228730",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17330,
        "pr_file": "packages/frontend/editor-ui/src/components/RunDataHtml.vue",
        "discussion_id": "2207228730",
        "commented_code": "@@ -2,7 +2,7 @@\n import sanitizeHtml, { defaults, type IOptions as SanitizeOptions } from 'sanitize-html';\n \n const sanitizeOptions: SanitizeOptions = {\n-\tallowVulnerableTags: false,\n+\tallowVulnerableTags: ['style'],",
        "comment_created_at": "2025-07-15T11:29:45+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[]} -->\nAllowing 'style' in allowVulnerableTags can introduce XSS risks if user input is not strictly controlled, as inline styles can be abused for attacks. Ensure that only trusted content is passed or consider stricter sanitization.\n\n```suggestion\n\tallowVulnerableTags: false,\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207228752",
    "pr_number": 17330,
    "pr_file": "packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue",
    "created_at": "2025-07-15T11:29:46+00:00",
    "commented_code": "+<template>\n+\t<div class=\"rich-message-container\" :class=\"{ 'user-message': isUser, 'bot-message': !isUser }\">\n+\t\t<!-- Custom CSS injection -->\n+\t\t<component :is=\"'style'\" v-if=\"content.css\" type=\"text/css\" scoped>\n+\t\t\t{{ sanitizedCSS }}\n+\t\t</component>\n+\n+\t\t<!-- HTML Content -->\n+\t\t<div v-if=\"content.html\" class=\"rich-html-content\" v-html=\"sanitizedHTML\" />\n+\n+\t\t<!-- Interactive Components -->\n+\t\t<div v-if=\"content.components && content.components.length > 0\" class=\"rich-components\">\n+\t\t\t<component\n+\t\t\t\tv-for=\"comp in content.components\"\n+\t\t\t\t:key=\"comp.id\"\n+\t\t\t\t:is=\"getComponentType(comp.type)\"\n+\t\t\t\tv-bind=\"comp.props\"\n+\t\t\t\t:style=\"comp.style\"\n+\t\t\t\t@click=\"handleComponentEvent(comp, 'click', $event)\"\n+\t\t\t\t@change=\"handleComponentEvent(comp, 'change', $event)\"\n+\t\t\t/>\n+\t\t</div>\n+\n+\t\t<!-- Data Display -->\n+\t\t<div v-if=\"content.data && Object.keys(content.data).length > 0\" class=\"rich-data\">\n+\t\t\t<pre>{{ JSON.stringify(content.data, null, 2) }}</pre>\n+\t\t</div>\n+\n+\t\t<!-- Script Execution -->\n+\t\t<div ref=\"scriptContainer\" class=\"script-container\" />\n+\t</div>\n+</template>\n+\n+<script setup lang=\"ts\">\n+import { computed, nextTick, onMounted, ref } from 'vue';\n+import DOMPurify from 'dompurify';\n+import type { RichContent, RichComponent } from '../types/messages';\n+\n+interface Props {\n+\tcontent: RichContent;\n+\tisUser?: boolean;\n+}\n+\n+const props = withDefaults(defineProps<Props>(), {\n+\tisUser: false,\n+});\n+\n+const scriptContainer = ref<HTMLElement>();\n+\n+// Sanitization based on content settings\n+const sanitizedHTML = computed(() => {\n+\tif (!props.content.html) return '';\n+\n+\tswitch (props.content.sanitize) {\n+\t\tcase 'none':\n+\t\t\treturn props.content.html;\n+\t\tcase 'strict':\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'span', 'div'],\n+\t\t\t\tALLOWED_ATTR: ['class'],\n+\t\t\t});\n+\t\tcase 'basic':\n+\t\tdefault:\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tADD_TAGS: ['iframe'],\n+\t\t\t\tADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],\n+\t\t\t});\n+\t}\n+});\n+\n+const sanitizedCSS = computed(() => {\n+\tif (!props.content.css) return '';\n+\n+\t// Basic CSS sanitization - remove dangerous properties\n+\tconst dangerousProps = ['expression', 'javascript:', 'vbscript:', 'onload', 'onerror'];",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2207228752",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17330,
        "pr_file": "packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue",
        "discussion_id": "2207228752",
        "commented_code": "@@ -0,0 +1,241 @@\n+<template>\n+\t<div class=\"rich-message-container\" :class=\"{ 'user-message': isUser, 'bot-message': !isUser }\">\n+\t\t<!-- Custom CSS injection -->\n+\t\t<component :is=\"'style'\" v-if=\"content.css\" type=\"text/css\" scoped>\n+\t\t\t{{ sanitizedCSS }}\n+\t\t</component>\n+\n+\t\t<!-- HTML Content -->\n+\t\t<div v-if=\"content.html\" class=\"rich-html-content\" v-html=\"sanitizedHTML\" />\n+\n+\t\t<!-- Interactive Components -->\n+\t\t<div v-if=\"content.components && content.components.length > 0\" class=\"rich-components\">\n+\t\t\t<component\n+\t\t\t\tv-for=\"comp in content.components\"\n+\t\t\t\t:key=\"comp.id\"\n+\t\t\t\t:is=\"getComponentType(comp.type)\"\n+\t\t\t\tv-bind=\"comp.props\"\n+\t\t\t\t:style=\"comp.style\"\n+\t\t\t\t@click=\"handleComponentEvent(comp, 'click', $event)\"\n+\t\t\t\t@change=\"handleComponentEvent(comp, 'change', $event)\"\n+\t\t\t/>\n+\t\t</div>\n+\n+\t\t<!-- Data Display -->\n+\t\t<div v-if=\"content.data && Object.keys(content.data).length > 0\" class=\"rich-data\">\n+\t\t\t<pre>{{ JSON.stringify(content.data, null, 2) }}</pre>\n+\t\t</div>\n+\n+\t\t<!-- Script Execution -->\n+\t\t<div ref=\"scriptContainer\" class=\"script-container\" />\n+\t</div>\n+</template>\n+\n+<script setup lang=\"ts\">\n+import { computed, nextTick, onMounted, ref } from 'vue';\n+import DOMPurify from 'dompurify';\n+import type { RichContent, RichComponent } from '../types/messages';\n+\n+interface Props {\n+\tcontent: RichContent;\n+\tisUser?: boolean;\n+}\n+\n+const props = withDefaults(defineProps<Props>(), {\n+\tisUser: false,\n+});\n+\n+const scriptContainer = ref<HTMLElement>();\n+\n+// Sanitization based on content settings\n+const sanitizedHTML = computed(() => {\n+\tif (!props.content.html) return '';\n+\n+\tswitch (props.content.sanitize) {\n+\t\tcase 'none':\n+\t\t\treturn props.content.html;\n+\t\tcase 'strict':\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'span', 'div'],\n+\t\t\t\tALLOWED_ATTR: ['class'],\n+\t\t\t});\n+\t\tcase 'basic':\n+\t\tdefault:\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tADD_TAGS: ['iframe'],\n+\t\t\t\tADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],\n+\t\t\t});\n+\t}\n+});\n+\n+const sanitizedCSS = computed(() => {\n+\tif (!props.content.css) return '';\n+\n+\t// Basic CSS sanitization - remove dangerous properties\n+\tconst dangerousProps = ['expression', 'javascript:', 'vbscript:', 'onload', 'onerror'];",
        "comment_created_at": "2025-07-15T11:29:46+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"new Function('event'\\\" -R\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,260p' packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"with (sandbox\\\" -R packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A5 -B5 \\\"new Function(\\\" packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"const scriptContainer\\\" -n packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"dangerousProps\\\" -R\"},\"toolName\":\"executeCommand\"}]}]} -->\nCSS sanitization is done with a simple case-insensitive substring replace, which is insufficient against crafted inputs (e.g., `jav\\0ascript:` or `url(javascript:...)`). This gives a false sense of security and can allow style-based XSS.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207228754",
    "pr_number": 17330,
    "pr_file": "packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue",
    "created_at": "2025-07-15T11:29:46+00:00",
    "commented_code": "+<template>\n+\t<div class=\"rich-message-container\" :class=\"{ 'user-message': isUser, 'bot-message': !isUser }\">\n+\t\t<!-- Custom CSS injection -->\n+\t\t<component :is=\"'style'\" v-if=\"content.css\" type=\"text/css\" scoped>\n+\t\t\t{{ sanitizedCSS }}\n+\t\t</component>\n+\n+\t\t<!-- HTML Content -->\n+\t\t<div v-if=\"content.html\" class=\"rich-html-content\" v-html=\"sanitizedHTML\" />\n+\n+\t\t<!-- Interactive Components -->\n+\t\t<div v-if=\"content.components && content.components.length > 0\" class=\"rich-components\">\n+\t\t\t<component\n+\t\t\t\tv-for=\"comp in content.components\"\n+\t\t\t\t:key=\"comp.id\"\n+\t\t\t\t:is=\"getComponentType(comp.type)\"\n+\t\t\t\tv-bind=\"comp.props\"\n+\t\t\t\t:style=\"comp.style\"\n+\t\t\t\t@click=\"handleComponentEvent(comp, 'click', $event)\"\n+\t\t\t\t@change=\"handleComponentEvent(comp, 'change', $event)\"\n+\t\t\t/>\n+\t\t</div>\n+\n+\t\t<!-- Data Display -->\n+\t\t<div v-if=\"content.data && Object.keys(content.data).length > 0\" class=\"rich-data\">\n+\t\t\t<pre>{{ JSON.stringify(content.data, null, 2) }}</pre>\n+\t\t</div>\n+\n+\t\t<!-- Script Execution -->\n+\t\t<div ref=\"scriptContainer\" class=\"script-container\" />\n+\t</div>\n+</template>\n+\n+<script setup lang=\"ts\">\n+import { computed, nextTick, onMounted, ref } from 'vue';\n+import DOMPurify from 'dompurify';\n+import type { RichContent, RichComponent } from '../types/messages';\n+\n+interface Props {\n+\tcontent: RichContent;\n+\tisUser?: boolean;\n+}\n+\n+const props = withDefaults(defineProps<Props>(), {\n+\tisUser: false,\n+});\n+\n+const scriptContainer = ref<HTMLElement>();\n+\n+// Sanitization based on content settings\n+const sanitizedHTML = computed(() => {\n+\tif (!props.content.html) return '';\n+\n+\tswitch (props.content.sanitize) {\n+\t\tcase 'none':\n+\t\t\treturn props.content.html;\n+\t\tcase 'strict':\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'span', 'div'],\n+\t\t\t\tALLOWED_ATTR: ['class'],\n+\t\t\t});\n+\t\tcase 'basic':\n+\t\tdefault:\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tADD_TAGS: ['iframe'],\n+\t\t\t\tADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],\n+\t\t\t});\n+\t}\n+});\n+\n+const sanitizedCSS = computed(() => {\n+\tif (!props.content.css) return '';\n+\n+\t// Basic CSS sanitization - remove dangerous properties\n+\tconst dangerousProps = ['expression', 'javascript:', 'vbscript:', 'onload', 'onerror'];\n+\tlet css = props.content.css;\n+\n+\tdangerousProps.forEach((prop) => {\n+\t\tcss = css.replace(new RegExp(prop, 'gi'), '');\n+\t});\n+\n+\treturn css;\n+});\n+\n+// Component type mapping\n+const getComponentType = (type: RichComponent['type']) => {\n+\tconst componentMap = {\n+\t\tbutton: 'button',\n+\t\tform: 'form',\n+\t\tchart: 'div', // Custom chart component\n+\t\ttable: 'table',\n+\t\timage: 'img',\n+\t\tvideo: 'video',\n+\t\tiframe: 'iframe',\n+\t};\n+\n+\treturn componentMap[type] || 'div';\n+};\n+\n+// Event handling for interactive components\n+const handleComponentEvent = (component: RichComponent, eventType: string, event: Event) => {\n+\tif (!component.events || !component.events[eventType]) return;\n+\n+\ttry {\n+\t\t// Safely execute event handler in controlled context\n+\t\tconst handler = new Function('event', 'component', 'data', component.events[eventType]);\n+\t\thandler(event, component, props.content.data);\n+\t} catch (error) {\n+\t\tconsole.warn('Rich content event handler error:', error);\n+\t}\n+};\n+\n+// Script execution in sandboxed environment\n+onMounted(async () => {\n+\tif (!props.content.script || !scriptContainer.value) return;\n+\n+\tawait nextTick();\n+\n+\ttry {\n+\t\t// Create sandboxed execution context\n+\t\tconst sandbox = {\n+\t\t\tconsole: {\n+\t\t\t\tlog: (...args: any[]) => {}, // Disabled in production\n+\t\t\t\terror: (...args: any[]) => console.error('[Rich Content]', ...args),\n+\t\t\t\twarn: (...args: any[]) => console.warn('[Rich Content]', ...args),\n+\t\t\t},\n+\t\t\tdata: props.content.data,\n+\t\t\tcontainer: scriptContainer.value,\n+\t\t\t// Restricted DOM access\n+\t\t\tdocument: {\n+\t\t\t\tcreateElement: document.createElement.bind(document),\n+\t\t\t\tgetElementById: (id: string) => scriptContainer.value?.querySelector(`#${id}`),\n+\t\t\t},\n+\t\t};\n+\n+\t\t// Execute script with limited context\n+\t\tconst scriptFunction = new Function(",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2207228754",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17330,
        "pr_file": "packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue",
        "discussion_id": "2207228754",
        "commented_code": "@@ -0,0 +1,241 @@\n+<template>\n+\t<div class=\"rich-message-container\" :class=\"{ 'user-message': isUser, 'bot-message': !isUser }\">\n+\t\t<!-- Custom CSS injection -->\n+\t\t<component :is=\"'style'\" v-if=\"content.css\" type=\"text/css\" scoped>\n+\t\t\t{{ sanitizedCSS }}\n+\t\t</component>\n+\n+\t\t<!-- HTML Content -->\n+\t\t<div v-if=\"content.html\" class=\"rich-html-content\" v-html=\"sanitizedHTML\" />\n+\n+\t\t<!-- Interactive Components -->\n+\t\t<div v-if=\"content.components && content.components.length > 0\" class=\"rich-components\">\n+\t\t\t<component\n+\t\t\t\tv-for=\"comp in content.components\"\n+\t\t\t\t:key=\"comp.id\"\n+\t\t\t\t:is=\"getComponentType(comp.type)\"\n+\t\t\t\tv-bind=\"comp.props\"\n+\t\t\t\t:style=\"comp.style\"\n+\t\t\t\t@click=\"handleComponentEvent(comp, 'click', $event)\"\n+\t\t\t\t@change=\"handleComponentEvent(comp, 'change', $event)\"\n+\t\t\t/>\n+\t\t</div>\n+\n+\t\t<!-- Data Display -->\n+\t\t<div v-if=\"content.data && Object.keys(content.data).length > 0\" class=\"rich-data\">\n+\t\t\t<pre>{{ JSON.stringify(content.data, null, 2) }}</pre>\n+\t\t</div>\n+\n+\t\t<!-- Script Execution -->\n+\t\t<div ref=\"scriptContainer\" class=\"script-container\" />\n+\t</div>\n+</template>\n+\n+<script setup lang=\"ts\">\n+import { computed, nextTick, onMounted, ref } from 'vue';\n+import DOMPurify from 'dompurify';\n+import type { RichContent, RichComponent } from '../types/messages';\n+\n+interface Props {\n+\tcontent: RichContent;\n+\tisUser?: boolean;\n+}\n+\n+const props = withDefaults(defineProps<Props>(), {\n+\tisUser: false,\n+});\n+\n+const scriptContainer = ref<HTMLElement>();\n+\n+// Sanitization based on content settings\n+const sanitizedHTML = computed(() => {\n+\tif (!props.content.html) return '';\n+\n+\tswitch (props.content.sanitize) {\n+\t\tcase 'none':\n+\t\t\treturn props.content.html;\n+\t\tcase 'strict':\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'span', 'div'],\n+\t\t\t\tALLOWED_ATTR: ['class'],\n+\t\t\t});\n+\t\tcase 'basic':\n+\t\tdefault:\n+\t\t\treturn DOMPurify.sanitize(props.content.html, {\n+\t\t\t\tADD_TAGS: ['iframe'],\n+\t\t\t\tADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],\n+\t\t\t});\n+\t}\n+});\n+\n+const sanitizedCSS = computed(() => {\n+\tif (!props.content.css) return '';\n+\n+\t// Basic CSS sanitization - remove dangerous properties\n+\tconst dangerousProps = ['expression', 'javascript:', 'vbscript:', 'onload', 'onerror'];\n+\tlet css = props.content.css;\n+\n+\tdangerousProps.forEach((prop) => {\n+\t\tcss = css.replace(new RegExp(prop, 'gi'), '');\n+\t});\n+\n+\treturn css;\n+});\n+\n+// Component type mapping\n+const getComponentType = (type: RichComponent['type']) => {\n+\tconst componentMap = {\n+\t\tbutton: 'button',\n+\t\tform: 'form',\n+\t\tchart: 'div', // Custom chart component\n+\t\ttable: 'table',\n+\t\timage: 'img',\n+\t\tvideo: 'video',\n+\t\tiframe: 'iframe',\n+\t};\n+\n+\treturn componentMap[type] || 'div';\n+};\n+\n+// Event handling for interactive components\n+const handleComponentEvent = (component: RichComponent, eventType: string, event: Event) => {\n+\tif (!component.events || !component.events[eventType]) return;\n+\n+\ttry {\n+\t\t// Safely execute event handler in controlled context\n+\t\tconst handler = new Function('event', 'component', 'data', component.events[eventType]);\n+\t\thandler(event, component, props.content.data);\n+\t} catch (error) {\n+\t\tconsole.warn('Rich content event handler error:', error);\n+\t}\n+};\n+\n+// Script execution in sandboxed environment\n+onMounted(async () => {\n+\tif (!props.content.script || !scriptContainer.value) return;\n+\n+\tawait nextTick();\n+\n+\ttry {\n+\t\t// Create sandboxed execution context\n+\t\tconst sandbox = {\n+\t\t\tconsole: {\n+\t\t\t\tlog: (...args: any[]) => {}, // Disabled in production\n+\t\t\t\terror: (...args: any[]) => console.error('[Rich Content]', ...args),\n+\t\t\t\twarn: (...args: any[]) => console.warn('[Rich Content]', ...args),\n+\t\t\t},\n+\t\t\tdata: props.content.data,\n+\t\t\tcontainer: scriptContainer.value,\n+\t\t\t// Restricted DOM access\n+\t\t\tdocument: {\n+\t\t\t\tcreateElement: document.createElement.bind(document),\n+\t\t\t\tgetElementById: (id: string) => scriptContainer.value?.querySelector(`#${id}`),\n+\t\t\t},\n+\t\t};\n+\n+\t\t// Execute script with limited context\n+\t\tconst scriptFunction = new Function(",
        "comment_created_at": "2025-07-15T11:29:46+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"new Function('event'\\\" -R\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,260p' packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"with (sandbox\\\" -R packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A5 -B5 \\\"new Function(\\\" packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"const scriptContainer\\\" -n packages/frontend/@n8n/chat/src/components/RichMessageRenderer.vue\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"dangerousProps\\\" -R\"},\"toolName\":\"executeCommand\"}]}]} -->\nRich content scripts are executed via `new Function`, again providing arbitrary code execution and violating CSP, only weakly masked by a `with(sandbox)` wrapper.",
        "pr_file_module": null
      }
    ]
  }
]