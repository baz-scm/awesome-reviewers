[
  {
    "discussion_id": "2178027606",
    "pr_number": 16895,
    "pr_file": "provision/provision_distributed.py",
    "created_at": "2025-07-01T16:18:06+00:00",
    "commented_code": "+from flask import Flask, request, jsonify\n+import yaml\n+import os\n+import random\n+import time\n+from kubernetes import client, config\n+from pymongo.mongo_client import MongoClient\n+from pymongo.server_api import ServerApi\n+\n+app = Flask(__name__)\n+\n+# Load Kubernetes config\n+try:\n+    config.load_incluster_config()  # For running inside cluster\n+except:\n+    config.load_kube_config()  # For local development\n+\n+k8s_apps_v1 = client.AppsV1Api()\n+k8s_core_v1 = client.CoreV1Api()\n+# Removed k8s_networking_v1 since not using Ingress with Cloudflare\n+\n+# MongoDB setup\n+uri = \"mongodb+srv://akaneai420:ilovehentai321@cluster0.jwyab3g.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0\"",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2178027606",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16895,
        "pr_file": "provision/provision_distributed.py",
        "discussion_id": "2178027606",
        "commented_code": "@@ -0,0 +1,244 @@\n+from flask import Flask, request, jsonify\n+import yaml\n+import os\n+import random\n+import time\n+from kubernetes import client, config\n+from pymongo.mongo_client import MongoClient\n+from pymongo.server_api import ServerApi\n+\n+app = Flask(__name__)\n+\n+# Load Kubernetes config\n+try:\n+    config.load_incluster_config()  # For running inside cluster\n+except:\n+    config.load_kube_config()  # For local development\n+\n+k8s_apps_v1 = client.AppsV1Api()\n+k8s_core_v1 = client.CoreV1Api()\n+# Removed k8s_networking_v1 since not using Ingress with Cloudflare\n+\n+# MongoDB setup\n+uri = \"mongodb+srv://akaneai420:ilovehentai321@cluster0.jwyab3g.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0\"",
        "comment_created_at": "2025-07-01T16:18:06+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[]} -->\nHard-coding database credentials exposes sensitive information in the repository and production image; move the URI to a secure environment variable or secret manager.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178027638",
    "pr_number": 16895,
    "pr_file": "provision/provision.py",
    "created_at": "2025-07-01T16:18:07+00:00",
    "commented_code": "+from flask import Flask, request, jsonify\n+import docker\n+import os\n+import yaml\n+import socket\n+import random\n+from pymongo.mongo_client import MongoClient\n+from pymongo.server_api import ServerApi\n+from flask_cors import CORS\n+import re\n+\n+from dotenv import load_dotenv, find_dotenv\n+import threading\n+load_dotenv(find_dotenv())\n+\n+app = Flask(__name__)\n+CORS(app)\n+docker_client = docker.from_env()\n+\n+domain = os.getenv('DOMAIN_NAME')\n+db_password = os.getenv('DB_PASSWORD')\n+uri = f\"mongodb+srv://akaneai420:{db_password}@cluster0.jwyab3g.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0\"\n+mongo_client = MongoClient(uri, server_api=ServerApi('1'))\n+users_mono = mongo_client['flowstate']['users-monolith']\n+\n+def is_port_in_use(port):\n+    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n+        try:\n+            s.bind(('', port))\n+            return False\n+        except socket.error:\n+            return True\n+\n+def create_compose_config(username, randomised_port, email=''):\n+    return {\n+        'networks': {\n+            'traefik-network': {\n+                'external': True\n+            }\n+        },\n+        'services': {\n+            'n8n': {\n+                'image': '5quidw4rd/n8n-custom-amd:latest',\n+                'restart': 'always',\n+                'networks': ['traefik-network'],\n+                'ports': [str(f'{randomised_port}:5678')],\n+                'container_name': f'n8n-{username}',\n+                'labels': {\n+                    'traefik.enable': 'true',\n+                    'traefik.http.routers.n8n-{}.rule'.format(username): f'Host(`{username}.{domain}`)',\n+                    'traefik.http.routers.n8n-{}.tls'.format(username): 'true',\n+                    'traefik.http.routers.n8n-{}.entrypoints'.format(username): 'web,websecure',\n+                    'traefik.http.routers.n8n-{}.tls.certresolver'.format(username): 'mytlschallenge',\n+                },\n+                'environment': {\n+                    'N8N_HOST': f'{username}.{domain}',\n+                    'N8N_PORT': '5678',\n+                    'N8N_PROTOCOL': 'https',\n+                    'NODE_ENV': 'production',\n+                    'WEBHOOK_URL': f'https://{username}.{domain}/',\n+                    'GENERIC_TIMEZONE': 'Europe/Berlin',\n+                    'EXTERNAL_HOOK_FILES': '/home/node/.n8n/hooks.js',\n+                    'LOGIN_EMAIL': f'{email}',\n+                    'LOGIN_PASSWORD': 'password',\n+                    'N8N_HIDE_USAGE_PAGE': 'true',\n+                    'N8N_PERSONALIZATION_ENABLED': 'false',\n+                    'N8N_VERSION_NOTIFICATIONS_ENABLED': 'false',\n+                    'NODES_EXCLUDE': '[\"n8n-nodes-base.executeCommand\"]'\n+                },\n+                'volumes': [\n+                    f'n8n_data_{username}:/home/node/.n8n'\n+                ]\n+            }\n+        },\n+        'volumes': {\n+            f'n8n_data_{username}': {\n+                'name': f'n8n_data_{username}'\n+            }\n+        }\n+    }\n+\n+def create_compose_config_mac(username, randomised_port):\n+    return {\n+        'networks': {\n+            'traefik-network': {\n+                'external': True\n+            }\n+        },\n+        'services': {\n+            'n8n': {\n+                'image': '5quidw4rd/n8n-custom:latest',\n+                'restart': 'always',\n+                'networks': ['traefik-network'],\n+                'ports': [str(f'{randomised_port}:5678')],\n+                'container_name': f'n8n-{username}',\n+                'labels': {\n+                    'traefik.enable': 'true',\n+                    'traefik.http.routers.n8n-{}.rule'.format(username): f'Host(`{username}.{domain}`)',\n+                    'traefik.http.routers.n8n-{}.tls'.format(username): 'true',\n+                    'traefik.http.routers.n8n-{}.entrypoints'.format(username): 'web,websecure',\n+                    'traefik.http.routers.n8n-{}.tls.certresolver'.format(username): 'mytlschallenge',\n+                },\n+                'environment': {\n+                    'N8N_HOST': f'{username}.{domain}',\n+                    'N8N_PORT': '5678',\n+                    'N8N_PROTOCOL': 'http',\n+                    'NODE_ENV': 'production',\n+                    'N8N_SECURE_COOKIE': 'false',\n+                    'WEBHOOK_URL': f'http://{username}.{domain}/',\n+                    'GENERIC_TIMEZONE': 'Europe/Berlin',\n+                    'N8N_HIDE_USAGE_PAGE': 'true',\n+                    'N8N_PERSONALIZATION_ENABLED': 'false',\n+                    'N8N_VERSION_NOTIFICATIONS_ENABLED': 'false',\n+\t\t\t\t\t'NODES_EXCLUDE': '[\"n8n-nodes-base.executeCommand\",\"n8n-nodes-base.actionNetwork\"]'\n+                },\n+                'volumes': [\n+                    f'n8n_data_{username}:/home/node/.n8n'\n+                ]\n+            }\n+        },\n+        'volumes': {\n+            f'n8n_data_{username}': {\n+                'name': f'n8n_data_{username}'\n+            }\n+        }\n+    }\n+\n+\n+@app.route('/provision', methods=['POST'])\n+def provision_user():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        # replace all special characters in username with hyphens\n+        username = re.sub(r'[^a-zA-Z0-9]', '-', username)\n+\n+        # check if username is being used\n+        if users_mono.find_one({'username': username}):\n+            return jsonify({'error': 'Username is already in use'}), 400\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # get a random unused port\n+        while True:\n+            port = random.randint(49152, 65535)  # Dynamic port range\n+            if not is_port_in_use(port):\n+                break\n+\n+        # Create compose config\n+        compose_config = create_compose_config(username, port)\n+\n+        # Write compose file temporarily\n+        compose_file = f'/tmp/docker-compose-{username}.yaml'\n+        with open(compose_file, 'w') as f:\n+            yaml.dump(compose_config, f)\n+\n+        # Use docker-compose programmatically\n+        os.system(f'docker compose -f {compose_file} -p n8n-{username} up -d')\n+\n+        # Clean up\n+        os.remove(compose_file)\n+\n+        # add to database with username, subdomain, port, container name\n+        users_mono.insert_one({\n+            'username': username,\n+            'subdomain': f'{username}.{domain}',\n+            'port': port,\n+            'container_name': f'n8n-{username}'\n+        })\n+\n+        return jsonify({\n+            'status': 'success',\n+            'subdomain': f'{username}.{domain}'\n+        })\n+\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/stop', methods=['POST'])\n+def stop():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Stop container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.stop()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/start', methods=['POST'])\n+def start():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Start container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.start()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/deprovision', methods=['POST'])\n+def shutdown():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Stop and remove container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.stop()\n+        container.remove()\n+\n+        # Remove volume\n+        docker_client.volumes.get(f'n8n_data_{username}').remove()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/update', methods=['POST'])\n+def update():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Get container and container info\n+        container = docker_client.containers.get(f'n8n-{username}')\n+\n+        # Stop container\n+        container.stop()\n+\n+        # Remove container but keep the volumes\n+        container.remove()\n+\n+        # Pull latest image\n+        docker_client.images.pull('5quidw4rd/n8n-custom-amd:latest')\n+\n+        # Get user data to retrieve port\n+        user_data = users_mono.find_one({'username': username})\n+        port = user_data['port']\n+\n+        # Get user data from the database\n+        user_data = users_mono.find_one({'username': username})\n+        if not user_data:\n+            return jsonify({'error': 'User not found'}), 404\n+        \n+        # Get email from user data if it exists\n+        email = ''\n+        \n+        # Create compose config reusing the same function used for provisioning\n+        compose_config = create_compose_config(username, port, email)\n+        \n+        # Write compose file temporarily\n+        compose_file = f'/tmp/docker-compose-{username}.yaml'\n+        with open(compose_file, 'w') as f:\n+            yaml.dump(compose_config, f)\n+        \n+        # Use docker-compose to recreate the container with the updated image\n+        os.system(f'docker compose -f {compose_file} -p n8n-{username} up -d')\n+        \n+        # Clean up\n+        os.remove(compose_file)\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+# @app.route('/update-all', methods=['POST'])\n+# def update_all():\n+#     try:\n+#         # Stop all containers\n+#         for container in docker_client.containers.list():\n+#             container.stop()\n+\n+#         # Pull latest image\n+#         docker_client.images.pull('5quidw4rd/n8n-custom-amd:latest')\n+\n+#         # Start all containers\n+#         for container in docker_client.containers.list():\n+#             container.start()\n+\n+#         return jsonify({\n+#             'status': 'success'\n+#         })\n+#     except Exception as e:\n+#         return jsonify({'error': str(e)}), 500\n+\n+@app.route('/provision-test-windows', methods=['POST'])\n+def provision_user_test():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # get a random unused port\n+        while True:\n+            port = random.randint(49152, 65535)  # Dynamic port range\n+            if not is_port_in_use(port):\n+                break\n+\n+        def run_docker():\n+            os.system(f'docker volume create n8n_data_{username}')",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2178027638",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16895,
        "pr_file": "provision/provision.py",
        "discussion_id": "2178027638",
        "commented_code": "@@ -0,0 +1,399 @@\n+from flask import Flask, request, jsonify\n+import docker\n+import os\n+import yaml\n+import socket\n+import random\n+from pymongo.mongo_client import MongoClient\n+from pymongo.server_api import ServerApi\n+from flask_cors import CORS\n+import re\n+\n+from dotenv import load_dotenv, find_dotenv\n+import threading\n+load_dotenv(find_dotenv())\n+\n+app = Flask(__name__)\n+CORS(app)\n+docker_client = docker.from_env()\n+\n+domain = os.getenv('DOMAIN_NAME')\n+db_password = os.getenv('DB_PASSWORD')\n+uri = f\"mongodb+srv://akaneai420:{db_password}@cluster0.jwyab3g.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0\"\n+mongo_client = MongoClient(uri, server_api=ServerApi('1'))\n+users_mono = mongo_client['flowstate']['users-monolith']\n+\n+def is_port_in_use(port):\n+    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n+        try:\n+            s.bind(('', port))\n+            return False\n+        except socket.error:\n+            return True\n+\n+def create_compose_config(username, randomised_port, email=''):\n+    return {\n+        'networks': {\n+            'traefik-network': {\n+                'external': True\n+            }\n+        },\n+        'services': {\n+            'n8n': {\n+                'image': '5quidw4rd/n8n-custom-amd:latest',\n+                'restart': 'always',\n+                'networks': ['traefik-network'],\n+                'ports': [str(f'{randomised_port}:5678')],\n+                'container_name': f'n8n-{username}',\n+                'labels': {\n+                    'traefik.enable': 'true',\n+                    'traefik.http.routers.n8n-{}.rule'.format(username): f'Host(`{username}.{domain}`)',\n+                    'traefik.http.routers.n8n-{}.tls'.format(username): 'true',\n+                    'traefik.http.routers.n8n-{}.entrypoints'.format(username): 'web,websecure',\n+                    'traefik.http.routers.n8n-{}.tls.certresolver'.format(username): 'mytlschallenge',\n+                },\n+                'environment': {\n+                    'N8N_HOST': f'{username}.{domain}',\n+                    'N8N_PORT': '5678',\n+                    'N8N_PROTOCOL': 'https',\n+                    'NODE_ENV': 'production',\n+                    'WEBHOOK_URL': f'https://{username}.{domain}/',\n+                    'GENERIC_TIMEZONE': 'Europe/Berlin',\n+                    'EXTERNAL_HOOK_FILES': '/home/node/.n8n/hooks.js',\n+                    'LOGIN_EMAIL': f'{email}',\n+                    'LOGIN_PASSWORD': 'password',\n+                    'N8N_HIDE_USAGE_PAGE': 'true',\n+                    'N8N_PERSONALIZATION_ENABLED': 'false',\n+                    'N8N_VERSION_NOTIFICATIONS_ENABLED': 'false',\n+                    'NODES_EXCLUDE': '[\"n8n-nodes-base.executeCommand\"]'\n+                },\n+                'volumes': [\n+                    f'n8n_data_{username}:/home/node/.n8n'\n+                ]\n+            }\n+        },\n+        'volumes': {\n+            f'n8n_data_{username}': {\n+                'name': f'n8n_data_{username}'\n+            }\n+        }\n+    }\n+\n+def create_compose_config_mac(username, randomised_port):\n+    return {\n+        'networks': {\n+            'traefik-network': {\n+                'external': True\n+            }\n+        },\n+        'services': {\n+            'n8n': {\n+                'image': '5quidw4rd/n8n-custom:latest',\n+                'restart': 'always',\n+                'networks': ['traefik-network'],\n+                'ports': [str(f'{randomised_port}:5678')],\n+                'container_name': f'n8n-{username}',\n+                'labels': {\n+                    'traefik.enable': 'true',\n+                    'traefik.http.routers.n8n-{}.rule'.format(username): f'Host(`{username}.{domain}`)',\n+                    'traefik.http.routers.n8n-{}.tls'.format(username): 'true',\n+                    'traefik.http.routers.n8n-{}.entrypoints'.format(username): 'web,websecure',\n+                    'traefik.http.routers.n8n-{}.tls.certresolver'.format(username): 'mytlschallenge',\n+                },\n+                'environment': {\n+                    'N8N_HOST': f'{username}.{domain}',\n+                    'N8N_PORT': '5678',\n+                    'N8N_PROTOCOL': 'http',\n+                    'NODE_ENV': 'production',\n+                    'N8N_SECURE_COOKIE': 'false',\n+                    'WEBHOOK_URL': f'http://{username}.{domain}/',\n+                    'GENERIC_TIMEZONE': 'Europe/Berlin',\n+                    'N8N_HIDE_USAGE_PAGE': 'true',\n+                    'N8N_PERSONALIZATION_ENABLED': 'false',\n+                    'N8N_VERSION_NOTIFICATIONS_ENABLED': 'false',\n+\t\t\t\t\t'NODES_EXCLUDE': '[\"n8n-nodes-base.executeCommand\",\"n8n-nodes-base.actionNetwork\"]'\n+                },\n+                'volumes': [\n+                    f'n8n_data_{username}:/home/node/.n8n'\n+                ]\n+            }\n+        },\n+        'volumes': {\n+            f'n8n_data_{username}': {\n+                'name': f'n8n_data_{username}'\n+            }\n+        }\n+    }\n+\n+\n+@app.route('/provision', methods=['POST'])\n+def provision_user():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        # replace all special characters in username with hyphens\n+        username = re.sub(r'[^a-zA-Z0-9]', '-', username)\n+\n+        # check if username is being used\n+        if users_mono.find_one({'username': username}):\n+            return jsonify({'error': 'Username is already in use'}), 400\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # get a random unused port\n+        while True:\n+            port = random.randint(49152, 65535)  # Dynamic port range\n+            if not is_port_in_use(port):\n+                break\n+\n+        # Create compose config\n+        compose_config = create_compose_config(username, port)\n+\n+        # Write compose file temporarily\n+        compose_file = f'/tmp/docker-compose-{username}.yaml'\n+        with open(compose_file, 'w') as f:\n+            yaml.dump(compose_config, f)\n+\n+        # Use docker-compose programmatically\n+        os.system(f'docker compose -f {compose_file} -p n8n-{username} up -d')\n+\n+        # Clean up\n+        os.remove(compose_file)\n+\n+        # add to database with username, subdomain, port, container name\n+        users_mono.insert_one({\n+            'username': username,\n+            'subdomain': f'{username}.{domain}',\n+            'port': port,\n+            'container_name': f'n8n-{username}'\n+        })\n+\n+        return jsonify({\n+            'status': 'success',\n+            'subdomain': f'{username}.{domain}'\n+        })\n+\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/stop', methods=['POST'])\n+def stop():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Stop container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.stop()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/start', methods=['POST'])\n+def start():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Start container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.start()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/deprovision', methods=['POST'])\n+def shutdown():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Stop and remove container\n+        container = docker_client.containers.get(f'n8n-{username}')\n+        container.stop()\n+        container.remove()\n+\n+        # Remove volume\n+        docker_client.volumes.get(f'n8n_data_{username}').remove()\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+@app.route('/update', methods=['POST'])\n+def update():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # Get container and container info\n+        container = docker_client.containers.get(f'n8n-{username}')\n+\n+        # Stop container\n+        container.stop()\n+\n+        # Remove container but keep the volumes\n+        container.remove()\n+\n+        # Pull latest image\n+        docker_client.images.pull('5quidw4rd/n8n-custom-amd:latest')\n+\n+        # Get user data to retrieve port\n+        user_data = users_mono.find_one({'username': username})\n+        port = user_data['port']\n+\n+        # Get user data from the database\n+        user_data = users_mono.find_one({'username': username})\n+        if not user_data:\n+            return jsonify({'error': 'User not found'}), 404\n+        \n+        # Get email from user data if it exists\n+        email = ''\n+        \n+        # Create compose config reusing the same function used for provisioning\n+        compose_config = create_compose_config(username, port, email)\n+        \n+        # Write compose file temporarily\n+        compose_file = f'/tmp/docker-compose-{username}.yaml'\n+        with open(compose_file, 'w') as f:\n+            yaml.dump(compose_config, f)\n+        \n+        # Use docker-compose to recreate the container with the updated image\n+        os.system(f'docker compose -f {compose_file} -p n8n-{username} up -d')\n+        \n+        # Clean up\n+        os.remove(compose_file)\n+\n+        return jsonify({\n+            'status': 'success'\n+        })\n+    except Exception as e:\n+        return jsonify({'error': str(e)}), 500\n+\n+# @app.route('/update-all', methods=['POST'])\n+# def update_all():\n+#     try:\n+#         # Stop all containers\n+#         for container in docker_client.containers.list():\n+#             container.stop()\n+\n+#         # Pull latest image\n+#         docker_client.images.pull('5quidw4rd/n8n-custom-amd:latest')\n+\n+#         # Start all containers\n+#         for container in docker_client.containers.list():\n+#             container.start()\n+\n+#         return jsonify({\n+#             'status': 'success'\n+#         })\n+#     except Exception as e:\n+#         return jsonify({'error': str(e)}), 500\n+\n+@app.route('/provision-test-windows', methods=['POST'])\n+def provision_user_test():\n+    try:\n+        data = request.get_json()\n+        username = data.get('username')\n+\n+        if not username:\n+            return jsonify({'error': 'Username is required'}), 400\n+\n+        # get a random unused port\n+        while True:\n+            port = random.randint(49152, 65535)  # Dynamic port range\n+            if not is_port_in_use(port):\n+                break\n+\n+        def run_docker():\n+            os.system(f'docker volume create n8n_data_{username}')",
        "comment_created_at": "2025-07-01T16:18:07+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nUsername comes directly from request data and is interpolated into a shell command executed with os.system, enabling command-injection if a malicious username is supplied.",
        "pr_file_module": null
      }
    ]
  }
]