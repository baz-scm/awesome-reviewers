[
  {
    "discussion_id": "2221553317",
    "pr_number": 17404,
    "pr_file": "packages/cli/src/evaluation.ee/test-runner/test-runner.service.ee.ts",
    "created_at": "2025-07-22T07:48:43+00:00",
    "commented_code": "/**\n \t * Get the evaluation set metrics nodes from a workflow.\n \t */\n-\tstatic getEvaluationMetricsNodes(workflow: IWorkflowBase) {\n+\tstatic getEvaluationNodes(\n+\t\tworkflow: IWorkflowBase,\n+\t\toperation: string,",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2221553317",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17404,
        "pr_file": "packages/cli/src/evaluation.ee/test-runner/test-runner.service.ee.ts",
        "discussion_id": "2221553317",
        "commented_code": "@@ -360,21 +362,32 @@ export class TestRunnerService {\n \t/**\n \t * Get the evaluation set metrics nodes from a workflow.\n \t */\n-\tstatic getEvaluationMetricsNodes(workflow: IWorkflowBase) {\n+\tstatic getEvaluationNodes(\n+\t\tworkflow: IWorkflowBase,\n+\t\toperation: string,",
        "comment_created_at": "2025-07-22T07:48:43+00:00",
        "comment_author": "ivov",
        "comment_body": "Any string? We don't know the operation names in advance?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179938328",
    "pr_number": 12546,
    "pr_file": "packages/cli/src/chat/chat-service.ts",
    "created_at": "2025-07-02T12:33:57+00:00",
    "commented_code": "+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2179938328",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 12546,
        "pr_file": "packages/cli/src/chat/chat-service.ts",
        "discussion_id": "2179938328",
        "commented_code": "@@ -0,0 +1,298 @@\n+import { Logger } from '@n8n/backend-common';\n+import { Service } from '@n8n/di';\n+import { jsonParse, UnexpectedError } from 'n8n-workflow';\n+import { type RawData, WebSocket } from 'ws';\n+\n+import { ChatExecutionManager } from './chat-execution-manager';\n+import type { ChatMessage, ChatRequest, Session } from './chat-service.types';\n+import {\n+\tgetLastNodeExecuted,\n+\tgetMessage,\n+\tisResponseNodeMode,\n+\tprepareMessageFromLastNode,\n+\tshouldResumeImmediately,\n+} from './utils';\n+\n+const CHECK_FOR_RESPONSE_INTERVAL = 3000;\n+const DRAIN_TIMEOUT = 50;\n+const HEARTBEAT_INTERVAL = 30 * 1000;\n+const HEARTBEAT_TIMEOUT = 60 * 1000;\n+\n+function closeConnection(ws: WebSocket) {\n+\tif (ws.readyState !== WebSocket.OPEN) return;\n+\n+\tws.once('drain', () => {\n+\t\tws.close();\n+\t});\n+\n+\tsetTimeout(() => {\n+\t\tif (ws.readyState === WebSocket.OPEN) {\n+\t\t\tws.close();\n+\t\t}\n+\t}, DRAIN_TIMEOUT);\n+}\n+\n+@Service()\n+export class ChatService {\n+\tprivate readonly sessions = new Map<string, Session>();\n+\n+\tconstructor(\n+\t\tprivate readonly executionManager: ChatExecutionManager,\n+\t\tprivate readonly logger: Logger,\n+\t) {\n+\t\tsetInterval(async () => await this.checkHeartbeats(), HEARTBEAT_INTERVAL);\n+\t}\n+\n+\tasync startSession(req: ChatRequest) {\n+\t\tconst {\n+\t\t\tws,\n+\t\t\tquery: { sessionId, executionId, isPublic },\n+\t\t} = req;\n+\n+\t\tif (!ws) {\n+\t\t\tthrow new UnexpectedError('WebSocket connection is missing');\n+\t\t}\n+\n+\t\tif (!sessionId || !executionId) {\n+\t\t\tconst parameter = sessionId ? 'executionId' : 'sessionId';\n+\t\t\tws.send(`The query parameter \"${parameter}\" is missing`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution) {\n+\t\t\tws.send(`Execution with id \"${executionId}\" does not exist`);\n+\t\t\tws.close(1008);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tws.isAlive = true;\n+\n+\t\tconst key = `${sessionId}|${executionId}|${isPublic ? 'public' : 'integrated'}`;\n+\n+\t\tif (this.sessions.has(key)) {\n+\t\t\tthis.sessions.get(key)?.connection.terminate();\n+\t\t\tclearInterval(this.sessions.get(key)?.intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t}\n+\n+\t\tconst onMessage = this.incomingMessageHandler(key);\n+\t\tconst respondToChat = this.outgoingMessageHandler(key);\n+\n+\t\tconst intervalId = setInterval(async () => await respondToChat(), CHECK_FOR_RESPONSE_INTERVAL);\n+\n+\t\tws.once('close', async () => {\n+\t\t\tws.off('message', onMessage);\n+\t\t\tclearInterval(intervalId);\n+\t\t\tthis.sessions.delete(key);\n+\t\t});\n+\n+\t\tws.on('message', onMessage);\n+\n+\t\tconst session: Session = {\n+\t\t\tconnection: ws,\n+\t\t\texecutionId,\n+\t\t\tsessionId,\n+\t\t\tintervalId,\n+\t\t\tisPublic,\n+\t\t\tlastHeartbeat: Date.now(),\n+\t\t};\n+\n+\t\tthis.sessions.set(key, session);\n+\n+\t\tws.send('n8n|heartbeat');\n+\t}\n+\n+\tprivate outgoingMessageHandler(sessionKey: string) {\n+\t\treturn async () => {\n+\t\t\tlet session: Session | undefined;\n+\t\t\ttry {\n+\t\t\t\tsession = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\t\t\t\tif (session.isProcessing) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tsession.isProcessing = true;\n+\n+\t\t\t\tconst { connection, executionId, sessionId, waitingNodeName, isPublic } = session;\n+\n+\t\t\t\tif (!executionId || !connection) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\n+\t\t\t\tif (!execution) {\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (waitingNodeName) {\n+\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\tif (execution.status === 'waiting' && lastNode?.name !== waitingNodeName) {\n+\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t}\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'waiting') {\n+\t\t\t\t\tconst message = getMessage(execution);\n+\n+\t\t\t\t\tif (message !== undefined) {\n+\t\t\t\t\t\tconnection.send(message);\n+\n+\t\t\t\t\t\tconst lastNode = getLastNodeExecuted(execution);\n+\n+\t\t\t\t\t\tif (lastNode && shouldResumeImmediately(lastNode)) {\n+\t\t\t\t\t\t\tconnection.send('n8n|continue');\n+\t\t\t\t\t\t\tconst data = { action: 'user', chatInput: '', sessionId };\n+\t\t\t\t\t\t\tawait this.resumeExecution(executionId, data, sessionKey);\n+\t\t\t\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tsession.waitingNodeName = lastNode?.name;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tif (execution.status === 'success') {\n+\t\t\t\t\tconst shouldNotReturnLastNodeResponse =\n+\t\t\t\t\t\t!isPublic || (isPublic && isResponseNodeMode(execution));\n+\n+\t\t\t\t\tif (shouldNotReturnLastNodeResponse) {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst textMessage = prepareMessageFromLastNode(execution);\n+\n+\t\t\t\t\tconnection.send(textMessage, () => {\n+\t\t\t\t\t\tcloseConnection(connection);\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tsession.isProcessing = false;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tsession.isProcessing = false;\n+\t\t\t} catch (error) {\n+\t\t\t\tif (session) session.isProcessing = false;\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error sending message to chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate incomingMessageHandler(sessionKey: string) {\n+\t\treturn async (data: RawData) => {\n+\t\t\ttry {\n+\t\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\t\tif (!session) return;\n+\n+\t\t\t\tconst message = data.toString();\n+\n+\t\t\t\tif (message === 'n8n|heartbeat-ack') {\n+\t\t\t\t\tsession.lastHeartbeat = Date.now();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n+\t\t\t\tconst executionId = session.executionId;\n+\n+\t\t\t\tawait this.resumeExecution(executionId, this.processIncomingData(data), sessionKey);\n+\t\t\t\tsession.waitingNodeName = undefined;\n+\t\t\t} catch (error) {\n+\t\t\t\tthis.logger.error(\n+\t\t\t\t\t`Error processing message from chat in session ${sessionKey}: ${(error as Error).message}`,\n+\t\t\t\t);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate async resumeExecution(executionId: string, message: ChatMessage, sessionKey: string) {\n+\t\tconst execution = await this.getExecution(executionId, sessionKey);\n+\t\tif (!execution) return;\n+\t\tawait this.executionManager.runWorkflow(execution, message);\n+\t}\n+\n+\tprivate async getExecution(executionId: string, sessionKey: string) {\n+\t\tconst execution = await this.executionManager.findExecution(executionId);\n+\n+\t\tif (!execution || ['error', 'canceled', 'crashed'].includes(execution.status)) {\n+\t\t\tconst session = this.sessions.get(sessionKey);\n+\n+\t\t\tif (!session) return null;\n+\n+\t\t\tsession.connection.terminate();\n+\t\t\tclearInterval(session.intervalId);\n+\t\t\tthis.sessions.delete(sessionKey);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tif (execution.status === 'running') return null;\n+\n+\t\treturn execution;\n+\t}\n+\n+\tprivate processIncomingData(data: RawData) {\n+\t\tconst buffer = Array.isArray(data)\n+\t\t\t? Buffer.concat(data.map((chunk) => Buffer.from(chunk)))\n+\t\t\t: Buffer.from(data);\n+\n+\t\tconst message = jsonParse<ChatMessage>(buffer.toString('utf8'));",
        "comment_created_at": "2025-07-02T12:33:57+00:00",
        "comment_author": "tomi",
        "comment_body": "We should define a zod schema for the incoming messages and parse them, to ensure we accept only expected messages",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215780810",
    "pr_number": 17121,
    "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/actions/prompt/improve.operation.ts",
    "created_at": "2025-07-18T11:11:53+00:00",
    "commented_code": "+import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n+import { updateDisplayOptions } from 'n8n-workflow';\n+\n+import type { Message, PromptResponse } from '../../helpers/interfaces';\n+import { apiRequest } from '../../transport';\n+\n+const properties: INodeProperties[] = [\n+\t{\n+\t\tdisplayName: 'Messages',\n+\t\tname: 'messages',\n+\t\ttype: 'fixedCollection',\n+\t\ttypeOptions: {\n+\t\t\tsortable: true,\n+\t\t\tmultipleValues: true,\n+\t\t},\n+\t\tdescription: 'Messages that constitute the prompt to be improved',\n+\t\tplaceholder: 'Add Message',\n+\t\tdefault: { values: [{ content: '' }] },\n+\t\toptions: [\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Values',\n+\t\t\t\tname: 'values',\n+\t\t\t\tvalues: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tdisplayName: 'Prompt',\n+\t\t\t\t\t\tname: 'content',\n+\t\t\t\t\t\ttype: 'string',\n+\t\t\t\t\t\tdescription: 'The content of the message to be sent',\n+\t\t\t\t\t\tdefault: '',\n+\t\t\t\t\t\tplaceholder: 'e.g. Concise instructions for a meal prep service',\n+\t\t\t\t\t\ttypeOptions: {\n+\t\t\t\t\t\t\trows: 2,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tdisplayName: 'Role',\n+\t\t\t\t\t\tname: 'role',\n+\t\t\t\t\t\ttype: 'options',\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Role in shaping the model's response, it tells the model how it should behave and interact with the user\",\n+\t\t\t\t\t\toptions: [\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tname: 'User',\n+\t\t\t\t\t\t\t\tvalue: 'user',\n+\t\t\t\t\t\t\t\tdescription: 'Send a message as a user and get a response from the model',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tname: 'Assistant',\n+\t\t\t\t\t\t\t\tvalue: 'assistant',\n+\t\t\t\t\t\t\t\tdescription: 'Tell the model to adopt a specific tone or personality',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t],\n+\t\t\t\t\t\tdefault: 'user',\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t],\n+\t},\n+\t{\n+\t\tdisplayName: 'Simplify Output',\n+\t\tname: 'simplify',\n+\t\ttype: 'boolean',\n+\t\tdefault: true,\n+\t\tdescription: 'Whether to return a simplified version of the response instead of the raw data',\n+\t},\n+\t{\n+\t\tdisplayName: 'Options',\n+\t\tname: 'options',\n+\t\tplaceholder: 'Add Option',\n+\t\ttype: 'collection',\n+\t\tdefault: {},\n+\t\toptions: [\n+\t\t\t{\n+\t\t\t\tdisplayName: 'System Message',\n+\t\t\t\tname: 'system',\n+\t\t\t\ttype: 'string',\n+\t\t\t\tdescription: 'The existing system prompt to incorporate, if any',\n+\t\t\t\tdefault: '',\n+\t\t\t\tplaceholder: 'e.g. You are a professional meal prep chef',\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Feedback',\n+\t\t\t\tname: 'feedback',\n+\t\t\t\ttype: 'string',\n+\t\t\t\tdescription: 'Feedback for improving the prompt',\n+\t\t\t\tdefault: '',\n+\t\t\t\tplaceholder: 'e.g. Make it more detailed and include cooking times',\n+\t\t\t},\n+\t\t],\n+\t},\n+];\n+\n+const displayOptions = {\n+\tshow: {\n+\t\toperation: ['improve'],\n+\t\tresource: ['prompt'],\n+\t},\n+};\n+\n+export const description = updateDisplayOptions(displayOptions, properties);\n+\n+export async function execute(this: IExecuteFunctions, i: number): Promise<INodeExecutionData[]> {\n+\tconst messages = this.getNodeParameter('messages.values', i, []) as Message[];\n+\tconst simplify = this.getNodeParameter('simplify', i, true) as boolean;\n+\tconst options = this.getNodeParameter('options', i, {});\n+\n+\tconst body = {",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2215878523",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17121,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/vendors/Anthropic/actions/prompt/improve.operation.ts",
        "discussion_id": "2215780810",
        "commented_code": "@@ -0,0 +1,135 @@\n+import type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\n+import { updateDisplayOptions } from 'n8n-workflow';\n+\n+import type { Message, PromptResponse } from '../../helpers/interfaces';\n+import { apiRequest } from '../../transport';\n+\n+const properties: INodeProperties[] = [\n+\t{\n+\t\tdisplayName: 'Messages',\n+\t\tname: 'messages',\n+\t\ttype: 'fixedCollection',\n+\t\ttypeOptions: {\n+\t\t\tsortable: true,\n+\t\t\tmultipleValues: true,\n+\t\t},\n+\t\tdescription: 'Messages that constitute the prompt to be improved',\n+\t\tplaceholder: 'Add Message',\n+\t\tdefault: { values: [{ content: '' }] },\n+\t\toptions: [\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Values',\n+\t\t\t\tname: 'values',\n+\t\t\t\tvalues: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tdisplayName: 'Prompt',\n+\t\t\t\t\t\tname: 'content',\n+\t\t\t\t\t\ttype: 'string',\n+\t\t\t\t\t\tdescription: 'The content of the message to be sent',\n+\t\t\t\t\t\tdefault: '',\n+\t\t\t\t\t\tplaceholder: 'e.g. Concise instructions for a meal prep service',\n+\t\t\t\t\t\ttypeOptions: {\n+\t\t\t\t\t\t\trows: 2,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tdisplayName: 'Role',\n+\t\t\t\t\t\tname: 'role',\n+\t\t\t\t\t\ttype: 'options',\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Role in shaping the model's response, it tells the model how it should behave and interact with the user\",\n+\t\t\t\t\t\toptions: [\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tname: 'User',\n+\t\t\t\t\t\t\t\tvalue: 'user',\n+\t\t\t\t\t\t\t\tdescription: 'Send a message as a user and get a response from the model',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tname: 'Assistant',\n+\t\t\t\t\t\t\t\tvalue: 'assistant',\n+\t\t\t\t\t\t\t\tdescription: 'Tell the model to adopt a specific tone or personality',\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t],\n+\t\t\t\t\t\tdefault: 'user',\n+\t\t\t\t\t},\n+\t\t\t\t],\n+\t\t\t},\n+\t\t],\n+\t},\n+\t{\n+\t\tdisplayName: 'Simplify Output',\n+\t\tname: 'simplify',\n+\t\ttype: 'boolean',\n+\t\tdefault: true,\n+\t\tdescription: 'Whether to return a simplified version of the response instead of the raw data',\n+\t},\n+\t{\n+\t\tdisplayName: 'Options',\n+\t\tname: 'options',\n+\t\tplaceholder: 'Add Option',\n+\t\ttype: 'collection',\n+\t\tdefault: {},\n+\t\toptions: [\n+\t\t\t{\n+\t\t\t\tdisplayName: 'System Message',\n+\t\t\t\tname: 'system',\n+\t\t\t\ttype: 'string',\n+\t\t\t\tdescription: 'The existing system prompt to incorporate, if any',\n+\t\t\t\tdefault: '',\n+\t\t\t\tplaceholder: 'e.g. You are a professional meal prep chef',\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Feedback',\n+\t\t\t\tname: 'feedback',\n+\t\t\t\ttype: 'string',\n+\t\t\t\tdescription: 'Feedback for improving the prompt',\n+\t\t\t\tdefault: '',\n+\t\t\t\tplaceholder: 'e.g. Make it more detailed and include cooking times',\n+\t\t\t},\n+\t\t],\n+\t},\n+];\n+\n+const displayOptions = {\n+\tshow: {\n+\t\toperation: ['improve'],\n+\t\tresource: ['prompt'],\n+\t},\n+};\n+\n+export const description = updateDisplayOptions(displayOptions, properties);\n+\n+export async function execute(this: IExecuteFunctions, i: number): Promise<INodeExecutionData[]> {\n+\tconst messages = this.getNodeParameter('messages.values', i, []) as Message[];\n+\tconst simplify = this.getNodeParameter('simplify', i, true) as boolean;\n+\tconst options = this.getNodeParameter('options', i, {});\n+\n+\tconst body = {",
        "comment_created_at": "2025-07-18T12:01:09+00:00",
        "comment_author": "RomanDavydchuk",
        "comment_body": "`system` and `feedback` are not required, according to Anthropic's API docs",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205262631",
    "pr_number": 17306,
    "pr_file": "packages/nodes-base/nodes/Mattermost/v1/actions/message/post/description.ts",
    "created_at": "2025-07-14T15:49:45+00:00",
    "commented_code": "placeholder: 'Add option',\n \t\toptions: [\n \t\t\t{\n-\t\t\t\tdisplayName: 'Make Comment',\n+\t\t\t\tdisplayName: 'Root Post ID',",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2205262631",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17306,
        "pr_file": "packages/nodes-base/nodes/Mattermost/v1/actions/message/post/description.ts",
        "discussion_id": "2205262631",
        "commented_code": "@@ -370,11 +370,12 @@ export const messagePostDescription: MessageProperties = [\n \t\tplaceholder: 'Add option',\n \t\toptions: [\n \t\t\t{\n-\t\t\t\tdisplayName: 'Make Comment',\n+\t\t\t\tdisplayName: 'Root Post ID',",
        "comment_created_at": "2025-07-14T15:49:45+00:00",
        "comment_author": "Joffcom",
        "comment_body": "Would Parent Post ID be a clearer display name?",
        "pr_file_module": null
      },
      {
        "comment_id": "2216032363",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17306,
        "pr_file": "packages/nodes-base/nodes/Mattermost/v1/actions/message/post/description.ts",
        "discussion_id": "2205262631",
        "commented_code": "@@ -370,11 +370,12 @@ export const messagePostDescription: MessageProperties = [\n \t\tplaceholder: 'Add option',\n \t\toptions: [\n \t\t\t{\n-\t\t\t\tdisplayName: 'Make Comment',\n+\t\t\t\tdisplayName: 'Root Post ID',",
        "comment_created_at": "2025-07-18T13:20:23+00:00",
        "comment_author": "nickmisasi",
        "comment_body": "I worry that \"parent\" could be misconstrued as \"the one before\". In the context of this API this parameter must be the _first_ post in the thread. For ex: A -> B -> C, when posting D, to attach to that thread it must pass A, it cannot pass C. I think the benefit of using the word \"root\" is that its basically a 1:1 map to [the post GET API body](https://developers.mattermost.com/api-documentation/#/operations/GetPost%23response-body)",
        "pr_file_module": null
      },
      {
        "comment_id": "2216072105",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 17306,
        "pr_file": "packages/nodes-base/nodes/Mattermost/v1/actions/message/post/description.ts",
        "discussion_id": "2205262631",
        "commented_code": "@@ -370,11 +370,12 @@ export const messagePostDescription: MessageProperties = [\n \t\tplaceholder: 'Add option',\n \t\toptions: [\n \t\t\t{\n-\t\t\t\tdisplayName: 'Make Comment',\n+\t\t\t\tdisplayName: 'Root Post ID',",
        "comment_created_at": "2025-07-18T13:39:18+00:00",
        "comment_author": "Joffcom",
        "comment_body": "I have never thought of parent as the one before but more the top level to post under.\n\nIt is only a display value I guess so we can go with root and if it needs to be changed it won't take much effort to do ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160114468",
    "pr_number": 16406,
    "pr_file": "packages/@n8n/nodes-langchain/nodes/mcp/McpClientTool/McpClientTool.node.ts",
    "created_at": "2025-06-21T18:37:54+00:00",
    "commented_code": "properties: [\n \t\t\tgetConnectionHintNoticeField([NodeConnectionTypes.AiAgent]),\n \t\t\t{\n-\t\t\t\tdisplayName: 'SSE Endpoint',\n-\t\t\t\tname: 'sseEndpoint',\n+\t\t\t\tdisplayName: 'Endpoint',\n+\t\t\t\tname: 'endpointUrl',\n \t\t\t\ttype: 'string',\n-\t\t\t\tdescription: 'SSE Endpoint of your MCP server',\n-\t\t\t\tplaceholder: 'e.g. https://my-mcp-server.ai/sse',\n+\t\t\t\tdescription: 'Endpoint of your MCP server',\n+\t\t\t\tplaceholder: 'e.g. https://my-mcp-server.ai/mcp',\n \t\t\t\tdefault: '',\n \t\t\t\trequired: true,\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Server Transport',\n+\t\t\t\tname: 'serverTransport',\n+\t\t\t\ttype: 'options',\n+\t\t\t\toptions: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname: 'Server Sent Events (Deprecated)',\n+\t\t\t\t\t\tvalue: 'sse',\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname: 'HTTP Streamable',\n+\t\t\t\t\t\tvalue: 'httpStreamable',",
    "repo_full_name": "n8n-io/n8n",
    "discussion_comments": [
      {
        "comment_id": "2160114468",
        "repo_full_name": "n8n-io/n8n",
        "pr_number": 16406,
        "pr_file": "packages/@n8n/nodes-langchain/nodes/mcp/McpClientTool/McpClientTool.node.ts",
        "discussion_id": "2160114468",
        "commented_code": "@@ -76,14 +76,31 @@ export class McpClientTool implements INodeType {\n \t\tproperties: [\n \t\t\tgetConnectionHintNoticeField([NodeConnectionTypes.AiAgent]),\n \t\t\t{\n-\t\t\t\tdisplayName: 'SSE Endpoint',\n-\t\t\t\tname: 'sseEndpoint',\n+\t\t\t\tdisplayName: 'Endpoint',\n+\t\t\t\tname: 'endpointUrl',\n \t\t\t\ttype: 'string',\n-\t\t\t\tdescription: 'SSE Endpoint of your MCP server',\n-\t\t\t\tplaceholder: 'e.g. https://my-mcp-server.ai/sse',\n+\t\t\t\tdescription: 'Endpoint of your MCP server',\n+\t\t\t\tplaceholder: 'e.g. https://my-mcp-server.ai/mcp',\n \t\t\t\tdefault: '',\n \t\t\t\trequired: true,\n \t\t\t},\n+\t\t\t{\n+\t\t\t\tdisplayName: 'Server Transport',\n+\t\t\t\tname: 'serverTransport',\n+\t\t\t\ttype: 'options',\n+\t\t\t\toptions: [\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname: 'Server Sent Events (Deprecated)',\n+\t\t\t\t\t\tvalue: 'sse',\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tname: 'HTTP Streamable',\n+\t\t\t\t\t\tvalue: 'httpStreamable',",
        "comment_created_at": "2025-06-21T18:37:54+00:00",
        "comment_author": "GuillermoGaete",
        "comment_body": "```suggestion\r\n\t\t\t\t\t\tname: 'Streamable HTTP',\r\n\t\t\t\t\t\tvalue: 'streamableHTTP',\r\n```\r\nAs referred here: https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#streamable-http",
        "pr_file_module": null
      }
    ]
  }
]