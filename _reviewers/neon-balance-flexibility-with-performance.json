[
  {
    "discussion_id": "2075424411",
    "pr_number": 11815,
    "pr_file": "pageserver/page_api/proto/page_service.proto",
    "created_at": "2025-05-06T12:58:30+00:00",
    "commented_code": "+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2075424411",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075424411",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.",
        "comment_created_at": "2025-05-06T12:58:30+00:00",
        "comment_author": "hlinnaka",
        "comment_body": "Yes, I believe 'not_modified_since' is meaningful for all request types. Probably much less performance critical for others, and I'm not sure if the compute has the tracking needed to provide a value that's any better than 'not_modified_since_lsn == request_lsn' for other requests, but in principle the same concept is valid for all request types.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075487619",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075424411",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.",
        "comment_created_at": "2025-05-06T13:31:21+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Ack, let's keep it then. Doesn't cost us anything, and it should just work.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2075459279",
    "pr_number": 11815,
    "pr_file": "pageserver/page_api/proto/page_service.proto",
    "created_at": "2025-05-06T13:17:21+00:00",
    "commented_code": "+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2075459279",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-06T13:17:21+00:00",
        "comment_author": "hlinnaka",
        "comment_body": "Some thoughts on this batching API, thinking about how it will be used by the compute. \r\n\r\nFor background, the Postgres function that will initiate batched requests is [smgrreadv()](https://github.com/postgres/postgres/blob/5e2f3df49d4298c6097789364a5a53be172f6e85/src/backend/storage/smgr/smgr.c#L600). It's a synchronous call that reads N contiguous pages from a relation. In vanilla Postgres, it is implemented with the libc [preadv(2)](https://linux.die.net/man/2/preadv) function.\r\n\r\nThis batching interface is much more flexible. It supports reading non-contiguous pages, from different relations, with different classes. I don't think we need that flexibility. Maybe it doesn't hurt either, but since the batching exists for performance, I think it's best to limit the freedom. It might allow skipping some overhead.\r\n\r\nReturning the responses individually means that Postgres will need to reassemble the responses again, to pass back one result for the smgrreadv() call. That adds a little complexity on the client.\r\n\r\nSo my suggestion is to model the batched requests after smgrreadv() / preadv(): Require the batch to be a contiguous range of pages, and treat it as a single request, with a single class and request ID and a single response.",
        "pr_file_module": null
      },
      {
        "comment_id": "2075548612",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-06T14:00:26+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Ack, I'm sympathetic to that. This API is modeled more after the Pageserver's current capabilities than the compute's needs (see e.g. [`get_vectored`](https://github.com/neondatabase/neon/blob/cbf442292b44decf7ab7fff77658d81c51b2c93f/pageserver/src/tenant/timeline.rs#L1182-L1191) and [`get_rel_page_at_lsn_batched`](https://github.com/neondatabase/neon/blob/c1ff7db1874c6b5ff8ee134b944f1c54616ba37b/pageserver/src/pgdatadir_mapping.rs#L244-L252)). If the compute is only ever going to request contiguous page chunks at the same LSN then we can probably lean into that for optimization.\r\n\r\nHowever, this assumes that the compute can't make forward progress until the entire batch has been received. I'm not sure that's always true.\r\n\r\nLet's consider an extreme case, for illustration: we send a batch request for pages 0-100, and at page 50 we have to download a layer which takes 3 seconds. I think there are cases where it's advantageous to send back pages 0-49 first, and pages 50-100 later:\r\n\r\n* A different backend may request a single page 20, and block on the batch request.\r\n* Similarly, if the batch was a prefetch, we could eagerly populate the LFC with pages 0-49 before anyone requests them.\r\n\r\nHowever, this depends on where readers would get blocked. If the initial batch request holds a Postgres lock for the pages, then we can't unblock the waiters until we serve the entire initial batch request.\r\n\r\nAs for the response, we can return at most 4 MB in a response, but that's 512 pages and likely fine as an upper bound. It would require a bit more memory to first buffer the entire batch and then send it, instead of just streaming them, so we could consider doing in-order streams instead. But maybe it's more efficient to just dump it into a large contiguous array too and just throw it over to Postgres ~directly.\r\n\r\ncc @VladLazar @problame since you probably have opinions here too.",
        "pr_file_module": null
      },
      {
        "comment_id": "2077191660",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-07T09:13:17+00:00",
        "comment_author": "VladLazar",
        "comment_body": "> Let's consider an extreme case, for illustration: we send a batch request for pages 0-100, and at page 50 we have to download a layer which takes 3 seconds. I think there are cases where it's advantageous to send back pages 0-49 first, and pages 50-100 later:\r\n\r\nOn streaming: the pageserver doesn't currently support streaming. The current implementation collects all the deltas and images for _all_ keys in the batch and then does walredo for all keys concurrently. We could do true streaming, but it's not trivial.\r\n\r\nOn how scattered the reads should be: hard to tell. Generally speaking, the more clustered the pages in a request are, the more predictable performance will be:\r\n* in-memory layers are ingest ordered: clustering by key doesn't help much here\r\n* delta layers are ordered by (key, lsn): clustering by key helps with index reads, but for the reads themselves our ability to merge depends on how many key versions we have\r\n* in-memory layers are ordered by key: clustering keys clearly helps here\r\n\r\nOverall take:\r\n* I'm not sure streaming responses makes sense at this stage. We currently support a max of 32 keys in a batch (PS side). We could increase it, but I don't think we should go above 512 pages short term. I'd just return all the pages at once. Streaming protocol can be done in the future, but I see there's other reasons quoted for streaming.\r\n* I think it makes sense to keep the grpc spec somewhat flexible here. The implementation can enforce strict batching rules or implement heuristics based on key, lsn range.",
        "pr_file_module": null
      },
      {
        "comment_id": "2077260968",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-07T09:49:50+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "> the pageserver doesn't currently support streaming. The current implementation collects all the deltas and images for all keys in the batch and then does walredo for all keys concurrently. We could do true streaming, but it's not trivial.\r\n\r\nYeah, but Christian wanted to leave the protocol open to send eager out-of-order responses, since it gives us more flexibility in how we optimize reads down the road.\r\n\r\nThis also has implications for how we design the request scheduler and locking in the communicator. If we bake in an assumption that we'll always get complete batches back, it may not be easy to back out of that later if we find that it causes too much contention and tail latency.\r\n\r\nSo I would like us to take a stance now on whether eager partial responses is something we should design for.\r\n\r\n> On how scattered the reads should be: hard to tell. Generally speaking, the more clustered the pages in a request are, the more predictable performance will be\r\n\r\nI think the more important point here is that when we do the batching client-side, we _know_ whether it makes sense to batch or not (i.e. whether to prioritize throughput or latency) -- Postgres will tell us via `smgrreadv`. And if Postgres asks us to batch, it will always batch as contiguous chunks, at the same LSN.\r\n\r\nI think I'm leaning towards changing `GetPageRequest` to take a `block_count` parameter specifying the number of contiguous pages to read, but keep the streaming responses to keep the door open to eager partial responses. But it depends on how the request scheduler design ends up -- if we don't leverage it there, then we may as well just return a full batch.",
        "pr_file_module": null
      },
      {
        "comment_id": "2077404247",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-07T11:20:21+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "> I think I'm leaning towards changing `GetPageRequest` to take a `block_count` parameter specifying the number of contiguous pages to read, but keep the streaming responses to keep the door open to eager partial responses.\r\n\r\nI made this change: https://github.com/neondatabase/neon/pull/11815/commits/f94d64a13cd5a630d15c8b5db1f5b48a46a6d254\r\n\r\nBut whether to send individual page responses is an open question, added a TODO for it: https://github.com/neondatabase/neon/pull/11815/commits/0f3c0696b15f2024d18c313c4521bac0b1aa13bb",
        "pr_file_module": null
      },
      {
        "comment_id": "2077538147",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-07T12:41:31+00:00",
        "comment_author": "VladLazar",
        "comment_body": "> think the more important point here is that when we do the batching client-side, we know whether it makes sense to batch or not (i.e. whether to prioritize throughput or latency)\r\n\r\nWith the more flexible protocol, the communicator could coalesce batches, but perhaps we don't care about that (yet?).",
        "pr_file_module": null
      },
      {
        "comment_id": "2077549276",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-07T12:47:41+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": ">With the more flexible protocol, the communicator could coalesce batches, but perhaps we don't care about that (yet?).\r\n\r\nIt's not clear that it's better to coalesce them than to send them in parallel on separate streams. The smaller the batch is, the more latency-sensitive it is likely to be.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088434150",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-14T08:56:29+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Actually, these batches won't necessarily be contiguous -- they can get fragmented by pages present in the LFC. Let's do scattered page reads after all.\r\n\r\nThey will still be for same relation -- and in the vicinity of other pages (but don't encode this latter assumption).\r\n\r\nThere's still no point returning eager responses and populating the LFC, because backends take out buffer pool locks before they read from the LFC.",
        "pr_file_module": null
      },
      {
        "comment_id": "2090910118",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2075459279",
        "commented_code": "@@ -0,0 +1,205 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns whether a relation exists.\n+  rpc CheckRelExists(CheckRelExistsRequest) returns (CheckRelExistsResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Returns the total size of a database, as # of bytes.\n+  rpc GetDbSize (GetDbSizeRequest) returns (GetDbSizeResponse);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc GetRelSize (GetRelSizeRequest) returns (GetRelSizeResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+}\n+\n+// The LSN a request should read at.\n+//\n+// TODO: is not_modified_since_lsn meaningful for any other requests than GetPage? If not, inline\n+// the relevant fields directly in each request type.\n+message ReadLsn {\n+  // The request's read LSN. Required.\n+  uint64 request_lsn = 1;\n+  // If given, the caller guarantees that the page has not been modified since\n+  // this LSN. Must be smaller than request_lsn. This allows the Pageserver to\n+  // serve an old page without waiting for the request LSN to arrive.\n+  uint64 not_modified_since_lsn = 2;\n+}\n+\n+// A relation identifier.\n+message RelTag {\n+    uint32 spc_oid = 1;\n+    uint32 db_oid = 2;\n+    uint32 rel_number = 3;\n+    uint32 fork_number = 4;\n+}\n+\n+// Checks whether a relation exists, at the given LSN. This is only accurate on\n+// shard 0; other shards will return their view of the relation according to\n+// which pages they have.\n+message CheckRelExistsRequest {\n+  ReadLsn read_lsn = 1;\n+  RelTag rel = 2;\n+}\n+\n+message CheckRelExistsResponse {\n+  bool exists = 1;\n+}\n+\n+// Requests a base backup at a given LSN.\n+message GetBaseBackupRequest {\n+  // The LSN to fetch a base backup at.\n+  ReadLsn read_lsn = 1;\n+  // If true, logical replication slots will not be created.\n+  bool replica = 2;\n+}\n+\n+// Base backup response chunk, returned as an ordered stream.\n+message GetBaseBackupResponseChunk {\n+  // A basebackup data chunk. The size is undefined, but bounded by the 4 MB\n+  // gRPC message size limit.\n+  bytes chunk = 1;\n+}\n+\n+// Requests the size of a database, as # of bytes. This is only accurate on\n+// shard 0; other shards will return their view of the database according to\n+// which pages they have.\n+message GetDbSizeRequest {\n+  ReadLsn read_lsn = 1;\n+  uint32 db_oid = 2;\n+}\n+\n+message GetDbSizeResponse {\n+  uint64 num_bytes = 1;\n+}\n+\n+// Requests a single page.\n+message GetPageRequest {\n+  // A request ID. Will be included in the response. Should be unique for\n+  // in-flight requests on the stream.\n+  uint64 request_id = 1;\n+  // The request class.\n+  GetPageClass request_class = 2;\n+  // The LSN to read at.\n+  ReadLsn read_lsn = 3;\n+  // The relation to read from.\n+  RelTag rel = 4;\n+  // The page number to read. Must belong to the remote shard.\n+  uint32 block_number = 5;\n+}\n+\n+// A GetPageRequest class. Primarily intended for observability, but may also be\n+// used for prioritization in the future.\n+enum GetPageClass {\n+  // Unknown class. For forwards compatibility: used when the client sends a\n+  // class that the server doesn't know about.\n+  GET_PAGE_CLASS_UNKNOWN = 0;\n+  // A normal request. This is the default.\n+  GET_PAGE_CLASS_NORMAL = 1;\n+  // A prefetch request.\n+  GET_PAGE_CLASS_PREFETCH = 2;\n+}\n+\n+// A batch of GetPage requests. These will be executed as a single batch by the\n+// Pageserver, amortizing layer access costs and parallelizing them. This may\n+// increase the latency of any individual request, but improves the overall\n+// latency and throughput of the batch as a whole.\n+//\n+// Responses will be emitted individually, as soon as they are ready. They may\n+// be emitted in a different order than the requests.\n+message GetPageRequestBatch {\n+  repeated GetPageRequest requests = 1;\n+}",
        "comment_created_at": "2025-05-15T11:01:08+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "https://github.com/neondatabase/neon/pull/11815/commits/ddf544d167c800b5f6d5abc2b04bf559a0b189c6",
        "pr_file_module": null
      }
    ]
  }
]