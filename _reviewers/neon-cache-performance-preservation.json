[
  {
    "discussion_id": "2003235648",
    "pr_number": 11294,
    "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
    "created_at": "2025-03-19T12:39:44+00:00",
    "commented_code": "+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute looses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, S3 proxy for unlogged storage of compute files.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    //. in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Prewarm progress in the range [0, 1]\n+        pub progress: f32\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.\n+\n+    3.2. Send cache invalidation message to all proxies, notifying them that all new connections\n+        should request and wait for the new connection details.\n+\n+    3.3. Attach warm replica compute to the primary endpoint inside control plane metadata\n+        database.\n+\n+    3.4. Promote replica to primary.\n+\n+    3.5. When everything is done, finalize the endpoint state to be just `active`.\n+\n+### Complete rolling restart flow\n+\n+```mermaid\n+  sequenceDiagram\n+\n+  autonumber\n+\n+  participant proxy as Neon proxy\n+\n+  participant cplane as Control plane\n+\n+  participant primary as Compute (primary)\n+  box Compute (replica)\n+    participant ctl as compute_ctl\n+    participant pg as Postgres\n+  end\n+\n+  box Endpoint unlogged storage\n+    participant s3proxy as S3 proxy\n+    participant s3 as S3\n+  end\n+\n+\n+  cplane ->> primary: POST /store_lfc_state\n+  primary -->> cplane: 200 OK\n+\n+  cplane ->> ctl: POST /restore_lfc_state\n+  activate ctl\n+  ctl -->> cplane: 202 Accepted\n+\n+  activate cplane\n+  cplane ->> ctl: GET /status: poll prewarm status\n+  ctl ->> s3proxy: GET /read_file\n+  s3proxy ->> s3: read file\n+  s3 -->> s3proxy: file content\n+  s3proxy -->> ctl: 200 OK: file content\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+  cplane -->> proxy: 200 OK: old primary conninfo\n+\n+  ctl ->> pg: prewarm LFC\n+  activate pg\n+  pg -->> ctl: prewarm is completed\n+  deactivate pg\n+\n+  ctl -->> cplane: 200 OK: prewarm is completed\n+  deactivate ctl\n+  deactivate cplane\n+\n+  cplane -->> cplane: reassign replica compute to endpoint,<br>start terminating the old primary compute\n+  activate cplane\n+  cplane ->> proxy: invalidate caches\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+\n+  cplane -x primary: POST /terminate\n+  primary -->> cplane: 200 OK\n+  note over primary: old primary<br>compute terminated\n+\n+  cplane ->> ctl: POST /promote\n+  activate ctl\n+  ctl ->> pg: pg_ctl promote\n+  activate pg\n+  pg -->> ctl: done\n+  deactivate pg\n+  ctl -->> cplane: 200 OK\n+  deactivate ctl\n+\n+  cplane -->> cplane: finalize operation\n+  cplane -->> proxy: 200 OK: new primary conninfo\n+  deactivate cplane\n+```\n+\n+### Reliability, failure modes and corner cases\n+\n+We consider following failures while implementing this RFC:\n+\n+1. Compute got interrupted/crashed/restarted during prewarm. The caller -- control plane -- should\n+    detect that and start prewarm from the beginning.\n+\n+2. Control plane promotion request timed out or hit network issues. If it never reached the\n+    compute, control plane should just repeat it. If it did reach the compute, then during\n+    retry control plane can hit `409` as previous request triggered the promotion already.\n+    In this case, control plane need to retry until either `200` or\n+    permanent error `500` is returned.\n+\n+3. Compute got interrupted/crashed/restarted during promotion. At restart it will ask for\n+    a spec from control plane, and its content should signal compute to start as **primary**,\n+    so it's expected that control plane will continue polling for certain period of time and\n+    will discover that compute is ready to accept connections if restart is fast enough.\n+\n+4. Any other unexpected failure or timeout during prewarming. This **failure mustn't be fatal**,\n+    control plane has to report failure, terminate replica and keep primary running.\n+\n+5. Any other unexpected failure or timeout during promotion. Unfortunately, at this moment\n+    we already have the primary node stopped, so the only option is to start primary again\n+    and proceed with auto-prewarm.\n+\n+6. Any unexpected failure during auto-prewarm. This **failure mustn't be fatal**,\n+    `compute_ctl` has to report the failure, but do not crash the compute.\n+\n+### Security implications\n+\n+There are two security implications to consider:\n+\n+1. Access to `compute_ctl` API. It has to be accessible from the outside of compute, so all\n+    new API methods have to be exposed on the **external** HTTP port and **must** be authenticated\n+    with JWT.\n+\n+2. Read/write only your own LFC state data in S3. Although it's not really a security concern,\n+    since LFC state is just a mapping of blocks present in LFC at certain moment in time;\n+    it still has to be highly restricted, so that i) only computes on the same timeline can\n+    read S3 state; ii) each compute can only write to the path that contains it's `endpoint_id`.\n+    Both of this must be validated by S3 proxy and JWT token used by `compute_ctl`.\n+\n+### Unresolved questions\n+\n+#### Auto-prewarm\n+\n+It's still an open question whether we need auto-prewarm at all. The author's gut-feeling is\n+that yes, we need it, but might be not for all workloads, so it could end up exposed as a\n+user-controllable knob on the endpoint. There are two arguments for that:\n+\n+1. Auto-prewarm existing in upstream's `pg_prewarm`, _probably for a reason_.\n+\n+2. There are still could be 2 flows when we cannot perform the rolling restart via the warm\n+    replica: i) any failure or interruption during promotion; ii) wake up after scale-to-zero.\n+    The latter might be challenged as well, i.e. one can argue that auto-prewarm may and will\n+    compete with user-workload for storage resources. This is correct, but it might as well\n+    reduce the time to get warm LFC and good performance.\n+\n+#### Low-level details of the replica promotion\n+\n+There are many things to consider here, but three items just off the top of my head:\n+\n+1. How to properly start the `walproposer` inside Postgres.\n+\n+2. What to do with logical replication. Currently, we do not include logical replication slots\n+    inside basebackup, because nobody advances them at replica, so they just prevent the WAL\n+    deletion. Yet, we do need to have them at primary after promotion, should we request a new\n+    basebackup during promotion?\n+\n+3. How do we guarantee that replica will receive all the latest WAL from safekeepers?",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2003235648",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2003235648",
        "commented_code": "@@ -0,0 +1,345 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute looses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, S3 proxy for unlogged storage of compute files.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    //. in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Prewarm progress in the range [0, 1]\n+        pub progress: f32\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.\n+\n+    3.2. Send cache invalidation message to all proxies, notifying them that all new connections\n+        should request and wait for the new connection details.\n+\n+    3.3. Attach warm replica compute to the primary endpoint inside control plane metadata\n+        database.\n+\n+    3.4. Promote replica to primary.\n+\n+    3.5. When everything is done, finalize the endpoint state to be just `active`.\n+\n+### Complete rolling restart flow\n+\n+```mermaid\n+  sequenceDiagram\n+\n+  autonumber\n+\n+  participant proxy as Neon proxy\n+\n+  participant cplane as Control plane\n+\n+  participant primary as Compute (primary)\n+  box Compute (replica)\n+    participant ctl as compute_ctl\n+    participant pg as Postgres\n+  end\n+\n+  box Endpoint unlogged storage\n+    participant s3proxy as S3 proxy\n+    participant s3 as S3\n+  end\n+\n+\n+  cplane ->> primary: POST /store_lfc_state\n+  primary -->> cplane: 200 OK\n+\n+  cplane ->> ctl: POST /restore_lfc_state\n+  activate ctl\n+  ctl -->> cplane: 202 Accepted\n+\n+  activate cplane\n+  cplane ->> ctl: GET /status: poll prewarm status\n+  ctl ->> s3proxy: GET /read_file\n+  s3proxy ->> s3: read file\n+  s3 -->> s3proxy: file content\n+  s3proxy -->> ctl: 200 OK: file content\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+  cplane -->> proxy: 200 OK: old primary conninfo\n+\n+  ctl ->> pg: prewarm LFC\n+  activate pg\n+  pg -->> ctl: prewarm is completed\n+  deactivate pg\n+\n+  ctl -->> cplane: 200 OK: prewarm is completed\n+  deactivate ctl\n+  deactivate cplane\n+\n+  cplane -->> cplane: reassign replica compute to endpoint,<br>start terminating the old primary compute\n+  activate cplane\n+  cplane ->> proxy: invalidate caches\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+\n+  cplane -x primary: POST /terminate\n+  primary -->> cplane: 200 OK\n+  note over primary: old primary<br>compute terminated\n+\n+  cplane ->> ctl: POST /promote\n+  activate ctl\n+  ctl ->> pg: pg_ctl promote\n+  activate pg\n+  pg -->> ctl: done\n+  deactivate pg\n+  ctl -->> cplane: 200 OK\n+  deactivate ctl\n+\n+  cplane -->> cplane: finalize operation\n+  cplane -->> proxy: 200 OK: new primary conninfo\n+  deactivate cplane\n+```\n+\n+### Reliability, failure modes and corner cases\n+\n+We consider following failures while implementing this RFC:\n+\n+1. Compute got interrupted/crashed/restarted during prewarm. The caller -- control plane -- should\n+    detect that and start prewarm from the beginning.\n+\n+2. Control plane promotion request timed out or hit network issues. If it never reached the\n+    compute, control plane should just repeat it. If it did reach the compute, then during\n+    retry control plane can hit `409` as previous request triggered the promotion already.\n+    In this case, control plane need to retry until either `200` or\n+    permanent error `500` is returned.\n+\n+3. Compute got interrupted/crashed/restarted during promotion. At restart it will ask for\n+    a spec from control plane, and its content should signal compute to start as **primary**,\n+    so it's expected that control plane will continue polling for certain period of time and\n+    will discover that compute is ready to accept connections if restart is fast enough.\n+\n+4. Any other unexpected failure or timeout during prewarming. This **failure mustn't be fatal**,\n+    control plane has to report failure, terminate replica and keep primary running.\n+\n+5. Any other unexpected failure or timeout during promotion. Unfortunately, at this moment\n+    we already have the primary node stopped, so the only option is to start primary again\n+    and proceed with auto-prewarm.\n+\n+6. Any unexpected failure during auto-prewarm. This **failure mustn't be fatal**,\n+    `compute_ctl` has to report the failure, but do not crash the compute.\n+\n+### Security implications\n+\n+There are two security implications to consider:\n+\n+1. Access to `compute_ctl` API. It has to be accessible from the outside of compute, so all\n+    new API methods have to be exposed on the **external** HTTP port and **must** be authenticated\n+    with JWT.\n+\n+2. Read/write only your own LFC state data in S3. Although it's not really a security concern,\n+    since LFC state is just a mapping of blocks present in LFC at certain moment in time;\n+    it still has to be highly restricted, so that i) only computes on the same timeline can\n+    read S3 state; ii) each compute can only write to the path that contains it's `endpoint_id`.\n+    Both of this must be validated by S3 proxy and JWT token used by `compute_ctl`.\n+\n+### Unresolved questions\n+\n+#### Auto-prewarm\n+\n+It's still an open question whether we need auto-prewarm at all. The author's gut-feeling is\n+that yes, we need it, but might be not for all workloads, so it could end up exposed as a\n+user-controllable knob on the endpoint. There are two arguments for that:\n+\n+1. Auto-prewarm existing in upstream's `pg_prewarm`, _probably for a reason_.\n+\n+2. There are still could be 2 flows when we cannot perform the rolling restart via the warm\n+    replica: i) any failure or interruption during promotion; ii) wake up after scale-to-zero.\n+    The latter might be challenged as well, i.e. one can argue that auto-prewarm may and will\n+    compete with user-workload for storage resources. This is correct, but it might as well\n+    reduce the time to get warm LFC and good performance.\n+\n+#### Low-level details of the replica promotion\n+\n+There are many things to consider here, but three items just off the top of my head:\n+\n+1. How to properly start the `walproposer` inside Postgres.\n+\n+2. What to do with logical replication. Currently, we do not include logical replication slots\n+    inside basebackup, because nobody advances them at replica, so they just prevent the WAL\n+    deletion. Yet, we do need to have them at primary after promotion, should we request a new\n+    basebackup during promotion?\n+\n+3. How do we guarantee that replica will receive all the latest WAL from safekeepers?",
        "comment_created_at": "2025-03-19T12:39:44+00:00",
        "comment_author": "MMeent",
        "comment_body": "Make primary report its flushLSN to CPlane on shutdown, and have CPlane pass that on with the `/promote` call so that compute_ctl can ensure that it has received that WAL before promotion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2003889111",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2003235648",
        "commented_code": "@@ -0,0 +1,345 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute looses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, S3 proxy for unlogged storage of compute files.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    //. in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Prewarm progress in the range [0, 1]\n+        pub progress: f32\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.\n+\n+    3.2. Send cache invalidation message to all proxies, notifying them that all new connections\n+        should request and wait for the new connection details.\n+\n+    3.3. Attach warm replica compute to the primary endpoint inside control plane metadata\n+        database.\n+\n+    3.4. Promote replica to primary.\n+\n+    3.5. When everything is done, finalize the endpoint state to be just `active`.\n+\n+### Complete rolling restart flow\n+\n+```mermaid\n+  sequenceDiagram\n+\n+  autonumber\n+\n+  participant proxy as Neon proxy\n+\n+  participant cplane as Control plane\n+\n+  participant primary as Compute (primary)\n+  box Compute (replica)\n+    participant ctl as compute_ctl\n+    participant pg as Postgres\n+  end\n+\n+  box Endpoint unlogged storage\n+    participant s3proxy as S3 proxy\n+    participant s3 as S3\n+  end\n+\n+\n+  cplane ->> primary: POST /store_lfc_state\n+  primary -->> cplane: 200 OK\n+\n+  cplane ->> ctl: POST /restore_lfc_state\n+  activate ctl\n+  ctl -->> cplane: 202 Accepted\n+\n+  activate cplane\n+  cplane ->> ctl: GET /status: poll prewarm status\n+  ctl ->> s3proxy: GET /read_file\n+  s3proxy ->> s3: read file\n+  s3 -->> s3proxy: file content\n+  s3proxy -->> ctl: 200 OK: file content\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+  cplane -->> proxy: 200 OK: old primary conninfo\n+\n+  ctl ->> pg: prewarm LFC\n+  activate pg\n+  pg -->> ctl: prewarm is completed\n+  deactivate pg\n+\n+  ctl -->> cplane: 200 OK: prewarm is completed\n+  deactivate ctl\n+  deactivate cplane\n+\n+  cplane -->> cplane: reassign replica compute to endpoint,<br>start terminating the old primary compute\n+  activate cplane\n+  cplane ->> proxy: invalidate caches\n+\n+  proxy ->> cplane: GET /proxy_wake_compute\n+\n+  cplane -x primary: POST /terminate\n+  primary -->> cplane: 200 OK\n+  note over primary: old primary<br>compute terminated\n+\n+  cplane ->> ctl: POST /promote\n+  activate ctl\n+  ctl ->> pg: pg_ctl promote\n+  activate pg\n+  pg -->> ctl: done\n+  deactivate pg\n+  ctl -->> cplane: 200 OK\n+  deactivate ctl\n+\n+  cplane -->> cplane: finalize operation\n+  cplane -->> proxy: 200 OK: new primary conninfo\n+  deactivate cplane\n+```\n+\n+### Reliability, failure modes and corner cases\n+\n+We consider following failures while implementing this RFC:\n+\n+1. Compute got interrupted/crashed/restarted during prewarm. The caller -- control plane -- should\n+    detect that and start prewarm from the beginning.\n+\n+2. Control plane promotion request timed out or hit network issues. If it never reached the\n+    compute, control plane should just repeat it. If it did reach the compute, then during\n+    retry control plane can hit `409` as previous request triggered the promotion already.\n+    In this case, control plane need to retry until either `200` or\n+    permanent error `500` is returned.\n+\n+3. Compute got interrupted/crashed/restarted during promotion. At restart it will ask for\n+    a spec from control plane, and its content should signal compute to start as **primary**,\n+    so it's expected that control plane will continue polling for certain period of time and\n+    will discover that compute is ready to accept connections if restart is fast enough.\n+\n+4. Any other unexpected failure or timeout during prewarming. This **failure mustn't be fatal**,\n+    control plane has to report failure, terminate replica and keep primary running.\n+\n+5. Any other unexpected failure or timeout during promotion. Unfortunately, at this moment\n+    we already have the primary node stopped, so the only option is to start primary again\n+    and proceed with auto-prewarm.\n+\n+6. Any unexpected failure during auto-prewarm. This **failure mustn't be fatal**,\n+    `compute_ctl` has to report the failure, but do not crash the compute.\n+\n+### Security implications\n+\n+There are two security implications to consider:\n+\n+1. Access to `compute_ctl` API. It has to be accessible from the outside of compute, so all\n+    new API methods have to be exposed on the **external** HTTP port and **must** be authenticated\n+    with JWT.\n+\n+2. Read/write only your own LFC state data in S3. Although it's not really a security concern,\n+    since LFC state is just a mapping of blocks present in LFC at certain moment in time;\n+    it still has to be highly restricted, so that i) only computes on the same timeline can\n+    read S3 state; ii) each compute can only write to the path that contains it's `endpoint_id`.\n+    Both of this must be validated by S3 proxy and JWT token used by `compute_ctl`.\n+\n+### Unresolved questions\n+\n+#### Auto-prewarm\n+\n+It's still an open question whether we need auto-prewarm at all. The author's gut-feeling is\n+that yes, we need it, but might be not for all workloads, so it could end up exposed as a\n+user-controllable knob on the endpoint. There are two arguments for that:\n+\n+1. Auto-prewarm existing in upstream's `pg_prewarm`, _probably for a reason_.\n+\n+2. There are still could be 2 flows when we cannot perform the rolling restart via the warm\n+    replica: i) any failure or interruption during promotion; ii) wake up after scale-to-zero.\n+    The latter might be challenged as well, i.e. one can argue that auto-prewarm may and will\n+    compete with user-workload for storage resources. This is correct, but it might as well\n+    reduce the time to get warm LFC and good performance.\n+\n+#### Low-level details of the replica promotion\n+\n+There are many things to consider here, but three items just off the top of my head:\n+\n+1. How to properly start the `walproposer` inside Postgres.\n+\n+2. What to do with logical replication. Currently, we do not include logical replication slots\n+    inside basebackup, because nobody advances them at replica, so they just prevent the WAL\n+    deletion. Yet, we do need to have them at primary after promotion, should we request a new\n+    basebackup during promotion?\n+\n+3. How do we guarantee that replica will receive all the latest WAL from safekeepers?",
        "comment_created_at": "2025-03-19T17:28:22+00:00",
        "comment_author": "ololobus",
        "comment_body": "Not a fan of wiring even more stuff via cplane. The flushLSN should be just the last 'consensus' LSN from sefekeepers, right? Cannot compute figure out it on its own before/during promotion (kinda incomplete sync-safekeepers, just without data copying, or we can even do a normal sync-safekeepers on compute before promotion)?\r\n\r\nThat'd be much more robust and less bug-prone because it doesn't put any implicit assumptions that someone passes the right LSN to us",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2005187179",
    "pr_number": 11294,
    "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
    "created_at": "2025-03-20T09:42:36+00:00",
    "commented_code": "+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2005187179",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T09:42:36+00:00",
        "comment_author": "VladLazar",
        "comment_body": "We terminate the old primary before promoting the secondary. If I'm reading this right, there's a an availability gap between the termination and promotion. Is this reading correct? If so, can we avoid it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2005425999",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T11:37:34+00:00",
        "comment_author": "MMeent",
        "comment_body": "> If I'm reading this right, there's a an availability gap between the termination and promotion\r\n\r\nThe secondary *could* be made available for read-only queries before the primary shuts down. However, we can *not* allow write queries to the secondary before the primary has shut down, so there will always be a gap where there is no writer available.\r\n\r\nThe system should be fast enough, however, that this gap is no longer than a second at most; and probably much less.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005581160",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T12:55:31+00:00",
        "comment_author": "VladLazar",
        "comment_body": "It would be great to aim for something where the happy path has no hiccups. If that's not possible, let's be explicit about it and say why.\r\n\r\n---\r\n\r\nProxy learns about about the new primary after the promotion of the new compute, so there should be no queries on it at that point (according to the diagram). It seems like we can swap promotion and termination around while maintaining this property.\r\n\r\nWhat would happen to the client in this case? Let's say we have an in-progress query when the old primary terminates. Client would probably retry and eventually get routed to the new primary.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2005695614",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T13:51:48+00:00",
        "comment_author": "MMeent",
        "comment_body": "> It seems like we can swap promotion and termination around while maintaining this property.\r\n\r\nNo, Vlad, we can not do that.\r\n\r\nTwo computes can Never, NEVER, _never_ both be Primary on the same timeline at the same time.  CPlane is supposed to make sure of that, and Compute will fail if it doesn't. Promotion of the replica before the original Primary shut down will cause errors, panics, data loss, shutdowns, and/or nasal deamons on the Primary, this promoting Secondary, or both.\r\n\r\nWe don't want to test that theory.\r\n\r\n\r\n> What would happen to the client in this case? Let's say we have an in-progress query when the old primary terminates.\r\n\r\nTheir session would and should get disconnected. How that client handles disconnections is not something we care about here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005739484",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T14:12:22+00:00",
        "comment_author": "VladLazar",
        "comment_body": "> Two computes can Never, NEVER, never both be Primary on the same timeline at the same time. CPlane is supposed to make sure of that, and Compute will fail if it doesn't. Promotion of the replica before the original Primary shut down will cause errors, panics, data loss, shutdowns, and/or nasal deamons on the Primary, this promoting Secondary, or both.\r\n\r\nAt the risk of being annoying: why? I understand it doesn't work in the case when two primaries are being written to. But what about if we could guarantee the new primary is idle? More specifically, by idle I mean it would have to not write any WAL and be in some sort of consensus observer role.\r\n\r\nI'm sure you're right about this working with the current state of afairs, but I'm curious about what the technical roadblock is.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005763548",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-20T14:22:49+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Postgres can write WAL not only as result of some query execution.\r\nThere many background activities which cause writing WAL: checkpoint, vacuum,...",
        "pr_file_module": null
      },
      {
        "comment_id": "2010497722",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11294,
        "pr_file": "docs/rfcs/2025-03-17-compute-prewarm.md",
        "discussion_id": "2005187179",
        "commented_code": "@@ -0,0 +1,379 @@\n+# Compute rolling restart with prewarm\n+\n+Created on 2025-03-17\n+Implemented on _TBD_\n+Author: Alexey Kondratov (@ololobus)\n+\n+## Summary\n+\n+This RFC describes an approach to reduce performance degradation due to missing caches after compute node restart, i.e.:\n+\n+1. Rolling restart of the running instance via 'warm' replica.\n+2. Auto-prewarm compute caches after unplanned restart or scale-to-zero.\n+\n+## Motivation\n+\n+Neon currently implements several features that guarantee high uptime of compute nodes:\n+\n+1. Storage high-availability (HA), i.e. each tenant shard has a secondary pageserver location, so we can quickly switch over compute to it in case of primary pageserver failure.\n+2. Fast compute provisioning, i.e. we have a fleet of pre-created empty computes, that are ready to serve workload, so restarting unresponsive compute is very fast.\n+3. Preemptive NeonVM compute provisioning in case of k8s node unavailability.\n+\n+This helps us to be well-within the uptime SLO of 99.95% most of the time. Problems begin when we go up to multi-TB workloads and 32-64 CU computes.\n+During restart, compute loses all caches: LFC, shared buffers, file system cache. Depending on the workload, it can take a lot of time to warm up the caches,\n+so that performance could be degraded and might be even unacceptable for certain workloads. The latter means that although current approach works well for small to\n+medium workloads, we still have to do some additional work to avoid performance degradation after restart of large instances.\n+\n+## Non Goals\n+\n+- Details of the persistence storage for prewarm data are out of scope, there is a separate RFC for that: <https://github.com/neondatabase/neon/pull/9661>.\n+- Complete compute/Postgres HA setup and flow. Although it was originally in scope of this RFC, during preliminary research it appeared to be a rabbit hole, so it's worth of a separate RFC.\n+- Low-level implementation details for Postgres replica-to-primary promotion. There are a lot of things to think and care about: how to start walproposer, [logical replication failover](https://www.postgresql.org/docs/current/logical-replication-failover.html), and so on, but it's worth of at least a separate one-pager design document if not RFC.\n+\n+## Impacted components\n+\n+Postgres, compute_ctl, Control plane, Object storage proxy for unlogged storage of compute files.\n+For the latter, we will need to implement a uniform abstraction layer on top of S3, ABS, etc., but\n+S3 is used in text interchangeably with 'object storage' for simplicity.\n+\n+## Proposed implementation\n+\n+### compute_ctl spec changes and auto-prewarm\n+\n+We are going to extend the current compute spec with the following attributes\n+\n+```rust\n+struct ComputeSpec {\n+    /// [All existing attributes]\n+    ...\n+    /// Whether to do auto-prewarm at start or not.\n+    /// Default to `false`.\n+    pub lfc_auto_prewarm: bool\n+    /// Interval in seconds between automatic dumps of\n+    /// LFC state into S3. Default `None`, which means 'off'.\n+    pub lfc_dump_interval_sec: Option<i32>\n+}\n+```\n+\n+When `lfc_dump_interval_sec` is set to `N`, `compute_ctl` will periodically dump the LFC state\n+and store it in S3, so that it could be used either for auto-prewarm after restart or by replica\n+during the rolling restart. For enabling periodic dumping, we should consider the following value\n+`lfc_dump_interval_sec=300` (5 minutes), same as in the upstream's `pg_prewarm.autoprewarm_interval`.\n+\n+When `lfc_auto_prewarm` is set to `true`, `compute_ctl` will start prewarming the LFC upon restart\n+iif some of the previous states is present in S3.\n+\n+### compute_ctl API\n+\n+1. `POST /store_lfc_state` -- dump LFC state using Postgres SQL interface and store result in S3.\n+    This has to be a blocking call, i.e. it will return only after the state is stored in S3.\n+    If there is any concurrent request in progress, we should return `429 Too Many Requests`,\n+    and let the caller to retry.\n+\n+2. `GET /dump_lfc_state` -- dump LFC state using Postgres SQL interface and return it as is\n+    in text format suitable for the future restore/prewarm. This API is not strictly needed at\n+    the end state, but could be useful for a faster prototyping of a complete rolling restart flow\n+    with prewarm, as it doesn't require persistent for LFC state storage.\n+\n+3. `POST /restore_lfc_state` -- restore/prewarm LFC state with request\n+\n+    ```yaml\n+    RestoreLFCStateRequest:\n+      oneOf:\n+        - type: object\n+          required:\n+            - lfc_state\n+          properties:\n+            lfc_state:\n+              type: string\n+              description: Raw LFC content dumped with GET `/dump_lfc_state`\n+        - type: object\n+          required:\n+            - lfc_cache_key\n+          properties:\n+            lfc_cache_key:\n+              type: string\n+              description: |\n+                endpoint_id of the source endpoint on the same branch\n+                to use as a 'donor' for LFC content. Compute will look up\n+                LFC content dump in S3 using this key and do prewarm.\n+    ```\n+\n+    where `lfc_state` and `lfc_cache_key` are mutually exclusive.\n+\n+    The actual prewarming will happen asynchronously, so the caller need to check the\n+    prewarm status using the compute's standard `GET /status` API.\n+\n+4. `GET /status` -- extend existing API with following attributes\n+\n+    ```rust\n+    struct ComputeStatusResponse {\n+        // [All existing attributes]\n+        ...\n+        pub prewarm_state: PrewarmState\n+    }\n+\n+    /// Compute prewarm state. Will be stored in the shared Compute state\n+    /// in compute_ctl\n+    struct PrewarmState {\n+        pub status: PrewarmStatus\n+        /// Total number of pages to prewarm\n+        pub pages_total: i64\n+        /// Number of pages prewarmed so far\n+        pub pages_processed: i64\n+        /// Optional prewarm error\n+        pub error: Option<String>\n+    }\n+\n+    pub enum PrewarmStatus {\n+        /// Prewarming was never requested on this compute\n+        Off,\n+        /// Prewarming was requested, but not started yet\n+        Pending,\n+        /// Prewarming is in progress. The caller should follow\n+        /// `PrewarmState::progress`.\n+        InProgress,\n+        /// Prewarming has been successfully completed\n+        Completed,\n+        /// Prewarming failed. The caller should look at\n+        /// `PrewarmState::error` for the reason.\n+        Failed,\n+        /// It is intended to be used by auto-prewarm if none of\n+        /// the previous LFC states is available in S3.\n+        /// This is a distinct state from the `Failed` because\n+        /// technically it's not a failure and could happen if\n+        /// compute was restart before it dumped anything into S3,\n+        /// or just after the initial rollout of the feature.\n+        Skipped,\n+    }\n+    ```\n+\n+5. `POST /promote` -- this is a **blocking** API call to promote compute replica into primary.\n+    This API should be very similar to the existing `POST /configure` API, i.e. accept the\n+    spec (primary spec, because originally compute was started as replica). It's a distinct\n+    API method because semantics and response codes are different:\n+\n+    - If promotion is done successfully, it will return `200 OK`.\n+    - If compute is already primary, the call will be no-op and `compute_ctl`\n+      will return `412 Precondition Failed`.\n+    - If, for some reason, second request reaches compute that is in progress of promotion,\n+      it will respond with `429 Too Many Requests`.\n+    - If compute hit any permanent failure during promotion `500 Internal Server Error`\n+      will be returned.\n+\n+### Control plane operations\n+\n+The complete flow will be present as a sequence diagram in the next section, but here\n+we just want to list some important steps that have to be done by control plane during\n+the rolling restart via warm replica, but without much of low-level implementation details.\n+\n+1. Register the 'intent' of the instance restart, but not yet interrupt any workload at\n+    primary and also accept new connections. This may require some endpoint state machine\n+    changes, e.g. introduction of the `pending_restart` state. Being in this state also\n+    **mustn't prevent any other operations except restart**: suspend, live-reconfiguration\n+    (e.g. due to notify-attach call from the storage controller), deletion.\n+\n+2. Start new replica compute on the same timeline and start prewarming it. This process\n+    may take quite a while, so the same concurrency considerations as in 1. should be applied\n+    here as well.\n+\n+3. When warm replica is ready, control plane should:\n+\n+    3.1. Terminate the primary compute. Starting from here, **this is a critical section**,\n+        if anything goes off, the only option is to start the primary normally and proceed\n+        with auto-prewarm.",
        "comment_created_at": "2025-03-24T16:12:21+00:00",
        "comment_author": "MMeent",
        "comment_body": "> More specifically, by idle I mean it would have to not write any WAL and be in some sort of consensus observer role.\r\n\r\nThat's what a hot standby is for PostgreSQL - the hot standby is not allowed to write WAL, but could stop reading and applying WAL from the primary and start writing its own WAL at a moment's notice.\r\n\r\nThe issue is that you can't promote until you've replayed all acknowledged WAL from safekeepers, because otherwise you'd fail to replay commits that the primary may have already sent acknowledgements for to its clients, essentially losing commits.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1994221131",
    "pr_number": 11227,
    "pr_file": "docs/rfcs/043-hot-secondaries.md",
    "created_at": "2025-03-13T19:56:24+00:00",
    "commented_code": "+\n+# Pageserver Hot Secondaries\n+\n+## Summary\n+\n+It is proposed to add a new mode for pageserver tenant shard locations,\n+called \"hot secondary\", which is able to serve page_service requests but\n+does not do all the same housekeeping as an attached location, and does\n+not store any additional data in S3.\n+\n+There is a stark tradeoff between resource cost and complexity: a very simple solution would be to have multiple full attached locations doing independent I/O, but this RFC proposes some additional complexity to\n+reduce cost.\n+\n+## Background\n+\n+In the [pageserver migration RFC](028-pageserver-migration.md), we introduced the concept of \"warm secondaries\".  These are pageserver locations that poll remote storage for a _heatmap_ describing which layers they should hold, and then download those layers from S3.  This enables them to rapidly transition into a usable attached location with a warm cache.\n+\n+Combined with the storage controller's detect of pageserver failures, warm\n+secondaries enabled high availability of pageservers with a recovery time\n+objective (RTO) measured in seconds (depends on configured heartbeat frequency) -- occasional cloud instance failures are typically recovered\n+in well under a minute, without human intervention.\n+\n+## Purpose\n+\n+We aim to provide a sub-second RTO for pageserver failures, for mission\n+critical workloads.  To do this, we should enable the postgres client",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "1994221131",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11227,
        "pr_file": "docs/rfcs/043-hot-secondaries.md",
        "discussion_id": "1994221131",
        "commented_code": "@@ -0,0 +1,110 @@\n+\n+# Pageserver Hot Secondaries\n+\n+## Summary\n+\n+It is proposed to add a new mode for pageserver tenant shard locations,\n+called \"hot secondary\", which is able to serve page_service requests but\n+does not do all the same housekeeping as an attached location, and does\n+not store any additional data in S3.\n+\n+There is a stark tradeoff between resource cost and complexity: a very simple solution would be to have multiple full attached locations doing independent I/O, but this RFC proposes some additional complexity to\n+reduce cost.\n+\n+## Background\n+\n+In the [pageserver migration RFC](028-pageserver-migration.md), we introduced the concept of \"warm secondaries\".  These are pageserver locations that poll remote storage for a _heatmap_ describing which layers they should hold, and then download those layers from S3.  This enables them to rapidly transition into a usable attached location with a warm cache.\n+\n+Combined with the storage controller's detect of pageserver failures, warm\n+secondaries enabled high availability of pageservers with a recovery time\n+objective (RTO) measured in seconds (depends on configured heartbeat frequency) -- occasional cloud instance failures are typically recovered\n+in well under a minute, without human intervention.\n+\n+## Purpose\n+\n+We aim to provide a sub-second RTO for pageserver failures, for mission\n+critical workloads.  To do this, we should enable the postgres client",
        "comment_created_at": "2025-03-13T19:56:24+00:00",
        "comment_author": "arpad-m",
        "comment_body": "I see a second benefit that hot secondaries bring: scaling read traffic. say someone runs a lot of analytic workloads on some database in parallel. for oltp stuff this is probably all already handle-able via caches, but idk.",
        "pr_file_module": null
      }
    ]
  }
]