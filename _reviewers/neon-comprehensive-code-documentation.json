[
  {
    "discussion_id": "2136687606",
    "pr_number": 12111,
    "pr_file": "pageserver/page_api/src/client.rs",
    "created_at": "2025-06-09T23:59:51+00:00",
    "commented_code": "+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2136687606",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12111,
        "pr_file": "pageserver/page_api/src/client.rs",
        "discussion_id": "2136687606",
        "commented_code": "@@ -0,0 +1,186 @@\n+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {",
        "comment_created_at": "2025-06-09T23:59:51+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "nit: both this and `AuthInterceptor` could use a short doc comment explaining what they're for and anything callers should be aware of.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136698511",
    "pr_number": 12111,
    "pr_file": "pageserver/page_api/src/client.rs",
    "created_at": "2025-06-10T00:15:31+00:00",
    "commented_code": "+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {\n+    client: proto::PageServiceClient<\n+        tonic::service::interceptor::InterceptedService<Channel, AuthInterceptor>,\n+    >,\n+}\n+\n+impl Client {\n+    pub async fn new<T: TryInto<tonic::transport::Endpoint> + Send + Sync + 'static>(\n+        into_endpoint: T,\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        shard_id: ShardIndex,\n+        auth_header: Option<String>,\n+    ) -> anyhow::Result<Self> {\n+        let endpoint: tonic::transport::Endpoint = into_endpoint\n+            .try_into()\n+            .map_err(|_e| anyhow::anyhow!(\"Failed to convert endpoint\"))?;\n+        let channel = endpoint.connect().await?;\n+        let auth = AuthInterceptor::new(tenant_id, timeline_id, auth_header, shard_id)\n+            .map_err(|e| Error::new(ErrorKind::InvalidInput, e.to_string()))?;\n+        let client = proto::PageServiceClient::with_interceptor(channel, auth);\n+\n+        Ok(Self { client })\n+    }\n+\n+    // Returns whether a relation exists.",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2136698511",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12111,
        "pr_file": "pageserver/page_api/src/client.rs",
        "discussion_id": "2136698511",
        "commented_code": "@@ -0,0 +1,186 @@\n+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {\n+    client: proto::PageServiceClient<\n+        tonic::service::interceptor::InterceptedService<Channel, AuthInterceptor>,\n+    >,\n+}\n+\n+impl Client {\n+    pub async fn new<T: TryInto<tonic::transport::Endpoint> + Send + Sync + 'static>(\n+        into_endpoint: T,\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        shard_id: ShardIndex,\n+        auth_header: Option<String>,\n+    ) -> anyhow::Result<Self> {\n+        let endpoint: tonic::transport::Endpoint = into_endpoint\n+            .try_into()\n+            .map_err(|_e| anyhow::anyhow!(\"Failed to convert endpoint\"))?;\n+        let channel = endpoint.connect().await?;\n+        let auth = AuthInterceptor::new(tenant_id, timeline_id, auth_header, shard_id)\n+            .map_err(|e| Error::new(ErrorKind::InvalidInput, e.to_string()))?;\n+        let client = proto::PageServiceClient::with_interceptor(channel, auth);\n+\n+        Ok(Self { client })\n+    }\n+\n+    // Returns whether a relation exists.",
        "comment_created_at": "2025-06-10T00:15:31+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Doc comments must start with `///`, otherwise they won't get picked up by IDEs and docs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2138547376",
    "pr_number": 12195,
    "pr_file": "compute_tools/src/compute_prewarm.rs",
    "created_at": "2025-06-10T18:34:17+00:00",
    "commented_code": "}\n \n const KEY: &str = \"lfc_state\";\n-impl TryFrom<&crate::compute::ParsedSpec> for EndpointStoragePair {\n-    type Error = anyhow::Error;\n-    fn try_from(pspec: &crate::compute::ParsedSpec) -> Result<Self, Self::Error> {\n-        let Some(ref endpoint_id) = pspec.spec.endpoint_id else {\n-            bail!(\"pspec.endpoint_id missing\")\n+impl EndpointStoragePair {\n+    /// endpoint_id is set to None while prewarming from other endpoint, see replica promotion",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2138547376",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12195,
        "pr_file": "compute_tools/src/compute_prewarm.rs",
        "discussion_id": "2138547376",
        "commented_code": "@@ -25,11 +25,16 @@ struct EndpointStoragePair {\n }\n \n const KEY: &str = \"lfc_state\";\n-impl TryFrom<&crate::compute::ParsedSpec> for EndpointStoragePair {\n-    type Error = anyhow::Error;\n-    fn try_from(pspec: &crate::compute::ParsedSpec) -> Result<Self, Self::Error> {\n-        let Some(ref endpoint_id) = pspec.spec.endpoint_id else {\n-            bail!(\"pspec.endpoint_id missing\")\n+impl EndpointStoragePair {\n+    /// endpoint_id is set to None while prewarming from other endpoint, see replica promotion",
        "comment_created_at": "2025-06-10T18:34:17+00:00",
        "comment_author": "ololobus",
        "comment_body": "> endpoint_id is set to None while prewarming from other endpoint, see replica promotion\r\n\r\nThis doesn't sound right. When we promote we should prewarm from another endpoint, so endpoint_id should **not** be None, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2138624565",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12195,
        "pr_file": "compute_tools/src/compute_prewarm.rs",
        "discussion_id": "2138547376",
        "commented_code": "@@ -25,11 +25,16 @@ struct EndpointStoragePair {\n }\n \n const KEY: &str = \"lfc_state\";\n-impl TryFrom<&crate::compute::ParsedSpec> for EndpointStoragePair {\n-    type Error = anyhow::Error;\n-    fn try_from(pspec: &crate::compute::ParsedSpec) -> Result<Self, Self::Error> {\n-        let Some(ref endpoint_id) = pspec.spec.endpoint_id else {\n-            bail!(\"pspec.endpoint_id missing\")\n+impl EndpointStoragePair {\n+    /// endpoint_id is set to None while prewarming from other endpoint, see replica promotion",
        "comment_created_at": "2025-06-10T19:25:29+00:00",
        "comment_author": "myrrc",
        "comment_body": "Yeah, a comment typo. It's None when we prewarm from ourselves' data, will fix in promotion PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "2138640192",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12195,
        "pr_file": "compute_tools/src/compute_prewarm.rs",
        "discussion_id": "2138547376",
        "commented_code": "@@ -25,11 +25,16 @@ struct EndpointStoragePair {\n }\n \n const KEY: &str = \"lfc_state\";\n-impl TryFrom<&crate::compute::ParsedSpec> for EndpointStoragePair {\n-    type Error = anyhow::Error;\n-    fn try_from(pspec: &crate::compute::ParsedSpec) -> Result<Self, Self::Error> {\n-        let Some(ref endpoint_id) = pspec.spec.endpoint_id else {\n-            bail!(\"pspec.endpoint_id missing\")\n+impl EndpointStoragePair {\n+    /// endpoint_id is set to None while prewarming from other endpoint, see replica promotion",
        "comment_created_at": "2025-06-10T19:36:21+00:00",
        "comment_author": "ololobus",
        "comment_body": "@myrrc, please, do not merge incorrect code (including comments) into `main` with the hope of fixing it in another PR. Another PR may never happen, it might be delayed for an arbitrary amount of time, you can forget, etc.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2120844964",
    "pr_number": 11911,
    "pr_file": "compute_tools/src/monitor.rs",
    "created_at": "2025-06-02T11:21:58+00:00",
    "commented_code": "const MONITOR_CHECK_INTERVAL: Duration = Duration::from_millis(500);\n \n+/// Struct to store runtime state of the compute monitor thread.",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2120844964",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11911,
        "pr_file": "compute_tools/src/monitor.rs",
        "discussion_id": "2120844964",
        "commented_code": "@@ -13,6 +13,12 @@ use crate::metrics::{PG_CURR_DOWNTIME_MS, PG_TOTAL_DOWNTIME_MS};\n \n const MONITOR_CHECK_INTERVAL: Duration = Duration::from_millis(500);\n \n+/// Struct to store runtime state of the compute monitor thread.",
        "comment_created_at": "2025-06-02T11:21:58+00:00",
        "comment_author": "myrrc",
        "comment_body": "`//!`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2121869070",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11911,
        "pr_file": "compute_tools/src/monitor.rs",
        "discussion_id": "2120844964",
        "commented_code": "@@ -13,6 +13,12 @@ use crate::metrics::{PG_CURR_DOWNTIME_MS, PG_TOTAL_DOWNTIME_MS};\n \n const MONITOR_CHECK_INTERVAL: Duration = Duration::from_millis(500);\n \n+/// Struct to store runtime state of the compute monitor thread.",
        "comment_created_at": "2025-06-02T18:26:26+00:00",
        "comment_author": "ololobus",
        "comment_body": "My understanding is that the difference between /// and !// is that the former applies to the following block, while the latter applies to the upper, which is frequently used for the top-level comments for the crate/module. Here, the comment applies to the struct, so /// seems applicable, or do I miss something?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2092708454",
    "pr_number": 11889,
    "pr_file": "pageserver/src/pgdatadir_mapping.rs",
    "created_at": "2025-05-16T09:36:06+00:00",
    "commented_code": "NoData(Lsn),\n }\n \n+#[derive(Debug, Clone, Copy, Default)]\n+pub struct LsnRange {",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2092708454",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11889,
        "pr_file": "pageserver/src/pgdatadir_mapping.rs",
        "discussion_id": "2092708454",
        "commented_code": "@@ -90,6 +92,24 @@ pub enum LsnForTimestamp {\n     NoData(Lsn),\n }\n \n+#[derive(Debug, Clone, Copy, Default)]\n+pub struct LsnRange {",
        "comment_created_at": "2025-05-16T09:36:06+00:00",
        "comment_author": "VladLazar",
        "comment_body": "nit: a comment would be nice:\r\n* explain difference between effective and request lsn\r\n* explain that primary compute always uses `request_lsn == MAX`\r\n* hint that this is how the compute thinks about get page requests",
        "pr_file_module": null
      },
      {
        "comment_id": "2094184240",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11889,
        "pr_file": "pageserver/src/pgdatadir_mapping.rs",
        "discussion_id": "2092708454",
        "commented_code": "@@ -90,6 +92,24 @@ pub enum LsnForTimestamp {\n     NoData(Lsn),\n }\n \n+#[derive(Debug, Clone, Copy, Default)]\n+pub struct LsnRange {",
        "comment_created_at": "2025-05-17T18:33:13+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  }
]