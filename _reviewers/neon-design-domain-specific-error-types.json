[
  {
    "discussion_id": "2136689342",
    "pr_number": 12111,
    "pr_file": "pageserver/page_api/src/client.rs",
    "created_at": "2025-06-10T00:02:26+00:00",
    "commented_code": "+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {\n+    client: proto::PageServiceClient<\n+        tonic::service::interceptor::InterceptedService<Channel, AuthInterceptor>,\n+    >,\n+}\n+\n+impl Client {\n+    pub async fn new<T: TryInto<tonic::transport::Endpoint> + Send + Sync + 'static>(\n+        into_endpoint: T,\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        shard_id: ShardIndex,\n+        auth_header: Option<String>,\n+    ) -> anyhow::Result<Self> {\n+        let endpoint: tonic::transport::Endpoint = into_endpoint\n+            .try_into()\n+            .map_err(|_e| anyhow::anyhow!(\"Failed to convert endpoint\"))?;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2136689342",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12111,
        "pr_file": "pageserver/page_api/src/client.rs",
        "discussion_id": "2136689342",
        "commented_code": "@@ -0,0 +1,186 @@\n+use std::convert::TryInto;\n+use std::io::Error;\n+use std::io::ErrorKind;\n+\n+use bytes::Bytes;\n+use futures::StreamExt;\n+use futures_core::Stream;\n+use tonic::metadata::AsciiMetadataValue;\n+use tonic::metadata::errors::InvalidMetadataValue;\n+use tonic::transport::Channel;\n+use tonic::{Request, Streaming};\n+\n+use utils::id::TenantId;\n+use utils::id::TimelineId;\n+use utils::shard::ShardIndex;\n+\n+use anyhow::Result;\n+\n+use crate::model;\n+use crate::proto;\n+#[derive(Clone)]\n+struct AuthInterceptor {\n+    tenant_id: AsciiMetadataValue,\n+    shard_id: Option<AsciiMetadataValue>,\n+    timeline_id: AsciiMetadataValue,\n+    auth_header: Option<AsciiMetadataValue>, // including \"Bearer \" prefix\n+}\n+\n+impl AuthInterceptor {\n+    fn new(\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        auth_token: Option<String>,\n+        shard_id: ShardIndex,\n+    ) -> Result<Self, InvalidMetadataValue> {\n+        let tenant_ascii: AsciiMetadataValue = tenant_id.to_string().try_into()?;\n+        let timeline_ascii: AsciiMetadataValue = timeline_id.to_string().try_into()?;\n+        let shard_ascii: AsciiMetadataValue = shard_id.clone().to_string().try_into()?;\n+\n+        let auth_header: Option<AsciiMetadataValue> = match auth_token {\n+            Some(token) => Some(format!(\"Bearer {token}\").try_into()?),\n+            None => None,\n+        };\n+\n+        Ok(Self {\n+            tenant_id: tenant_ascii,\n+            shard_id: Some(shard_ascii),\n+            timeline_id: timeline_ascii,\n+            auth_header,\n+        })\n+    }\n+}\n+\n+impl tonic::service::Interceptor for AuthInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        req.metadata_mut()\n+            .insert(\"neon-tenant-id\", self.tenant_id.clone());\n+        if let Some(shard_id) = &self.shard_id {\n+            req.metadata_mut().insert(\"neon-shard-id\", shard_id.clone());\n+        }\n+        req.metadata_mut()\n+            .insert(\"neon-timeline-id\", self.timeline_id.clone());\n+        if let Some(auth_header) = &self.auth_header {\n+            req.metadata_mut()\n+                .insert(\"authorization\", auth_header.clone());\n+        }\n+        Ok(req)\n+    }\n+}\n+#[derive(Clone)]\n+pub struct Client {\n+    client: proto::PageServiceClient<\n+        tonic::service::interceptor::InterceptedService<Channel, AuthInterceptor>,\n+    >,\n+}\n+\n+impl Client {\n+    pub async fn new<T: TryInto<tonic::transport::Endpoint> + Send + Sync + 'static>(\n+        into_endpoint: T,\n+        tenant_id: TenantId,\n+        timeline_id: TimelineId,\n+        shard_id: ShardIndex,\n+        auth_header: Option<String>,\n+    ) -> anyhow::Result<Self> {\n+        let endpoint: tonic::transport::Endpoint = into_endpoint\n+            .try_into()\n+            .map_err(|_e| anyhow::anyhow!(\"Failed to convert endpoint\"))?;",
        "comment_created_at": "2025-06-10T00:02:26+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "nit: Rust errors normally start with lowercase (since they'll often get prefixed by outer error messages), and should include the inner error, i.e. `anyhow!(\"failed to convert endpoint: {e}\")`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2078001222",
    "pr_number": 11821,
    "pr_file": "libs/posthog_client_lite/src/lib.rs",
    "created_at": "2025-05-07T16:07:10+00:00",
    "commented_code": "+//! A lite version of the PostHog client that only supports local evaluation of feature flags.\n+\n+use std::{collections::HashMap, sync::Arc};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::json;\n+use sha2::Digest;\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationResponse {\n+    #[allow(dead_code)]\n+    flags: Vec<PostHogLocalEvaluationFlag>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlag {\n+    key: String,\n+    filters: PostHogLocalEvaluationFlagFilters,\n+    active: bool,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilters {\n+    groups: Vec<PostHogLocalEvaluationFlagFilterGroup>,\n+    multivariate: PostHogLocalEvaluationFlagMultivariate,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterGroup {\n+    variant: Option<String>,\n+    properties: Option<Vec<PostHogLocalEvaluationFlagFilterProperty>>,\n+    rollout_percentage: f64,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterProperty {\n+    key: String,\n+    value: PostHogFlagFilterPropertyValue,\n+    operator: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum PostHogFlagFilterPropertyValue {\n+    String(String),\n+    Number(f64),\n+    Boolean(bool),\n+    List(Vec<String>),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariate {\n+    variants: Vec<PostHogLocalEvaluationFlagMultivariateVariant>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariateVariant {\n+    key: String,\n+    rollout_percentage: f64,\n+}\n+\n+pub struct PostHogClient {\n+    server_api_key: String,\n+    client_api_key: String,\n+    project_id: String,\n+    private_api_url: String,\n+    public_api_url: String,\n+    client: Arc<reqwest::Client>,\n+}\n+\n+pub struct FeatureStore {\n+    flags: HashMap<String, PostHogLocalEvaluationFlag>,\n+}\n+\n+impl Default for FeatureStore {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl FeatureStore {\n+    pub fn new() -> Self {\n+        Self {\n+            flags: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn update_flags(&mut self, flags: Vec<PostHogLocalEvaluationFlag>) {\n+        self.flags.clear();\n+        for flag in flags {\n+            if flag.active {\n+                self.flags.insert(flag.key.clone(), flag);\n+            }\n+        }\n+    }\n+\n+    /// Generate a consistent hash for a user ID (e.g., tenant ID).\n+    ///\n+    /// The implementation is different from PostHog SDK. In PostHog SDK, it is sha1 of `user_id.distinct_id.salt`.\n+    /// However, as we do not upload all of our tenant IDs to PostHog, we do not have the PostHog distinct_id for a\n+    /// tenant.\n+    fn consistent_hash(user_id: &str) -> f64 {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(user_id);\n+        let hash = hasher.finalize();\n+        let hash_int = u64::from_le_bytes(hash[..8].try_into().unwrap());\n+        hash_int as f64 / u64::MAX as f64\n+    }\n+\n+    /// Evaluate a condition. Returns `None` if the condition cannot be evaluated due to parsing error or missing\n+    /// property.\n+    fn evaluate_condition(\n+        &self,\n+        operator: &str,\n+        provided: &PostHogFlagFilterPropertyValue,\n+        requested: &PostHogFlagFilterPropertyValue,\n+    ) -> Option<bool> {\n+        match operator {\n+            \"exact\" => {\n+                let PostHogFlagFilterPropertyValue::String(provided) = provided else {\n+                    // Left should be a string\n+                    return None;\n+                };\n+                let PostHogFlagFilterPropertyValue::List(requested) = requested else {\n+                    // Right should be a list of string\n+                    return None;\n+                };\n+                Some(requested.contains(provided))\n+            }\n+            \"lt\" | \"gt\" => {\n+                let PostHogFlagFilterPropertyValue::String(requested) = requested else {\n+                    // Right should be a string\n+                    return None;\n+                };\n+                let Ok(requested) = requested.parse::<f64>() else {\n+                    return None;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2078001222",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11821,
        "pr_file": "libs/posthog_client_lite/src/lib.rs",
        "discussion_id": "2078001222",
        "commented_code": "@@ -0,0 +1,433 @@\n+//! A lite version of the PostHog client that only supports local evaluation of feature flags.\n+\n+use std::{collections::HashMap, sync::Arc};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::json;\n+use sha2::Digest;\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationResponse {\n+    #[allow(dead_code)]\n+    flags: Vec<PostHogLocalEvaluationFlag>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlag {\n+    key: String,\n+    filters: PostHogLocalEvaluationFlagFilters,\n+    active: bool,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilters {\n+    groups: Vec<PostHogLocalEvaluationFlagFilterGroup>,\n+    multivariate: PostHogLocalEvaluationFlagMultivariate,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterGroup {\n+    variant: Option<String>,\n+    properties: Option<Vec<PostHogLocalEvaluationFlagFilterProperty>>,\n+    rollout_percentage: f64,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterProperty {\n+    key: String,\n+    value: PostHogFlagFilterPropertyValue,\n+    operator: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum PostHogFlagFilterPropertyValue {\n+    String(String),\n+    Number(f64),\n+    Boolean(bool),\n+    List(Vec<String>),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariate {\n+    variants: Vec<PostHogLocalEvaluationFlagMultivariateVariant>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariateVariant {\n+    key: String,\n+    rollout_percentage: f64,\n+}\n+\n+pub struct PostHogClient {\n+    server_api_key: String,\n+    client_api_key: String,\n+    project_id: String,\n+    private_api_url: String,\n+    public_api_url: String,\n+    client: Arc<reqwest::Client>,\n+}\n+\n+pub struct FeatureStore {\n+    flags: HashMap<String, PostHogLocalEvaluationFlag>,\n+}\n+\n+impl Default for FeatureStore {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl FeatureStore {\n+    pub fn new() -> Self {\n+        Self {\n+            flags: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn update_flags(&mut self, flags: Vec<PostHogLocalEvaluationFlag>) {\n+        self.flags.clear();\n+        for flag in flags {\n+            if flag.active {\n+                self.flags.insert(flag.key.clone(), flag);\n+            }\n+        }\n+    }\n+\n+    /// Generate a consistent hash for a user ID (e.g., tenant ID).\n+    ///\n+    /// The implementation is different from PostHog SDK. In PostHog SDK, it is sha1 of `user_id.distinct_id.salt`.\n+    /// However, as we do not upload all of our tenant IDs to PostHog, we do not have the PostHog distinct_id for a\n+    /// tenant.\n+    fn consistent_hash(user_id: &str) -> f64 {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(user_id);\n+        let hash = hasher.finalize();\n+        let hash_int = u64::from_le_bytes(hash[..8].try_into().unwrap());\n+        hash_int as f64 / u64::MAX as f64\n+    }\n+\n+    /// Evaluate a condition. Returns `None` if the condition cannot be evaluated due to parsing error or missing\n+    /// property.\n+    fn evaluate_condition(\n+        &self,\n+        operator: &str,\n+        provided: &PostHogFlagFilterPropertyValue,\n+        requested: &PostHogFlagFilterPropertyValue,\n+    ) -> Option<bool> {\n+        match operator {\n+            \"exact\" => {\n+                let PostHogFlagFilterPropertyValue::String(provided) = provided else {\n+                    // Left should be a string\n+                    return None;\n+                };\n+                let PostHogFlagFilterPropertyValue::List(requested) = requested else {\n+                    // Right should be a list of string\n+                    return None;\n+                };\n+                Some(requested.contains(provided))\n+            }\n+            \"lt\" | \"gt\" => {\n+                let PostHogFlagFilterPropertyValue::String(requested) = requested else {\n+                    // Right should be a string\n+                    return None;\n+                };\n+                let Ok(requested) = requested.parse::<f64>() else {\n+                    return None;",
        "comment_created_at": "2025-05-07T16:07:10+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "Is it ok that we return `None` and not real errors here and there?\r\nProbably we want to log if there is some error in evaluation because usually it means bugs",
        "pr_file_module": null
      },
      {
        "comment_id": "2078759809",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11821,
        "pr_file": "libs/posthog_client_lite/src/lib.rs",
        "discussion_id": "2078001222",
        "commented_code": "@@ -0,0 +1,433 @@\n+//! A lite version of the PostHog client that only supports local evaluation of feature flags.\n+\n+use std::{collections::HashMap, sync::Arc};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::json;\n+use sha2::Digest;\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationResponse {\n+    #[allow(dead_code)]\n+    flags: Vec<PostHogLocalEvaluationFlag>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlag {\n+    key: String,\n+    filters: PostHogLocalEvaluationFlagFilters,\n+    active: bool,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilters {\n+    groups: Vec<PostHogLocalEvaluationFlagFilterGroup>,\n+    multivariate: PostHogLocalEvaluationFlagMultivariate,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterGroup {\n+    variant: Option<String>,\n+    properties: Option<Vec<PostHogLocalEvaluationFlagFilterProperty>>,\n+    rollout_percentage: f64,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterProperty {\n+    key: String,\n+    value: PostHogFlagFilterPropertyValue,\n+    operator: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum PostHogFlagFilterPropertyValue {\n+    String(String),\n+    Number(f64),\n+    Boolean(bool),\n+    List(Vec<String>),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariate {\n+    variants: Vec<PostHogLocalEvaluationFlagMultivariateVariant>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariateVariant {\n+    key: String,\n+    rollout_percentage: f64,\n+}\n+\n+pub struct PostHogClient {\n+    server_api_key: String,\n+    client_api_key: String,\n+    project_id: String,\n+    private_api_url: String,\n+    public_api_url: String,\n+    client: Arc<reqwest::Client>,\n+}\n+\n+pub struct FeatureStore {\n+    flags: HashMap<String, PostHogLocalEvaluationFlag>,\n+}\n+\n+impl Default for FeatureStore {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl FeatureStore {\n+    pub fn new() -> Self {\n+        Self {\n+            flags: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn update_flags(&mut self, flags: Vec<PostHogLocalEvaluationFlag>) {\n+        self.flags.clear();\n+        for flag in flags {\n+            if flag.active {\n+                self.flags.insert(flag.key.clone(), flag);\n+            }\n+        }\n+    }\n+\n+    /// Generate a consistent hash for a user ID (e.g., tenant ID).\n+    ///\n+    /// The implementation is different from PostHog SDK. In PostHog SDK, it is sha1 of `user_id.distinct_id.salt`.\n+    /// However, as we do not upload all of our tenant IDs to PostHog, we do not have the PostHog distinct_id for a\n+    /// tenant.\n+    fn consistent_hash(user_id: &str) -> f64 {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(user_id);\n+        let hash = hasher.finalize();\n+        let hash_int = u64::from_le_bytes(hash[..8].try_into().unwrap());\n+        hash_int as f64 / u64::MAX as f64\n+    }\n+\n+    /// Evaluate a condition. Returns `None` if the condition cannot be evaluated due to parsing error or missing\n+    /// property.\n+    fn evaluate_condition(\n+        &self,\n+        operator: &str,\n+        provided: &PostHogFlagFilterPropertyValue,\n+        requested: &PostHogFlagFilterPropertyValue,\n+    ) -> Option<bool> {\n+        match operator {\n+            \"exact\" => {\n+                let PostHogFlagFilterPropertyValue::String(provided) = provided else {\n+                    // Left should be a string\n+                    return None;\n+                };\n+                let PostHogFlagFilterPropertyValue::List(requested) = requested else {\n+                    // Right should be a list of string\n+                    return None;\n+                };\n+                Some(requested.contains(provided))\n+            }\n+            \"lt\" | \"gt\" => {\n+                let PostHogFlagFilterPropertyValue::String(requested) = requested else {\n+                    // Right should be a string\n+                    return None;\n+                };\n+                let Ok(requested) = requested.parse::<f64>() else {\n+                    return None;",
        "comment_created_at": "2025-05-08T01:49:22+00:00",
        "comment_author": "skyzh",
        "comment_body": "Yep I'll return real errors there",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2085186464",
    "pr_number": 11821,
    "pr_file": "libs/posthog_client_lite/src/lib.rs",
    "created_at": "2025-05-12T18:03:28+00:00",
    "commented_code": "+//! A lite version of the PostHog client that only supports local evaluation of feature flags.\n+\n+use std::{collections::HashMap, sync::Arc};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::json;\n+use sha2::Digest;\n+\n+#[derive(Debug, thiserror::Error)]\n+pub enum PostHogEvaluationError {\n+    /// The feature flag is not available, for example, because the local evaluation data is not populated yet.\n+    #[error(\"Feature flag not available: {0}\")]\n+    NotAvailable(&'static str),\n+    #[error(\"No condition group is matched\")]\n+    NoConditionGroupMatched,\n+    /// Real errors, e.g., the rollout percentage does not add up to 100.\n+    #[error(\"Failed to evaluate feature flag: {0}\")]\n+    Internal(&'static str),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationResponse {\n+    #[allow(dead_code)]\n+    flags: Vec<PostHogLocalEvaluationFlag>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlag {\n+    key: String,\n+    filters: PostHogLocalEvaluationFlagFilters,\n+    active: bool,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilters {\n+    groups: Vec<PostHogLocalEvaluationFlagFilterGroup>,\n+    multivariate: PostHogLocalEvaluationFlagMultivariate,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterGroup {\n+    variant: Option<String>,\n+    properties: Option<Vec<PostHogLocalEvaluationFlagFilterProperty>>,\n+    rollout_percentage: i64,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterProperty {\n+    key: String,\n+    value: PostHogFlagFilterPropertyValue,\n+    operator: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum PostHogFlagFilterPropertyValue {\n+    String(String),\n+    Number(f64),\n+    Boolean(bool),\n+    List(Vec<String>),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariate {\n+    variants: Vec<PostHogLocalEvaluationFlagMultivariateVariant>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariateVariant {\n+    key: String,\n+    rollout_percentage: i64,\n+}\n+\n+/// A lite PostHog client.\n+///\n+/// At the point of writing this code, PostHog does not have a functional Rust client with feature flag support.\n+/// This is a lite version that only supports local evaluation of feature flags and only supports those JSON specs\n+/// that will be used within Neon.\n+///\n+/// PostHog is designed as a browser-server system: the browser (client) side uses the client key and is exposed\n+/// to the end users; the server side uses a server key and is not exposed to the end users. The client and the\n+/// server has different API keys and provide a different set of APIs. In Neon, we only have the server (that is\n+/// pageserver), and it will use both the client API and the server API. So we need to store two API keys within\n+/// our PostHog client.\n+///\n+/// The server API is used to fetch the feature flag specs. The client API is used to capture events in case we\n+/// want to report the feature flag usage back to PostHog. The current plan is to use PostHog only as an UI to\n+/// configure feature flags so it is very likely that the client API will not be used.\n+pub struct PostHogClient {\n+    /// The server API key.\n+    server_api_key: String,\n+    /// The client API key.\n+    client_api_key: String,\n+    /// The project ID.\n+    project_id: String,\n+    /// The private API URL.\n+    private_api_url: String,\n+    /// The public API URL.\n+    public_api_url: String,\n+    /// The HTTP client.\n+    client: Arc<reqwest::Client>,\n+}\n+\n+pub struct FeatureStore {\n+    flags: HashMap<String, PostHogLocalEvaluationFlag>,\n+}\n+\n+impl Default for FeatureStore {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+enum GroupEvaluationResult {\n+    MatchedAndOverride(String),\n+    MatchedAndEvaluate,\n+    Unmatched,\n+}\n+\n+impl FeatureStore {\n+    pub fn new() -> Self {\n+        Self {\n+            flags: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn set_flags(&mut self, flags: Vec<PostHogLocalEvaluationFlag>) {\n+        self.flags.clear();\n+        for flag in flags {\n+            if flag.active {\n+                self.flags.insert(flag.key.clone(), flag);\n+            }\n+        }\n+    }\n+\n+    /// Generate a consistent hash for a user ID (e.g., tenant ID).\n+    ///\n+    /// The implementation is different from PostHog SDK. In PostHog SDK, it is sha1 of `user_id.distinct_id.salt`.\n+    /// However, as we do not upload all of our tenant IDs to PostHog, we do not have the PostHog distinct_id for a\n+    /// tenant. Therefore, the way we compute it is sha256 of `user_id.feature_id`.\n+    fn consistent_hash(user_id: &str, flag_key: &str, salt: &str) -> f64 {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(user_id);\n+        hasher.update(\".\");\n+        hasher.update(flag_key);\n+        hasher.update(\".\");\n+        hasher.update(salt);\n+        let hash = hasher.finalize();\n+        let hash_int = u64::from_le_bytes(hash[..8].try_into().unwrap());\n+        hash_int as f64 / u64::MAX as f64\n+    }\n+\n+    /// Evaluate a condition. Returns `None` if the condition cannot be evaluated due to parsing error or missing\n+    /// property.\n+    fn evaluate_condition(\n+        &self,\n+        operator: &str,\n+        provided: &PostHogFlagFilterPropertyValue,\n+        requested: &PostHogFlagFilterPropertyValue,\n+    ) -> Result<bool, PostHogEvaluationError> {\n+        match operator {\n+            \"exact\" => {\n+                let PostHogFlagFilterPropertyValue::String(provided) = provided else {\n+                    // Left should be a string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The left side of the condition is not a string\",\n+                    ));\n+                };\n+                let PostHogFlagFilterPropertyValue::List(requested) = requested else {\n+                    // Right should be a list of string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The right side of the condition is not a list\",\n+                    ));\n+                };\n+                Ok(requested.contains(provided))\n+            }\n+            \"lt\" | \"gt\" => {\n+                let PostHogFlagFilterPropertyValue::String(requested) = requested else {\n+                    // Right should be a string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The right side of the condition is not a string\",\n+                    ));\n+                };\n+                let Ok(requested) = requested.parse::<f64>() else {\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"Can not parse the right side of the condition as a number\",\n+                    ));\n+                };\n+                // Left can either be a number or a string\n+                let provided = match provided {\n+                    PostHogFlagFilterPropertyValue::Number(provided) => *provided,\n+                    PostHogFlagFilterPropertyValue::String(provided) => {\n+                        let Ok(provided) = provided.parse::<f64>() else {\n+                            return Err(PostHogEvaluationError::Internal(\n+                                \"Can not parse the left side of the condition as a number\",\n+                            ));\n+                        };\n+                        provided\n+                    }\n+                    _ => {\n+                        return Err(PostHogEvaluationError::Internal(\n+                            \"The left side of the condition is not a number or a string\",\n+                        ));\n+                    }\n+                };\n+                match operator {\n+                    \"lt\" => Ok(provided < requested),\n+                    \"gt\" => Ok(provided > requested),\n+                    _ => Err(PostHogEvaluationError::Internal(\"Unreachable code path\")),\n+                }\n+            }\n+            _ => Err(PostHogEvaluationError::Internal(\"Unsupported operator\")),\n+        }\n+    }\n+\n+    /// Evaluate a percentage.\n+    fn evaluate_percentage(&self, mapped_user_id: f64, percentage: i64) -> bool {\n+        mapped_user_id <= percentage as f64 / 100.0\n+    }\n+\n+    /// Evaluate a filter group for a feature flag. Returns `None` if the group is not matched or if there are errors\n+    /// during the evaluation.\n+    ///\n+    /// Return values:\n+    /// Ok(Some(variant)): matched and evaluated to this value\n+    /// Ok(None): condition unmatched and not evaluated\n+    fn evaluate_group(\n+        &self,\n+        group: &PostHogLocalEvaluationFlagFilterGroup,\n+        hash_on_group_rollout_percentage: f64,\n+        provided_properties: &HashMap<String, PostHogFlagFilterPropertyValue>,\n+    ) -> Result<GroupEvaluationResult, PostHogEvaluationError> {\n+        if let Some(ref properties) = group.properties {\n+            for property in properties {\n+                if let Some(value) = provided_properties.get(&property.key) {\n+                    // The user provided the property value\n+                    if !self.evaluate_condition(\n+                        property.operator.as_ref(),\n+                        value,\n+                        &property.value,\n+                    )? {\n+                        return Ok(GroupEvaluationResult::Unmatched);\n+                    }\n+                } else {\n+                    // We cannot evaluate, the property is not available\n+                    return Err(PostHogEvaluationError::NotAvailable(\n+                        \"The required property in the condition is not available\",",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2085186464",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11821,
        "pr_file": "libs/posthog_client_lite/src/lib.rs",
        "discussion_id": "2085186464",
        "commented_code": "@@ -0,0 +1,616 @@\n+//! A lite version of the PostHog client that only supports local evaluation of feature flags.\n+\n+use std::{collections::HashMap, sync::Arc};\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json::json;\n+use sha2::Digest;\n+\n+#[derive(Debug, thiserror::Error)]\n+pub enum PostHogEvaluationError {\n+    /// The feature flag is not available, for example, because the local evaluation data is not populated yet.\n+    #[error(\"Feature flag not available: {0}\")]\n+    NotAvailable(&'static str),\n+    #[error(\"No condition group is matched\")]\n+    NoConditionGroupMatched,\n+    /// Real errors, e.g., the rollout percentage does not add up to 100.\n+    #[error(\"Failed to evaluate feature flag: {0}\")]\n+    Internal(&'static str),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationResponse {\n+    #[allow(dead_code)]\n+    flags: Vec<PostHogLocalEvaluationFlag>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlag {\n+    key: String,\n+    filters: PostHogLocalEvaluationFlagFilters,\n+    active: bool,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilters {\n+    groups: Vec<PostHogLocalEvaluationFlagFilterGroup>,\n+    multivariate: PostHogLocalEvaluationFlagMultivariate,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterGroup {\n+    variant: Option<String>,\n+    properties: Option<Vec<PostHogLocalEvaluationFlagFilterProperty>>,\n+    rollout_percentage: i64,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagFilterProperty {\n+    key: String,\n+    value: PostHogFlagFilterPropertyValue,\n+    operator: String,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(untagged)]\n+pub enum PostHogFlagFilterPropertyValue {\n+    String(String),\n+    Number(f64),\n+    Boolean(bool),\n+    List(Vec<String>),\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariate {\n+    variants: Vec<PostHogLocalEvaluationFlagMultivariateVariant>,\n+}\n+\n+#[derive(Deserialize)]\n+pub struct PostHogLocalEvaluationFlagMultivariateVariant {\n+    key: String,\n+    rollout_percentage: i64,\n+}\n+\n+/// A lite PostHog client.\n+///\n+/// At the point of writing this code, PostHog does not have a functional Rust client with feature flag support.\n+/// This is a lite version that only supports local evaluation of feature flags and only supports those JSON specs\n+/// that will be used within Neon.\n+///\n+/// PostHog is designed as a browser-server system: the browser (client) side uses the client key and is exposed\n+/// to the end users; the server side uses a server key and is not exposed to the end users. The client and the\n+/// server has different API keys and provide a different set of APIs. In Neon, we only have the server (that is\n+/// pageserver), and it will use both the client API and the server API. So we need to store two API keys within\n+/// our PostHog client.\n+///\n+/// The server API is used to fetch the feature flag specs. The client API is used to capture events in case we\n+/// want to report the feature flag usage back to PostHog. The current plan is to use PostHog only as an UI to\n+/// configure feature flags so it is very likely that the client API will not be used.\n+pub struct PostHogClient {\n+    /// The server API key.\n+    server_api_key: String,\n+    /// The client API key.\n+    client_api_key: String,\n+    /// The project ID.\n+    project_id: String,\n+    /// The private API URL.\n+    private_api_url: String,\n+    /// The public API URL.\n+    public_api_url: String,\n+    /// The HTTP client.\n+    client: Arc<reqwest::Client>,\n+}\n+\n+pub struct FeatureStore {\n+    flags: HashMap<String, PostHogLocalEvaluationFlag>,\n+}\n+\n+impl Default for FeatureStore {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+enum GroupEvaluationResult {\n+    MatchedAndOverride(String),\n+    MatchedAndEvaluate,\n+    Unmatched,\n+}\n+\n+impl FeatureStore {\n+    pub fn new() -> Self {\n+        Self {\n+            flags: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn set_flags(&mut self, flags: Vec<PostHogLocalEvaluationFlag>) {\n+        self.flags.clear();\n+        for flag in flags {\n+            if flag.active {\n+                self.flags.insert(flag.key.clone(), flag);\n+            }\n+        }\n+    }\n+\n+    /// Generate a consistent hash for a user ID (e.g., tenant ID).\n+    ///\n+    /// The implementation is different from PostHog SDK. In PostHog SDK, it is sha1 of `user_id.distinct_id.salt`.\n+    /// However, as we do not upload all of our tenant IDs to PostHog, we do not have the PostHog distinct_id for a\n+    /// tenant. Therefore, the way we compute it is sha256 of `user_id.feature_id`.\n+    fn consistent_hash(user_id: &str, flag_key: &str, salt: &str) -> f64 {\n+        let mut hasher = sha2::Sha256::new();\n+        hasher.update(user_id);\n+        hasher.update(\".\");\n+        hasher.update(flag_key);\n+        hasher.update(\".\");\n+        hasher.update(salt);\n+        let hash = hasher.finalize();\n+        let hash_int = u64::from_le_bytes(hash[..8].try_into().unwrap());\n+        hash_int as f64 / u64::MAX as f64\n+    }\n+\n+    /// Evaluate a condition. Returns `None` if the condition cannot be evaluated due to parsing error or missing\n+    /// property.\n+    fn evaluate_condition(\n+        &self,\n+        operator: &str,\n+        provided: &PostHogFlagFilterPropertyValue,\n+        requested: &PostHogFlagFilterPropertyValue,\n+    ) -> Result<bool, PostHogEvaluationError> {\n+        match operator {\n+            \"exact\" => {\n+                let PostHogFlagFilterPropertyValue::String(provided) = provided else {\n+                    // Left should be a string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The left side of the condition is not a string\",\n+                    ));\n+                };\n+                let PostHogFlagFilterPropertyValue::List(requested) = requested else {\n+                    // Right should be a list of string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The right side of the condition is not a list\",\n+                    ));\n+                };\n+                Ok(requested.contains(provided))\n+            }\n+            \"lt\" | \"gt\" => {\n+                let PostHogFlagFilterPropertyValue::String(requested) = requested else {\n+                    // Right should be a string\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"The right side of the condition is not a string\",\n+                    ));\n+                };\n+                let Ok(requested) = requested.parse::<f64>() else {\n+                    return Err(PostHogEvaluationError::Internal(\n+                        \"Can not parse the right side of the condition as a number\",\n+                    ));\n+                };\n+                // Left can either be a number or a string\n+                let provided = match provided {\n+                    PostHogFlagFilterPropertyValue::Number(provided) => *provided,\n+                    PostHogFlagFilterPropertyValue::String(provided) => {\n+                        let Ok(provided) = provided.parse::<f64>() else {\n+                            return Err(PostHogEvaluationError::Internal(\n+                                \"Can not parse the left side of the condition as a number\",\n+                            ));\n+                        };\n+                        provided\n+                    }\n+                    _ => {\n+                        return Err(PostHogEvaluationError::Internal(\n+                            \"The left side of the condition is not a number or a string\",\n+                        ));\n+                    }\n+                };\n+                match operator {\n+                    \"lt\" => Ok(provided < requested),\n+                    \"gt\" => Ok(provided > requested),\n+                    _ => Err(PostHogEvaluationError::Internal(\"Unreachable code path\")),\n+                }\n+            }\n+            _ => Err(PostHogEvaluationError::Internal(\"Unsupported operator\")),\n+        }\n+    }\n+\n+    /// Evaluate a percentage.\n+    fn evaluate_percentage(&self, mapped_user_id: f64, percentage: i64) -> bool {\n+        mapped_user_id <= percentage as f64 / 100.0\n+    }\n+\n+    /// Evaluate a filter group for a feature flag. Returns `None` if the group is not matched or if there are errors\n+    /// during the evaluation.\n+    ///\n+    /// Return values:\n+    /// Ok(Some(variant)): matched and evaluated to this value\n+    /// Ok(None): condition unmatched and not evaluated\n+    fn evaluate_group(\n+        &self,\n+        group: &PostHogLocalEvaluationFlagFilterGroup,\n+        hash_on_group_rollout_percentage: f64,\n+        provided_properties: &HashMap<String, PostHogFlagFilterPropertyValue>,\n+    ) -> Result<GroupEvaluationResult, PostHogEvaluationError> {\n+        if let Some(ref properties) = group.properties {\n+            for property in properties {\n+                if let Some(value) = provided_properties.get(&property.key) {\n+                    // The user provided the property value\n+                    if !self.evaluate_condition(\n+                        property.operator.as_ref(),\n+                        value,\n+                        &property.value,\n+                    )? {\n+                        return Ok(GroupEvaluationResult::Unmatched);\n+                    }\n+                } else {\n+                    // We cannot evaluate, the property is not available\n+                    return Err(PostHogEvaluationError::NotAvailable(\n+                        \"The required property in the condition is not available\",",
        "comment_created_at": "2025-05-12T18:03:28+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "nit: it's already fine (and much better than just `return None`), but adding some context to error messages would increase debugability (e.g. the name of the missing property).\r\nIt's applies to all other places as well",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076083051",
    "pr_number": 11835,
    "pr_file": "pageserver/src/tenant/blob_io.rs",
    "created_at": "2025-05-06T19:01:30+00:00",
    "commented_code": "cancel: CancellationToken,\n         ctx: &RequestContext,\n         flush_task_span: tracing::Span,\n-    ) -> anyhow::Result<Self> {\n+    ) -> Result<Self, BlobWriterError> {\n+        let gate_token = gate.enter().map_err(|e| BlobWriterError::Other(e.into()))?;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2076083051",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11835,
        "pr_file": "pageserver/src/tenant/blob_io.rs",
        "discussion_id": "2076083051",
        "commented_code": "@@ -238,14 +246,16 @@ where\n         cancel: CancellationToken,\n         ctx: &RequestContext,\n         flush_task_span: tracing::Span,\n-    ) -> anyhow::Result<Self> {\n+    ) -> Result<Self, BlobWriterError> {\n+        let gate_token = gate.enter().map_err(|e| BlobWriterError::Other(e.into()))?;",
        "comment_created_at": "2025-05-06T19:01:30+00:00",
        "comment_author": "problame",
        "comment_body": "entering the gate should map to `Cancelled`; fix that not just here but all over this PR ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076091985",
    "pr_number": 11835,
    "pr_file": "pageserver/src/tenant/timeline/compaction.rs",
    "created_at": "2025-05-06T19:08:49+00:00",
    "commented_code": ".unwrap()\n                     .put_value(key, lsn, value, ctx)\n                     .await\n-                    .map_err(CompactionError::Other)?;\n+                    .map_err(|e| match e {\n+                        DeltaLayerWriterError::Cancelled => {\n+                            CompactionError::Other(anyhow::anyhow!(\"flush task cancelled\"))",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2076091985",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11835,
        "pr_file": "pageserver/src/tenant/timeline/compaction.rs",
        "discussion_id": "2076091985",
        "commented_code": "@@ -2199,7 +2214,12 @@ impl Timeline {\n                     .unwrap()\n                     .put_value(key, lsn, value, ctx)\n                     .await\n-                    .map_err(CompactionError::Other)?;\n+                    .map_err(|e| match e {\n+                        DeltaLayerWriterError::Cancelled => {\n+                            CompactionError::Other(anyhow::anyhow!(\"flush task cancelled\"))",
        "comment_created_at": "2025-05-06T19:08:49+00:00",
        "comment_author": "problame",
        "comment_body": "There needs to be a `CompactionError::Cancelled` variant! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076092539",
    "pr_number": 11835,
    "pr_file": "pageserver/src/tenant/timeline/detach_ancestor.rs",
    "created_at": "2025-05-06T19:09:14+00:00",
    "commented_code": "let (desc, path) = writer\n             .finish(reused_highest_key, ctx)\n             .await\n-            .map_err(Error::Prepare)?;\n+            .map_err(|e| match e {\n+                DeltaLayerWriterError::Cancelled => {\n+                    Error::Prepare(anyhow::anyhow!(\"flush task cancelled\"))\n+                }",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2076092539",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11835,
        "pr_file": "pageserver/src/tenant/timeline/detach_ancestor.rs",
        "discussion_id": "2076092539",
        "commented_code": "@@ -816,7 +817,12 @@ async fn copy_lsn_prefix(\n         let (desc, path) = writer\n             .finish(reused_highest_key, ctx)\n             .await\n-            .map_err(Error::Prepare)?;\n+            .map_err(|e| match e {\n+                DeltaLayerWriterError::Cancelled => {\n+                    Error::Prepare(anyhow::anyhow!(\"flush task cancelled\"))\n+                }",
        "comment_created_at": "2025-05-06T19:09:14+00:00",
        "comment_author": "problame",
        "comment_body": "Map this to Error::ShuttingDown",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077126369",
    "pr_number": 11835,
    "pr_file": "pageserver/src/tenant/storage_layer/batch_split_writer.rs",
    "created_at": "2025-05-07T08:42:08+00:00",
    "commented_code": "generated_layers.push(BatchWriterResult::Discarded(layer_key));\n             } else {\n                 let res = match inner {\n-                    LayerWriterWrapper::Delta(writer) => {\n-                        writer.finish(layer_key.key_range.end, ctx).await\n-                    }\n-                    LayerWriterWrapper::Image(writer) => {\n-                        writer\n-                            .finish_with_end_key(layer_key.key_range.end, ctx)\n-                            .await\n-                    }\n+                    LayerWriterWrapper::Delta(writer) => writer\n+                        .finish(layer_key.key_range.end, ctx)\n+                        .await\n+                        .map_err(|e| match e {\n+                            DeltaLayerWriterError::Cancelled => {\n+                                anyhow::anyhow!(\"flush task cancelled\")\n+                            }\n+                            DeltaLayerWriterError::Other(err) => err,\n+                        }),",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2077126369",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11835,
        "pr_file": "pageserver/src/tenant/storage_layer/batch_split_writer.rs",
        "discussion_id": "2077126369",
        "commented_code": "@@ -139,14 +141,24 @@ impl BatchLayerWriter {\n                 generated_layers.push(BatchWriterResult::Discarded(layer_key));\n             } else {\n                 let res = match inner {\n-                    LayerWriterWrapper::Delta(writer) => {\n-                        writer.finish(layer_key.key_range.end, ctx).await\n-                    }\n-                    LayerWriterWrapper::Image(writer) => {\n-                        writer\n-                            .finish_with_end_key(layer_key.key_range.end, ctx)\n-                            .await\n-                    }\n+                    LayerWriterWrapper::Delta(writer) => writer\n+                        .finish(layer_key.key_range.end, ctx)\n+                        .await\n+                        .map_err(|e| match e {\n+                            DeltaLayerWriterError::Cancelled => {\n+                                anyhow::anyhow!(\"flush task cancelled\")\n+                            }\n+                            DeltaLayerWriterError::Other(err) => err,\n+                        }),",
        "comment_created_at": "2025-05-07T08:42:08+00:00",
        "comment_author": "problame",
        "comment_body": "No anyhow here, this needs to be a distinguished error type like the other ones",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077138070",
    "pr_number": 11835,
    "pr_file": "pageserver/src/tenant/timeline.rs",
    "created_at": "2025-05-07T08:47:05+00:00",
    "commented_code": ")\n         .await?;\n         for (key, img) in images {\n-            image_layer_writer.put_image(key, img, ctx).await?;\n+            image_layer_writer\n+                .put_image(key, img, ctx)\n+                .await\n+                .map_err(|e| match e {\n+                    ImageLayerWriterError::Cancelled => {\n+                        anyhow::anyhow!(\"flush task cancelled\")\n+                    }",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2077138070",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11835,
        "pr_file": "pageserver/src/tenant/timeline.rs",
        "discussion_id": "2077138070",
        "commented_code": "@@ -6922,9 +6945,22 @@ impl Timeline {\n         )\n         .await?;\n         for (key, img) in images {\n-            image_layer_writer.put_image(key, img, ctx).await?;\n+            image_layer_writer\n+                .put_image(key, img, ctx)\n+                .await\n+                .map_err(|e| match e {\n+                    ImageLayerWriterError::Cancelled => {\n+                        anyhow::anyhow!(\"flush task cancelled\")\n+                    }",
        "comment_created_at": "2025-05-07T08:47:05+00:00",
        "comment_author": "problame",
        "comment_body": "Bubble up the ImageLayerWriterError instead of mapping to anyhow",
        "pr_file_module": null
      }
    ]
  }
]