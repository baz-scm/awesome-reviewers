[
  {
    "discussion_id": "2140433907",
    "pr_number": 12166,
    "pr_file": "pgxn/neon/relkind_cache.c",
    "created_at": "2025-06-11T15:01:45+00:00",
    "commented_code": "+/*-------------------------------------------------------------------------\n+ *\n+ * relkind_cache.c\n+ *      Cache for marking unlogged relations\n+ *\n+ * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n+ * Portions Copyright (c) 1994, Regents of the University of California\n+ *\n+ *-------------------------------------------------------------------------\n+ */\n+#include \"postgres.h\"\n+\n+#include \"neon_pgversioncompat.h\"\n+\n+#include \"pagestore_client.h\"\n+#include RELFILEINFO_HDR\n+#include \"storage/smgr.h\"\n+#include \"storage/lwlock.h\"\n+#include \"storage/ipc.h\"\n+#include \"storage/shmem.h\"\n+#include \"catalog/pg_tablespace_d.h\"\n+#include \"utils/dynahash.h\"\n+#include \"utils/guc.h\"\n+\n+#if PG_VERSION_NUM >= 150000\n+#include \"miscadmin.h\"\n+#endif\n+\n+/*\n+ * The main goal of this cache is to avoid calls of mdexists in neon_write,\n+ * which is needed to distinguish unlogged relations.\n+ *\n+ * This hash is also used to mark relation during unlogged build.\n+ * It has limited size, implementing eviction based on LRU algorithm.\n+ * Relations involved in unlogged build are pinned in the cache (assuming that\n+ * number of concurrent unlogged build is small.\n+ *\n+ * Another task of this hash is to prevent race condition during unlogged build termination.\n+ * Some backend may want to evict page which backenf performing unlogged build can complete it and unlinking local files.\n+ * We are using shared lock which is hold during all write operation. As far as lock is shared is doesn't prevent concurrent writes.\n+ * Exclusive lock is taken by unlogged_build_end to change relation kind.\n+ */\n+\n+typedef struct\n+{\n+\tsize_t      size;\n+\tuint64\t\thits;\n+\tuint64\t\tmisses;\n+\tuint64\t\tpinned;\n+\tslock_t\t\tmutex;\n+\tdlist_head\tlru;\t\t\t/* double linked list for LRU replacement\n+\t\t\t\t\t\t\t\t * algorithm */\n+} RelKindHashControl;\n+\n+static HTAB *relkind_hash;\n+static LWLockId relkind_lock;\n+static int\trelkind_hash_size;\n+static RelKindHashControl* relkind_ctl;\n+static shmem_startup_hook_type prev_shmem_startup_hook = NULL;\n+#if PG_VERSION_NUM >= 150000\n+static shmem_request_hook_type prev_shmem_request_hook = NULL;\n+static void relkind_shmem_request(void);\n+#endif\n+\n+#define MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS 100 /* MaxBackend? */\n+\n+/*\n+ * Should not be smaller than MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS.\n+ * Size of a cache entry is 32 bytes. So this default will take about 2 MB,\n+ * which seems reasonable.\n+ */\n+#define DEFAULT_RELKIND_HASH_SIZE (64 * 1024)\n+\n+\n+\n+static void\n+relkind_cache_startup(void)\n+{\n+\tstatic HASHCTL info;\n+\tbool found;\n+\n+\tif (prev_shmem_startup_hook)\n+\t\tprev_shmem_startup_hook();\n+\n+\tLWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n+\trelkind_ctl = (RelKindHashControl *) ShmemInitStruct(\"relkind_hash\", sizeof(RelKindHashControl), &found);\n+\tif (!found)\n+\t{\n+\t\trelkind_lock = (LWLockId) GetNamedLWLockTranche(\"neon_relkind\");\n+\t\tinfo.keysize = sizeof(NRelFileInfo);\n+\t\tinfo.entrysize = sizeof(RelKindEntry);\n+\t\trelkind_hash = ShmemInitHash(\"neon_relkind\",\n+\t\t\t\t\t\t\t\t\t relkind_hash_size, relkind_hash_size,\n+\t\t\t\t\t\t\t\t\t &info,\n+\t\t\t\t\t\t\t\t\t HASH_ELEM | HASH_BLOBS);\n+\t\tSpinLockInit(&relkind_ctl->mutex);\n+\t\trelkind_ctl->size = 0;\n+\t\trelkind_ctl->hits = 0;\n+\t\trelkind_ctl->misses = 0;\n+\t\trelkind_ctl->pinned = 0;\n+\t\tdlist_init(&relkind_ctl->lru);\n+\t}\n+\tLWLockRelease(AddinShmemInitLock);\n+}\n+\n+/*\n+ * Intialize new entry. This function is used by neon_start_unlogged_build to mark relation involved in unlogged build.\n+ * In case of overflow removes least recently used entry.\n+ * Return pinned entry. It will be released by unpin_cached_relkind at the end of unlogged build.\n+ */\n+RelKindEntry*\n+set_cached_relkind(NRelFileInfo rinfo, uint8 flags)\n+{\n+\tRelKindEntry *entry = NULL;\n+\tbool found;\n+\n+\t/* Use spinlock to prevent concurrent hash modifitcation */\n+\tSpinLockAcquire(&relkind_ctl->mutex);\n+\n+\t/*\n+\t * This should actually never happen! Below we check if hash is full and delete least recently user item in this case.\n+\t * But for further safety we also perform check here.\n+\t */\n+\twhile ((entry = hash_search(relkind_hash, &rinfo, HASH_ENTER_NULL, &found)) == NULL)\n+\t{\n+\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\tAssert(relkind_ctl->size > 0);\n+\t\trelkind_ctl->size -= 1;\n+\t}\n+\tif (!found)\n+\t{\n+\t\tif (++relkind_ctl->size == relkind_hash_size)\n+\t\t{\n+\t\t\t/*\n+\t\t\t * Remove least recently used elment from the hash.\n+\t\t\t * Hash size after is becomes `relkind_hash_size-1`.\n+\t\t\t * But it is not considered to be a problem, because size of this hash is expecrted large enough and +-1 doesn't matter.\n+\t\t\t */\n+\t\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\t\trelkind_ctl->size -= 1;\n+\t\t}\n+\t\trelkind_ctl->pinned += 1;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2140433907",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12166,
        "pr_file": "pgxn/neon/relkind_cache.c",
        "discussion_id": "2140433907",
        "commented_code": "@@ -0,0 +1,356 @@\n+/*-------------------------------------------------------------------------\n+ *\n+ * relkind_cache.c\n+ *      Cache for marking unlogged relations\n+ *\n+ * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n+ * Portions Copyright (c) 1994, Regents of the University of California\n+ *\n+ *-------------------------------------------------------------------------\n+ */\n+#include \"postgres.h\"\n+\n+#include \"neon_pgversioncompat.h\"\n+\n+#include \"pagestore_client.h\"\n+#include RELFILEINFO_HDR\n+#include \"storage/smgr.h\"\n+#include \"storage/lwlock.h\"\n+#include \"storage/ipc.h\"\n+#include \"storage/shmem.h\"\n+#include \"catalog/pg_tablespace_d.h\"\n+#include \"utils/dynahash.h\"\n+#include \"utils/guc.h\"\n+\n+#if PG_VERSION_NUM >= 150000\n+#include \"miscadmin.h\"\n+#endif\n+\n+/*\n+ * The main goal of this cache is to avoid calls of mdexists in neon_write,\n+ * which is needed to distinguish unlogged relations.\n+ *\n+ * This hash is also used to mark relation during unlogged build.\n+ * It has limited size, implementing eviction based on LRU algorithm.\n+ * Relations involved in unlogged build are pinned in the cache (assuming that\n+ * number of concurrent unlogged build is small.\n+ *\n+ * Another task of this hash is to prevent race condition during unlogged build termination.\n+ * Some backend may want to evict page which backenf performing unlogged build can complete it and unlinking local files.\n+ * We are using shared lock which is hold during all write operation. As far as lock is shared is doesn't prevent concurrent writes.\n+ * Exclusive lock is taken by unlogged_build_end to change relation kind.\n+ */\n+\n+typedef struct\n+{\n+\tsize_t      size;\n+\tuint64\t\thits;\n+\tuint64\t\tmisses;\n+\tuint64\t\tpinned;\n+\tslock_t\t\tmutex;\n+\tdlist_head\tlru;\t\t\t/* double linked list for LRU replacement\n+\t\t\t\t\t\t\t\t * algorithm */\n+} RelKindHashControl;\n+\n+static HTAB *relkind_hash;\n+static LWLockId relkind_lock;\n+static int\trelkind_hash_size;\n+static RelKindHashControl* relkind_ctl;\n+static shmem_startup_hook_type prev_shmem_startup_hook = NULL;\n+#if PG_VERSION_NUM >= 150000\n+static shmem_request_hook_type prev_shmem_request_hook = NULL;\n+static void relkind_shmem_request(void);\n+#endif\n+\n+#define MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS 100 /* MaxBackend? */\n+\n+/*\n+ * Should not be smaller than MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS.\n+ * Size of a cache entry is 32 bytes. So this default will take about 2 MB,\n+ * which seems reasonable.\n+ */\n+#define DEFAULT_RELKIND_HASH_SIZE (64 * 1024)\n+\n+\n+\n+static void\n+relkind_cache_startup(void)\n+{\n+\tstatic HASHCTL info;\n+\tbool found;\n+\n+\tif (prev_shmem_startup_hook)\n+\t\tprev_shmem_startup_hook();\n+\n+\tLWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n+\trelkind_ctl = (RelKindHashControl *) ShmemInitStruct(\"relkind_hash\", sizeof(RelKindHashControl), &found);\n+\tif (!found)\n+\t{\n+\t\trelkind_lock = (LWLockId) GetNamedLWLockTranche(\"neon_relkind\");\n+\t\tinfo.keysize = sizeof(NRelFileInfo);\n+\t\tinfo.entrysize = sizeof(RelKindEntry);\n+\t\trelkind_hash = ShmemInitHash(\"neon_relkind\",\n+\t\t\t\t\t\t\t\t\t relkind_hash_size, relkind_hash_size,\n+\t\t\t\t\t\t\t\t\t &info,\n+\t\t\t\t\t\t\t\t\t HASH_ELEM | HASH_BLOBS);\n+\t\tSpinLockInit(&relkind_ctl->mutex);\n+\t\trelkind_ctl->size = 0;\n+\t\trelkind_ctl->hits = 0;\n+\t\trelkind_ctl->misses = 0;\n+\t\trelkind_ctl->pinned = 0;\n+\t\tdlist_init(&relkind_ctl->lru);\n+\t}\n+\tLWLockRelease(AddinShmemInitLock);\n+}\n+\n+/*\n+ * Intialize new entry. This function is used by neon_start_unlogged_build to mark relation involved in unlogged build.\n+ * In case of overflow removes least recently used entry.\n+ * Return pinned entry. It will be released by unpin_cached_relkind at the end of unlogged build.\n+ */\n+RelKindEntry*\n+set_cached_relkind(NRelFileInfo rinfo, uint8 flags)\n+{\n+\tRelKindEntry *entry = NULL;\n+\tbool found;\n+\n+\t/* Use spinlock to prevent concurrent hash modifitcation */\n+\tSpinLockAcquire(&relkind_ctl->mutex);\n+\n+\t/*\n+\t * This should actually never happen! Below we check if hash is full and delete least recently user item in this case.\n+\t * But for further safety we also perform check here.\n+\t */\n+\twhile ((entry = hash_search(relkind_hash, &rinfo, HASH_ENTER_NULL, &found)) == NULL)\n+\t{\n+\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\tAssert(relkind_ctl->size > 0);\n+\t\trelkind_ctl->size -= 1;\n+\t}\n+\tif (!found)\n+\t{\n+\t\tif (++relkind_ctl->size == relkind_hash_size)\n+\t\t{\n+\t\t\t/*\n+\t\t\t * Remove least recently used elment from the hash.\n+\t\t\t * Hash size after is becomes `relkind_hash_size-1`.\n+\t\t\t * But it is not considered to be a problem, because size of this hash is expecrted large enough and +-1 doesn't matter.\n+\t\t\t */\n+\t\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\t\trelkind_ctl->size -= 1;\n+\t\t}\n+\t\trelkind_ctl->pinned += 1;",
        "comment_created_at": "2025-06-11T15:01:45+00:00",
        "comment_author": "myrrc",
        "comment_body": "This check and loop are further used in other functions, can we extract them to a separate helper function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2140527805",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12166,
        "pr_file": "pgxn/neon/relkind_cache.c",
        "discussion_id": "2140433907",
        "commented_code": "@@ -0,0 +1,356 @@\n+/*-------------------------------------------------------------------------\n+ *\n+ * relkind_cache.c\n+ *      Cache for marking unlogged relations\n+ *\n+ * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group\n+ * Portions Copyright (c) 1994, Regents of the University of California\n+ *\n+ *-------------------------------------------------------------------------\n+ */\n+#include \"postgres.h\"\n+\n+#include \"neon_pgversioncompat.h\"\n+\n+#include \"pagestore_client.h\"\n+#include RELFILEINFO_HDR\n+#include \"storage/smgr.h\"\n+#include \"storage/lwlock.h\"\n+#include \"storage/ipc.h\"\n+#include \"storage/shmem.h\"\n+#include \"catalog/pg_tablespace_d.h\"\n+#include \"utils/dynahash.h\"\n+#include \"utils/guc.h\"\n+\n+#if PG_VERSION_NUM >= 150000\n+#include \"miscadmin.h\"\n+#endif\n+\n+/*\n+ * The main goal of this cache is to avoid calls of mdexists in neon_write,\n+ * which is needed to distinguish unlogged relations.\n+ *\n+ * This hash is also used to mark relation during unlogged build.\n+ * It has limited size, implementing eviction based on LRU algorithm.\n+ * Relations involved in unlogged build are pinned in the cache (assuming that\n+ * number of concurrent unlogged build is small.\n+ *\n+ * Another task of this hash is to prevent race condition during unlogged build termination.\n+ * Some backend may want to evict page which backenf performing unlogged build can complete it and unlinking local files.\n+ * We are using shared lock which is hold during all write operation. As far as lock is shared is doesn't prevent concurrent writes.\n+ * Exclusive lock is taken by unlogged_build_end to change relation kind.\n+ */\n+\n+typedef struct\n+{\n+\tsize_t      size;\n+\tuint64\t\thits;\n+\tuint64\t\tmisses;\n+\tuint64\t\tpinned;\n+\tslock_t\t\tmutex;\n+\tdlist_head\tlru;\t\t\t/* double linked list for LRU replacement\n+\t\t\t\t\t\t\t\t * algorithm */\n+} RelKindHashControl;\n+\n+static HTAB *relkind_hash;\n+static LWLockId relkind_lock;\n+static int\trelkind_hash_size;\n+static RelKindHashControl* relkind_ctl;\n+static shmem_startup_hook_type prev_shmem_startup_hook = NULL;\n+#if PG_VERSION_NUM >= 150000\n+static shmem_request_hook_type prev_shmem_request_hook = NULL;\n+static void relkind_shmem_request(void);\n+#endif\n+\n+#define MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS 100 /* MaxBackend? */\n+\n+/*\n+ * Should not be smaller than MAX_CONCURRENTLY_ACCESSED_UNLOGGED_RELS.\n+ * Size of a cache entry is 32 bytes. So this default will take about 2 MB,\n+ * which seems reasonable.\n+ */\n+#define DEFAULT_RELKIND_HASH_SIZE (64 * 1024)\n+\n+\n+\n+static void\n+relkind_cache_startup(void)\n+{\n+\tstatic HASHCTL info;\n+\tbool found;\n+\n+\tif (prev_shmem_startup_hook)\n+\t\tprev_shmem_startup_hook();\n+\n+\tLWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n+\trelkind_ctl = (RelKindHashControl *) ShmemInitStruct(\"relkind_hash\", sizeof(RelKindHashControl), &found);\n+\tif (!found)\n+\t{\n+\t\trelkind_lock = (LWLockId) GetNamedLWLockTranche(\"neon_relkind\");\n+\t\tinfo.keysize = sizeof(NRelFileInfo);\n+\t\tinfo.entrysize = sizeof(RelKindEntry);\n+\t\trelkind_hash = ShmemInitHash(\"neon_relkind\",\n+\t\t\t\t\t\t\t\t\t relkind_hash_size, relkind_hash_size,\n+\t\t\t\t\t\t\t\t\t &info,\n+\t\t\t\t\t\t\t\t\t HASH_ELEM | HASH_BLOBS);\n+\t\tSpinLockInit(&relkind_ctl->mutex);\n+\t\trelkind_ctl->size = 0;\n+\t\trelkind_ctl->hits = 0;\n+\t\trelkind_ctl->misses = 0;\n+\t\trelkind_ctl->pinned = 0;\n+\t\tdlist_init(&relkind_ctl->lru);\n+\t}\n+\tLWLockRelease(AddinShmemInitLock);\n+}\n+\n+/*\n+ * Intialize new entry. This function is used by neon_start_unlogged_build to mark relation involved in unlogged build.\n+ * In case of overflow removes least recently used entry.\n+ * Return pinned entry. It will be released by unpin_cached_relkind at the end of unlogged build.\n+ */\n+RelKindEntry*\n+set_cached_relkind(NRelFileInfo rinfo, uint8 flags)\n+{\n+\tRelKindEntry *entry = NULL;\n+\tbool found;\n+\n+\t/* Use spinlock to prevent concurrent hash modifitcation */\n+\tSpinLockAcquire(&relkind_ctl->mutex);\n+\n+\t/*\n+\t * This should actually never happen! Below we check if hash is full and delete least recently user item in this case.\n+\t * But for further safety we also perform check here.\n+\t */\n+\twhile ((entry = hash_search(relkind_hash, &rinfo, HASH_ENTER_NULL, &found)) == NULL)\n+\t{\n+\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\tAssert(relkind_ctl->size > 0);\n+\t\trelkind_ctl->size -= 1;\n+\t}\n+\tif (!found)\n+\t{\n+\t\tif (++relkind_ctl->size == relkind_hash_size)\n+\t\t{\n+\t\t\t/*\n+\t\t\t * Remove least recently used elment from the hash.\n+\t\t\t * Hash size after is becomes `relkind_hash_size-1`.\n+\t\t\t * But it is not considered to be a problem, because size of this hash is expecrted large enough and +-1 doesn't matter.\n+\t\t\t */\n+\t\t\tRelKindEntry *victim = dlist_container(RelKindEntry, lru_node, dlist_pop_head_node(&relkind_ctl->lru));\n+\t\t\thash_search(relkind_hash, &victim->rel, HASH_REMOVE, NULL);\n+\t\t\trelkind_ctl->size -= 1;\n+\t\t}\n+\t\trelkind_ctl->pinned += 1;",
        "comment_created_at": "2025-06-11T15:46:08+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126658515",
    "pr_number": 12129,
    "pr_file": "pgxn/neon/walproposer.c",
    "created_at": "2025-06-04T13:50:18+00:00",
    "commented_code": "{\n \t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n \t\t}\n+\t\tif (*endptr != ':')",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2126658515",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12129,
        "pr_file": "pgxn/neon/walproposer.c",
        "discussion_id": "2126658515",
        "commented_code": "@@ -119,6 +119,10 @@ WalProposerCreate(WalProposerConfig *config, walproposer_api api)\n \t\t{\n \t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n \t\t}\n+\t\tif (*endptr != ':')",
        "comment_created_at": "2025-06-04T13:50:18+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "nit: Maybe reuse `split_off_safekeepers_generation` here? Looks exactly like it",
        "pr_file_module": null
      },
      {
        "comment_id": "2126690141",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12129,
        "pr_file": "pgxn/neon/walproposer.c",
        "discussion_id": "2126658515",
        "commented_code": "@@ -119,6 +119,10 @@ WalProposerCreate(WalProposerConfig *config, walproposer_api api)\n \t\t{\n \t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n \t\t}\n+\t\tif (*endptr != ':')",
        "comment_created_at": "2025-06-04T14:03:36+00:00",
        "comment_author": "arpad-m",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081211505",
    "pr_number": 11830,
    "pr_file": "pgxn/neon/walproposer.c",
    "created_at": "2025-05-09T08:38:43+00:00",
    "commented_code": "wp->mconf.members.len = 0;\n \twp->mconf.new_members.len = 0;\n \n-\twp_log(LOG, \"neon.safekeepers=%s\", wp->config->safekeepers_list);\n+\twp_log(LOG, \"neon.safekeeper_connstrings=%s\", wp->config->safekeeper_connstrings);\n \n \t/*\n \t * If safekeepers list starts with g# parse generation number followed by\n \t * :\n \t */\n-\tif (strncmp(wp->config->safekeepers_list, \"g#\", 2) == 0)\n+\tif (strncmp(wp->config->safekeeper_connstrings, \"g#\", 2) == 0)\n \t{\n \t\tchar\t   *endptr;\n \n \t\terrno = 0;\n-\t\twp->safekeepers_generation = strtoul(wp->config->safekeepers_list + 2, &endptr, 10);\n+\t\twp->safekeepers_generation = strtoul(wp->config->safekeeper_connstrings + 2, &endptr, 10);\n \t\tif (errno != 0)\n \t\t{\n-\t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n+\t\t\twp_log(FATAL, \"failed to parse neon.safekeeper_connstrings generation number: %m\");\n \t\t}\n \t\t/* Skip past : to the first hostname. */\n-\t\thost = endptr + 1;\n+\t\tconnstring = endptr + 1;\n \t}\n \telse\n \t{\n \t\twp->safekeepers_generation = INVALID_GENERATION;\n-\t\thost = wp->config->safekeepers_list;\n+\t\tconnstring = wp->config->safekeeper_connstrings;\n \t}\n \twp_log(LOG, \"safekeepers_generation=%u\", wp->safekeepers_generation);\n \n-\tfor (; host != NULL && *host != '\\0'; host = sep)\n+\tfor (; connstring != NULL && *connstring != '\\0'; connstring = sep)\n \t{\n-\t\tport = strchr(host, ':');\n-\t\tif (port == NULL)\n-\t\t{\n-\t\t\twp_log(FATAL, \"port is not specified\");\n-\t\t}\n-\t\t*port++ = '\\0';\n-\t\tsep = strchr(port, ',');\n+\t\tchar\t   *port;\n+\t\tchar\t   *errmsg;\n+\t\tSafekeeper *sk;\n+\t\tPQconninfoOption *conninfo_options, *option;\n+\n+\t\tsk = &wp->safekeeper[wp->n_safekeepers];\n+\n+\t\tsep = strchr(connstring, ',');\n \t\tif (sep != NULL)\n \t\t\t*sep++ = '\\0';\n \t\tif (wp->n_safekeepers + 1 >= MAX_SAFEKEEPERS)\n \t\t{\n \t\t\twp_log(FATAL, \"too many safekeepers\");\n \t\t}\n-\t\twp->safekeeper[wp->n_safekeepers].host = host;\n-\t\twp->safekeeper[wp->n_safekeepers].port = port;\n-\t\twp->safekeeper[wp->n_safekeepers].state = SS_OFFLINE;\n-\t\twp->safekeeper[wp->n_safekeepers].active_state = SS_ACTIVE_SEND;\n-\t\twp->safekeeper[wp->n_safekeepers].wp = wp;\n+\n+\t\t/* TODO(tristan957): Remove this compatibility code and only keep the\n+\t\t * else branch.\n+\t\t *\n+\t\t * Check if we have a connection string formatted as host:port, and use\n+\t\t * the old parsing code.\n+\t\t */",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2081211505",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11830,
        "pr_file": "pgxn/neon/walproposer.c",
        "discussion_id": "2081211505",
        "commented_code": "@@ -103,72 +104,122 @@ WalProposerCreate(WalProposerConfig *config, walproposer_api api)\n \twp->mconf.members.len = 0;\n \twp->mconf.new_members.len = 0;\n \n-\twp_log(LOG, \"neon.safekeepers=%s\", wp->config->safekeepers_list);\n+\twp_log(LOG, \"neon.safekeeper_connstrings=%s\", wp->config->safekeeper_connstrings);\n \n \t/*\n \t * If safekeepers list starts with g# parse generation number followed by\n \t * :\n \t */\n-\tif (strncmp(wp->config->safekeepers_list, \"g#\", 2) == 0)\n+\tif (strncmp(wp->config->safekeeper_connstrings, \"g#\", 2) == 0)\n \t{\n \t\tchar\t   *endptr;\n \n \t\terrno = 0;\n-\t\twp->safekeepers_generation = strtoul(wp->config->safekeepers_list + 2, &endptr, 10);\n+\t\twp->safekeepers_generation = strtoul(wp->config->safekeeper_connstrings + 2, &endptr, 10);\n \t\tif (errno != 0)\n \t\t{\n-\t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n+\t\t\twp_log(FATAL, \"failed to parse neon.safekeeper_connstrings generation number: %m\");\n \t\t}\n \t\t/* Skip past : to the first hostname. */\n-\t\thost = endptr + 1;\n+\t\tconnstring = endptr + 1;\n \t}\n \telse\n \t{\n \t\twp->safekeepers_generation = INVALID_GENERATION;\n-\t\thost = wp->config->safekeepers_list;\n+\t\tconnstring = wp->config->safekeeper_connstrings;\n \t}\n \twp_log(LOG, \"safekeepers_generation=%u\", wp->safekeepers_generation);\n \n-\tfor (; host != NULL && *host != '\\0'; host = sep)\n+\tfor (; connstring != NULL && *connstring != '\\0'; connstring = sep)\n \t{\n-\t\tport = strchr(host, ':');\n-\t\tif (port == NULL)\n-\t\t{\n-\t\t\twp_log(FATAL, \"port is not specified\");\n-\t\t}\n-\t\t*port++ = '\\0';\n-\t\tsep = strchr(port, ',');\n+\t\tchar\t   *port;\n+\t\tchar\t   *errmsg;\n+\t\tSafekeeper *sk;\n+\t\tPQconninfoOption *conninfo_options, *option;\n+\n+\t\tsk = &wp->safekeeper[wp->n_safekeepers];\n+\n+\t\tsep = strchr(connstring, ',');\n \t\tif (sep != NULL)\n \t\t\t*sep++ = '\\0';\n \t\tif (wp->n_safekeepers + 1 >= MAX_SAFEKEEPERS)\n \t\t{\n \t\t\twp_log(FATAL, \"too many safekeepers\");\n \t\t}\n-\t\twp->safekeeper[wp->n_safekeepers].host = host;\n-\t\twp->safekeeper[wp->n_safekeepers].port = port;\n-\t\twp->safekeeper[wp->n_safekeepers].state = SS_OFFLINE;\n-\t\twp->safekeeper[wp->n_safekeepers].active_state = SS_ACTIVE_SEND;\n-\t\twp->safekeeper[wp->n_safekeepers].wp = wp;\n+\n+\t\t/* TODO(tristan957): Remove this compatibility code and only keep the\n+\t\t * else branch.\n+\t\t *\n+\t\t * Check if we have a connection string formatted as host:port, and use\n+\t\t * the old parsing code.\n+\t\t */",
        "comment_created_at": "2025-05-09T08:38:43+00:00",
        "comment_author": "dimitri",
        "comment_body": "I would move that connection string parsing code to its own utility function. If you're going to internally always use host:port, have the utility function prepare that. I'm now used to using C struct to pass down writable parameters to a function, if that's helpful.",
        "pr_file_module": null
      }
    ]
  }
]