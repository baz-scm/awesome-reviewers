[
  {
    "discussion_id": "2177417025",
    "pr_number": 12416,
    "pr_file": "proxy/README.md",
    "created_at": "2025-07-01T12:00:26+00:00",
    "commented_code": "```sh\n PGSSLROOTCERT=./server.crt psql  \"postgresql://proxy:password@endpoint.local.neon.build:4432/postgres?sslmode=verify-full\"\n ```\n+\n+## auth broker setup:\n+\n+```sh\n+docker run \\\n+  --detach \\\n+  --name proxy-postgres \\\n+  --env POSTGRES_HOST_AUTH_METHOD=trust \\\n+  --env POSTGRES_USER=authenticated \\\n+  --env POSTGRES_DB=database \\\n+  --publish 5432:5432 \\\n+  postgres:17-bookworm\n+```\n+\n+```sh\n+cargo run --bin local_proxy -- \\\n+  --http 0.0.0.0:7432\n+```\n+\n+```sh\n+LOGFMT=text OTEL_SDK_DISABLED=true cargo run --bin proxy --features testing -- \\\n+  -c server.crt -k server.key \\\n+  --is-auth-broker true \\\n+  --wss 0.0.0.0:8080 \\\n+  --http 0.0.0.0:7002 \\\n+  --auth-backend local",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2177417025",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12416,
        "pr_file": "proxy/README.md",
        "discussion_id": "2177417025",
        "commented_code": "@@ -138,3 +138,40 @@ Now from client you can start a new session:\n ```sh\n PGSSLROOTCERT=./server.crt psql  \"postgresql://proxy:password@endpoint.local.neon.build:4432/postgres?sslmode=verify-full\"\n ```\n+\n+## auth broker setup:\n+\n+```sh\n+docker run \\\n+  --detach \\\n+  --name proxy-postgres \\\n+  --env POSTGRES_HOST_AUTH_METHOD=trust \\\n+  --env POSTGRES_USER=authenticated \\\n+  --env POSTGRES_DB=database \\\n+  --publish 5432:5432 \\\n+  postgres:17-bookworm\n+```\n+\n+```sh\n+cargo run --bin local_proxy -- \\\n+  --http 0.0.0.0:7432\n+```\n+\n+```sh\n+LOGFMT=text OTEL_SDK_DISABLED=true cargo run --bin proxy --features testing -- \\\n+  -c server.crt -k server.key \\\n+  --is-auth-broker true \\\n+  --wss 0.0.0.0:8080 \\\n+  --http 0.0.0.0:7002 \\\n+  --auth-backend local",
        "comment_created_at": "2025-07-01T12:00:26+00:00",
        "comment_author": "conradludgate",
        "comment_body": "This also needs an example for the local_proxy.json config file",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071308045",
    "pr_number": 11805,
    "pr_file": "docs/rfcs/0XY-feature-flag.md",
    "created_at": "2025-05-02T08:53:45+00:00",
    "commented_code": "+# Storage Feature Flags\n+\n+In this RFC, we will describe how we will implement per-tenant feature flags.\n+\n+## PostHog as Feature Flag Service\n+\n+Before we start, let's talk about how current feature flag services work. PostHog is the feature flag service we are currently using across multiple user-facing components in the company. PostHog has two modes of operation: HTTP evaluation and server-side local evaluation.\n+\n+Let's assume we have a storage feature flag called gc-compaction and we want to roll it out to scale-tier users with resident size >= 10GB and <= 100GB.\n+\n+### Define User Profiles\n+\n+The first step is to synchronize our user profiles to the PostHog service. We can simply assume that each tenant is a user in PostHog. Each user profile has some properties associated with it. In our case, it will be: plan type (free, scale, enterprise, etc); resident size (in bytes); primary pageserver (string); region (string).\n+\n+### Define Feature Flags\n+\n+We would create a feature flag called gc-compaction in PostHog with 4 variants: disabled, stage-1, stage-2, fully-enabled. We will flip the feature flags from disabled to fully-enabled stage by stage for some percentage of our users.\n+\n+### Option 1: HTTP Evaluation Mode\n+\n+When using PostHog's HTTP evaluation mode, the client will make request to the PostHog service, asking for the value of a feature flag for a specific user.\n+\n+* Control plane will report the plan type to PostHog each time it attaches a tenant to the storcon or when the user upgrades/downgrades. It calls the PostHog profile API to associate tenant ID with the plan type. Assume we have X active tenants and such attach or plan change event happens each week, that would be 4X profile update requests per month.\n+* Pageservers will report the resident size and the primary pageserver to the PostHog service. Assume we report resident size every 24 hours, that would be 30X requests per month.\n+* Each tenant will request the state of the feature flag every 1 hour, that's 720X requests per month.\n+* The Rust client would be easy to implement as we only need to call the `/decide` API on PostHog.\n+\n+Using the HTTP evaluation mode we will issue 754X requests a month.\n+\n+### Option 2: Local Evaluation Mode\n+\n+When using PostHog's HTTP evaluation mode, the client (usually the server in a browser/server architecture) will poll the feature flag configuration every minute from PostHog. Such configuration contains data like:\n+\n+<details>\n+\n+<summary>Example JSON response from the PostHog local evaluation API</summary>\n+\n+```\n+[\n+    {\n+        \"id\": 1,\n+        \"name\": \"Beta Feature\",\n+        \"key\": \"person-flag\",\n+        \"is_simple_flag\": True,\n+        \"active\": True,\n+        \"filters\": {\n+            \"groups\": [\n+                {\n+                    \"properties\": [\n+                        {\n+                            \"key\": \"location\",\n+                            \"operator\": \"exact\",\n+                            \"value\": [\"Straße\"],\n+                            \"type\": \"person\",\n+                        }\n+                    ],\n+                    \"rollout_percentage\": 100,\n+                },\n+                {\n+                    \"properties\": [\n+                        {\n+                            \"key\": \"star\",\n+                            \"operator\": \"exact\",\n+                            \"value\": [\"ſun\"],\n+                            \"type\": \"person\",\n+                        }\n+                    ],\n+                    \"rollout_percentage\": 100,\n+                },\n+            ],\n+        },\n+    }\n+]\n+```\n+\n+</details>\n+\n+Note that the API only contains information like \"under what condition => rollout percentage\". The user is responsible to provide the properties required to the client for local evaluation, and the PostHog service (web UI) cannot know if a feature is enabled for the tenant or not until the client uses the `capture` API to report the result back. To control the rollout percentage, the user ID gets mapped to a float number in `[0, 1)` on a consistent hash ring. All values <= the percentage will get the feature enabled or set to the desired value.",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2071308045",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11805,
        "pr_file": "docs/rfcs/0XY-feature-flag.md",
        "discussion_id": "2071308045",
        "commented_code": "@@ -0,0 +1,122 @@\n+# Storage Feature Flags\n+\n+In this RFC, we will describe how we will implement per-tenant feature flags.\n+\n+## PostHog as Feature Flag Service\n+\n+Before we start, let's talk about how current feature flag services work. PostHog is the feature flag service we are currently using across multiple user-facing components in the company. PostHog has two modes of operation: HTTP evaluation and server-side local evaluation.\n+\n+Let's assume we have a storage feature flag called gc-compaction and we want to roll it out to scale-tier users with resident size >= 10GB and <= 100GB.\n+\n+### Define User Profiles\n+\n+The first step is to synchronize our user profiles to the PostHog service. We can simply assume that each tenant is a user in PostHog. Each user profile has some properties associated with it. In our case, it will be: plan type (free, scale, enterprise, etc); resident size (in bytes); primary pageserver (string); region (string).\n+\n+### Define Feature Flags\n+\n+We would create a feature flag called gc-compaction in PostHog with 4 variants: disabled, stage-1, stage-2, fully-enabled. We will flip the feature flags from disabled to fully-enabled stage by stage for some percentage of our users.\n+\n+### Option 1: HTTP Evaluation Mode\n+\n+When using PostHog's HTTP evaluation mode, the client will make request to the PostHog service, asking for the value of a feature flag for a specific user.\n+\n+* Control plane will report the plan type to PostHog each time it attaches a tenant to the storcon or when the user upgrades/downgrades. It calls the PostHog profile API to associate tenant ID with the plan type. Assume we have X active tenants and such attach or plan change event happens each week, that would be 4X profile update requests per month.\n+* Pageservers will report the resident size and the primary pageserver to the PostHog service. Assume we report resident size every 24 hours, that would be 30X requests per month.\n+* Each tenant will request the state of the feature flag every 1 hour, that's 720X requests per month.\n+* The Rust client would be easy to implement as we only need to call the `/decide` API on PostHog.\n+\n+Using the HTTP evaluation mode we will issue 754X requests a month.\n+\n+### Option 2: Local Evaluation Mode\n+\n+When using PostHog's HTTP evaluation mode, the client (usually the server in a browser/server architecture) will poll the feature flag configuration every minute from PostHog. Such configuration contains data like:\n+\n+<details>\n+\n+<summary>Example JSON response from the PostHog local evaluation API</summary>\n+\n+```\n+[\n+    {\n+        \"id\": 1,\n+        \"name\": \"Beta Feature\",\n+        \"key\": \"person-flag\",\n+        \"is_simple_flag\": True,\n+        \"active\": True,\n+        \"filters\": {\n+            \"groups\": [\n+                {\n+                    \"properties\": [\n+                        {\n+                            \"key\": \"location\",\n+                            \"operator\": \"exact\",\n+                            \"value\": [\"Straße\"],\n+                            \"type\": \"person\",\n+                        }\n+                    ],\n+                    \"rollout_percentage\": 100,\n+                },\n+                {\n+                    \"properties\": [\n+                        {\n+                            \"key\": \"star\",\n+                            \"operator\": \"exact\",\n+                            \"value\": [\"ſun\"],\n+                            \"type\": \"person\",\n+                        }\n+                    ],\n+                    \"rollout_percentage\": 100,\n+                },\n+            ],\n+        },\n+    }\n+]\n+```\n+\n+</details>\n+\n+Note that the API only contains information like \"under what condition => rollout percentage\". The user is responsible to provide the properties required to the client for local evaluation, and the PostHog service (web UI) cannot know if a feature is enabled for the tenant or not until the client uses the `capture` API to report the result back. To control the rollout percentage, the user ID gets mapped to a float number in `[0, 1)` on a consistent hash ring. All values <= the percentage will get the feature enabled or set to the desired value.",
        "comment_created_at": "2025-05-02T08:53:45+00:00",
        "comment_author": "jcsp",
        "comment_body": "Idea for a hack: if we accept percentage not quite being exact, we could:\r\n- map percentage to a bitmask on tenant ID, such that for example when we are asked to enable on 1/16th of tenants, we would enable it for all the tenant IDs starting 0x00 , or for 1/256th of tenants use tenant IDs starting 0x0000.\r\n- (this takes advantage of our tenant IDs being pseudorandom)\r\n- then, when we look at grafana dashboards, we could filter statistics by `tenant_id~=\"0x00.*\"` to get a view of whatever stats we want for the enabled cohort only.\r\n\r\nThis only works when we're not also filtering on other things like plan, but it would be really powerful to be able to set a feature flag and then view e.g. latency histograms for tenants where the flag is set.\r\n\r\nWe might need to rotate the way we map percentages to masks to avoid tenant with certain prefixes always being the \"test subjects\" for new functionality.",
        "pr_file_module": null
      }
    ]
  }
]