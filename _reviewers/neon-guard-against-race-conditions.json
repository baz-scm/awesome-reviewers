[
  {
    "discussion_id": "2150211030",
    "pr_number": 12092,
    "pr_file": "pgxn/neon/pagestore_smgr.c",
    "created_at": "2025-06-16T14:51:15+00:00",
    "commented_code": "#endif\n \t\t\t{\n \t\t\t\t/* It exists locally. Guess it's unlogged then. */\n+\t\t\t\tif (mdnblocks(reln, forknum) >= blocknum)\n+\t\t\t\t{\n+\t\t\t\t\t/* prevent race condition with unlogged build end which unlinks local files */",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2150211030",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12092,
        "pr_file": "pgxn/neon/pagestore_smgr.c",
        "discussion_id": "2150211030",
        "commented_code": "@@ -1604,19 +1604,23 @@ neon_write(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, const vo\n #endif\n \t\t\t{\n \t\t\t\t/* It exists locally. Guess it's unlogged then. */\n+\t\t\t\tif (mdnblocks(reln, forknum) >= blocknum)\n+\t\t\t\t{\n+\t\t\t\t\t/* prevent race condition with unlogged build end which unlinks local files */",
        "comment_created_at": "2025-06-16T14:51:15+00:00",
        "comment_author": "hlinnaka",
        "comment_body": "This needs a comment to explain why `mdnblocks` is called. The caller is never supposed to call smgrwrite() with a block that's beyond the EOF, so this call looks pointless.",
        "pr_file_module": null
      },
      {
        "comment_id": "2150286734",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12092,
        "pr_file": "pgxn/neon/pagestore_smgr.c",
        "discussion_id": "2150211030",
        "commented_code": "@@ -1604,19 +1604,23 @@ neon_write(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, const vo\n #endif\n \t\t\t{\n \t\t\t\t/* It exists locally. Guess it's unlogged then. */\n+\t\t\t\tif (mdnblocks(reln, forknum) >= blocknum)\n+\t\t\t\t{\n+\t\t\t\t\t/* prevent race condition with unlogged build end which unlinks local files */",
        "comment_created_at": "2025-06-16T15:23:26+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2121110196",
    "pr_number": 12090,
    "pr_file": "pgxn/neon/walproposer_pg.c",
    "created_at": "2025-06-02T13:10:00+00:00",
    "commented_code": "return true;\n }\n \n-/*\n- * GUC assign_hook for neon.safekeepers. Restarts walproposer through FATAL if\n- * the list changed.\n- */\n static void\n assign_neon_safekeepers(const char *newval, void *extra)\n {\n \tchar\t   *newval_copy;\n \tchar\t   *oldval;\n \n+\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2121110196",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2121110196",
        "commented_code": "@@ -294,16 +301,15 @@ safekeepers_cmp(char *old, char *new)\n \treturn true;\n }\n \n-/*\n- * GUC assign_hook for neon.safekeepers. Restarts walproposer through FATAL if\n- * the list changed.\n- */\n static void\n assign_neon_safekeepers(const char *newval, void *extra)\n {\n \tchar\t   *newval_copy;\n \tchar\t   *oldval;\n \n+\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())",
        "comment_created_at": "2025-06-02T13:10:00+00:00",
        "comment_author": "MMeent",
        "comment_body": "Shouldn't `IsUnderPostmaster` be a better approach than these rather arbitrary conditions?\r\n\r\nI.e. \r\n```suggestion\r\n\tif (newval && *newval != '\\0' && IsUnderPostmaster && RecoveryInProgress())\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2121176811",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2121110196",
        "commented_code": "@@ -294,16 +301,15 @@ safekeepers_cmp(char *old, char *new)\n \treturn true;\n }\n \n-/*\n- * GUC assign_hook for neon.safekeepers. Restarts walproposer through FATAL if\n- * the list changed.\n- */\n static void\n assign_neon_safekeepers(const char *newval, void *extra)\n {\n \tchar\t   *newval_copy;\n \tchar\t   *oldval;\n \n+\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())",
        "comment_created_at": "2025-06-02T13:35:39+00:00",
        "comment_author": "knizhnik",
        "comment_body": "This really strange check is used to ensure that shared memory is initialized and not detached (as done by PG14 for stat process).\r\nSo checking it with `IsUnderPostmaster` is not correct.\r\nSimilar check is done in several other places in our codeL:\r\n```\r\nfile_cache-inmem.c\u0000205:\tif (!lfc_ctl || !UsedShmemSegAddr || IsParallelWorker())\r\nfile_cache.c\u0000395:\t * SIGHUP and it has access to shared memory (UsedShmemSegAddr != NULL),\r\nfile_cache.c\u0000398:\treturn lfc_ctl && MyProc && UsedShmemSegAddr && !IsParallelWorker();\r\nlibpagestore.c\u0000183:\treturn pagestore_shared && UsedShmemSegAddr;\r\nwalproposer_pg.c\u0000314:\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())\r\n```\r\nMay be it will be good to somehow refactor it and use single function for it.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2121190481",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2121110196",
        "commented_code": "@@ -294,16 +301,15 @@ safekeepers_cmp(char *old, char *new)\n \treturn true;\n }\n \n-/*\n- * GUC assign_hook for neon.safekeepers. Restarts walproposer through FATAL if\n- * the list changed.\n- */\n static void\n assign_neon_safekeepers(const char *newval, void *extra)\n {\n \tchar\t   *newval_copy;\n \tchar\t   *oldval;\n \n+\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())",
        "comment_created_at": "2025-06-02T13:40:01+00:00",
        "comment_author": "MMeent",
        "comment_body": "Yeah, it's weird that we're checking for the availability of shmem when we know that shmem should be available exactly when we run code with `IsUnderPostmaster`. AFAIK there is no valid reason why we should be unable to access shared memory in `IsUnderPostmaster` processes.",
        "pr_file_module": null
      },
      {
        "comment_id": "2123816997",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2121110196",
        "commented_code": "@@ -294,16 +301,15 @@ safekeepers_cmp(char *old, char *new)\n \treturn true;\n }\n \n-/*\n- * GUC assign_hook for neon.safekeepers. Restarts walproposer through FATAL if\n- * the list changed.\n- */\n static void\n assign_neon_safekeepers(const char *newval, void *extra)\n {\n \tchar\t   *newval_copy;\n \tchar\t   *oldval;\n \n+\tif (newval && *newval != '\\0' && UsedShmemSegAddr && walprop_shared && RecoveryInProgress())",
        "comment_created_at": "2025-06-03T13:28:05+00:00",
        "comment_author": "knizhnik",
        "comment_body": "In stat process in PG14 `IsUnderPostmaster` is true, but shared memory is detached.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081826973",
    "pr_number": 11880,
    "pr_file": "pgxn/neon/libpagestore.c",
    "created_at": "2025-05-09T14:38:30+00:00",
    "commented_code": "/*\n \t\t * If we did other tasks between reconnect attempts, then we won't\n \t\t * need to wait as long as a full delay.\n+\t\t *\n+\t\t * This is a loop to protect against interrupted sleeps.\n \t\t */\n-\t\tif (us_since_last_attempt < shard->delay_us)\n+\t\twhile (us_since_last_attempt < shard->delay_us)\n \t\t{\n+\t\t\tTimestampTz\tcurrent_time;\n \t\t\tpg_usleep(shard->delay_us - us_since_last_attempt);\n+\n+\t\t\t/* At least we should handle cancellations here */\n+\t\t\tCHECK_FOR_INTERRUPTS();\n+\n+\t\t\tcurrent_time = GetCurrentTimestamp();\n+\t\t\tus_since_last_attempt = (int64) (current_time - shard->last_reconnect_time);\n \t\t}\n \n \t\t/* update the delay metric */\n \t\tshard->delay_us = Min(shard->delay_us * 2, MAX_RECONNECT_INTERVAL_USEC);\n+\t\tshard->last_reconnect_time = now;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2081826973",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11880,
        "pr_file": "pgxn/neon/libpagestore.c",
        "discussion_id": "2081826973",
        "commented_code": "@@ -447,14 +446,24 @@ pageserver_connect(shardno_t shard_no, int elevel)\n \t\t/*\n \t\t * If we did other tasks between reconnect attempts, then we won't\n \t\t * need to wait as long as a full delay.\n+\t\t *\n+\t\t * This is a loop to protect against interrupted sleeps.\n \t\t */\n-\t\tif (us_since_last_attempt < shard->delay_us)\n+\t\twhile (us_since_last_attempt < shard->delay_us)\n \t\t{\n+\t\t\tTimestampTz\tcurrent_time;\n \t\t\tpg_usleep(shard->delay_us - us_since_last_attempt);\n+\n+\t\t\t/* At least we should handle cancellations here */\n+\t\t\tCHECK_FOR_INTERRUPTS();\n+\n+\t\t\tcurrent_time = GetCurrentTimestamp();\n+\t\t\tus_since_last_attempt = (int64) (current_time - shard->last_reconnect_time);\n \t\t}\n \n \t\t/* update the delay metric */\n \t\tshard->delay_us = Min(shard->delay_us * 2, MAX_RECONNECT_INTERVAL_USEC);\n+\t\tshard->last_reconnect_time = now;",
        "comment_created_at": "2025-05-09T14:38:30+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "We'll need to take a new clock reading here, otherwise we're populating it with a stale timestamp and shortening the next backoff delay.\r\n\r\nAlternatively, update `now` at the end of the backoff loop.",
        "pr_file_module": null
      },
      {
        "comment_id": "2081951493",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11880,
        "pr_file": "pgxn/neon/libpagestore.c",
        "discussion_id": "2081826973",
        "commented_code": "@@ -447,14 +446,24 @@ pageserver_connect(shardno_t shard_no, int elevel)\n \t\t/*\n \t\t * If we did other tasks between reconnect attempts, then we won't\n \t\t * need to wait as long as a full delay.\n+\t\t *\n+\t\t * This is a loop to protect against interrupted sleeps.\n \t\t */\n-\t\tif (us_since_last_attempt < shard->delay_us)\n+\t\twhile (us_since_last_attempt < shard->delay_us)\n \t\t{\n+\t\t\tTimestampTz\tcurrent_time;\n \t\t\tpg_usleep(shard->delay_us - us_since_last_attempt);\n+\n+\t\t\t/* At least we should handle cancellations here */\n+\t\t\tCHECK_FOR_INTERRUPTS();\n+\n+\t\t\tcurrent_time = GetCurrentTimestamp();\n+\t\t\tus_since_last_attempt = (int64) (current_time - shard->last_reconnect_time);\n \t\t}\n \n \t\t/* update the delay metric */\n \t\tshard->delay_us = Min(shard->delay_us * 2, MAX_RECONNECT_INTERVAL_USEC);\n+\t\tshard->last_reconnect_time = now;",
        "comment_created_at": "2025-05-09T15:37:05+00:00",
        "comment_author": "MMeent",
        "comment_body": "Fixed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2081826973",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11880,
        "pr_file": "pgxn/neon/libpagestore.c",
        "discussion_id": "2081826973",
        "commented_code": "@@ -447,14 +446,24 @@ pageserver_connect(shardno_t shard_no, int elevel)\n \t\t/*\n \t\t * If we did other tasks between reconnect attempts, then we won't\n \t\t * need to wait as long as a full delay.\n+\t\t *\n+\t\t * This is a loop to protect against interrupted sleeps.\n \t\t */\n-\t\tif (us_since_last_attempt < shard->delay_us)\n+\t\twhile (us_since_last_attempt < shard->delay_us)\n \t\t{\n+\t\t\tTimestampTz\tcurrent_time;\n \t\t\tpg_usleep(shard->delay_us - us_since_last_attempt);\n+\n+\t\t\t/* At least we should handle cancellations here */\n+\t\t\tCHECK_FOR_INTERRUPTS();\n+\n+\t\t\tcurrent_time = GetCurrentTimestamp();\n+\t\t\tus_since_last_attempt = (int64) (current_time - shard->last_reconnect_time);\n \t\t}\n \n \t\t/* update the delay metric */\n \t\tshard->delay_us = Min(shard->delay_us * 2, MAX_RECONNECT_INTERVAL_USEC);\n+\t\tshard->last_reconnect_time = now;",
        "comment_created_at": "2025-05-09T14:38:30+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "We'll need to take a new clock reading here, otherwise we're populating it with a stale timestamp and shortening the next backoff delay.\r\n\r\nAlternatively, update `now` at the end of the backoff loop.",
        "pr_file_module": null
      },
      {
        "comment_id": "2081951493",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11880,
        "pr_file": "pgxn/neon/libpagestore.c",
        "discussion_id": "2081826973",
        "commented_code": "@@ -447,14 +446,24 @@ pageserver_connect(shardno_t shard_no, int elevel)\n \t\t/*\n \t\t * If we did other tasks between reconnect attempts, then we won't\n \t\t * need to wait as long as a full delay.\n+\t\t *\n+\t\t * This is a loop to protect against interrupted sleeps.\n \t\t */\n-\t\tif (us_since_last_attempt < shard->delay_us)\n+\t\twhile (us_since_last_attempt < shard->delay_us)\n \t\t{\n+\t\t\tTimestampTz\tcurrent_time;\n \t\t\tpg_usleep(shard->delay_us - us_since_last_attempt);\n+\n+\t\t\t/* At least we should handle cancellations here */\n+\t\t\tCHECK_FOR_INTERRUPTS();\n+\n+\t\t\tcurrent_time = GetCurrentTimestamp();\n+\t\t\tus_since_last_attempt = (int64) (current_time - shard->last_reconnect_time);\n \t\t}\n \n \t\t/* update the delay metric */\n \t\tshard->delay_us = Min(shard->delay_us * 2, MAX_RECONNECT_INTERVAL_USEC);\n+\t\tshard->last_reconnect_time = now;",
        "comment_created_at": "2025-05-09T15:37:05+00:00",
        "comment_author": "MMeent",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  }
]