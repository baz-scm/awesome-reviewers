[
  {
    "discussion_id": "2190017174",
    "pr_number": 12371,
    "pr_file": "pgxn/neon/communicator.c",
    "created_at": "2025-07-07T13:03:43+00:00",
    "commented_code": "/*\n \t\t\t * Ignore errors\n \t\t\t */\n-\t\t\tif (slot->response->tag != T_NeonGetPageResponse)\n+\t\t\tif (slot->response->tag == T_NeonErrorResponse)",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2190017174",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190017174",
        "commented_code": "@@ -1027,14 +1096,8 @@ communicator_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forknum, BlockNumbe\n \t\t\t/*\n \t\t\t * Ignore errors\n \t\t\t */\n-\t\t\tif (slot->response->tag != T_NeonGetPageResponse)\n+\t\t\tif (slot->response->tag == T_NeonErrorResponse)",
        "comment_created_at": "2025-07-07T13:03:43+00:00",
        "comment_author": "MMeent",
        "comment_body": "Please add an Assert(slot->response->tag == T_NeonGetPageResponse) below the `continue` code block, so that any misplaced response in slot->response is caught, at least in debug builds.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190131124",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190017174",
        "commented_code": "@@ -1027,14 +1096,8 @@ communicator_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forknum, BlockNumbe\n \t\t\t/*\n \t\t\t * Ignore errors\n \t\t\t */\n-\t\t\tif (slot->response->tag != T_NeonGetPageResponse)\n+\t\t\tif (slot->response->tag == T_NeonErrorResponse)",
        "comment_created_at": "2025-07-07T13:34:13+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Please notice that right now this check is performed at the moment when response is assigned to slot by `check_getpage_response` function.\r\nThis is first thing that it does and panics if it is not true.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190138928",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190017174",
        "commented_code": "@@ -1027,14 +1096,8 @@ communicator_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forknum, BlockNumbe\n \t\t\t/*\n \t\t\t * Ignore errors\n \t\t\t */\n-\t\t\tif (slot->response->tag != T_NeonGetPageResponse)\n+\t\t\tif (slot->response->tag == T_NeonErrorResponse)",
        "comment_created_at": "2025-07-07T13:37:46+00:00",
        "comment_author": "MMeent",
        "comment_body": "Yes, but I'd rather have that check in place here as well, in case anything changes in other places that touch slot->response.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190191086",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190017174",
        "commented_code": "@@ -1027,14 +1096,8 @@ communicator_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forknum, BlockNumbe\n \t\t\t/*\n \t\t\t * Ignore errors\n \t\t\t */\n-\t\t\tif (slot->response->tag != T_NeonGetPageResponse)\n+\t\t\tif (slot->response->tag == T_NeonErrorResponse)",
        "comment_created_at": "2025-07-07T13:53:25+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Ok, will add assertion here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190070980",
    "pr_number": 12371,
    "pr_file": "pgxn/neon/communicator.c",
    "created_at": "2025-07-07T13:16:47+00:00",
    "commented_code": ".segno = segno\n \t};\n \n-\tdo\n-\t{\n-\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\tconsume_prefetch_responses();\n \n-\t\tconsume_prefetch_responses();\n+\tPG_TRY();\n+\t{\n+\t\tbefore_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\tdo\n+\t\t{\n+\t\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\t\t\tresp = page_server->receive(shard_no);\n+\t\t} while (resp == NULL);\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t}\n+\tPG_CATCH();\n+\t{\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\t/* Nothing should cancel disconnect: we should not leave connection in opaque state */\n+\t\tHOLD_INTERRUPTS();\n+\t\tpage_server->disconnect(shard_no);\n+\t\tRESUME_INTERRUPTS();\n \n-\t\tresp = page_server->receive(shard_no);\n-\t} while (resp == NULL);\n+\t\tPG_RE_THROW();\n+\t}\n+\tPG_END_TRY();",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2190070980",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190070980",
        "commented_code": "@@ -2383,14 +2418,29 @@ communicator_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *re\n \t\t.segno = segno\n \t};\n \n-\tdo\n-\t{\n-\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\tconsume_prefetch_responses();\n \n-\t\tconsume_prefetch_responses();\n+\tPG_TRY();\n+\t{\n+\t\tbefore_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\tdo\n+\t\t{\n+\t\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\t\t\tresp = page_server->receive(shard_no);\n+\t\t} while (resp == NULL);\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t}\n+\tPG_CATCH();\n+\t{\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\t/* Nothing should cancel disconnect: we should not leave connection in opaque state */\n+\t\tHOLD_INTERRUPTS();\n+\t\tpage_server->disconnect(shard_no);\n+\t\tRESUME_INTERRUPTS();\n \n-\t\tresp = page_server->receive(shard_no);\n-\t} while (resp == NULL);\n+\t\tPG_RE_THROW();\n+\t}\n+\tPG_END_TRY();",
        "comment_created_at": "2025-07-07T13:16:47+00:00",
        "comment_author": "MMeent",
        "comment_body": "So, is this the fix, or is there another component that's been fixed with this PR?",
        "pr_file_module": null
      },
      {
        "comment_id": "2190148649",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190070980",
        "commented_code": "@@ -2383,14 +2418,29 @@ communicator_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *re\n \t\t.segno = segno\n \t};\n \n-\tdo\n-\t{\n-\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\tconsume_prefetch_responses();\n \n-\t\tconsume_prefetch_responses();\n+\tPG_TRY();\n+\t{\n+\t\tbefore_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\tdo\n+\t\t{\n+\t\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\t\t\tresp = page_server->receive(shard_no);\n+\t\t} while (resp == NULL);\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t}\n+\tPG_CATCH();\n+\t{\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\t/* Nothing should cancel disconnect: we should not leave connection in opaque state */\n+\t\tHOLD_INTERRUPTS();\n+\t\tpage_server->disconnect(shard_no);\n+\t\tRESUME_INTERRUPTS();\n \n-\t\tresp = page_server->receive(shard_no);\n-\t} while (resp == NULL);\n+\t\tPG_RE_THROW();\n+\t}\n+\tPG_END_TRY();",
        "comment_created_at": "2025-07-07T13:41:02+00:00",
        "comment_author": "knizhnik",
        "comment_body": "There are several cases which can cause incorrect handling of errors or interrupts: when connection is not dropped or it is dropped put prefetch ring state is not reset.\r\nActually what I have done:\r\n1. Move `consume_prefetch_responses` prior to sending new (non-getpage request)\r\n2. Block interrupts while preforming disconnect (CHECK_FOR_INTERRUPTS can be called from any logging function and can cause exit from this function without actually dripping connection)\r\n3. Register `before_shmem_exit` to handle terminate backend requests which are not handled by `PG_TRY/PG_CATCH`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2192332665",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190070980",
        "commented_code": "@@ -2383,14 +2418,29 @@ communicator_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *re\n \t\t.segno = segno\n \t};\n \n-\tdo\n-\t{\n-\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\tconsume_prefetch_responses();\n \n-\t\tconsume_prefetch_responses();\n+\tPG_TRY();\n+\t{\n+\t\tbefore_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\tdo\n+\t\t{\n+\t\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\t\t\tresp = page_server->receive(shard_no);\n+\t\t} while (resp == NULL);\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t}\n+\tPG_CATCH();\n+\t{\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\t/* Nothing should cancel disconnect: we should not leave connection in opaque state */\n+\t\tHOLD_INTERRUPTS();\n+\t\tpage_server->disconnect(shard_no);\n+\t\tRESUME_INTERRUPTS();\n \n-\t\tresp = page_server->receive(shard_no);\n-\t} while (resp == NULL);\n+\t\tPG_RE_THROW();\n+\t}\n+\tPG_END_TRY();",
        "comment_created_at": "2025-07-08T12:08:04+00:00",
        "comment_author": "MMeent",
        "comment_body": "Hmm, I see. How come we're not handling termination -related errors in PG_CATCH? Because we can't recover from them?",
        "pr_file_module": null
      },
      {
        "comment_id": "2194660091",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12371,
        "pr_file": "pgxn/neon/communicator.c",
        "discussion_id": "2190070980",
        "commented_code": "@@ -2383,14 +2418,29 @@ communicator_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *re\n \t\t.segno = segno\n \t};\n \n-\tdo\n-\t{\n-\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\tconsume_prefetch_responses();\n \n-\t\tconsume_prefetch_responses();\n+\tPG_TRY();\n+\t{\n+\t\tbefore_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\tdo\n+\t\t{\n+\t\t\twhile (!page_server->send(shard_no, &request.hdr) || !page_server->flush(shard_no));\n+\t\t\tresp = page_server->receive(shard_no);\n+\t\t} while (resp == NULL);\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t}\n+\tPG_CATCH();\n+\t{\n+\t\tcancel_before_shmem_exit(prefetch_on_exit, Int32GetDatum(shard_no));\n+\t\t/* Nothing should cancel disconnect: we should not leave connection in opaque state */\n+\t\tHOLD_INTERRUPTS();\n+\t\tpage_server->disconnect(shard_no);\n+\t\tRESUME_INTERRUPTS();\n \n-\t\tresp = page_server->receive(shard_no);\n-\t} while (resp == NULL);\n+\t\tPG_RE_THROW();\n+\t}\n+\tPG_END_TRY();",
        "comment_created_at": "2025-07-09T10:27:31+00:00",
        "comment_author": "knizhnik",
        "comment_body": "FATAL errors are not matched by TRY/CATCH blocks. In this case proc_exit is called directly.\r\nSo we have not closed connection but still can communicate with PS in backend cleanup code (i.e. removing temp relations)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126624879",
    "pr_number": 12129,
    "pr_file": "pgxn/neon/walproposer_pg.c",
    "created_at": "2025-06-04T13:35:43+00:00",
    "commented_code": "return n_safekeepers;\n }\n \n+static char *split_off_safekeepers_generation(char *safekeepers_list, uint32 *generation)\n+{\n+\tchar\t   *endptr;\n+\n+\tif (strncmp(safekeepers_list, \"g#\", 2) != 0)\n+\t{\n+\t\treturn safekeepers_list;\n+\t}\n+\telse\n+\t{\n+\t\terrno = 0;\n+\t\t*generation = strtoul(safekeepers_list + 2, &endptr, 10);\n+\t\tif (errno != 0)\n+\t\t{\n+\t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n+\t\t}\n+\t\treturn endptr + 1;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2126624879",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12129,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2126624879",
        "commented_code": "@@ -272,6 +272,26 @@ split_safekeepers_list(char *safekeepers_list, char *safekeepers[])\n \treturn n_safekeepers;\n }\n \n+static char *split_off_safekeepers_generation(char *safekeepers_list, uint32 *generation)\n+{\n+\tchar\t   *endptr;\n+\n+\tif (strncmp(safekeepers_list, \"g#\", 2) != 0)\n+\t{\n+\t\treturn safekeepers_list;\n+\t}\n+\telse\n+\t{\n+\t\terrno = 0;\n+\t\t*generation = strtoul(safekeepers_list + 2, &endptr, 10);\n+\t\tif (errno != 0)\n+\t\t{\n+\t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n+\t\t}\n+\t\treturn endptr + 1;",
        "comment_created_at": "2025-06-04T13:35:43+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "If we set `safekeepers` guc to`g#123`, endptr will point to the `\\0` terminator. Here you skip the terminator and return a pointer past the string data. It will probably cause a segfault later in the code\r\n\r\nIt is an incorrect value, and cplane should never specify it, but the best practice for handling incorrect input is an error, not SIGSEGV :)\r\n\r\nNeed to check that `*endptr == ':'` ",
        "pr_file_module": null
      },
      {
        "comment_id": "2126654078",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12129,
        "pr_file": "pgxn/neon/walproposer_pg.c",
        "discussion_id": "2126624879",
        "commented_code": "@@ -272,6 +272,26 @@ split_safekeepers_list(char *safekeepers_list, char *safekeepers[])\n \treturn n_safekeepers;\n }\n \n+static char *split_off_safekeepers_generation(char *safekeepers_list, uint32 *generation)\n+{\n+\tchar\t   *endptr;\n+\n+\tif (strncmp(safekeepers_list, \"g#\", 2) != 0)\n+\t{\n+\t\treturn safekeepers_list;\n+\t}\n+\telse\n+\t{\n+\t\terrno = 0;\n+\t\t*generation = strtoul(safekeepers_list + 2, &endptr, 10);\n+\t\tif (errno != 0)\n+\t\t{\n+\t\t\twp_log(FATAL, \"failed to parse neon.safekeepers generation number: %m\");\n+\t\t}\n+\t\treturn endptr + 1;",
        "comment_created_at": "2025-06-04T13:48:19+00:00",
        "comment_author": "arpad-m",
        "comment_body": "added the check, both to `split_off_safekeepers_generation`, as well as to `WalProposerCreate` where I got part of the code from.",
        "pr_file_module": null
      }
    ]
  }
]