[
  {
    "discussion_id": "2169264578",
    "pr_number": 12294,
    "pr_file": "compute/etc/neon_collector.jsonnet",
    "created_at": "2025-06-26T14:51:51+00:00",
    "commented_code": "import 'sql_exporter/file_cache_read_wait_seconds_sum.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_bucket.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_count.libsonnet',\n+    import 'sql_exporter/frozen_xid_age.libsonnet',",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2169264578",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12294,
        "pr_file": "compute/etc/neon_collector.jsonnet",
        "discussion_id": "2169264578",
        "commented_code": "@@ -17,6 +17,7 @@\n     import 'sql_exporter/file_cache_read_wait_seconds_sum.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_bucket.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_count.libsonnet',\n+    import 'sql_exporter/frozen_xid_age.libsonnet',",
        "comment_created_at": "2025-06-26T14:51:51+00:00",
        "comment_author": "tristan957",
        "comment_body": "New metrics related to compute should be prefixed with `compute_`",
        "pr_file_module": null
      },
      {
        "comment_id": "2169270893",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12294,
        "pr_file": "compute/etc/neon_collector.jsonnet",
        "discussion_id": "2169264578",
        "commented_code": "@@ -17,6 +17,7 @@\n     import 'sql_exporter/file_cache_read_wait_seconds_sum.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_bucket.libsonnet',\n     import 'sql_exporter/file_cache_write_wait_seconds_count.libsonnet',\n+    import 'sql_exporter/frozen_xid_age.libsonnet',",
        "comment_created_at": "2025-06-26T14:54:42+00:00",
        "comment_author": "tristan957",
        "comment_body": "I would prefer that we start prefixing Postgres metrics with `postgres_` but it isn't something that we've discussed as a team.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177293734",
    "pr_number": 12294,
    "pr_file": "compute/etc/sql_exporter/compute_frozen_xid_age.libsonnet",
    "created_at": "2025-07-01T11:12:14+00:00",
    "commented_code": "+{\n+  metric_name: 'compute_frozen_xid_age',",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2177293734",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12294,
        "pr_file": "compute/etc/sql_exporter/compute_frozen_xid_age.libsonnet",
        "discussion_id": "2177293734",
        "commented_code": "@@ -0,0 +1,13 @@\n+{\n+  metric_name: 'compute_frozen_xid_age',",
        "comment_created_at": "2025-07-01T11:12:14+00:00",
        "comment_author": "ololobus",
        "comment_body": "As discussed, I'd use `compute_pg_` prefix to indicate that it comes from Postgres. Same for both metrics",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177318428",
    "pr_number": 12294,
    "pr_file": "compute/etc/sql_exporter/compute_min_mxid_age.libsonnet",
    "created_at": "2025-07-01T11:21:08+00:00",
    "commented_code": "+{\n+  metric_name: 'compute_min_mxid_age',",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2177318428",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12294,
        "pr_file": "compute/etc/sql_exporter/compute_min_mxid_age.libsonnet",
        "discussion_id": "2177318428",
        "commented_code": "@@ -0,0 +1,13 @@\n+{\n+  metric_name: 'compute_min_mxid_age',",
        "comment_created_at": "2025-07-01T11:21:08+00:00",
        "comment_author": "ololobus",
        "comment_body": "I think we should drop `min` from the metric. Yes, in the view it's min_mxid across all tables in this DB (same about `frozen_xid`, note PG naming consistency), but when you take age() and sort DESC you actually get oldest as it's properly mentioned in the description.\r\n\r\nSo I guess at the end metrics could be named like\r\n- compute_pg_oldest_frozen_xid_age\r\n- compute_pg_oldest_mxid_age\r\n\r\nor something",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072936236",
    "pr_number": 11815,
    "pr_file": "pageserver/page_api/proto/page_service.proto",
    "created_at": "2025-05-05T07:06:33+00:00",
    "commented_code": "+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2072936236",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2072936236",
        "commented_code": "@@ -0,0 +1,202 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);",
        "comment_created_at": "2025-05-05T07:06:33+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "nit: google style guide suggests using verbs in method names. `GetDbSize`, `CheckRelExists`, `GetRelSize`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072939628",
    "pr_number": 11815,
    "pr_file": "pageserver/page_api/proto/page_service.proto",
    "created_at": "2025-05-05T07:10:09+00:00",
    "commented_code": "+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+\n+  // Returns whether a relation exists.\n+  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);\n+}\n+\n+// Common request fields.\n+message RequestCommon {",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2072939628",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2072939628",
        "commented_code": "@@ -0,0 +1,202 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+\n+  // Returns whether a relation exists.\n+  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);\n+}\n+\n+// Common request fields.\n+message RequestCommon {",
        "comment_created_at": "2025-05-05T07:10:09+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "nit: I would rather call it `LsnInfo` or smth more specific than \"common\". I don't think it's going to be extended",
        "pr_file_module": null
      },
      {
        "comment_id": "2073106933",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2072939628",
        "commented_code": "@@ -0,0 +1,202 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+\n+  // Returns whether a relation exists.\n+  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);\n+}\n+\n+// Common request fields.\n+message RequestCommon {",
        "comment_created_at": "2025-05-05T09:12:22+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Renamed it to `ReadLsn`.\r\n\r\nI'm not sure `not_modified_since_lsn` is actually meaningful/useful for any other requests than `GetPage`. All requests do pass it on to `wait_or_get_last_lsn()`, and they _could_ make use of it, but I'm not sure if they actually do?\r\n\r\n@hlinnaka Wdyt, can we move `not_modified_since_lsn` onto `GetPageRequest`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2075488396",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11815,
        "pr_file": "pageserver/page_api/proto/page_service.proto",
        "discussion_id": "2072939628",
        "commented_code": "@@ -0,0 +1,202 @@\n+// Page service, presented by pageservers for computes.\n+//\n+// This is the compute read path. It primarily serves page versions at given\n+// LSNs, but also base backups, SLRU segments, and relation metadata.\n+//\n+// EXPERIMENTAL: this is still under development and subject to change.\n+//\n+// Request metadata headers:\n+// - authorization: JWT token (\"Bearer <token>\"), if auth is enabled\n+// - neon-tenant-id: tenant ID (\"7c4a1f9e3bd6470c8f3e21a65bd2e980\")\n+// - neon-shard-id: shard ID, as <number><count> in hex (\"0b10\" = shard 11 of 16, 0-based)\n+// - neon-timeline-id: timeline ID (\"f08c4e9a2d5f76b1e3a7c2d8910f4b3e\")\n+//\n+// TODO: write implementation guidance on\n+// - Health checks\n+// - Tracing, OpenTelemetry\n+// - Compression\n+\n+syntax = \"proto3\";\n+package page_service;\n+\n+service PageService {\n+  // Returns the total size of a database, as # of bytes.\n+  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);\n+\n+  // Fetches a base backup.\n+  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);\n+\n+  // Fetches pages.\n+  //\n+  // This is implemented as a bidirectional streaming RPC for performance. Unary\n+  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,\n+  // authentication, and so on -- with streaming, we only pay these costs during\n+  // the initial stream setup. This ~doubles throughput in benchmarks. Other\n+  // RPCs use regular unary requests, since they are not as frequent and\n+  // performance-critical, and this simplifies implementation.\n+  //\n+  // NB: a status response (e.g. errors) will terminate the stream. The stream\n+  // may be shared by e.g. multiple Postgres backends, so we should avoid this.\n+  // Most errors are therefore sent as GetPageResponse.status instead.\n+  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);\n+\n+  // Fetches an SLRU segment.\n+  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);\n+\n+  // Returns whether a relation exists.\n+  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);\n+\n+  // Returns the size of a relation, as # of blocks.\n+  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);\n+}\n+\n+// Common request fields.\n+message RequestCommon {",
        "comment_created_at": "2025-05-06T13:31:45+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Discussed in https://github.com/neondatabase/neon/pull/11815#pullrequestreview-2818183483.",
        "pr_file_module": null
      }
    ]
  }
]