[
  {
    "discussion_id": "1919683104",
    "pr_number": 10312,
    "pr_file": "pgxn/neon/file_cache_internal.h",
    "created_at": "2025-01-17T07:39:01+00:00",
    "commented_code": "+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "1919683104",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10312,
        "pr_file": "pgxn/neon/file_cache_internal.h",
        "discussion_id": "1919683104",
        "commented_code": "@@ -0,0 +1,266 @@\n+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new",
        "comment_created_at": "2025-01-17T07:39:01+00:00",
        "comment_author": "knizhnik",
        "comment_body": "It is true for prewarm, but if we are going to use the same mechanism for storing prefetch results in LFC as soon as they arrived, number of writer ca. be as larger as number of backends (`max_connections`) which can be thousands.",
        "pr_file_module": null
      },
      {
        "comment_id": "1922225273",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10312,
        "pr_file": "pgxn/neon/file_cache_internal.h",
        "discussion_id": "1919683104",
        "commented_code": "@@ -0,0 +1,266 @@\n+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new",
        "comment_created_at": "2025-01-20T11:05:09+00:00",
        "comment_author": "MMeent",
        "comment_body": "True, but I wouldn't expect them to be working on the LFC _concurrently_. Similar to the shared buffers partition locks and the WAL writers locks, I think we only need a limited amount of concurrent slots to satisfy the workload (e.g. 128), as we only really need the lock once we're ready to start loading data.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1919691139",
    "pr_number": 10312,
    "pr_file": "pgxn/neon/file_cache_internal.h",
    "created_at": "2025-01-17T07:47:16+00:00",
    "commented_code": "+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new\n+ *         `prewarm_worker_field` on chunk (this needs to be only a few bits,\n+ *         e.g. 8, as we only will likely have very few workers concurrently\n+ *         prewarming the LFC),\n+ *     3.  Copy the LFC entry's refcount into per-prewarmworker state's\n+ *         'wait_count', reduced by 1 (to account for the bgworker itself).",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "1919691139",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10312,
        "pr_file": "pgxn/neon/file_cache_internal.h",
        "discussion_id": "1919691139",
        "commented_code": "@@ -0,0 +1,266 @@\n+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new\n+ *         `prewarm_worker_field` on chunk (this needs to be only a few bits,\n+ *         e.g. 8, as we only will likely have very few workers concurrently\n+ *         prewarming the LFC),\n+ *     3.  Copy the LFC entry's refcount into per-prewarmworker state's\n+ *         'wait_count', reduced by 1 (to account for the bgworker itself).",
        "comment_created_at": "2025-01-17T07:47:16+00:00",
        "comment_author": "knizhnik",
        "comment_body": "Once again, if this mechanism is used not only for prewarm, but for normal backends, then maintaining per-bakend state is non-disarable.",
        "pr_file_module": null
      },
      {
        "comment_id": "1922237523",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10312,
        "pr_file": "pgxn/neon/file_cache_internal.h",
        "discussion_id": "1919691139",
        "commented_code": "@@ -0,0 +1,266 @@\n+#ifndef FILE_CACHE_INTERNAL_H\n+#define FILE_CACHE_INTERNAL_H\n+\n+#include \"lib/ilist.h\"\n+#include \"storage/buf_internals.h\"\n+#include \"storage/condition_variable.h\"\n+#include \"storage/lwlock.h\"\n+#include \"utils/dynahash.h\"\n+\n+#include \"hll.h\"\n+\n+/*-----------\n+ * Prewarming\n+ * ----------\n+ *\n+ * LFC prewarming happens with the use of one or more prewarm workers, which\n+ * should never access the same LFC chunk at the same time.\n+ *\n+ * The prewarm worker works with these invariants:\n+ *\t\t1. There are no concurrent writes to the pages that the prewarm worker\n+ *\t\t\tis writing to the chunk.\n+ *\t\t\tThis is guaranteed by these mechanisms: \n+ *\t\t\t - Before starting to write, a prewarm worker marks the chunk as\n+ *\t\t\t   \"prewarm is writing to this\", and then waits for all current\n+ *\t\t\t   accessors to finish their activities. Therefore, all users\n+ *\t\t\t   know that prewarm is active on the chunk.\n+ *\t\t\t - Prewarm workers will only write to as-of-yet unwritten blocks\n+ *\t\t\t   in the chunk.\n+ *\t\t\t - Writers to the chunk will wait for the prewarm worker to finish\n+ *\t\t\t   writing in the chunk before starting their own writes into\n+ *\t\t\t   as-of-yet unwritten blocks in the chunk.\n+ *\t\t\t - Readers won't be blocked (but can decide to wait for prewarm\n+ *\t\t\t   in case they need to read pages not yet in LFC, and prewarm is\n+ *\t\t\t   active on the chunk)\n+ *\t\t2. Pages are never overwritten by LFC prewarm\n+ *\t\t3. Readers are never blocked\n+ *\t\t4. Only potentially conflicting writers are blocked, *but are not ignored*.\n+ *\n+ * The only consideration is that in hot-standby mode, we *can not* ignore\n+ * writes to pages that are being prewarmed. Usually, that's not much of an\n+ * issue, but here we don't have a buffer that ensures synchronization between\n+ * the redo process and the contents of the page/buffer (which we'd otherwise\n+ * have). So, in REDO mode we'd have to make sure that the recovery process\n+ * DOES do redo for pages in chunks that are being prewarmed, even if that\n+ * means doing PS reads, to make sure we don't drop changes for pages we're\n+ * fetching through prewarm processes.\n+ *\n+ * The algorithm used is as follows:\n+ *\n+ * 1.  Select a chunk to prewarm.\n+ *     This requires the chunk to be present in LFC, or an empty chunk to be\n+ *     available in the LFC that we can then fill.\n+ *     If there are no empty chunks left, and the chunk we selected isn't\n+ *     present in the LFC, we skip this chunk as evicting data to prewarm other\n+ *     data may be detrimental to the workload.\n+ * 2.  Prepare the chunk: with exclusively locked LFC:\n+ *     1.  Note down which blocks are already written to the chunk.\n+ *         We don't have to read those blocks, as they're already the latest\n+ *         version.\n+ *         If we don't have any blocks left to fetch, we're done: restart at 1\n+ *     2.  Unlink the selected chunk from the LRU.\n+ *         Now it can't be removed through LRU eviction, so we know any new\n+ *         blocks written to the chunk will be the latest version of said pages.\n+ * 3.  Determine which blocks to retrieve (= selection from 1, with selection\n+ *     from 2.1 removed)\n+ * 4.  Prefetch the to-be-retrieved blocks of the chunk.\n+ * 5.  Read all to-be-retrieved blocks of the chunk into local memory.\n+ * 6.  With exclusively locked LFC:\n+ *     1.  Mark chunk as LFC_PREWARM_STARTED\n+ *     2.  Copy this backend's prewarmer worker number (if relevant) into new\n+ *         `prewarm_worker_field` on chunk (this needs to be only a few bits,\n+ *         e.g. 8, as we only will likely have very few workers concurrently\n+ *         prewarming the LFC),\n+ *     3.  Copy the LFC entry's refcount into per-prewarmworker state's\n+ *         'wait_count', reduced by 1 (to account for the bgworker itself).",
        "comment_created_at": "2025-01-20T11:14:15+00:00",
        "comment_author": "MMeent",
        "comment_body": "Yes, see https://github.com/neondatabase/neon/pull/10312#discussion_r1922225273 - we can limit this to a limited number of concurrent backends.\r\n\r\nNote that we'll only need a prewarm state once a backend has the prefetched data in memory (no need to hold an LFC entry for a not-yet-received prefetch entry; actually, holding that is dangerous for other backends that want to prefetch a set of pages from that chunk), and the turnaround time for prewarming is expected to be very small: it's quite unlikely you're waiting for a long time on concurrent backends to finish their work, as reasonably there are at most BLOCKS_PER_CHUNK backends that are doing IO on the LFC chunk, and each such IO probably won't take very long.",
        "pr_file_module": null
      }
    ]
  }
]