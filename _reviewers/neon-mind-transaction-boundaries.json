[
  {
    "discussion_id": "2121117518",
    "pr_number": 12090,
    "pr_file": "test_runner/regress/test_replica_promote.py",
    "created_at": "2025-06-02T13:13:31+00:00",
    "commented_code": "+\"\"\"\n+File with secondary->primary promotion testing.\n+\n+This far, only contains a test that we don't break and that the data is persisted.\n+\"\"\"\n+\n+import psycopg2\n+from fixtures.neon_fixtures import Endpoint, NeonEnv, wait_replica_caughtup\n+from fixtures.pg_version import PgVersion\n+from pytest import raises\n+\n+\n+def test_replica_promotes(neon_simple_env: NeonEnv, pg_version: PgVersion):\n+    \"\"\"\n+    Test that a replica safely promotes, and can commit data updates which\n+    show up when the primary boots up after the promoted secondary endpoint\n+    shut down.\n+    \"\"\"\n+\n+    # Initialize the primary, a test table, and a helper function to create lots\n+    # of subtransactions.\n+    env: NeonEnv = neon_simple_env\n+    primary: Endpoint = env.endpoints.create_start(branch_name=\"main\", endpoint_id=\"primary\")\n+    secondary: Endpoint = env.endpoints.new_replica_start(origin=primary, endpoint_id=\"secondary\")\n+\n+    with primary.connect() as primary_conn:\n+        primary_cur = primary_conn.cursor()\n+        primary_cur.execute(\n+            \"create table t(pk bigint GENERATED ALWAYS AS IDENTITY, payload integer)\"\n+        )\n+        primary_cur.execute(\"INSERT INTO t(payload) SELECT generate_series(1, 100)\")\n+        primary_cur.execute(\"select pg_switch_wal()\")\n+        primary_cur.execute(\"show neon.safekeepers\")\n+        safekeepers = primary_cur.fetchall()[0][0]\n+\n+    wait_replica_caughtup(primary, secondary)\n+\n+    with secondary.connect() as secondary_conn:\n+        secondary_cur = secondary_conn.cursor()\n+        secondary_cur.execute(\"select count(*) from t\")\n+\n+        assert secondary_cur.fetchone() == (100,)\n+\n+        with raises(psycopg2.Error):\n+            secondary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+            secondary_conn.commit()\n+\n+        secondary_conn.rollback()\n+        secondary_cur.execute(\"select count(*) from t\")\n+        assert secondary_cur.fetchone() == (100,)\n+\n+    wait_replica_caughtup(primary, secondary)\n+    primary.stop()\n+\n+    secondary_conn = secondary.connect()\n+    secondary_cur = secondary_conn.cursor()\n+\n+    secondary_cur.execute(f\"alter system set neon.safekeepers='{safekeepers}'\")\n+    secondary_cur.execute(\"select pg_reload_conf()\")\n+\n+    secondary_cur.execute(\"SELECT * FROM pg_promote()\")\n+    assert secondary_cur.fetchone() == (True,)\n+\n+    new_primary = secondary\n+    old_primary = primary\n+\n+    new_primary_conn = new_primary.connect()\n+    new_primary_cur = new_primary_conn.cursor()\n+    new_primary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+\n+    new_primary_cur.execute(\"select count(*) from t\")\n+    assert new_primary_cur.fetchone() == (200,)",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2121117518",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "test_runner/regress/test_replica_promote.py",
        "discussion_id": "2121117518",
        "commented_code": "@@ -0,0 +1,93 @@\n+\"\"\"\n+File with secondary->primary promotion testing.\n+\n+This far, only contains a test that we don't break and that the data is persisted.\n+\"\"\"\n+\n+import psycopg2\n+from fixtures.neon_fixtures import Endpoint, NeonEnv, wait_replica_caughtup\n+from fixtures.pg_version import PgVersion\n+from pytest import raises\n+\n+\n+def test_replica_promotes(neon_simple_env: NeonEnv, pg_version: PgVersion):\n+    \"\"\"\n+    Test that a replica safely promotes, and can commit data updates which\n+    show up when the primary boots up after the promoted secondary endpoint\n+    shut down.\n+    \"\"\"\n+\n+    # Initialize the primary, a test table, and a helper function to create lots\n+    # of subtransactions.\n+    env: NeonEnv = neon_simple_env\n+    primary: Endpoint = env.endpoints.create_start(branch_name=\"main\", endpoint_id=\"primary\")\n+    secondary: Endpoint = env.endpoints.new_replica_start(origin=primary, endpoint_id=\"secondary\")\n+\n+    with primary.connect() as primary_conn:\n+        primary_cur = primary_conn.cursor()\n+        primary_cur.execute(\n+            \"create table t(pk bigint GENERATED ALWAYS AS IDENTITY, payload integer)\"\n+        )\n+        primary_cur.execute(\"INSERT INTO t(payload) SELECT generate_series(1, 100)\")\n+        primary_cur.execute(\"select pg_switch_wal()\")\n+        primary_cur.execute(\"show neon.safekeepers\")\n+        safekeepers = primary_cur.fetchall()[0][0]\n+\n+    wait_replica_caughtup(primary, secondary)\n+\n+    with secondary.connect() as secondary_conn:\n+        secondary_cur = secondary_conn.cursor()\n+        secondary_cur.execute(\"select count(*) from t\")\n+\n+        assert secondary_cur.fetchone() == (100,)\n+\n+        with raises(psycopg2.Error):\n+            secondary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+            secondary_conn.commit()\n+\n+        secondary_conn.rollback()\n+        secondary_cur.execute(\"select count(*) from t\")\n+        assert secondary_cur.fetchone() == (100,)\n+\n+    wait_replica_caughtup(primary, secondary)\n+    primary.stop()\n+\n+    secondary_conn = secondary.connect()\n+    secondary_cur = secondary_conn.cursor()\n+\n+    secondary_cur.execute(f\"alter system set neon.safekeepers='{safekeepers}'\")\n+    secondary_cur.execute(\"select pg_reload_conf()\")\n+\n+    secondary_cur.execute(\"SELECT * FROM pg_promote()\")\n+    assert secondary_cur.fetchone() == (True,)\n+\n+    new_primary = secondary\n+    old_primary = primary\n+\n+    new_primary_conn = new_primary.connect()\n+    new_primary_cur = new_primary_conn.cursor()\n+    new_primary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+\n+    new_primary_cur.execute(\"select count(*) from t\")\n+    assert new_primary_cur.fetchone() == (200,)",
        "comment_created_at": "2025-06-02T13:13:31+00:00",
        "comment_author": "MMeent",
        "comment_body": "Could you please do better connection lifetime management here? It's quite bad to see the connections get leaked.",
        "pr_file_module": null
      },
      {
        "comment_id": "2121226606",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12090,
        "pr_file": "test_runner/regress/test_replica_promote.py",
        "discussion_id": "2121117518",
        "commented_code": "@@ -0,0 +1,93 @@\n+\"\"\"\n+File with secondary->primary promotion testing.\n+\n+This far, only contains a test that we don't break and that the data is persisted.\n+\"\"\"\n+\n+import psycopg2\n+from fixtures.neon_fixtures import Endpoint, NeonEnv, wait_replica_caughtup\n+from fixtures.pg_version import PgVersion\n+from pytest import raises\n+\n+\n+def test_replica_promotes(neon_simple_env: NeonEnv, pg_version: PgVersion):\n+    \"\"\"\n+    Test that a replica safely promotes, and can commit data updates which\n+    show up when the primary boots up after the promoted secondary endpoint\n+    shut down.\n+    \"\"\"\n+\n+    # Initialize the primary, a test table, and a helper function to create lots\n+    # of subtransactions.\n+    env: NeonEnv = neon_simple_env\n+    primary: Endpoint = env.endpoints.create_start(branch_name=\"main\", endpoint_id=\"primary\")\n+    secondary: Endpoint = env.endpoints.new_replica_start(origin=primary, endpoint_id=\"secondary\")\n+\n+    with primary.connect() as primary_conn:\n+        primary_cur = primary_conn.cursor()\n+        primary_cur.execute(\n+            \"create table t(pk bigint GENERATED ALWAYS AS IDENTITY, payload integer)\"\n+        )\n+        primary_cur.execute(\"INSERT INTO t(payload) SELECT generate_series(1, 100)\")\n+        primary_cur.execute(\"select pg_switch_wal()\")\n+        primary_cur.execute(\"show neon.safekeepers\")\n+        safekeepers = primary_cur.fetchall()[0][0]\n+\n+    wait_replica_caughtup(primary, secondary)\n+\n+    with secondary.connect() as secondary_conn:\n+        secondary_cur = secondary_conn.cursor()\n+        secondary_cur.execute(\"select count(*) from t\")\n+\n+        assert secondary_cur.fetchone() == (100,)\n+\n+        with raises(psycopg2.Error):\n+            secondary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+            secondary_conn.commit()\n+\n+        secondary_conn.rollback()\n+        secondary_cur.execute(\"select count(*) from t\")\n+        assert secondary_cur.fetchone() == (100,)\n+\n+    wait_replica_caughtup(primary, secondary)\n+    primary.stop()\n+\n+    secondary_conn = secondary.connect()\n+    secondary_cur = secondary_conn.cursor()\n+\n+    secondary_cur.execute(f\"alter system set neon.safekeepers='{safekeepers}'\")\n+    secondary_cur.execute(\"select pg_reload_conf()\")\n+\n+    secondary_cur.execute(\"SELECT * FROM pg_promote()\")\n+    assert secondary_cur.fetchone() == (True,)\n+\n+    new_primary = secondary\n+    old_primary = primary\n+\n+    new_primary_conn = new_primary.connect()\n+    new_primary_cur = new_primary_conn.cursor()\n+    new_primary_cur.execute(\"INSERT INTO t (payload) SELECT generate_series(101, 200)\")\n+\n+    new_primary_cur.execute(\"select count(*) from t\")\n+    assert new_primary_cur.fetchone() == (200,)",
        "comment_created_at": "2025-06-02T13:53:36+00:00",
        "comment_author": "knizhnik",
        "comment_body": "I am absolutely against using `with` construction in tests.\r\nIt is really very convenient and safe in real python database applications.\r\nBut in case of test connection lifetime management is not critical - leaking connection is not a problem, it is in any case dropped when endpoint is restarted or testis finished.\r\n\r\nThe main problem with `with` construction which cause many problems: it implicitly start new transaction and even in auto commit all code in `with` body is executed in one transaction.\r\n\r\nBut please notice that I have also added your version of the test which uses this `with` constructions for connections.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2063352361",
    "pr_number": 11726,
    "pr_file": "test_runner/fixtures/neon_fixtures.py",
    "created_at": "2025-04-28T10:11:33+00:00",
    "commented_code": "if last_flush_lsn is None:\n         last_flush_lsn = Lsn(endpoint.safe_psql(\"SELECT pg_current_wal_flush_lsn()\")[0][0])\n+        # The last_flush_lsn may not correspond to a record boundary.\n+        # For example, if the compute flushed WAL on a page boundary,\n+        # the remaining part of the record might not be flushed for a long time.\n+        # This would prevent the pageserver from reaching last_flush_lsn promptly.\n+        # To ensure the rest of the record reaches the pageserver quickly,\n+        # we forcibly flush the WAL by using pg_switch_wal().\n+        endpoint.safe_psql(\"SELECT pg_switch_wal()\")",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2063352361",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11726,
        "pr_file": "test_runner/fixtures/neon_fixtures.py",
        "discussion_id": "2063352361",
        "commented_code": "@@ -5459,6 +5459,13 @@ def wait_for_last_flush_lsn(\n \n     if last_flush_lsn is None:\n         last_flush_lsn = Lsn(endpoint.safe_psql(\"SELECT pg_current_wal_flush_lsn()\")[0][0])\n+        # The last_flush_lsn may not correspond to a record boundary.\n+        # For example, if the compute flushed WAL on a page boundary,\n+        # the remaining part of the record might not be flushed for a long time.\n+        # This would prevent the pageserver from reaching last_flush_lsn promptly.\n+        # To ensure the rest of the record reaches the pageserver quickly,\n+        # we forcibly flush the WAL by using pg_switch_wal().\n+        endpoint.safe_psql(\"SELECT pg_switch_wal()\")",
        "comment_created_at": "2025-04-28T10:11:33+00:00",
        "comment_author": "MMeent",
        "comment_body": "Both `CHECKPOINT` and `COMMIT` should be sufficient to flush current WAL.\r\n\r\nAdditionally, the `last_flush_lsn` is quite out-of-date by the time `pg_switch_wal()` has succeeded. Better use `SELECT pg_current_wal_insert_lsn()` and then run `CHECKPOINT`.",
        "pr_file_module": null
      }
    ]
  }
]