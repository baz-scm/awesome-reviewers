[
  {
    "discussion_id": "2100150318",
    "pr_number": 11963,
    "pr_file": ".github/workflows/periodic_pagebench.yml",
    "created_at": "2025-05-21T12:21:53+00:00",
    "commented_code": "with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2100150318",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11963,
        "pr_file": ".github/workflows/periodic_pagebench.yml",
        "discussion_id": "2100150318",
        "commented_code": "@@ -56,99 +64,191 @@ jobs:\n       with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do",
        "comment_created_at": "2025-05-21T12:21:53+00:00",
        "comment_author": "a-masterov",
        "comment_body": "Shouldn't we use double brackets, e.g., `[[ $attempt -lt $max_attempts ]]` for consistency?\r\nWe don't need to keep compatibility with the older versions of shell",
        "pr_file_module": null
      },
      {
        "comment_id": "2104099785",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11963,
        "pr_file": ".github/workflows/periodic_pagebench.yml",
        "discussion_id": "2100150318",
        "commented_code": "@@ -56,99 +64,191 @@ jobs:\n       with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do",
        "comment_created_at": "2025-05-23T08:31:02+00:00",
        "comment_author": "Bodobolero",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100267388",
    "pr_number": 11963,
    "pr_file": ".github/workflows/periodic_pagebench.yml",
    "created_at": "2025-05-21T13:14:17+00:00",
    "commented_code": "with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do\n+          set +e # the following command will fail until the artifacts are available\n+          S3_KEY=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix artifacts/$COMMIT_HASH/ | jq -r '.Contents[]?.Key' | grep neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst | sort --version-sort | tail -1)\n+          set -e\n+\n+          if [ -n \"$S3_KEY\" ]; then\n+            echo \"Artifact found: $S3_KEY\"\n+            echo \"S3_KEY=$S3_KEY\" >> $GITHUB_ENV\n             break\n-          elif [[ \"$status\" == \"too_many_runs\" ]]; then\n-            echo \"Too many runs already running\"\n-            echo \"too_many_runs=true\" >> \"$GITHUB_OUTPUT\"\n-            exit 1\n           fi\n-\n-          sleep 60 # Poll every 60 seconds\n+          \n+          # Increment attempt counter and sleep for 5 minutes\n+          attempt=$((attempt + 1))\n+          echo \"Attempt $attempt of $max_attempts to find artifacts in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH failed. Retrying in 5 minutes...\"\n+          sleep 300 # Sleep for 5 minutes\n         done\n \n-    - name: Retrieve Test Logs\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        if [ -z \"$S3_KEY\" ]; then\n+          echo \"Error: artifact not found in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH\" after 2 hours\n+        else\n+          mkdir -p $(dirname $ARCHIVE)\n+          time aws s3 cp --only-show-errors s3://$S3_BUCKET/${S3_KEY} ${ARCHIVE}\n+          mkdir -p ${NEON_DIR}\n+          time tar -xf ${ARCHIVE} -C ${NEON_DIR}\n+          rm -f ${ARCHIVE}\n+        fi\n+\n+    - name: Download snapshots from S3\n+      if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.recreate_snapshots == 'false' || github.event.inputs.recreate_snapshots == '' }}\n+      id: download_snapshots\n+      shell: bash -euxo pipefail {0}\n       run: |\n-        curl -k -X 'GET' \\\n-        \"${EC2_MACHINE_URL_US}/test_log/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/gzip' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        --output \"test_log_${GITHUB_RUN_ID}.gz\"\n-\n-    - name: Unzip Test Log and Print it into this job's log\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        # Download the snapshots from S3\n+        mkdir -p ${TEST_OUTPUT}\n+        mkdir -p $BACKUP_DIR\n+        cd $BACKUP_DIR\n+        mkdir parts\n+        cd parts\n+        PART=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix performance/pagebench/ \\\n+          | jq -r '.Contents[]?.Key' \\\n+          | grep -E 'shared-snapshots-[0-9]{4}-[0-9]{2}-[0-9]{2}' \\\n+          | sort \\\n+          | tail -1)\n+        echo \"Latest PART: $PART\"\n+        if [[ -z \"$PART\" ]]; then",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2100267388",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11963,
        "pr_file": ".github/workflows/periodic_pagebench.yml",
        "discussion_id": "2100267388",
        "commented_code": "@@ -56,99 +64,191 @@ jobs:\n       with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do\n+          set +e # the following command will fail until the artifacts are available\n+          S3_KEY=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix artifacts/$COMMIT_HASH/ | jq -r '.Contents[]?.Key' | grep neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst | sort --version-sort | tail -1)\n+          set -e\n+\n+          if [ -n \"$S3_KEY\" ]; then\n+            echo \"Artifact found: $S3_KEY\"\n+            echo \"S3_KEY=$S3_KEY\" >> $GITHUB_ENV\n             break\n-          elif [[ \"$status\" == \"too_many_runs\" ]]; then\n-            echo \"Too many runs already running\"\n-            echo \"too_many_runs=true\" >> \"$GITHUB_OUTPUT\"\n-            exit 1\n           fi\n-\n-          sleep 60 # Poll every 60 seconds\n+          \n+          # Increment attempt counter and sleep for 5 minutes\n+          attempt=$((attempt + 1))\n+          echo \"Attempt $attempt of $max_attempts to find artifacts in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH failed. Retrying in 5 minutes...\"\n+          sleep 300 # Sleep for 5 minutes\n         done\n \n-    - name: Retrieve Test Logs\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        if [ -z \"$S3_KEY\" ]; then\n+          echo \"Error: artifact not found in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH\" after 2 hours\n+        else\n+          mkdir -p $(dirname $ARCHIVE)\n+          time aws s3 cp --only-show-errors s3://$S3_BUCKET/${S3_KEY} ${ARCHIVE}\n+          mkdir -p ${NEON_DIR}\n+          time tar -xf ${ARCHIVE} -C ${NEON_DIR}\n+          rm -f ${ARCHIVE}\n+        fi\n+\n+    - name: Download snapshots from S3\n+      if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.recreate_snapshots == 'false' || github.event.inputs.recreate_snapshots == '' }}\n+      id: download_snapshots\n+      shell: bash -euxo pipefail {0}\n       run: |\n-        curl -k -X 'GET' \\\n-        \"${EC2_MACHINE_URL_US}/test_log/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/gzip' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        --output \"test_log_${GITHUB_RUN_ID}.gz\"\n-\n-    - name: Unzip Test Log and Print it into this job's log\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        # Download the snapshots from S3\n+        mkdir -p ${TEST_OUTPUT}\n+        mkdir -p $BACKUP_DIR\n+        cd $BACKUP_DIR\n+        mkdir parts\n+        cd parts\n+        PART=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix performance/pagebench/ \\\n+          | jq -r '.Contents[]?.Key' \\\n+          | grep -E 'shared-snapshots-[0-9]{4}-[0-9]{2}-[0-9]{2}' \\\n+          | sort \\\n+          | tail -1)\n+        echo \"Latest PART: $PART\"\n+        if [[ -z \"$PART\" ]]; then",
        "comment_created_at": "2025-05-21T13:14:17+00:00",
        "comment_author": "a-masterov",
        "comment_body": "If we use double brackets `[[ ]]`, quotes `\"\"` are redundant (but no harm if used)",
        "pr_file_module": null
      },
      {
        "comment_id": "2104122399",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11963,
        "pr_file": ".github/workflows/periodic_pagebench.yml",
        "discussion_id": "2100267388",
        "commented_code": "@@ -56,99 +64,191 @@ jobs:\n       with:\n         egress-policy: audit\n \n-    - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+    - name: Set up the environment which depends on $RUNNER_TEMP on nvme drive\n+      id: set-env\n+      shell: bash -euxo pipefail {0}\n+      run: |\n+        {\n+          echo \"NEON_DIR=${RUNNER_TEMP}/neon\"\n+          echo \"NEON_BIN=${RUNNER_TEMP}/neon/bin\"\n+          echo \"POSTGRES_DISTRIB_DIR=${RUNNER_TEMP}/neon/pg_install\"\n+          echo \"LD_LIBRARY_PATH=${RUNNER_TEMP}/neon/pg_install/v${DEFAULT_PG_VERSION}/lib\"\n+          echo \"BACKUP_DIR=${RUNNER_TEMP}/instance_store/saved_snapshots\"\n+          echo \"TEST_OUTPUT=${RUNNER_TEMP}/neon/test_output\"\n+          echo \"PERF_REPORT_DIR=${RUNNER_TEMP}/neon/test_output/perf-report-local\"\n+          echo \"ALLURE_DIR=${RUNNER_TEMP}/neon/test_output/allure-results\"\n+          echo \"ALLURE_RESULTS_DIR=${RUNNER_TEMP}/neon/test_output/allure-results/results\"\n+        } >> \"$GITHUB_ENV\"\n \n-    - name: Show my own (github runner) external IP address - usefull for IP allowlisting\n-      run: curl https://ifconfig.me\n+        echo \"allure_results_dir=${RUNNER_TEMP}/neon/test_output/allure-results/results\" >> \"$GITHUB_OUTPUT\"\n \n-    - name: Assume AWS OIDC role that allows to manage (start/stop/describe... EC machine)\n-      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n+    - uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2\n       with:\n         aws-region: eu-central-1\n-        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_MANAGE_BENCHMARK_EC2_VMS_ARN }}\n-        role-duration-seconds: 3600\n-\n-    - name: Start EC2 instance and wait for the instance to boot up\n-      run: |\n-        aws ec2 start-instances --instance-ids $AWS_INSTANCE_ID\n-        aws ec2 wait instance-running --instance-ids $AWS_INSTANCE_ID\n-        sleep 60 # sleep some time to allow cloudinit and our API server to start up\n-\n-    - name: Determine public IP of the EC2 instance and set env variable EC2_MACHINE_URL_US\n-      run: |\n-        public_ip=$(aws ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --query 'Reservations[*].Instances[*].PublicIpAddress' --output text)\n-        echo \"Public IP of the EC2 instance: $public_ip\"\n-        echo \"EC2_MACHINE_URL_US=https://${public_ip}:8443\" >> $GITHUB_ENV\n-\n+        role-to-assume: ${{ vars.DEV_AWS_OIDC_ROLE_ARN }}\n+        role-duration-seconds: 18000 # max 5 hours (needed in case commit hash is still being built)\n     - name: Determine commit hash\n+      id: commit_hash\n       env:\n         INPUT_COMMIT_HASH: ${{ github.event.inputs.commit_hash }}\n       run: |\n         if [ -z \"$INPUT_COMMIT_HASH\" ]; then\n-          echo \"COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\" >> $GITHUB_ENV\n+          COMMIT_HASH=$(curl -s https://api.github.com/repos/neondatabase/neon/commits/main | jq -r '.sha')\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=latest\" >> $GITHUB_ENV\n         else\n-          echo \"COMMIT_HASH=$INPUT_COMMIT_HASH\" >> $GITHUB_ENV\n+          COMMIT_HASH=\"$INPUT_COMMIT_HASH\"\n+          echo \"COMMIT_HASH=$COMMIT_HASH\" >> $GITHUB_ENV\n+          echo \"commit_hash=$COMMIT_HASH\" >> \"$GITHUB_OUTPUT\"\n           echo \"COMMIT_HASH_TYPE=manual\" >> $GITHUB_ENV\n         fi\n+    - name: Checkout the neon repository at given commit hash\n+      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+      with:\n+        ref: ${{ steps.commit_hash.outputs.commit_hash }}\n \n-    - name: Start Bench with run_id\n-      run: |\n-        curl -k -X 'POST' \\\n-        \"${EC2_MACHINE_URL_US}/start_test/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/json' \\\n-        -H 'Content-Type: application/json' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        -d \"{\\\"neonRepoCommitHash\\\": \\\"${COMMIT_HASH}\\\", \\\"neonRepoCommitHashType\\\": \\\"${COMMIT_HASH_TYPE}\\\"}\"\n-\n-    - name: Poll Test Status\n-      id: poll_step\n+    # does not reuse ./.github/actions/download because we need to download the artifact for the given commit hash\n+    # example artifact\n+    # s3://neon-github-public-dev/artifacts/48b870bc078bd2c450eb7b468e743b9c118549bf/15036827400/1/neon-Linux-X64-release-artifact.tar.zst /instance_store/artifacts/neon-Linux-release-artifact.tar.zst\n+    - name: Determine artifact S3_KEY for given commit hash and download and extract artifact\n+      id: artifact_prefix\n+      shell: bash -euxo pipefail {0}\n+      env:\n+        ARCHIVE: ${{ runner.temp }}/downloads/neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst\n+        COMMIT_HASH: ${{ env.COMMIT_HASH }}\n+        COMMIT_HASH_TYPE: ${{ env.COMMIT_HASH_TYPE }}\n       run: |\n-        status=\"\"\n-        while [[ \"$status\" != \"failure\" && \"$status\" != \"success\" ]]; do\n-          response=$(curl -k -X 'GET' \\\n-          \"${EC2_MACHINE_URL_US}/test_status/${GITHUB_RUN_ID}\" \\\n-          -H 'accept: application/json' \\\n-          -H \"Authorization: Bearer $API_KEY\")\n-          echo \"Response: $response\"\n-          set +x\n-          status=$(echo $response | jq -r '.status')\n-          echo \"Test status: $status\"\n-          if [[ \"$status\" == \"failure\" ]]; then\n-            echo \"Test failed\"\n-            exit 1 # Fail the job step if status is failure\n-          elif [[ \"$status\" == \"success\" || \"$status\" == \"null\" ]]; then\n+        attempt=0\n+        max_attempts=24 # 5 minutes * 24 = 2 hours\n+\n+        while [ $attempt -lt $max_attempts ]; do\n+          set +e # the following command will fail until the artifacts are available\n+          S3_KEY=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix artifacts/$COMMIT_HASH/ | jq -r '.Contents[]?.Key' | grep neon-${{ runner.os }}-${{ runner.arch }}-release-artifact.tar.zst | sort --version-sort | tail -1)\n+          set -e\n+\n+          if [ -n \"$S3_KEY\" ]; then\n+            echo \"Artifact found: $S3_KEY\"\n+            echo \"S3_KEY=$S3_KEY\" >> $GITHUB_ENV\n             break\n-          elif [[ \"$status\" == \"too_many_runs\" ]]; then\n-            echo \"Too many runs already running\"\n-            echo \"too_many_runs=true\" >> \"$GITHUB_OUTPUT\"\n-            exit 1\n           fi\n-\n-          sleep 60 # Poll every 60 seconds\n+          \n+          # Increment attempt counter and sleep for 5 minutes\n+          attempt=$((attempt + 1))\n+          echo \"Attempt $attempt of $max_attempts to find artifacts in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH failed. Retrying in 5 minutes...\"\n+          sleep 300 # Sleep for 5 minutes\n         done\n \n-    - name: Retrieve Test Logs\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        if [ -z \"$S3_KEY\" ]; then\n+          echo \"Error: artifact not found in S3 bucket s3://$S3_BUCKET/artifacts/$COMMIT_HASH\" after 2 hours\n+        else\n+          mkdir -p $(dirname $ARCHIVE)\n+          time aws s3 cp --only-show-errors s3://$S3_BUCKET/${S3_KEY} ${ARCHIVE}\n+          mkdir -p ${NEON_DIR}\n+          time tar -xf ${ARCHIVE} -C ${NEON_DIR}\n+          rm -f ${ARCHIVE}\n+        fi\n+\n+    - name: Download snapshots from S3\n+      if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.recreate_snapshots == 'false' || github.event.inputs.recreate_snapshots == '' }}\n+      id: download_snapshots\n+      shell: bash -euxo pipefail {0}\n       run: |\n-        curl -k -X 'GET' \\\n-        \"${EC2_MACHINE_URL_US}/test_log/${GITHUB_RUN_ID}\" \\\n-        -H 'accept: application/gzip' \\\n-        -H \"Authorization: Bearer $API_KEY\" \\\n-        --output \"test_log_${GITHUB_RUN_ID}.gz\"\n-\n-    - name: Unzip Test Log and Print it into this job's log\n-      if: always() && steps.poll_step.outputs.too_many_runs != 'true'\n+        # Download the snapshots from S3\n+        mkdir -p ${TEST_OUTPUT}\n+        mkdir -p $BACKUP_DIR\n+        cd $BACKUP_DIR\n+        mkdir parts\n+        cd parts\n+        PART=$(aws s3api list-objects-v2 --bucket $S3_BUCKET --prefix performance/pagebench/ \\\n+          | jq -r '.Contents[]?.Key' \\\n+          | grep -E 'shared-snapshots-[0-9]{4}-[0-9]{2}-[0-9]{2}' \\\n+          | sort \\\n+          | tail -1)\n+        echo \"Latest PART: $PART\"\n+        if [[ -z \"$PART\" ]]; then",
        "comment_created_at": "2025-05-23T08:43:42+00:00",
        "comment_author": "Bodobolero",
        "comment_body": "that is true for bash. However it\u2019s safe, consistent, and protects you if you later change to [ ... ] or embed it in scripts with stricter styles.",
        "pr_file_module": null
      }
    ]
  }
]