[
  {
    "discussion_id": "2159173408",
    "pr_number": 12308,
    "pr_file": "pgxn/neon_walredo/walredoproc.c",
    "created_at": "2025-06-20T15:00:27+00:00",
    "commented_code": "* it potentially leaked to us, _before_ we start processing potentially dangerous\n \t * wal records. See the comment in the Rust code that launches this process.\n \t */\n-\tif (close_range_syscall(3, ~0U, 0) != 0)\n+#define START_FD 3\n+#ifdef __NR_close_range\n+\tif (syscall(__NR_close_range, START_FD, ~0U, 0) != 0)\n \t\tereport(FATAL,\n \t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n-\t\t\t\t errmsg(\"seccomp: could not close files >= fd 3\")));\n+\t\t\t\t errmsg(\"seccomp: could not close files >= fd START_FD\")));\n+#else\n+\t// close_range can return EINVAL -- not our case as start_fd and end_fd are hardcoded.\n+\t// It doesn't return any other errors if CLOSE_RANGE_UNSHARE is not set so we don't\n+\t// report any errors here\n+\t#ifdef NO_CLOSE_RANGE\n+\t\t#warning \"__NR_close_range unavailable, using suboptimal implementation\"\n+\t\tint fd;\n+\t\tfor (fd = START_FD; fd <= INT_MAX; ++fd)\n+\t\t\tclose(fd);",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2159173408",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12308,
        "pr_file": "pgxn/neon_walredo/walredoproc.c",
        "discussion_id": "2159173408",
        "commented_code": "@@ -213,10 +209,25 @@ enter_seccomp_mode(void)\n \t * it potentially leaked to us, _before_ we start processing potentially dangerous\n \t * wal records. See the comment in the Rust code that launches this process.\n \t */\n-\tif (close_range_syscall(3, ~0U, 0) != 0)\n+#define START_FD 3\n+#ifdef __NR_close_range\n+\tif (syscall(__NR_close_range, START_FD, ~0U, 0) != 0)\n \t\tereport(FATAL,\n \t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n-\t\t\t\t errmsg(\"seccomp: could not close files >= fd 3\")));\n+\t\t\t\t errmsg(\"seccomp: could not close files >= fd START_FD\")));\n+#else\n+\t// close_range can return EINVAL -- not our case as start_fd and end_fd are hardcoded.\n+\t// It doesn't return any other errors if CLOSE_RANGE_UNSHARE is not set so we don't\n+\t// report any errors here\n+\t#ifdef NO_CLOSE_RANGE\n+\t\t#warning \"__NR_close_range unavailable, using suboptimal implementation\"\n+\t\tint fd;\n+\t\tfor (fd = START_FD; fd <= INT_MAX; ++fd)\n+\t\t\tclose(fd);",
        "comment_created_at": "2025-06-20T15:00:27+00:00",
        "comment_author": "hlinnaka",
        "comment_body": "Looping from 3..INT_MAX is _very_ expensive indeed...\r\n\r\nHow about https://www.gnu.org/software/libc/manual/html_node/Opening-and-Closing-Files.html#index-closefrom?",
        "pr_file_module": null
      },
      {
        "comment_id": "2159175473",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12308,
        "pr_file": "pgxn/neon_walredo/walredoproc.c",
        "discussion_id": "2159173408",
        "commented_code": "@@ -213,10 +209,25 @@ enter_seccomp_mode(void)\n \t * it potentially leaked to us, _before_ we start processing potentially dangerous\n \t * wal records. See the comment in the Rust code that launches this process.\n \t */\n-\tif (close_range_syscall(3, ~0U, 0) != 0)\n+#define START_FD 3\n+#ifdef __NR_close_range\n+\tif (syscall(__NR_close_range, START_FD, ~0U, 0) != 0)\n \t\tereport(FATAL,\n \t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n-\t\t\t\t errmsg(\"seccomp: could not close files >= fd 3\")));\n+\t\t\t\t errmsg(\"seccomp: could not close files >= fd START_FD\")));\n+#else\n+\t// close_range can return EINVAL -- not our case as start_fd and end_fd are hardcoded.\n+\t// It doesn't return any other errors if CLOSE_RANGE_UNSHARE is not set so we don't\n+\t// report any errors here\n+\t#ifdef NO_CLOSE_RANGE\n+\t\t#warning \"__NR_close_range unavailable, using suboptimal implementation\"\n+\t\tint fd;\n+\t\tfor (fd = START_FD; fd <= INT_MAX; ++fd)\n+\t\t\tclose(fd);",
        "comment_created_at": "2025-06-20T15:01:40+00:00",
        "comment_author": "hlinnaka",
        "comment_body": "oh, that also requires glibc 2.34",
        "pr_file_module": null
      },
      {
        "comment_id": "2159448997",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12308,
        "pr_file": "pgxn/neon_walredo/walredoproc.c",
        "discussion_id": "2159173408",
        "commented_code": "@@ -213,10 +209,25 @@ enter_seccomp_mode(void)\n \t * it potentially leaked to us, _before_ we start processing potentially dangerous\n \t * wal records. See the comment in the Rust code that launches this process.\n \t */\n-\tif (close_range_syscall(3, ~0U, 0) != 0)\n+#define START_FD 3\n+#ifdef __NR_close_range\n+\tif (syscall(__NR_close_range, START_FD, ~0U, 0) != 0)\n \t\tereport(FATAL,\n \t\t\t\t(errcode(ERRCODE_SYSTEM_ERROR),\n-\t\t\t\t errmsg(\"seccomp: could not close files >= fd 3\")));\n+\t\t\t\t errmsg(\"seccomp: could not close files >= fd START_FD\")));\n+#else\n+\t// close_range can return EINVAL -- not our case as start_fd and end_fd are hardcoded.\n+\t// It doesn't return any other errors if CLOSE_RANGE_UNSHARE is not set so we don't\n+\t// report any errors here\n+\t#ifdef NO_CLOSE_RANGE\n+\t\t#warning \"__NR_close_range unavailable, using suboptimal implementation\"\n+\t\tint fd;\n+\t\tfor (fd = START_FD; fd <= INT_MAX; ++fd)\n+\t\t\tclose(fd);",
        "comment_created_at": "2025-06-20T17:51:30+00:00",
        "comment_author": "myrrc",
        "comment_body": "Yeah, that's why I want to gate it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126351367",
    "pr_number": 10050,
    "pr_file": "pgxn/neon/neon_perf_counters.c",
    "created_at": "2025-06-04T11:20:22+00:00",
    "commented_code": "return i;\n }\n \n+static int\n+qt_histogram_to_metrics(QTHistogram histogram,\n+\t\t\t\t\t\tmetric_t *metrics,\n+\t\t\t\t\t\tconst char *count,\n+\t\t\t\t\t\tconst char *sum,\n+\t\t\t\t\t\tconst char *bucket)\n+{\n+\tint\t\ti = 0;\n+\tuint64\tbucket_accum = 0;\n+\n+\tmetrics[i].name = count;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_count;\n+\ti++;\n+\tmetrics[i].name = sum;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_sum / 1000000.0;\n+\ti++;\n+\tfor (int bucketno = 0; bucketno < NUM_QT_BUCKETS; bucketno++)\n+\t{\n+\t\tuint64\t\tthreshold = qt_bucket_thresholds[bucketno];\n+\n+\t\tbucket_accum += histogram->elapsed_us_bucket[bucketno];\n+\n+\t\tmetrics[i].name = bucket;\n+\t\tmetrics[i].is_bucket = true;\n+\t\tmetrics[i].bucket_le = (threshold == UINT64_MAX) ? INFINITY : ((double) threshold) / 1000000.0;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2126351367",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10050,
        "pr_file": "pgxn/neon/neon_perf_counters.c",
        "discussion_id": "2126351367",
        "commented_code": "@@ -145,10 +173,44 @@ histogram_to_metrics(IOHistogram histogram,\n \treturn i;\n }\n \n+static int\n+qt_histogram_to_metrics(QTHistogram histogram,\n+\t\t\t\t\t\tmetric_t *metrics,\n+\t\t\t\t\t\tconst char *count,\n+\t\t\t\t\t\tconst char *sum,\n+\t\t\t\t\t\tconst char *bucket)\n+{\n+\tint\t\ti = 0;\n+\tuint64\tbucket_accum = 0;\n+\n+\tmetrics[i].name = count;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_count;\n+\ti++;\n+\tmetrics[i].name = sum;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_sum / 1000000.0;\n+\ti++;\n+\tfor (int bucketno = 0; bucketno < NUM_QT_BUCKETS; bucketno++)\n+\t{\n+\t\tuint64\t\tthreshold = qt_bucket_thresholds[bucketno];\n+\n+\t\tbucket_accum += histogram->elapsed_us_bucket[bucketno];\n+\n+\t\tmetrics[i].name = bucket;\n+\t\tmetrics[i].is_bucket = true;\n+\t\tmetrics[i].bucket_le = (threshold == UINT64_MAX) ? INFINITY : ((double) threshold) / 1000000.0;",
        "comment_created_at": "2025-06-04T11:20:22+00:00",
        "comment_author": "myrrc",
        "comment_body": "A very minor thing, but as `threshold = UINT64_MAX` only for last bucket, we can loop from 0 to `NUM_QT_BUCKETS - 1`, write last iteration manually and avoid branching in assigning `bucket_le`",
        "pr_file_module": null
      },
      {
        "comment_id": "2126681166",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 10050,
        "pr_file": "pgxn/neon/neon_perf_counters.c",
        "discussion_id": "2126351367",
        "commented_code": "@@ -145,10 +173,44 @@ histogram_to_metrics(IOHistogram histogram,\n \treturn i;\n }\n \n+static int\n+qt_histogram_to_metrics(QTHistogram histogram,\n+\t\t\t\t\t\tmetric_t *metrics,\n+\t\t\t\t\t\tconst char *count,\n+\t\t\t\t\t\tconst char *sum,\n+\t\t\t\t\t\tconst char *bucket)\n+{\n+\tint\t\ti = 0;\n+\tuint64\tbucket_accum = 0;\n+\n+\tmetrics[i].name = count;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_count;\n+\ti++;\n+\tmetrics[i].name = sum;\n+\tmetrics[i].is_bucket = false;\n+\tmetrics[i].value = (double) histogram->elapsed_us_sum / 1000000.0;\n+\ti++;\n+\tfor (int bucketno = 0; bucketno < NUM_QT_BUCKETS; bucketno++)\n+\t{\n+\t\tuint64\t\tthreshold = qt_bucket_thresholds[bucketno];\n+\n+\t\tbucket_accum += histogram->elapsed_us_bucket[bucketno];\n+\n+\t\tmetrics[i].name = bucket;\n+\t\tmetrics[i].is_bucket = true;\n+\t\tmetrics[i].bucket_le = (threshold == UINT64_MAX) ? INFINITY : ((double) threshold) / 1000000.0;",
        "comment_created_at": "2025-06-04T13:59:40+00:00",
        "comment_author": "knizhnik",
        "comment_body": "I do not think that this code is performance critical.\r\nSo it is better to keep it simpler and straightforward rather than try to optimise it.\r\nThis cold assignment can be easily avoided by doing `metrics[NUM_QT_BUCKETS].bucket_le = INFINITY` after the loop.  But pleas notice thatI have not written this function: it is just cut&paste of existed `histogram_to_metrics` function. If it needs to be optimised, then it should be done in separate PR.\r\n",
        "pr_file_module": null
      }
    ]
  }
]