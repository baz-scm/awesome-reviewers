[
  {
    "discussion_id": "2160958710",
    "pr_number": 12233,
    "pr_file": "pageserver/src/http/routes.rs",
    "created_at": "2025-06-23T07:56:07+00:00",
    "commented_code": ".await\n }\n \n+async fn force_override_feature_flag_for_testing_put(\n+    request: Request<Body>,\n+    _cancel: CancellationToken,\n+) -> Result<Response<Body>, ApiError> {\n+    let flag: String = must_parse_query_param(&request, \"flag\")?;",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2160958710",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12233,
        "pr_file": "pageserver/src/http/routes.rs",
        "discussion_id": "2160958710",
        "commented_code": "@@ -3709,6 +3713,31 @@ async fn tenant_evaluate_feature_flag(\n     .await\n }\n \n+async fn force_override_feature_flag_for_testing_put(\n+    request: Request<Body>,\n+    _cancel: CancellationToken,\n+) -> Result<Response<Body>, ApiError> {\n+    let flag: String = must_parse_query_param(&request, \"flag\")?;",
        "comment_created_at": "2025-06-23T07:56:07+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "Need to protect those methods with `check_permissions(&request, None)` to block these API calls with tenant-scoped tokens.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2104978137",
    "pr_number": 12010,
    "pr_file": "pageserver/src/page_service.rs",
    "created_at": "2025-05-23T16:22:44+00:00",
    "commented_code": "}\n }\n \n+/// gRPC interceptor that decodes tenant metadata and stores it as request extensions of type\n+/// TenantTimelineId and ShardIndex.\n+///\n+/// TODO: consider looking up the timeline handle here and storing it.\n+#[derive(Clone)]\n+struct TenantMetadataInterceptor;\n+\n+impl tonic::service::Interceptor for TenantMetadataInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Decode the tenant ID.\n+        let tenant_id = req\n+            .metadata()\n+            .get(\"neon-tenant-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-tenant-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+        let tenant_id = TenantId::from_str(tenant_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+\n+        // Decode the timeline ID.\n+        let timeline_id = req\n+            .metadata()\n+            .get(\"neon-timeline-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-timeline-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+        let timeline_id = TimelineId::from_str(timeline_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+\n+        // Decode the shard ID.\n+        let shard_index = req\n+            .metadata()\n+            .get(\"neon-shard-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-shard-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+        let shard_index = ShardIndex::from_str(shard_index)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+\n+        // Stash them in the request.\n+        let extensions = req.extensions_mut();\n+        extensions.insert(TenantTimelineId::new(tenant_id, timeline_id));\n+        extensions.insert(shard_index);\n+\n+        Ok(req)\n+    }\n+}\n+\n+/// Authenticates gRPC page service requests, and stores the JWT claims as a request extension. Must\n+/// run after TenantMetadataInterceptor.\n+#[derive(Clone)]\n+struct TenantAuthInterceptor {\n+    auth: Option<Arc<SwappableJwtAuth>>,\n+}\n+\n+impl TenantAuthInterceptor {\n+    fn new(auth: Option<Arc<SwappableJwtAuth>>) -> Self {\n+        Self { auth }\n+    }\n+}\n+\n+impl tonic::service::Interceptor for TenantAuthInterceptor {\n+    fn call(&mut self, req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Do nothing if auth is disabled.\n+        let Some(auth) = self.auth.as_ref() else {\n+            return Ok(req);\n+        };\n+\n+        // Fetch the tenant ID that's been set by TenantMetadataInterceptor.\n+        let ttid = req\n+            .extensions()\n+            .get::<TenantTimelineId>()\n+            .expect(\"TenantMetadataInterceptor must run before TenantAuthInterceptor\");\n+\n+        // Fetch and decode the JWT token.\n+        let authorization = req\n+            .metadata()\n+            .get(\"authorization\")\n+            .ok_or(tonic::Status::unauthenticated(\"no authorization header\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid authorization header\"))?;\n+        if &authorization[0..7] != \"Bearer \" {",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2104978137",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12010,
        "pr_file": "pageserver/src/page_service.rs",
        "discussion_id": "2104978137",
        "commented_code": "@@ -3290,6 +3303,108 @@ impl From<GetActiveTenantError> for QueryError {\n     }\n }\n \n+/// gRPC interceptor that decodes tenant metadata and stores it as request extensions of type\n+/// TenantTimelineId and ShardIndex.\n+///\n+/// TODO: consider looking up the timeline handle here and storing it.\n+#[derive(Clone)]\n+struct TenantMetadataInterceptor;\n+\n+impl tonic::service::Interceptor for TenantMetadataInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Decode the tenant ID.\n+        let tenant_id = req\n+            .metadata()\n+            .get(\"neon-tenant-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-tenant-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+        let tenant_id = TenantId::from_str(tenant_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+\n+        // Decode the timeline ID.\n+        let timeline_id = req\n+            .metadata()\n+            .get(\"neon-timeline-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-timeline-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+        let timeline_id = TimelineId::from_str(timeline_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+\n+        // Decode the shard ID.\n+        let shard_index = req\n+            .metadata()\n+            .get(\"neon-shard-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-shard-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+        let shard_index = ShardIndex::from_str(shard_index)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+\n+        // Stash them in the request.\n+        let extensions = req.extensions_mut();\n+        extensions.insert(TenantTimelineId::new(tenant_id, timeline_id));\n+        extensions.insert(shard_index);\n+\n+        Ok(req)\n+    }\n+}\n+\n+/// Authenticates gRPC page service requests, and stores the JWT claims as a request extension. Must\n+/// run after TenantMetadataInterceptor.\n+#[derive(Clone)]\n+struct TenantAuthInterceptor {\n+    auth: Option<Arc<SwappableJwtAuth>>,\n+}\n+\n+impl TenantAuthInterceptor {\n+    fn new(auth: Option<Arc<SwappableJwtAuth>>) -> Self {\n+        Self { auth }\n+    }\n+}\n+\n+impl tonic::service::Interceptor for TenantAuthInterceptor {\n+    fn call(&mut self, req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Do nothing if auth is disabled.\n+        let Some(auth) = self.auth.as_ref() else {\n+            return Ok(req);\n+        };\n+\n+        // Fetch the tenant ID that's been set by TenantMetadataInterceptor.\n+        let ttid = req\n+            .extensions()\n+            .get::<TenantTimelineId>()\n+            .expect(\"TenantMetadataInterceptor must run before TenantAuthInterceptor\");\n+\n+        // Fetch and decode the JWT token.\n+        let authorization = req\n+            .metadata()\n+            .get(\"authorization\")\n+            .ok_or(tonic::Status::unauthenticated(\"no authorization header\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid authorization header\"))?;\n+        if &authorization[0..7] != \"Bearer \" {",
        "comment_created_at": "2025-05-23T16:22:44+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "It will panic if authorization header is shorter than 7 bytes, need to check. I think `.strip_prefix(\"Bearer\")` does the job in the rust-way\r\n\r\nAnd may be `trim_start()` before it also makes sense\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2105148915",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12010,
        "pr_file": "pageserver/src/page_service.rs",
        "discussion_id": "2104978137",
        "commented_code": "@@ -3290,6 +3303,108 @@ impl From<GetActiveTenantError> for QueryError {\n     }\n }\n \n+/// gRPC interceptor that decodes tenant metadata and stores it as request extensions of type\n+/// TenantTimelineId and ShardIndex.\n+///\n+/// TODO: consider looking up the timeline handle here and storing it.\n+#[derive(Clone)]\n+struct TenantMetadataInterceptor;\n+\n+impl tonic::service::Interceptor for TenantMetadataInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Decode the tenant ID.\n+        let tenant_id = req\n+            .metadata()\n+            .get(\"neon-tenant-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-tenant-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+        let tenant_id = TenantId::from_str(tenant_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+\n+        // Decode the timeline ID.\n+        let timeline_id = req\n+            .metadata()\n+            .get(\"neon-timeline-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-timeline-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+        let timeline_id = TimelineId::from_str(timeline_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+\n+        // Decode the shard ID.\n+        let shard_index = req\n+            .metadata()\n+            .get(\"neon-shard-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-shard-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+        let shard_index = ShardIndex::from_str(shard_index)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+\n+        // Stash them in the request.\n+        let extensions = req.extensions_mut();\n+        extensions.insert(TenantTimelineId::new(tenant_id, timeline_id));\n+        extensions.insert(shard_index);\n+\n+        Ok(req)\n+    }\n+}\n+\n+/// Authenticates gRPC page service requests, and stores the JWT claims as a request extension. Must\n+/// run after TenantMetadataInterceptor.\n+#[derive(Clone)]\n+struct TenantAuthInterceptor {\n+    auth: Option<Arc<SwappableJwtAuth>>,\n+}\n+\n+impl TenantAuthInterceptor {\n+    fn new(auth: Option<Arc<SwappableJwtAuth>>) -> Self {\n+        Self { auth }\n+    }\n+}\n+\n+impl tonic::service::Interceptor for TenantAuthInterceptor {\n+    fn call(&mut self, req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Do nothing if auth is disabled.\n+        let Some(auth) = self.auth.as_ref() else {\n+            return Ok(req);\n+        };\n+\n+        // Fetch the tenant ID that's been set by TenantMetadataInterceptor.\n+        let ttid = req\n+            .extensions()\n+            .get::<TenantTimelineId>()\n+            .expect(\"TenantMetadataInterceptor must run before TenantAuthInterceptor\");\n+\n+        // Fetch and decode the JWT token.\n+        let authorization = req\n+            .metadata()\n+            .get(\"authorization\")\n+            .ok_or(tonic::Status::unauthenticated(\"no authorization header\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid authorization header\"))?;\n+        if &authorization[0..7] != \"Bearer \" {",
        "comment_created_at": "2025-05-23T17:42:38+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "Oops, thanks -- just blindly copied this over from some prototype code. Fixed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2106763641",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12010,
        "pr_file": "pageserver/src/page_service.rs",
        "discussion_id": "2104978137",
        "commented_code": "@@ -3290,6 +3303,108 @@ impl From<GetActiveTenantError> for QueryError {\n     }\n }\n \n+/// gRPC interceptor that decodes tenant metadata and stores it as request extensions of type\n+/// TenantTimelineId and ShardIndex.\n+///\n+/// TODO: consider looking up the timeline handle here and storing it.\n+#[derive(Clone)]\n+struct TenantMetadataInterceptor;\n+\n+impl tonic::service::Interceptor for TenantMetadataInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Decode the tenant ID.\n+        let tenant_id = req\n+            .metadata()\n+            .get(\"neon-tenant-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-tenant-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+        let tenant_id = TenantId::from_str(tenant_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+\n+        // Decode the timeline ID.\n+        let timeline_id = req\n+            .metadata()\n+            .get(\"neon-timeline-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-timeline-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+        let timeline_id = TimelineId::from_str(timeline_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+\n+        // Decode the shard ID.\n+        let shard_index = req\n+            .metadata()\n+            .get(\"neon-shard-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-shard-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+        let shard_index = ShardIndex::from_str(shard_index)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+\n+        // Stash them in the request.\n+        let extensions = req.extensions_mut();\n+        extensions.insert(TenantTimelineId::new(tenant_id, timeline_id));\n+        extensions.insert(shard_index);\n+\n+        Ok(req)\n+    }\n+}\n+\n+/// Authenticates gRPC page service requests, and stores the JWT claims as a request extension. Must\n+/// run after TenantMetadataInterceptor.\n+#[derive(Clone)]\n+struct TenantAuthInterceptor {\n+    auth: Option<Arc<SwappableJwtAuth>>,\n+}\n+\n+impl TenantAuthInterceptor {\n+    fn new(auth: Option<Arc<SwappableJwtAuth>>) -> Self {\n+        Self { auth }\n+    }\n+}\n+\n+impl tonic::service::Interceptor for TenantAuthInterceptor {\n+    fn call(&mut self, req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Do nothing if auth is disabled.\n+        let Some(auth) = self.auth.as_ref() else {\n+            return Ok(req);\n+        };\n+\n+        // Fetch the tenant ID that's been set by TenantMetadataInterceptor.\n+        let ttid = req\n+            .extensions()\n+            .get::<TenantTimelineId>()\n+            .expect(\"TenantMetadataInterceptor must run before TenantAuthInterceptor\");\n+\n+        // Fetch and decode the JWT token.\n+        let authorization = req\n+            .metadata()\n+            .get(\"authorization\")\n+            .ok_or(tonic::Status::unauthenticated(\"no authorization header\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid authorization header\"))?;\n+        if &authorization[0..7] != \"Bearer \" {",
        "comment_created_at": "2025-05-26T07:49:32+00:00",
        "comment_author": "DimasKovas",
        "comment_body": "My initial comment was slightly incorrect - having a space after `Bearer` as it was in your code before ( `.strip_prefix(\"Bearer \")`) is probably more correct because otherwise, it will match header value `BearerSmth <token>`. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2106866503",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 12010,
        "pr_file": "pageserver/src/page_service.rs",
        "discussion_id": "2104978137",
        "commented_code": "@@ -3290,6 +3303,108 @@ impl From<GetActiveTenantError> for QueryError {\n     }\n }\n \n+/// gRPC interceptor that decodes tenant metadata and stores it as request extensions of type\n+/// TenantTimelineId and ShardIndex.\n+///\n+/// TODO: consider looking up the timeline handle here and storing it.\n+#[derive(Clone)]\n+struct TenantMetadataInterceptor;\n+\n+impl tonic::service::Interceptor for TenantMetadataInterceptor {\n+    fn call(&mut self, mut req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Decode the tenant ID.\n+        let tenant_id = req\n+            .metadata()\n+            .get(\"neon-tenant-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-tenant-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+        let tenant_id = TenantId::from_str(tenant_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-tenant-id\"))?;\n+\n+        // Decode the timeline ID.\n+        let timeline_id = req\n+            .metadata()\n+            .get(\"neon-timeline-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-timeline-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+        let timeline_id = TimelineId::from_str(timeline_id)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-timeline-id\"))?;\n+\n+        // Decode the shard ID.\n+        let shard_index = req\n+            .metadata()\n+            .get(\"neon-shard-id\")\n+            .ok_or(tonic::Status::invalid_argument(\"missing neon-shard-id\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+        let shard_index = ShardIndex::from_str(shard_index)\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid neon-shard-id\"))?;\n+\n+        // Stash them in the request.\n+        let extensions = req.extensions_mut();\n+        extensions.insert(TenantTimelineId::new(tenant_id, timeline_id));\n+        extensions.insert(shard_index);\n+\n+        Ok(req)\n+    }\n+}\n+\n+/// Authenticates gRPC page service requests, and stores the JWT claims as a request extension. Must\n+/// run after TenantMetadataInterceptor.\n+#[derive(Clone)]\n+struct TenantAuthInterceptor {\n+    auth: Option<Arc<SwappableJwtAuth>>,\n+}\n+\n+impl TenantAuthInterceptor {\n+    fn new(auth: Option<Arc<SwappableJwtAuth>>) -> Self {\n+        Self { auth }\n+    }\n+}\n+\n+impl tonic::service::Interceptor for TenantAuthInterceptor {\n+    fn call(&mut self, req: tonic::Request<()>) -> Result<tonic::Request<()>, tonic::Status> {\n+        // Do nothing if auth is disabled.\n+        let Some(auth) = self.auth.as_ref() else {\n+            return Ok(req);\n+        };\n+\n+        // Fetch the tenant ID that's been set by TenantMetadataInterceptor.\n+        let ttid = req\n+            .extensions()\n+            .get::<TenantTimelineId>()\n+            .expect(\"TenantMetadataInterceptor must run before TenantAuthInterceptor\");\n+\n+        // Fetch and decode the JWT token.\n+        let authorization = req\n+            .metadata()\n+            .get(\"authorization\")\n+            .ok_or(tonic::Status::unauthenticated(\"no authorization header\"))?\n+            .to_str()\n+            .map_err(|_| tonic::Status::invalid_argument(\"invalid authorization header\"))?;\n+        if &authorization[0..7] != \"Bearer \" {",
        "comment_created_at": "2025-05-26T08:50:41+00:00",
        "comment_author": "erikgrinaker",
        "comment_body": "I don't think it matters much since the JWT will fail to parse and validate in that case, but sure -- updated.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2101005192",
    "pr_number": 11991,
    "pr_file": "proxy/src/auth/backend/mod.rs",
    "created_at": "2025-05-21T19:20:26+00:00",
    "commented_code": ".field(&endpoint.url())\n                     .finish(),\n                 #[cfg(any(test, feature = \"testing\"))]\n-                ControlPlaneClient::PostgresMock(endpoint) => fmt\n-                    .debug_tuple(\"ControlPlane::PostgresMock\")\n-                    .field(&endpoint.url())\n-                    .finish(),\n+                ControlPlaneClient::PostgresMock(endpoint) => {\n+                    let url = endpoint.url();\n+                    match url::Url::parse(url) {\n+                        Ok(mut url) => {\n+                            let _ = url.set_password(None);",
    "repo_full_name": "neondatabase/neon",
    "discussion_comments": [
      {
        "comment_id": "2101005192",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11991,
        "pr_file": "proxy/src/auth/backend/mod.rs",
        "discussion_id": "2101005192",
        "commented_code": "@@ -80,10 +80,22 @@ impl std::fmt::Display for Backend<'_, ()> {\n                     .field(&endpoint.url())\n                     .finish(),\n                 #[cfg(any(test, feature = \"testing\"))]\n-                ControlPlaneClient::PostgresMock(endpoint) => fmt\n-                    .debug_tuple(\"ControlPlane::PostgresMock\")\n-                    .field(&endpoint.url())\n-                    .finish(),\n+                ControlPlaneClient::PostgresMock(endpoint) => {\n+                    let url = endpoint.url();\n+                    match url::Url::parse(url) {\n+                        Ok(mut url) => {\n+                            let _ = url.set_password(None);",
        "comment_created_at": "2025-05-21T19:20:26+00:00",
        "comment_author": "cloneable",
        "comment_body": "Nice! Sorry, didn't see this before.\r\nnit: Maybe replace with something like \"[redacted]\", if a password is set. `url::set_password(url.password().map(...))`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2101021303",
        "repo_full_name": "neondatabase/neon",
        "pr_number": 11991,
        "pr_file": "proxy/src/auth/backend/mod.rs",
        "discussion_id": "2101005192",
        "commented_code": "@@ -80,10 +80,22 @@ impl std::fmt::Display for Backend<'_, ()> {\n                     .field(&endpoint.url())\n                     .finish(),\n                 #[cfg(any(test, feature = \"testing\"))]\n-                ControlPlaneClient::PostgresMock(endpoint) => fmt\n-                    .debug_tuple(\"ControlPlane::PostgresMock\")\n-                    .field(&endpoint.url())\n-                    .finish(),\n+                ControlPlaneClient::PostgresMock(endpoint) => {\n+                    let url = endpoint.url();\n+                    match url::Url::parse(url) {\n+                        Ok(mut url) => {\n+                            let _ = url.set_password(None);",
        "comment_created_at": "2025-05-21T19:31:16+00:00",
        "comment_author": "Bodobolero",
        "comment_body": "I decided to use placeholder\r\n\r\n\"\\_redacted\\_\"\r\n\r\nbecause \r\n\r\n\"[redacted]\"\r\n\r\nuses [] which are escaped in Urls:\r\n\r\n```log\r\n2025-05-21T19:25:41.106073Z  INFO Authentication backend: ControlPlane::PostgresMock(\"postgresql://postgres:%5Bredacted%5D@127.0.0.1:5432/postgres\")\r\n```\r\n\r\nNow it looks like this\r\n\r\n```log\r\n2025-05-21T19:28:33.320648Z  INFO Authentication backend: ControlPlane::PostgresMock(\"postgresql://postgres:_redacted_@127.0.0.1:5432/postgres\")\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  }
]