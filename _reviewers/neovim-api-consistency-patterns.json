[
  {
    "discussion_id": "2203507189",
    "pr_number": 34806,
    "pr_file": "test/functional/core/server_spec.lua",
    "created_at": "2025-07-13T19:52:55+00:00",
    "commented_code": "-- Exactly #servs servers should be added.\n     eq(_n + #servs, #new_servs)\n-    -- The new servers should be at the end of the list.\n+    -- servers started by `serverstart` will be listed after the current sever and before the other ones\n     for i = 1, #servs do\n-      eq(servs[i], new_servs[i + _n])\n+      eq(servs[i], new_servs[i + 1])",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203507189",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34806,
        "pr_file": "test/functional/core/server_spec.lua",
        "discussion_id": "2203507189",
        "commented_code": "@@ -179,9 +179,9 @@ describe('server', function()\n \n     -- Exactly #servs servers should be added.\n     eq(_n + #servs, #new_servs)\n-    -- The new servers should be at the end of the list.\n+    -- servers started by `serverstart` will be listed after the current sever and before the other ones\n     for i = 1, #servs do\n-      eq(servs[i], new_servs[i + _n])\n+      eq(servs[i], new_servs[i + 1])",
        "comment_created_at": "2025-07-13T19:52:55+00:00",
        "comment_author": "justinmk",
        "comment_body": "this existing test shouldn't require a change, because the enhancement to serverlist() should be opt-in, i.e. the user needs to pass something like:\n\n    vim.fn.serverlist({peer=true})",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2233124448",
    "pr_number": 35078,
    "pr_file": "runtime/lua/vim/lsp/_cmd.lua",
    "created_at": "2025-07-26T17:57:05+00:00",
    "commented_code": "+local lsp = vim.lsp\n+\n+local M = {}\n+\n+--- @param filter? vim.lsp.get_clients.Filter\n+--- @return string[]\n+local function get_client_names(filter)\n+  return vim\n+    .iter(lsp.get_clients(filter))\n+    :map(function(client)\n+      return client.name\n+    end)\n+    :filter(function(name)\n+      return not not vim.lsp.config[name]\n+    end)\n+    :totable()\n+end\n+\n+---@param clients string[]\n+local function ex_lsp_stop(clients)\n+  -- Default to disabling all servers on current buffer\n+  if #clients == 0 then\n+    clients = get_client_names { bufnr = vim.api.nvim_get_current_buf() }\n+  end\n+\n+  for _, name in ipairs(clients) do\n+    if vim.lsp.config[name] == nil then\n+      vim.notify((\"Invalid server name '%s'\"):format(name))",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2233124448",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35078,
        "pr_file": "runtime/lua/vim/lsp/_cmd.lua",
        "discussion_id": "2233124448",
        "commented_code": "@@ -0,0 +1,105 @@\n+local lsp = vim.lsp\n+\n+local M = {}\n+\n+--- @param filter? vim.lsp.get_clients.Filter\n+--- @return string[]\n+local function get_client_names(filter)\n+  return vim\n+    .iter(lsp.get_clients(filter))\n+    :map(function(client)\n+      return client.name\n+    end)\n+    :filter(function(name)\n+      return not not vim.lsp.config[name]\n+    end)\n+    :totable()\n+end\n+\n+---@param clients string[]\n+local function ex_lsp_stop(clients)\n+  -- Default to disabling all servers on current buffer\n+  if #clients == 0 then\n+    clients = get_client_names { bufnr = vim.api.nvim_get_current_buf() }\n+  end\n+\n+  for _, name in ipairs(clients) do\n+    if vim.lsp.config[name] == nil then\n+      vim.notify((\"Invalid server name '%s'\"):format(name))",
        "comment_created_at": "2025-07-26T17:57:05+00:00",
        "comment_author": "mfussenegger",
        "comment_body": "Any reason not to call `client:stop` in this case? Users can start clients without going through lsp.config/enable and we already got the client object here.\r\n\r\nE.g. my custom `LspStop` is currently:\r\n\r\n```lua\r\n  api.nvim_create_user_command(\r\n    'LspStop',\r\n    function(kwargs)\r\n      local name = kwargs.fargs[1]\r\n      for _, client in ipairs(lsp.get_clients({ name = name })) do\r\n        client:stop()\r\n      end\r\n    end,\r\n    {\r\n      nargs = \"?\",\r\n      complete = function()\r\n        return vim.tbl_map(function(c) return c.name end, lsp.get_clients())\r\n      end\r\n    }\r\n  )\r\n```\r\n\r\n\r\n(Also raises a bit the question if `:lsp stop` is  \"stop server\" or \"stop and disable server\")",
        "pr_file_module": null
      },
      {
        "comment_id": "2233173360",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35078,
        "pr_file": "runtime/lua/vim/lsp/_cmd.lua",
        "discussion_id": "2233124448",
        "commented_code": "@@ -0,0 +1,105 @@\n+local lsp = vim.lsp\n+\n+local M = {}\n+\n+--- @param filter? vim.lsp.get_clients.Filter\n+--- @return string[]\n+local function get_client_names(filter)\n+  return vim\n+    .iter(lsp.get_clients(filter))\n+    :map(function(client)\n+      return client.name\n+    end)\n+    :filter(function(name)\n+      return not not vim.lsp.config[name]\n+    end)\n+    :totable()\n+end\n+\n+---@param clients string[]\n+local function ex_lsp_stop(clients)\n+  -- Default to disabling all servers on current buffer\n+  if #clients == 0 then\n+    clients = get_client_names { bufnr = vim.api.nvim_get_current_buf() }\n+  end\n+\n+  for _, name in ipairs(clients) do\n+    if vim.lsp.config[name] == nil then\n+      vim.notify((\"Invalid server name '%s'\"):format(name))",
        "comment_created_at": "2025-07-26T18:55:39+00:00",
        "comment_author": "brianhuster",
        "comment_body": "> (Also raises a bit the question if :lsp stop is \"stop server\" or \"stop and disable server\")\r\n\r\nSince I just copied the logic from `nvim-lspconfig`, its description is the same as in there [\"Disable and stop the given client\"](https://github.com/neovim/nvim-lspconfig/blob/4d3b3bb8815fbe37bcaf3dbdb12a22382bc11ebe/plugin/lspconfig.lua#L178).\r\n\r\nMaybe `:lsp disable` is a better name?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2088066037",
    "pr_number": 34014,
    "pr_file": "runtime/lua/vim/diagnostic.lua",
    "created_at": "2025-05-14T05:27:00+00:00",
    "commented_code": "end\n \n   local scope = ({ l = 'line', c = 'cursor', b = 'buffer' })[opts.scope] or opts.scope or 'line'\n-  local lnum, col --- @type integer, integer\n-  local opts_pos = opts.pos\n+  local extmarks_start = { 0, 0 }\n+  local extmarks_end = { -1, -1 }\n   if scope == 'line' or scope == 'cursor' then\n+    local opts_pos = opts.pos\n+\n     if not opts_pos then\n       local pos = api.nvim_win_get_cursor(0)\n-      lnum = pos[1] - 1\n-      col = pos[2]\n+      extmarks_start[1] = pos[1] - 1\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = pos[2]\n+      end\n     elseif type(opts_pos) == 'number' then\n-      lnum = opts_pos\n+      extmarks_start[1] = opts_pos\n     elseif type(opts_pos) == 'table' then\n-      lnum, col = opts_pos[1], opts_pos[2]\n+      extmarks_start[1] = opts_pos[1]\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = opts_pos[2]\n+      end\n     else\n       error(\"Invalid value for option 'pos'\")\n     end\n+\n+    extmarks_end[1] = extmarks_start[1]\n+\n+    if scope == 'cursor' then\n+      extmarks_end[2] = extmarks_start[2]\n+    end\n   elseif scope ~= 'buffer' then\n     error(\"Invalid value for option 'scope'\")\n   end\n \n-  local diagnostics = get_diagnostics(bufnr, opts --[[@as vim.diagnostic.GetOpts]], true)\n+  local namespaces = {} ---@type integer[]\n+  if type(opts.namespace) == 'number' then\n+    namespaces[1] = opts.namespace\n+  else\n+    for namespace in pairs(diagnostic_cache[bufnr]) do\n+      table.insert(namespaces, namespace)\n+    end\n+  end",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2088066037",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2088066037",
        "commented_code": "@@ -2150,43 +2277,69 @@ function M.open_float(opts, ...)\n   end\n \n   local scope = ({ l = 'line', c = 'cursor', b = 'buffer' })[opts.scope] or opts.scope or 'line'\n-  local lnum, col --- @type integer, integer\n-  local opts_pos = opts.pos\n+  local extmarks_start = { 0, 0 }\n+  local extmarks_end = { -1, -1 }\n   if scope == 'line' or scope == 'cursor' then\n+    local opts_pos = opts.pos\n+\n     if not opts_pos then\n       local pos = api.nvim_win_get_cursor(0)\n-      lnum = pos[1] - 1\n-      col = pos[2]\n+      extmarks_start[1] = pos[1] - 1\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = pos[2]\n+      end\n     elseif type(opts_pos) == 'number' then\n-      lnum = opts_pos\n+      extmarks_start[1] = opts_pos\n     elseif type(opts_pos) == 'table' then\n-      lnum, col = opts_pos[1], opts_pos[2]\n+      extmarks_start[1] = opts_pos[1]\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = opts_pos[2]\n+      end\n     else\n       error(\"Invalid value for option 'pos'\")\n     end\n+\n+    extmarks_end[1] = extmarks_start[1]\n+\n+    if scope == 'cursor' then\n+      extmarks_end[2] = extmarks_start[2]\n+    end\n   elseif scope ~= 'buffer' then\n     error(\"Invalid value for option 'scope'\")\n   end\n \n-  local diagnostics = get_diagnostics(bufnr, opts --[[@as vim.diagnostic.GetOpts]], true)\n+  local namespaces = {} ---@type integer[]\n+  if type(opts.namespace) == 'number' then\n+    namespaces[1] = opts.namespace\n+  else\n+    for namespace in pairs(diagnostic_cache[bufnr]) do\n+      table.insert(namespaces, namespace)\n+    end\n+  end",
        "comment_created_at": "2025-05-14T05:27:00+00:00",
        "comment_author": "faergeek",
        "comment_body": "should `type(opts.namespace) == 'table'` case be supported?\r\n\r\nNeither types nor docs seem to allow it, but implicitly it has been supported since\r\n`get_diagnostics` does",
        "pr_file_module": null
      },
      {
        "comment_id": "2094170028",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2088066037",
        "commented_code": "@@ -2150,43 +2277,69 @@ function M.open_float(opts, ...)\n   end\n \n   local scope = ({ l = 'line', c = 'cursor', b = 'buffer' })[opts.scope] or opts.scope or 'line'\n-  local lnum, col --- @type integer, integer\n-  local opts_pos = opts.pos\n+  local extmarks_start = { 0, 0 }\n+  local extmarks_end = { -1, -1 }\n   if scope == 'line' or scope == 'cursor' then\n+    local opts_pos = opts.pos\n+\n     if not opts_pos then\n       local pos = api.nvim_win_get_cursor(0)\n-      lnum = pos[1] - 1\n-      col = pos[2]\n+      extmarks_start[1] = pos[1] - 1\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = pos[2]\n+      end\n     elseif type(opts_pos) == 'number' then\n-      lnum = opts_pos\n+      extmarks_start[1] = opts_pos\n     elseif type(opts_pos) == 'table' then\n-      lnum, col = opts_pos[1], opts_pos[2]\n+      extmarks_start[1] = opts_pos[1]\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = opts_pos[2]\n+      end\n     else\n       error(\"Invalid value for option 'pos'\")\n     end\n+\n+    extmarks_end[1] = extmarks_start[1]\n+\n+    if scope == 'cursor' then\n+      extmarks_end[2] = extmarks_start[2]\n+    end\n   elseif scope ~= 'buffer' then\n     error(\"Invalid value for option 'scope'\")\n   end\n \n-  local diagnostics = get_diagnostics(bufnr, opts --[[@as vim.diagnostic.GetOpts]], true)\n+  local namespaces = {} ---@type integer[]\n+  if type(opts.namespace) == 'number' then\n+    namespaces[1] = opts.namespace\n+  else\n+    for namespace in pairs(diagnostic_cache[bufnr]) do\n+      table.insert(namespaces, namespace)\n+    end\n+  end",
        "comment_created_at": "2025-05-17T17:13:51+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Yeah we should support it for consistency with other diagnostic APIs (e.g. https://github.com/neovim/neovim/pull/33982). I can follow up with a PR for this later.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094175331",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2088066037",
        "commented_code": "@@ -2150,43 +2277,69 @@ function M.open_float(opts, ...)\n   end\n \n   local scope = ({ l = 'line', c = 'cursor', b = 'buffer' })[opts.scope] or opts.scope or 'line'\n-  local lnum, col --- @type integer, integer\n-  local opts_pos = opts.pos\n+  local extmarks_start = { 0, 0 }\n+  local extmarks_end = { -1, -1 }\n   if scope == 'line' or scope == 'cursor' then\n+    local opts_pos = opts.pos\n+\n     if not opts_pos then\n       local pos = api.nvim_win_get_cursor(0)\n-      lnum = pos[1] - 1\n-      col = pos[2]\n+      extmarks_start[1] = pos[1] - 1\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = pos[2]\n+      end\n     elseif type(opts_pos) == 'number' then\n-      lnum = opts_pos\n+      extmarks_start[1] = opts_pos\n     elseif type(opts_pos) == 'table' then\n-      lnum, col = opts_pos[1], opts_pos[2]\n+      extmarks_start[1] = opts_pos[1]\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = opts_pos[2]\n+      end\n     else\n       error(\"Invalid value for option 'pos'\")\n     end\n+\n+    extmarks_end[1] = extmarks_start[1]\n+\n+    if scope == 'cursor' then\n+      extmarks_end[2] = extmarks_start[2]\n+    end\n   elseif scope ~= 'buffer' then\n     error(\"Invalid value for option 'scope'\")\n   end\n \n-  local diagnostics = get_diagnostics(bufnr, opts --[[@as vim.diagnostic.GetOpts]], true)\n+  local namespaces = {} ---@type integer[]\n+  if type(opts.namespace) == 'number' then\n+    namespaces[1] = opts.namespace\n+  else\n+    for namespace in pairs(diagnostic_cache[bufnr]) do\n+      table.insert(namespaces, namespace)\n+    end\n+  end",
        "comment_created_at": "2025-05-17T17:43:03+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Opened https://github.com/neovim/neovim/pull/34073 for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094357206",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2088066037",
        "commented_code": "@@ -2150,43 +2277,69 @@ function M.open_float(opts, ...)\n   end\n \n   local scope = ({ l = 'line', c = 'cursor', b = 'buffer' })[opts.scope] or opts.scope or 'line'\n-  local lnum, col --- @type integer, integer\n-  local opts_pos = opts.pos\n+  local extmarks_start = { 0, 0 }\n+  local extmarks_end = { -1, -1 }\n   if scope == 'line' or scope == 'cursor' then\n+    local opts_pos = opts.pos\n+\n     if not opts_pos then\n       local pos = api.nvim_win_get_cursor(0)\n-      lnum = pos[1] - 1\n-      col = pos[2]\n+      extmarks_start[1] = pos[1] - 1\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = pos[2]\n+      end\n     elseif type(opts_pos) == 'number' then\n-      lnum = opts_pos\n+      extmarks_start[1] = opts_pos\n     elseif type(opts_pos) == 'table' then\n-      lnum, col = opts_pos[1], opts_pos[2]\n+      extmarks_start[1] = opts_pos[1]\n+\n+      if scope == 'cursor' then\n+        extmarks_start[2] = opts_pos[2]\n+      end\n     else\n       error(\"Invalid value for option 'pos'\")\n     end\n+\n+    extmarks_end[1] = extmarks_start[1]\n+\n+    if scope == 'cursor' then\n+      extmarks_end[2] = extmarks_start[2]\n+    end\n   elseif scope ~= 'buffer' then\n     error(\"Invalid value for option 'scope'\")\n   end\n \n-  local diagnostics = get_diagnostics(bufnr, opts --[[@as vim.diagnostic.GetOpts]], true)\n+  local namespaces = {} ---@type integer[]\n+  if type(opts.namespace) == 'number' then\n+    namespaces[1] = opts.namespace\n+  else\n+    for namespace in pairs(diagnostic_cache[bufnr]) do\n+      table.insert(namespaces, namespace)\n+    end\n+  end",
        "comment_created_at": "2025-05-18T04:52:23+00:00",
        "comment_author": "faergeek",
        "comment_body": "Added it here 3c325a08bdafaf02e7b61fd64634d5f1dcd9842f\r\nOnly implementation change.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187450740",
    "pr_number": 34797,
    "pr_file": "runtime/lua/vim/lsp/semantic_tokens.lua",
    "created_at": "2025-07-05T16:54:04+00:00",
    "commented_code": "end\n end\n \n+util._enable('semantic_tokens', true)\n+\n+---@class vim.lsp.semantic_tokens.enable.Filter",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2187450740",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/semantic_tokens.lua",
        "discussion_id": "2187450740",
        "commented_code": "@@ -694,6 +717,48 @@ function M.stop(bufnr, client_id)\n   end\n end\n \n+util._enable('semantic_tokens', true)\n+\n+---@class vim.lsp.semantic_tokens.enable.Filter",
        "comment_created_at": "2025-07-05T16:54:04+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "We should have a general utility type for this buffer/client filter.",
        "pr_file_module": null
      },
      {
        "comment_id": "2187942562",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/semantic_tokens.lua",
        "discussion_id": "2187450740",
        "commented_code": "@@ -694,6 +717,48 @@ function M.stop(bufnr, client_id)\n   end\n end\n \n+util._enable('semantic_tokens', true)\n+\n+---@class vim.lsp.semantic_tokens.enable.Filter",
        "comment_created_at": "2025-07-06T03:28:00+00:00",
        "comment_author": "ofseed",
        "comment_body": "I have added `vim.lsp.util.enable.Filter` as a general utility type, which can be used for `semantic_token`, but it won't be useful for filters like `inlay_hint.enable` that do not support `client_id`. Perhaps I should use it inside `enable` for semantic tokens, which supports both types of filters?",
        "pr_file_module": null
      },
      {
        "comment_id": "2188012440",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/semantic_tokens.lua",
        "discussion_id": "2187450740",
        "commented_code": "@@ -694,6 +717,48 @@ function M.stop(bufnr, client_id)\n   end\n end\n \n+util._enable('semantic_tokens', true)\n+\n+---@class vim.lsp.semantic_tokens.enable.Filter",
        "comment_created_at": "2025-07-06T04:57:55+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Yeah I think that would be cleaner.\r\n\r\nRelated comment: https://github.com/neovim/neovim/pull/34797/files#r2188010479",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188274095",
    "pr_number": 33972,
    "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
    "created_at": "2025-07-06T13:23:19+00:00",
    "commented_code": "+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.inline_completion.CurrentItem\n+---@field index integer\n+---@field extmark integer\n+---@field autocmd integer\n+\n+---@class (private) vim.lsp.inline_completion.Item\n+---@field client_id integer\n+---@field item lsp.InlineCompletionItem\n+\n+---@class (private) vim.lsp.inline_completion.Completor\n+---@field active table<integer, vim.lsp.inline_completion.Completor?>\n+---@field bufnr integer\n+---@field items vim.lsp.inline_completion.Item[]\n+---@field current? vim.lsp.inline_completion.CurrentItem\n+local Completor = { active = {} }\n+\n+---@package\n+---@param bufnr integer\n+function Completor.new(bufnr)\n+  local self = setmetatable({}, { __index = Completor })\n+  self.bufnr = bufnr\n+  return self\n+end\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+---@package\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+function Completor:handler(results)\n+  ---@type vim.lsp.inline_completion.Item[]\n+  local items = {}\n+\n+  for client_id, result in pairs(results) do\n+    local client = assert(vim.lsp.get_client_by_id(client_id))\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        item.range['start'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['start'], client.offset_encoding)\n+        item.range['end'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['end'], client.offset_encoding)\n+        table.insert(items, { client_id = client_id, item = item })\n+      end\n+    end\n+  end\n+\n+  if #items ~= 0 then\n+    self.items = items\n+    self:present(1)\n+  end\n+end\n+\n+---@package\n+---@param index integer\n+---@param show_index? boolean\n+function Completor:present(index, show_index)\n+  if self.current then\n+    self:dismiss()\n+  end\n+  self.current = {\n+    index = index,\n+    extmark = set_extmark(\n+      self.bufnr,\n+      self.items[index].item,\n+      show_index and (' (%d/%d)'):format(index, #self.items) or nil\n+    ),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      buffer = self.bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        self:dismiss()\n+      end,\n+    }),\n+  }\n+end\n+\n+---@package\n+function Completor:dismiss()\n+  local current = assert(self.current)\n+  api.nvim_buf_del_extmark(self.bufnr, namespace, current.extmark)\n+  api.nvim_del_autocmd(current.autocmd)\n+  self.current = nil\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+function Completor:request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2188274095",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33972,
        "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
        "discussion_id": "2188274095",
        "commented_code": "@@ -0,0 +1,253 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.inline_completion.CurrentItem\n+---@field index integer\n+---@field extmark integer\n+---@field autocmd integer\n+\n+---@class (private) vim.lsp.inline_completion.Item\n+---@field client_id integer\n+---@field item lsp.InlineCompletionItem\n+\n+---@class (private) vim.lsp.inline_completion.Completor\n+---@field active table<integer, vim.lsp.inline_completion.Completor?>\n+---@field bufnr integer\n+---@field items vim.lsp.inline_completion.Item[]\n+---@field current? vim.lsp.inline_completion.CurrentItem\n+local Completor = { active = {} }\n+\n+---@package\n+---@param bufnr integer\n+function Completor.new(bufnr)\n+  local self = setmetatable({}, { __index = Completor })\n+  self.bufnr = bufnr\n+  return self\n+end\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+---@package\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+function Completor:handler(results)\n+  ---@type vim.lsp.inline_completion.Item[]\n+  local items = {}\n+\n+  for client_id, result in pairs(results) do\n+    local client = assert(vim.lsp.get_client_by_id(client_id))\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        item.range['start'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['start'], client.offset_encoding)\n+        item.range['end'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['end'], client.offset_encoding)\n+        table.insert(items, { client_id = client_id, item = item })\n+      end\n+    end\n+  end\n+\n+  if #items ~= 0 then\n+    self.items = items\n+    self:present(1)\n+  end\n+end\n+\n+---@package\n+---@param index integer\n+---@param show_index? boolean\n+function Completor:present(index, show_index)\n+  if self.current then\n+    self:dismiss()\n+  end\n+  self.current = {\n+    index = index,\n+    extmark = set_extmark(\n+      self.bufnr,\n+      self.items[index].item,\n+      show_index and (' (%d/%d)'):format(index, #self.items) or nil\n+    ),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      buffer = self.bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        self:dismiss()\n+      end,\n+    }),\n+  }\n+end\n+\n+---@package\n+function Completor:dismiss()\n+  local current = assert(self.current)\n+  api.nvim_buf_del_extmark(self.bufnr, namespace, current.extmark)\n+  api.nvim_del_autocmd(current.autocmd)\n+  self.current = nil\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+function Completor:request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,",
        "comment_created_at": "2025-07-06T13:23:19+00:00",
        "comment_author": "ribru17",
        "comment_body": "`make_position_params` also returns the `textDocument`, maybe we could just call this to create the params and inject the `context` field? Or keep it how it is now but put the result of `make_position_params()` in another variable and read its fields to populate both `textDocument` and `position`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2188335063",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33972,
        "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
        "discussion_id": "2188274095",
        "commented_code": "@@ -0,0 +1,253 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.inline_completion.CurrentItem\n+---@field index integer\n+---@field extmark integer\n+---@field autocmd integer\n+\n+---@class (private) vim.lsp.inline_completion.Item\n+---@field client_id integer\n+---@field item lsp.InlineCompletionItem\n+\n+---@class (private) vim.lsp.inline_completion.Completor\n+---@field active table<integer, vim.lsp.inline_completion.Completor?>\n+---@field bufnr integer\n+---@field items vim.lsp.inline_completion.Item[]\n+---@field current? vim.lsp.inline_completion.CurrentItem\n+local Completor = { active = {} }\n+\n+---@package\n+---@param bufnr integer\n+function Completor.new(bufnr)\n+  local self = setmetatable({}, { __index = Completor })\n+  self.bufnr = bufnr\n+  return self\n+end\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+---@package\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+function Completor:handler(results)\n+  ---@type vim.lsp.inline_completion.Item[]\n+  local items = {}\n+\n+  for client_id, result in pairs(results) do\n+    local client = assert(vim.lsp.get_client_by_id(client_id))\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        item.range['start'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['start'], client.offset_encoding)\n+        item.range['end'].character =\n+          util._get_line_byte_from_position(self.bufnr, item.range['end'], client.offset_encoding)\n+        table.insert(items, { client_id = client_id, item = item })\n+      end\n+    end\n+  end\n+\n+  if #items ~= 0 then\n+    self.items = items\n+    self:present(1)\n+  end\n+end\n+\n+---@package\n+---@param index integer\n+---@param show_index? boolean\n+function Completor:present(index, show_index)\n+  if self.current then\n+    self:dismiss()\n+  end\n+  self.current = {\n+    index = index,\n+    extmark = set_extmark(\n+      self.bufnr,\n+      self.items[index].item,\n+      show_index and (' (%d/%d)'):format(index, #self.items) or nil\n+    ),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      buffer = self.bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        self:dismiss()\n+      end,\n+    }),\n+  }\n+end\n+\n+---@package\n+function Completor:dismiss()\n+  local current = assert(self.current)\n+  api.nvim_buf_del_extmark(self.bufnr, namespace, current.extmark)\n+  api.nvim_del_autocmd(current.autocmd)\n+  self.current = nil\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+function Completor:request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,",
        "comment_created_at": "2025-07-06T14:13:34+00:00",
        "comment_author": "ofseed",
        "comment_body": "I chose the first approach. I noticed that `make_position_params` and `make_range_params` directly return the completed parameters instead of `lsp.Position` or `lsp.Range`, which makes their behavior somewhat inconsistent with `make_text_document_params` and a bit awkward to use. I hope there can be a better solution.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198401291",
    "pr_number": 34837,
    "pr_file": "runtime/lua/vim/diagnostic.lua",
    "created_at": "2025-07-10T18:21:41+00:00",
    "commented_code": "local float_bufnr, winnr = vim.lsp.util.open_floating_preview(lines, 'plaintext', opts)\n   vim.bo[float_bufnr].path = vim.bo[bufnr].path\n \n+  -- TODO: Handle this generally (like vim.ui.open()), rather than overriding gf.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2198401291",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34837,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2198401291",
        "commented_code": "@@ -2412,6 +2415,19 @@ function M.open_float(opts, ...)\n   local float_bufnr, winnr = vim.lsp.util.open_floating_preview(lines, 'plaintext', opts)\n   vim.bo[float_bufnr].path = vim.bo[bufnr].path\n \n+  -- TODO: Handle this generally (like vim.ui.open()), rather than overriding gf.",
        "comment_created_at": "2025-07-10T18:21:41+00:00",
        "comment_author": "justinmk",
        "comment_body": "```suggestion\n  -- TODO: Handle this generally (like vim.ui.open()), rather than overriding gf. #7282\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2148832025",
    "pr_number": 34508,
    "pr_file": "runtime/lua/vim/lsp/protocol.lua",
    "created_at": "2025-06-15T21:28:53+00:00",
    "commented_code": "workspaceEdit = {\n         resourceOperations = { 'rename', 'create', 'delete' },\n         normalizesLineEndings = true,\n+        changeAnnotationSupport = { groupsOnLabel = true },",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2148832025",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34508,
        "pr_file": "runtime/lua/vim/lsp/protocol.lua",
        "discussion_id": "2148832025",
        "commented_code": "@@ -558,6 +558,7 @@ function protocol.make_client_capabilities()\n       workspaceEdit = {\n         resourceOperations = { 'rename', 'create', 'delete' },\n         normalizesLineEndings = true,\n+        changeAnnotationSupport = { groupsOnLabel = true },",
        "comment_created_at": "2025-06-15T21:28:53+00:00",
        "comment_author": "ribru17",
        "comment_body": "Does this mean we can also mark `honorsChangeAnnotations` as true for rename/code action capabilities?",
        "pr_file_module": null
      },
      {
        "comment_id": "2148832428",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34508,
        "pr_file": "runtime/lua/vim/lsp/protocol.lua",
        "discussion_id": "2148832025",
        "commented_code": "@@ -558,6 +558,7 @@ function protocol.make_client_capabilities()\n       workspaceEdit = {\n         resourceOperations = { 'rename', 'create', 'delete' },\n         normalizesLineEndings = true,\n+        changeAnnotationSupport = { groupsOnLabel = true },",
        "comment_created_at": "2025-06-15T21:31:07+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "ahhh I knew I was forgetting something. I think we can!",
        "pr_file_module": null
      },
      {
        "comment_id": "2148834455",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34508,
        "pr_file": "runtime/lua/vim/lsp/protocol.lua",
        "discussion_id": "2148832025",
        "commented_code": "@@ -558,6 +558,7 @@ function protocol.make_client_capabilities()\n       workspaceEdit = {\n         resourceOperations = { 'rename', 'create', 'delete' },\n         normalizesLineEndings = true,\n+        changeAnnotationSupport = { groupsOnLabel = true },",
        "comment_created_at": "2025-06-15T21:40:17+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Kind of weird that there are separate capabilities for those since they should be implied by the workspace capability, but LSP is weird sometimes.",
        "pr_file_module": null
      },
      {
        "comment_id": "2148845037",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34508,
        "pr_file": "runtime/lua/vim/lsp/protocol.lua",
        "discussion_id": "2148832025",
        "commented_code": "@@ -558,6 +558,7 @@ function protocol.make_client_capabilities()\n       workspaceEdit = {\n         resourceOperations = { 'rename', 'create', 'delete' },\n         normalizesLineEndings = true,\n+        changeAnnotationSupport = { groupsOnLabel = true },",
        "comment_created_at": "2025-06-15T22:31:27+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "We can indeed support these for rename and code actions since they call `apply_workspace_edit`, which is the code modified in this PR :)",
        "pr_file_module": null
      }
    ]
  }
]