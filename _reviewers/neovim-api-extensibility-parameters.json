[
  {
    "discussion_id": "1493831698",
    "pr_number": 27223,
    "pr_file": "src/nvim/api/tabpage.c",
    "created_at": "2024-02-18T19:40:31+00:00",
    "commented_code": "# include \"api/tabpage.c.generated.h\"\n #endif\n \n+/// Opens a new tabpage with a single window\n+///\n+/// @param buffer   Buffer handle, or 0 for current buffer\n+/// @param enter    Boolean, whether to enter the new tabpage\n+/// @param[out] err Error details, if any\n+/// @return Handle to newly created tabpage\n+Tabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Error *err)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1493831698",
        "repo_full_name": "neovim/neovim",
        "pr_number": 27223,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1493831698",
        "commented_code": "@@ -14,6 +16,27 @@\n # include \"api/tabpage.c.generated.h\"\n #endif\n \n+/// Opens a new tabpage with a single window\n+///\n+/// @param buffer   Buffer handle, or 0 for current buffer\n+/// @param enter    Boolean, whether to enter the new tabpage\n+/// @param[out] err Error details, if any\n+/// @return Handle to newly created tabpage\n+Tabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Error *err)",
        "comment_created_at": "2024-02-18T19:40:31+00:00",
        "comment_author": "justinmk",
        "comment_body": "- We almost always want to accept `opts` and return `Dict`, unless we are 100% certain we won't need to expand the features in the future (which is usually wrong).\r\n- But in this case the returned value is a tabpage handle which (1) already represents an object, and (2) is symmetric with `nvim_open_win`.  So it's probably acceptable to return `Tabpage`.\r\n- For `opts` (or `config`?) I could imagine an arg that controls which tabpage to open next to (like `:[count]tabnew`).\r\n\r\n```suggestion\r\nTabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Dict opts, Error *err)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1493832968",
        "repo_full_name": "neovim/neovim",
        "pr_number": 27223,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1493831698",
        "commented_code": "@@ -14,6 +16,27 @@\n # include \"api/tabpage.c.generated.h\"\n #endif\n \n+/// Opens a new tabpage with a single window\n+///\n+/// @param buffer   Buffer handle, or 0 for current buffer\n+/// @param enter    Boolean, whether to enter the new tabpage\n+/// @param[out] err Error details, if any\n+/// @return Handle to newly created tabpage\n+Tabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Error *err)",
        "comment_created_at": "2024-02-18T19:49:22+00:00",
        "comment_author": "willothy",
        "comment_body": "Good to know, I'll remember that in the future. I'll update this and add an opts dict parameter. I think the `after` idea mirroring `[count]tabnew` should be trivial because it's handled by `win_new_tabpage`, so maybe I'll add that in as well.\r\n\r\n> is symmetric with nvim_open_win\r\n\r\nAgreed, this was my logic for returning a tabpage handle.\r\n\r\nre: whether this API is wanted\r\n\r\nThis was largely an experiment and I don't have a real use case for it, so no worries if it's not wanted.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119590367",
    "pr_number": 33953,
    "pr_file": "src/nvim/ui_client.c",
    "created_at": "2025-06-01T20:58:30+00:00",
    "commented_code": "(const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2119590367",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33953,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2119590367",
        "commented_code": "@@ -284,6 +285,59 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);",
        "comment_created_at": "2025-06-01T20:58:30+00:00",
        "comment_author": "justinmk",
        "comment_body": "FUTURE: we might want to give more control over how the server is stopped. E.g.:\r\n\r\n    :restart +qall\r\n\r\n(similar to `:help +cmd`). This also frees up \"!\" to be used for some other purpose.",
        "pr_file_module": null
      },
      {
        "comment_id": "2122447847",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33953,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2119590367",
        "commented_code": "@@ -284,6 +285,59 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);",
        "comment_created_at": "2025-06-03T01:50:52+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "For this, I'm thinking along the lines of:\nIf the custom command argument is passed we make a `rpc_send_event` to the server to call `nvim_command` and then proceed with the `ui_client_detach` and `channel_close` (I wonder if these two are required if the command actually quits, might have to experiment a little bit).\nShould also think about what to do if the command being passed doesn't actually quit the server.\n\nWill make a draft PR working on the follow-ups from this PR soon..",
        "pr_file_module": null
      },
      {
        "comment_id": "2186027194",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33953,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2119590367",
        "commented_code": "@@ -284,6 +285,59 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);",
        "comment_created_at": "2025-07-04T19:35:21+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "#34788 ",
        "pr_file_module": null
      }
    ]
  }
]