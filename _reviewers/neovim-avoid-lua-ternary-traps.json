[
  {
    "discussion_id": "1807728270",
    "pr_number": 30841,
    "pr_file": "runtime/lua/vim/lsp/document_highlight.lua",
    "created_at": "2024-10-20T08:28:13+00:00",
    "commented_code": "+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1807728270",
        "repo_full_name": "neovim/neovim",
        "pr_number": 30841,
        "pr_file": "runtime/lua/vim/lsp/document_highlight.lua",
        "discussion_id": "1807728270",
        "commented_code": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
        "comment_created_at": "2024-10-20T08:28:13+00:00",
        "comment_author": "glepnir",
        "comment_body": "```suggestion\r\n    bufstate.enabled = enable ~= globalstate.enabled and enable or nil\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1807730115",
        "repo_full_name": "neovim/neovim",
        "pr_number": 30841,
        "pr_file": "runtime/lua/vim/lsp/document_highlight.lua",
        "discussion_id": "1807728270",
        "commented_code": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
        "comment_created_at": "2024-10-20T08:38:10+00:00",
        "comment_author": "ofseed",
        "comment_body": "This is not correct. `and ... or` is not equivalent to the regular ternary operation. In `condition and expr1 or expr2`, if the value of `expr1` can be `nil` or `false`, regardless of the result of `condition`, the obtained value will always be `expr2`. This is what I deliberately want to avoid.",
        "pr_file_module": null
      },
      {
        "comment_id": "1807731350",
        "repo_full_name": "neovim/neovim",
        "pr_number": 30841,
        "pr_file": "runtime/lua/vim/lsp/document_highlight.lua",
        "discussion_id": "1807728270",
        "commented_code": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
        "comment_created_at": "2024-10-20T08:44:23+00:00",
        "comment_author": "glepnir",
        "comment_body": "aha I remember encountering a similar nil trap but I forgot about it. it should be avoided. enable always has a boolean available i think, we have `vim.F.if_nil`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195439638",
    "pr_number": 34797,
    "pr_file": "runtime/lua/vim/lsp/util.lua",
    "created_at": "2025-07-09T16:17:24+00:00",
    "commented_code": "end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')\n+end\n+\n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil\n+    else\n+      vim.g[client_var] = enable\n+    end\n+  elseif bufnr then\n+    if enable == vim.g[var] then\n+      vim.b[bufnr][var] = nil\n+    else\n+      vim.b[bufnr][var] = enable",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2195439638",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2195439638",
        "commented_code": "@@ -2335,6 +2335,85 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')\n+end\n+\n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil\n+    else\n+      vim.g[client_var] = enable\n+    end\n+  elseif bufnr then\n+    if enable == vim.g[var] then\n+      vim.b[bufnr][var] = nil\n+    else\n+      vim.b[bufnr][var] = enable",
        "comment_created_at": "2025-07-09T16:17:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "ternary",
        "pr_file_module": null
      },
      {
        "comment_id": "2195459170",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2195439638",
        "commented_code": "@@ -2335,6 +2335,85 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')\n+end\n+\n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('feature', feature, 'string')\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = make_enable_var(feature)\n+  local client_var = make_enable_var(feature, client_id)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil\n+    else\n+      vim.g[client_var] = enable\n+    end\n+  elseif bufnr then\n+    if enable == vim.g[var] then\n+      vim.b[bufnr][var] = nil\n+    else\n+      vim.b[bufnr][var] = enable",
        "comment_created_at": "2025-07-09T16:27:28+00:00",
        "comment_author": "ofseed",
        "comment_body": "Ternary cannot be used here because\r\n```lua\r\nvim.b[bufnr][var] = enable == vim.g[var] and nil or enable\r\n```\r\nIn this case, `and nil or enable` will always return `enable`, `nil` will never be returned.",
        "pr_file_module": null
      }
    ]
  }
]