[
  {
    "discussion_id": "2230097537",
    "pr_number": 35058,
    "pr_file": "runtime/doc/filetype.txt",
    "created_at": "2025-07-25T04:15:07+00:00",
    "commented_code": "To disable linting completely, set >lua\n \n \tvim.g.query_lint_on = {}\n+\n+Automatic reload of treesitter queries for installed parsers is enabled by\n+default on `BufWritePost`. To change the events that trigger autoreload, use >lua\n+\n+\tvim.g.query_autoreload_on = { 'InsertLeave', 'TextChanged' }",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2230097537",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35058,
        "pr_file": "runtime/doc/filetype.txt",
        "discussion_id": "2230097537",
        "commented_code": "@@ -905,6 +905,15 @@ Linting of treesitter queries for installed parsers using\n To disable linting completely, set >lua\n \n \tvim.g.query_lint_on = {}\n+\n+Automatic reload of treesitter queries for installed parsers is enabled by\n+default on `BufWritePost`. To change the events that trigger autoreload, use >lua\n+\n+\tvim.g.query_autoreload_on = { 'InsertLeave', 'TextChanged' }",
        "comment_created_at": "2025-07-25T04:15:07+00:00",
        "comment_author": "justinmk",
        "comment_body": "no, special-purpose options are clusmsy and a maintenance burden.\n\nthe *actual* implementation is only a few lines long. since users have to find this documentation and add this option anyway, it's nearly equivalent to just documenting an event handler that they can copy into their config. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1618366751",
    "pr_number": 29073,
    "pr_file": "runtime/doc/lua-plugin.txt",
    "created_at": "2024-05-29T07:42:03+00:00",
    "commented_code": "+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1618366751",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T07:42:03+00:00",
        "comment_author": "echasnovski",
        "comment_body": "Although technically correct (newcomers indeed often do that), I would like to ask to rephrase the \"intro\" or remove it completely due to implied negative connotations (\"newcomers often don't know what they are doing and they do this, so ...\").\r\n\r\nSame with using \"Cleanly separated ...\" (implying that \"not separated is not clean\"). I'd suggest using either \"explicitly separated\", \"intentionally separated\", or just \"separated\" without any description.\r\n\r\nHere is my suggestion:\r\n\r\n```suggestion\r\nSeparated configuration and smart initialization allow your plugin to work out\r\nof the box. Common approaches are:\r\n\r\n- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides\r\n  the default configuration and does not contain any initialization logic.\r\n- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that\r\n  your plugin reads from and validates at initialization time.\r\n  See also |lua-vim-variables|.\r\n\r\nTypically, automatic initialization logic is done in a |plugin| or |ftplugin|\r\nscript. See also |'runtimepath'|.\r\n\r\nIf you want to force users to explicitly enable plugin functionality, using\r\n`setup(opts)` function for both initialization and configuration is a common\r\npractice.\r\n\r\nNOTE: A well designed plugin has minimal impact on startup time.\r\n      See also |lua-plugin-lazy-loading|.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1618475939",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T08:44:49+00:00",
        "comment_author": "max397574",
        "comment_body": ">  I would like to ask to rephrase the \"intro\" or remove it completely due to implied negative connotations\r\n\r\nI don't know where you read this in between the lines\r\nI think it's perfectly fine and there is value in describing what the current \"de facto standard\" is and why that's not good\r\n\r\n> Same with using \"Cleanly separated ...\" (implying that \"not separated is not clean\"). I'd suggest using either \"explicitly separated\", \"intentionally separated\", or just \"separated\" without any description.\r\n\r\nAs far as I know as a non-native English speaker \"clean separation\" doesn't at all imply that otherwise it's not clean (which imo even is the case here but that's not the discussion right now)\r\nas duckduckgo ai chat said:\r\n> The term \"clean separation\" typically refers to a clear and distinct division or distinction between two things or entities. It does not necessarily imply cleanliness in the literal sense, but rather emphasizes a clear and unambiguous separation.\r\n\r\nI found \"separated configuration\" quite a confusing term though\r\nFor me this more sounds like you'd want people to split up the configuration even further",
        "pr_file_module": null
      },
      {
        "comment_id": "1618505186",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T09:00:14+00:00",
        "comment_author": "echasnovski",
        "comment_body": "> I think it's perfectly fine and there is value in describing what the current \"de facto standard\" is and why that's not good\r\n\r\nLess opinionated -> more better. A suggested rewrite contains both emphasis on configuration-initialization separation and the \"de facto standard\" which is a perfectly fine alternative if understanding the consequences.\r\n\r\n> I found \"separated configuration\" quite a confusing term though\r\n\r\nIt is not \"\\<separated configuration> and \\<initialization>\" but more like \"configuration and initialization are separate\". Both sound OK to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "1618653016",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T10:33:13+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "Given our previous negative interaction, I will give one response and then leave it to everyone else to decide.\r\n\r\nI disagree with your suggested change for the following reasons:\r\n\r\nIt is important to emphasize the consequences of defaulting to forcing users to call a `setup` function in the way I am doing. As @max397574 points out, it's a fact that newcomers usually default to this without understanding the consequences.\r\nAs mentioned in https://github.com/nvim-neorocks/nvim-best-practices/issues/5#issuecomment-2131367234, plugin authors can choose to diverge if they deem it necessary, which is made clear right at the beginning of this guide:\r\n\r\n> it is not intended as a set of rules...\r\n\r\nI disagree that the way I have phrased it has any negative connotations (which is a nitpick), as I don't make any recommendations not to diverge.\r\n\r\nI second @max397574's statement on \"clean separation\". But I see how this could be misinterpreted as negative for non-native speakers.\r\nHow about \"strict separation\" instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "1618698813",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T11:11:21+00:00",
        "comment_author": "echasnovski",
        "comment_body": "> It is important to emphasize the consequences of defaulting to forcing users to call a `setup` function\r\n\r\nIt *is* described in the suggested change: \"If you want to force users to explicitly enable plugin functionality, using ...\". Without unnecessary \"Newcomers often\" / \"even if they are happy\", as built-in docs usually prefer to be more on point.\r\n\r\n> How about \"strict separation\" instead?\r\n\r\nTo me this is also fine. Using no description is even better.",
        "pr_file_module": null
      },
      {
        "comment_id": "1618789572",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1618366751",
        "commented_code": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
        "comment_created_at": "2024-05-29T12:23:20+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "I strongly disagree that your suggestion \"is more on point\".\r\nThe sentence as you suggest would be redundant, as it lacks any reason for it, while losing the *emphasis* on the *very often overlooked* consequences. I have often heard people complain about being forced to call a `setup` function. Not once have I had anyone complain about *not being forced* to call one. Hence, I will not actively encourage doing so without good reason.\r\n\r\nIf anything, the phrasing, \"Newcomers will often...\" makes it clear that this advice is directed at newcomers, knowing that more advanced plugin developers will be able to make their own judgement.\r\n\r\n> To me this is also fine. \r\n\r\n~I'll adjust it later today.~\r\nDone.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1622308575",
    "pr_number": 29073,
    "pr_file": "runtime/doc/lua-plugin.txt",
    "created_at": "2024-05-31T11:45:56+00:00",
    "commented_code": "+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1622308575",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T11:45:56+00:00",
        "comment_author": "dundargoc",
        "comment_body": "This also seems completely broken. Let's take it easy with the recommendations unless we're certain they're reliable.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622319299",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T11:56:59+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "I maintain this one. How are you testing it?\r\nIt has a workflow that runs on itself: https://github.com/mrcjkb/lua-typecheck-action/actions/workflows/typecheck.yml\r\nIt just needs a properly configured .luarc.json for packages that have dependencies.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622319961",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T11:57:37+00:00",
        "comment_author": "max397574",
        "comment_body": "I use this and also know a few projects which use it where it works just fine",
        "pr_file_module": null
      },
      {
        "comment_id": "1622326442",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T12:04:16+00:00",
        "comment_author": "dundargoc",
        "comment_body": ">  How are you testing it?\r\n\r\nhttps://github.com/dundargoc/neovim/actions/runs/9317809971/workflow\r\nhttps://github.com/dundargoc/neovim/actions/runs/9317809971/job/25648875919\r\n\r\nIt complains about file under `/nix/store` for some reason, even though it says only the repo is supposed to be tested?",
        "pr_file_module": null
      },
      {
        "comment_id": "1622332825",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T12:10:27+00:00",
        "comment_author": "dundargoc",
        "comment_body": "OK, you know what? Let's continue the discussion in your repo. Leave this in for now.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622343497",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T12:20:49+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "That's because the neovim `.luarc.json` has\r\n\r\n```json\r\n    \"library\": [\r\n      \"runtime/lua\",\r\n      \"${3rd}/busted/library\", \r\n      \"${3rd}/luv/library\"\r\n    ],\r\n```\r\n\r\n`\"${3rd}/busted/library\"` ([which is deprecated btw](https://github.com/LuaLS/lua-language-server/wiki/Libraries#built-in-libraries)) is what is failing.\r\n\r\nYou need `\"diagnostic.libraryFiles\": \"Disable\"` in the `.luarc.json`. Although I'm not sure if `runtime/lua` is a library for Neovim, as you would probably want to get diagnostics for that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1622519795",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T14:34:37+00:00",
        "comment_author": "dundargoc",
        "comment_body": "@mrcjkb wanna send a separate PR to neovim to fix `.luarc.json` and `test/.luarc.json`? You seem to already have a good grasp of how these should be configured. (I looked at the docs for luals and got scared)",
        "pr_file_module": null
      },
      {
        "comment_id": "1622605515",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T15:39:29+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "Sure. I'm not quite sure how to fix the `${3rd}` libraries here. That would require [using addons](https://github.com/LuaLS/LLS-Addons). Maybe we should open an issue first?",
        "pr_file_module": null
      },
      {
        "comment_id": "1622772690",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1622308575",
        "commented_code": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
        "comment_created_at": "2024-05-31T17:55:09+00:00",
        "comment_author": "dundargoc",
        "comment_body": "https://github.com/neovim/neovim/pull/29115",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094169684",
    "pr_number": 34009,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2025-05-17T17:11:51+00:00",
    "commented_code": "\u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2094169684",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:11:51+00:00",
        "comment_author": "gpanders",
        "comment_body": "Does this download happen automatically? So if a user has `vim.pack.add` in their init.lua, as soon as they start Nvim it will automatically start downloading things?\r\n\r\nI wonder if this should be a more explicit action. Nvim automatically downloading things without any user action feels a bit iffy (I don't think there's any precedent for that?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2094169923",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:13:08+00:00",
        "comment_author": "clason",
        "comment_body": "Spell files? I would consider a `vim.pack.add` line as \"explicitly opting in\" here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094174061",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:36:19+00:00",
        "comment_author": "gpanders",
        "comment_body": "I've never downloaded a spell file in Vim, but reading the docs briefly it says \r\n\r\n>But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nIn this case it's still requiring an explicit action (confirmation) from the user, not just immediately downloading.\r\n\r\n>I would consider a vim.pack.add line as \"explicitly opting in\" here.\r\n\r\nUsers are required to have `vim.pack.add` in their init file to even load/enable the plugin. So I don't think it's acceptable to treat that as tacit approval of \"yes please download things automatically\".\r\n\r\nIt's not difficult to show a single confirmation dialog that says \"Install the following plugins? [Y/n]\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2094174802",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:40:28+00:00",
        "comment_author": "clason",
        "comment_body": "No, I mean adding `vim.pack.add('thisplugin')` _is_ giving confirmation to \"yes, please download _this plugin_\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\n> But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nWhich it is by default, in Nvim (not Vim IIRC). You're right that this shows a prompt (correctly in this case, because the action is not directly tied to what triggers it, unlike here).\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2094175776",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:45:25+00:00",
        "comment_author": "gpanders",
        "comment_body": ">Which it is by default, in Nvim (not Vim IIRC).\r\n\r\nThe plugin is enabled, but still \"offers to download the spell file\" (implying there is a prompt).\r\n\r\n>No, I mean adding vim.pack.add('thisplugin') is giving confirmation to \"yes, please download this plugin\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\nThe bootstrapping situation is exactly the one I'm thinking of where I would want a prompt. If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBut if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094175991",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T17:46:49+00:00",
        "comment_author": "gpanders",
        "comment_body": ">If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBeing able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094179150",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T18:02:11+00:00",
        "comment_author": "lewis6991",
        "comment_body": "Pretty sure there is a prompt for spell files, and I also agree plugin installs should require a prompt.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094183625",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T18:28:46+00:00",
        "comment_author": "echasnovski",
        "comment_body": "My thinking is what @clason described: putting explicit `vim.pack.add()` in the config should be enough of a confirmation already. \r\n\r\n> Being able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.\r\n\r\nPlugin will be installed already after `vim.pack.add()`, no need to either restart Nvim or `vim.pack.update()`. So I don't really understand what this is about.\r\n\r\n> But if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.\r\n\r\nWell, right now it is known (all plugins are listed), but if/when there is packspec support, this indeed won't be known 100% in advance.\r\n\r\nI am open to adding some confirmation before installing. Some questions:\r\n- Is something like `vim.fn.confirm('These plugins will be installed:\\n...')` enough or should be more interactive (like allowing to specify which plugins to install)? I'd guess it should be enough.\r\n- Should it be one confirmation per install (i.e. several times pressing `y`) or one confirm for all installs? I'd guess one for all plugins should be enough, otherwise it is a tedious amount of \"y\" during bootstrap.\r\n- Should it be run only during startup (i.e. `vim.v.vim_did_enter == 0`) or for every install? I'd go with only during startup, because otherwise it should be a conscious decision (i.e. enough of confirmation already).",
        "pr_file_module": null
      },
      {
        "comment_id": "2094185053",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T18:38:41+00:00",
        "comment_author": "lewis6991",
        "comment_body": "I think a single prompt for a list of plugins and done any time a plugin is installed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094194341",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-17T19:30:19+00:00",
        "comment_author": "gpanders",
        "comment_body": ">Is something like vim.fn.confirm('These plugins will be installed:\\n...') enough or should be more interactive \r\n\r\nYes I think that's fine\r\n\r\n>Should it be one confirmation per install (i.e. several times pressing y) or one confirm for all installs\r\n\r\nOne for all, just list all of the ones that are going to be installed (this can be done in a floating window or something if there are a lot)\r\n\r\n>putting explicit vim.pack.add() in the config should be enough of a confirmation already.\r\n\r\nThere are cases where you DIDN'T put `vim.pack.add` in the config though (you are using a config that somebody else provided to reproduce a bug), or when you did the context/situation was different (maybe I put `vim.pack.add` in my config several months ago, but now I'm cloning onto a new machine and I want to review what's going to be downloaded before Nvim starts cloning a bunch of repos automatically).\r\n\r\n> Plugin will be installed already after vim.pack.add(), no need to either restart Nvim or vim.pack.update(). So I don't really understand what this is about.\r\n\r\nAs a general design rule Nvim shouldn't be downloading things from the internet without some explicit consent/action from the user. If the user runs `vim.pack.add()` interactively then I agree that is sufficiently explicit. But if it's run programmatically (as part of startup in init.lua) I don't think it is, at least not as a default.\r\n\r\nIn Emacs, `use-package` has an `ensure` option that users can set to have the plugin automatically downloaded. That is another option we could explore (set either per-plugin as part of `vim.pack.add()` or globally as part of `vim.pack.config()`). But as a **default**, we should err on the side of requiring user action.",
        "pr_file_module": null
      },
      {
        "comment_id": "2096135993",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094169684",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+\u2022 Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+\u2022 Restart Nvim.\n+\n+Remove plugin from disk:\n+\u2022 Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+\u2022 *PackInstallPre* - before trying to install plugin on disk.\n+\u2022 *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+\u2022 *PackUpdatePre* - before trying to update plugin's state.\n+\u2022 *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      \u2022 {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      \u2022 {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      \u2022 {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    \u2022 Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    \u2022 Tag name.\n+                    \u2022 Branch name.\n+                    \u2022 \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    \u2022 Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    \u2022 For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      \u2022 If exists, do nothin in this step.\n+      \u2022 If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
        "comment_created_at": "2025-05-19T16:47:06+00:00",
        "comment_author": "echasnovski",
        "comment_body": "There is now a confirm before any plugin(s) install. It uses `vim.fn.confirm()`, but during startup it is drawing issues (see #34088), so for now it is a bit hacky workaround with delayed `vim.print()` and manual processing of the key asked via `vim.fn.getcharstr()`. After #34088 is solved (or 'extui' becomes default, whichever is sooner), the `vim.fn.confirm()` can be used universally.",
        "pr_file_module": null
      }
    ]
  }
]