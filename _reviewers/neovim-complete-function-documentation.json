[
  {
    "discussion_id": "2230114466",
    "pr_number": 34014,
    "pr_file": "runtime/lua/vim/diagnostic.lua",
    "created_at": "2025-07-25T04:33:12+00:00",
    "commented_code": "diagnostic_cache[bufnr][namespace] = diagnostics\n   end\n \n+  once_buf_loaded(bufnr, function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2230114466",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2230114466",
        "commented_code": "@@ -1247,6 +1292,48 @@ function M.set(namespace, bufnr, diagnostics, opts)\n     diagnostic_cache[bufnr][namespace] = diagnostics\n   end\n \n+  once_buf_loaded(bufnr, function()",
        "comment_created_at": "2025-07-25T04:33:12+00:00",
        "comment_author": "justinmk",
        "comment_body": "This is a whole new blob of code that future developers must study. We really need to give hints where we can. In this case, the key idea seems to be (correct if wrong):\n\n\n```suggestion\n  -- Compute positions, set them as extmarks, and store in diagnostic._extmark_id\n  -- (used by get_logical_location to adjust positions). \n  once_buf_loaded(bufnr, function()\n```\n\nNone of this will be obvious in the future. We need to leave hints.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861724526",
    "pr_number": 31364,
    "pr_file": "runtime/lua/vim/fs.lua",
    "created_at": "2024-11-28T08:30:21+00:00",
    "commented_code": "--- Use `math.huge` to place no limit on the number of matches.\n --- (default: `1`)\n --- @field limit? number\n+---\n+--- Do not traverse matching directories.\n+--- If omitted, all directories are searched recursively.\n+--- @field skip? (fun(dir_name: string): boolean)|nil",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1861724526",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/lua/vim/fs.lua",
        "discussion_id": "1861724526",
        "commented_code": "@@ -190,6 +190,14 @@ end\n --- Use `math.huge` to place no limit on the number of matches.\n --- (default: `1`)\n --- @field limit? number\n+---\n+--- Do not traverse matching directories.\n+--- If omitted, all directories are searched recursively.\n+--- @field skip? (fun(dir_name: string): boolean)|nil",
        "comment_created_at": "2024-11-28T08:30:21+00:00",
        "comment_author": "lewis6991",
        "comment_body": "```suggestion\n--- @field skip? fun(dir: string): boolean\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203466979",
    "pr_number": 34914,
    "pr_file": "runtime/lua/vim/treesitter/query.lua",
    "created_at": "2025-07-13T17:03:35+00:00",
    "commented_code": "return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203466979",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/treesitter/query.lua",
        "discussion_id": "2203466979",
        "commented_code": "@@ -1161,10 +1161,23 @@ function M.omnifunc(findstart, base)\n   return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
        "comment_created_at": "2025-07-13T17:03:35+00:00",
        "comment_author": "justinmk",
        "comment_body": "```suggestion\n--- Can also be shown with `:EditQuery`. [:EditQuery]()\n--- `:EditQuery <tab>` completes injected language names.\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2203469547",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/treesitter/query.lua",
        "discussion_id": "2203466979",
        "commented_code": "@@ -1161,10 +1161,23 @@ function M.omnifunc(findstart, base)\n   return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
        "comment_created_at": "2025-07-13T17:14:42+00:00",
        "comment_author": "PeterCardenas",
        "comment_body": "formatting is a bit different in the auto generated doc with this change. most notably the `:EditQuery` tag isn't right aligned anymore. don't think we want that?\r\n| Before | After |\r\n|--------|--------|\r\n| <img width=\"693\" height=\"292\" alt=\"image\" src=\"https://github.com/user-attachments/assets/ba86ada5-d097-440b-a83d-86259c0d7b8a\" />  | <img width=\"693\" height=\"292\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6a40eff2-6045-4000-8ca1-0b79a6fd3e3e\" /> |",
        "pr_file_module": null
      },
      {
        "comment_id": "2203476506",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/treesitter/query.lua",
        "discussion_id": "2203466979",
        "commented_code": "@@ -1161,10 +1161,23 @@ function M.omnifunc(findstart, base)\n   return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
        "comment_created_at": "2025-07-13T17:43:07+00:00",
        "comment_author": "justinmk",
        "comment_body": "try this\r\n\r\n```\r\n--- Can also be shown with `:EditQuery`. `:EditQuery <tab>` completes injected language names. [:EditQuery]()\r\n```\r\n\r\nbtw, I'm confused about the mention of \"injected languages\" in your docs, since it looks like `_complete()` just iterates all available parsers, not specific to \"injected languages\" for the current buffer.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203520179",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/treesitter/query.lua",
        "discussion_id": "2203466979",
        "commented_code": "@@ -1161,10 +1161,23 @@ function M.omnifunc(findstart, base)\n   return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
        "comment_created_at": "2025-07-13T20:52:22+00:00",
        "comment_author": "PeterCardenas",
        "comment_body": "tried this, not a huge fan of the result. i was hoping the tag would be on the first line but maybe there's a way to do that\r\n\r\n<img width=\"693\" height=\"292\" alt=\"image\" src=\"https://github.com/user-attachments/assets/3aa59125-a564-4f11-805c-4c79ad73916f\" />\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2203520336",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/treesitter/query.lua",
        "discussion_id": "2203466979",
        "commented_code": "@@ -1161,10 +1161,23 @@ function M.omnifunc(findstart, base)\n   return vim.treesitter._query_linter.omnifunc(findstart, base)\n end\n \n+--- Returns available treesitter languages.\n+function M._complete()\n+  local parsers = vim.api.nvim_get_runtime_file('parser/*', true)\n+  local parser_names_set = {} ---@type table<string, boolean>\n+  for _, parser in ipairs(parsers) do\n+    local parser_name = vim.fn.fnamemodify(parser, ':t:r')\n+    parser_names_set[parser_name] = true\n+  end\n+  return vim.tbl_keys(parser_names_set)\n+end\n+\n --- Opens a live editor to query the buffer you started from.\n ---\n --- Can also be shown with `:EditQuery`. [:EditQuery]()\n ---\n+--- `:EditQuery <tab>` completes injected language names.",
        "comment_created_at": "2025-07-13T20:52:56+00:00",
        "comment_author": "PeterCardenas",
        "comment_body": "also updated the doc to be more correct thanks for catching that \ud83d\ude4f ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2171513335",
    "pr_number": 34140,
    "pr_file": "runtime/lua/vim/net.lua",
    "created_at": "2025-06-27T10:15:21+00:00",
    "commented_code": "+local M = {}\n+\n+--- Makes an HTTP GET request to the given URL.\n+--- Can either return the body or save it to a file.\n+---\n+--- @param url string The URL to fetch.\n+--- @param opts? table Optional parameters:\n+---   - verbose (boolean|nil): Enables curl verbose output.\n+---   - retry   (integer|nil): Number of retries on transient failures (default: 3).\n+---   - output  (string|nil): If set, path to save response body instead of returning it.\n+--- @param on_exit? fun(err?: string, content?: string)\n+---   - Async mode if provided: always called as\n+---       - on_exit(err)           on failure\n+---       - on_exit(nil, content)  on success; if `opts.output` is set, `content` is nil\n+---   - Sync mode if omitted: returns\n+---       - (nil, err)             on failure\n+---       - (true, nil)            on success when `opts.output` is set\n+---       - (content, nil)         on success when returning the body",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2171513335",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34140,
        "pr_file": "runtime/lua/vim/net.lua",
        "discussion_id": "2171513335",
        "commented_code": "@@ -0,0 +1,78 @@\n+local M = {}\n+\n+--- Makes an HTTP GET request to the given URL.\n+--- Can either return the body or save it to a file.\n+---\n+--- @param url string The URL to fetch.\n+--- @param opts? table Optional parameters:\n+---   - verbose (boolean|nil): Enables curl verbose output.\n+---   - retry   (integer|nil): Number of retries on transient failures (default: 3).\n+---   - output  (string|nil): If set, path to save response body instead of returning it.\n+--- @param on_exit? fun(err?: string, content?: string)\n+---   - Async mode if provided: always called as\n+---       - on_exit(err)           on failure\n+---       - on_exit(nil, content)  on success; if `opts.output` is set, `content` is nil\n+---   - Sync mode if omitted: returns\n+---       - (nil, err)             on failure\n+---       - (true, nil)            on success when `opts.output` is set\n+---       - (content, nil)         on success when returning the body",
        "comment_created_at": "2025-06-27T10:15:21+00:00",
        "comment_author": "justinmk",
        "comment_body": "need a `@return` tag. maybe helpful to look at `vim.system` example https://github.com/neovim/neovim/blob/e518666f1db110abcfc899e1227da949998cdd82/runtime/lua/vim/_editor.lua#L130",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174766897",
    "pr_number": 34140,
    "pr_file": "runtime/lua/vim/net.lua",
    "created_at": "2025-06-30T10:37:44+00:00",
    "commented_code": "+local M = {}\n+\n+--- Makes an HTTP GET request to the given URL.\n+---\n+--- This function operates in two modes:\n+---   - Synchronous (blocking): If `on_response` is omitted, it waits for the\n+---   request to complete and returns the result.\n+---   - Asynchronous (non-blocking): If `on_response` is provided, it returns\n+---   immediately and invokes the callback with the result later.\n+---\n+--- @param url string The URL for the request.\n+--- @param opts? table Optional parameters:\n+---   - `verbose` (boolean|nil): Enables curl verbose output.\n+---   - `retry`   (integer|nil): Number of retries on transient failures (default: 3).\n+---   - `output`  (string|nil): A file path to save the response body to. If set, the success value will be `true` instead of the response body.\n+--- @param on_response? fun(err?: string, content?: string|boolean) Optional callback for async execution.\n+---   It is invoked with `(err, nil)` on failure or `(nil, content)` on success.\n+--- @return string|boolean|nil In sync mode, returns the response body or `true` on success; otherwise `nil`",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2174766897",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34140,
        "pr_file": "runtime/lua/vim/net.lua",
        "discussion_id": "2174766897",
        "commented_code": "@@ -0,0 +1,71 @@\n+local M = {}\n+\n+--- Makes an HTTP GET request to the given URL.\n+---\n+--- This function operates in two modes:\n+---   - Synchronous (blocking): If `on_response` is omitted, it waits for the\n+---   request to complete and returns the result.\n+---   - Asynchronous (non-blocking): If `on_response` is provided, it returns\n+---   immediately and invokes the callback with the result later.\n+---\n+--- @param url string The URL for the request.\n+--- @param opts? table Optional parameters:\n+---   - `verbose` (boolean|nil): Enables curl verbose output.\n+---   - `retry`   (integer|nil): Number of retries on transient failures (default: 3).\n+---   - `output`  (string|nil): A file path to save the response body to. If set, the success value will be `true` instead of the response body.\n+--- @param on_response? fun(err?: string, content?: string|boolean) Optional callback for async execution.\n+---   It is invoked with `(err, nil)` on failure or `(nil, content)` on success.\n+--- @return string|boolean|nil In sync mode, returns the response body or `true` on success; otherwise `nil`",
        "comment_created_at": "2025-06-30T10:37:44+00:00",
        "comment_author": "justinmk",
        "comment_body": "the wording is kind of confusing, is this rewording correct?\r\n```suggestion\r\n--- @return string|boolean|nil Response body (sync) or `true` (async) on success; `nil` on failure\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989238393",
    "pr_number": 32619,
    "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
    "created_at": "2025-03-11T13:09:23+00:00",
    "commented_code": "return nil, 0\n end\n \n+---@param m MarkInfo\n+---@param buf integer\n+---@param line integer\n+---@param next_marks MarkInfo[]\n+local function add_mark(m, buf, line, next_marks)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1989238393",
        "repo_full_name": "neovim/neovim",
        "pr_number": 32619,
        "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
        "discussion_id": "1989238393",
        "commented_code": "@@ -306,6 +310,33 @@ local function get_spell(capture_name)\n   return nil, 0\n end\n \n+---@param m MarkInfo\n+---@param buf integer\n+---@param line integer\n+---@param next_marks MarkInfo[]\n+local function add_mark(m, buf, line, next_marks)",
        "comment_created_at": "2025-03-11T13:09:23+00:00",
        "comment_author": "justinmk",
        "comment_body": "is there a 1-line docstring that can give insight into what this does? E.g. \"Sets a mark unless...\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175357976",
    "pr_number": 34715,
    "pr_file": "runtime/lua/vim/version.lua",
    "created_at": "2025-06-30T15:28:36+00:00",
    "commented_code": "end\n     end\n     ---@diagnostic enable: need-check-nil\n-    return setmetatable({ from = from, to = to }, { __index = VersionRange })\n+    return setmetatable({ from = from, to = to }, range_mt)\n+  end\n+end\n+\n+--- Compute common range",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2175357976",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34715,
        "pr_file": "runtime/lua/vim/version.lua",
        "discussion_id": "2175357976",
        "commented_code": "@@ -341,7 +353,24 @@ function M.range(spec) -- Adapted from https://github.com/folke/lazy.nvim\n       end\n     end\n     ---@diagnostic enable: need-check-nil\n-    return setmetatable({ from = from, to = to }, { __index = VersionRange })\n+    return setmetatable({ from = from, to = to }, range_mt)\n+  end\n+end\n+\n+--- Compute common range",
        "comment_created_at": "2025-06-30T15:28:36+00:00",
        "comment_author": "justinmk",
        "comment_body": "missing `@since`\r\n\r\n```suggestion\r\n--- Computes the common range shared by the given ranges.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2175484352",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34715,
        "pr_file": "runtime/lua/vim/version.lua",
        "discussion_id": "2175357976",
        "commented_code": "@@ -341,7 +353,24 @@ function M.range(spec) -- Adapted from https://github.com/folke/lazy.nvim\n       end\n     end\n     ---@diagnostic enable: need-check-nil\n-    return setmetatable({ from = from, to = to }, { __index = VersionRange })\n+    return setmetatable({ from = from, to = to }, range_mt)\n+  end\n+end\n+\n+--- Compute common range",
        "comment_created_at": "2025-06-30T16:34:30+00:00",
        "comment_author": "echasnovski",
        "comment_body": "> missing `@since`\r\n\r\nDidn't add it since it results in the \"WARNING: This feature is experimental/unstable.\" in documentation. So I thought it is planned to somehow be added during the release. And there is no `@since 14` in the code base yet, although there were new functions (#33703).\r\n\r\nSo just to double-check: should it still be added now?",
        "pr_file_module": null
      },
      {
        "comment_id": "2175490516",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34715,
        "pr_file": "runtime/lua/vim/version.lua",
        "discussion_id": "2175357976",
        "commented_code": "@@ -341,7 +353,24 @@ function M.range(spec) -- Adapted from https://github.com/folke/lazy.nvim\n       end\n     end\n     ---@diagnostic enable: need-check-nil\n-    return setmetatable({ from = from, to = to }, { __index = VersionRange })\n+    return setmetatable({ from = from, to = to }, range_mt)\n+  end\n+end\n+\n+--- Compute common range",
        "comment_created_at": "2025-06-30T16:38:28+00:00",
        "comment_author": "echasnovski",
        "comment_body": "I've found [the recommendation](https://github.com/neovim/neovim/blob/d6d1bfd20da05e8bd40441ecdc0ac75af66f77eb/runtime/doc/develop.txt#L250-L253), so it is probably intended. My bad, didn't know about this. Added `@since 14`.",
        "pr_file_module": null
      }
    ]
  }
]