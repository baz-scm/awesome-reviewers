[
  {
    "discussion_id": "1860686411",
    "pr_number": 31364,
    "pr_file": "runtime/lua/vim/fs.lua",
    "created_at": "2024-11-27T13:41:54+00:00",
    "commented_code": "for other, type_ in M.dir(dir) do\n         local f = M.joinpath(dir, other)\n+        local stat = vim.uv.fs_stat(f)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1860686411",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/lua/vim/fs.lua",
        "discussion_id": "1860686411",
        "commented_code": "@@ -308,6 +318,8 @@ function M.find(names, opts)\n \n       for other, type_ in M.dir(dir) do\n         local f = M.joinpath(dir, other)\n+        local stat = vim.uv.fs_stat(f)",
        "comment_created_at": "2024-11-27T13:41:54+00:00",
        "comment_author": "justinmk",
        "comment_body": "this is a perf cost, which should only be paid if it's actually necessary (i.e. depending on the `follow` param)",
        "pr_file_module": null
      },
      {
        "comment_id": "1860828983",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/lua/vim/fs.lua",
        "discussion_id": "1860686411",
        "commented_code": "@@ -308,6 +318,8 @@ function M.find(names, opts)\n \n       for other, type_ in M.dir(dir) do\n         local f = M.joinpath(dir, other)\n+        local stat = vim.uv.fs_stat(f)",
        "comment_created_at": "2024-11-27T15:06:40+00:00",
        "comment_author": "mike325",
        "comment_body": "Ok, I'll change it ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203519819",
    "pr_number": 34914,
    "pr_file": "runtime/lua/vim/_defaults.lua",
    "created_at": "2025-07-13T20:50:48+00:00",
    "commented_code": "vim.api.nvim_create_user_command('EditQuery', function(cmd)\n     vim.treesitter.query.edit(cmd.fargs[1])\n-  end, { desc = 'Edit treesitter query', nargs = '?' })\n+  end, {\n+    desc = 'Edit treesitter query',\n+    nargs = '?',\n+    complete = vim.treesitter.language._complete,",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203519819",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2203519819",
        "commented_code": "@@ -23,7 +23,11 @@ do\n \n   vim.api.nvim_create_user_command('EditQuery', function(cmd)\n     vim.treesitter.query.edit(cmd.fargs[1])\n-  end, { desc = 'Edit treesitter query', nargs = '?' })\n+  end, {\n+    desc = 'Edit treesitter query',\n+    nargs = '?',\n+    complete = vim.treesitter.language._complete,",
        "comment_created_at": "2025-07-13T20:50:48+00:00",
        "comment_author": "justinmk",
        "comment_body": "perf nit: vim.ts is [lazy loaded](https://github.com/neovim/neovim/blob/7cd5356a6f89a46d83bbba9b7f6496b67f054629/runtime/lua/vim/treesitter.lua#L6) so let's wrap this to avoid eager-loading it:\n```suggestion\n    complete = function(...) return vim.treesitter.language._complete(...) end,\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2203521281",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34914,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2203519819",
        "commented_code": "@@ -23,7 +23,11 @@ do\n \n   vim.api.nvim_create_user_command('EditQuery', function(cmd)\n     vim.treesitter.query.edit(cmd.fargs[1])\n-  end, { desc = 'Edit treesitter query', nargs = '?' })\n+  end, {\n+    desc = 'Edit treesitter query',\n+    nargs = '?',\n+    complete = vim.treesitter.language._complete,",
        "comment_created_at": "2025-07-13T20:57:04+00:00",
        "comment_author": "PeterCardenas",
        "comment_body": "works like a charm \ud83d\udc68\u200d\ud83c\udf73 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2069154349",
    "pr_number": 33723,
    "pr_file": "runtime/lua/vim/_defaults.lua",
    "created_at": "2025-04-30T17:27:53+00:00",
    "commented_code": "end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2069154349",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2069154349",
        "commented_code": "@@ -925,6 +925,57 @@ do\n       end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
        "comment_created_at": "2025-04-30T17:27:53+00:00",
        "comment_author": "mfussenegger",
        "comment_body": "Not sure if this is a good idea to do by default as it can either lead to more redraws than necessary or in the worst case interfere with messages that are being polled (like lsp status)\r\n\r\nI think ideally the full `DiagnosticChanged` autocmd should only be setup on demand if the default status line is actually used. Otherwise everyone pays the cost for the string formatting.",
        "pr_file_module": null
      },
      {
        "comment_id": "2069244311",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2069154349",
        "commented_code": "@@ -925,6 +925,57 @@ do\n       end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
        "comment_created_at": "2025-04-30T18:35:31+00:00",
        "comment_author": "antonk52",
        "comment_body": "The schedule is most likely unnecessary here. I initially added it to my custom statusline because of some plugin compatibility issue. I can test this implementation without scheduling redraws.\r\n\r\nIs there a preferred way of detecting if statusline was changed from default? I can only think of using `OptionSet` autocommand for statusline",
        "pr_file_module": null
      },
      {
        "comment_id": "2069534561",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2069154349",
        "commented_code": "@@ -925,6 +925,57 @@ do\n       end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
        "comment_created_at": "2025-04-30T21:58:36+00:00",
        "comment_author": "justinmk",
        "comment_body": "> I think ideally the full `DiagnosticChanged` autocmd should only be setup on demand if the default status line is actually used. Otherwise everyone pays the cost for the string formatting.\r\n\r\nOh, should we introduce this as `vim.diagnostic.status()` (compare `vim.lsp.status()`) ?\r\n\r\nAnd yes, making this conditional on whether the default statusline is used, makes sense.",
        "pr_file_module": null
      },
      {
        "comment_id": "2069569241",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2069154349",
        "commented_code": "@@ -925,6 +925,57 @@ do\n       end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
        "comment_created_at": "2025-04-30T22:31:54+00:00",
        "comment_author": "antonk52",
        "comment_body": "> Oh, should we introduce this as vim.diagnostic.status() (compare vim.lsp.status()) ?\r\n\r\nMakes sense. Looking at the implementation `vim.lsp.status()` displays messages from all clients for all buffers. `vim.diagnostic.status()` would have to be local to the current or passed in buffer for starters, can be expanded to display all diagnostics if needed.\r\n\r\nIf we decided to go with `vim.diagnostic.status()` would it be used in the statusline as is i.e. \r\n```lua\r\nvim.opt.status = '... %{luaeval(\"vim.diagnostic.status()\")} ...'\r\n```\r\n\r\n> And yes, making this conditional on whether the default statusline is used, makes sense.\r\n\r\nI've updated the code to sub/unsub when statusline is changed",
        "pr_file_module": null
      },
      {
        "comment_id": "2069668207",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "runtime/lua/vim/_defaults.lua",
        "discussion_id": "2069154349",
        "commented_code": "@@ -925,6 +925,57 @@ do\n       end\n     end\n   end\n+\n+  vim.api.nvim_create_autocmd('DiagnosticChanged', {\n+    pattern = '*',\n+    desc = 'Update buffer diagnostics in the statusline',\n+    group = vim.api.nvim_create_augroup('nvim.statusline', {}),\n+    callback = function()\n+      local bufnr = vim.api.nvim_get_current_buf()\n+      local diagnostics = vim.diagnostic.get(bufnr)\n+\n+      local counts = { errors = 0, warnings = 0, info = 0, hints = 0 }\n+      local severity = vim.diagnostic.severity\n+\n+      for _, d in ipairs(diagnostics) do\n+        if d.severity == severity.ERROR then\n+          counts.errors = counts.errors + 1\n+        elseif d.severity == severity.WARN then\n+          counts.warnings = counts.warnings + 1\n+        elseif d.severity == severity.INFO then\n+          counts.info = counts.info + 1\n+        elseif d.severity == severity.HINT then\n+          counts.hints = counts.hints + 1\n+        end\n+      end\n+\n+      local result = {}\n+      if counts.errors > 0 then\n+        table.insert(result, 'e:' .. counts.errors)\n+      end\n+      if counts.warnings > 0 then\n+        table.insert(result, 'w:' .. counts.warnings)\n+      end\n+      if counts.info > 0 then\n+        table.insert(result, 'i:' .. counts.info)\n+      end\n+      if counts.hints > 0 then\n+        table.insert(result, 'h:' .. counts.hints)\n+      end\n+\n+      local result_str = table.concat(result, ' ')\n+\n+      if #result_str > 0 then\n+        result_str = result_str .. '  '\n+      end\n+\n+      vim.b[bufnr].buffer_diagnostics = result_str\n+\n+      vim.schedule(function()\n+        vim.cmd.redrawstatus()\n+      end)",
        "comment_created_at": "2025-04-30T23:40:21+00:00",
        "comment_author": "justinmk",
        "comment_body": "> `vim.lsp.status()` displays messages from all clients for all buffers.\r\n\r\nvim.diagnostics.status() doesn't need to exactly match how lsp.status works; it's just a reference for the \"shape\" + name.\r\n\r\n\r\n\r\n> If we decided to go with `vim.diagnostic.status()` would it be used in the statusline as is i.e.\r\n\r\nI think so. And then the [default 'statusline'](https://github.com/neovim/neovim/blob/6577d72d819dde32abeacd6a72d6ba64483f7ddc/src/nvim/options.lua#L8577-L8584) will reflect this too, which is Good. If there are \"performance\" issues, those need to be fixed internally in `status()`, e.g. by debouncing or whatever.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126972372",
    "pr_number": 34009,
    "pr_file": "runtime/lua/vim/pack.lua",
    "created_at": "2025-06-04T16:10:37+00:00",
    "commented_code": "+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\n%s\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\n%s\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\n\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\n\n' .. table.concat(sources, '\n') .. '\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2126972372",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2126972372",
        "commented_code": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then",
        "comment_created_at": "2025-06-04T16:10:37+00:00",
        "comment_author": "lewis6991",
        "comment_body": "There are redundant `fs_stat` calls here which can be reduced. You can add a private `installed: boolean?` field to `vim.pack.Plug` to effectively cache these calls. `nil`: unknown, `true`: installed, `false`: not installed.",
        "pr_file_module": null
      }
    ]
  }
]