[
  {
    "discussion_id": "2191305351",
    "pr_number": 34637,
    "pr_file": "runtime/lua/vim/lsp/on_type_formatting.lua",
    "created_at": "2025-07-08T01:41:24+00:00",
    "commented_code": "+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local method = lsp.protocol.Methods.textDocument_onTypeFormatting\n+\n+local schedule = vim.schedule\n+local current_buf = api.nvim_get_current_buf\n+local mode = api.nvim_get_mode\n+\n+local ns = api.nvim_create_namespace('nvim.lsp.on_type_formatting')\n+local augroup = api.nvim_create_augroup('nvim.lsp.on_type_formatting', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.on_type_formatting.BufTriggers table<string, table<integer, vim.lsp.Client>>\n+\n+--- A map from bufnr -> trigger character -> client ID -> client\n+--- @type table<integer, vim.lsp.on_type_formatting.BufTriggers>\n+local buf_handles = {}\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return string.format('nvim.lsp.on_type_formatting.client:%d', client_id)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2191305351",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/lua/vim/lsp/on_type_formatting.lua",
        "discussion_id": "2191305351",
        "commented_code": "@@ -0,0 +1,267 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local method = lsp.protocol.Methods.textDocument_onTypeFormatting\n+\n+local schedule = vim.schedule\n+local current_buf = api.nvim_get_current_buf\n+local mode = api.nvim_get_mode\n+\n+local ns = api.nvim_create_namespace('nvim.lsp.on_type_formatting')\n+local augroup = api.nvim_create_augroup('nvim.lsp.on_type_formatting', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.on_type_formatting.BufTriggers table<string, table<integer, vim.lsp.Client>>\n+\n+--- A map from bufnr -> trigger character -> client ID -> client\n+--- @type table<integer, vim.lsp.on_type_formatting.BufTriggers>\n+local buf_handles = {}\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return string.format('nvim.lsp.on_type_formatting.client:%d', client_id)",
        "comment_created_at": "2025-07-08T01:41:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "I like the \":\" idea to separate the variable part. (Though hopefully we don't need that in the future when we have [user-defined event keys](https://github.com/neovim/neovim/pull/34637#discussion_r2188886306).)",
        "pr_file_module": null
      },
      {
        "comment_id": "2196346095",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/lua/vim/lsp/on_type_formatting.lua",
        "discussion_id": "2191305351",
        "commented_code": "@@ -0,0 +1,267 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local method = lsp.protocol.Methods.textDocument_onTypeFormatting\n+\n+local schedule = vim.schedule\n+local current_buf = api.nvim_get_current_buf\n+local mode = api.nvim_get_mode\n+\n+local ns = api.nvim_create_namespace('nvim.lsp.on_type_formatting')\n+local augroup = api.nvim_create_augroup('nvim.lsp.on_type_formatting', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.on_type_formatting.BufTriggers table<string, table<integer, vim.lsp.Client>>\n+\n+--- A map from bufnr -> trigger character -> client ID -> client\n+--- @type table<integer, vim.lsp.on_type_formatting.BufTriggers>\n+local buf_handles = {}\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return string.format('nvim.lsp.on_type_formatting.client:%d', client_id)",
        "comment_created_at": "2025-07-10T02:05:14+00:00",
        "comment_author": "justinmk",
        "comment_body": "[Rethinking this](https://github.com/neovim/neovim/pull/34388#discussion_r2196343686), can we just store the state on the client instead of creating per-client augroups?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188324252",
    "pr_number": 34797,
    "pr_file": "runtime/lua/vim/lsp/util.lua",
    "created_at": "2025-07-06T14:03:23+00:00",
    "commented_code": "end\n end\n \n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2188324252",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2188324252",
        "commented_code": "@@ -2323,6 +2323,77 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil",
        "comment_created_at": "2025-07-06T14:03:23+00:00",
        "comment_author": "ribru17",
        "comment_body": "Is this necessary if we set client values to `nil` below, when applying global settings? Is it possible to just ignore if the global value is already set?",
        "pr_file_module": null
      },
      {
        "comment_id": "2188360282",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2188324252",
        "commented_code": "@@ -2323,6 +2323,77 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil",
        "comment_created_at": "2025-07-06T14:40:32+00:00",
        "comment_author": "ofseed",
        "comment_body": "This is to delete the client value when the global value and client value are the same, so that the next time the global value is changed, the client value is also \"changed\" accordingly (at this point it becomes `nil`, thus falling back to the global value)",
        "pr_file_module": null
      },
      {
        "comment_id": "2188363689",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2188324252",
        "commented_code": "@@ -2323,6 +2323,77 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil",
        "comment_created_at": "2025-07-06T14:44:10+00:00",
        "comment_author": "ribru17",
        "comment_body": "That makes sense, but I think if the global value is set then the client value should *already* be `nil`, no? Thus this line is unnecessary, and we can just focus on the case when the global value is not set? I could be wrong, but it looks like every time the global value is changed, it updates all attached clients and sets their properties to `nil` if they are equal to the new global value",
        "pr_file_module": null
      },
      {
        "comment_id": "2188374319",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2188324252",
        "commented_code": "@@ -2323,6 +2323,77 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@class vim.lsp.enable.Filter\n+---@inlinedoc\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all\n+---@field client_id? integer\n+\n+---@param feature string\n+---@param filter? vim.lsp.enable.Filter\n+function M._is_enabled(feature, filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+  return vim.F.if_nil(client_id and vim.g[client_var], vim.g[var])\n+    and vim.F.if_nil(bufnr and vim.b[bufnr][var], vim.g[var])\n+end\n+\n+---@param feature string\n+---@param enable? boolean\n+---@param filter? vim.lsp.enable.Filter\n+function M._enable(feature, enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+  local client_id = filter.client_id\n+  assert(\n+    not (bufnr and client_id),\n+    'Only one of `bufnr` or `client_id` filters can be specified at a time.'\n+  )\n+\n+  local var = ('__lsp_%s_enabled'):format(feature)\n+  local client_var = ('__lsp_%s_client_%d_enabled'):format(feature, client_id or 0)\n+\n+  if client_id then\n+    if enable == vim.g[var] then\n+      vim.g[client_var] = nil",
        "comment_created_at": "2025-07-06T14:58:58+00:00",
        "comment_author": "ofseed",
        "comment_body": "For example, in this case, it is used to handle the situation where the global value is `true` and the client value is set to `false` by the user. Then, when the user sets the client value to `true`, we destroy it by setting it to `nil`. During this process, the global value does not change because we still need this part of the code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195446699",
    "pr_number": 34797,
    "pr_file": "runtime/lua/vim/lsp/util.lua",
    "created_at": "2025-07-09T16:20:43+00:00",
    "commented_code": "end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2195446699",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2195446699",
        "commented_code": "@@ -2335,6 +2335,85 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')",
        "comment_created_at": "2025-07-09T16:20:43+00:00",
        "comment_author": "justinmk",
        "comment_body": "(Non-blocker; we can try it out and revisit later:) This could end up creating many top-level _lsp_...<client> vars. That's pretty noisy. It might be worth the trouble to define a single _lsp_enable table and manage things in there, e.g.\n\n```\n_lsp_enable = {\n  client = { [42] = true, [78] = true, ... },\n}\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2203117959",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2195446699",
        "commented_code": "@@ -2335,6 +2335,85 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')",
        "comment_created_at": "2025-07-13T03:33:23+00:00",
        "comment_author": "justinmk",
        "comment_body": "Actually, could we store this info on the `client` object itself? Any time the \"key\" is the client-id, it usually makes sense to store the data on the `Client`. Or is that not possible because of \"lifecycle\" requirements (maybe we need a `on_dispose` hook on the client?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2203142442",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34797,
        "pr_file": "runtime/lua/vim/lsp/util.lua",
        "discussion_id": "2195446699",
        "commented_code": "@@ -2335,6 +2335,85 @@ function M._refresh(method, opts)\n   end\n end\n \n+---@param feature string\n+---@param client_id? integer\n+local function make_enable_var(feature, client_id)\n+  return ('_lsp_enabled_%s%s'):format(feature, client_id and ('_client_%d'):format(client_id) or '')",
        "comment_created_at": "2025-07-13T03:58:23+00:00",
        "comment_author": "ofseed",
        "comment_body": "This is one of the \"reasonable approach\" I mentioned in that comment below. I'd seriously consider this solution, but I'm wondering if we can directly change the logic since we changed the information stored in the `client`, since `vim.lsp.Capability` is created in `client.lua`? There may be a better way to achieve the goal of `enable`, `Capability` and `Client` working together.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196343686",
    "pr_number": 34388,
    "pr_file": "runtime/lua/vim/lsp/linked_editing_range.lua",
    "created_at": "2025-07-10T02:02:03+00:00",
    "commented_code": "+--- @brief\n+--- The `vim.lsp.linked_editing_range` module enables \"linked editing\" via a language server's\n+--- `textDocument/linkedEditingRange` request. Linked editing ranges are synchronized text regions,\n+--- meaning changes in one range are mirrored in all the others. This is helpful in HTML files for\n+--- example, where the language server can update the text of a closing tag if its opening tag was\n+--- changed.\n+---\n+--- LSP spec: https://microsoft.github.io/language-server-protocol/specification/#textDocument_linkedEditingRange\n+\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local lsp = vim.lsp\n+local method = require('vim.lsp.protocol').Methods.textDocument_linkedEditingRange\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+local M = {}\n+\n+---@class (private) vim.lsp.linked_editing_range.state Global state for linked editing ranges\n+---An optional word pattern (regular expression) that describes valid contents for the given ranges.\n+---@field word_pattern string\n+---@field range_index? integer The index of the range that the cursor is on.\n+---@field namespace integer namespace for range extmarks\n+\n+---@class (private) vim.lsp.linked_editing_range.LinkedEditor\n+---@field active table<integer, vim.lsp.linked_editing_range.LinkedEditor>\n+---@field bufnr integer\n+---@field augroup integer augroup for buffer events\n+---@field client_states table<integer, vim.lsp.linked_editing_range.state>\n+local LinkedEditor = { active = {} }\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return 'nvim.lsp.linked_editing_range.client:' .. client_id\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:attach(client_id)\n+  if self.client_states[client_id] then\n+    return\n+  end\n+  self.client_states[client_id] = {\n+    namespace = api.nvim_create_namespace('nvim.lsp.linked_editing_range:' .. client_id),\n+    word_pattern = '^[%w%-_]*$',\n+  }\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function clear_ranges(bufnr, client_state)\n+  api.nvim_buf_clear_namespace(bufnr, client_state.namespace, 0, -1)\n+  client_state.range_index = nil\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:detach(client_id)\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  --TODO: delete namespace if/when that becomes possible\n+  clear_ranges(self.bufnr, client_state)\n+  self.client_states[client_id] = nil\n+\n+  -- Destroy the LinkedEditor instance if we are detaching the last client\n+  if vim.tbl_isempty(self.client_states) then\n+    api.nvim_del_augroup_by_id(self.augroup)\n+    LinkedEditor.active[self.bufnr] = nil\n+  end\n+end\n+\n+---Syncs the text of each linked editing range after a range has been edited.\n+---\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function update_ranges(bufnr, client_state)\n+  if not client_state.range_index then\n+    return\n+  end\n+\n+  local ns = client_state.namespace\n+  local ranges = api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, { details = true })\n+  if #ranges <= 1 then\n+    return\n+  end\n+\n+  local r = assert(ranges[client_state.range_index])\n+  local replacement = api.nvim_buf_get_text(bufnr, r[2], r[3], r[4].end_row, r[4].end_col, {})\n+\n+  if not string.match(table.concat(replacement, '\n'), client_state.word_pattern) then\n+    clear_ranges(bufnr, client_state)\n+    return\n+  end\n+\n+  -- Join text update changes into one undo chunk. If we came here from an undo, then return.\n+  local success = pcall(vim.cmd.undojoin)\n+  if not success then\n+    return\n+  end\n+\n+  for i, range in ipairs(ranges) do\n+    if i ~= client_state.range_index then\n+      api.nvim_buf_set_text(\n+        bufnr,\n+        range[2],\n+        range[3],\n+        range[4].end_row,\n+        range[4].end_col,\n+        replacement\n+      )\n+    end\n+  end\n+end\n+\n+---|lsp-handler| for the `textDocument/linkedEditingRange` request. Sets marks for the given ranges\n+---(if present) and tracks which range the cursor is currently inside.\n+---\n+---@package\n+---@param err lsp.ResponseError?\n+---@param result lsp.LinkedEditingRanges?\n+---@param ctx lsp.HandlerContext\n+function LinkedEditor:handler(err, result, ctx)\n+  if err then\n+    log.error('linkededitingrange', err)\n+    return\n+  end\n+\n+  local client_id = ctx.client_id\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) or util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  clear_ranges(bufnr, client_state)\n+\n+  if not result then\n+    return\n+  end\n+\n+  local client = assert(lsp.get_client_by_id(client_id))\n+\n+  local lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local curpos = api.nvim_win_get_cursor(0)\n+  local cursor_range = { curpos[1] - 1, curpos[2], curpos[1] - 1, curpos[2] }\n+  for i, range in ipairs(result.ranges) do\n+    local start_line = range.start.line\n+    local line = lines and lines[start_line + 1] or ''\n+    local start_col = vim.str_byteindex(line, client.offset_encoding, range.start.character, false)\n+    local end_line = range['end'].line\n+    line = lines and lines[end_line + 1] or ''\n+    local end_col = vim.str_byteindex(line, client.offset_encoding, range['end'].character, false)\n+\n+    api.nvim_buf_set_extmark(bufnr, client_state.namespace, start_line, start_col, {\n+      end_line = end_line,\n+      end_col = end_col,\n+      hl_group = 'LspReferenceTarget',\n+      right_gravity = false,\n+      end_right_gravity = true,\n+    })\n+\n+    local range_tuple = { start_line, start_col, end_line, end_col }\n+    if Range.contains(range_tuple, cursor_range) then\n+      client_state.range_index = i\n+    end\n+  end\n+\n+  -- TODO: Apply the client's own word pattern, if it exists\n+end\n+\n+---Refreshes the linked editing ranges by issuing a new request.\n+---@package\n+function LinkedEditor:refresh()\n+  local bufnr = self.bufnr\n+\n+  util._cancel_requests({\n+    bufnr = bufnr,\n+    method = method,\n+    type = 'pending',\n+  })\n+  lsp.buf_request(bufnr, method, function(client)\n+    return util.make_position_params(0, client.offset_encoding)\n+  end, function(...)\n+    self:handler(...)\n+  end)\n+end\n+\n+---Construct a new LinkedEditor for the buffer.\n+---\n+---@private\n+---@param bufnr integer\n+---@return vim.lsp.linked_editing_range.LinkedEditor\n+function LinkedEditor.new(bufnr)\n+  local self = setmetatable({}, { __index = LinkedEditor })\n+\n+  self.bufnr = bufnr\n+  local augroup =\n+    api.nvim_create_augroup('nvim.lsp.linked_editing_range:' .. bufnr, { clear = true })\n+  self.augroup = augroup\n+  self.client_states = {}\n+\n+  api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    buffer = bufnr,\n+    group = augroup,\n+    callback = function()\n+      for _, client_state in pairs(self.client_states) do\n+        update_ranges(bufnr, client_state)\n+      end\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      self:detach(args.data.client_id)\n+    end,\n+  })\n+\n+  LinkedEditor.active[bufnr] = self\n+  return self\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function attach_linked_editor(bufnr, client)\n+  local client_id = client.id\n+  if not lsp.buf_is_attached(bufnr, client_id) then\n+    vim.notify(\n+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,\n+      vim.log.levels.WARN\n+    )\n+    return\n+  end\n+\n+  if not vim.tbl_get(client.server_capabilities, 'linkedEditingRangeProvider') then\n+    vim.notify('[LSP] Server does not support linked editing ranges', vim.log.levels.WARN)\n+    return\n+  end\n+\n+  local linked_editor = LinkedEditor.active[bufnr] or LinkedEditor.new(bufnr)\n+  linked_editor:attach(client_id)\n+  linked_editor:refresh()\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function detach_linked_editor(bufnr, client)\n+  local linked_editor = LinkedEditor.active[bufnr]\n+  if not linked_editor then\n+    return\n+  end\n+\n+  linked_editor:detach(client.id)\n+end\n+\n+---@param enable boolean\n+---@param client vim.lsp.Client\n+local function toggle_linked_editing_for_client(enable, client)\n+  local handler = enable and attach_linked_editor or detach_linked_editor\n+  local client_id = client.id\n+\n+  -- Toggle for buffers already attached.\n+  for bufnr, _ in pairs(client.attached_buffers) do\n+    handler(bufnr, client)\n+  end\n+\n+  -- If disabling, only clear the attachment autocmd. If enabling, create it.\n+  local group = api.nvim_create_augroup(get_client_augroup(client_id), { clear = true })",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2196343686",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/lua/vim/lsp/linked_editing_range.lua",
        "discussion_id": "2196343686",
        "commented_code": "@@ -0,0 +1,361 @@\n+--- @brief\n+--- The `vim.lsp.linked_editing_range` module enables \"linked editing\" via a language server's\n+--- `textDocument/linkedEditingRange` request. Linked editing ranges are synchronized text regions,\n+--- meaning changes in one range are mirrored in all the others. This is helpful in HTML files for\n+--- example, where the language server can update the text of a closing tag if its opening tag was\n+--- changed.\n+---\n+--- LSP spec: https://microsoft.github.io/language-server-protocol/specification/#textDocument_linkedEditingRange\n+\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local lsp = vim.lsp\n+local method = require('vim.lsp.protocol').Methods.textDocument_linkedEditingRange\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+local M = {}\n+\n+---@class (private) vim.lsp.linked_editing_range.state Global state for linked editing ranges\n+---An optional word pattern (regular expression) that describes valid contents for the given ranges.\n+---@field word_pattern string\n+---@field range_index? integer The index of the range that the cursor is on.\n+---@field namespace integer namespace for range extmarks\n+\n+---@class (private) vim.lsp.linked_editing_range.LinkedEditor\n+---@field active table<integer, vim.lsp.linked_editing_range.LinkedEditor>\n+---@field bufnr integer\n+---@field augroup integer augroup for buffer events\n+---@field client_states table<integer, vim.lsp.linked_editing_range.state>\n+local LinkedEditor = { active = {} }\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return 'nvim.lsp.linked_editing_range.client:' .. client_id\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:attach(client_id)\n+  if self.client_states[client_id] then\n+    return\n+  end\n+  self.client_states[client_id] = {\n+    namespace = api.nvim_create_namespace('nvim.lsp.linked_editing_range:' .. client_id),\n+    word_pattern = '^[%w%-_]*$',\n+  }\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function clear_ranges(bufnr, client_state)\n+  api.nvim_buf_clear_namespace(bufnr, client_state.namespace, 0, -1)\n+  client_state.range_index = nil\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:detach(client_id)\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  --TODO: delete namespace if/when that becomes possible\n+  clear_ranges(self.bufnr, client_state)\n+  self.client_states[client_id] = nil\n+\n+  -- Destroy the LinkedEditor instance if we are detaching the last client\n+  if vim.tbl_isempty(self.client_states) then\n+    api.nvim_del_augroup_by_id(self.augroup)\n+    LinkedEditor.active[self.bufnr] = nil\n+  end\n+end\n+\n+---Syncs the text of each linked editing range after a range has been edited.\n+---\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function update_ranges(bufnr, client_state)\n+  if not client_state.range_index then\n+    return\n+  end\n+\n+  local ns = client_state.namespace\n+  local ranges = api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, { details = true })\n+  if #ranges <= 1 then\n+    return\n+  end\n+\n+  local r = assert(ranges[client_state.range_index])\n+  local replacement = api.nvim_buf_get_text(bufnr, r[2], r[3], r[4].end_row, r[4].end_col, {})\n+\n+  if not string.match(table.concat(replacement, '\\n'), client_state.word_pattern) then\n+    clear_ranges(bufnr, client_state)\n+    return\n+  end\n+\n+  -- Join text update changes into one undo chunk. If we came here from an undo, then return.\n+  local success = pcall(vim.cmd.undojoin)\n+  if not success then\n+    return\n+  end\n+\n+  for i, range in ipairs(ranges) do\n+    if i ~= client_state.range_index then\n+      api.nvim_buf_set_text(\n+        bufnr,\n+        range[2],\n+        range[3],\n+        range[4].end_row,\n+        range[4].end_col,\n+        replacement\n+      )\n+    end\n+  end\n+end\n+\n+---|lsp-handler| for the `textDocument/linkedEditingRange` request. Sets marks for the given ranges\n+---(if present) and tracks which range the cursor is currently inside.\n+---\n+---@package\n+---@param err lsp.ResponseError?\n+---@param result lsp.LinkedEditingRanges?\n+---@param ctx lsp.HandlerContext\n+function LinkedEditor:handler(err, result, ctx)\n+  if err then\n+    log.error('linkededitingrange', err)\n+    return\n+  end\n+\n+  local client_id = ctx.client_id\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) or util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  clear_ranges(bufnr, client_state)\n+\n+  if not result then\n+    return\n+  end\n+\n+  local client = assert(lsp.get_client_by_id(client_id))\n+\n+  local lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local curpos = api.nvim_win_get_cursor(0)\n+  local cursor_range = { curpos[1] - 1, curpos[2], curpos[1] - 1, curpos[2] }\n+  for i, range in ipairs(result.ranges) do\n+    local start_line = range.start.line\n+    local line = lines and lines[start_line + 1] or ''\n+    local start_col = vim.str_byteindex(line, client.offset_encoding, range.start.character, false)\n+    local end_line = range['end'].line\n+    line = lines and lines[end_line + 1] or ''\n+    local end_col = vim.str_byteindex(line, client.offset_encoding, range['end'].character, false)\n+\n+    api.nvim_buf_set_extmark(bufnr, client_state.namespace, start_line, start_col, {\n+      end_line = end_line,\n+      end_col = end_col,\n+      hl_group = 'LspReferenceTarget',\n+      right_gravity = false,\n+      end_right_gravity = true,\n+    })\n+\n+    local range_tuple = { start_line, start_col, end_line, end_col }\n+    if Range.contains(range_tuple, cursor_range) then\n+      client_state.range_index = i\n+    end\n+  end\n+\n+  -- TODO: Apply the client's own word pattern, if it exists\n+end\n+\n+---Refreshes the linked editing ranges by issuing a new request.\n+---@package\n+function LinkedEditor:refresh()\n+  local bufnr = self.bufnr\n+\n+  util._cancel_requests({\n+    bufnr = bufnr,\n+    method = method,\n+    type = 'pending',\n+  })\n+  lsp.buf_request(bufnr, method, function(client)\n+    return util.make_position_params(0, client.offset_encoding)\n+  end, function(...)\n+    self:handler(...)\n+  end)\n+end\n+\n+---Construct a new LinkedEditor for the buffer.\n+---\n+---@private\n+---@param bufnr integer\n+---@return vim.lsp.linked_editing_range.LinkedEditor\n+function LinkedEditor.new(bufnr)\n+  local self = setmetatable({}, { __index = LinkedEditor })\n+\n+  self.bufnr = bufnr\n+  local augroup =\n+    api.nvim_create_augroup('nvim.lsp.linked_editing_range:' .. bufnr, { clear = true })\n+  self.augroup = augroup\n+  self.client_states = {}\n+\n+  api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    buffer = bufnr,\n+    group = augroup,\n+    callback = function()\n+      for _, client_state in pairs(self.client_states) do\n+        update_ranges(bufnr, client_state)\n+      end\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      self:detach(args.data.client_id)\n+    end,\n+  })\n+\n+  LinkedEditor.active[bufnr] = self\n+  return self\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function attach_linked_editor(bufnr, client)\n+  local client_id = client.id\n+  if not lsp.buf_is_attached(bufnr, client_id) then\n+    vim.notify(\n+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,\n+      vim.log.levels.WARN\n+    )\n+    return\n+  end\n+\n+  if not vim.tbl_get(client.server_capabilities, 'linkedEditingRangeProvider') then\n+    vim.notify('[LSP] Server does not support linked editing ranges', vim.log.levels.WARN)\n+    return\n+  end\n+\n+  local linked_editor = LinkedEditor.active[bufnr] or LinkedEditor.new(bufnr)\n+  linked_editor:attach(client_id)\n+  linked_editor:refresh()\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function detach_linked_editor(bufnr, client)\n+  local linked_editor = LinkedEditor.active[bufnr]\n+  if not linked_editor then\n+    return\n+  end\n+\n+  linked_editor:detach(client.id)\n+end\n+\n+---@param enable boolean\n+---@param client vim.lsp.Client\n+local function toggle_linked_editing_for_client(enable, client)\n+  local handler = enable and attach_linked_editor or detach_linked_editor\n+  local client_id = client.id\n+\n+  -- Toggle for buffers already attached.\n+  for bufnr, _ in pairs(client.attached_buffers) do\n+    handler(bufnr, client)\n+  end\n+\n+  -- If disabling, only clear the attachment autocmd. If enabling, create it.\n+  local group = api.nvim_create_augroup(get_client_augroup(client_id), { clear = true })",
        "comment_created_at": "2025-07-10T02:02:03+00:00",
        "comment_author": "justinmk",
        "comment_body": "Looking at this again, IIUC the per-client augroups (`get_client_augroup`) are just to enable/disable a specific client? And thus the augroup is a way to manage state. \n\nSeems like a much better pattern would be to store the state on the client itself. Could shove it in a `_foo` field for now. Then we just need 1 general `LspAttach` handler , which checks the `_foo` field on the relevant client object.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198410668",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/lua/vim/lsp/linked_editing_range.lua",
        "discussion_id": "2196343686",
        "commented_code": "@@ -0,0 +1,361 @@\n+--- @brief\n+--- The `vim.lsp.linked_editing_range` module enables \"linked editing\" via a language server's\n+--- `textDocument/linkedEditingRange` request. Linked editing ranges are synchronized text regions,\n+--- meaning changes in one range are mirrored in all the others. This is helpful in HTML files for\n+--- example, where the language server can update the text of a closing tag if its opening tag was\n+--- changed.\n+---\n+--- LSP spec: https://microsoft.github.io/language-server-protocol/specification/#textDocument_linkedEditingRange\n+\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local lsp = vim.lsp\n+local method = require('vim.lsp.protocol').Methods.textDocument_linkedEditingRange\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+local M = {}\n+\n+---@class (private) vim.lsp.linked_editing_range.state Global state for linked editing ranges\n+---An optional word pattern (regular expression) that describes valid contents for the given ranges.\n+---@field word_pattern string\n+---@field range_index? integer The index of the range that the cursor is on.\n+---@field namespace integer namespace for range extmarks\n+\n+---@class (private) vim.lsp.linked_editing_range.LinkedEditor\n+---@field active table<integer, vim.lsp.linked_editing_range.LinkedEditor>\n+---@field bufnr integer\n+---@field augroup integer augroup for buffer events\n+---@field client_states table<integer, vim.lsp.linked_editing_range.state>\n+local LinkedEditor = { active = {} }\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return 'nvim.lsp.linked_editing_range.client:' .. client_id\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:attach(client_id)\n+  if self.client_states[client_id] then\n+    return\n+  end\n+  self.client_states[client_id] = {\n+    namespace = api.nvim_create_namespace('nvim.lsp.linked_editing_range:' .. client_id),\n+    word_pattern = '^[%w%-_]*$',\n+  }\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function clear_ranges(bufnr, client_state)\n+  api.nvim_buf_clear_namespace(bufnr, client_state.namespace, 0, -1)\n+  client_state.range_index = nil\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:detach(client_id)\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  --TODO: delete namespace if/when that becomes possible\n+  clear_ranges(self.bufnr, client_state)\n+  self.client_states[client_id] = nil\n+\n+  -- Destroy the LinkedEditor instance if we are detaching the last client\n+  if vim.tbl_isempty(self.client_states) then\n+    api.nvim_del_augroup_by_id(self.augroup)\n+    LinkedEditor.active[self.bufnr] = nil\n+  end\n+end\n+\n+---Syncs the text of each linked editing range after a range has been edited.\n+---\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function update_ranges(bufnr, client_state)\n+  if not client_state.range_index then\n+    return\n+  end\n+\n+  local ns = client_state.namespace\n+  local ranges = api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, { details = true })\n+  if #ranges <= 1 then\n+    return\n+  end\n+\n+  local r = assert(ranges[client_state.range_index])\n+  local replacement = api.nvim_buf_get_text(bufnr, r[2], r[3], r[4].end_row, r[4].end_col, {})\n+\n+  if not string.match(table.concat(replacement, '\\n'), client_state.word_pattern) then\n+    clear_ranges(bufnr, client_state)\n+    return\n+  end\n+\n+  -- Join text update changes into one undo chunk. If we came here from an undo, then return.\n+  local success = pcall(vim.cmd.undojoin)\n+  if not success then\n+    return\n+  end\n+\n+  for i, range in ipairs(ranges) do\n+    if i ~= client_state.range_index then\n+      api.nvim_buf_set_text(\n+        bufnr,\n+        range[2],\n+        range[3],\n+        range[4].end_row,\n+        range[4].end_col,\n+        replacement\n+      )\n+    end\n+  end\n+end\n+\n+---|lsp-handler| for the `textDocument/linkedEditingRange` request. Sets marks for the given ranges\n+---(if present) and tracks which range the cursor is currently inside.\n+---\n+---@package\n+---@param err lsp.ResponseError?\n+---@param result lsp.LinkedEditingRanges?\n+---@param ctx lsp.HandlerContext\n+function LinkedEditor:handler(err, result, ctx)\n+  if err then\n+    log.error('linkededitingrange', err)\n+    return\n+  end\n+\n+  local client_id = ctx.client_id\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) or util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  clear_ranges(bufnr, client_state)\n+\n+  if not result then\n+    return\n+  end\n+\n+  local client = assert(lsp.get_client_by_id(client_id))\n+\n+  local lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local curpos = api.nvim_win_get_cursor(0)\n+  local cursor_range = { curpos[1] - 1, curpos[2], curpos[1] - 1, curpos[2] }\n+  for i, range in ipairs(result.ranges) do\n+    local start_line = range.start.line\n+    local line = lines and lines[start_line + 1] or ''\n+    local start_col = vim.str_byteindex(line, client.offset_encoding, range.start.character, false)\n+    local end_line = range['end'].line\n+    line = lines and lines[end_line + 1] or ''\n+    local end_col = vim.str_byteindex(line, client.offset_encoding, range['end'].character, false)\n+\n+    api.nvim_buf_set_extmark(bufnr, client_state.namespace, start_line, start_col, {\n+      end_line = end_line,\n+      end_col = end_col,\n+      hl_group = 'LspReferenceTarget',\n+      right_gravity = false,\n+      end_right_gravity = true,\n+    })\n+\n+    local range_tuple = { start_line, start_col, end_line, end_col }\n+    if Range.contains(range_tuple, cursor_range) then\n+      client_state.range_index = i\n+    end\n+  end\n+\n+  -- TODO: Apply the client's own word pattern, if it exists\n+end\n+\n+---Refreshes the linked editing ranges by issuing a new request.\n+---@package\n+function LinkedEditor:refresh()\n+  local bufnr = self.bufnr\n+\n+  util._cancel_requests({\n+    bufnr = bufnr,\n+    method = method,\n+    type = 'pending',\n+  })\n+  lsp.buf_request(bufnr, method, function(client)\n+    return util.make_position_params(0, client.offset_encoding)\n+  end, function(...)\n+    self:handler(...)\n+  end)\n+end\n+\n+---Construct a new LinkedEditor for the buffer.\n+---\n+---@private\n+---@param bufnr integer\n+---@return vim.lsp.linked_editing_range.LinkedEditor\n+function LinkedEditor.new(bufnr)\n+  local self = setmetatable({}, { __index = LinkedEditor })\n+\n+  self.bufnr = bufnr\n+  local augroup =\n+    api.nvim_create_augroup('nvim.lsp.linked_editing_range:' .. bufnr, { clear = true })\n+  self.augroup = augroup\n+  self.client_states = {}\n+\n+  api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    buffer = bufnr,\n+    group = augroup,\n+    callback = function()\n+      for _, client_state in pairs(self.client_states) do\n+        update_ranges(bufnr, client_state)\n+      end\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      self:detach(args.data.client_id)\n+    end,\n+  })\n+\n+  LinkedEditor.active[bufnr] = self\n+  return self\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function attach_linked_editor(bufnr, client)\n+  local client_id = client.id\n+  if not lsp.buf_is_attached(bufnr, client_id) then\n+    vim.notify(\n+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,\n+      vim.log.levels.WARN\n+    )\n+    return\n+  end\n+\n+  if not vim.tbl_get(client.server_capabilities, 'linkedEditingRangeProvider') then\n+    vim.notify('[LSP] Server does not support linked editing ranges', vim.log.levels.WARN)\n+    return\n+  end\n+\n+  local linked_editor = LinkedEditor.active[bufnr] or LinkedEditor.new(bufnr)\n+  linked_editor:attach(client_id)\n+  linked_editor:refresh()\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function detach_linked_editor(bufnr, client)\n+  local linked_editor = LinkedEditor.active[bufnr]\n+  if not linked_editor then\n+    return\n+  end\n+\n+  linked_editor:detach(client.id)\n+end\n+\n+---@param enable boolean\n+---@param client vim.lsp.Client\n+local function toggle_linked_editing_for_client(enable, client)\n+  local handler = enable and attach_linked_editor or detach_linked_editor\n+  local client_id = client.id\n+\n+  -- Toggle for buffers already attached.\n+  for bufnr, _ in pairs(client.attached_buffers) do\n+    handler(bufnr, client)\n+  end\n+\n+  -- If disabling, only clear the attachment autocmd. If enabling, create it.\n+  local group = api.nvim_create_augroup(get_client_augroup(client_id), { clear = true })",
        "comment_created_at": "2025-07-10T18:27:13+00:00",
        "comment_author": "ribru17",
        "comment_body": "Take a look at this latest push (the first one was just a rebase to keep the gh compare screen clean), let me know if this is what you had in mind :+1: \r\n\r\nI like this because eventually we can also use a more general `features` property that users can specify, which will make configuration super easy and intuitive",
        "pr_file_module": null
      },
      {
        "comment_id": "2198497987",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/lua/vim/lsp/linked_editing_range.lua",
        "discussion_id": "2196343686",
        "commented_code": "@@ -0,0 +1,361 @@\n+--- @brief\n+--- The `vim.lsp.linked_editing_range` module enables \"linked editing\" via a language server's\n+--- `textDocument/linkedEditingRange` request. Linked editing ranges are synchronized text regions,\n+--- meaning changes in one range are mirrored in all the others. This is helpful in HTML files for\n+--- example, where the language server can update the text of a closing tag if its opening tag was\n+--- changed.\n+---\n+--- LSP spec: https://microsoft.github.io/language-server-protocol/specification/#textDocument_linkedEditingRange\n+\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local lsp = vim.lsp\n+local method = require('vim.lsp.protocol').Methods.textDocument_linkedEditingRange\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+local M = {}\n+\n+---@class (private) vim.lsp.linked_editing_range.state Global state for linked editing ranges\n+---An optional word pattern (regular expression) that describes valid contents for the given ranges.\n+---@field word_pattern string\n+---@field range_index? integer The index of the range that the cursor is on.\n+---@field namespace integer namespace for range extmarks\n+\n+---@class (private) vim.lsp.linked_editing_range.LinkedEditor\n+---@field active table<integer, vim.lsp.linked_editing_range.LinkedEditor>\n+---@field bufnr integer\n+---@field augroup integer augroup for buffer events\n+---@field client_states table<integer, vim.lsp.linked_editing_range.state>\n+local LinkedEditor = { active = {} }\n+\n+---@param client_id integer\n+---@return string\n+local function get_client_augroup(client_id)\n+  return 'nvim.lsp.linked_editing_range.client:' .. client_id\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:attach(client_id)\n+  if self.client_states[client_id] then\n+    return\n+  end\n+  self.client_states[client_id] = {\n+    namespace = api.nvim_create_namespace('nvim.lsp.linked_editing_range:' .. client_id),\n+    word_pattern = '^[%w%-_]*$',\n+  }\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function clear_ranges(bufnr, client_state)\n+  api.nvim_buf_clear_namespace(bufnr, client_state.namespace, 0, -1)\n+  client_state.range_index = nil\n+end\n+\n+---@package\n+---@param client_id integer\n+function LinkedEditor:detach(client_id)\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  --TODO: delete namespace if/when that becomes possible\n+  clear_ranges(self.bufnr, client_state)\n+  self.client_states[client_id] = nil\n+\n+  -- Destroy the LinkedEditor instance if we are detaching the last client\n+  if vim.tbl_isempty(self.client_states) then\n+    api.nvim_del_augroup_by_id(self.augroup)\n+    LinkedEditor.active[self.bufnr] = nil\n+  end\n+end\n+\n+---Syncs the text of each linked editing range after a range has been edited.\n+---\n+---@package\n+---@param bufnr integer\n+---@param client_state vim.lsp.linked_editing_range.state\n+local function update_ranges(bufnr, client_state)\n+  if not client_state.range_index then\n+    return\n+  end\n+\n+  local ns = client_state.namespace\n+  local ranges = api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, { details = true })\n+  if #ranges <= 1 then\n+    return\n+  end\n+\n+  local r = assert(ranges[client_state.range_index])\n+  local replacement = api.nvim_buf_get_text(bufnr, r[2], r[3], r[4].end_row, r[4].end_col, {})\n+\n+  if not string.match(table.concat(replacement, '\\n'), client_state.word_pattern) then\n+    clear_ranges(bufnr, client_state)\n+    return\n+  end\n+\n+  -- Join text update changes into one undo chunk. If we came here from an undo, then return.\n+  local success = pcall(vim.cmd.undojoin)\n+  if not success then\n+    return\n+  end\n+\n+  for i, range in ipairs(ranges) do\n+    if i ~= client_state.range_index then\n+      api.nvim_buf_set_text(\n+        bufnr,\n+        range[2],\n+        range[3],\n+        range[4].end_row,\n+        range[4].end_col,\n+        replacement\n+      )\n+    end\n+  end\n+end\n+\n+---|lsp-handler| for the `textDocument/linkedEditingRange` request. Sets marks for the given ranges\n+---(if present) and tracks which range the cursor is currently inside.\n+---\n+---@package\n+---@param err lsp.ResponseError?\n+---@param result lsp.LinkedEditingRanges?\n+---@param ctx lsp.HandlerContext\n+function LinkedEditor:handler(err, result, ctx)\n+  if err then\n+    log.error('linkededitingrange', err)\n+    return\n+  end\n+\n+  local client_id = ctx.client_id\n+  local client_state = self.client_states[client_id]\n+  if not client_state then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) or util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  clear_ranges(bufnr, client_state)\n+\n+  if not result then\n+    return\n+  end\n+\n+  local client = assert(lsp.get_client_by_id(client_id))\n+\n+  local lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local curpos = api.nvim_win_get_cursor(0)\n+  local cursor_range = { curpos[1] - 1, curpos[2], curpos[1] - 1, curpos[2] }\n+  for i, range in ipairs(result.ranges) do\n+    local start_line = range.start.line\n+    local line = lines and lines[start_line + 1] or ''\n+    local start_col = vim.str_byteindex(line, client.offset_encoding, range.start.character, false)\n+    local end_line = range['end'].line\n+    line = lines and lines[end_line + 1] or ''\n+    local end_col = vim.str_byteindex(line, client.offset_encoding, range['end'].character, false)\n+\n+    api.nvim_buf_set_extmark(bufnr, client_state.namespace, start_line, start_col, {\n+      end_line = end_line,\n+      end_col = end_col,\n+      hl_group = 'LspReferenceTarget',\n+      right_gravity = false,\n+      end_right_gravity = true,\n+    })\n+\n+    local range_tuple = { start_line, start_col, end_line, end_col }\n+    if Range.contains(range_tuple, cursor_range) then\n+      client_state.range_index = i\n+    end\n+  end\n+\n+  -- TODO: Apply the client's own word pattern, if it exists\n+end\n+\n+---Refreshes the linked editing ranges by issuing a new request.\n+---@package\n+function LinkedEditor:refresh()\n+  local bufnr = self.bufnr\n+\n+  util._cancel_requests({\n+    bufnr = bufnr,\n+    method = method,\n+    type = 'pending',\n+  })\n+  lsp.buf_request(bufnr, method, function(client)\n+    return util.make_position_params(0, client.offset_encoding)\n+  end, function(...)\n+    self:handler(...)\n+  end)\n+end\n+\n+---Construct a new LinkedEditor for the buffer.\n+---\n+---@private\n+---@param bufnr integer\n+---@return vim.lsp.linked_editing_range.LinkedEditor\n+function LinkedEditor.new(bufnr)\n+  local self = setmetatable({}, { __index = LinkedEditor })\n+\n+  self.bufnr = bufnr\n+  local augroup =\n+    api.nvim_create_augroup('nvim.lsp.linked_editing_range:' .. bufnr, { clear = true })\n+  self.augroup = augroup\n+  self.client_states = {}\n+\n+  api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    buffer = bufnr,\n+    group = augroup,\n+    callback = function()\n+      for _, client_state in pairs(self.client_states) do\n+        update_ranges(bufnr, client_state)\n+      end\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      self:refresh()\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      self:detach(args.data.client_id)\n+    end,\n+  })\n+\n+  LinkedEditor.active[bufnr] = self\n+  return self\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function attach_linked_editor(bufnr, client)\n+  local client_id = client.id\n+  if not lsp.buf_is_attached(bufnr, client_id) then\n+    vim.notify(\n+      '[LSP] Client with id ' .. client_id .. ' not attached to buffer ' .. bufnr,\n+      vim.log.levels.WARN\n+    )\n+    return\n+  end\n+\n+  if not vim.tbl_get(client.server_capabilities, 'linkedEditingRangeProvider') then\n+    vim.notify('[LSP] Server does not support linked editing ranges', vim.log.levels.WARN)\n+    return\n+  end\n+\n+  local linked_editor = LinkedEditor.active[bufnr] or LinkedEditor.new(bufnr)\n+  linked_editor:attach(client_id)\n+  linked_editor:refresh()\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client\n+local function detach_linked_editor(bufnr, client)\n+  local linked_editor = LinkedEditor.active[bufnr]\n+  if not linked_editor then\n+    return\n+  end\n+\n+  linked_editor:detach(client.id)\n+end\n+\n+---@param enable boolean\n+---@param client vim.lsp.Client\n+local function toggle_linked_editing_for_client(enable, client)\n+  local handler = enable and attach_linked_editor or detach_linked_editor\n+  local client_id = client.id\n+\n+  -- Toggle for buffers already attached.\n+  for bufnr, _ in pairs(client.attached_buffers) do\n+    handler(bufnr, client)\n+  end\n+\n+  -- If disabling, only clear the attachment autocmd. If enabling, create it.\n+  local group = api.nvim_create_augroup(get_client_augroup(client_id), { clear = true })",
        "comment_created_at": "2025-07-10T19:07:13+00:00",
        "comment_author": "justinmk",
        "comment_body": "> I like this because eventually we can also use a more general `features` property\r\n\r\nsame thought popped into my mind... :) related: https://github.com/neovim/neovim/issues/34659",
        "pr_file_module": null
      }
    ]
  }
]