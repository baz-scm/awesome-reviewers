[
  {
    "discussion_id": "1866344132",
    "pr_number": 31364,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2024-12-02T18:02:00+00:00",
    "commented_code": "\u2022 {limit}? (`number`, default: `1`) Stop the search after\n                    finding this many matches. Use `math.huge` to place no\n                    limit on the number of matches.\n+                 \u2022 {skip}? (`fun(dir: string): boolean`) Do not traverse",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1866344132",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "1866344132",
        "commented_code": "@@ -3039,6 +3039,11 @@ vim.fs.find({names}, {opts})                                   *vim.fs.find()*\n                  \u2022 {limit}? (`number`, default: `1`) Stop the search after\n                    finding this many matches. Use `math.huge` to place no\n                    limit on the number of matches.\n+                 \u2022 {skip}? (`fun(dir: string): boolean`) Do not traverse",
        "comment_created_at": "2024-12-02T18:02:00+00:00",
        "comment_author": "justinmk",
        "comment_body": "please search for \"predicate\", \"filter\", \"skip\", and any other related concept, in the :help docs to see which is the most common. I'm wondering if positive logic (\"match\") or negative logic (\"skip\") is more common and more intuitive. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1867679696",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "1866344132",
        "commented_code": "@@ -3039,6 +3039,11 @@ vim.fs.find({names}, {opts})                                   *vim.fs.find()*\n                  \u2022 {limit}? (`number`, default: `1`) Stop the search after\n                    finding this many matches. Use `math.huge` to place no\n                    limit on the number of matches.\n+                 \u2022 {skip}? (`fun(dir: string): boolean`) Do not traverse",
        "comment_created_at": "2024-12-03T12:57:31+00:00",
        "comment_author": "mike325",
        "comment_body": "### Skip\r\n    - vim.fs.dir() - mentions both predicate and skip \r\n    - vim.iter:skip()\r\n    - vim.iter:rskip()\r\n    - search()\r\n    - searchparipos()\r\n    - searchpos()\r\n    - strcharpart()\r\n    - strchars()\r\n\r\n### Filter\r\n    - filter()\r\n    - vim.inspect_pos()\r\n    - vim.show_pos()\r\n    - vim.tbl_filter()\r\n    - vim.iter:filter()\r\n    - vim.snippet.active()\r\n    - vim.lsp.buf.code_action() - mentions both filter and predicate\r\n    - vim.lsp.buf.format() - mentions both filter and predicate\r\n    - vim.lsp.buf.rename() - mentions both filter and predicate\r\n    - `filter` is mentions as prefer way to control `enable` functionality in dev-name-common and dev-api-patterns\r\n\r\n### Match\r\n    - string:match()\r\n    - string:gmatch()\r\n    - vim.lpeg.Pattern:match()\r\n    - vim.filetype.match()\r\n    - nvim_get_autocmds()\r\n    - vim.regex:match_line()\r\n    - vim.regex:match_str()\r\n    - vim.diagnostic.match()\r\n    - match() and match*() family\r\n\r\n### Predicate\r\n    - vim.fs.dir() - mentions both predicate and skip\r\n    - vim.tbl_contains()\r\n    - vim.tbl_filter()\r\n    - vim.iter:all()\r\n    - vim.iter:any()\r\n    - vim.iter:find()\r\n    - vim.iter:rfind()\r\n    - vim.lsp.start() - reuse_client\r\n    - vim.lsp.buf.code_action() - mentions both filter and predicate\r\n    - vim.lsp.buf.format() - mentions both filter and predicate\r\n    - vim.lsp.buf.rename() - mentions both filter and predicate\r\n    - used by TS API\r\n\r\nI might had missed some cases but I think this is a general overview of idioms.\r\n\r\nit looks like `match` is by far the prefer idiom in the code base since it's used in a lot places to filter/narrow down in various scenarios, although is not so commonly used in as filter mechanism for functions/callbacks, `skip` is actually not that commonly used but is what I picked for `vim.fs.find` since I borrowed the concept from `vim.fs.dir`",
        "pr_file_module": null
      },
      {
        "comment_id": "1868326717",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "1866344132",
        "commented_code": "@@ -3039,6 +3039,11 @@ vim.fs.find({names}, {opts})                                   *vim.fs.find()*\n                  \u2022 {limit}? (`number`, default: `1`) Stop the search after\n                    finding this many matches. Use `math.huge` to place no\n                    limit on the number of matches.\n+                 \u2022 {skip}? (`fun(dir: string): boolean`) Do not traverse",
        "comment_created_at": "2024-12-03T20:27:33+00:00",
        "comment_author": "justinmk",
        "comment_body": "> I borrowed the concept from `vim.fs.dir`\r\n\r\nOh, I missed that an existing `vim.fs` function already has this concept. In that case this seems fine.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018567943",
    "pr_number": 31364,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2025-03-28T12:25:40+00:00",
    "commented_code": "limit on the number of matches.\n                  \u2022 {follow}? (`boolean`, default: `false`) Follow symbolic\n                    links.\n+                 \u2022 {filter}? (`fun(dir: string): boolean`) Traverse Matching",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2018567943",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2018567943",
        "commented_code": "@@ -3060,6 +3060,9 @@ vim.fs.find({names}, {opts})                                   *vim.fs.find()*\n                    limit on the number of matches.\n                  \u2022 {follow}? (`boolean`, default: `false`) Follow symbolic\n                    links.\n+                 \u2022 {filter}? (`fun(dir: string): boolean`) Traverse Matching",
        "comment_created_at": "2025-03-28T12:25:40+00:00",
        "comment_author": "justinmk",
        "comment_body": "does returning `false` omit a directory (that matches the `vim.fs.dir` case)?\r\n```suggestion\r\n                 \u2022 {filter}? (`fun(dir: string): boolean`) Predicate that\r\n                   decides if a directory is traversed. Return true to traverse\r\n                   a directory, or false to skip. ...                   \r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018568625",
    "pr_number": 31364,
    "pr_file": "runtime/doc/news.txt",
    "created_at": "2025-03-28T12:26:10+00:00",
    "commented_code": "\u2022 |vim.fs.relpath()| gets relative path compared to base path.\n \u2022 |vim.fs.dir()| and |vim.fs.find()| can now follow symbolic links,\n   the behavior can be turn on using the new `follow` option.\n+\u2022 |vim.fs.find()| has an option to filter the directory traversal.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2018568625",
        "repo_full_name": "neovim/neovim",
        "pr_number": 31364,
        "pr_file": "runtime/doc/news.txt",
        "discussion_id": "2018568625",
        "commented_code": "@@ -338,6 +338,7 @@ LUA\n \u2022 |vim.fs.relpath()| gets relative path compared to base path.\n \u2022 |vim.fs.dir()| and |vim.fs.find()| can now follow symbolic links,\n   the behavior can be turn on using the new `follow` option.\n+\u2022 |vim.fs.find()| has an option to filter the directory traversal.",
        "comment_created_at": "2025-03-28T12:26:10+00:00",
        "comment_author": "justinmk",
        "comment_body": "```suggestion\r\n\u2022 |vim.fs.find()| accepts a `filter` predicate.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]