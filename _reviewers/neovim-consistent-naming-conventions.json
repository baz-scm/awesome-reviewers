[
  {
    "discussion_id": "2230117483",
    "pr_number": 34014,
    "pr_file": "runtime/lua/vim/diagnostic.lua",
    "created_at": "2025-07-25T04:36:04+00:00",
    "commented_code": "local floating_highlight_map = make_highlight_map('Floating')\n local sign_highlight_map = make_highlight_map('Sign')\n \n+--- @param diagnostic vim.Diagnostic\n+--- @return integer lnum\n+--- @return integer col\n+--- @return integer end_lnum\n+--- @return integer end_col\n+local function get_logical_location(diagnostic)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2230117483",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2230117483",
        "commented_code": "@@ -642,6 +643,23 @@ local underline_highlight_map = make_highlight_map('Underline')\n local floating_highlight_map = make_highlight_map('Floating')\n local sign_highlight_map = make_highlight_map('Sign')\n \n+--- @param diagnostic vim.Diagnostic\n+--- @return integer lnum\n+--- @return integer col\n+--- @return integer end_lnum\n+--- @return integer end_col\n+local function get_logical_location(diagnostic)",
        "comment_created_at": "2025-07-25T04:36:04+00:00",
        "comment_author": "justinmk",
        "comment_body": "Let's stick to \"pos\" as the nonce for position/location. Jargon creep adds friction.\n\n```suggestion\nlocal function get_logical_pos(diagnostic)\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2230132576",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2230117483",
        "commented_code": "@@ -642,6 +643,23 @@ local underline_highlight_map = make_highlight_map('Underline')\n local floating_highlight_map = make_highlight_map('Floating')\n local sign_highlight_map = make_highlight_map('Sign')\n \n+--- @param diagnostic vim.Diagnostic\n+--- @return integer lnum\n+--- @return integer col\n+--- @return integer end_lnum\n+--- @return integer end_col\n+local function get_logical_location(diagnostic)",
        "comment_created_at": "2025-07-25T04:51:49+00:00",
        "comment_author": "faergeek",
        "comment_body": "I don't see any problem with changing the name, just wanted to note that I took \"logical location\" from first paragraph of extmarks docs https://github.com/neovim/neovim/blob/e512efe3696b2ed18db55683fecf42bbc733c767/runtime/doc/api.txt#L476-L481",
        "pr_file_module": null
      },
      {
        "comment_id": "2230143050",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "runtime/lua/vim/diagnostic.lua",
        "discussion_id": "2230117483",
        "commented_code": "@@ -642,6 +643,23 @@ local underline_highlight_map = make_highlight_map('Underline')\n local floating_highlight_map = make_highlight_map('Floating')\n local sign_highlight_map = make_highlight_map('Sign')\n \n+--- @param diagnostic vim.Diagnostic\n+--- @return integer lnum\n+--- @return integer col\n+--- @return integer end_lnum\n+--- @return integer end_col\n+local function get_logical_location(diagnostic)",
        "comment_created_at": "2025-07-25T05:01:27+00:00",
        "comment_author": "justinmk",
        "comment_body": "In a description many different terms may be used to orient the reader. But in interface names, same concept should always have same name.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188414598",
    "pr_number": 34710,
    "pr_file": "runtime/pack/dist/opt/cfilter/plugin/cfilter.lua",
    "created_at": "2025-07-06T15:43:24+00:00",
    "commented_code": "+---@param bufnr integer\n+---@param lnum integer\n+---@return string?\n+local function get_line(bufnr, lnum)\n+  local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, false)[1]\n+  if not line then\n+    return nil\n+  end\n+  return line\n+end\n+\n+---@param searchpat string\n+---@return string\n+local function get_search_pat(searchpat)\n+  local firstchar = searchpat:sub(1, 1)\n+  local lastchar = searchpat:sub(-1)\n+  local pat = searchpat\n+  if firstchar == lastchar and (firstchar == '/' or firstchar == '\"' or firstchar == \"'\") then\n+    pat = searchpat:sub(2, -2)\n+    if pat == '' then\n+      -- Use the last search pattern\n+      pat = vim.fn.getreg('/')\n+    end\n+  end\n+  return pat\n+end\n+\n+---@param items table[]\n+---@param regex vim.regex\n+---@param bang boolean\n+---@param opts? { max_matches: integer }\n+---@return table[]\n+local function get_matched_items(items, regex, bang, opts)\n+  if not opts then opts = {} end\n+  local bufname = vim.api.nvim_buf_get_name\n+  local cond ---@type fun(val: table): boolean\n+  local results = {}\n+  if bang then\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return not (text_match or bufname_match)\n+    end\n+  else\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return text_match or bufname_match\n+    end\n+  end\n+\n+  local results_num = 0\n+  for i, item in ipairs(items) do\n+    if cond(item) then\n+      item.nvim_cfilter = {\n+        lnum = i - 1,\n+      }\n+      table.insert(results, item)\n+      if opts.max_matches then\n+        results_num = results_num + 1\n+        if results_num > opts.max_matches then\n+          break\n+        end\n+      end\n+    end\n+  end\n+  return results\n+end\n+\n+---@param is_qf boolean\n+---@param pat string\n+---@param bang boolean\n+local function cmd_cb(is_qf, pat, bang)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2188414598",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34710,
        "pr_file": "runtime/pack/dist/opt/cfilter/plugin/cfilter.lua",
        "discussion_id": "2188414598",
        "commented_code": "@@ -0,0 +1,170 @@\n+---@param bufnr integer\n+---@param lnum integer\n+---@return string?\n+local function get_line(bufnr, lnum)\n+  local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, false)[1]\n+  if not line then\n+    return nil\n+  end\n+  return line\n+end\n+\n+---@param searchpat string\n+---@return string\n+local function get_search_pat(searchpat)\n+  local firstchar = searchpat:sub(1, 1)\n+  local lastchar = searchpat:sub(-1)\n+  local pat = searchpat\n+  if firstchar == lastchar and (firstchar == '/' or firstchar == '\"' or firstchar == \"'\") then\n+    pat = searchpat:sub(2, -2)\n+    if pat == '' then\n+      -- Use the last search pattern\n+      pat = vim.fn.getreg('/')\n+    end\n+  end\n+  return pat\n+end\n+\n+---@param items table[]\n+---@param regex vim.regex\n+---@param bang boolean\n+---@param opts? { max_matches: integer }\n+---@return table[]\n+local function get_matched_items(items, regex, bang, opts)\n+  if not opts then opts = {} end\n+  local bufname = vim.api.nvim_buf_get_name\n+  local cond ---@type fun(val: table): boolean\n+  local results = {}\n+  if bang then\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return not (text_match or bufname_match)\n+    end\n+  else\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return text_match or bufname_match\n+    end\n+  end\n+\n+  local results_num = 0\n+  for i, item in ipairs(items) do\n+    if cond(item) then\n+      item.nvim_cfilter = {\n+        lnum = i - 1,\n+      }\n+      table.insert(results, item)\n+      if opts.max_matches then\n+        results_num = results_num + 1\n+        if results_num > opts.max_matches then\n+          break\n+        end\n+      end\n+    end\n+  end\n+  return results\n+end\n+\n+---@param is_qf boolean\n+---@param pat string\n+---@param bang boolean\n+local function cmd_cb(is_qf, pat, bang)",
        "comment_created_at": "2025-07-06T15:43:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "avoid the `_cb` suffix, use an `on_` suffix. `:help dev-naming`",
        "pr_file_module": null
      },
      {
        "comment_id": "2188451916",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34710,
        "pr_file": "runtime/pack/dist/opt/cfilter/plugin/cfilter.lua",
        "discussion_id": "2188414598",
        "commented_code": "@@ -0,0 +1,170 @@\n+---@param bufnr integer\n+---@param lnum integer\n+---@return string?\n+local function get_line(bufnr, lnum)\n+  local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, false)[1]\n+  if not line then\n+    return nil\n+  end\n+  return line\n+end\n+\n+---@param searchpat string\n+---@return string\n+local function get_search_pat(searchpat)\n+  local firstchar = searchpat:sub(1, 1)\n+  local lastchar = searchpat:sub(-1)\n+  local pat = searchpat\n+  if firstchar == lastchar and (firstchar == '/' or firstchar == '\"' or firstchar == \"'\") then\n+    pat = searchpat:sub(2, -2)\n+    if pat == '' then\n+      -- Use the last search pattern\n+      pat = vim.fn.getreg('/')\n+    end\n+  end\n+  return pat\n+end\n+\n+---@param items table[]\n+---@param regex vim.regex\n+---@param bang boolean\n+---@param opts? { max_matches: integer }\n+---@return table[]\n+local function get_matched_items(items, regex, bang, opts)\n+  if not opts then opts = {} end\n+  local bufname = vim.api.nvim_buf_get_name\n+  local cond ---@type fun(val: table): boolean\n+  local results = {}\n+  if bang then\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return not (text_match or bufname_match)\n+    end\n+  else\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return text_match or bufname_match\n+    end\n+  end\n+\n+  local results_num = 0\n+  for i, item in ipairs(items) do\n+    if cond(item) then\n+      item.nvim_cfilter = {\n+        lnum = i - 1,\n+      }\n+      table.insert(results, item)\n+      if opts.max_matches then\n+        results_num = results_num + 1\n+        if results_num > opts.max_matches then\n+          break\n+        end\n+      end\n+    end\n+  end\n+  return results\n+end\n+\n+---@param is_qf boolean\n+---@param pat string\n+---@param bang boolean\n+local function cmd_cb(is_qf, pat, bang)",
        "comment_created_at": "2025-07-06T16:22:38+00:00",
        "comment_author": "brianhuster",
        "comment_body": "I know it, but I don't know what should follows `on_`. `on_cmd` just sounds strange to me",
        "pr_file_module": null
      },
      {
        "comment_id": "2188502716",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34710,
        "pr_file": "runtime/pack/dist/opt/cfilter/plugin/cfilter.lua",
        "discussion_id": "2188414598",
        "commented_code": "@@ -0,0 +1,170 @@\n+---@param bufnr integer\n+---@param lnum integer\n+---@return string?\n+local function get_line(bufnr, lnum)\n+  local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, false)[1]\n+  if not line then\n+    return nil\n+  end\n+  return line\n+end\n+\n+---@param searchpat string\n+---@return string\n+local function get_search_pat(searchpat)\n+  local firstchar = searchpat:sub(1, 1)\n+  local lastchar = searchpat:sub(-1)\n+  local pat = searchpat\n+  if firstchar == lastchar and (firstchar == '/' or firstchar == '\"' or firstchar == \"'\") then\n+    pat = searchpat:sub(2, -2)\n+    if pat == '' then\n+      -- Use the last search pattern\n+      pat = vim.fn.getreg('/')\n+    end\n+  end\n+  return pat\n+end\n+\n+---@param items table[]\n+---@param regex vim.regex\n+---@param bang boolean\n+---@param opts? { max_matches: integer }\n+---@return table[]\n+local function get_matched_items(items, regex, bang, opts)\n+  if not opts then opts = {} end\n+  local bufname = vim.api.nvim_buf_get_name\n+  local cond ---@type fun(val: table): boolean\n+  local results = {}\n+  if bang then\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return not (text_match or bufname_match)\n+    end\n+  else\n+    ---@param val table\n+    ---@return boolean\n+    cond = function(val)\n+      local text_match = regex:match_str(val.text) ~= nil\n+      local bufname_match = regex:match_str(bufname(val.bufnr)) ~= nil\n+      return text_match or bufname_match\n+    end\n+  end\n+\n+  local results_num = 0\n+  for i, item in ipairs(items) do\n+    if cond(item) then\n+      item.nvim_cfilter = {\n+        lnum = i - 1,\n+      }\n+      table.insert(results, item)\n+      if opts.max_matches then\n+        results_num = results_num + 1\n+        if results_num > opts.max_matches then\n+          break\n+        end\n+      end\n+    end\n+  end\n+  return results\n+end\n+\n+---@param is_qf boolean\n+---@param pat string\n+---@param bang boolean\n+local function cmd_cb(is_qf, pat, bang)",
        "comment_created_at": "2025-07-06T18:02:32+00:00",
        "comment_author": "justinmk",
        "comment_body": "`on_cmd` is fine",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154489282",
    "pr_number": 34469,
    "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
    "created_at": "2025-06-18T12:35:55+00:00",
    "commented_code": "---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-\n----@type table<integer, vim.lsp.folding_range.BufState?>\n-local bufstates = {}\n+local FRProvider = { active = {} }",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2154489282",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34469,
        "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
        "discussion_id": "2154489282",
        "commented_code": "@@ -23,23 +26,18 @@ local M = {}\n ---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-\n----@type table<integer, vim.lsp.folding_range.BufState?>\n-local bufstates = {}\n+local FRProvider = { active = {} }",
        "comment_created_at": "2025-06-18T12:35:55+00:00",
        "comment_author": "justinmk",
        "comment_body": "The name FRProvider seems questionable. Why not name it `FoldRange` or `FoldState`? If it's just an object that does stuff, that's the typical pattern.\r\n\r\n\"Provider\" implies that there will be different backend implementations of a concept, typically platform-specific in some way. If we're only talking about polymorphism or a \"base class\", it's helpful to just name the base-class by its main purpose.",
        "pr_file_module": null
      },
      {
        "comment_id": "2156357928",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34469,
        "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
        "discussion_id": "2154489282",
        "commented_code": "@@ -23,23 +26,18 @@ local M = {}\n ---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-\n----@type table<integer, vim.lsp.folding_range.BufState?>\n-local bufstates = {}\n+local FRProvider = { active = {} }",
        "comment_created_at": "2025-06-19T07:40:46+00:00",
        "comment_author": "ofseed",
        "comment_body": "I spent quite a bit of time thinking about this name, haha. The suffix `Provider` is just to highlight that it have a common base class and contains methods.\r\n\r\nThe reason why simply calling it `FoldingRange` doesn't seem appropriate is that there is already an `lsp.FoldingRange` in the protocol type definition, which could confuse. So I thought of naming it `vim.lsp.folding_range.State` instead.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2156933791",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34469,
        "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
        "discussion_id": "2154489282",
        "commented_code": "@@ -23,23 +26,18 @@ local M = {}\n ---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-\n----@type table<integer, vim.lsp.folding_range.BufState?>\n-local bufstates = {}\n+local FRProvider = { active = {} }",
        "comment_created_at": "2025-06-19T12:42:27+00:00",
        "comment_author": "justinmk",
        "comment_body": "> The suffix `Provider` is just to highlight that it have a common base class and contains methods.\r\n\r\nOk then \"Provider\" isn't the right name, for the reason mentioned in my above comment.\r\n\r\n`vim.lsp.folding_range.State` seems fine, but the name of the instance should probably be `foldState` or `foldRangeState`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188857902",
    "pr_number": 34639,
    "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
    "created_at": "2025-07-07T02:42:40+00:00",
    "commented_code": "---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-local State = { active = {} }\n+local FoldEvaluator = { name = 'Folding Range', active = {} }\n+FoldEvaluator.__index = FoldEvaluator\n+setmetatable(FoldEvaluator, Capability)\n \n---- Renew the cached foldinfo in the buffer.\n-function State:renew()\n+--- Re-evaluate the cached foldinfo in the buffer.\n+function FoldEvaluator:evaluate()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2188857902",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34639,
        "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
        "discussion_id": "2188857902",
        "commented_code": "@@ -33,18 +35,20 @@ local M = {}\n ---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-local State = { active = {} }\n+local FoldEvaluator = { name = 'Folding Range', active = {} }\n+FoldEvaluator.__index = FoldEvaluator\n+setmetatable(FoldEvaluator, Capability)\n \n---- Renew the cached foldinfo in the buffer.\n-function State:renew()\n+--- Re-evaluate the cached foldinfo in the buffer.\n+function FoldEvaluator:evaluate()",
        "comment_created_at": "2025-07-07T02:42:40+00:00",
        "comment_author": "justinmk",
        "comment_body": "would refresh() make sense here? that's a common name in other modules.",
        "pr_file_module": null
      },
      {
        "comment_id": "2188862255",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34639,
        "pr_file": "runtime/lua/vim/lsp/_folding_range.lua",
        "discussion_id": "2188857902",
        "commented_code": "@@ -33,18 +35,20 @@ local M = {}\n ---\n --- Index in the form of start_row -> collapsed_text\n ---@field row_text table<integer, string?>\n-local State = { active = {} }\n+local FoldEvaluator = { name = 'Folding Range', active = {} }\n+FoldEvaluator.__index = FoldEvaluator\n+setmetatable(FoldEvaluator, Capability)\n \n---- Renew the cached foldinfo in the buffer.\n-function State:renew()\n+--- Re-evaluate the cached foldinfo in the buffer.\n+function FoldEvaluator:evaluate()",
        "comment_created_at": "2025-07-07T02:47:26+00:00",
        "comment_author": "ofseed",
        "comment_body": "I noticed the generality of `refresh`, but in other modules, it is usually used to mean \"sending a new LSP request,\" which is somewhat different from the situation of `renew()` here. We could rename the `request()` below to `refresh()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203477869",
    "pr_number": 34919,
    "pr_file": "runtime/lua/vim/pack.lua",
    "created_at": "2025-07-13T17:49:24+00:00",
    "commented_code": "vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n end\n \n+--- Get map of plugin names that need update: all plugin sections present in\n+--- confirmation buffer under \"# Update\" section.\n+--- @param bufnr integer\n+--- @return table<string,boolean>\n+local function get_confirmed_update_plugins(bufnr)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203477869",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34919,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2203477869",
        "commented_code": "@@ -822,6 +822,31 @@ local function show_confirm_buf(lines, on_finish)\n   vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n end\n \n+--- Get map of plugin names that need update: all plugin sections present in\n+--- confirmation buffer under \"# Update\" section.\n+--- @param bufnr integer\n+--- @return table<string,boolean>\n+local function get_confirmed_update_plugins(bufnr)",
        "comment_created_at": "2025-07-13T17:49:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "the doc seems to imply this name:\n\n\n```suggestion\nlocal function get_confirm_update_plugins(bufnr)\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2203483665",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34919,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2203477869",
        "commented_code": "@@ -822,6 +822,31 @@ local function show_confirm_buf(lines, on_finish)\n   vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n end\n \n+--- Get map of plugin names that need update: all plugin sections present in\n+--- confirmation buffer under \"# Update\" section.\n+--- @param bufnr integer\n+--- @return table<string,boolean>\n+local function get_confirmed_update_plugins(bufnr)",
        "comment_created_at": "2025-07-13T18:14:05+00:00",
        "comment_author": "echasnovski",
        "comment_body": "It's just that using (what looks like) three verbs in a row throws me off.\r\nProbably something like `get_update_map()` is better here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989236183",
    "pr_number": 32619,
    "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
    "created_at": "2025-03-11T13:08:03+00:00",
    "commented_code": "conceal = conceal,\n             spell = spell,\n             url = url,\n-          })\n+          }\n+          local mark = { begin_line = start_row, begin_col = start_col, opts = opts }",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1989236183",
        "repo_full_name": "neovim/neovim",
        "pr_number": 32619,
        "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
        "discussion_id": "1989236183",
        "commented_code": "@@ -370,7 +407,9 @@ local function on_line_impl(self, buf, line, on_spell, on_conceal)\n             conceal = conceal,\n             spell = spell,\n             url = url,\n-          })\n+          }\n+          local mark = { begin_line = start_row, begin_col = start_col, opts = opts }",
        "comment_created_at": "2025-03-11T13:08:03+00:00",
        "comment_author": "justinmk",
        "comment_body": "start/end are the normal convention in the codebase\r\n\r\n```suggestion\r\n          local mark = { start_line = start_row, start_col = start_col, opts = opts }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "317412132",
    "pr_number": 10842,
    "pr_file": "src/nvim/globals.h",
    "created_at": "2019-08-25T19:46:10+00:00",
    "commented_code": "EXTERN int km_stopsel INIT(= FALSE);\n EXTERN int km_startsel INIT(= FALSE);\n \n+typedef enum {\n+  kModalNone = 0,  ///< no modal window active\n+  kModalCmdwin,    ///< cmdline window\n+  kModalTerminal,  ///< modal terminal (:!)\n+  KModalUser       ///< window for modal()\n+} ModalType;\n+\n EXTERN int cedit_key INIT(= -1);     ///< key value of 'cedit' option\n-EXTERN int cmdwin_type INIT(= 0);    ///< type of cmdline window or 0\n-EXTERN int cmdwin_result INIT(= 0);  ///< result of cmdline window or 0\n+\n+//EXTERN bool modal_active INIT(= 0); ///< modal window is active\n+#define modal_active() (modal_type != kModalNone)\n+#define cmdwin_active() (modal_type == kModalCmdwin)\n+EXTERN ModalType modal_type INIT(= 0);  ///< type of modal window.\n+EXTERN int modal_result INIT(= 0);  ///< result of modal window or 0",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "317412132",
        "repo_full_name": "neovim/neovim",
        "pr_number": 10842,
        "pr_file": "src/nvim/globals.h",
        "discussion_id": "317412132",
        "commented_code": "@@ -844,9 +844,22 @@ EXTERN char_u   *globaldir INIT(= NULL);\n EXTERN int km_stopsel INIT(= FALSE);\n EXTERN int km_startsel INIT(= FALSE);\n \n+typedef enum {\n+  kModalNone = 0,  ///< no modal window active\n+  kModalCmdwin,    ///< cmdline window\n+  kModalTerminal,  ///< modal terminal (:!)\n+  KModalUser       ///< window for modal()\n+} ModalType;\n+\n EXTERN int cedit_key INIT(= -1);     ///< key value of 'cedit' option\n-EXTERN int cmdwin_type INIT(= 0);    ///< type of cmdline window or 0\n-EXTERN int cmdwin_result INIT(= 0);  ///< result of cmdline window or 0\n+\n+//EXTERN bool modal_active INIT(= 0); ///< modal window is active\n+#define modal_active() (modal_type != kModalNone)\n+#define cmdwin_active() (modal_type == kModalCmdwin)\n+EXTERN ModalType modal_type INIT(= 0);  ///< type of modal window.\n+EXTERN int modal_result INIT(= 0);  ///< result of modal window or 0",
        "comment_created_at": "2019-08-25T19:46:10+00:00",
        "comment_author": "justinmk",
        "comment_body": "since \"mode\" is pretty similar to \"modal\", maybe mention \"win\" in these new names. My reflex would be a prefix (`win_modal_active`, `win_cmdwin_active`, `win_modal_result`, `WinModalType`, ...) but I guess the prevalence of `cmdwin_xx` would justify `modalwin_xx` (this also complements `floatwin_xx`).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177273298",
    "pr_number": 34720,
    "pr_file": "runtime/lua/vim/lsp/handlers.lua",
    "created_at": "2025-07-01T11:04:32+00:00",
    "commented_code": "api.nvim_command('redraw')\n end\n \n+--- @param params lsp.ShowMessageParams|lsp.ShowMessageRequestParams\n+--- @param ctx lsp.HandlerContext\n+local function show_message_notification(params, ctx)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2177273298",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34720,
        "pr_file": "runtime/lua/vim/lsp/handlers.lua",
        "discussion_id": "2177273298",
        "commented_code": "@@ -28,6 +28,22 @@ local function err_message(...)\n   api.nvim_command('redraw')\n end\n \n+--- @param params lsp.ShowMessageParams|lsp.ShowMessageRequestParams\n+--- @param ctx lsp.HandlerContext\n+local function show_message_notification(params, ctx)",
        "comment_created_at": "2025-07-01T11:04:32+00:00",
        "comment_author": "justinmk",
        "comment_body": "handlers should be prefixed with `on_`. or if we think of this function as \"procedural\" we can just call it `show_message()` ?\r\n\r\n\r\n\r\n```suggestion\r\nlocal function on_show_message(params, ctx)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2178071107",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34720,
        "pr_file": "runtime/lua/vim/lsp/handlers.lua",
        "discussion_id": "2177273298",
        "commented_code": "@@ -28,6 +28,22 @@ local function err_message(...)\n   api.nvim_command('redraw')\n end\n \n+--- @param params lsp.ShowMessageParams|lsp.ShowMessageRequestParams\n+--- @param ctx lsp.HandlerContext\n+local function show_message_notification(params, ctx)",
        "comment_created_at": "2025-07-01T16:44:21+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Yeah I wouldn't consider this a proper handler, it's just the shared utility between the \"showMessage\" notification/request to invoke `vim.notify`. I'll stick with the current name though as `vim.ui.select` is another way to show the message, the `_notification` bit is just to clarify that it invokes `vim.notify`.",
        "pr_file_module": null
      }
    ]
  }
]