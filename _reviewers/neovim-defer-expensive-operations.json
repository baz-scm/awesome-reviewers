[
  {
    "discussion_id": "1617921509",
    "pr_number": 29073,
    "pr_file": "runtime/doc/lua-plugin.txt",
    "created_at": "2024-05-28T21:40:17+00:00",
    "commented_code": "+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1617921509",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1617921509",
        "commented_code": "@@ -0,0 +1,441 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.",
        "comment_created_at": "2024-05-28T21:40:17+00:00",
        "comment_author": "dundargoc",
        "comment_body": "```suggestion\r\nwhich will eagerly load the `foo` module and any other modules it imports\r\neagerly, you can lazy load it by moving the `require` into the command's\r\nimplementation.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162079583",
    "pr_number": 27963,
    "pr_file": "runtime/doc/news.txt",
    "created_at": "2025-06-23T17:05:55+00:00",
    "commented_code": "EVENTS\n \n-\u2022 todo\n+\u2022 |ui-messages| no longer emits the `msg_show.return_prompt`, `msg_clear` and\n+  `msg_history_clear` events.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2162079583",
        "repo_full_name": "neovim/neovim",
        "pr_number": 27963,
        "pr_file": "runtime/doc/news.txt",
        "discussion_id": "2162079583",
        "commented_code": "@@ -67,7 +67,8 @@ EDITOR\n \n EVENTS\n \n-\u2022 todo\n+\u2022 |ui-messages| no longer emits the `msg_show.return_prompt`, `msg_clear` and\n+  `msg_history_clear` events.",
        "comment_created_at": "2025-06-23T17:05:55+00:00",
        "comment_author": "justinmk",
        "comment_body": "```suggestion\r\n  `msg_history_clear` events. Performance benefit: reduces UI events traffic.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]