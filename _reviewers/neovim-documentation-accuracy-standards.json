[
  {
    "discussion_id": "2234546923",
    "pr_number": 34586,
    "pr_file": "src/nvim/api/ui.c",
    "created_at": "2025-07-28T03:17:57+00:00",
    "commented_code": "return true;\n }\n \n+// Returns true if the 'connect' event was successfully sent to the UI\n+void remote_ui_connect(uint64_t channel_id, char *server_address, Error *err)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234546923",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/api/ui.c",
        "discussion_id": "2234546923",
        "commented_code": "@@ -305,6 +305,20 @@ bool remote_ui_restart(uint64_t channel_id, Error *err)\n   return true;\n }\n \n+// Returns true if the 'connect' event was successfully sent to the UI\n+void remote_ui_connect(uint64_t channel_id, char *server_address, Error *err)",
        "comment_created_at": "2025-07-28T03:17:57+00:00",
        "comment_author": "justinmk",
        "comment_body": "the docstring looks wrong, it doesn't return anything",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "178466204",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-01T18:52:00+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kScrollLock = 0x80,\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+\n+/// A helper function to be used to load the libX11\n+static bool os_xlib_open(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// A helper function to be used to get the pointer of the function to be used\n+static bool os_xlib_dlsym(const char *const name, void **const ptr,\n+                       const char **const err)\n+{\n+  const int uds_ret = uv_dlsym(&xlib, name, ptr);\n+  if (uds_ret != 0) {\n+    *err = \"Failed to retrieve the function from X11 library\";\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// Get the status of the Capslock, Numlock and Scrolllock in linux\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_open(err)) {\n+    return false;\n+  }\n+  _XDisplay *(*_XOpenDisplay)(void *);\n+  int (*_XCloseDisplay)(_XDisplay *);\n+  _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get the status of the Capslock, Numlock and Scrolllock in windows\n+bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods = *mods | kScrollLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get the status of the Capslock, Numlock and Scrolllock in MacOS\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums, stateScroll;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// A helper function to be used by `nvim_get_keyboard_mods_state` API function\n+/// giving the information about the Capslock, Numlock and Scrollock state.\n+///\n+/// @param dict[out]  The dictionary holding the information of the\n+///                   different mods\n+///\n+/// @param err[out]   The error if encountered, otherwise will be NULL\n+///\n+/// @return           `true` if no error occurs\n+///                   otherwise `false`",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "178466204",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "178466204",
        "commented_code": "@@ -0,0 +1,222 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kScrollLock = 0x80,\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+\n+/// A helper function to be used to load the libX11\n+static bool os_xlib_open(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// A helper function to be used to get the pointer of the function to be used\n+static bool os_xlib_dlsym(const char *const name, void **const ptr,\n+                       const char **const err)\n+{\n+  const int uds_ret = uv_dlsym(&xlib, name, ptr);\n+  if (uds_ret != 0) {\n+    *err = \"Failed to retrieve the function from X11 library\";\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// Get the status of the Capslock, Numlock and Scrolllock in linux\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_open(err)) {\n+    return false;\n+  }\n+  _XDisplay *(*_XOpenDisplay)(void *);\n+  int (*_XCloseDisplay)(_XDisplay *);\n+  _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get the status of the Capslock, Numlock and Scrolllock in windows\n+bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods = *mods | kScrollLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get the status of the Capslock, Numlock and Scrolllock in MacOS\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums, stateScroll;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// A helper function to be used by `nvim_get_keyboard_mods_state` API function\n+/// giving the information about the Capslock, Numlock and Scrollock state.\n+///\n+/// @param dict[out]  The dictionary holding the information of the\n+///                   different mods\n+///\n+/// @param err[out]   The error if encountered, otherwise will be NULL\n+///\n+/// @return           `true` if no error occurs\n+///                   otherwise `false`",
        "comment_created_at": "2018-04-01T18:52:00+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "This is not correct, should use one space after `@return` and `@param[...]{two spaces}name{two spaces}{description, aligned to just after latest two spaces}`. No newlines between argument descriptions, function referenced like `func()` (*without* backticks, but *with* parenthesis) and proper sentences in anything, but (oneline!) summary. That is something like\r\n\r\n```C\r\n/// Get information about Num/Caps/Scroll Lock state in linux\r\n///\r\n/// To be used in nvim_get_keyboard_mods_state() API function.\r\n///\r\n/// @param[out]  dict  Pointer to dictionary where information about modifiers\r\n///                    is to be dumped.\r\n/// @param[out]  err  Location where error message is to be saved, set to NULL\r\n///                   if no error.\r\n///\r\n/// @return true in case of error, false otherwise.\r\nbool os_mods_status(Dictionary *const dict, const char **const err)\r\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\r\n```\r\n\r\n(I should say though this is not the only style used currently, only what I use. But none of the styles you may find matches what you used here.)",
        "pr_file_module": null
      },
      {
        "comment_id": "178559370",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "178466204",
        "commented_code": "@@ -0,0 +1,222 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kScrollLock = 0x80,\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+\n+/// A helper function to be used to load the libX11\n+static bool os_xlib_open(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// A helper function to be used to get the pointer of the function to be used\n+static bool os_xlib_dlsym(const char *const name, void **const ptr,\n+                       const char **const err)\n+{\n+  const int uds_ret = uv_dlsym(&xlib, name, ptr);\n+  if (uds_ret != 0) {\n+    *err = \"Failed to retrieve the function from X11 library\";\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// Get the status of the Capslock, Numlock and Scrolllock in linux\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_open(err)) {\n+    return false;\n+  }\n+  _XDisplay *(*_XOpenDisplay)(void *);\n+  int (*_XCloseDisplay)(_XDisplay *);\n+  _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get the status of the Capslock, Numlock and Scrolllock in windows\n+bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods = *mods | kScrollLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get the status of the Capslock, Numlock and Scrolllock in MacOS\n+static bool os_get_locks_status(char *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums, stateScroll;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// A helper function to be used by `nvim_get_keyboard_mods_state` API function\n+/// giving the information about the Capslock, Numlock and Scrollock state.\n+///\n+/// @param dict[out]  The dictionary holding the information of the\n+///                   different mods\n+///\n+/// @param err[out]   The error if encountered, otherwise will be NULL\n+///\n+/// @return           `true` if no error occurs\n+///                   otherwise `false`",
        "comment_created_at": "2018-04-02T14:50:09+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "OK",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179298489",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-04T22:10:57+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+///\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    xNumLock = 0x10,  ///< Mask for NumLock\n+    xCapsLock = 0x02,  ///< Mask for CapsLock\n+    xScrollLock = 0x80,  ///< Mask for ScrollLock\n+} xlib_KbdLocks;\n+\n+#endif\n+\n+#ifdef WIN32\n+\n+#include <Winuser.h>\n+\n+#endif\n+\n+#ifdef __APPLE__\n+\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+\n+#endif\n+\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+typedef int32_t mod_mask_t;\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E6000: Unable to open %s function from X11\n\"\n+                  \"uv_dlsym Failed: %s\", uv_dlerror(&xlib));\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5999: Unable to load libX11.so library\n\"\n+                  \"uv_dlopen Failed: %s\", uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5666: Unable to open the display\n\"\n+                  \"XOpenDisplay Failed\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5888: Unable to get keyboard state of the display\n\"\n+                  \"XkbGetState Failed: %d\", status);\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & xNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & xCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & xScrollLock) {\n+    *mods |= xScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);\n+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                                       (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5777: Unable to initiate the service.\n\"\n+                  \"IOServiceGetMatchingService() Failed\");\n+    return -1;\n+  }\n+\n+  io_connect_t ioc;\n+  kern_return_t kr;\n+  if ((kr = IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                          &ioc)) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5777: Unable to initiate the service.\n\"\n+                  \"IOServiceOpen() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+  IOObjectRelease(ios);\n+\n+  bool stateCaps;\n+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                      &stateCaps)) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5778: Unable to query CapsLock state.\n\"\n+                  \"IOHIDGetModifierLockState() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+\n+  bool stateNums;\n+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,\n+                                      &stateNums)) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5779: Unable to query NumLock state:\n\"\n+                  \"IOHIDGetModifierLockState() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+  if (stateCaps) {\n+    *mods |= kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods |= kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return kCapsLock | kNumLock;\n+}\n+#else\n+/// Dummy function used in case of no known platform detected.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return 0 for all the cases.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  return 0;\n+}\n+#endif\n+\n+/// Get information about Num/Caps/Scroll Lock state.\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location and description where error message is to",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179298489",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179298489",
        "commented_code": "@@ -0,0 +1,295 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+///\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    xNumLock = 0x10,  ///< Mask for NumLock\n+    xCapsLock = 0x02,  ///< Mask for CapsLock\n+    xScrollLock = 0x80,  ///< Mask for ScrollLock\n+} xlib_KbdLocks;\n+\n+#endif\n+\n+#ifdef WIN32\n+\n+#include <Winuser.h>\n+\n+#endif\n+\n+#ifdef __APPLE__\n+\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+\n+#endif\n+\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+typedef int32_t mod_mask_t;\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E6000: Unable to open %s function from X11\\n\"\n+                  \"uv_dlsym Failed: %s\", uv_dlerror(&xlib));\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5999: Unable to load libX11.so library\\n\"\n+                  \"uv_dlopen Failed: %s\", uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5666: Unable to open the display\\n\"\n+                  \"XOpenDisplay Failed\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5888: Unable to get keyboard state of the display\\n\"\n+                  \"XkbGetState Failed: %d\", status);\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & xNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & xCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & xScrollLock) {\n+    *mods |= xScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return -1 in case of error otherwise an integer specified for given OS.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);\n+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                                       (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5777: Unable to initiate the service.\\n\"\n+                  \"IOServiceGetMatchingService() Failed\");\n+    return -1;\n+  }\n+\n+  io_connect_t ioc;\n+  kern_return_t kr;\n+  if ((kr = IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                          &ioc)) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5777: Unable to initiate the service.\\n\"\n+                  \"IOServiceOpen() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+  IOObjectRelease(ios);\n+\n+  bool stateCaps;\n+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                      &stateCaps)) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5778: Unable to query CapsLock state.\\n\"\n+                  \"IOHIDGetModifierLockState() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+\n+  bool stateNums;\n+  if ((kr = IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,\n+                                      &stateNums)) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"E5779: Unable to query NumLock state:\\n\"\n+                  \"IOHIDGetModifierLockState() Failed: %d\", (int)kr);\n+    return -1;\n+  }\n+  if (stateCaps) {\n+    *mods |= kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods |= kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return kCapsLock | kNumLock;\n+}\n+#else\n+/// Dummy function used in case of no known platform detected.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to enum KbdLocks.\n+/// @param[out]  err  Location and description where error message is to\n+///                   be saved.\n+///\n+/// @return 0 for all the cases.\n+static mod_mask_t os_get_locks_status(mod_mask_t *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  return 0;\n+}\n+#endif\n+\n+/// Get information about Num/Caps/Scroll Lock state.\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location and description where error message is to",
        "comment_created_at": "2018-04-04T22:10:57+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "It sounds like `err` contains description of location where error message is saved alongside with location itself. This is not the case, remove \u201cand description\u201d.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179620520",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-05T22:42:14+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to load \" XLIB_NAME \": %s\",\n+                  uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to open the display\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get keyboard state of the display\");\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & kXNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & kXCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & kXScrollLock) {\n+    *mods |= kScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);\n+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                                       (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get service for default master port\");\n+    return -1;\n+  }\n+\n+  io_connect_t ioc;\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get service for HID system class\");\n+    return -1;\n+  }\n+  IOObjectRelease(ios);\n+\n+  bool stateCaps;\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to query CapsLock state\");\n+    return -1;\n+  }\n+\n+  bool stateNums;\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to query NumLock state\");\n+    return -1;\n+  }\n+  if (stateCaps) {\n+    *mods |= kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods |= kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return kCapsLock | kNumLock;\n+}\n+#else\n+/// Dummy function used in case of no known platform detected.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return Always return 0.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179620520",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179620520",
        "commented_code": "@@ -0,0 +1,285 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to load \" XLIB_NAME \": %s\",\n+                  uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to open the display\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get keyboard state of the display\");\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & kXNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & kXCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & kXScrollLock) {\n+    *mods |= kScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  const CFMutableDictionaryRef mdict = IOServiceMatching(kIOHIDSystemClass);\n+  const io_service_t ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                                       (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get service for default master port\");\n+    return -1;\n+  }\n+\n+  io_connect_t ioc;\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get service for HID system class\");\n+    return -1;\n+  }\n+  IOObjectRelease(ios);\n+\n+  bool stateCaps;\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to query CapsLock state\");\n+    return -1;\n+  }\n+\n+  bool stateNums;\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDNumLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    IOServiceClose(ioc);\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to query NumLock state\");\n+    return -1;\n+  }\n+  if (stateCaps) {\n+    *mods |= kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods |= kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return kCapsLock | kNumLock;\n+}\n+#else\n+/// Dummy function used in case of no known platform detected.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return Always return 0.",
        "comment_created_at": "2018-04-05T22:42:14+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "It is supposed to be phrased like `@return` is the start of the sentence. E.g. in this case it would be `@return always 0.` (as you could not move \u201calways\u201d before `@return`). You may see in https://neovim.io/doc/dev/typval_8c.html#a2aeea7f4caab15609a6249a8d1e9a587 actually why it is so: `@return` starting block is rendered as a block which starts with an outstanding \u201cReturns\u201d header.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179948848",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-08T14:03:32+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179948848",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:03:32+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "Documentation string looks strange and it is missing documentation about arguments and return value.\r\n\r\n```C\r\n/// Load symbol from previously opened X11 library\r\n///\r\n/// Requires os_xlib_init() to successfully load library before calling this.\r\n///\r\n/// @param[in]  name  Symbol to load. Assumes it being a function name.\r\n/// @param[out]  fun  Location where to put load results.\r\n/// @param[out]  err  Location where to save error.\r\n///\r\n/// @return true if loading was successfull, false otherwise.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "179948995",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:09:17+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "OK\r\n\r\n`@ /// @param[in]  name  Symbol to load. Assumes it being a function name.`\r\n\r\n\r\nShouldn't there be obtain instead of load, as you told of a reason earlier, because of the documentation of the uv_dlsym\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "179949034",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:11:13+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "There was an update as second paragraph was incorrect.",
        "pr_file_module": null
      },
      {
        "comment_id": "179949059",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:12:17+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "Obtain is also good.",
        "pr_file_module": null
      },
      {
        "comment_id": "179949159",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:14:53+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "BTW, cite code with `@\u2026` as code. You can invite users like this, though I think `@param` as an organization does not mind, maybe it is even actually a dummy created by GH team.",
        "pr_file_module": null
      },
      {
        "comment_id": "179949247",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179948848",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11",
        "comment_created_at": "2018-04-08T14:17:32+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "Oh, thats it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179949000",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-08T14:09:32+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *err)\n+  FUNC_ATTR_NONNULL_ALL\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179949000",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179949000",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *err)\n+  FUNC_ATTR_NONNULL_ALL\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions",
        "comment_created_at": "2018-04-08T14:09:32+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "This also missing documentation about return value. And do not add noise about something being a \u201chelper function\u201d, most functions are like this.\r\n\r\n```C\r\n/// Initialize global variables, loading X11 library and required functions\r\n///\r\n/// @param[out]  err  Location where error is saved.\r\n///\r\n/// @return true if everything was loaded successfully, false otherwise.\r\n```\r\n\r\n(and do not use \u201chelper function\u201d here, there is no clear definition of \u201chelper\u201d for this statement to be useful, but it does occupy place)",
        "pr_file_module": null
      },
      {
        "comment_id": "179949128",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179949000",
        "commented_code": "@@ -0,0 +1,292 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *err)\n+  FUNC_ATTR_NONNULL_ALL\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions",
        "comment_created_at": "2018-04-08T14:13:58+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "OK",
        "pr_file_module": null
      }
    ]
  }
]