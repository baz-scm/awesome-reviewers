[
  {
    "discussion_id": "1617912500",
    "pr_number": 29073,
    "pr_file": "runtime/doc/lua-plugin.txt",
    "created_at": "2024-05-28T21:30:37+00:00",
    "commented_code": "+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1617912500",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1617912500",
        "commented_code": "@@ -0,0 +1,447 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]",
        "comment_created_at": "2024-05-28T21:30:37+00:00",
        "comment_author": "dundargoc",
        "comment_body": "You need to indent all codeblocks for TS to highlight correctly. Don't ask me why, thems the rules.\r\n\r\n```suggestion\r\n    ---@class FooSubcommand\r\n    ---@field impl fun(args:string[], opts: table)\r\n    ---@field complete? fun(subcmd_arg_lead: string): string[]\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1617919591",
        "repo_full_name": "neovim/neovim",
        "pr_number": 29073,
        "pr_file": "runtime/doc/lua-plugin.txt",
        "discussion_id": "1617912500",
        "commented_code": "@@ -0,0 +1,447 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]",
        "comment_created_at": "2024-05-28T21:39:34+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "Ah, I was wondering about that :smile: \r\nGood to know.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094171165",
    "pr_number": 34009,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2025-05-17T17:20:40+00:00",
    "commented_code": "\u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2094171165",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2094171165",
        "commented_code": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },",
        "comment_created_at": "2025-05-17T17:20:40+00:00",
        "comment_author": "gpanders",
        "comment_body": "This comment and the way these two lines are grouped together is confusing (I had to read this 3 times and I'm still not 100% confident I'm understanding it correctly).\r\n\r\nIIUC, this installs two different plugins, `github.com/user/plugin1` and `github.com/user/plugin2`. The 1st example is demonstrating the \"shortcut\" method of installing a plugin and the 2nd example is showing the more verbose version.\r\n\r\nThe single comment and grouping of these lines makes it seem like this is installing a single plugin under a directory `plugin1/plugin2`.\r\n\r\nIf my understanding is correct, I think formatting it like this would make it clearer:\r\n\r\n```\r\n-- Install \"plugin1\" and use greatest available version.\r\n'https://github.com/user/plugin1',\r\n\r\n-- Same as above, but using a full table, which allows setting other options.\r\n{ source = 'https://github.com/user/plugin1' },\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161572367",
    "pr_number": 34491,
    "pr_file": "runtime/doc/news.txt",
    "created_at": "2025-06-23T13:00:29+00:00",
    "commented_code": "\u2022 |omnicompletion| in `help` buffer. |ft-help-omni|\n \u2022 Setting \"'0\" in 'shada' prevents storing the jumplist in the shada file.\n \u2022 'shada' now correctly respects \"/0\" and \"f0\".\n+\u2022 Prompt-Buffer:\n+  \u2022 supports multiline inputs.\n+  \u2022 supports multiline paste.\n+  \u2022 supports undo/redo on current prompt.\n+  \u2022 supports normal o/O operations.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2161572367",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "runtime/doc/news.txt",
        "discussion_id": "2161572367",
        "commented_code": "@@ -146,6 +146,11 @@ EDITOR\n \u2022 |omnicompletion| in `help` buffer. |ft-help-omni|\n \u2022 Setting \"'0\" in 'shada' prevents storing the jumplist in the shada file.\n \u2022 'shada' now correctly respects \"/0\" and \"f0\".\n+\u2022 Prompt-Buffer:\n+  \u2022 supports multiline inputs.\n+  \u2022 supports multiline paste.\n+  \u2022 supports undo/redo on current prompt.\n+  \u2022 supports normal o/O operations.",
        "comment_created_at": "2025-06-23T13:00:29+00:00",
        "comment_author": "justinmk",
        "comment_body": "```suggestion\r\n\u2022 |prompt-buffer| supports multiline input/paste, undo/redo, and o/O normal\r\n  commands.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]