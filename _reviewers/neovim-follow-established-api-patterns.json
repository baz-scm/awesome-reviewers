[
  {
    "discussion_id": "2165069136",
    "pr_number": 34637,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-24T22:45:59+00:00",
    "commented_code": "\u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2165069136",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165069136",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
        "comment_created_at": "2025-06-24T22:45:59+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "I don't feel like this needs its own module. But if we don't want to add stuff to `lsp/buf.lua` then I would create a new `formatting.lua` module and move all the formatting handlers there, not make this on-type exclusive.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166031262",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165069136",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
        "comment_created_at": "2025-06-25T07:43:34+00:00",
        "comment_author": "ribru17",
        "comment_body": "Sure; I don't mind adding stuff to buf.lua, I guess I just made a new module because I didn't really know how to add this without that :sweat_smile: I should've asked first. How should this be done- maybe `vim.lsp.buf.start_on_type_formatting(bufnr, client_id)`? And then I could prefix this module with an underscore and just import it in `buf.lua`",
        "pr_file_module": null
      },
      {
        "comment_id": "2166075857",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165069136",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
        "comment_created_at": "2025-06-25T08:06:37+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "TBH I don't think we have documentation around the architecture of new LSP features, and so my comments come from personal takes + previous LSP bikeshedding.\r\n\r\nLet me invoke @lewis6991 and @justinmk for the API design here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166085940",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165069136",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
        "comment_created_at": "2025-06-25T08:11:54+00:00",
        "comment_author": "clason",
        "comment_body": "Personally, `start_on_type_formatting` is too much of a mouthful, so I would prefer `lsp.format.enable()` (with proper options) here, mirroring the `lsp.completion` module. (Formatting seems to be on the same level as completion, conceptually.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2189367047",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165069136",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*",
        "comment_created_at": "2025-07-07T08:34:32+00:00",
        "comment_author": "lewis6991",
        "comment_body": "Wouldn't `vim.lsp.formatting` be a little better. `completion` means to `complete`, and `formatting` means to `format`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165073662",
    "pr_number": 34637,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-24T22:50:10+00:00",
    "commented_code": "\u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2165073662",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-24T22:50:10+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Although dealing with a lot of formatting providers can be funky, we do handle multiple clients in `vim.lsp.buf.format` and I don't think we should differ from that here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166026376",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T07:40:57+00:00",
        "comment_author": "ribru17",
        "comment_body": "Multiple clients are also handled here :+1: using an approach based off `vim.lsp.buf.format`. It's just that clients/buffers are registered one at a time, like in `completion.lua` or `semantic_tokens.lua`",
        "pr_file_module": null
      },
      {
        "comment_id": "2166086027",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T08:11:57+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Understood. Given that the current LSP formatting API that we have only exposes a `format` function, I find it a tad confusing to add a new formatting module with `start` and `stop` functionality.\r\n\r\nIn fact I'm now wondering: Why not just add this into the existing `vim.lsp.buf.format` implementation? Not a suggestion just throwing random questions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166091412",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T08:14:39+00:00",
        "comment_author": "clason",
        "comment_body": "I think we should keep this separate -- distinguishing \"do $THING _now\" and \"set up autocommands for $THING to happen automatically\" are quite different things.\r\n\r\nNot opposed to `vim.lsp.buf.format_enable` though. (Should be called `enable` to match completion and LSP in general.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2166161878",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T08:43:12+00:00",
        "comment_author": "ofseed",
        "comment_body": "Is it feasible to add something like `vim.lsp.enable_feature({feature})`? It seems that there are a lot of features that need to be enabled, not just being called like functions in `vim.lsp.buf`, unless creating a new module for every single feature is acceptable(though I don't oppose it ).",
        "pr_file_module": null
      },
      {
        "comment_id": "2166175192",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T08:48:01+00:00",
        "comment_author": "clason",
        "comment_body": "If anything, this should be an option to `vim.lsp.enable`. That would be a general refactor, though; we should not switch strategies from one feature to the next. (I am skeptical, though, of such a \"one size fits all\" approach.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2166188402",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T08:53:27+00:00",
        "comment_author": "ofseed",
        "comment_body": "`enable()` has an important use for triggering on and off. A common use is `vim.lsp.inlay_hint.enable(vim.lsp.inlay_hint.is_enabled()`. It is indeed difficult to continue using the existing API.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166348824",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T10:10:34+00:00",
        "comment_author": "mfussenegger",
        "comment_body": "> Not opposed to vim.lsp.buf.format_enable though. (Should be called enable to match completion and LSP in general.)\r\n\r\nVia callable metatable we could also have both `vim.lsp.buf.format()` and `vim.lsp.buf.format.enable({ on_save = true, on_type = true })`. (Just bringing it up, not sure it is a good idea)",
        "pr_file_module": null
      },
      {
        "comment_id": "2166633617",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T12:47:00+00:00",
        "comment_author": "ribru17",
        "comment_body": "That would be nice, the only downside I can think of is that it will be harder to enable/disable for specific buffers/clients",
        "pr_file_module": null
      },
      {
        "comment_id": "2166708809",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2165073662",
        "commented_code": "@@ -2249,6 +2249,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*",
        "comment_created_at": "2025-06-25T13:22:42+00:00",
        "comment_author": "ribru17",
        "comment_body": "Maybe we could add buf and client_id fields which, when nil, enable for all buffers/clients",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166760465",
    "pr_number": 34637,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-25T13:44:45+00:00",
    "commented_code": "\u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2166760465",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T13:44:45+00:00",
        "comment_author": "justinmk",
        "comment_body": "`:help dev-naming` i would expect a `enable(enable:boolean)` pattern, not a stop() function\r\n\r\nalso agree that if we want a new module then it seems attractive to have a [format module](https://github.com/neovim/neovim/pull/34637#discussion_r2165069136) for formatting-related things. (We also discussed a `vim.lsp.workspace` module for workspace-related thing).\r\n\r\nBut ideally I think [`vim.lsp.enable` or a similar](https://github.com/neovim/neovim/pull/34637#discussion_r2166175192) top-level demuxer seems to be badly needed, instead of numerous `vim.lsp.x.enable()` things.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166950746",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T14:59:29+00:00",
        "comment_author": "clason",
        "comment_body": "It's straightforward to extend `vim.lsp.enable({'server'}, {feature1 = true, feature2 = { option = a }})`, which I think would be the least intrusive option. Would need a bit of care about defaults and how to handle buffer-specific settings (probably by allowing `feature` to be a command that resolves the desired settings -- again, needs a bit of thinking what this function needs to be passed to; maybe `bufnr` is enough).\r\n\r\nI envision a very similar interface for `vim.treesitter` (where `feature` could be highlight, folds, indents, ...).",
        "pr_file_module": null
      },
      {
        "comment_id": "2166959236",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:03:23+00:00",
        "comment_author": "ribru17",
        "comment_body": "Would this be possible though since we already committed to a signature like `vim.lsp.enable({'server'}, false)` (to stop the server)? I do agree that this would be best though, *if* we can make it work",
        "pr_file_module": null
      },
      {
        "comment_id": "2166963356",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:05:25+00:00",
        "comment_author": "clason",
        "comment_body": "Could dispatch on the `type` of the second argument. I don't much like multiple dispatch, but here it would kinda work (`features = false` == \"no features\" == \"stop the server\").",
        "pr_file_module": null
      },
      {
        "comment_id": "2166965037",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:06:14+00:00",
        "comment_author": "clason",
        "comment_body": "Ceterum censeo: Mixing starting/stopping and enabling autostarting in one function was a domain error.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166999655",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:22:13+00:00",
        "comment_author": "ofseed",
        "comment_body": "Just sharing some ideas on how this could be implemented, because when implementing #34639, I thought it might be suitable to use a unified API like `vim.lsp.enable` to handle this kind of thing. \r\n\r\nI think we can use vim variables like `vim.b` to mark whether a buffer has a specific feature enabled. This way, we can manage this kind of data with unified logic in one place. Otherwise, variables like `enabled` are usually stored in private variables (various `bufstate`), making it impossible to access them outside modules like `vim.lsp.inlay_hint`.\r\n\r\nAs for enabling per client or server, unless we implement it in a somewhat hacky way by \"disabling specific client features through controlling client capabilities,\" it would be quite troublesome; the implementation of certain features must be changed. I have tried doing this before, see #28521.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167013306",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:28:35+00:00",
        "comment_author": "ribru17",
        "comment_body": "That sounds perfect. I think if someone really doesn't want feature \"foo\" for server \"bar\", they can delete the corresponding server capability of \"bar\", like how semantic tokens disabling works now.\r\n\r\n(I don't think it will ever be the case that somebody wants to disable feature \"foo\" for server \"bar\" only in buffer \"x\".)",
        "pr_file_module": null
      },
      {
        "comment_id": "2167033866",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34637,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2166760465",
        "commented_code": "@@ -2249,6 +2249,34 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       \u2022 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.on_type_formatting                *lsp-on_type_formatting*\n+\n+start({bufnr}, {client_id})               *vim.lsp.on_type_formatting.start()*\n+    Enables on-type formatting by the given language client for the given\n+    buffer. The following is a practical usage example: >lua\n+        vim.lsp.start({\n+          name = 'ts_ls',\n+          cmd = \u2026,\n+          on_attach = function(client, bufnr)\n+            vim.lsp.on_type_formatting.start(bufnr, client.id)\n+          end,\n+        })\n+<\n+\n+    Parameters: ~\n+      \u2022 {bufnr}      (`integer`) Buffer handle, or 0 for current.\n+      \u2022 {client_id}  (`integer`) Client ID.\n+\n+stop({bufnr}, {client_id})                 *vim.lsp.on_type_formatting.stop()*",
        "comment_created_at": "2025-06-25T15:38:30+00:00",
        "comment_author": "ofseed",
        "comment_body": "Yes, I have to say that the server itself usually provides a configuration (for us, it's `client.settings`) to permanently disable a specific feature, like inlay hints. Implementing this feature is somewhat difficult, and there are too many ways to achieve it already, so the cost would be pretty high if just for API consistency, like what I tried in that PR.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1581156758",
    "pr_number": 28521,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2024-04-26T14:57:48+00:00",
    "commented_code": "\u2022 {client_id} (`integer`)\n         \u2022 {inlay_hint} (`lsp.InlayHint`)\n \n-is_enabled({bufnr})                          *vim.lsp.inlay_hint.is_enabled()*\n+is_enabled({bufnr}, {client_id})             *vim.lsp.inlay_hint.is_enabled()*",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1581156758",
        "repo_full_name": "neovim/neovim",
        "pr_number": 28521,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "1581156758",
        "commented_code": "@@ -1649,13 +1651,14 @@ get({filter})                                       *vim.lsp.inlay_hint.get()*\n         \u2022 {client_id} (`integer`)\n         \u2022 {inlay_hint} (`lsp.InlayHint`)\n \n-is_enabled({bufnr})                          *vim.lsp.inlay_hint.is_enabled()*\n+is_enabled({bufnr}, {client_id})             *vim.lsp.inlay_hint.is_enabled()*",
        "comment_created_at": "2024-04-26T14:57:48+00:00",
        "comment_author": "justinmk",
        "comment_body": "if more filters are being added then it's time to make this a \"kwargs\" arg instead of adding more parameters.\r\n\r\nprobably `is_enabled({filter})` is best, though `is_enabled({bufnr}, {filter})` could be acceptable (and `bufnr=nil` would be \"all/any buffer\")\r\n\r\n```suggestion\r\nis_enabled({bufnr}, {filter})             *vim.lsp.inlay_hint.is_enabled()*\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136699137",
    "pr_number": 34388,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-10T00:16:39+00:00",
    "commented_code": "(`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+enable({enable})                       *vim.lsp.linked_editing_range.enable()*\n+    Enables or disables linked editing ranges\n+\n+    To \"toggle\", pass the inverse of `is_enabled()`: >lua",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2136699137",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2136699137",
        "commented_code": "@@ -2274,6 +2274,26 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+enable({enable})                       *vim.lsp.linked_editing_range.enable()*\n+    Enables or disables linked editing ranges\n+\n+    To \"toggle\", pass the inverse of `is_enabled()`: >lua",
        "comment_created_at": "2025-06-10T00:16:39+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "Maybe others will disagree but I can't think of why someone would want to toggle this. I do think we should keep `enable()` for API consistency, but I would lean towards killing `is_enabled()` (at least for the first iteration of the feature).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168696297",
    "pr_number": 34388,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-26T10:03:17+00:00",
    "commented_code": "(`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2168696297",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T10:03:17+00:00",
        "comment_author": "justinmk",
        "comment_body": "Isn't a filter kwargs table the common pattern? Not sure why `vim.lsp.completion.enable()` differs though.\r\n\r\n```suggestion\r\nenable({enable}, {filter})\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2169013913",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T12:58:58+00:00",
        "comment_author": "ribru17",
        "comment_body": "I can do that, it will just take some more logic to handle global enabling/disabling, etc. `document_color.enable()` also doesn't use kwargs and `semantic_tokens` doesn't either (but it also uses `start()` and `stop()` to be weird :laughing: ). Seems like enabling/disabling features is kinda all over the place right now",
        "pr_file_module": null
      },
      {
        "comment_id": "2169097967",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T13:37:12+00:00",
        "comment_author": "ribru17",
        "comment_body": "Actually, it looks like supporting global enabling will add a lot of complexity (especially if we specify only one of `buf = nil` and `client_id = nil`. Is this a blocker or can it be put on hold?",
        "pr_file_module": null
      },
      {
        "comment_id": "2169102483",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T13:39:21+00:00",
        "comment_author": "justinmk",
        "comment_body": "> `semantic_tokens` doesn't either (but it also uses `start()` and `stop()` to be weird \ud83d\ude06\r\n\r\noh we might need to fix that. https://github.com/neovim/neovim/issues/34664\r\n\r\n> Seems like enabling/disabling features is kinda all over the place right now\r\n\r\n`:help dev-patterns` documents the expected `enable()` pattern.\r\n\r\n> will just take some more logic to handle global enabling/disabling\r\n\r\nif possible we should add a `vim._util` to help with that",
        "pr_file_module": null
      },
      {
        "comment_id": "2169107556",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T13:41:39+00:00",
        "comment_author": "justinmk",
        "comment_body": "> supporting global enabling will add a lot of complexity (especially if we specify only one of `buf = nil` and `client_id = nil`. Is this a blocker or can it be put on hold?\r\n\r\nthere is no requirement to support any particular behavior, as long as the interface has the right pattern. i.e `enable(boolean)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2169109056",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-26T13:42:16+00:00",
        "comment_author": "ribru17",
        "comment_body": "> `:help dev-patterns` documents the expected `enable()` pattern.\r\n\r\nSorry, I should really read that whole page soon. I see also now that f1dfe32b explicitly changed the inlay hint impl\r\n\r\n> if possible we should add a `vim._util` to help with that\r\n\r\n:+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "2170814014",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-27T05:24:23+00:00",
        "comment_author": "ofseed",
        "comment_body": "> I can do that, it will just take some more logic to handle global enabling/disabling, etc. `document_color.enable()` also doesn't use kwargs and `semantic_tokens` doesn't either (but it also uses `start()` and `stop()` to be weird \ud83d\ude06 ). Seems like enabling/disabling features is kinda all over the place right now\r\n\r\nThe different signature of `document_color` was suggested by me, but that's just limited to the implementation, because the signature like `inlay_hint.enable` will make it unnecessarily complex. We are just waiting for a common module for that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2171158668",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-27T08:11:31+00:00",
        "comment_author": "ribru17",
        "comment_body": "Inlay hints also can't currently be enabled per-client, meaning it can't yet work with https://github.com/neovim/neovim/issues/34659",
        "pr_file_module": null
      },
      {
        "comment_id": "2171439748",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34388,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2168696297",
        "commented_code": "@@ -2292,6 +2292,29 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n         (`boolean`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.linked_editing_range            *lsp-linked_editing_range*\n+\n+                                       *vim.lsp.linked_editing_range.enable()*\n+enable({enable}, {bufnr}, {client_id})",
        "comment_created_at": "2025-06-27T09:47:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "Just to be clear, there is no requirement for the initial impl of this or other lsp features to fully support things like per-client enablement, etc. The only requirement is that the basic signature of `enable(enable:boolean, filter?:table)` is correct :) \r\n\r\n\"per-client\", \"per-buffer\" can be added later by expanding the `filter` kwargs.",
        "pr_file_module": null
      }
    ]
  }
]