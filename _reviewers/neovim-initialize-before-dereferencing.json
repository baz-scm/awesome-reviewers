[
  {
    "discussion_id": "2144548757",
    "pr_number": 34414,
    "pr_file": "src/nvim/memline.c",
    "created_at": "2025-06-13T09:03:46+00:00",
    "commented_code": "// If vimrc has \"simalt ~x\" we don't want it to\n             // interfere with the prompt here.\n             flush_buffers(FLUSH_TYPEAHEAD);\n-          }\n \n-          if (swap_exists_action != SEA_NONE && choice == SEA_CHOICE_NONE) {\n-            const char *const sw_msg_1 = _(\"Swap file \\\"\");\n-            const char *const sw_msg_2 = _(\"\\\" already exists!\");\n-\n-            const size_t fname_len = strlen(fname);\n-            const size_t sw_msg_1_len = strlen(sw_msg_1);\n-            const size_t sw_msg_2_len = strlen(sw_msg_2);\n-\n-            const size_t name_len = sw_msg_1_len + fname_len + sw_msg_2_len + 5;\n-\n-            char *const name = xmalloc(name_len);\n-            memcpy(name, sw_msg_1, sw_msg_1_len + 1);\n-            home_replace(NULL, fname, name + sw_msg_1_len, fname_len, true);\n-            xstrlcat(name, sw_msg_2, name_len);\n-            int dialog_result\n-              = do_dialog(VIM_WARNING,\n-                          _(\"VIM - ATTENTION\"),\n-                          name,\n-                          proc_running\n-                          ? _(\"&Open Read-Only\n&Edit anyway\n&Recover\n&Quit\n&Abort\")\n-                          : _(\"&Open Read-Only\n&Edit anyway\n&Recover\n&Delete it\n&Quit\n&Abort\"),\n-                          1, NULL, false);\n-\n-            if (proc_running && dialog_result >= 4) {\n+            if (swap_exists_action != SEA_NONE) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2144548757",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34414,
        "pr_file": "src/nvim/memline.c",
        "discussion_id": "2144548757",
        "commented_code": "@@ -3472,40 +3474,26 @@ static char *findswapname(buf_T *buf, char **dirp, char *old_fname, bool *found_\n             // If vimrc has \"simalt ~x\" we don't want it to\n             // interfere with the prompt here.\n             flush_buffers(FLUSH_TYPEAHEAD);\n-          }\n \n-          if (swap_exists_action != SEA_NONE && choice == SEA_CHOICE_NONE) {\n-            const char *const sw_msg_1 = _(\"Swap file \\\"\");\n-            const char *const sw_msg_2 = _(\"\\\" already exists!\");\n-\n-            const size_t fname_len = strlen(fname);\n-            const size_t sw_msg_1_len = strlen(sw_msg_1);\n-            const size_t sw_msg_2_len = strlen(sw_msg_2);\n-\n-            const size_t name_len = sw_msg_1_len + fname_len + sw_msg_2_len + 5;\n-\n-            char *const name = xmalloc(name_len);\n-            memcpy(name, sw_msg_1, sw_msg_1_len + 1);\n-            home_replace(NULL, fname, name + sw_msg_1_len, fname_len, true);\n-            xstrlcat(name, sw_msg_2, name_len);\n-            int dialog_result\n-              = do_dialog(VIM_WARNING,\n-                          _(\"VIM - ATTENTION\"),\n-                          name,\n-                          proc_running\n-                          ? _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Quit\\n&Abort\")\n-                          : _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Delete it\\n&Quit\\n&Abort\"),\n-                          1, NULL, false);\n-\n-            if (proc_running && dialog_result >= 4) {\n+            if (swap_exists_action != SEA_NONE) {",
        "comment_created_at": "2025-06-13T09:03:46+00:00",
        "comment_author": "justinmk",
        "comment_body": "coverity:\r\n\r\n```\r\n*** CID 554963:           (FORWARD_NULL)\r\n/src/nvim/memline.c: 3484             in findswapname()\r\n3478                 if (swap_exists_action != SEA_NONE) {\r\n3479                   kv_printf(msg, _(\"Swap file \\\"\"));\r\n3480                   kv_printf(msg, \"%s\", fhname);\r\n3481                   kv_printf(msg, _(\"\\\" already exists!\"));\r\n3482                   char *run_but = _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Quit\\n&Abort\");\r\n3483                   char *but = _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Delete it\\n&Quit\\n&Abort\");\r\n>>>     CID 554963:           (FORWARD_NULL)\r\n>>>     Passing null pointer \"msg.items\" to \"do_dialog\", which dereferences it.\r\n3484                   choice = (sea_choice_T)do_dialog(VIM_WARNING, _(\"VIM - ATTENTION\"), msg.items,\r\n3485                                                    proc_running ? run_but : but, 1, NULL, false);\r\n3486     \r\n3487                   // compensate for missing \"Delete it\" button\r\n3488                   choice += proc_running && choice >= 4;\r\n3489                   // pretend screen didn't scroll, need redraw anyway\r\n/src/nvim/memline.c: 3492             in findswapname()\r\n3486     \r\n3487                   // compensate for missing \"Delete it\" button\r\n3488                   choice += proc_running && choice >= 4;\r\n3489                   // pretend screen didn't scroll, need redraw anyway\r\n3490                   msg_reset_scroll();\r\n3491                 } else {\r\n>>>     CID 554963:           (FORWARD_NULL)\r\n>>>     Passing null pointer \"msg.items\" to \"msg_outtrans\", which dereferences it.\r\n3492                   msg_outtrans(msg.items, 0, false);\r\n3493                 }\r\n3494                 no_wait_return--;\r\n3495                 kv_destroy(msg);\r\n3496                 xfree(fhname);\r\n3497               }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2144574865",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34414,
        "pr_file": "src/nvim/memline.c",
        "discussion_id": "2144548757",
        "commented_code": "@@ -3472,40 +3474,26 @@ static char *findswapname(buf_T *buf, char **dirp, char *old_fname, bool *found_\n             // If vimrc has \"simalt ~x\" we don't want it to\n             // interfere with the prompt here.\n             flush_buffers(FLUSH_TYPEAHEAD);\n-          }\n \n-          if (swap_exists_action != SEA_NONE && choice == SEA_CHOICE_NONE) {\n-            const char *const sw_msg_1 = _(\"Swap file \\\"\");\n-            const char *const sw_msg_2 = _(\"\\\" already exists!\");\n-\n-            const size_t fname_len = strlen(fname);\n-            const size_t sw_msg_1_len = strlen(sw_msg_1);\n-            const size_t sw_msg_2_len = strlen(sw_msg_2);\n-\n-            const size_t name_len = sw_msg_1_len + fname_len + sw_msg_2_len + 5;\n-\n-            char *const name = xmalloc(name_len);\n-            memcpy(name, sw_msg_1, sw_msg_1_len + 1);\n-            home_replace(NULL, fname, name + sw_msg_1_len, fname_len, true);\n-            xstrlcat(name, sw_msg_2, name_len);\n-            int dialog_result\n-              = do_dialog(VIM_WARNING,\n-                          _(\"VIM - ATTENTION\"),\n-                          name,\n-                          proc_running\n-                          ? _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Quit\\n&Abort\")\n-                          : _(\"&Open Read-Only\\n&Edit anyway\\n&Recover\\n&Delete it\\n&Quit\\n&Abort\"),\n-                          1, NULL, false);\n-\n-            if (proc_running && dialog_result >= 4) {\n+            if (swap_exists_action != SEA_NONE) {",
        "comment_created_at": "2025-06-13T09:18:39+00:00",
        "comment_author": "luukvbaal",
        "comment_body": "Yeah I saw the report. Definitely a false positive but maybe this suppresses it?\r\n```diff\r\ndiff --git a/src/nvim/memline.c b/src/nvim/memline.c\r\nindex 1054e40190..fb640e00d1 100644\r\n--- a/src/nvim/memline.c\r\n+++ b/src/nvim/memline.c\r\n@@ -3258,6 +3258,7 @@ static void attention_message(buf_T *buf, char *fname, char *fhname, StringBuild\r\n   assert(buf->b_fname != NULL);\r\n\r\n   emsg(_(\"E325: ATTENTION\"));\r\n+  kv_resize(*msg, IOSIZE);\r\n   kv_printf(*msg, _(\"Found a swap file by the name \\\"\"));\r\n   kv_printf(*msg, \"%s\\\"\\n\", fhname);\r\n   const time_t swap_mtime = swapfile_info(fname, msg);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179620889",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-05T22:44:28+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to load \" XLIB_NAME \": %s\",\n+                  uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to open the display\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get keyboard state of the display\");\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & kXNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & kXCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & kXScrollLock) {\n+    *mods |= kScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179620889",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "179620889",
        "commented_code": "@@ -0,0 +1,285 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/os/keyboard.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#if defined(__linux__)\n+# define XLIB_NAME \"libX11.so.6\"\n+\n+typedef void *_XDisplay;\n+\n+/// Holds the data of the present state of Keyboard\n+typedef struct {\n+  char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+/// The offset of the keyboard lock modes for X11\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+\n+/// Masks used in libX11 for different Lock states\n+typedef enum {\n+    kXNumLock = 0x10,  ///< Mask for NumLock\n+    kXCapsLock = 0x02,  ///< Mask for CapsLock\n+    kXScrollLock = 0x80,  ///< Mask for ScrollLock\n+} XlibKbdLocks;\n+#elif defined(WIN32)\n+# include <Winuser.h>\n+#elif defined(__APPLE__)\n+# define Boolean Boolean_I_Dont_Care\n+# include <IOKit/IOKitLib.h>\n+# include <IOKit/IOReturn.h>\n+# include <IOKit/hidsystem/IOHIDLib.h>\n+# include <IOKit/hidsystem/IOHIDParameter.h>\n+# include <CoreFoundation/CoreFoundation.h>\n+# undef Boolean\n+#endif\n+\n+/// Masks for the specific keyboard lock status\n+typedef enum {\n+  kNumLock = 0x01,  ///< Mask used to check if the NumLock is active\n+  kCapsLock = 0x02,  ///< Mask used to check if the CapsLock is active\n+  kScrollLock = 0x04,  ///< Mask used to check if the ScrollLock is active\n+} KbdLocks;\n+\n+/// Used as a bitmask for the status of the different Lock Status\n+typedef int ModMask;\n+\n+#ifdef INCLUDE_GENERATED_DECLARATIONS\n+# include \"os/keyboard.c.generated.h\"\n+#endif\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load a function of libX11\n+static bool os_xlib_dlsym(const char *name, void **fun, Error *const err)\n+{\n+  const int ret = uv_dlsym(&xlib, name, fun);\n+  if (ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to obtain %s function from X11\",\n+                  name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(Error *const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to load \" XLIB_NAME \": %s\",\n+                  uv_dlerror(&xlib));\n+    return false;\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if (!os_xlib_dlsym(\"XOpenDisplay\", (void **)&_XOpenDisplay, err)\n+      || !os_xlib_dlsym(\"XCloseDisplay\", (void **)&_XCloseDisplay, err)\n+      || !os_xlib_dlsym(\"XkbGetState\", (void **)&_XkbGetState, err)) {\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps/Scroll Lock state in Linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  if (!os_xlib_init(err)) {\n+    return -1;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to open the display\");\n+    return -1;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Unable to get keyboard state of the display\");\n+\n+    _XCloseDisplay(display);\n+  }\n+\n+  int state = xkb_state.data[kLockedModsOffset];\n+  if (state & kXNumLock) {\n+    *mods |= kNumLock;\n+  }\n+\n+  if (state & kXCapsLock) {\n+    *mods |= kCapsLock;\n+  }\n+\n+  if (state & kXScrollLock) {\n+    *mods |= kScrollLock;\n+  }\n+\n+  _XCloseDisplay(display);\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps/Scroll Lock state in Windows.\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)\n+{\n+  *mods = 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods |= kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods |= kNumLock;\n+  }\n+  if (GetKeyState(VK_SCROLL) & 0x0001) {\n+    *mods |= kScrollLock;\n+  }\n+  return kCapsLock | kNumLock | kScrollLock;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a pointer to integer bitmask.\n+/// @param[out]  err  Location where error message is to be saved\n+///\n+/// @return -1 in case of error and a mask specifying which values\n+///         in mods are valid otherwise.\n+static ModMask os_get_locks_status(ModMask *const mods, Error *const err)",
        "comment_created_at": "2018-04-05T22:44:28+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "Would be a good idea to add `FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT` to all these functions.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2099720910",
    "pr_number": 33953,
    "pr_file": "src/nvim/ui_client.c",
    "created_at": "2025-05-21T08:41:34+00:00",
    "commented_code": "(const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);\n+  if (!success) {\n+    ELOG(\"%s\", error);\n+    return;\n+  }\n+\n+  // 3. Get v:argv.\n+  typval_T *tv = get_vim_var_tv(VV_ARGV);\n+  if (tv->v_type != VAR_LIST || tv->vval.v_list == NULL) {\n+    ELOG(\"failed to get vim var typval\");\n+    return;\n+  }\n+  list_T *l = tv->vval.v_list;\n+  int argc = tv_list_len(l);\n+\n+  // Assert to be positive for safe conversion to size_t.\n+  assert(argc >= 0);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2099720910",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33953,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2099720910",
        "commented_code": "@@ -284,6 +285,57 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// Restarts the embedded server without killing the UI.\n+void ui_client_event_restart(Array args)\n+{\n+  // 1. Client-side server detach.\n+  ui_client_detach();\n+\n+  // 2. Close ui client channel (auto kills the `nvim --embed` server due to self-exit).\n+  const char *error;\n+  bool success = channel_close(ui_client_channel_id, kChannelPartAll, &error);\n+  if (!success) {\n+    ELOG(\"%s\", error);\n+    return;\n+  }\n+\n+  // 3. Get v:argv.\n+  typval_T *tv = get_vim_var_tv(VV_ARGV);\n+  if (tv->v_type != VAR_LIST || tv->vval.v_list == NULL) {\n+    ELOG(\"failed to get vim var typval\");\n+    return;\n+  }\n+  list_T *l = tv->vval.v_list;\n+  int argc = tv_list_len(l);\n+\n+  // Assert to be positive for safe conversion to size_t.\n+  assert(argc >= 0);",
        "comment_created_at": "2025-05-21T08:41:34+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "Change this to be `assert(argc > 0)` instead. `argc` can never be zero",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158370621",
    "pr_number": 34225,
    "pr_file": "src/nvim/tui/tui.c",
    "created_at": "2025-06-20T08:41:43+00:00",
    "commented_code": "char *term = os_getenv(\"TERM\");\n #ifdef MSWIN\n-  os_tty_guess_term(&term, tui->out_fd);\n+  os_tty_guess_term((const char **)&term, tui->out_fd);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2158370621",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34225,
        "pr_file": "src/nvim/tui/tui.c",
        "discussion_id": "2158370621",
        "commented_code": "@@ -386,10 +386,8 @@ static void terminfo_start(TUIData *tui)\n \n   char *term = os_getenv(\"TERM\");\n #ifdef MSWIN\n-  os_tty_guess_term(&term, tui->out_fd);\n+  os_tty_guess_term((const char **)&term, tui->out_fd);",
        "comment_created_at": "2025-06-20T08:41:43+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "I think `os_tty_guess_term()` needs change too. It can't just override `term` as it's now an allocated string. It needs to free the old `term` and set the new value to an allocated string instead of a constant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2158391367",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34225,
        "pr_file": "src/nvim/tui/tui.c",
        "discussion_id": "2158370621",
        "commented_code": "@@ -386,10 +386,8 @@ static void terminfo_start(TUIData *tui)\n \n   char *term = os_getenv(\"TERM\");\n #ifdef MSWIN\n-  os_tty_guess_term(&term, tui->out_fd);\n+  os_tty_guess_term((const char **)&term, tui->out_fd);",
        "comment_created_at": "2025-06-20T08:52:58+00:00",
        "comment_author": "axelhj",
        "comment_body": "True. I just checked what it does. It sets the pointed-to pointer to a statically allocated char* value. Those are not supposed to be freed with xfree but that seems likely to happen now?",
        "pr_file_module": null
      },
      {
        "comment_id": "2158418505",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34225,
        "pr_file": "src/nvim/tui/tui.c",
        "discussion_id": "2158370621",
        "commented_code": "@@ -386,10 +386,8 @@ static void terminfo_start(TUIData *tui)\n \n   char *term = os_getenv(\"TERM\");\n #ifdef MSWIN\n-  os_tty_guess_term(&term, tui->out_fd);\n+  os_tty_guess_term((const char **)&term, tui->out_fd);",
        "comment_created_at": "2025-06-20T09:03:57+00:00",
        "comment_author": "axelhj",
        "comment_body": "term is only changed if term is a null pointer (which `os_getenv` can return). TERM is very often set though so it is unlikely to be freeing the statically allocated string (but possible?). I pushed a change which I think is safer (I don't know if the value of term is actually important. `os_tty_guess_term()` has a bunch of sideffects which might matter more than the term value. I didn't check but the behaviour should be roughly the same.).",
        "pr_file_module": null
      }
    ]
  }
]