[
  {
    "discussion_id": "1278211579",
    "pr_number": 24507,
    "pr_file": "src/nvim/api/tabpage.c",
    "created_at": "2023-07-29T02:09:42+00:00",
    "commented_code": "#include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1278211579",
        "repo_full_name": "neovim/neovim",
        "pr_number": 24507,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1278211579",
        "commented_code": "@@ -4,15 +4,51 @@\n #include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
        "comment_created_at": "2023-07-29T02:09:42+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "```suggestion\r\n  Array rv = vim_to_object(&list_tv).data.array;\r\n  tv_clear(&list_tv);\r\n  return rv;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1278212188",
        "repo_full_name": "neovim/neovim",
        "pr_number": 24507,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1278211579",
        "commented_code": "@@ -4,15 +4,51 @@\n #include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
        "comment_created_at": "2023-07-29T02:15:16+00:00",
        "comment_author": "willothy",
        "comment_body": "Ahh okay, thanks! Still getting a handle on the type system here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1278214208",
        "repo_full_name": "neovim/neovim",
        "pr_number": 24507,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1278211579",
        "commented_code": "@@ -4,15 +4,51 @@\n #include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
        "comment_created_at": "2023-07-29T02:35:57+00:00",
        "comment_author": "willothy",
        "comment_body": "So to be clear, vim_to_object performs a copy  so the memory held by whatever it's converting from is no longer needed?",
        "pr_file_module": null
      },
      {
        "comment_id": "1278214401",
        "repo_full_name": "neovim/neovim",
        "pr_number": 24507,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1278211579",
        "commented_code": "@@ -4,15 +4,51 @@\n #include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
        "comment_created_at": "2023-07-29T02:37:44+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "Yes. There is a similar example in lines 317-319 in src/nvim/context.c.",
        "pr_file_module": null
      },
      {
        "comment_id": "1278214536",
        "repo_full_name": "neovim/neovim",
        "pr_number": 24507,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1278211579",
        "commented_code": "@@ -4,15 +4,51 @@\n #include <stdbool.h>\n #include <stdlib.h>\n \n+#include \"nvim/api/private/converter.h\"\n #include \"nvim/api/private/defs.h\"\n #include \"nvim/api/private/helpers.h\"\n #include \"nvim/api/tabpage.h\"\n #include \"nvim/api/vim.h\"\n #include \"nvim/buffer_defs.h\"\n+#include \"nvim/eval/typval.h\"\n+#include \"nvim/eval/typval_defs.h\"\n+#include \"nvim/eval/typval_encode.h\"\n+#include \"nvim/eval/window.h\"\n #include \"nvim/globals.h\"\n #include \"nvim/memory.h\"\n #include \"nvim/window.h\"\n \n+/// Returns the layout of a tabpage as a tree-structured Dictionary\n+///\n+/// @param tabpage Tabpage handle, or 0 for the current tabpage\n+/// @param[out] err Error details, if any.\n+/// @return Tree of windows and frames in `tabpage`, or nil if the tab is invalid\n+Object nvim_tabpage_get_layout(Tabpage tabpage, Error *err)\n+  FUNC_API_SINCE(10)\n+{\n+  tabpage_T *tab;\n+  if (tabpage == 0) {\n+    tab = curtab;\n+  } else {\n+    tab = find_tab_by_handle(tabpage, err);\n+  }\n+\n+  if (!tab) {\n+    return NIL;\n+  }\n+\n+  list_T *fr_list = tv_list_alloc(2);\n+\n+  get_framelayout(tab->tp_topframe, fr_list, true);\n+\n+  typval_T rv = {\n+    .vval.v_list = fr_list,\n+    .v_type = VAR_LIST\n+  };\n+\n+  return vim_to_object(&rv);",
        "comment_created_at": "2023-07-29T02:38:55+00:00",
        "comment_author": "willothy",
        "comment_body": "Thanks, I'll check that out. I appreciate the help!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "178654775",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-02T21:24:28+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if ((uv_dlsym(&xlib, \"XOpenDisplay\", (void **)&_XOpenDisplay)\n+       || uv_dlsym(&xlib, \"XCloseDisplay\", (void **)&_XCloseDisplay)\n+       || uv_dlsym(&xlib, \"XkbGetState\", (void **)&_XkbGetState)) != 0) {\n+    *err = \"Unable to get the functions of X11\";\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps Lock state in linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_init(err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps Lock state in Windows\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_mods_status(Dictionary *const dict, const char **const err )\n+{\n+  int mods = 0;\n+  *err = NULL;\n+  bool status = os_get_locks_status(&mods, err);\n+  if (!status) {\n+      return false;\n+  }\n+  PUT(*dict, \"CapsLock\", BOOLEAN_OBJ(mods & kCapsLock));\n+  PUT(*dict, \"NumLock\", BOOLEAN_OBJ(mods & kNumLock));",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "178654775",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "178654775",
        "commented_code": "@@ -0,0 +1,231 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if ((uv_dlsym(&xlib, \"XOpenDisplay\", (void **)&_XOpenDisplay)\n+       || uv_dlsym(&xlib, \"XCloseDisplay\", (void **)&_XCloseDisplay)\n+       || uv_dlsym(&xlib, \"XkbGetState\", (void **)&_XkbGetState)) != 0) {\n+    *err = \"Unable to get the functions of X11\";\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps Lock state in linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_init(err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps Lock state in Windows\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_mods_status(Dictionary *const dict, const char **const err )\n+{\n+  int mods = 0;\n+  *err = NULL;\n+  bool status = os_get_locks_status(&mods, err);\n+  if (!status) {\n+      return false;\n+  }\n+  PUT(*dict, \"CapsLock\", BOOLEAN_OBJ(mods & kCapsLock));\n+  PUT(*dict, \"NumLock\", BOOLEAN_OBJ(mods & kNumLock));",
        "comment_created_at": "2018-04-02T21:24:28+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "If you do not want to add `#ifdef` here (understandable, I also would not) then define `kOSModQueryMask` enum near `os_get_locks_status` function and write code like\r\n\r\n```C\r\nif (kOSModQueryMask & kCapsLock) {\r\n  PUT(\u2026);\r\n}\r\n```\r\n\r\nOr, probably better, make this mask another return: not needed now, but will help refactoring a thing into providers.",
        "pr_file_module": null
      },
      {
        "comment_id": "178666000",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "178654775",
        "commented_code": "@@ -0,0 +1,231 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if ((uv_dlsym(&xlib, \"XOpenDisplay\", (void **)&_XOpenDisplay)\n+       || uv_dlsym(&xlib, \"XCloseDisplay\", (void **)&_XCloseDisplay)\n+       || uv_dlsym(&xlib, \"XkbGetState\", (void **)&_XkbGetState)) != 0) {\n+    *err = \"Unable to get the functions of X11\";\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps Lock state in linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_init(err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps Lock state in Windows\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_mods_status(Dictionary *const dict, const char **const err )\n+{\n+  int mods = 0;\n+  *err = NULL;\n+  bool status = os_get_locks_status(&mods, err);\n+  if (!status) {\n+      return false;\n+  }\n+  PUT(*dict, \"CapsLock\", BOOLEAN_OBJ(mods & kCapsLock));\n+  PUT(*dict, \"NumLock\", BOOLEAN_OBJ(mods & kNumLock));",
        "comment_created_at": "2018-04-02T22:16:24+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "I want some info about this `kOSModQueryMask`, why its useful, what its value will be, do you mean, I make the enum of the integer pointer `mods`, so its value can be used in more convenient manner",
        "pr_file_module": null
      }
    ]
  }
]