[
  {
    "discussion_id": "2234353486",
    "pr_number": 35087,
    "pr_file": "src/nvim/api/extmark.c",
    "created_at": "2025-07-28T02:04:58+00:00",
    "commented_code": "}\n \n   if (HAS_KEY(opts, set_extmark, conceal)) {\n-    hl.flags |= kSHConceal;\n     has_hl = true;\n-    if (opts->conceal.size > 0) {\n-      int ch;\n-      hl.conceal_char = utfc_ptr2schar(opts->conceal.data, &ch);\n-      VALIDATE(hl.conceal_char && vim_isprintc(ch), \"%s\", \"conceal char has to be printable\", {\n-        goto error;\n-      });\n+    if (opts->conceal.type == kObjectTypeBoolean) {\n+      Boolean is_concealed = opts->conceal.data.boolean;\n+      if (is_concealed) {\n+        hl.flags |= kSHConceal;\n+      } else {\n+        hl.flags |= kSHConcealOff;",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234353486",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35087,
        "pr_file": "src/nvim/api/extmark.c",
        "discussion_id": "2234353486",
        "commented_code": "@@ -625,14 +628,27 @@ Integer nvim_buf_set_extmark(Buffer buffer, Integer ns_id, Integer line, Integer\n   }\n \n   if (HAS_KEY(opts, set_extmark, conceal)) {\n-    hl.flags |= kSHConceal;\n     has_hl = true;\n-    if (opts->conceal.size > 0) {\n-      int ch;\n-      hl.conceal_char = utfc_ptr2schar(opts->conceal.data, &ch);\n-      VALIDATE(hl.conceal_char && vim_isprintc(ch), \"%s\", \"conceal char has to be printable\", {\n-        goto error;\n-      });\n+    if (opts->conceal.type == kObjectTypeBoolean) {\n+      Boolean is_concealed = opts->conceal.data.boolean;\n+      if (is_concealed) {\n+        hl.flags |= kSHConceal;\n+      } else {\n+        hl.flags |= kSHConcealOff;",
        "comment_created_at": "2025-07-28T02:04:58+00:00",
        "comment_author": "justinmk",
        "comment_body": "please, use ternaries for simple cases. verbose code is a cost.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1486276350",
    "pr_number": 26799,
    "pr_file": "src/nvim/popupmenu.c",
    "created_at": "2024-02-12T14:39:29+00:00",
    "commented_code": "block_autocmds();\n   RedrawingDisabled++;\n   no_u_sync++;\n-  win_T *wp = win_float_find_preview();\n+  win_T *wp = win_float_find_preview(true);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1486276350",
        "repo_full_name": "neovim/neovim",
        "pr_number": 26799,
        "pr_file": "src/nvim/popupmenu.c",
        "discussion_id": "1486276350",
        "commented_code": "@@ -772,7 +772,7 @@ win_T *pum_set_info(int pum_idx, char *info)\n   block_autocmds();\n   RedrawingDisabled++;\n   no_u_sync++;\n-  win_T *wp = win_float_find_preview();\n+  win_T *wp = win_float_find_preview(true);",
        "comment_created_at": "2024-02-12T14:39:29+00:00",
        "comment_author": "seandewar",
        "comment_body": "Nit, but above this, the line `bool use_float = strstr(p_cot, \"popup\") != NULL ? true : false;` doesn't need the ternary.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "177264244",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/env.c",
    "created_at": "2018-03-26T23:20:19+00:00",
    "commented_code": "#endif\n }\n \n+/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.\n+int capslock_status(void ) {\n+\n+#if defined(__linux__)\n+\n+  FILE *fp = NULL;\n+  char res[1024];\n+  fp = popen(\"xset -q | grep Caps\", \"r\");\n+  if (fp == NULL) {\n+      return -1;\n+  }\n+  fgets(res, sizeof(res), fp);\n+  if (STRNCMP(res + 21, \"on\", 2) == 0) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+\n+#elif defined(WIN32)\n+  if ((GetKeyState(VK_CAPITAL) & 0x0001)!=0) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "177264244",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/env.c",
        "discussion_id": "177264244",
        "commented_code": "@@ -169,6 +178,64 @@ void os_get_hostname(char *hostname, size_t size)\n #endif\n }\n \n+/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.\n+int capslock_status(void ) {\n+\n+#if defined(__linux__)\n+\n+  FILE *fp = NULL;\n+  char res[1024];\n+  fp = popen(\"xset -q | grep Caps\", \"r\");\n+  if (fp == NULL) {\n+      return -1;\n+  }\n+  fgets(res, sizeof(res), fp);\n+  if (STRNCMP(res + 21, \"on\", 2) == 0) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+\n+#elif defined(WIN32)\n+  if ((GetKeyState(VK_CAPITAL) & 0x0001)!=0) {",
        "comment_created_at": "2018-03-26T23:20:19+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "This is four lines longer then needed, you can just return the result of comparison.",
        "pr_file_module": null
      },
      {
        "comment_id": "177407781",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/env.c",
        "discussion_id": "177264244",
        "commented_code": "@@ -169,6 +178,64 @@ void os_get_hostname(char *hostname, size_t size)\n #endif\n }\n \n+/// @return -1 if error encountered, 1 if capslock active otherwise 0 if not.\n+int capslock_status(void ) {\n+\n+#if defined(__linux__)\n+\n+  FILE *fp = NULL;\n+  char res[1024];\n+  fp = popen(\"xset -q | grep Caps\", \"r\");\n+  if (fp == NULL) {\n+      return -1;\n+  }\n+  fgets(res, sizeof(res), fp);\n+  if (STRNCMP(res + 21, \"on\", 2) == 0) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+\n+#elif defined(WIN32)\n+  if ((GetKeyState(VK_CAPITAL) & 0x0001)!=0) {",
        "comment_created_at": "2018-03-27T12:38:40+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "yes it can be made, just `return (GetKeyState(VK_CAPITAL) & 0x0001)!=0` would be better",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "178654949",
    "pr_number": 8187,
    "pr_file": "src/nvim/os/keyboard.c",
    "created_at": "2018-04-02T21:25:08+00:00",
    "commented_code": "+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if ((uv_dlsym(&xlib, \"XOpenDisplay\", (void **)&_XOpenDisplay)\n+       || uv_dlsym(&xlib, \"XCloseDisplay\", (void **)&_XCloseDisplay)\n+       || uv_dlsym(&xlib, \"XkbGetState\", (void **)&_XkbGetState)) != 0) {\n+    *err = \"Unable to get the functions of X11\";\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps Lock state in linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_init(err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps Lock state in Windows\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_mods_status(Dictionary *const dict, const char **const err )\n+{\n+  int mods = 0;\n+  *err = NULL;\n+  bool status = os_get_locks_status(&mods, err);\n+  if (!status) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "178654949",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "src/nvim/os/keyboard.c",
        "discussion_id": "178654949",
        "commented_code": "@@ -0,0 +1,231 @@\n+// This is an open source non-commercial project. Dear PVS-Studio, please check\n+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include <uv.h>\n+\n+#include \"nvim/api/private/helpers.h\"\n+#include \"nvim/api/private/defs.h\"\n+#include \"nvim/lua/executor.h\"\n+#include \"nvim/vim.h\"\n+#include \"nvim/version.h\"\n+\n+#ifdef __linux__\n+\n+#define XLIB_NAME \"libX11.so.6\"\n+typedef void *_XDisplay;\n+typedef struct {\n+    char data[18];\n+} _XkbStateRec;\n+typedef int _XStatus;\n+\n+enum { kLockedModsOffset = 9 };\n+enum { _XkbUseCoreKbd = 0x0100 };\n+#endif\n+\n+#ifdef WIN32\n+#include <Winuser.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#define Boolean Boolean_I_Dont_Care\n+#include <IOKit/IOKitLib.h>\n+#include <IOKit/IOReturn.h>\n+#include <IOKit/hidsystem/IOHIDLib.h>\n+#include <IOKit/hidsystem/IOHIDParameter.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#undef Boolean\n+#endif\n+\n+enum {\n+    kNumLock = 0x10,\n+    kCapsLock = 0x02,\n+};\n+\n+\n+#if defined(__linux__)\n+static bool xlib_opened = false;\n+static uv_lib_t xlib;\n+static _XDisplay *(*_XOpenDisplay)(void *);\n+static int (*_XCloseDisplay)(_XDisplay *);\n+static _XStatus (*_XkbGetState)(_XDisplay *, unsigned, _XkbStateRec *);\n+\n+/// A helper function to be used to load the libX11 and required functions\n+static bool os_xlib_init(const char **const err)\n+{\n+  if (xlib_opened) {\n+    return true;\n+  }\n+  const int udl_ret = uv_dlopen(XLIB_NAME, &xlib);\n+  if (udl_ret != 0) {\n+    *err = \"Failed to open library libX11\";\n+  } else {\n+    xlib_opened = true;\n+  }\n+\n+  if ((uv_dlsym(&xlib, \"XOpenDisplay\", (void **)&_XOpenDisplay)\n+       || uv_dlsym(&xlib, \"XCloseDisplay\", (void **)&_XCloseDisplay)\n+       || uv_dlsym(&xlib, \"XkbGetState\", (void **)&_XkbGetState)) != 0) {\n+    *err = \"Unable to get the functions of X11\";\n+    return false;\n+  }\n+  return xlib_opened;\n+}\n+\n+/// Get information about Num/Caps Lock state in linux\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+#define CLOSE_DISPLAY(display) \\\n+  do { \\\n+    const int e = _XCloseDisplay(display); \\\n+    if (e) { \\\n+      *err = \"XCloseDisplay unable to close the display\"; \\\n+      return false; \\\n+    } \\\n+  } while (0)\n+  *mods = 0;\n+  *err = NULL;\n+  if (!os_xlib_init(err)) {\n+    return false;\n+  }\n+\n+  _XDisplay *const display = _XOpenDisplay(NULL);\n+  if (display == NULL) {\n+    *err = \"Couldn't open the display\";\n+    return false;\n+  }\n+\n+  _XkbStateRec xkb_state;\n+  const _XStatus status = _XkbGetState(display, _XkbUseCoreKbd, &xkb_state);\n+  if (status) {\n+    *err = \"Non-zero status returned by XkbGetState\";\n+    CLOSE_DISPLAY(display);\n+  }\n+  *mods = xkb_state.data[kLockedModsOffset];\n+\n+  CLOSE_DISPLAY(display);\n+  return true;\n+#undef CLOSE_DISPLAY\n+}\n+\n+#elif defined(WIN32)\n+/// Get information about Num/Caps Lock state in Windows\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *mods = 0;\n+  *err = NULL;\n+  return (GetKeyState(VK_CAPITAL) & 0x0001) != 0;\n+  if (GetKeyState(VK_CAPITAL) & 0x0001) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (GetKeyState(VK_NUMLOCK) & 0x0001) {\n+    *mods = *mods | kNumLock;\n+  }\n+  return true;\n+}\n+\n+#elif defined(__APPLE__)\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in os_mods_status() function.\n+///\n+/// @param[out]  mods  Holds the information about the status of various locks\n+///                    in form of a bitmas\n+///\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+static bool os_get_locks_status(int *const mods, const char **const err)\n+{\n+  *err = NULL;\n+  io_service_t ios;\n+  io_connect_t ioc;\n+  CFMutableDictionaryRef mdict;\n+  bool stateCaps, stateNums;\n+  mdict = IOServiceMatching(kIOHIDSystemClass);\n+  ios = IOServiceGetMatchingService(kIOMasterPortDefault,\n+                                    (CFDictionaryRef)mdict);\n+  if (!ios) {\n+    if (mdict) {\n+      CFRelease(mdict);\n+    }\n+    *err = \"Unable to start service to query data\";\n+    return false;\n+  }\n+\n+  if (IOServiceOpen(ios, mach_task_self(), kIOHIDParamConnectType,\n+                    &ioc) != kIOReturnSuccess) {\n+    IOObjectRelease(ios);\n+    *err = \"Unable to query data\";\n+    return false;\n+  }\n+  IOObjectRelease(ios);\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateCaps) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+\n+  if (IOHIDGetModifierLockState(ioc, kIOHIDCapsLockState,\n+                                &stateNums) != kIOReturnSuccess) {\n+    *err = \"Unable to lock the state\";\n+    return false;\n+  }\n+  if (stateCaps) {\n+    *mods = *mods | kCapsLock;\n+  }\n+  if (stateNums) {\n+    *mods = *mods | kNumLock;\n+  }\n+  IOServiceClose(ioc);\n+  return true;\n+}\n+#endif\n+\n+/// Get information about Num/Caps Lock state in MacOS\n+///\n+/// To be used in nvim_get_keyboard_mods_state() function.\n+///\n+/// @param[out]  dict  Pointer to dictionary where information about modifiers\n+///                    is to be dumped.\n+/// @param[out]  err  Location where error message is to be saved, set to NULL\n+///                   if no error.\n+///\n+/// @return true in case of error, false otherwise.\n+bool os_mods_status(Dictionary *const dict, const char **const err )\n+{\n+  int mods = 0;\n+  *err = NULL;\n+  bool status = os_get_locks_status(&mods, err);\n+  if (!status) {",
        "comment_created_at": "2018-04-02T21:25:08+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "`status` variable may be removed, such code is normally written like `if (!os_get_locks_status(\u2026))`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160038090",
    "pr_number": 34318,
    "pr_file": "src/nvim/drawline.c",
    "created_at": "2025-06-21T13:25:28+00:00",
    "commented_code": "}\n \n         if (wp->w_buffer->terminal) {\n-          wlv.char_attr = hl_combine_attr(term_attrs[wlv.vcol], wlv.char_attr);\n+          wlv.char_attr = hl_combine_attr(TERM_ATTRS_MAX > wlv.vcol ? term_attrs[wlv.vcol] : 0, wlv.char_attr);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2160038090",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34318,
        "pr_file": "src/nvim/drawline.c",
        "discussion_id": "2160038090",
        "commented_code": "@@ -2265,7 +2265,7 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, int col_rows, b\n         }\n \n         if (wp->w_buffer->terminal) {\n-          wlv.char_attr = hl_combine_attr(term_attrs[wlv.vcol], wlv.char_attr);\n+          wlv.char_attr = hl_combine_attr(TERM_ATTRS_MAX > wlv.vcol ? term_attrs[wlv.vcol] : 0, wlv.char_attr);",
        "comment_created_at": "2025-06-21T13:25:28+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "This is a bit hard to read\r\n```suggestion\r\n          wlv.char_attr = hl_combine_attr(wlv.vcol < TERM_ATTRS_MAX ? term_attrs[wlv.vcol] : 0, wlv.char_attr);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2160038649",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34318,
        "pr_file": "src/nvim/drawline.c",
        "discussion_id": "2160038090",
        "commented_code": "@@ -2265,7 +2265,7 @@ int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, int col_rows, b\n         }\n \n         if (wp->w_buffer->terminal) {\n-          wlv.char_attr = hl_combine_attr(term_attrs[wlv.vcol], wlv.char_attr);\n+          wlv.char_attr = hl_combine_attr(TERM_ATTRS_MAX > wlv.vcol ? term_attrs[wlv.vcol] : 0, wlv.char_attr);",
        "comment_created_at": "2025-06-21T13:27:42+00:00",
        "comment_author": "The-Briel-Deal",
        "comment_body": "Thats fair, i'll fix that",
        "pr_file_module": null
      }
    ]
  }
]