[
  {
    "discussion_id": "2170276345",
    "pr_number": 34586,
    "pr_file": "src/nvim/ui_client.c",
    "created_at": "2025-06-26T23:40:30+00:00",
    "commented_code": "(const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2170276345",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-06-26T23:40:30+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "I don't think this postponing is needed. Unlike `:restart` which requires the new server to be started after the old server exits, `:connect` has no such requirements as the new server is already there, so you can just handle the `connect` UI event immediately.",
        "pr_file_module": null
      },
      {
        "comment_id": "2171397435",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-06-27T09:32:20+00:00",
        "comment_author": "justinmk",
        "comment_body": "Side-note: not a blocker for this PR, but need think about how to show an error if this logic fails. E.g. `:connect bogus` currently just exits without saying why.",
        "pr_file_module": null
      },
      {
        "comment_id": "2172016451",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-06-27T13:09:32+00:00",
        "comment_author": "siddhantdev",
        "comment_body": "The problem I encountered when trying to handle `connect` immediately was that the UI client can only connect to one server at a time, so it needs to be detached first. If it first connects and then detaches, the UI just stops, so the connection needs to happen after the channel has closed but before the UI stops, hence the delay.\r\n\r\nSince we want to avoid multiple states, I one way I thought of was to just maintain one value which maintains the state: not pending, restart pending or connect pending and an array which contains the related args. Then instead of two different functions which checks for each possible type, it's managed in one place, `process_pending_events()` or something similar.",
        "pr_file_module": null
      },
      {
        "comment_id": "2172021333",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-06-27T13:12:15+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "> If it first connects and then detaches, the UI just stops\r\n\r\nIf you set the value of `ui_client_channel_id` to the new server after connecting, this shouldn't happen.",
        "pr_file_module": null
      },
      {
        "comment_id": "2193315295",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-07-08T19:42:22+00:00",
        "comment_author": "siddhantdev",
        "comment_body": "I've tried a few different things, but the problem always ends up being this:\r\n\r\nI tried to connect to the new server before pushing the `connect` event and passing along the channel id, but this creates a channel between the current server and the new one, not the UI client and the new server like we want.\r\n\r\nSo, you need to connect to the new server from the UI client. When connecting to the new server from the UI client, `loop_uv_run` (from `src/nvim/event/loop.c`) is called from `channel_connect` (with a few different functions in between).\r\n\r\nIn `loop_uv_run`, there is a condition `if (loop->recursive++)` which gets triggered and aborts the program, causing the crash. The only comment in the if statement states: `Should not re-enter uv_run`.\r\n\r\nI'm not sure what this is protecting against, but when the server connection stuff is done with the postponement, I think the server and ui client get disconnected and then this part of the code is run, so probably it's preventing the ui client from connecting to two different servers. I understand that we want to avoid multiple states as much as possible, but I'm not sure if it's possible here.\r\n\r\nRelevant code:\r\n`loop_uv_run`: https://github.com/neovim/neovim/blob/435f03ee106a548c2e5fd6c10005f5ae2a29a5a4/src/nvim/event/loop.c#L43-L47",
        "pr_file_module": null
      },
      {
        "comment_id": "2193547083",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-07-08T22:36:39+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "Ah, I didn't realize that `channel_connect()` has a timeout. However, in this case you can just use `multiqueue_put()` to schedule the the `channel_connect()` on `main_loop.fast_events` (which allows carrying arguments along with the event), and do not have to wait for the server to disconnect.",
        "pr_file_module": null
      },
      {
        "comment_id": "2197857820",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "src/nvim/ui_client.c",
        "discussion_id": "2170276345",
        "commented_code": "@@ -283,6 +283,62 @@ void ui_client_event_raw_line(GridLineEvent *g)\n                (const schar_T *)grid_line_buf_char, grid_line_buf_attr);\n }\n \n+/// When a \"connect\" UI event is received, its arguments are saved here when\n+/// waiting for the server to exit.\n+static Array connect_args;\n+static bool connect_pending = false;\n+static bool connect_successful = false;\n+\n+void ui_client_event_connect(Array args)\n+{\n+  api_free_array(connect_args);\n+  connect_args = copy_array(args, NULL);\n+  connect_pending = true;\n+}",
        "comment_created_at": "2025-07-10T14:11:39+00:00",
        "comment_author": "siddhantdev",
        "comment_body": "This worked, thanks! There's some issues now with the order of code execution but I should be able to work it out. Specifically, the `detach` / `getout` calls are executed before the `channel_connect` can be reached. This is fine for `detach`, but `getout` stops the ui client before it can connect to the new server.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1525149740",
    "pr_number": 27223,
    "pr_file": "src/nvim/api/tabpage.c",
    "created_at": "2024-03-14T16:12:34+00:00",
    "commented_code": "# include \"api/tabpage.c.generated.h\"\n #endif\n \n+/// Opens a new tabpage with a single window\n+///\n+/// @param buffer   Buffer handle, or 0 for current buffer\n+/// @param enter    Boolean, whether to enter the new tabpage\n+/// @param opts     Optional parameters\n+///  - after: Tabpage handle, open new tabpage after this tabpage.\n+///           Defaults to opening after the current tabpage.\n+/// @param[out] err Error details, if any\n+/// @return Handle to newly created tabpage\n+Tabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Dict(open_tabpage_opts) *opts, Error *err)\n+  FUNC_API_SINCE(12)\n+{\n+  buf_T *buf = find_buffer_by_handle(buffer, err);\n+  if (!buf) {\n+    return 0;\n+  }\n+\n+  int after = 0;\n+  if (HAS_KEY(opts, open_tabpage_opts, after)) {\n+    tabpage_T *tp = find_tab_by_handle((Tabpage)opts->after, err);\n+    if (!tp) {\n+      return 0;\n+    }\n+    // Add 1 to the tabpage index because of tabpage numbering.\n+    // Neglecting to do this will result in the new tabpage being opened\n+    // *before* the specified tabpage.\n+    after = tabpage_index(tp) + 1;\n+  }\n+\n+  tabpage_T *tp = win_new_tabpage(after, buf->b_ffname, enter);\n+\n+  if (!tp) {\n+    api_set_error(err, kErrorTypeException, \"Failed to create tabpage\");\n+    return 0;\n+  }\n+\n+  win_set_buf(tp->tp_firstwin, buf, false, err);\n+\n+  return tp->handle;",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "1525149740",
        "repo_full_name": "neovim/neovim",
        "pr_number": 27223,
        "pr_file": "src/nvim/api/tabpage.c",
        "discussion_id": "1525149740",
        "commented_code": "@@ -14,6 +18,47 @@\n # include \"api/tabpage.c.generated.h\"\n #endif\n \n+/// Opens a new tabpage with a single window\n+///\n+/// @param buffer   Buffer handle, or 0 for current buffer\n+/// @param enter    Boolean, whether to enter the new tabpage\n+/// @param opts     Optional parameters\n+///  - after: Tabpage handle, open new tabpage after this tabpage.\n+///           Defaults to opening after the current tabpage.\n+/// @param[out] err Error details, if any\n+/// @return Handle to newly created tabpage\n+Tabpage nvim_open_tabpage(Buffer buffer, Boolean enter, Dict(open_tabpage_opts) *opts, Error *err)\n+  FUNC_API_SINCE(12)\n+{\n+  buf_T *buf = find_buffer_by_handle(buffer, err);\n+  if (!buf) {\n+    return 0;\n+  }\n+\n+  int after = 0;\n+  if (HAS_KEY(opts, open_tabpage_opts, after)) {\n+    tabpage_T *tp = find_tab_by_handle((Tabpage)opts->after, err);\n+    if (!tp) {\n+      return 0;\n+    }\n+    // Add 1 to the tabpage index because of tabpage numbering.\n+    // Neglecting to do this will result in the new tabpage being opened\n+    // *before* the specified tabpage.\n+    after = tabpage_index(tp) + 1;\n+  }\n+\n+  tabpage_T *tp = win_new_tabpage(after, buf->b_ffname, enter);\n+\n+  if (!tp) {\n+    api_set_error(err, kErrorTypeException, \"Failed to create tabpage\");\n+    return 0;\n+  }\n+\n+  win_set_buf(tp->tp_firstwin, buf, false, err);\n+\n+  return tp->handle;",
        "comment_created_at": "2024-03-14T16:12:34+00:00",
        "comment_author": "seandewar",
        "comment_body": "Autocommands from `win_new_tabpage`, `win_set_buf` have to be considered here:\r\n\r\n- `tp` may have been immediately freed (even `tp->handle` isn't valid in that case).\r\n- `buf` may have been immediately freed.\r\n- `tp->tp_firstwin` may be wrong if `win_new_tabpage` autocommands enter the tabpage and mess with the layout.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2082590069",
    "pr_number": 33919,
    "pr_file": "src/nvim/api/options.c",
    "created_at": "2025-05-09T22:54:41+00:00",
    "commented_code": "}\n \n /// Create a dummy buffer and run the FileType autocmd on it.\n-static buf_T *do_ft_buf(char *filetype, aco_save_T *aco, Error *err)\n+static buf_T *do_ft_buf(const char *filetype, aco_save_T *aco, bool *aco_used, Error *err)\n+  FUNC_ATTR_NONNULL_ARG(2, 3, 4)\n {\n+  *aco_used = false;\n   if (filetype == NULL) {\n     return NULL;\n   }\n+  // Not firing nested FileType autocmds; bail early if one's running.\n+  if (in_filetype_autocmd()) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Cannot detect default while FileType autocommands are running\");",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2082590069",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33919,
        "pr_file": "src/nvim/api/options.c",
        "discussion_id": "2082590069",
        "commented_code": "@@ -101,11 +103,19 @@ static int validate_option_value_args(Dict(option) *opts, char *name, OptIndex *\n }\n \n /// Create a dummy buffer and run the FileType autocmd on it.\n-static buf_T *do_ft_buf(char *filetype, aco_save_T *aco, Error *err)\n+static buf_T *do_ft_buf(const char *filetype, aco_save_T *aco, bool *aco_used, Error *err)\n+  FUNC_ATTR_NONNULL_ARG(2, 3, 4)\n {\n+  *aco_used = false;\n   if (filetype == NULL) {\n     return NULL;\n   }\n+  // Not firing nested FileType autocmds; bail early if one's running.\n+  if (in_filetype_autocmd()) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Cannot detect default while FileType autocommands are running\");",
        "comment_created_at": "2025-05-09T22:54:41+00:00",
        "comment_author": "seandewar",
        "comment_body": "This issue bit me recently. `nvim_get_option_value` sometimes gave incorrect defaults from `LspAttach` when it indirectly ran from `FileType`...\r\n\r\nMaybe some level of recursion can be allowed later, but for now the error is better than silence.",
        "pr_file_module": null
      },
      {
        "comment_id": "2083272221",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33919,
        "pr_file": "src/nvim/api/options.c",
        "discussion_id": "2082590069",
        "commented_code": "@@ -101,11 +103,19 @@ static int validate_option_value_args(Dict(option) *opts, char *name, OptIndex *\n }\n \n /// Create a dummy buffer and run the FileType autocmd on it.\n-static buf_T *do_ft_buf(char *filetype, aco_save_T *aco, Error *err)\n+static buf_T *do_ft_buf(const char *filetype, aco_save_T *aco, bool *aco_used, Error *err)\n+  FUNC_ATTR_NONNULL_ARG(2, 3, 4)\n {\n+  *aco_used = false;\n   if (filetype == NULL) {\n     return NULL;\n   }\n+  // Not firing nested FileType autocmds; bail early if one's running.\n+  if (in_filetype_autocmd()) {\n+    api_set_error(err, kErrorTypeException,\n+                  \"Cannot detect default while FileType autocommands are running\");",
        "comment_created_at": "2025-05-10T19:13:21+00:00",
        "comment_author": "seandewar",
        "comment_body": "After a bit of tinkering, I feel like it's _maybe_ better to just allow it and let the `apply_autocmds_group` nesting check take the wheel. :innocent: ",
        "pr_file_module": null
      }
    ]
  }
]