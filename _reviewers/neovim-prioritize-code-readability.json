[
  {
    "discussion_id": "2234269600",
    "pr_number": 35087,
    "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
    "created_at": "2025-07-28T01:28:51+00:00",
    "commented_code": "local spell, spell_pri_offset = get_spell(capture_name)\n \n+            local is_noconceal = capture_name == 'noconceal'\n+            -- The \"conceal\" attribute can be set at the pattern level or on a particular capture\n+            local conceal_attr = metadata.conceal ~= nil and metadata.conceal\n+              or metadata[capture] and metadata[capture].conceal",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234269600",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35087,
        "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
        "discussion_id": "2234269600",
        "commented_code": "@@ -410,14 +410,28 @@ local function on_line_impl(self, win, buf, line, on_spell, on_conceal)\n \n             local spell, spell_pri_offset = get_spell(capture_name)\n \n+            local is_noconceal = capture_name == 'noconceal'\n+            -- The \"conceal\" attribute can be set at the pattern level or on a particular capture\n+            local conceal_attr = metadata.conceal ~= nil and metadata.conceal\n+              or metadata[capture] and metadata[capture].conceal",
        "comment_created_at": "2025-07-28T01:28:51+00:00",
        "comment_author": "justinmk",
        "comment_body": "this logic looks suspicious. what is the purpose of the `metadata.conceal ~= nil` check, since if `metadata.conceal=false` it will fallthrough to the latter part anyway? also, use parens for clarity, since `a and b or c and d` is not obvious.",
        "pr_file_module": null
      },
      {
        "comment_id": "2234274888",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35087,
        "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
        "discussion_id": "2234269600",
        "commented_code": "@@ -410,14 +410,28 @@ local function on_line_impl(self, win, buf, line, on_spell, on_conceal)\n \n             local spell, spell_pri_offset = get_spell(capture_name)\n \n+            local is_noconceal = capture_name == 'noconceal'\n+            -- The \"conceal\" attribute can be set at the pattern level or on a particular capture\n+            local conceal_attr = metadata.conceal ~= nil and metadata.conceal\n+              or metadata[capture] and metadata[capture].conceal",
        "comment_created_at": "2025-07-28T01:32:42+00:00",
        "comment_author": "PeterCardenas",
        "comment_body": "yea that's it, i can also just create an if statement so that it's abundantly clear:\n\n```lua\nlocal conceal_attr = metadata.conceal\nif conceal_attr == nil then\n  conceal_attr = metadata[capture] and metadata[capture].conceal\nend\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2234342262",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35087,
        "pr_file": "runtime/lua/vim/treesitter/highlighter.lua",
        "discussion_id": "2234269600",
        "commented_code": "@@ -410,14 +410,28 @@ local function on_line_impl(self, win, buf, line, on_spell, on_conceal)\n \n             local spell, spell_pri_offset = get_spell(capture_name)\n \n+            local is_noconceal = capture_name == 'noconceal'\n+            -- The \"conceal\" attribute can be set at the pattern level or on a particular capture\n+            local conceal_attr = metadata.conceal ~= nil and metadata.conceal\n+              or metadata[capture] and metadata[capture].conceal",
        "comment_created_at": "2025-07-28T02:01:16+00:00",
        "comment_author": "justinmk",
        "comment_body": "not asking for an if statement, just parens",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203513647",
    "pr_number": 34140,
    "pr_file": "runtime/plugin/nvim/net.lua",
    "created_at": "2025-07-13T20:24:10+00:00",
    "commented_code": "+vim.g.loaded_remote_file_loader = true\n+\n+--- Callback for BufReadCmd on remote URLs.\n+--- @param args { buf: integer }\n+local function on_remote_read(args)\n+  if vim.fn.executable('curl') ~= 1 then\n+    vim.api.nvim_echo({\n+      { 'Warning: `curl` not found; remote URL loading disabled.', 'WarningMsg' },\n+    }, true, {})\n+    return true\n+  end\n+\n+  local bufnr = args.buf\n+  local url = vim.api.nvim_buf_get_name(bufnr)\n+  local view = vim.fn.winsaveview()\n+\n+  vim.api.nvim_echo({ { 'Fetching ' .. url .. ' \u2026', 'MoreMsg' } }, true, {})",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203513647",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34140,
        "pr_file": "runtime/plugin/nvim/net.lua",
        "discussion_id": "2203513647",
        "commented_code": "@@ -0,0 +1,43 @@\n+vim.g.loaded_remote_file_loader = true\n+\n+--- Callback for BufReadCmd on remote URLs.\n+--- @param args { buf: integer }\n+local function on_remote_read(args)\n+  if vim.fn.executable('curl') ~= 1 then\n+    vim.api.nvim_echo({\n+      { 'Warning: `curl` not found; remote URL loading disabled.', 'WarningMsg' },\n+    }, true, {})\n+    return true\n+  end\n+\n+  local bufnr = args.buf\n+  local url = vim.api.nvim_buf_get_name(bufnr)\n+  local view = vim.fn.winsaveview()\n+\n+  vim.api.nvim_echo({ { 'Fetching ' .. url .. ' \u2026', 'MoreMsg' } }, true, {})",
        "comment_created_at": "2025-07-13T20:24:10+00:00",
        "comment_author": "justinmk",
        "comment_body": "use `('...'):format()` almost always. using `..` to concatenate usually ends up being less readable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "179942943",
    "pr_number": 8187,
    "pr_file": "test/functional/api/vim_spec.lua",
    "created_at": "2018-04-08T10:25:24+00:00",
    "commented_code": "eq(expected, nvim(\"list_uis\"))\n     end)\n   end)\n-\n+  describe('nvim_get_keyboard_mods_state', function()\n+    it('on linux either xlib11 is available or not', function()\n+      if os_name() == 'unix' then\n+        local status, rv = pcall(nvim, \"get_keyboard_mods_state\")\n+        if status == true then",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "179942943",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "test/functional/api/vim_spec.lua",
        "discussion_id": "179942943",
        "commented_code": "@@ -1036,5 +1036,33 @@ describe('api', function()\n       eq(expected, nvim(\"list_uis\"))\n     end)\n   end)\n-\n+  describe('nvim_get_keyboard_mods_state', function()\n+    it('on linux either xlib11 is available or not', function()\n+      if os_name() == 'unix' then\n+        local status, rv = pcall(nvim, \"get_keyboard_mods_state\")\n+        if status == true then",
        "comment_created_at": "2018-04-08T10:25:24+00:00",
        "comment_author": "ZyX-I",
        "comment_body": "Never check boolean variables for equality to something in conditions, they are boolean precisely for them to be put in condition directly.",
        "pr_file_module": null
      },
      {
        "comment_id": "179943400",
        "repo_full_name": "neovim/neovim",
        "pr_number": 8187,
        "pr_file": "test/functional/api/vim_spec.lua",
        "discussion_id": "179942943",
        "commented_code": "@@ -1036,5 +1036,33 @@ describe('api', function()\n       eq(expected, nvim(\"list_uis\"))\n     end)\n   end)\n-\n+  describe('nvim_get_keyboard_mods_state', function()\n+    it('on linux either xlib11 is available or not', function()\n+      if os_name() == 'unix' then\n+        local status, rv = pcall(nvim, \"get_keyboard_mods_state\")\n+        if status == true then",
        "comment_created_at": "2018-04-08T10:44:53+00:00",
        "comment_author": "nimitbhardwaj",
        "comment_body": "OKs\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126956351",
    "pr_number": 34009,
    "pr_file": "runtime/lua/vim/pack.lua",
    "created_at": "2025-06-04T16:01:36+00:00",
    "commented_code": "+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\n%s\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\n%s\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\n\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\n\n' .. table.concat(sources, '\n') .. '\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2126956351",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2126956351",
        "commented_code": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version",
        "comment_created_at": "2025-06-04T16:01:36+00:00",
        "comment_author": "lewis6991",
        "comment_body": "can you break these kinds of decls/assignments. It's not too bad when the RHS are simple expressions (e.g. `0, 0`), but when they are more complex expressions this becomes hard to read. This is especially true if the RHS is a function call since they can return multiple values.",
        "pr_file_module": null
      },
      {
        "comment_id": "2129401858",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2126956351",
        "commented_code": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version",
        "comment_created_at": "2025-06-05T17:11:53+00:00",
        "comment_author": "echasnovski",
        "comment_body": "I opted for separate assignments in most places, except where it felt like simple expressions.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126976540",
    "pr_number": 34009,
    "pr_file": "runtime/lua/vim/pack.lua",
    "created_at": "2025-06-04T16:12:54+00:00",
    "commented_code": "+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\n%s\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\n%s\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\n\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\n\n' .. table.concat(sources, '\n') .. '\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\n\n  ' .. p.job.err:gsub('\n', '\n  ')",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2126976540",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2126976540",
        "commented_code": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')",
        "comment_created_at": "2025-06-04T16:12:54+00:00",
        "comment_author": "lewis6991",
        "comment_body": "If a string has multiple concatenations, best to use `string.format`.\r\n\r\n```suggestion\r\n    return ('## %s\\n\\n %s':format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  ')\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2129407076",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/lua/vim/pack.lua",
        "discussion_id": "2126976540",
        "commented_code": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h \u2502 %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')",
        "comment_created_at": "2025-06-05T17:13:03+00:00",
        "comment_author": "echasnovski",
        "comment_body": "I also opted for consistently using `('text'):format(...)` style instead of `string.format('text', ...)`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2025154848",
    "pr_number": 33274,
    "pr_file": "test/functional/ui/decorations_spec.lua",
    "created_at": "2025-04-02T16:01:52+00:00",
    "commented_code": "]])\n \n     -- When only one highlight group has an underline attribute, it should always take effect.\n-    for _, d in ipairs({-5, 5}) do\n+    for _, d in ipairs({ -5, 5 }) do\n       api.nvim_buf_clear_namespace(0, ns, 0, -1)\n       screen:expect([[\n         aaabbbaa^a                                         |\n         {0:~                                                 }|\n                                                           |\n       ]])\n       api.nvim_buf_set_extmark(0, ns, 0, 0, { end_col = 9, hl_group = 'TestUL', priority = 25 + d })\n-      api.nvim_buf_set_extmark(0, ns, 0, 3, { end_col = 6, hl_group = 'TestBold', priority = 25 - d })\n+      api.nvim_buf_set_extmark(",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2025154848",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33274,
        "pr_file": "test/functional/ui/decorations_spec.lua",
        "discussion_id": "2025154848",
        "commented_code": "@@ -1972,30 +2404,42 @@ describe('extmark decorations', function()\n     ]])\n \n     -- When only one highlight group has an underline attribute, it should always take effect.\n-    for _, d in ipairs({-5, 5}) do\n+    for _, d in ipairs({ -5, 5 }) do\n       api.nvim_buf_clear_namespace(0, ns, 0, -1)\n       screen:expect([[\n         aaabbbaa^a                                         |\n         {0:~                                                 }|\n                                                           |\n       ]])\n       api.nvim_buf_set_extmark(0, ns, 0, 0, { end_col = 9, hl_group = 'TestUL', priority = 25 + d })\n-      api.nvim_buf_set_extmark(0, ns, 0, 3, { end_col = 6, hl_group = 'TestBold', priority = 25 - d })\n+      api.nvim_buf_set_extmark(",
        "comment_created_at": "2025-04-02T16:01:52+00:00",
        "comment_author": "bfredl",
        "comment_body": "As a modest proposal, could we perhaps increase the column threshold from 100 to like 120? \r\n\r\nThis would avoid a lot of _deformatting_ like this. Nothing about this line is different from the line just above. It shouldn't have a completely different style just because a string was one single ASCII byte longer. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2025170708",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33274,
        "pr_file": "test/functional/ui/decorations_spec.lua",
        "discussion_id": "2025154848",
        "commented_code": "@@ -1972,30 +2404,42 @@ describe('extmark decorations', function()\n     ]])\n \n     -- When only one highlight group has an underline attribute, it should always take effect.\n-    for _, d in ipairs({-5, 5}) do\n+    for _, d in ipairs({ -5, 5 }) do\n       api.nvim_buf_clear_namespace(0, ns, 0, -1)\n       screen:expect([[\n         aaabbbaa^a                                         |\n         {0:~                                                 }|\n                                                           |\n       ]])\n       api.nvim_buf_set_extmark(0, ns, 0, 0, { end_col = 9, hl_group = 'TestUL', priority = 25 + d })\n-      api.nvim_buf_set_extmark(0, ns, 0, 3, { end_col = 6, hl_group = 'TestBold', priority = 25 - d })\n+      api.nvim_buf_set_extmark(",
        "comment_created_at": "2025-04-02T16:10:31+00:00",
        "comment_author": "clason",
        "comment_body": "But can we set per-file configs? Otherwise we'd have to increase the line length for all tests (in that subdirectory), which would give churn in the other direction...\r\n\r\n(But may be worth it in the long run.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2025171947",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33274,
        "pr_file": "test/functional/ui/decorations_spec.lua",
        "discussion_id": "2025154848",
        "commented_code": "@@ -1972,30 +2404,42 @@ describe('extmark decorations', function()\n     ]])\n \n     -- When only one highlight group has an underline attribute, it should always take effect.\n-    for _, d in ipairs({-5, 5}) do\n+    for _, d in ipairs({ -5, 5 }) do\n       api.nvim_buf_clear_namespace(0, ns, 0, -1)\n       screen:expect([[\n         aaabbbaa^a                                         |\n         {0:~                                                 }|\n                                                           |\n       ]])\n       api.nvim_buf_set_extmark(0, ns, 0, 0, { end_col = 9, hl_group = 'TestUL', priority = 25 + d })\n-      api.nvim_buf_set_extmark(0, ns, 0, 3, { end_col = 6, hl_group = 'TestBold', priority = 25 - d })\n+      api.nvim_buf_set_extmark(",
        "comment_created_at": "2025-04-02T16:11:16+00:00",
        "comment_author": "clason",
        "comment_body": "Alternatively, we could actively poke Stylua about it; there's still development activity.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072742960",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33274,
        "pr_file": "test/functional/ui/decorations_spec.lua",
        "discussion_id": "2025154848",
        "commented_code": "@@ -1972,30 +2404,42 @@ describe('extmark decorations', function()\n     ]])\n \n     -- When only one highlight group has an underline attribute, it should always take effect.\n-    for _, d in ipairs({-5, 5}) do\n+    for _, d in ipairs({ -5, 5 }) do\n       api.nvim_buf_clear_namespace(0, ns, 0, -1)\n       screen:expect([[\n         aaabbbaa^a                                         |\n         {0:~                                                 }|\n                                                           |\n       ]])\n       api.nvim_buf_set_extmark(0, ns, 0, 0, { end_col = 9, hl_group = 'TestUL', priority = 25 + d })\n-      api.nvim_buf_set_extmark(0, ns, 0, 3, { end_col = 6, hl_group = 'TestBold', priority = 25 - d })\n+      api.nvim_buf_set_extmark(",
        "comment_created_at": "2025-05-04T23:42:50+00:00",
        "comment_author": "justinmk",
        "comment_body": "> As a modest proposal, could we perhaps increase the column threshold from 100 to like 120?\r\n\r\nPushed an update.\r\n\r\nAre we ok with the changes to other test files, or should the 120 width be limited to certain files (idk if that's possible)",
        "pr_file_module": null
      }
    ]
  }
]