[
  {
    "discussion_id": "2234314929",
    "pr_number": 35069,
    "pr_file": "test/functional/core/startup_spec.lua",
    "created_at": "2025-07-28T01:50:05+00:00",
    "commented_code": "})\n       -- current directory exrc is found first\n       screen:expect({ any = '.nvim.lua' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('ia')\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('iv')\n \n       -- after that the exrc in the parent directory\n-      screen:expect({ any = '.exrc' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('a')\n+      screen:expect({ any = '.exrc', unchanged = true })\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('v')\n+\n+      -- trust .exrc\n+      feed(':trust<CR>')\n+      screen:expect({ any = 'Allowed' })\n+      screen:expect({ any = '.exrc', unchanged = true })",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234314929",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35069,
        "pr_file": "test/functional/core/startup_spec.lua",
        "discussion_id": "2234314929",
        "commented_code": "@@ -1249,13 +1251,38 @@ describe('user config init', function()\n       })\n       -- current directory exrc is found first\n       screen:expect({ any = '.nvim.lua' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('ia')\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('iv')\n \n       -- after that the exrc in the parent directory\n-      screen:expect({ any = '.exrc' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('a')\n+      screen:expect({ any = '.exrc', unchanged = true })\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('v')\n+\n+      -- trust .exrc\n+      feed(':trust<CR>')\n+      screen:expect({ any = 'Allowed' })\n+      screen:expect({ any = '.exrc', unchanged = true })",
        "comment_created_at": "2025-07-28T01:50:05+00:00",
        "comment_author": "justinmk",
        "comment_body": "this is the same screen, isn't it? just use a multiline pattern to match the contents of 1 screen, instead of multiple expect() with `unchanged=true`.\n\nsame for the other cases below.\n\n```suggestion\n      screen:expect({ any = 'Allowed.*\\n.exrc' })\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2234731010",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35069,
        "pr_file": "test/functional/core/startup_spec.lua",
        "discussion_id": "2234314929",
        "commented_code": "@@ -1249,13 +1251,38 @@ describe('user config init', function()\n       })\n       -- current directory exrc is found first\n       screen:expect({ any = '.nvim.lua' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('ia')\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('iv')\n \n       -- after that the exrc in the parent directory\n-      screen:expect({ any = '.exrc' })\n-      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny, (a)llow:'), unchanged = true })\n-      feed('a')\n+      screen:expect({ any = '.exrc', unchanged = true })\n+      screen:expect({ any = pesc('[i]gnore, (v)iew, (d)eny:'), unchanged = true })\n+      feed('v')\n+\n+      -- trust .exrc\n+      feed(':trust<CR>')\n+      screen:expect({ any = 'Allowed' })\n+      screen:expect({ any = '.exrc', unchanged = true })",
        "comment_created_at": "2025-07-28T05:23:06+00:00",
        "comment_author": "nyngwang",
        "comment_body": "Thank you. My original code is indeed a bad workaround for a pattern matching issue related to line-wrapping. I ended up increasing the screen width to avoid the sequence [`|`,`\\n`,`|`] being inserted into any/both of the critical parts of the two filepaths we're interested in here, i.e. `\".*/.exrc\"`, `\".*/.nvim.lua\"`. As I realized that `.*` is capturing a runtime path which can be of any length.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234334231",
    "pr_number": 35069,
    "pr_file": "test/functional/lua/secure_spec.lua",
    "created_at": "2025-07-28T01:58:16+00:00",
    "commented_code": "{2:{MATCH: +}}|\n         :lua vim.secure.read('Xfile'){MATCH: +}|\n         {3:]] .. msg .. [[}{MATCH: +}|\n-        {3:[i]gnore, (v)iew, (d)eny, (a)llow: }^{MATCH: +}|\n+        {3:[i]gnore, (v)iew, (d)eny: }^{MATCH: +}|\n       ]])\n-      feed('a')\n+      feed('v')\n+      feed(':trust<CR>')\n       screen:expect([[\n-        ^{MATCH: +}|\n-        {1:~{MATCH: +}}|*6\n+        ^let g:foobar = 42{MATCH: +}|\n+        {1:~{MATCH: +}}|*2",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234334231",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35069,
        "pr_file": "test/functional/lua/secure_spec.lua",
        "discussion_id": "2234334231",
        "commented_code": "@@ -91,14 +93,21 @@ describe('vim.secure', function()\n         {2:{MATCH: +}}|\n         :lua vim.secure.read('Xfile'){MATCH: +}|\n         {3:]] .. msg .. [[}{MATCH: +}|\n-        {3:[i]gnore, (v)iew, (d)eny, (a)llow: }^{MATCH: +}|\n+        {3:[i]gnore, (v)iew, (d)eny: }^{MATCH: +}|\n       ]])\n-      feed('a')\n+      feed('v')\n+      feed(':trust<CR>')\n       screen:expect([[\n-        ^{MATCH: +}|\n-        {1:~{MATCH: +}}|*6\n+        ^let g:foobar = 42{MATCH: +}|\n+        {1:~{MATCH: +}}|*2",
        "comment_created_at": "2025-07-28T01:58:16+00:00",
        "comment_author": "justinmk",
        "comment_body": "When the literal contents are known we usually don't use match. It tends to be more readable to write the literal contents, e.g. in this case it would look like (I think):\n\n    {1:~                          }|*2",
        "pr_file_module": null
      },
      {
        "comment_id": "2234711166",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35069,
        "pr_file": "test/functional/lua/secure_spec.lua",
        "discussion_id": "2234334231",
        "commented_code": "@@ -91,14 +93,21 @@ describe('vim.secure', function()\n         {2:{MATCH: +}}|\n         :lua vim.secure.read('Xfile'){MATCH: +}|\n         {3:]] .. msg .. [[}{MATCH: +}|\n-        {3:[i]gnore, (v)iew, (d)eny, (a)llow: }^{MATCH: +}|\n+        {3:[i]gnore, (v)iew, (d)eny: }^{MATCH: +}|\n       ]])\n-      feed('a')\n+      feed('v')\n+      feed(':trust<CR>')\n       screen:expect([[\n-        ^{MATCH: +}|\n-        {1:~{MATCH: +}}|*6\n+        ^let g:foobar = 42{MATCH: +}|\n+        {1:~{MATCH: +}}|*2",
        "comment_created_at": "2025-07-28T05:08:21+00:00",
        "comment_author": "nyngwang",
        "comment_body": "Could we skip this, since on line 39 they set screen width to `500`:\r\n\r\n```lua\r\n25    before_each(function()\r\n...\r\n39      screen = Screen.new(500, 8)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2234713584",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35069,
        "pr_file": "test/functional/lua/secure_spec.lua",
        "discussion_id": "2234334231",
        "commented_code": "@@ -91,14 +93,21 @@ describe('vim.secure', function()\n         {2:{MATCH: +}}|\n         :lua vim.secure.read('Xfile'){MATCH: +}|\n         {3:]] .. msg .. [[}{MATCH: +}|\n-        {3:[i]gnore, (v)iew, (d)eny, (a)llow: }^{MATCH: +}|\n+        {3:[i]gnore, (v)iew, (d)eny: }^{MATCH: +}|\n       ]])\n-      feed('a')\n+      feed('v')\n+      feed(':trust<CR>')\n       screen:expect([[\n-        ^{MATCH: +}|\n-        {1:~{MATCH: +}}|*6\n+        ^let g:foobar = 42{MATCH: +}|\n+        {1:~{MATCH: +}}|*2",
        "comment_created_at": "2025-07-28T05:10:34+00:00",
        "comment_author": "justinmk",
        "comment_body": "oh, yeah that makes sense.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234626945",
    "pr_number": 34586,
    "pr_file": "test/functional/terminal/tui_spec.lua",
    "created_at": "2025-07-28T04:17:21+00:00",
    "commented_code": "end)\n end)\n \n+describe('TUI :connect', function()\n+  if is_os('win') then\n+    -- :connect relies on :detach which currently doesn't work on windows\n+    return\n+  end\n+\n+  it('requires an argument', function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234626945",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34586,
        "pr_file": "test/functional/terminal/tui_spec.lua",
        "discussion_id": "2234626945",
        "commented_code": "@@ -320,6 +320,128 @@ describe('TUI :restart', function()\n   end)\n end)\n \n+describe('TUI :connect', function()\n+  if is_os('win') then\n+    -- :connect relies on :detach which currently doesn't work on windows\n+    return\n+  end\n+\n+  it('requires an argument', function()",
        "comment_created_at": "2025-07-28T04:17:21+00:00",
        "comment_author": "justinmk",
        "comment_body": "test is too verbose just to check that a commmand requires an argument. that only requires ~2 lines to check. also rename this to: \n```suggestion\n  it('validation', function()\n```\n\nthen we can add more validation later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2116060549",
    "pr_number": 34014,
    "pr_file": "test/functional/lua/diagnostic_spec.lua",
    "created_at": "2025-05-30T14:42:12+00:00",
    "commented_code": "eq(true, exec_lua('return _G.jumped'))\n       end)\n     end)\n+\n+    it('finds next diagnostic at a logical location after text changes before', function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2116060549",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2116060549",
        "commented_code": "@@ -1430,6 +1430,94 @@ describe('vim.diagnostic', function()\n         eq(true, exec_lua('return _G.jumped'))\n       end)\n     end)\n+\n+    it('finds next diagnostic at a logical location after text changes before', function()",
        "comment_created_at": "2025-05-30T14:42:12+00:00",
        "comment_author": "justinmk",
        "comment_body": "is it possible for these tests to re-use a shared function, to make them less verbose?\r\n\r\nindirection can make things harder to read, but if these tests are mostly doing the same kind of thing, then using a shared function can be much more readable because it makes it obvious what is being tested in each case.",
        "pr_file_module": null
      },
      {
        "comment_id": "2117257309",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2116060549",
        "commented_code": "@@ -1430,6 +1430,94 @@ describe('vim.diagnostic', function()\n         eq(true, exec_lua('return _G.jumped'))\n       end)\n     end)\n+\n+    it('finds next diagnostic at a logical location after text changes before', function()",
        "comment_created_at": "2025-05-31T04:50:46+00:00",
        "comment_author": "faergeek",
        "comment_body": "reused it via `describe` + `before_each`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143128112",
    "pr_number": 34014,
    "pr_file": "test/functional/lua/diagnostic_spec.lua",
    "created_at": "2025-06-12T15:58:36+00:00",
    "commented_code": "end)\n       )\n     end)\n+\n+    it('shows diagnostics at their logical locations after text changes before', function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2143128112",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2143128112",
        "commented_code": "@@ -3478,6 +3549,88 @@ describe('vim.diagnostic', function()\n         end)\n       )\n     end)\n+\n+    it('shows diagnostics at their logical locations after text changes before', function()",
        "comment_created_at": "2025-06-12T15:58:36+00:00",
        "comment_author": "justinmk",
        "comment_body": "are we actually testing anything here or is this just redundantly testing the existing behavior  of extmarks?\r\n\r\nis there a less verbose way to instead (1) assert that extmarks are mapped as expected to a diagnostic, and (2) just assume that extmarks work they way they should?\r\n\r\nsame question for all the other tests.",
        "pr_file_module": null
      },
      {
        "comment_id": "2144284245",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34014,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2143128112",
        "commented_code": "@@ -3478,6 +3549,88 @@ describe('vim.diagnostic', function()\n         end)\n       )\n     end)\n+\n+    it('shows diagnostics at their logical locations after text changes before', function()",
        "comment_created_at": "2025-06-13T06:17:56+00:00",
        "comment_author": "faergeek",
        "comment_body": ">redundantly testing the existing behavior of extmarks?\r\n\r\nIn a sense, yes. But just setting extmarks isn't the whole story. If we only check that we set extmarks correctly, we can revert all the changes where they are being used and tests will still happily pass, confirming basically nothing. These tests are more useful to confirm the behavior end to end. They confirm that extmark positions are not only set correctly, but also used to find diagnostics to show them in a floating window or jump between them. For these use cases I don't really see any reason to care that this behavior is implemented using extmarks. That's why extmarks are not mentioned in the tests right now.\r\n\r\nThese extmarks are not really visible to the user in any way except through API. And testing the behavior the user most likely cares about seems to be more useful than testing an implementation detail, which is only exposed to the user by accident, just because all the extmarks can be easily retrieved by the user through API, no matter what, as far as I'm aware.\r\n\r\nBut these are just my opinions and I only occasionally contribute and don't maintain the project. So the final decision is not going to be mine anyway.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203166372",
    "pr_number": 33723,
    "pr_file": "test/functional/lua/diagnostic_spec.lua",
    "created_at": "2025-07-13T05:43:07+00:00",
    "commented_code": "end)\n   end)\n \n+  describe('status', function()\n+    it('returns empty string if no diagnostics', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, _G.diagnostic_bufnr, {})\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, '')\n+    end)\n+\n+    it('returns count for each diagnostic kind', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, 0, {\n+          _G.make_error('Error 1', 0, 1, 0, 1),\n+\n+          _G.make_warning('Warning 1', 2, 2, 2, 2),\n+          _G.make_warning('Warning 2', 2, 2, 2, 2),\n+\n+          _G.make_info('Info 1', 3, 3, 3, 3),\n+          _G.make_info('Info 2', 3, 3, 3, 3),\n+          _G.make_info('Info 3', 3, 3, 3, 3),\n+\n+          _G.make_hint('Hint 1', 4, 4, 4, 4),\n+          _G.make_hint('Hint 2', 4, 4, 4, 4),\n+          _G.make_hint('Hint 3', 4, 4, 4, 4),\n+          _G.make_hint('Hint 4', 4, 4, 4, 4),\n+        })\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, 'E:1 W:2 I:3 H:4')\n+    end)\n+\n+    it('does not return diagnostics for non current buffers', function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203166372",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2203166372",
        "commented_code": "@@ -3766,6 +3766,85 @@ describe('vim.diagnostic', function()\n     end)\n   end)\n \n+  describe('status', function()\n+    it('returns empty string if no diagnostics', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, _G.diagnostic_bufnr, {})\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, '')\n+    end)\n+\n+    it('returns count for each diagnostic kind', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, 0, {\n+          _G.make_error('Error 1', 0, 1, 0, 1),\n+\n+          _G.make_warning('Warning 1', 2, 2, 2, 2),\n+          _G.make_warning('Warning 2', 2, 2, 2, 2),\n+\n+          _G.make_info('Info 1', 3, 3, 3, 3),\n+          _G.make_info('Info 2', 3, 3, 3, 3),\n+          _G.make_info('Info 3', 3, 3, 3, 3),\n+\n+          _G.make_hint('Hint 1', 4, 4, 4, 4),\n+          _G.make_hint('Hint 2', 4, 4, 4, 4),\n+          _G.make_hint('Hint 3', 4, 4, 4, 4),\n+          _G.make_hint('Hint 4', 4, 4, 4, 4),\n+        })\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, 'E:1 W:2 I:3 H:4')\n+    end)\n+\n+    it('does not return diagnostics for non current buffers', function()",
        "comment_created_at": "2025-07-13T05:43:07+00:00",
        "comment_author": "justinmk",
        "comment_body": "instead of a separate test for this case, let's just add an extra step to the end of the one above, something like `enew` followed by `eq('', exec_lua(return vim.diagnostic.status()`.\n\nthat saves 20 lines of code, which is valuable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203166422",
    "pr_number": 33723,
    "pr_file": "test/functional/lua/diagnostic_spec.lua",
    "created_at": "2025-07-13T05:43:34+00:00",
    "commented_code": "end)\n   end)\n \n+  describe('status', function()\n+    it('returns empty string if no diagnostics', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, _G.diagnostic_bufnr, {})\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, '')\n+    end)\n+\n+    it('returns count for each diagnostic kind', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, 0, {\n+          _G.make_error('Error 1', 0, 1, 0, 1),\n+\n+          _G.make_warning('Warning 1', 2, 2, 2, 2),\n+          _G.make_warning('Warning 2', 2, 2, 2, 2),\n+\n+          _G.make_info('Info 1', 3, 3, 3, 3),\n+          _G.make_info('Info 2', 3, 3, 3, 3),\n+          _G.make_info('Info 3', 3, 3, 3, 3),\n+\n+          _G.make_hint('Hint 1', 4, 4, 4, 4),\n+          _G.make_hint('Hint 2', 4, 4, 4, 4),\n+          _G.make_hint('Hint 3', 4, 4, 4, 4),\n+          _G.make_hint('Hint 4', 4, 4, 4, 4),\n+        })\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, 'E:1 W:2 I:3 H:4')",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203166422",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33723,
        "pr_file": "test/functional/lua/diagnostic_spec.lua",
        "discussion_id": "2203166422",
        "commented_code": "@@ -3766,6 +3766,85 @@ describe('vim.diagnostic', function()\n     end)\n   end)\n \n+  describe('status', function()\n+    it('returns empty string if no diagnostics', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, _G.diagnostic_bufnr, {})\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, '')\n+    end)\n+\n+    it('returns count for each diagnostic kind', function()\n+      local result = exec_lua(function()\n+        vim.diagnostic.set(_G.diagnostic_ns, 0, {\n+          _G.make_error('Error 1', 0, 1, 0, 1),\n+\n+          _G.make_warning('Warning 1', 2, 2, 2, 2),\n+          _G.make_warning('Warning 2', 2, 2, 2, 2),\n+\n+          _G.make_info('Info 1', 3, 3, 3, 3),\n+          _G.make_info('Info 2', 3, 3, 3, 3),\n+          _G.make_info('Info 3', 3, 3, 3, 3),\n+\n+          _G.make_hint('Hint 1', 4, 4, 4, 4),\n+          _G.make_hint('Hint 2', 4, 4, 4, 4),\n+          _G.make_hint('Hint 3', 4, 4, 4, 4),\n+          _G.make_hint('Hint 4', 4, 4, 4, 4),\n+        })\n+        return vim.diagnostic.status()\n+      end)\n+\n+      eq(result, 'E:1 W:2 I:3 H:4')",
        "comment_created_at": "2025-07-13T05:43:34+00:00",
        "comment_author": "justinmk",
        "comment_body": "note: the args are flipped :) `eq()` takes the \"expected\" value as the first arg.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164124842",
    "pr_number": 34491,
    "pr_file": "test/functional/legacy/prompt_buffer_spec.lua",
    "created_at": "2025-06-24T14:07:08+00:00",
    "commented_code": "{1:~                        }|*3\n       {5:-- INSERT --}             |\n     ]])\n+\n+    -- newline created with o/O is reflected in nvim_getinput\n+    feed('asdf<esc>o<esc>')\n+    eq('asdf\n', fn('prompt_getinput', buf))\n+    feed('kO')\n+    eq('\nasdf\n', fn('prompt_getinput', buf))",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2164124842",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "test/functional/legacy/prompt_buffer_spec.lua",
        "discussion_id": "2164124842",
        "commented_code": "@@ -477,6 +497,12 @@ describe('prompt buffer', function()\n       {1:~                        }|*3\n       {5:-- INSERT --}             |\n     ]])\n+\n+    -- newline created with o/O is reflected in nvim_getinput\n+    feed('asdf<esc>o<esc>')\n+    eq('asdf\\n', fn('prompt_getinput', buf))\n+    feed('kO')\n+    eq('\\nasdf\\n', fn('prompt_getinput', buf))",
        "comment_created_at": "2025-06-24T14:07:08+00:00",
        "comment_author": "justinmk",
        "comment_body": "the earlier lines in this test already make edits (and are more readable than \"asdf\"). wouldn't it make sense just to add `prompt_getinput` assertions after those screen tests, instead of peforming new edits here ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2164398768",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "test/functional/legacy/prompt_buffer_spec.lua",
        "discussion_id": "2164124842",
        "commented_code": "@@ -477,6 +497,12 @@ describe('prompt buffer', function()\n       {1:~                        }|*3\n       {5:-- INSERT --}             |\n     ]])\n+\n+    -- newline created with o/O is reflected in nvim_getinput\n+    feed('asdf<esc>o<esc>')\n+    eq('asdf\\n', fn('prompt_getinput', buf))\n+    feed('kO')\n+    eq('\\nasdf\\n', fn('prompt_getinput', buf))",
        "comment_created_at": "2025-06-24T16:01:27+00:00",
        "comment_author": "shadmansaleh",
        "comment_body": "good idea.",
        "pr_file_module": null
      }
    ]
  }
]