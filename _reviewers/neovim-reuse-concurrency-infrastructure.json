[
  {
    "discussion_id": "2184175563",
    "pr_number": 33972,
    "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
    "created_at": "2025-07-04T02:46:50+00:00",
    "commented_code": "+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class vim.lsp.inline_completion.State\n+---@field items lsp.InlineCompletionItem[]\n+---@field current integer index of currently active completion item\n+---@field extmark integer id of the currently visible extmark\n+---@field autocmd integer id of the autocmd\n+\n+---@type table<integer, vim.lsp.inline_completion.State?>\n+local bufstates = {}\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+local augroup = api.nvim_create_augroup('nvim.lsp.inline_completion', {})\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+local function clear(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  api.nvim_del_autocmd(bufstate.autocmd)\n+  bufstates[bufnr] = nil\n+end\n+\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+---@type lsp.MultiHandler\n+local function handler(results, ctx)\n+  local items = {}\n+  for _, result in pairs(results) do\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        table.insert(items, item)\n+      end\n+    end\n+  end\n+\n+  if #items == 0 then\n+    return\n+  end\n+  local bufnr = assert(ctx.bufnr)\n+  bufstates[bufnr] = {\n+    items = items,\n+    current = 1,\n+    extmark = set_extmark(bufnr, items[1]),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      group = augroup,\n+      buffer = bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        clear(bufnr)\n+      end,\n+    }),\n+  }\n+end\n+\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+local function request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,\n+    }\n+  end, handler)\n+end\n+\n+---@class vim.lsp.inline_completion.JumpOpts\n+---@inlinedoc\n+---\n+---(default: current)\n+---@field bufnr? integer\n+---\n+---(default: 1)\n+---@field count? integer\n+---\n+---(default: true)\n+---@field wrap? boolean\n+\n+---@param opts vim.lsp.inline_completion.JumpOpts\n+function M.jump(opts)\n+  opts = opts or {}\n+  local bufnr = vim._resolve_bufnr(opts.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  local count = opts.count or 1\n+  local wrap = opts.wrap or true\n+\n+  local items = bufstate.items\n+  local active = bufstate.current + count\n+  active = wrap and (active - 1) % #items + 1 or math.min(math.max(1, active), #items)\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  bufstate.extmark = set_extmark(bufnr, items[active], (' (%d/%d)'):format(active, #items))\n+  bufstate.current = active\n+end\n+\n+---@param bufnr? integer\n+function M.trigger(bufnr)\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then -- Trigger\n+    ---@type lsp.InlineCompletionContext\n+    local context = { triggerKind = 1 }\n+    request(bufnr, context)\n+  else -- Accept\n+    local item = bufstate.items[bufstate.current]\n+    local text = item.insertText\n+    local range = item.range\n+    if type(text) ~= 'string' then\n+      vim.snippet.expand(text.value)\n+    elseif range then\n+      util.apply_text_edits({ { newText = text, range = range } }, bufnr, 'utf-16')\n+    end\n+    clear(bufnr)\n+  end\n+end\n+\n+---@generic T: function\n+---@param f T\n+---@param timeout integer\n+---@return T\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        if timer then\n+          vim.uv.timer_stop(timer)\n+          timer:close()\n+          timer = nil\n+        end\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+---@param bufnr integer\n+local function automatic_request(bufnr)\n+  request(bufnr, { triggerKind = 2 })\n+end\n+\n+---(default: true)\n+---@param enable? boolean\n+---\n+---(default: current)\n+---@param bufnr? integer\n+function M.enable(enable, bufnr)\n+  enable = enable == nil or enable\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local debounced_request = debunce(automatic_request, 100)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2184175563",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33972,
        "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
        "discussion_id": "2184175563",
        "commented_code": "@@ -0,0 +1,243 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class vim.lsp.inline_completion.State\n+---@field items lsp.InlineCompletionItem[]\n+---@field current integer index of currently active completion item\n+---@field extmark integer id of the currently visible extmark\n+---@field autocmd integer id of the autocmd\n+\n+---@type table<integer, vim.lsp.inline_completion.State?>\n+local bufstates = {}\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+local augroup = api.nvim_create_augroup('nvim.lsp.inline_completion', {})\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+local function clear(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  api.nvim_del_autocmd(bufstate.autocmd)\n+  bufstates[bufnr] = nil\n+end\n+\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+---@type lsp.MultiHandler\n+local function handler(results, ctx)\n+  local items = {}\n+  for _, result in pairs(results) do\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        table.insert(items, item)\n+      end\n+    end\n+  end\n+\n+  if #items == 0 then\n+    return\n+  end\n+  local bufnr = assert(ctx.bufnr)\n+  bufstates[bufnr] = {\n+    items = items,\n+    current = 1,\n+    extmark = set_extmark(bufnr, items[1]),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      group = augroup,\n+      buffer = bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        clear(bufnr)\n+      end,\n+    }),\n+  }\n+end\n+\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+local function request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,\n+    }\n+  end, handler)\n+end\n+\n+---@class vim.lsp.inline_completion.JumpOpts\n+---@inlinedoc\n+---\n+---(default: current)\n+---@field bufnr? integer\n+---\n+---(default: 1)\n+---@field count? integer\n+---\n+---(default: true)\n+---@field wrap? boolean\n+\n+---@param opts vim.lsp.inline_completion.JumpOpts\n+function M.jump(opts)\n+  opts = opts or {}\n+  local bufnr = vim._resolve_bufnr(opts.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  local count = opts.count or 1\n+  local wrap = opts.wrap or true\n+\n+  local items = bufstate.items\n+  local active = bufstate.current + count\n+  active = wrap and (active - 1) % #items + 1 or math.min(math.max(1, active), #items)\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  bufstate.extmark = set_extmark(bufnr, items[active], (' (%d/%d)'):format(active, #items))\n+  bufstate.current = active\n+end\n+\n+---@param bufnr? integer\n+function M.trigger(bufnr)\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then -- Trigger\n+    ---@type lsp.InlineCompletionContext\n+    local context = { triggerKind = 1 }\n+    request(bufnr, context)\n+  else -- Accept\n+    local item = bufstate.items[bufstate.current]\n+    local text = item.insertText\n+    local range = item.range\n+    if type(text) ~= 'string' then\n+      vim.snippet.expand(text.value)\n+    elseif range then\n+      util.apply_text_edits({ { newText = text, range = range } }, bufnr, 'utf-16')\n+    end\n+    clear(bufnr)\n+  end\n+end\n+\n+---@generic T: function\n+---@param f T\n+---@param timeout integer\n+---@return T\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        if timer then\n+          vim.uv.timer_stop(timer)\n+          timer:close()\n+          timer = nil\n+        end\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+---@param bufnr integer\n+local function automatic_request(bufnr)\n+  request(bufnr, { triggerKind = 2 })\n+end\n+\n+---(default: true)\n+---@param enable? boolean\n+---\n+---(default: current)\n+---@param bufnr? integer\n+function M.enable(enable, bufnr)\n+  enable = enable == nil or enable\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local debounced_request = debunce(automatic_request, 100)",
        "comment_created_at": "2025-07-04T02:46:50+00:00",
        "comment_author": "luozhiya",
        "comment_body": "We already have `next_debounce` infrastructure in `lsp/_changetracking.lua`. Can we reuse this part of the code?\r\n \r\nRef: `client.flags.debounce_text_changes`",
        "pr_file_module": null
      },
      {
        "comment_id": "2188127049",
        "repo_full_name": "neovim/neovim",
        "pr_number": 33972,
        "pr_file": "runtime/lua/vim/lsp/inline_completion.lua",
        "discussion_id": "2184175563",
        "commented_code": "@@ -0,0 +1,243 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local grammar = require('vim.lsp._snippet_grammar')\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class vim.lsp.inline_completion.State\n+---@field items lsp.InlineCompletionItem[]\n+---@field current integer index of currently active completion item\n+---@field extmark integer id of the currently visible extmark\n+---@field autocmd integer id of the autocmd\n+\n+---@type table<integer, vim.lsp.inline_completion.State?>\n+local bufstates = {}\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.inline_completion')\n+local augroup = api.nvim_create_augroup('nvim.lsp.inline_completion', {})\n+\n+--- Longest common prefix\n+---@param a string\n+---@param b string\n+---@return integer index where the common prefix ends, exclusive\n+local function lcp(a, b)\n+  local i = 1\n+  while a:sub(i, i) == b:sub(i, i) do\n+    i = i + 1\n+  end\n+  return i\n+end\n+\n+---@param bufnr integer\n+---@param item lsp.InlineCompletionItem\n+---@param suffix? string\n+local function set_extmark(bufnr, item, suffix)\n+  ---@type integer, integer\n+  local line, col\n+\n+  if item.range then\n+    line = item.range['start'].line\n+    col = item.range['start'].character\n+  else\n+    local winid = vim.fn.bufwinid(bufnr)\n+    local pos = api.nvim_win_get_cursor(winid)\n+    line = pos[1] - 1\n+    col = pos[2]\n+  end\n+\n+  local text = item.insertText\n+  if type(text) ~= 'string' then\n+    text = tostring(grammar.parse(text.value))\n+  end\n+\n+  ---@type [string, string][][]\n+  local lines = {}\n+  for s in vim.gsplit(text, '\\n') do\n+    table.insert(lines, { { s, 'LspInlineCompletion' } })\n+  end\n+  if suffix then\n+    table.insert(lines[#lines], { suffix, 'LspInlineCompletionSuffix' })\n+  end\n+\n+  local virt_text = lines[1]\n+  local virt_lines = { select(2, unpack(lines)) }\n+  local skip =\n+    lcp(api.nvim_buf_get_lines(bufnr, line, line + 1, true)[1]:sub(col + 1), virt_text[1][1])\n+  virt_text[1][1] = virt_text[1][1]:sub(skip)\n+  return api.nvim_buf_set_extmark(bufnr, namespace, line, col + skip - 1, {\n+    virt_text = virt_text,\n+    virt_lines = virt_lines,\n+    virt_text_pos = 'overlay',\n+  })\n+end\n+\n+local function clear(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  api.nvim_del_autocmd(bufstate.autocmd)\n+  bufstates[bufnr] = nil\n+end\n+\n+---@param results table<integer, { err: lsp.ResponseError?, result: lsp.InlineCompletionItem[]|lsp.InlineCompletionList? }>\n+---@type lsp.MultiHandler\n+local function handler(results, ctx)\n+  local items = {}\n+  for _, result in pairs(results) do\n+    if result.err then\n+      log.error(result.err)\n+    elseif result.result then\n+      for _, item in ipairs(result.result.items or result.result) do\n+        table.insert(items, item)\n+      end\n+    end\n+  end\n+\n+  if #items == 0 then\n+    return\n+  end\n+  local bufnr = assert(ctx.bufnr)\n+  bufstates[bufnr] = {\n+    items = items,\n+    current = 1,\n+    extmark = set_extmark(bufnr, items[1]),\n+    autocmd = api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+      group = augroup,\n+      buffer = bufnr,\n+      desc = 'Clean up candidate inline completion items',\n+      callback = function()\n+        clear(bufnr)\n+      end,\n+    }),\n+  }\n+end\n+\n+---@param bufnr integer\n+---@param context? lsp.InlineCompletionContext\n+local function request(bufnr, context)\n+  context = context or { triggerKind = 2 }\n+\n+  vim.lsp.buf_request_all(bufnr, ms.textDocument_inlineCompletion, function(client)\n+    ---@type lsp.InlineCompletionParams\n+    return {\n+      context = context,\n+      textDocument = util.make_text_document_params(bufnr),\n+      position = util.make_position_params(nil, client.offset_encoding).position,\n+    }\n+  end, handler)\n+end\n+\n+---@class vim.lsp.inline_completion.JumpOpts\n+---@inlinedoc\n+---\n+---(default: current)\n+---@field bufnr? integer\n+---\n+---(default: 1)\n+---@field count? integer\n+---\n+---(default: true)\n+---@field wrap? boolean\n+\n+---@param opts vim.lsp.inline_completion.JumpOpts\n+function M.jump(opts)\n+  opts = opts or {}\n+  local bufnr = vim._resolve_bufnr(opts.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  local count = opts.count or 1\n+  local wrap = opts.wrap or true\n+\n+  local items = bufstate.items\n+  local active = bufstate.current + count\n+  active = wrap and (active - 1) % #items + 1 or math.min(math.max(1, active), #items)\n+  api.nvim_buf_del_extmark(bufnr, namespace, bufstate.extmark)\n+  bufstate.extmark = set_extmark(bufnr, items[active], (' (%d/%d)'):format(active, #items))\n+  bufstate.current = active\n+end\n+\n+---@param bufnr? integer\n+function M.trigger(bufnr)\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then -- Trigger\n+    ---@type lsp.InlineCompletionContext\n+    local context = { triggerKind = 1 }\n+    request(bufnr, context)\n+  else -- Accept\n+    local item = bufstate.items[bufstate.current]\n+    local text = item.insertText\n+    local range = item.range\n+    if type(text) ~= 'string' then\n+      vim.snippet.expand(text.value)\n+    elseif range then\n+      util.apply_text_edits({ { newText = text, range = range } }, bufnr, 'utf-16')\n+    end\n+    clear(bufnr)\n+  end\n+end\n+\n+---@generic T: function\n+---@param f T\n+---@param timeout integer\n+---@return T\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        if timer then\n+          vim.uv.timer_stop(timer)\n+          timer:close()\n+          timer = nil\n+        end\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+---@param bufnr integer\n+local function automatic_request(bufnr)\n+  request(bufnr, { triggerKind = 2 })\n+end\n+\n+---(default: true)\n+---@param enable? boolean\n+---\n+---(default: current)\n+---@param bufnr? integer\n+function M.enable(enable, bufnr)\n+  enable = enable == nil or enable\n+  bufnr = vim._resolve_bufnr(bufnr)\n+  local debounced_request = debunce(automatic_request, 100)",
        "comment_created_at": "2025-07-06T09:17:20+00:00",
        "comment_author": "ofseed",
        "comment_body": "Many other places in various LSP modules also require debouncing, most of which are to prevent a large number of requests caused by users frequently changing the text. I will keep an eye on this issue, but for now, I prefer to refactor it in a subsequent PR.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2144875812",
    "pr_number": 34473,
    "pr_file": "runtime/lua/vim/async.lua",
    "created_at": "2025-06-13T11:24:37+00:00",
    "commented_code": "+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2144875812",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T11:24:37+00:00",
        "comment_author": "clason",
        "comment_body": "Not necessarily in scope for this PR, but would it make sense to provide `vim.async.system` as a convenience object? I suspect that many consumers will want such a wrapper.",
        "pr_file_module": null
      },
      {
        "comment_id": "2144981108",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T12:22:51+00:00",
        "comment_author": "justinmk",
        "comment_body": "could that be a flag on `vim.system` ? want to avoid teaching people to reach for similar things in different places. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2144988808",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T12:26:52+00:00",
        "comment_author": "clason",
        "comment_body": "No, that would be recursive. I also think that the \"for async, look in `vim.async`\" is better for discoverability -- this also avoids spreading out the `async` module over unrelated modules.\r\n\r\n(But the comment was mainly motivated by removing boilerplate and less by the naming.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2145028882",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T12:51:15+00:00",
        "comment_author": "lewis6991",
        "comment_body": "Users can currently just do:\r\n\r\n```lua\r\nlocal obj = vim.async.await(3, vim.system, cmd, opts)\r\n```\r\n\r\nand/or\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nlocal async_system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nI think it's important that the signature of `vim.system()` stays the same and that It can continue to work properly without `vim.async`.\r\n\r\nIf we do want a convenience wrapper like:\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nvim.async.system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nThen do we also want `vim.async.uv.*` for `vim.uv.*` just like https://github.com/nvim-neotest/nvim-nio/blob/master/lua/nio/uv.lua",
        "pr_file_module": null
      },
      {
        "comment_id": "2145046508",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T13:01:30+00:00",
        "comment_author": "clason",
        "comment_body": "If it's just a one-liner, then we don't need to provide a wrapper and it's enough to give the example in the docs. (The current example made it look much more complicated, but that seems to have been my misreading.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2145050781",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34473,
        "pr_file": "runtime/lua/vim/async.lua",
        "discussion_id": "2144875812",
        "commented_code": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
        "comment_created_at": "2025-06-13T13:04:11+00:00",
        "comment_author": "lewis6991",
        "comment_body": "I think this example is an AI hallucination \ud83d\ude48 . Lines 44-49 are bogus",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141953068",
    "pr_number": 34277,
    "pr_file": "runtime/lua/vim/_helptags.lua",
    "created_at": "2025-06-12T07:43:19+00:00",
    "commented_code": "+local M = {}\n+\n+local ts = vim.treesitter\n+local query = ts.query.parse('vimdoc', '(tag (word) @tagname)')\n+\n+--- @alias TagLocation { [1]: string, [2]: string, [3]: string}[] tuple of tag, file, and search command\n+\n+--- Find all helptags in a single file.\n+---\n+--- @param filename string helpfile with tags\n+--- @return TagLocation[] # empty if file is not readable\n+local function extract_file_tags(filename)\n+  local f, err = io.open(filename, 'r')\n+  if f == nil or err then\n+    vim.notify(('E153: Unable to open %s for reading'):format(filename), vim.log.levels.ERROR)\n+    return {}\n+  end\n+  local source = f:read('*a')\n+  f:close()\n+  local fn = vim.fs.basename(filename)\n+\n+  local tags = {}\n+  local tree = ts.get_string_parser(source, 'vimdoc'):parse()[1]:root()\n+\n+  for _, match in query:iter_matches(tree, source) do\n+    for id, node in pairs(match) do\n+      if query.captures[id] == 'tagname' then\n+        local tagname = ts.get_node_text(node[1], source)\n+        local escaped = tagname:gsub('[\\\\/]', '\\\\%0')\n+        local searchcmd = '/*' .. escaped .. '*'\n+        table.insert(tags, { tagname, fn, searchcmd })\n+      end\n+    end\n+  end\n+\n+  return tags\n+end\n+\n+--- Report duplicate tags.\n+---\n+--- @param tags TagLocation[]\n+--- @return boolean # true if there are duplicate tags\n+local function duplicate_tags(tags)\n+  local found = false\n+  local prevtag, prevfn\n+  for _, tag in ipairs(tags) do\n+    local curtag, curfn, _ = unpack(tag)\n+    if curtag == prevtag then\n+      found = true\n+      local other_fn = prevfn ~= curfn and (' and ' .. prevfn) or ''\n+      vim.notify(\n+        ('E154: Duplicate tag \"%s\" in %s%s'):format(curtag, curfn, other_fn),\n+        vim.log.levels.WARN\n+      )\n+    end\n+    prevtag = curtag\n+    prevfn = curfn\n+  end\n+  return found\n+end\n+\n+--- Extract tags from a list of helpfiles.\n+---\n+--- @param helpfiles string[] list of helpfiles\n+--- @param tagsfile string the filename of the 'tags' file\n+--- @param include_helptags_tag boolean true if the 'tags' tag should be included\n+local function create_tags_from_files(helpfiles, tagsfile, include_helptags_tag)\n+  ---@type TagLocation\n+  local tags = {}\n+  local i = 1\n+  local function process_helpfile(co)\n+    if i > #helpfiles then\n+      coroutine.resume(co, true)\n+      return\n+    end\n+\n+    local filename = helpfiles[i]\n+    i = i + 1\n+\n+    vim.schedule(function()\n+      local filetags = extract_file_tags(filename)\n+      vim.list_extend(tags, filetags)\n+      process_helpfile(co)\n+    end)\n+  end\n+\n+  coroutine.wrap(function()",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2141953068",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34277,
        "pr_file": "runtime/lua/vim/_helptags.lua",
        "discussion_id": "2141953068",
        "commented_code": "@@ -0,0 +1,164 @@\n+local M = {}\n+\n+local ts = vim.treesitter\n+local query = ts.query.parse('vimdoc', '(tag (word) @tagname)')\n+\n+--- @alias TagLocation { [1]: string, [2]: string, [3]: string}[] tuple of tag, file, and search command\n+\n+--- Find all helptags in a single file.\n+---\n+--- @param filename string helpfile with tags\n+--- @return TagLocation[] # empty if file is not readable\n+local function extract_file_tags(filename)\n+  local f, err = io.open(filename, 'r')\n+  if f == nil or err then\n+    vim.notify(('E153: Unable to open %s for reading'):format(filename), vim.log.levels.ERROR)\n+    return {}\n+  end\n+  local source = f:read('*a')\n+  f:close()\n+  local fn = vim.fs.basename(filename)\n+\n+  local tags = {}\n+  local tree = ts.get_string_parser(source, 'vimdoc'):parse()[1]:root()\n+\n+  for _, match in query:iter_matches(tree, source) do\n+    for id, node in pairs(match) do\n+      if query.captures[id] == 'tagname' then\n+        local tagname = ts.get_node_text(node[1], source)\n+        local escaped = tagname:gsub('[\\\\/]', '\\\\%0')\n+        local searchcmd = '/*' .. escaped .. '*'\n+        table.insert(tags, { tagname, fn, searchcmd })\n+      end\n+    end\n+  end\n+\n+  return tags\n+end\n+\n+--- Report duplicate tags.\n+---\n+--- @param tags TagLocation[]\n+--- @return boolean # true if there are duplicate tags\n+local function duplicate_tags(tags)\n+  local found = false\n+  local prevtag, prevfn\n+  for _, tag in ipairs(tags) do\n+    local curtag, curfn, _ = unpack(tag)\n+    if curtag == prevtag then\n+      found = true\n+      local other_fn = prevfn ~= curfn and (' and ' .. prevfn) or ''\n+      vim.notify(\n+        ('E154: Duplicate tag \"%s\" in %s%s'):format(curtag, curfn, other_fn),\n+        vim.log.levels.WARN\n+      )\n+    end\n+    prevtag = curtag\n+    prevfn = curfn\n+  end\n+  return found\n+end\n+\n+--- Extract tags from a list of helpfiles.\n+---\n+--- @param helpfiles string[] list of helpfiles\n+--- @param tagsfile string the filename of the 'tags' file\n+--- @param include_helptags_tag boolean true if the 'tags' tag should be included\n+local function create_tags_from_files(helpfiles, tagsfile, include_helptags_tag)\n+  ---@type TagLocation\n+  local tags = {}\n+  local i = 1\n+  local function process_helpfile(co)\n+    if i > #helpfiles then\n+      coroutine.resume(co, true)\n+      return\n+    end\n+\n+    local filename = helpfiles[i]\n+    i = i + 1\n+\n+    vim.schedule(function()\n+      local filetags = extract_file_tags(filename)\n+      vim.list_extend(tags, filetags)\n+      process_helpfile(co)\n+    end)\n+  end\n+\n+  coroutine.wrap(function()",
        "comment_created_at": "2025-06-12T07:43:19+00:00",
        "comment_author": "clason",
        "comment_body": "I don't think we should add manual async at this point since we're already considering a `vim.async` module based on @lewis6991 work. Please look at #34009 and https://github.com/lewis6991/async.nvim, and pull in whatever you need from that into a `vim._async` module (that we'll merge with the one from #34009).",
        "pr_file_module": null
      },
      {
        "comment_id": "2142062094",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34277,
        "pr_file": "runtime/lua/vim/_helptags.lua",
        "discussion_id": "2141953068",
        "commented_code": "@@ -0,0 +1,164 @@\n+local M = {}\n+\n+local ts = vim.treesitter\n+local query = ts.query.parse('vimdoc', '(tag (word) @tagname)')\n+\n+--- @alias TagLocation { [1]: string, [2]: string, [3]: string}[] tuple of tag, file, and search command\n+\n+--- Find all helptags in a single file.\n+---\n+--- @param filename string helpfile with tags\n+--- @return TagLocation[] # empty if file is not readable\n+local function extract_file_tags(filename)\n+  local f, err = io.open(filename, 'r')\n+  if f == nil or err then\n+    vim.notify(('E153: Unable to open %s for reading'):format(filename), vim.log.levels.ERROR)\n+    return {}\n+  end\n+  local source = f:read('*a')\n+  f:close()\n+  local fn = vim.fs.basename(filename)\n+\n+  local tags = {}\n+  local tree = ts.get_string_parser(source, 'vimdoc'):parse()[1]:root()\n+\n+  for _, match in query:iter_matches(tree, source) do\n+    for id, node in pairs(match) do\n+      if query.captures[id] == 'tagname' then\n+        local tagname = ts.get_node_text(node[1], source)\n+        local escaped = tagname:gsub('[\\\\/]', '\\\\%0')\n+        local searchcmd = '/*' .. escaped .. '*'\n+        table.insert(tags, { tagname, fn, searchcmd })\n+      end\n+    end\n+  end\n+\n+  return tags\n+end\n+\n+--- Report duplicate tags.\n+---\n+--- @param tags TagLocation[]\n+--- @return boolean # true if there are duplicate tags\n+local function duplicate_tags(tags)\n+  local found = false\n+  local prevtag, prevfn\n+  for _, tag in ipairs(tags) do\n+    local curtag, curfn, _ = unpack(tag)\n+    if curtag == prevtag then\n+      found = true\n+      local other_fn = prevfn ~= curfn and (' and ' .. prevfn) or ''\n+      vim.notify(\n+        ('E154: Duplicate tag \"%s\" in %s%s'):format(curtag, curfn, other_fn),\n+        vim.log.levels.WARN\n+      )\n+    end\n+    prevtag = curtag\n+    prevfn = curfn\n+  end\n+  return found\n+end\n+\n+--- Extract tags from a list of helpfiles.\n+---\n+--- @param helpfiles string[] list of helpfiles\n+--- @param tagsfile string the filename of the 'tags' file\n+--- @param include_helptags_tag boolean true if the 'tags' tag should be included\n+local function create_tags_from_files(helpfiles, tagsfile, include_helptags_tag)\n+  ---@type TagLocation\n+  local tags = {}\n+  local i = 1\n+  local function process_helpfile(co)\n+    if i > #helpfiles then\n+      coroutine.resume(co, true)\n+      return\n+    end\n+\n+    local filename = helpfiles[i]\n+    i = i + 1\n+\n+    vim.schedule(function()\n+      local filetags = extract_file_tags(filename)\n+      vim.list_extend(tags, filetags)\n+      process_helpfile(co)\n+    end)\n+  end\n+\n+  coroutine.wrap(function()",
        "comment_created_at": "2025-06-12T08:34:06+00:00",
        "comment_author": "yochem",
        "comment_body": "Ah yes I indeed knew about the efforts for creating a vim.async module, but thought I wouldn't be a able to make use of them here. For now, I'll just pull in the vim._async module from the vim.pack PR",
        "pr_file_module": null
      },
      {
        "comment_id": "2142097491",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34277,
        "pr_file": "runtime/lua/vim/_helptags.lua",
        "discussion_id": "2141953068",
        "commented_code": "@@ -0,0 +1,164 @@\n+local M = {}\n+\n+local ts = vim.treesitter\n+local query = ts.query.parse('vimdoc', '(tag (word) @tagname)')\n+\n+--- @alias TagLocation { [1]: string, [2]: string, [3]: string}[] tuple of tag, file, and search command\n+\n+--- Find all helptags in a single file.\n+---\n+--- @param filename string helpfile with tags\n+--- @return TagLocation[] # empty if file is not readable\n+local function extract_file_tags(filename)\n+  local f, err = io.open(filename, 'r')\n+  if f == nil or err then\n+    vim.notify(('E153: Unable to open %s for reading'):format(filename), vim.log.levels.ERROR)\n+    return {}\n+  end\n+  local source = f:read('*a')\n+  f:close()\n+  local fn = vim.fs.basename(filename)\n+\n+  local tags = {}\n+  local tree = ts.get_string_parser(source, 'vimdoc'):parse()[1]:root()\n+\n+  for _, match in query:iter_matches(tree, source) do\n+    for id, node in pairs(match) do\n+      if query.captures[id] == 'tagname' then\n+        local tagname = ts.get_node_text(node[1], source)\n+        local escaped = tagname:gsub('[\\\\/]', '\\\\%0')\n+        local searchcmd = '/*' .. escaped .. '*'\n+        table.insert(tags, { tagname, fn, searchcmd })\n+      end\n+    end\n+  end\n+\n+  return tags\n+end\n+\n+--- Report duplicate tags.\n+---\n+--- @param tags TagLocation[]\n+--- @return boolean # true if there are duplicate tags\n+local function duplicate_tags(tags)\n+  local found = false\n+  local prevtag, prevfn\n+  for _, tag in ipairs(tags) do\n+    local curtag, curfn, _ = unpack(tag)\n+    if curtag == prevtag then\n+      found = true\n+      local other_fn = prevfn ~= curfn and (' and ' .. prevfn) or ''\n+      vim.notify(\n+        ('E154: Duplicate tag \"%s\" in %s%s'):format(curtag, curfn, other_fn),\n+        vim.log.levels.WARN\n+      )\n+    end\n+    prevtag = curtag\n+    prevfn = curfn\n+  end\n+  return found\n+end\n+\n+--- Extract tags from a list of helpfiles.\n+---\n+--- @param helpfiles string[] list of helpfiles\n+--- @param tagsfile string the filename of the 'tags' file\n+--- @param include_helptags_tag boolean true if the 'tags' tag should be included\n+local function create_tags_from_files(helpfiles, tagsfile, include_helptags_tag)\n+  ---@type TagLocation\n+  local tags = {}\n+  local i = 1\n+  local function process_helpfile(co)\n+    if i > #helpfiles then\n+      coroutine.resume(co, true)\n+      return\n+    end\n+\n+    local filename = helpfiles[i]\n+    i = i + 1\n+\n+    vim.schedule(function()\n+      local filetags = extract_file_tags(filename)\n+      vim.list_extend(tags, filetags)\n+      process_helpfile(co)\n+    end)\n+  end\n+\n+  coroutine.wrap(function()",
        "comment_created_at": "2025-06-12T08:53:14+00:00",
        "comment_author": "lewis6991",
        "comment_body": "The potential of `vim.async` shouldn't restrict the use of coroutines. `vim.async` is just a very generalized layer on top of coroutines, but if the requirements are small (like) here, then I don't see a problem with using coroutines. I still think coroutines are important for generator functions (functions that return iterators).\r\n\r\nThe usage here is contained within ~30LOC, if anything this is might be preferable to using `vim.async`.\r\n\r\nThough I'm not quite sure why coroutines are being used here (needs a comment). It looks like it's to not eat up the main loop, in which case `vim.async` + `uv.fs_open` might help in the future.\r\n\r\nWhat is the effect if no coroutines where used here? Does creating tags from helpfiles cause lots of lag or something?",
        "pr_file_module": null
      },
      {
        "comment_id": "2142135454",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34277,
        "pr_file": "runtime/lua/vim/_helptags.lua",
        "discussion_id": "2141953068",
        "commented_code": "@@ -0,0 +1,164 @@\n+local M = {}\n+\n+local ts = vim.treesitter\n+local query = ts.query.parse('vimdoc', '(tag (word) @tagname)')\n+\n+--- @alias TagLocation { [1]: string, [2]: string, [3]: string}[] tuple of tag, file, and search command\n+\n+--- Find all helptags in a single file.\n+---\n+--- @param filename string helpfile with tags\n+--- @return TagLocation[] # empty if file is not readable\n+local function extract_file_tags(filename)\n+  local f, err = io.open(filename, 'r')\n+  if f == nil or err then\n+    vim.notify(('E153: Unable to open %s for reading'):format(filename), vim.log.levels.ERROR)\n+    return {}\n+  end\n+  local source = f:read('*a')\n+  f:close()\n+  local fn = vim.fs.basename(filename)\n+\n+  local tags = {}\n+  local tree = ts.get_string_parser(source, 'vimdoc'):parse()[1]:root()\n+\n+  for _, match in query:iter_matches(tree, source) do\n+    for id, node in pairs(match) do\n+      if query.captures[id] == 'tagname' then\n+        local tagname = ts.get_node_text(node[1], source)\n+        local escaped = tagname:gsub('[\\\\/]', '\\\\%0')\n+        local searchcmd = '/*' .. escaped .. '*'\n+        table.insert(tags, { tagname, fn, searchcmd })\n+      end\n+    end\n+  end\n+\n+  return tags\n+end\n+\n+--- Report duplicate tags.\n+---\n+--- @param tags TagLocation[]\n+--- @return boolean # true if there are duplicate tags\n+local function duplicate_tags(tags)\n+  local found = false\n+  local prevtag, prevfn\n+  for _, tag in ipairs(tags) do\n+    local curtag, curfn, _ = unpack(tag)\n+    if curtag == prevtag then\n+      found = true\n+      local other_fn = prevfn ~= curfn and (' and ' .. prevfn) or ''\n+      vim.notify(\n+        ('E154: Duplicate tag \"%s\" in %s%s'):format(curtag, curfn, other_fn),\n+        vim.log.levels.WARN\n+      )\n+    end\n+    prevtag = curtag\n+    prevfn = curfn\n+  end\n+  return found\n+end\n+\n+--- Extract tags from a list of helpfiles.\n+---\n+--- @param helpfiles string[] list of helpfiles\n+--- @param tagsfile string the filename of the 'tags' file\n+--- @param include_helptags_tag boolean true if the 'tags' tag should be included\n+local function create_tags_from_files(helpfiles, tagsfile, include_helptags_tag)\n+  ---@type TagLocation\n+  local tags = {}\n+  local i = 1\n+  local function process_helpfile(co)\n+    if i > #helpfiles then\n+      coroutine.resume(co, true)\n+      return\n+    end\n+\n+    local filename = helpfiles[i]\n+    i = i + 1\n+\n+    vim.schedule(function()\n+      local filetags = extract_file_tags(filename)\n+      vim.list_extend(tags, filetags)\n+      process_helpfile(co)\n+    end)\n+  end\n+\n+  coroutine.wrap(function()",
        "comment_created_at": "2025-06-12T09:12:37+00:00",
        "comment_author": "yochem",
        "comment_body": "I noticed it blocked the editor (~2 secs for the runtimedir). Although maybe vim.schedule will be enough for this. \n\nI added coroutines because I was looking for parallelization, as extracting tags for every file is a task that can be parallelized very efficiently. But I learned that coroutines all run on a single thread and file reads are blocking. Still, this implementation felt 'snappier' and faster to me than the fully sync approach. I'll try vim.schedule (+ uv.fs_open)",
        "pr_file_module": null
      }
    ]
  }
]