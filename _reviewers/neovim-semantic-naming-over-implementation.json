[
  {
    "discussion_id": "2174716003",
    "pr_number": 34523,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-06-30T10:08:50+00:00",
    "commented_code": "\u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2174716003",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-06-30T10:08:50+00:00",
        "comment_author": "justinmk",
        "comment_body": "is there an `on_foo` name we can use? same for the others. \r\n```suggestion\r\ndeclaration({opts}, {on_result})                    *vim.lsp.buf.declaration()*\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2175602462",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-06-30T17:50:52+00:00",
        "comment_author": "MariaSolOs",
        "comment_body": "I think `callback` feels better as `result` does have a \"positive\" connotation, but this callback should always be invoked regardless of the request completing successfully or not.",
        "pr_file_module": null
      },
      {
        "comment_id": "2188325717",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-06T14:06:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "All of the callbacks in this pr need some sort of `on_` prefix (`:help dev-naming`). We use \"callback\" way too much. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2188343417",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-06T14:19:11+00:00",
        "comment_author": "lewis6991",
        "comment_body": "`callback` is usually a continuation and is the async version of `return`, not the same as registering callbacks for events. `on_` isn't necessary for continuations.\n\n> We use \"callback\" way too much.\n\nI don't understand this. What is \"too much\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198412801",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T18:28:24+00:00",
        "comment_author": "justinmk",
        "comment_body": "> `on_` isn't necessary for continuations.\r\n\r\nIt is much easier to communicate one invariant rule rather than multiple, subjective rules. `on_x` tends to result in much more meaningful names, while also avoiding over-use of `callback`.\r\n\r\n> What is \"too much\"?\r\n\r\n`callback` and `cb` are used in places where an `on_x` name would be more useful and intuitive. And then people see that and just do even more of it. That is why it matters: people copy what existing code is doing, so isolated decisions spread out and multiply.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198801147",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:36:23+00:00",
        "comment_author": "lewis6991",
        "comment_body": "> It is much easier to communicate one invariant rule rather than multiple, subjective rules.\n\n`callback` for continuations and `on_` for (potentially repeatable) events isn't a subjective rule.\n\n> on_x tends to result in much more meaningful names, while also avoiding over-use of callback.\n\nI disagree, and can just as well say `on_*` is overused and leads lots of variations of the same name: `on_exit`, `on_done`, `on_finished`, `on_result`, `on_complete` all mean the same thing and can all be replaced with `callback` which is a much more standard name. It's also not obvious these names are callbacks... unlike `callback`, which translates across domains.\n\n> And then people see that and just do even more of it.\n\nI noticed despite how much `on_x` has been pushed in this project, it hasn't been used more. People naturally lean towards `callback`.\n\nHappy to change `cb` -> `callback`, but the `on_x` thing just seems like a specific thing you are over pushing for everything and seems to come directly from js. It works ok for things like the decoration provider and buf attach, but for most other things `callback` works better and easier to understand because it is so common.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198811882",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:42:57+00:00",
        "comment_author": "justinmk",
        "comment_body": "> leads lots of variations of the same name: `on_exit`, `on_done`, `on_finished`, `on_result`, `on_complet`\r\n\r\nIf those are the same then they should align on one name.\r\n\r\n> It's also not obvious these names are callbacks... unlike `callback`.\r\n\r\nWhat happens when there is more than one callback? Then you need a qualifier anyway. So having a common prefix is extra helpful in that case.\r\n\r\nAnything prefixed with `on_` is a callback, I don't see how that is unclear.\r\n\r\n> but the `on_x` thing just seems like a specific thing you are over pushing for everything and seems to come directly from js. \r\n\r\nNo, this decision was made after experience from early days of the project where `_cb` prefix was used. `on_` is much more readable and conventional. You made a wrong assumption/speculation here.\r\n\r\nIt's a project guideline, and continually objecting to project guidelines is really not helpful. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2198816023",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:46:17+00:00",
        "comment_author": "lewis6991",
        "comment_body": "\n > What happens when there is more than one callback?\n\nThen it's not a continuation.\n\n> Anything prefixed with on_ is a callback, I don't see how that is unclear.\n\nMaybe if you're used to js.\n\n> on_ is much more readable and conventional.\n\nI've already explained why it isn't\n\n> It's a project guideline, and continually objecting to project guidelines is really not helpful.\n\nYou treat them like biblical texts, despite you writing most of them. Guidelines should be able to be questioned and changed at any time as projects evolve.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198820132",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:49:13+00:00",
        "comment_author": "justinmk",
        "comment_body": "> > What happens when there is more than one callback?\r\n> \r\n> Then it's not a continuation.\r\n\r\nA continuation is just a special case. And naming it differently leads to confusion and debates, which is exactly what I'm trying to avoid.\r\n\r\nMany people are just going to copy `callback` even when it's not a \"continuation\" or whatever other specific circumstances. A blanket rule is easier to follow and document.\r\n\r\n> Maybe if you're used to js.\r\n\r\nIt could be named `abc_` for all I care, what matters is that it's a common consistent prefix instead of a different subjective choice everywhere. \r\n\r\nIf it's hard for you to adapt to `on_` then you'll appreciate that it's even harder to document and learn when different kinds of callbacks/handlers should be named in which way in various contexts.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198821781",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:50:33+00:00",
        "comment_author": "lewis6991",
        "comment_body": "> A continuation is just a special case. And naming it differently leads to confusion and debates, which is exactly what I'm trying to avoid.\n\nArguably it's the most common case.\n\n> Many people are just going to copy callback even when it's not a \"continuation\" or whatever other specific circumstances. A blanket rule is easier to follow and document.\n\nMost of the time that will be fine, and people will understand it. If there are multiple events then `on_` can be switched to.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198828266",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:54:12+00:00",
        "comment_author": "justinmk",
        "comment_body": "> If there are multiple events then `on_` can be switched to.\r\n\r\nNot if it's a field, like in the case of `nvim_create_autocmd({callback=...})` which is a case where `on_x` was clearly more meaningful and readable.\r\n\r\nAnd \"we'll just do it differently here and there\" is what I'm trying to avoid.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198831512",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T21:56:31+00:00",
        "comment_author": "mfussenegger",
        "comment_body": "For what's worth, +1 for `on_` from my side.\r\n\r\nThere's already:\r\n\r\n```\r\n                                                        *dev-name-events*\r\nUse the \"on_\" prefix to name event-handling callbacks and also the interface for\r\n\"registering\" such handlers (on_key). The dual nature is acceptable to avoid\r\na confused collection of naming conventions for these related concepts.\r\n```\r\n\r\nThis fits here as well, not sure why we'd special case continuation cases. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2198843083",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-10T22:02:12+00:00",
        "comment_author": "lewis6991",
        "comment_body": "> This fits here as well, not sure why we'd special case continuation cases.\n\n`callback` fits better here, and does in most places and is a much more common and understood name. There's a reason people use it, and I don't think it's because we already use `callback` for autocmds. I've been reading about a lot of different structured concurrency frameworks and they all seem to use this, except js which coincidentally seems to have one the worst frameworks.\n\n> There's already:\n\nI know, Justin added it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2199100924",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-11T00:38:35+00:00",
        "comment_author": "justinmk",
        "comment_body": "I added it because we had no guidelines and we have things named `handler`, `callback`, `x_cb`, `on_x`, and more (js uses \"listener\" btw). What's your point? I get criticized when there are no guidelines, and when there are...\r\n\r\nHow about this compromise:\r\n\r\n- `callback` for continuations (exactly one callback param, not multiple [like uv.new_work](https://github.com/neovim/neovim/blob/4745270bf124a960ccdffdddbb6c27b7bf36ba82/runtime/doc/luvref.txt#L3600) for example),\r\n- `on_x` for everything else\r\n\r\nand we can commit to this (no debates about special cases or personal preferences in the future)? Then I will update the docs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2199869957",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-11T07:19:43+00:00",
        "comment_author": "lewis6991",
        "comment_body": "sgtm.\n\nFor the `new_work` case, `after_work_callback` is the continuation and `work_callback` is the work and is quite special because it runs with its own Lua state. So you could have `work` and `callback` as arguments for it to follow the rule. We don't own those anyway, and fwiw I would accept `on_` there if we could think of appropriate names.",
        "pr_file_module": null
      },
      {
        "comment_id": "2200005915",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-11T08:17:15+00:00",
        "comment_author": "mfussenegger",
        "comment_body": "> callback fits better here, and does in most places and is a much more common and understood name. There's a reason people use it, and I don't think it's because we already use callback for autocmds\r\n\r\nConclusory language?\r\nYes, callback is useful to describe the concept of a higher-order function used as parameter to signal something back to the original caller. `on_` naming is useful to clarify _when_ or _what_ it is that is signaled. E.g. I'd still describe a `on_list` as a callback, but that doesn't mean that the parameter needs to be named `callback`. Similar how not every table needs to be called `table`, but can communicate the contents.\r\n\r\n> callback for continuations\r\n\r\nIsn't that to some degree up to the call-site if a callback is used for continuation or not? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2200227173",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2174716003",
        "commented_code": "@@ -1689,21 +1689,25 @@ code_action({opts})                                *vim.lsp.buf.code_action()*\n       \u2022 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n       \u2022 vim.lsp.protocol.CodeActionTriggerKind\n \n-declaration({opts})                                *vim.lsp.buf.declaration()*\n+declaration({opts}, {callback})                    *vim.lsp.buf.declaration()*",
        "comment_created_at": "2025-07-11T09:35:30+00:00",
        "comment_author": "lewis6991",
        "comment_body": "> Isn't that to some degree up to the call-site if a callback is used for continuation or not?\n\nA continuation strictly always needs to be called to signal the asynchronous `return` of a function. And ideally the first argument that is passed back is an `err` argument to avoid erroring on the main thread. This is especially important for anything that supports cancellation.\n\nNot using the continuation is equivalent to ignoring the return arguments of a function. The way I see it is we don't have contextual names for `return`, or any other language construct, and async functions are a construct we are adding on top.\n\n`vim.async` will also further emphasise the term of callback-functions (not to be confused with async functions), so mixing in `on_` makes that less coherent. callback-functions have a `callback`, normal/async functions have `return`.\n\nFor these reasons `on_list` should be deprecated and replaced with `callback` which includes an `err` argument.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2199229323",
    "pr_number": 34523,
    "pr_file": "runtime/doc/lsp.txt",
    "created_at": "2025-07-11T01:14:07+00:00",
    "commented_code": "<\n \n     Parameters: ~\n-      \u2022 {config}  (`vim.lsp.buf.signature_help.Opts?`) See\n-                  |vim.lsp.buf.signature_help.Opts|.\n+      \u2022 {config}    (`vim.lsp.buf.signature_help.Opts?`) See\n+                    |vim.lsp.buf.signature_help.Opts|.\n+      \u2022 {callback}  (`fun(errors: lsp.ResponseError[])?`) Function called\n+                    after the request is completed.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2199229323",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34523,
        "pr_file": "runtime/doc/lsp.txt",
        "discussion_id": "2199229323",
        "commented_code": "@@ -1856,14 +1872,18 @@ signature_help({config})                        *vim.lsp.buf.signature_help()*\n <\n \n     Parameters: ~\n-      \u2022 {config}  (`vim.lsp.buf.signature_help.Opts?`) See\n-                  |vim.lsp.buf.signature_help.Opts|.\n+      \u2022 {config}    (`vim.lsp.buf.signature_help.Opts?`) See\n+                    |vim.lsp.buf.signature_help.Opts|.\n+      \u2022 {callback}  (`fun(errors: lsp.ResponseError[])?`) Function called\n+                    after the request is completed.",
        "comment_created_at": "2025-07-11T01:14:07+00:00",
        "comment_author": "justinmk",
        "comment_body": "`on_response` sure would be more meaningful here. Instead the docs have to explain it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172098892",
    "pr_number": 34140,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2025-06-27T13:54:06+00:00",
    "commented_code": "(`string[]`)\n \n \n+==============================================================================\n+Lua module: vim.net                                                  *vim.net*\n+\n+vim.net.request({url}, {opts}, {on_exit})                  *vim.net.request()*\n+    Makes an HTTP GET request to the given URL. Can either return the body or\n+    save it to a file.\n+\n+    Parameters: ~\n+      \u2022 {url}      (`string`) The URL to fetch.\n+      \u2022 {opts}     (`table?`) Optional parameters:\n+                   \u2022 verbose (boolean|nil): Enables curl verbose output.\n+                   \u2022 retry (integer|nil): Number of retries on transient\n+                     failures (default: 3).\n+                   \u2022 output (string|nil): If set, path to save response body\n+                     instead of returning it.\n+      \u2022 {on_exit}  (`fun(err?: string, content?: string)?`)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2172098892",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34140,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2172098892",
        "commented_code": "@@ -4656,4 +4656,30 @@ tohtml.tohtml({winid}, {opt})                         *tohtml.tohtml.tohtml()*\n         (`string[]`)\n \n \n+==============================================================================\n+Lua module: vim.net                                                  *vim.net*\n+\n+vim.net.request({url}, {opts}, {on_exit})                  *vim.net.request()*\n+    Makes an HTTP GET request to the given URL. Can either return the body or\n+    save it to a file.\n+\n+    Parameters: ~\n+      \u2022 {url}      (`string`) The URL to fetch.\n+      \u2022 {opts}     (`table?`) Optional parameters:\n+                   \u2022 verbose (boolean|nil): Enables curl verbose output.\n+                   \u2022 retry (integer|nil): Number of retries on transient\n+                     failures (default: 3).\n+                   \u2022 output (string|nil): If set, path to save response body\n+                     instead of returning it.\n+      \u2022 {on_exit}  (`fun(err?: string, content?: string)?`)",
        "comment_created_at": "2025-06-27T13:54:06+00:00",
        "comment_author": "justinmk",
        "comment_body": "does `on_response` make sense as the name for this? \"exit\" is an implementation detail.  the fact that curl is used internally isn't relevant and shouldn't be surfaced in the request() interface (for now).",
        "pr_file_module": null
      },
      {
        "comment_id": "2173541914",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34140,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2172098892",
        "commented_code": "@@ -4656,4 +4656,30 @@ tohtml.tohtml({winid}, {opt})                         *tohtml.tohtml.tohtml()*\n         (`string[]`)\n \n \n+==============================================================================\n+Lua module: vim.net                                                  *vim.net*\n+\n+vim.net.request({url}, {opts}, {on_exit})                  *vim.net.request()*\n+    Makes an HTTP GET request to the given URL. Can either return the body or\n+    save it to a file.\n+\n+    Parameters: ~\n+      \u2022 {url}      (`string`) The URL to fetch.\n+      \u2022 {opts}     (`table?`) Optional parameters:\n+                   \u2022 verbose (boolean|nil): Enables curl verbose output.\n+                   \u2022 retry (integer|nil): Number of retries on transient\n+                     failures (default: 3).\n+                   \u2022 output (string|nil): If set, path to save response body\n+                     instead of returning it.\n+      \u2022 {on_exit}  (`fun(err?: string, content?: string)?`)",
        "comment_created_at": "2025-06-28T22:28:24+00:00",
        "comment_author": "tampueroc",
        "comment_body": "Agree!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2087614353",
    "pr_number": 34009,
    "pr_file": "runtime/doc/lua.txt",
    "created_at": "2025-05-13T20:51:26+00:00",
    "commented_code": "\u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2087614353",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2087614353",
        "commented_code": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.",
        "comment_created_at": "2025-05-13T20:51:26+00:00",
        "comment_author": "mrcjkb",
        "comment_body": "question: Lockfile support isn't implemented yet. What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\nThis isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nquibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\nFor consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.",
        "pr_file_module": null
      },
      {
        "comment_id": "2091167529",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34009,
        "pr_file": "runtime/doc/lua.txt",
        "discussion_id": "2087614353",
        "commented_code": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       \u2022 {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+\u2022 Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+\u2022 Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+\u2022 To update all plugins with new changes:\n+  \u2022 Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  \u2022 Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+\u2022 Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+\u2022 Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+\u2022 Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+\u2022 Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+\u2022 Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+\u2022 Restart Nvim.",
        "comment_created_at": "2025-05-15T13:23:54+00:00",
        "comment_author": "echasnovski",
        "comment_body": "> What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\n> This isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nTechnically - whichever is after `git clone`. On paper - added that \"HEAD\" is \"... for already installed plugin\" only. At least indeed until there is a lockfile support.\r\n\r\n> quibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\n> For consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.\r\n\r\nI am also not 100% happy with either \"version\" or \"HEAD\". Using \"FREEZE\" indeed might be a good idea, although I personally would prefer using \"checkout\" instead of \"version\". But that seems too Git-specific and needs a review.\r\n\r\nI've updated [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2087290998) to keep these kind of suggestions in one place.",
        "pr_file_module": null
      }
    ]
  }
]