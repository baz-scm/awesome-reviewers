[
  {
    "discussion_id": "2203062393",
    "pr_number": 26799,
    "pr_file": "src/nvim/winfloat.c",
    "created_at": "2025-07-13T02:45:28+00:00",
    "commented_code": "return false;\n }\n \n-win_T *win_float_find_preview(void)\n+/// Parses the 'border' style configuration and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dup_val Value text to parse.\n+/// @param len Length of the text.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_border(WinConfig *config, char *dup_val, size_t len, Error *err)\n+{\n+  Object style = CSTR_AS_OBJ(dup_val);\n+  parse_border_style(style, config, err);\n+  api_free_object(style);\n+  if (ERROR_SET(err)) {\n+    return false;\n+  }\n+  int border_attr = syn_name2attr(\"FloatBorder\");\n+  for (int i = 0; i < 8; i++) {\n+    config->border_attr[i] = config->border_hl_ids[i]\n+                             ? hl_get_ui_attr(0, HLF_BORDER, config->border_hl_ids[i], false)\n+                             : border_attr;\n+  }\n+  return true;\n+}\n+\n+/// Parses numeric keys for 'height' and 'width' options and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dig Digits representing the numeric value.\n+/// @param len Length of the digits.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_dig_key(WinConfig *config, char *dig, size_t len, Error *err)\n+{\n+  char *start = dig;\n+  int val = getdigits_int(&dig, false, 0);\n+  if (dig == start) {\n+    return false;\n+  }\n+  if (len == 6) {\n+    config->width = val;\n+  } else {\n+    config->height = val;\n+  }\n+  return true;\n+}\n+\n+/// Parses the 'align' option for floating window configuration.\n+///\n+/// @param config Configuration storage.\n+/// @param dup_val Value text to parse (\"item\" or \"menu\").\n+/// @param len Length of the key (should be 6 for \"align:\").\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_align(WinConfig *config, char *val, size_t len, Error *err)\n+{\n+  // TODO(glepnir): support this by adding completepopup\n+  bool is_item = (len == 4) && strncmp(val, \"item\", 4) == 0;\n+  bool is_menu = (len == 4) && strncmp(val, \"menu\", 4) == 0;\n+\n+  if (!is_item && !is_menu) {\n+    // Invalid align value\n+    api_set_error(err, kErrorTypeValidation, \"Invalid align value. Expected 'item' or 'menu'\");\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/// Parses options for configuring floating windows for completion popups or preview popups.\n+/// Supports setting border style, title, title position, footer, footer position, height, and width.\n+/// Only processes height and width options if `preview` is true.\n+///\n+/// @param fconfig The floating window configuration to modify.\n+/// @param preview Indicates if the configuration is for a preview popup.\n+///\n+/// @return True if options are successfully parsed, otherwise false.\n+bool parse_float_option(WinConfig *config)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203062393",
        "repo_full_name": "neovim/neovim",
        "pr_number": 26799,
        "pr_file": "src/nvim/winfloat.c",
        "discussion_id": "2203062393",
        "commented_code": "@@ -343,10 +352,158 @@ bool win_float_valid(const win_T *win)\n   return false;\n }\n \n-win_T *win_float_find_preview(void)\n+/// Parses the 'border' style configuration and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dup_val Value text to parse.\n+/// @param len Length of the text.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_border(WinConfig *config, char *dup_val, size_t len, Error *err)\n+{\n+  Object style = CSTR_AS_OBJ(dup_val);\n+  parse_border_style(style, config, err);\n+  api_free_object(style);\n+  if (ERROR_SET(err)) {\n+    return false;\n+  }\n+  int border_attr = syn_name2attr(\"FloatBorder\");\n+  for (int i = 0; i < 8; i++) {\n+    config->border_attr[i] = config->border_hl_ids[i]\n+                             ? hl_get_ui_attr(0, HLF_BORDER, config->border_hl_ids[i], false)\n+                             : border_attr;\n+  }\n+  return true;\n+}\n+\n+/// Parses numeric keys for 'height' and 'width' options and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dig Digits representing the numeric value.\n+/// @param len Length of the digits.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_dig_key(WinConfig *config, char *dig, size_t len, Error *err)\n+{\n+  char *start = dig;\n+  int val = getdigits_int(&dig, false, 0);\n+  if (dig == start) {\n+    return false;\n+  }\n+  if (len == 6) {\n+    config->width = val;\n+  } else {\n+    config->height = val;\n+  }\n+  return true;\n+}\n+\n+/// Parses the 'align' option for floating window configuration.\n+///\n+/// @param config Configuration storage.\n+/// @param dup_val Value text to parse (\"item\" or \"menu\").\n+/// @param len Length of the key (should be 6 for \"align:\").\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_align(WinConfig *config, char *val, size_t len, Error *err)\n+{\n+  // TODO(glepnir): support this by adding completepopup\n+  bool is_item = (len == 4) && strncmp(val, \"item\", 4) == 0;\n+  bool is_menu = (len == 4) && strncmp(val, \"menu\", 4) == 0;\n+\n+  if (!is_item && !is_menu) {\n+    // Invalid align value\n+    api_set_error(err, kErrorTypeValidation, \"Invalid align value. Expected 'item' or 'menu'\");\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/// Parses options for configuring floating windows for completion popups or preview popups.\n+/// Supports setting border style, title, title position, footer, footer position, height, and width.\n+/// Only processes height and width options if `preview` is true.\n+///\n+/// @param fconfig The floating window configuration to modify.\n+/// @param preview Indicates if the configuration is for a preview popup.\n+///\n+/// @return True if options are successfully parsed, otherwise false.\n+bool parse_float_option(WinConfig *config)",
        "comment_created_at": "2025-07-13T02:45:28+00:00",
        "comment_author": "justinmk",
        "comment_body": "\"float\" is ambiguous. we should always say \"floatwin\" or win_float.\n```suggestion\nbool win_float_parse_option(WinConfig *config)\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203082163",
    "pr_number": 26799,
    "pr_file": "src/nvim/winfloat.c",
    "created_at": "2025-07-13T02:50:38+00:00",
    "commented_code": "return false;\n }\n \n-win_T *win_float_find_preview(void)\n+/// Parses the 'border' style configuration and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dup_val Value text to parse.\n+/// @param len Length of the text.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_border(WinConfig *config, char *dup_val, size_t len, Error *err)\n+{\n+  Object style = CSTR_AS_OBJ(dup_val);\n+  parse_border_style(style, config, err);\n+  api_free_object(style);\n+  if (ERROR_SET(err)) {\n+    return false;\n+  }\n+  int border_attr = syn_name2attr(\"FloatBorder\");\n+  for (int i = 0; i < 8; i++) {\n+    config->border_attr[i] = config->border_hl_ids[i]\n+                             ? hl_get_ui_attr(0, HLF_BORDER, config->border_hl_ids[i], false)\n+                             : border_attr;\n+  }\n+  return true;\n+}\n+\n+/// Parses numeric keys for 'height' and 'width' options and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dig Digits representing the numeric value.\n+/// @param len Length of the digits.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_dig_key(WinConfig *config, char *dig, size_t len, Error *err)\n+{\n+  char *start = dig;\n+  int val = getdigits_int(&dig, false, 0);\n+  if (dig == start) {\n+    return false;\n+  }\n+  if (len == 6) {\n+    config->width = val;\n+  } else {\n+    config->height = val;\n+  }\n+  return true;\n+}\n+\n+/// Parses the 'align' option for floating window configuration.\n+///\n+/// @param config Configuration storage.\n+/// @param dup_val Value text to parse (\"item\" or \"menu\").\n+/// @param len Length of the key (should be 6 for \"align:\").\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_align(WinConfig *config, char *val, size_t len, Error *err)\n+{\n+  // TODO(glepnir): support this by adding completepopup\n+  bool is_item = (len == 4) && strncmp(val, \"item\", 4) == 0;\n+  bool is_menu = (len == 4) && strncmp(val, \"menu\", 4) == 0;\n+\n+  if (!is_item && !is_menu) {\n+    // Invalid align value\n+    api_set_error(err, kErrorTypeValidation, \"Invalid align value. Expected 'item' or 'menu'\");\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/// Parses options for configuring floating windows for completion popups or preview popups.\n+/// Supports setting border style, title, title position, footer, footer position, height, and width.\n+/// Only processes height and width options if `preview` is true.\n+///\n+/// @param fconfig The floating window configuration to modify.\n+/// @param preview Indicates if the configuration is for a preview popup.\n+///\n+/// @return True if options are successfully parsed, otherwise false.\n+bool parse_float_option(WinConfig *config)\n+{\n+  char *p = p_pvp;\n+  Error err = ERROR_INIT;\n+\n+  struct {\n+    char *key;\n+    bool (*parser_func)(WinConfig *, char *, size_t, Error *);\n+  } parsers[] = {\n+    { \"border:\", parse_opt_border },\n+    { \"height:\", parse_opt_dig_key },\n+    { \"width:\", parse_opt_dig_key },\n+    { \"align:\", parse_opt_align },",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2203082163",
        "repo_full_name": "neovim/neovim",
        "pr_number": 26799,
        "pr_file": "src/nvim/winfloat.c",
        "discussion_id": "2203082163",
        "commented_code": "@@ -343,10 +352,158 @@ bool win_float_valid(const win_T *win)\n   return false;\n }\n \n-win_T *win_float_find_preview(void)\n+/// Parses the 'border' style configuration and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dup_val Value text to parse.\n+/// @param len Length of the text.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_border(WinConfig *config, char *dup_val, size_t len, Error *err)\n+{\n+  Object style = CSTR_AS_OBJ(dup_val);\n+  parse_border_style(style, config, err);\n+  api_free_object(style);\n+  if (ERROR_SET(err)) {\n+    return false;\n+  }\n+  int border_attr = syn_name2attr(\"FloatBorder\");\n+  for (int i = 0; i < 8; i++) {\n+    config->border_attr[i] = config->border_hl_ids[i]\n+                             ? hl_get_ui_attr(0, HLF_BORDER, config->border_hl_ids[i], false)\n+                             : border_attr;\n+  }\n+  return true;\n+}\n+\n+/// Parses numeric keys for 'height' and 'width' options and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dig Digits representing the numeric value.\n+/// @param len Length of the digits.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_dig_key(WinConfig *config, char *dig, size_t len, Error *err)\n+{\n+  char *start = dig;\n+  int val = getdigits_int(&dig, false, 0);\n+  if (dig == start) {\n+    return false;\n+  }\n+  if (len == 6) {\n+    config->width = val;\n+  } else {\n+    config->height = val;\n+  }\n+  return true;\n+}\n+\n+/// Parses the 'align' option for floating window configuration.\n+///\n+/// @param config Configuration storage.\n+/// @param dup_val Value text to parse (\"item\" or \"menu\").\n+/// @param len Length of the key (should be 6 for \"align:\").\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_align(WinConfig *config, char *val, size_t len, Error *err)\n+{\n+  // TODO(glepnir): support this by adding completepopup\n+  bool is_item = (len == 4) && strncmp(val, \"item\", 4) == 0;\n+  bool is_menu = (len == 4) && strncmp(val, \"menu\", 4) == 0;\n+\n+  if (!is_item && !is_menu) {\n+    // Invalid align value\n+    api_set_error(err, kErrorTypeValidation, \"Invalid align value. Expected 'item' or 'menu'\");\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/// Parses options for configuring floating windows for completion popups or preview popups.\n+/// Supports setting border style, title, title position, footer, footer position, height, and width.\n+/// Only processes height and width options if `preview` is true.\n+///\n+/// @param fconfig The floating window configuration to modify.\n+/// @param preview Indicates if the configuration is for a preview popup.\n+///\n+/// @return True if options are successfully parsed, otherwise false.\n+bool parse_float_option(WinConfig *config)\n+{\n+  char *p = p_pvp;\n+  Error err = ERROR_INIT;\n+\n+  struct {\n+    char *key;\n+    bool (*parser_func)(WinConfig *, char *, size_t, Error *);\n+  } parsers[] = {\n+    { \"border:\", parse_opt_border },\n+    { \"height:\", parse_opt_dig_key },\n+    { \"width:\", parse_opt_dig_key },\n+    { \"align:\", parse_opt_align },",
        "comment_created_at": "2025-07-13T02:50:38+00:00",
        "comment_author": "justinmk",
        "comment_body": "was this copied from vim? or generated by AI? :) we have lots of similar code like `parse_winborder`, `parse_win_config`, `parse_border_style`. why do we need even more ? \n\nand if it's really needed, the name should make it more clear that this is specifically for 'previewpopup'. The name `parse_float_option` is very unclear. A clearer name would be `parse_previewpopu_option`.\n\nAlso, should this live in `optionstr.c` ?\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2203128254",
        "repo_full_name": "neovim/neovim",
        "pr_number": 26799,
        "pr_file": "src/nvim/winfloat.c",
        "discussion_id": "2203082163",
        "commented_code": "@@ -343,10 +352,158 @@ bool win_float_valid(const win_T *win)\n   return false;\n }\n \n-win_T *win_float_find_preview(void)\n+/// Parses the 'border' style configuration and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dup_val Value text to parse.\n+/// @param len Length of the text.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_border(WinConfig *config, char *dup_val, size_t len, Error *err)\n+{\n+  Object style = CSTR_AS_OBJ(dup_val);\n+  parse_border_style(style, config, err);\n+  api_free_object(style);\n+  if (ERROR_SET(err)) {\n+    return false;\n+  }\n+  int border_attr = syn_name2attr(\"FloatBorder\");\n+  for (int i = 0; i < 8; i++) {\n+    config->border_attr[i] = config->border_hl_ids[i]\n+                             ? hl_get_ui_attr(0, HLF_BORDER, config->border_hl_ids[i], false)\n+                             : border_attr;\n+  }\n+  return true;\n+}\n+\n+/// Parses numeric keys for 'height' and 'width' options and updates WinConfig.\n+///\n+/// @param fconfig Configuration storage.\n+/// @param dig Digits representing the numeric value.\n+/// @param len Length of the digits.\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_dig_key(WinConfig *config, char *dig, size_t len, Error *err)\n+{\n+  char *start = dig;\n+  int val = getdigits_int(&dig, false, 0);\n+  if (dig == start) {\n+    return false;\n+  }\n+  if (len == 6) {\n+    config->width = val;\n+  } else {\n+    config->height = val;\n+  }\n+  return true;\n+}\n+\n+/// Parses the 'align' option for floating window configuration.\n+///\n+/// @param config Configuration storage.\n+/// @param dup_val Value text to parse (\"item\" or \"menu\").\n+/// @param len Length of the key (should be 6 for \"align:\").\n+/// @param err Pointer to the Error structure for error handling.\n+///\n+/// @return true if parsing is successful, otherwise false.\n+static bool parse_opt_align(WinConfig *config, char *val, size_t len, Error *err)\n+{\n+  // TODO(glepnir): support this by adding completepopup\n+  bool is_item = (len == 4) && strncmp(val, \"item\", 4) == 0;\n+  bool is_menu = (len == 4) && strncmp(val, \"menu\", 4) == 0;\n+\n+  if (!is_item && !is_menu) {\n+    // Invalid align value\n+    api_set_error(err, kErrorTypeValidation, \"Invalid align value. Expected 'item' or 'menu'\");\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+/// Parses options for configuring floating windows for completion popups or preview popups.\n+/// Supports setting border style, title, title position, footer, footer position, height, and width.\n+/// Only processes height and width options if `preview` is true.\n+///\n+/// @param fconfig The floating window configuration to modify.\n+/// @param preview Indicates if the configuration is for a preview popup.\n+///\n+/// @return True if options are successfully parsed, otherwise false.\n+bool parse_float_option(WinConfig *config)\n+{\n+  char *p = p_pvp;\n+  Error err = ERROR_INIT;\n+\n+  struct {\n+    char *key;\n+    bool (*parser_func)(WinConfig *, char *, size_t, Error *);\n+  } parsers[] = {\n+    { \"border:\", parse_opt_border },\n+    { \"height:\", parse_opt_dig_key },\n+    { \"width:\", parse_opt_dig_key },\n+    { \"align:\", parse_opt_align },",
        "comment_created_at": "2025-07-13T03:38:12+00:00",
        "comment_author": "glepnir",
        "comment_body": "code in popupwin.c handles this option in Vim. Here's how I've modified it to make it clearer.\r\n\r\nhttps://github.com/vim/vim/blob/68ee1cf7de36bdd6e642807c8beda751112aaab8/src/popupwin.c#L1778-L1904\r\n\r\nI have removed these `parse_opt_*` functions .. If you still feel it's too long, then maybe as you said, we could handle some comma-list options in Lua and replace certain C functions. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "312705728",
    "pr_number": 10735,
    "pr_file": "src/nvim/api/vim.c",
    "created_at": "2019-08-10T15:08:05+00:00",
    "commented_code": "PUT(rv, \"mode\", STRING_OBJ(cstr_as_string(modestr)));\n   PUT(rv, \"blocking\", BOOLEAN_OBJ(blocked));\n+  // :help getcmdwintype()\n+  PUT(rv, \"wintype\", STRING_OBJ(cchar_to_string((char)cmdwin_type)));",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "312705728",
        "repo_full_name": "neovim/neovim",
        "pr_number": 10735,
        "pr_file": "src/nvim/api/vim.c",
        "discussion_id": "312705728",
        "commented_code": "@@ -1344,6 +1344,8 @@ Dictionary nvim_get_mode(void)\n \n   PUT(rv, \"mode\", STRING_OBJ(cstr_as_string(modestr)));\n   PUT(rv, \"blocking\", BOOLEAN_OBJ(blocked));\n+  // :help getcmdwintype()\n+  PUT(rv, \"wintype\", STRING_OBJ(cchar_to_string((char)cmdwin_type)));",
        "comment_created_at": "2019-08-10T15:08:05+00:00",
        "comment_author": "bfredl",
        "comment_body": "Do we want these to be grouped under \"cmdline\" label somehow? I assume we want `wintype` to later also indicate modal terminal or plugin-defined `modal()` functionality being active.",
        "pr_file_module": null
      },
      {
        "comment_id": "314215692",
        "repo_full_name": "neovim/neovim",
        "pr_number": 10735,
        "pr_file": "src/nvim/api/vim.c",
        "discussion_id": "312705728",
        "commented_code": "@@ -1344,6 +1344,8 @@ Dictionary nvim_get_mode(void)\n \n   PUT(rv, \"mode\", STRING_OBJ(cstr_as_string(modestr)));\n   PUT(rv, \"blocking\", BOOLEAN_OBJ(blocked));\n+  // :help getcmdwintype()\n+  PUT(rv, \"wintype\", STRING_OBJ(cchar_to_string((char)cmdwin_type)));",
        "comment_created_at": "2019-08-15T08:23:41+00:00",
        "comment_author": "justinmk",
        "comment_body": "@bfredl latest commit returns names like `cmdline_:` and `cmdline_/`. Is that what you were thinking?\r\n\r\nI think I'd prefer if we stuck to the standard plain `:` and `/` names, and these are simply understood (and documented) to mean \"cmdline window\". Then we have new identifiers for new window-types (e.g. `modal`, `modal-term`, ...). Normal windows are \"\" (empty string).",
        "pr_file_module": null
      },
      {
        "comment_id": "314243865",
        "repo_full_name": "neovim/neovim",
        "pr_number": 10735,
        "pr_file": "src/nvim/api/vim.c",
        "discussion_id": "312705728",
        "commented_code": "@@ -1344,6 +1344,8 @@ Dictionary nvim_get_mode(void)\n \n   PUT(rv, \"mode\", STRING_OBJ(cstr_as_string(modestr)));\n   PUT(rv, \"blocking\", BOOLEAN_OBJ(blocked));\n+  // :help getcmdwintype()\n+  PUT(rv, \"wintype\", STRING_OBJ(cchar_to_string((char)cmdwin_type)));",
        "comment_created_at": "2019-08-15T09:51:21+00:00",
        "comment_author": "bfredl",
        "comment_body": "> I think I'd prefer if we stuck to the standard plain : and / names, and these are simply understood (and documented) to mean \"cmdline window\".\r\n\r\nBut there is no standard that says that one-letter chars identify cmdline window as opposed to other modal windows. We are defining this standard here and now, there is exactly nothing we have to \"stick\" to. One char strings are only used to distinguish the type of the _cmdline_ in something you already know is a cmdline window, for `getcmdwintype()` that already has \"cmdwin\" in the name.\r\n\r\nIt would be useful for an async plugin to identify cmdline windows overall without caring which sort it is. Cmdline window overrides a bunch of behaviors consistently, regardless of what the `firstc` happens to be. Should they check if the string is one byte long? Do we want to rule out `firstc` from ever being a unicode char? \r\n\r\nChecking `wintype==\"cmdwin\"` is self-documenting, while `strlen(wintype)==1` looks fragile and obscure. The firstc can be just a separate field if it is needed, we do not have to invent new stringly typed composites like `\"cmdline_/\"`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2153367689",
    "pr_number": 34491,
    "pr_file": "src/nvim/eval.c",
    "created_at": "2025-06-18T00:10:16+00:00",
    "commented_code": "}\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2153367689",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "src/nvim/eval.c",
        "discussion_id": "2153367689",
        "commented_code": "@@ -8660,24 +8660,12 @@ void eval_fmt_source_name_line(char *buf, size_t bufsize)\n   }\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
        "comment_created_at": "2025-06-18T00:10:16+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "This function name is a bit vague. It's not immediately clear that it gets the user input.",
        "pr_file_module": null
      },
      {
        "comment_id": "2153479665",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "src/nvim/eval.c",
        "discussion_id": "2153367689",
        "commented_code": "@@ -8660,24 +8660,12 @@ void eval_fmt_source_name_line(char *buf, size_t bufsize)\n   }\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
        "comment_created_at": "2025-06-18T02:07:22+00:00",
        "comment_author": "shadmansaleh",
        "comment_body": "Any suggestions?",
        "pr_file_module": null
      },
      {
        "comment_id": "2154514077",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "src/nvim/eval.c",
        "discussion_id": "2153367689",
        "commented_code": "@@ -8660,24 +8660,12 @@ void eval_fmt_source_name_line(char *buf, size_t bufsize)\n   }\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
        "comment_created_at": "2025-06-18T12:48:31+00:00",
        "comment_author": "justinmk",
        "comment_body": "`prompt_cur_input` ?\r\n\r\nalso a brief docstring helps when there is ambiguity. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2154774180",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "src/nvim/eval.c",
        "discussion_id": "2153367689",
        "commented_code": "@@ -8660,24 +8660,12 @@ void eval_fmt_source_name_line(char *buf, size_t bufsize)\n   }\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
        "comment_created_at": "2025-06-18T14:33:17+00:00",
        "comment_author": "shadmansaleh",
        "comment_body": "Yeah, docstring would help. And probably prefixing it with `prompt_` is will make it distinct enough for an internal function. Any suggestions on `prompt_gettext()` ? Should I make it `prompt_getinput(bufnr)`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2154792541",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34491,
        "pr_file": "src/nvim/eval.c",
        "discussion_id": "2153367689",
        "commented_code": "@@ -8660,24 +8660,12 @@ void eval_fmt_source_name_line(char *buf, size_t bufsize)\n   }\n }\n \n-void invoke_prompt_callback(void)\n+char *get_current_prompt(buf_T *buf)",
        "comment_created_at": "2025-06-18T14:40:43+00:00",
        "comment_author": "justinmk",
        "comment_body": "either SGTM, slightly in favor of `prompt_gettext` since it aligns with `getcmdline()` (whereas `input*()` family of functions usually involves starting a prompt, not getting the current input?)",
        "pr_file_module": null
      }
    ]
  }
]