[
  {
    "discussion_id": "2234165546",
    "pr_number": 35087,
    "pr_file": "src/nvim/api/extmark.c",
    "created_at": "2025-07-27T23:05:11+00:00",
    "commented_code": "}\n \n   if (HAS_KEY(opts, set_extmark, conceal)) {\n-    hl.flags |= kSHConceal;\n     has_hl = true;\n-    if (opts->conceal.size > 0) {\n-      int ch;\n-      hl.conceal_char = utfc_ptr2schar(opts->conceal.data, &ch);\n-      VALIDATE(hl.conceal_char && vim_isprintc(ch), \"%s\", \"conceal char has to be printable\", {\n-        goto error;\n-      });\n+    if (opts->conceal.type == kObjectTypeBoolean) {\n+      Boolean is_concealed = opts->conceal.data.boolean;\n+      if (is_concealed) {\n+        hl.flags |= kSHConceal;\n+      } else {\n+        hl.flags |= kSHConcealOff;\n+      }\n+    } else if (opts->conceal.type == kObjectTypeString) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2234165546",
        "repo_full_name": "neovim/neovim",
        "pr_number": 35087,
        "pr_file": "src/nvim/api/extmark.c",
        "discussion_id": "2234165546",
        "commented_code": "@@ -625,14 +628,24 @@ Integer nvim_buf_set_extmark(Buffer buffer, Integer ns_id, Integer line, Integer\n   }\n \n   if (HAS_KEY(opts, set_extmark, conceal)) {\n-    hl.flags |= kSHConceal;\n     has_hl = true;\n-    if (opts->conceal.size > 0) {\n-      int ch;\n-      hl.conceal_char = utfc_ptr2schar(opts->conceal.data, &ch);\n-      VALIDATE(hl.conceal_char && vim_isprintc(ch), \"%s\", \"conceal char has to be printable\", {\n-        goto error;\n-      });\n+    if (opts->conceal.type == kObjectTypeBoolean) {\n+      Boolean is_concealed = opts->conceal.data.boolean;\n+      if (is_concealed) {\n+        hl.flags |= kSHConceal;\n+      } else {\n+        hl.flags |= kSHConcealOff;\n+      }\n+    } else if (opts->conceal.type == kObjectTypeString) {",
        "comment_created_at": "2025-07-27T23:05:11+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "Need to error out if the type is neither string nor boolean",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188742153",
    "pr_number": 34788,
    "pr_file": "src/nvim/ex_docmd.c",
    "created_at": "2025-07-06T23:50:56+00:00",
    "commented_code": "Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2188742153",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2188742153",
        "commented_code": "@@ -4839,7 +4840,17 @@ static void ex_quitall_or_restart(exarg_T *eap)\n   Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
        "comment_created_at": "2025-07-06T23:50:56+00:00",
        "comment_author": "justinmk",
        "comment_body": "also need to handle the case where the +cmd didnt cause an exit nor an error ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2188837508",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2188742153",
        "commented_code": "@@ -4839,7 +4840,17 @@ static void ex_quitall_or_restart(exarg_T *eap)\n   Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
        "comment_created_at": "2025-07-07T02:16:51+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "If +cmd doesn't error and doesn't quit the server we are at a state where the UI has attached to the newly created server and the \"dangling\" server is at the end of the if-else block. We could just call `getout(0)` if we get there by logging an error message (would just need to remove the else, the log can go after this error check).",
        "pr_file_module": null
      },
      {
        "comment_id": "2188847534",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2188742153",
        "commented_code": "@@ -4839,7 +4840,17 @@ static void ex_quitall_or_restart(exarg_T *eap)\n   Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
        "comment_created_at": "2025-07-07T02:30:26+00:00",
        "comment_author": "justinmk",
        "comment_body": "> We could just call `getout(0)` if we get there by logging an error message\r\n\r\nlogging *and* then call `getout` makes sense \ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "2189263423",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2188742153",
        "commented_code": "@@ -4839,7 +4840,17 @@ static void ex_quitall_or_restart(exarg_T *eap)\n   Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
        "comment_created_at": "2025-07-07T07:50:54+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "~A small problem with this: \":restart +qall\" still triggers `getout(0)` from within `ex_quitall_or_restart` (renamed to `ex_restart` as per https://github.com/neovim/neovim/pull/34788#issuecomment-3043318938 ). I check for the `exiting` global being `false` before triggering it and it doesn't seem to be set quick enough.~\r\n\r\n~ref: https://github.com/neovim/neovim/pull/34788/files#diff-e8cf5e56e29738d0c1605f75d1b158ea0fae543b45c55e3b721f91dd10ac9b49R4869~\r\n\r\n\r\nIm just stupid......",
        "pr_file_module": null
      },
      {
        "comment_id": "2189484703",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2188742153",
        "commented_code": "@@ -4839,7 +4840,17 @@ static void ex_quitall_or_restart(exarg_T *eap)\n   Error err = ERROR_INIT;\n   if ((eap->forceit || !check_changed_any(false, false))\n       && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+    if (eap->cmdidx == CMD_restart) {\n+      char *quit_cmd = (eap->do_ecmd_cmd) ? eap->do_ecmd_cmd : (eap->forceit) ? \"qall!\" : \"qall\";\n+      nvim_command(cstr_as_string(quit_cmd), &err);\n+      if (ERROR_SET(&err)) {\n+        emsg(err.msg);  // Could not exit\n+        api_clear_error(&err);",
        "comment_created_at": "2025-07-07T09:27:30+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "Resolved: https://github.com/neovim/neovim/pull/34788/commits/0856ee4d700a96e67f80ff0e740c4316c45a9c16",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2189507086",
    "pr_number": 34788,
    "pr_file": "src/nvim/ex_docmd.c",
    "created_at": "2025-07-07T09:38:03+00:00",
    "commented_code": "}\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2189507086",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2189507086",
        "commented_code": "@@ -4829,22 +4830,45 @@ int before_quit_all(exarg_T *eap)\n }\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
        "comment_created_at": "2025-07-07T09:38:03+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "If you have this check here, doesn't this essentially make it pointless to support `:restart +qall!`?\r\n\r\nOn the other hand, if you remove this check, even `:restart +echo` will quit the server without confirmation, as you still call `getout(0)` anyway.",
        "pr_file_module": null
      },
      {
        "comment_id": "2189544582",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2189507086",
        "commented_code": "@@ -4829,22 +4830,45 @@ int before_quit_all(exarg_T *eap)\n }\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
        "comment_created_at": "2025-07-07T09:53:08+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "> On the other hand, if you remave this check, even `:restart +echo` will quit the server without confirmation, as you still call `getout(0)` anyway.\r\n\r\nThis is true. We would need to somehow check if \":cmd\" would quit the server and only then call `remote_ui_restart` (because we don't need to attach to the new server unless we know the old server will exit). If it doesn't quit the server, we could maybe just `emsg` the log and bail on restarting altogether..\r\n\r\nThe first part of this is what I'd need to figure out. Any suggestions? I was initially thinking to just match against a list of possible \"quit\" commands (and combinations) and then checking against that. But that's probably not efficient.",
        "pr_file_module": null
      },
      {
        "comment_id": "2189788703",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2189507086",
        "commented_code": "@@ -4829,22 +4830,45 @@ int before_quit_all(exarg_T *eap)\n }\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
        "comment_created_at": "2025-07-07T11:31:58+00:00",
        "comment_author": "justinmk",
        "comment_body": "> I was initially thinking to just match against a list of possible \"quit\" commands (and combinations) and then checking against that\n\nThat's probably good enough for now.\n\nThe \"right\" way to do things is probably to setup some sort of `on_exiting` callback which performs `remote_ui_restart` only when Nvim is about to exit, wherever the `VimLeavePre` logic is.",
        "pr_file_module": null
      },
      {
        "comment_id": "2189851363",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2189507086",
        "commented_code": "@@ -4829,22 +4830,45 @@ int before_quit_all(exarg_T *eap)\n }\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
        "comment_created_at": "2025-07-07T11:58:30+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "Alright. Checking against `{\"qall\",  \"qa\", \"q\", \"q!\", \"qa!\", \"qall!\"}` for now should do...",
        "pr_file_module": null
      },
      {
        "comment_id": "2189976783",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34788,
        "pr_file": "src/nvim/ex_docmd.c",
        "discussion_id": "2189507086",
        "commented_code": "@@ -4829,22 +4830,45 @@ int before_quit_all(exarg_T *eap)\n }\n \n /// \":qall\": try to quit all windows\n-/// \":restart\": restart the Nvim server\n-static void ex_quitall_or_restart(exarg_T *eap)\n+static void ex_quitall(exarg_T *eap)\n {\n   if (before_quit_all(eap) == FAIL) {\n     return;\n   }\n   exiting = true;\n+  if (!eap->forceit && check_changed_any(false, false)) {\n+    not_exiting();\n+    return;\n+  }\n+  getout(0);\n+}\n+\n+/// \":restart\": restart the Nvim server (using \":qall\").\n+/// \":restart +cmd\": restart the Nvim server using \":cmd\".\n+static void ex_restart(exarg_T *eap)\n+{\n+  if (eap->forceit) {\n+    emsg(\"bang (!) not supported\");\n+    return;\n+  }\n   Error err = ERROR_INIT;\n-  if ((eap->forceit || !check_changed_any(false, false))\n-      && (eap->cmdidx != CMD_restart || remote_ui_restart(current_ui, &err))) {\n-    getout(0);\n+  if (check_changed_any(false, false) || !remote_ui_restart(current_ui, &err)) {",
        "comment_created_at": "2025-07-07T12:46:14+00:00",
        "comment_author": "sathya-pramodh",
        "comment_body": "Also added a check to see if the \"+cmd\" itself ends with a bang (!). If so, \":restart +qall!\" also supports force restart as well as \":confirm restart\" as we still do the `check_changed_any` check.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2207136260",
    "pr_number": 34943,
    "pr_file": "src/nvim/api/win_config.c",
    "created_at": "2025-07-15T10:48:47+00:00",
    "commented_code": "return;\n     }\n \n-    if (!check_split_disallowed_err(win, err)) {\n+    if (!check_split_float_disallowed_err(win, err, true)) {",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2207136260",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34943,
        "pr_file": "src/nvim/api/win_config.c",
        "discussion_id": "2207136260",
        "commented_code": "@@ -468,7 +470,7 @@ void nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\n       return;\n     }\n \n-    if (!check_split_disallowed_err(win, err)) {\n+    if (!check_split_float_disallowed_err(win, err, true)) {",
        "comment_created_at": "2025-07-15T10:48:47+00:00",
        "comment_author": "seandewar",
        "comment_body": "Doesn't seem to prevent this crash:\r\n\r\n```vim\r\ntabnew\r\nautocmd WinLeave * split | call nvim_win_set_config(0, {'win': 0, 'relative': 'win', 'row': 2, 'col': 2, 'width': 2, 'height': 2})\r\nquit\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2207139882",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34943,
        "pr_file": "src/nvim/api/win_config.c",
        "discussion_id": "2207136260",
        "commented_code": "@@ -468,7 +470,7 @@ void nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\n       return;\n     }\n \n-    if (!check_split_disallowed_err(win, err)) {\n+    if (!check_split_float_disallowed_err(win, err, true)) {",
        "comment_created_at": "2025-07-15T10:50:48+00:00",
        "comment_author": "glepnir",
        "comment_body": "dm has been  broken  for a long time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2207158289",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34943,
        "pr_file": "src/nvim/api/win_config.c",
        "discussion_id": "2207136260",
        "commented_code": "@@ -468,7 +470,7 @@ void nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\n       return;\n     }\n \n-    if (!check_split_disallowed_err(win, err)) {\n+    if (!check_split_float_disallowed_err(win, err, true)) {",
        "comment_created_at": "2025-07-15T11:00:32+00:00",
        "comment_author": "glepnir",
        "comment_body": "how about this like current `cannot close last window`, removed `float_disallowed`.\r\n\r\n```diff\r\n@@ -2710,6 +2706,20 @@ int win_close(win_T *win, bool free_buf, bool force)\r\n     return FAIL;\r\n   }\r\n\r\n+  // Check if closing this non-floating window would leave only floating windows\r\n+  if (!win->w_floating && !force) {\r\n+    int non_float_count = 0;\r\n+    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\r\n+      if (!wp->w_floating) {\r\n+        non_float_count++;\r\n+      }\r\n+    }\r\n+    if (non_float_count <= 1) {\r\n+      emsg(_(\"E444: Cannot close last non-floating window\"));\r\n+      return FAIL;\r\n+    }\r\n+  }\r\n+\r\n   if (win_locked(win)\r\n       || (win->w_buffer != NULL && win->w_buffer->b_locked > 0)) {\r\n     return FAIL;     // window is already being closed\r\n@@ -2991,6 +3001,19 @@ void win_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\r\n       || (win->w_buffer != NULL && win->w_buffer->b_locked > 0)) {\r\n     return;  // window is already being closed\r\n   }\r\n+  // Check if closing this window would leave only floating windows\r\n+  if (!win->w_floating) {\r\n+    int non_float_count = 0;\r\n+    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {\r\n+      if (!wp->w_floating) {\r\n+        non_float_count++;\r\n+      }\r\n+    }\r\n+    // If this is the last non-floating window, don't close it\r\n+    if (non_float_count <= 1) {\r\n+      return;\r\n+    }\r\n+  }\r\n\r\n   // Fire WinClosed just before starting to free window-related resources.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2207236845",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34943,
        "pr_file": "src/nvim/api/win_config.c",
        "discussion_id": "2207136260",
        "commented_code": "@@ -468,7 +470,7 @@ void nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\n       return;\n     }\n \n-    if (!check_split_disallowed_err(win, err)) {\n+    if (!check_split_float_disallowed_err(win, err, true)) {",
        "comment_created_at": "2025-07-15T11:33:55+00:00",
        "comment_author": "seandewar",
        "comment_body": "> dm has been broken for a long time.\r\n\r\nAh, I've not checked them since the Matrix outage that also took out the dev room. I'll have a look in a bit. :+1:\r\n\r\n> how about this like current cannot close last window, removed float_disallowed.\r\n\r\n~~I think `win_close` is already covered by the `last_window` check.~~ Nah, that's only if it's the only tabpage. I mean `lastwin->w_floating && one_window(win)`.\r\n\r\nCan't check `win_close_othertab` right now, but take care that there's no callsites that assume it always succeeds.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160346160",
    "pr_number": 34594,
    "pr_file": "src/nvim/tui/tui.c",
    "created_at": "2025-06-22T13:24:04+00:00",
    "commented_code": "grid->col = 0;\n \n   FILE *f = fopen(path.data, \"w\");\n+  if (f == NULL) {\n+    return;\n+  }",
    "repo_full_name": "neovim/neovim",
    "discussion_comments": [
      {
        "comment_id": "2160346160",
        "repo_full_name": "neovim/neovim",
        "pr_number": 34594,
        "pr_file": "src/nvim/tui/tui.c",
        "discussion_id": "2160346160",
        "commented_code": "@@ -1657,6 +1657,9 @@ void tui_screenshot(TUIData *tui, String path)\n   grid->col = 0;\n \n   FILE *f = fopen(path.data, \"w\");\n+  if (f == NULL) {\n+    return;\n+  }",
        "comment_created_at": "2025-06-22T13:24:04+00:00",
        "comment_author": "zeertzjq",
        "comment_body": "Perhaps this block should be moved to the top of the function? The cursor movement shouldn't be done if the screenshot fails.",
        "pr_file_module": null
      }
    ]
  }
]