[
  {
    "discussion_id": "1694136521",
    "pr_number": 13378,
    "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
    "created_at": "2024-07-28T07:23:59+00:00",
    "commented_code": "handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1694136521",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13378,
        "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
        "discussion_id": "1694136521",
        "commented_code": "@@ -111,10 +111,13 @@ export class WsAdapter extends AbstractWsAdapter {\n     handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
        "comment_created_at": "2024-07-28T07:23:59+00:00",
        "comment_author": "Theofilos-Chamalis",
        "comment_body": "While in Computer Science theory accessing a Map is faster than iterating through an array, in practice it may be a different story. Would you consider running a benchmark for various sizes (100, 1_000, 10_000, 1_000_000) between 3 different implementations:\r\n1. The original that uses the handlers array and the find() function\r\n2. Your proposed on with the usage of a Map\r\n3. Another one with a plain Object, similar to how the Map is used\r\n\r\nThe rationale behind these is:\r\n1. For small sizes arrays in practice should be faster, since they utilize a continuous block of memory plus we do not allocate a new object or Map for the Garbage collector to clean up later.\r\n2. V8 may optimize the Object and Map approaches differently based on their sizes/contents (e.g. if Object has messages of similar structure)\r\n\r\nBased on the above and its findings, it may be worth it to have an approach where we switch between implementations based on the size itself.\r\n\r\nThanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "1694477447",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13378,
        "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
        "discussion_id": "1694136521",
        "commented_code": "@@ -111,10 +111,13 @@ export class WsAdapter extends AbstractWsAdapter {\n     handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
        "comment_created_at": "2024-07-29T03:32:53+00:00",
        "comment_author": "CodyTseng",
        "comment_body": "Very valuable advice! I will find time to experiment and make further optimizations.",
        "pr_file_module": null
      },
      {
        "comment_id": "1699343621",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13378,
        "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
        "discussion_id": "1694136521",
        "commented_code": "@@ -111,10 +111,13 @@ export class WsAdapter extends AbstractWsAdapter {\n     handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
        "comment_created_at": "2024-08-01T03:21:41+00:00",
        "comment_author": "CodyTseng",
        "comment_body": "hi @Theofilos-Chamalis , I wrote a simple benchmark script to test. Below are the script code and test results.\r\n\r\n```js\r\nconst { performance } = require('perf_hooks');\r\n\r\nfunction generateKey() {\r\n  const length = Math.floor(Math.random() * 10) + 5;\r\n  return Math.random().toString(36).substring(2, length + 2);\r\n}\r\n\r\nfunction generateTestData(size) {\r\n  const keys = new Set();\r\n  const data = [];\r\n  for (let i = 0; i < size; i++) {\r\n    let key = generateKey();\r\n    while (keys.has(key)) {\r\n      key = generateKey();\r\n    }\r\n    keys.add(key);\r\n    data.push({ key, value: `value${i}` });\r\n  }\r\n  return data;\r\n}\r\n\r\nfunction prepareDataStructures(data) {\r\n  const arr = data;\r\n  const map = new Map(data.map(item => [item.key, item]));\r\n  const obj = Object.fromEntries(data.map(item => [item.key, item]));\r\n  return { arr, map, obj };\r\n}\r\n\r\nfunction runQuery(structure, key, { arr, map, obj }) {\r\n  switch (structure) {\r\n    case 'array':\r\n      return arr.find(item => item.key === key);\r\n    case 'map':\r\n      return map.get(key);\r\n    case 'object':\r\n      return obj[key];\r\n  }\r\n}\r\n\r\nfunction runBenchmark(dataSize, iterations) {\r\n  const data = generateTestData(dataSize);\r\n  const structures = prepareDataStructures(data);\r\n\r\n  const structureTypes = ['array', 'map', 'object'];\r\n  const results = {};\r\n  const queryKeys = Array.from({ length: iterations }, () =>\r\n    structures.arr[Math.floor(Math.random() * dataSize)].key\r\n  );\r\n\r\n  structureTypes.forEach(structure => {\r\n    const start = performance.now();\r\n    queryKeys.forEach(key => runQuery(structure, key, structures));\r\n    const end = performance.now();\r\n    results[structure] = end - start;\r\n  });\r\n\r\n  console.log(`Data size: ${dataSize}, Iterations: ${iterations}`);\r\n  structureTypes.forEach(structure => {\r\n    console.log(`${structure}: ${results[structure]}ms`);\r\n  });\r\n  console.log();\r\n}\r\n\r\nconst dataSizes = [10, 100, 1000, 1100, 10000, 100000, 1000000];\r\nconst iterations = 10000;\r\n\r\ndataSizes.forEach(size => runBenchmark(size, iterations));\r\n```\r\n\r\n```\r\nData size: 10, Iterations: 10000\r\narray: 2.747333999999995ms\r\nmap: 0.5214579999999955ms\r\nobject: 0.5284999999999798ms\r\n\r\nData size: 100, Iterations: 10000\r\narray: 3.855249999999984ms\r\nmap: 0.23916599999998311ms\r\nobject: 0.8671249999999873ms\r\n\r\nData size: 1000, Iterations: 10000\r\narray: 12.472582999999986ms\r\nmap: 0.6492920000000026ms\r\nobject: 1.0919159999999977ms\r\n\r\nData size: 1100, Iterations: 10000\r\narray: 14.062583999999987ms\r\nmap: 0.4570840000000089ms\r\nobject: 0.17512499999998ms\r\n\r\nData size: 10000, Iterations: 10000\r\narray: 151.927208ms\r\nmap: 0.3831250000000068ms\r\nobject: 0.30000000000001137ms\r\n\r\nData size: 100000, Iterations: 10000\r\narray: 1890.3527499999998ms\r\nmap: 0.9712919999997212ms\r\nobject: 0.7580419999999322ms\r\n\r\nData size: 1000000, Iterations: 10000\r\narray: 20552.290500000003ms\r\nmap: 7.172417000001587ms\r\nobject: 4.059665999997378ms\r\n```\r\n\r\nFrom the test results, it can be seen that Map and Object are always faster than Array. When the data size exceeds 1000, Object becomes faster than Map.\r\n\r\nI'm not sure if we need to optimize for cases where the data size exceeds 1000. If not, we can simply use Map.",
        "pr_file_module": null
      },
      {
        "comment_id": "1699628662",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13378,
        "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
        "discussion_id": "1694136521",
        "commented_code": "@@ -111,10 +111,13 @@ export class WsAdapter extends AbstractWsAdapter {\n     handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
        "comment_created_at": "2024-08-01T08:10:56+00:00",
        "comment_author": "Theofilos-Chamalis",
        "comment_body": "Hey @CodyTseng , great work on testing this out! \r\n\r\nI believe that the original implementation based on the Map is going to serve well this implementation, since it is a sizeable improvement over using an array. Resolving to an object for larger data sizes is a minor improvement IMHO, since data should be flushed at that point and not hold that many concurrent messages, unless people try to handle a lot of traffic on a single service instance.\r\n\r\nLet me know of your thoughts on this.\r\n\r\nThanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "1699657981",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13378,
        "pr_file": "packages/platform-ws/adapters/ws-adapter.ts",
        "discussion_id": "1694136521",
        "commented_code": "@@ -111,10 +111,13 @@ export class WsAdapter extends AbstractWsAdapter {\n     handlers: MessageMappingProperties[],\n     transform: (data: any) => Observable<any>,\n   ) {\n+    const handlersMap = new Map<string, MessageMappingProperties>();",
        "comment_created_at": "2024-08-01T08:33:24+00:00",
        "comment_author": "CodyTseng",
        "comment_body": "Generally, the number of message handlers does not exceed 100. With this quantity, the performance of the Map is optimal, providing a 5 to 10 times improvement compared to using an Array.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1095436563",
    "pr_number": 11023,
    "pr_file": "packages/core/injector/module-token-factory.ts",
    "created_at": "2023-02-03T07:33:41+00:00",
    "commented_code": "import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';\n import { isFunction, isSymbol } from '@nestjs/common/utils/shared.utils';\n import stringify from 'fast-safe-stringify';\n-import * as hash from 'object-hash';\n+import { createHash } from 'crypto';",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1095436563",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11023,
        "pr_file": "packages/core/injector/module-token-factory.ts",
        "discussion_id": "1095436563",
        "commented_code": "@@ -3,33 +3,51 @@ import { Type } from '@nestjs/common/interfaces/type.interface';\n import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';\n import { isFunction, isSymbol } from '@nestjs/common/utils/shared.utils';\n import stringify from 'fast-safe-stringify';\n-import * as hash from 'object-hash';\n+import { createHash } from 'crypto';",
        "comment_created_at": "2023-02-03T07:33:41+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "Wondering how fast it is compared to @napi-rs/blake-hash 🤔 \r\n\r\nAlso, on a side note, did you have a chance to compare https://github.com/Brooooooklyn/uuid to `@lukeed/uuid` (for generating uuids)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1095685880",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11023,
        "pr_file": "packages/core/injector/module-token-factory.ts",
        "discussion_id": "1095436563",
        "commented_code": "@@ -3,33 +3,51 @@ import { Type } from '@nestjs/common/interfaces/type.interface';\n import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';\n import { isFunction, isSymbol } from '@nestjs/common/utils/shared.utils';\n import stringify from 'fast-safe-stringify';\n-import * as hash from 'object-hash';\n+import { createHash } from 'crypto';",
        "comment_created_at": "2023-02-03T11:12:32+00:00",
        "comment_author": "H4ad",
        "comment_body": "I never tried but I run some benchmarks:\r\n\r\n```\r\nuuid v4 x 17,312,526 ops/sec ±1.17% (91 runs sampled)\r\nuuid v5 x 234,243 ops/sec ±1.20% (87 runs sampled)\r\nsha1 x 502,120 ops/sec ±2.31% (79 runs sampled)\r\nnapi-rs/blake x 495,174 ops/sec ±2.27% (71 runs sampled)\r\nnanoid x 3,418,245 ops/sec ±1.43% (90 runs sampled)\r\nuid x 48,565,650 ops/sec ±1.07% (91 runs sampled)\r\nluuked x 5,012,523 ops/sec ±1.36% (90 runs sampled)\r\nnapi-rs/uuid x 5,499,031 ops/sec ±0.92% (89 runs sampled)\r\nFastest is uid\r\n```\r\n\r\nDon't seem to be faster in our scenario.\r\n\r\n> Benchmark: [perf-nanoid-uuid.benchmark.ts.zip](https://github.com/nestjs/nest/files/10578313/perf-nanoid-uuid.benchmark.ts.zip)\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1095894797",
    "pr_number": 11022,
    "pr_file": "packages/core/router/paths-explorer.ts",
    "created_at": "2023-02-03T14:57:43+00:00",
    "commented_code": "? Object.getPrototypeOf(instance)\n       : prototype;\n \n-    return this.metadataScanner.scanFromPrototype<Controller, RouteDefinition>(\n-      instance,\n-      instancePrototype,\n-      method => this.exploreMethodMetadata(instance, instancePrototype, method),\n-    );\n+    const methods = this.metadataScanner.getAllMethodNames(instancePrototype);\n+\n+    const routes: RouteDefinition[] = [];\n+\n+    for (const methodKey of methods) {\n+      const route = this.exploreMethodMetadata(\n+        instance,\n+        instancePrototype,\n+        methodKey,\n+      );\n+\n+      if (!route) continue;\n+\n+      routes.push(route);\n+    }\n+\n+    return routes;",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1095894797",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11022,
        "pr_file": "packages/core/router/paths-explorer.ts",
        "discussion_id": "1095894797",
        "commented_code": "@@ -33,18 +33,30 @@ export class PathsExplorer {\n       ? Object.getPrototypeOf(instance)\n       : prototype;\n \n-    return this.metadataScanner.scanFromPrototype<Controller, RouteDefinition>(\n-      instance,\n-      instancePrototype,\n-      method => this.exploreMethodMetadata(instance, instancePrototype, method),\n-    );\n+    const methods = this.metadataScanner.getAllMethodNames(instancePrototype);\n+\n+    const routes: RouteDefinition[] = [];\n+\n+    for (const methodKey of methods) {\n+      const route = this.exploreMethodMetadata(\n+        instance,\n+        instancePrototype,\n+        methodKey,\n+      );\n+\n+      if (!route) continue;\n+\n+      routes.push(route);\n+    }\n+\n+    return routes;",
        "comment_created_at": "2023-02-03T14:57:43+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "Why not filter + map? Performance should be marginal in this case (I'd think)",
        "pr_file_module": null
      },
      {
        "comment_id": "1095898021",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11022,
        "pr_file": "packages/core/router/paths-explorer.ts",
        "discussion_id": "1095894797",
        "commented_code": "@@ -33,18 +33,30 @@ export class PathsExplorer {\n       ? Object.getPrototypeOf(instance)\n       : prototype;\n \n-    return this.metadataScanner.scanFromPrototype<Controller, RouteDefinition>(\n-      instance,\n-      instancePrototype,\n-      method => this.exploreMethodMetadata(instance, instancePrototype, method),\n-    );\n+    const methods = this.metadataScanner.getAllMethodNames(instancePrototype);\n+\n+    const routes: RouteDefinition[] = [];\n+\n+    for (const methodKey of methods) {\n+      const route = this.exploreMethodMetadata(\n+        instance,\n+        instancePrototype,\n+        methodKey,\n+      );\n+\n+      if (!route) continue;\n+\n+      routes.push(route);\n+    }\n+\n+    return routes;",
        "comment_created_at": "2023-02-03T15:00:04+00:00",
        "comment_author": "H4ad",
        "comment_body": "To use `.map`, I will also need to use `.filter`.  So I didn't want to introduce two loops, that's why I use `for`.\r\n\r\nAbout the performance, if this method is called often, someone will eventually create a pull request to change `filter` and `map` to a for loop, so I prefer to not introduce a point of optimization in the future if we can do it now.",
        "pr_file_module": null
      },
      {
        "comment_id": "1096062022",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11022,
        "pr_file": "packages/core/router/paths-explorer.ts",
        "discussion_id": "1095894797",
        "commented_code": "@@ -33,18 +33,30 @@ export class PathsExplorer {\n       ? Object.getPrototypeOf(instance)\n       : prototype;\n \n-    return this.metadataScanner.scanFromPrototype<Controller, RouteDefinition>(\n-      instance,\n-      instancePrototype,\n-      method => this.exploreMethodMetadata(instance, instancePrototype, method),\n-    );\n+    const methods = this.metadataScanner.getAllMethodNames(instancePrototype);\n+\n+    const routes: RouteDefinition[] = [];\n+\n+    for (const methodKey of methods) {\n+      const route = this.exploreMethodMetadata(\n+        instance,\n+        instancePrototype,\n+        methodKey,\n+      );\n+\n+      if (!route) continue;\n+\n+      routes.push(route);\n+    }\n+\n+    return routes;",
        "comment_created_at": "2023-02-03T17:26:42+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "Still, the performance impact should be negligible. filter & map is just cleaner & easier to read, not worth the optimization in this particular case ",
        "pr_file_module": null
      },
      {
        "comment_id": "1096534671",
        "repo_full_name": "nestjs/nest",
        "pr_number": 11022,
        "pr_file": "packages/core/router/paths-explorer.ts",
        "discussion_id": "1095894797",
        "commented_code": "@@ -33,18 +33,30 @@ export class PathsExplorer {\n       ? Object.getPrototypeOf(instance)\n       : prototype;\n \n-    return this.metadataScanner.scanFromPrototype<Controller, RouteDefinition>(\n-      instance,\n-      instancePrototype,\n-      method => this.exploreMethodMetadata(instance, instancePrototype, method),\n-    );\n+    const methods = this.metadataScanner.getAllMethodNames(instancePrototype);\n+\n+    const routes: RouteDefinition[] = [];\n+\n+    for (const methodKey of methods) {\n+      const route = this.exploreMethodMetadata(\n+        instance,\n+        instancePrototype,\n+        methodKey,\n+      );\n+\n+      if (!route) continue;\n+\n+      routes.push(route);\n+    }\n+\n+    return routes;",
        "comment_created_at": "2023-02-04T13:07:26+00:00",
        "comment_author": "H4ad",
        "comment_body": "Instead I change `map + filter` to `reduce` which I think is a middle ground between readability and performance.\r\n\r\nAbout the performance:\r\n\r\n```\r\nMetadataScanner#scanFromPrototype x 109,945 ops/sec ±1.63% (88 runs sampled)\r\nBetterMetadataScanner#scanFromPrototype map and filter x 232,174 ops/sec ±2.00% (86 runs sampled)\r\nBetterMetadataScanner#scanFromPrototype reduce x 244,521 ops/sec ±1.50% (89 runs sampled)\r\nBetterMetadataScanner#scanFromPrototype for loop x 246,414 ops/sec ±1.39% (88 runs sampled)\r\nFastest is BetterMetadataScanner#scanFromPrototype for loop,BetterMetadataScanner#scanFromPrototype reduce\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "945332457",
    "pr_number": 10112,
    "pr_file": "packages/core/services/reflector.service.ts",
    "created_at": "2022-08-14T19:24:18+00:00",
    "commented_code": "metadataKey: TKey,\n     targets: (Type<any> | Function)[],\n   ): TResult {\n-    return this.getAll(metadataKey, targets).find(item => item !== undefined);\n+    for (const target of targets) {\n+      const result = this.get(metadataKey, target);\n+      if (result !== undefined) {\n+        return result;\n+      }\n+    }\n+    return undefined;",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "945332457",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10112,
        "pr_file": "packages/core/services/reflector.service.ts",
        "discussion_id": "945332457",
        "commented_code": "@@ -86,6 +86,12 @@ export class Reflector {\n     metadataKey: TKey,\n     targets: (Type<any> | Function)[],\n   ): TResult {\n-    return this.getAll(metadataKey, targets).find(item => item !== undefined);\n+    for (const target of targets) {\n+      const result = this.get(metadataKey, target);\n+      if (result !== undefined) {\n+        return result;\n+      }\n+    }\n+    return undefined;",
        "comment_created_at": "2022-08-14T19:24:18+00:00",
        "comment_author": "jmcdo29",
        "comment_body": "If you're going to refactor this to a raw for loop, we should do the same to the `getAll` for squeezing as much performance out as we can. \r\n\r\nSide note: do you have any benchmarks for how much of an improvement this is? Just curious if the improvement is going to be worth the readability ",
        "pr_file_module": null
      },
      {
        "comment_id": "945334497",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10112,
        "pr_file": "packages/core/services/reflector.service.ts",
        "discussion_id": "945332457",
        "commented_code": "@@ -86,6 +86,12 @@ export class Reflector {\n     metadataKey: TKey,\n     targets: (Type<any> | Function)[],\n   ): TResult {\n-    return this.getAll(metadataKey, targets).find(item => item !== undefined);\n+    for (const target of targets) {\n+      const result = this.get(metadataKey, target);\n+      if (result !== undefined) {\n+        return result;\n+      }\n+    }\n+    return undefined;",
        "comment_created_at": "2022-08-14T19:46:17+00:00",
        "comment_author": "zanminkian",
        "comment_body": "I think raw for loop is not the mainly reason. Just break the loop earlier to increase the performance.",
        "pr_file_module": null
      },
      {
        "comment_id": "945335695",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10112,
        "pr_file": "packages/core/services/reflector.service.ts",
        "discussion_id": "945332457",
        "commented_code": "@@ -86,6 +86,12 @@ export class Reflector {\n     metadataKey: TKey,\n     targets: (Type<any> | Function)[],\n   ): TResult {\n-    return this.getAll(metadataKey, targets).find(item => item !== undefined);\n+    for (const target of targets) {\n+      const result = this.get(metadataKey, target);\n+      if (result !== undefined) {\n+        return result;\n+      }\n+    }\n+    return undefined;",
        "comment_created_at": "2022-08-14T19:57:54+00:00",
        "comment_author": "zanminkian",
        "comment_body": "Seems not increase too much. This is a choice between a little performance and readability. :P\r\n```ts\r\nfunction get(num) {\r\n    for(let i = 0; i < 100; i++) {\r\n        num++\r\n    }\r\n    return num\r\n}\r\n\r\nfunction test1() {\r\n    const start = process.hrtime.bigint();\r\n    for(let i = 0; i< 10000; i++) {\r\n        const targets = [100, 1000, 10000]\r\n        targets.map(target=>get(target)).find(item => item !== undefined)\r\n    }\r\n    console.log(process.hrtime.bigint()-start);\r\n}\r\n\r\nfunction test2() {\r\n    const start = process.hrtime.bigint();\r\n    for(let i = 0; i< 10000; i++) {\r\n        const targets = [100, 1000, 10000]\r\n        for(const target of targets) {\r\n            const res = get(target)\r\n            if(res !== undefined) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    console.log(process.hrtime.bigint()-start);\r\n}\r\n\r\nfunction test3() {\r\n    const start = process.hrtime.bigint();\r\n    for(let i = 0; i< 10000; i++) {\r\n        const targets = [100, 1000, 10000]\r\n        for(const target of targets) {\r\n            const res = get(target)\r\n            if(res !== undefined) {\r\n                // break;\r\n            }\r\n        }\r\n    }\r\n    console.log(process.hrtime.bigint()-start);\r\n}\r\n\r\ntest1() // 119022900n\r\ntest2() // 4902500n\r\ntest3() // 7564600n\r\n```",
        "pr_file_module": null
      }
    ]
  }
]