[
  {
    "discussion_id": "1540122387",
    "pr_number": 13327,
    "pr_file": "sample/04-grpc/server/src/helloworld/helloworld.controller.ts",
    "created_at": "2024-03-26T21:16:19+00:00",
    "commented_code": "+// https://github.com/grpc/grpc-node/blob/master/examples/error_handling/server.js\n+import { Controller } from '@nestjs/common';\n+import { GrpcMethod, RpcException } from '@nestjs/microservices';\n+import { Observable, ReplaySubject } from 'rxjs';\n+import {\n+  GreeterController,\n+  HelloReply,\n+  HelloRequest,\n+} from '../interface/helloworld';\n+import * as grpc from '@grpc/grpc-js';\n+\n+@Controller()\n+export class HelloworldController implements GreeterController {\n+  private readonly REPLY_COUNT = 5;\n+\n+  @GrpcMethod('Greeter', 'sayHello')\n+  sayHello(request: HelloRequest): HelloReply {\n+    if (request.name === '') {\n+      throw new RpcException({\n+        code: grpc.status.INVALID_ARGUMENT,\n+        message: 'request missing required field: name',\n+      });\n+    }\n+\n+    return {\n+      message: 'Hello ' + request.name,\n+    };\n+  }\n+\n+  @GrpcMethod('Greeter', 'sayHelloStreamReply')\n+  sayHelloStreamReply(request: HelloRequest): Observable<HelloReply> {\n+    const hero$ = new ReplaySubject<HelloReply>();\n+\n+    if (request.name === '') {\n+      hero$.error(\n+        new RpcException({\n+          code: grpc.status.INVALID_ARGUMENT,\n+          message: 'request missing required field: name',\n+        }),\n+      );\n+\n+      return hero$.asObservable();\n+    }\n+\n+    for (let i = 0; i < this.REPLY_COUNT; i++) {\n+      hero$.next({ message: 'Hello ' + request.name });\n+    }\n+    hero$.complete();\n+\n+    return hero$.asObservable();\n+  }",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1540122387",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13327,
        "pr_file": "sample/04-grpc/server/src/helloworld/helloworld.controller.ts",
        "discussion_id": "1540122387",
        "commented_code": "@@ -0,0 +1,52 @@\n+// https://github.com/grpc/grpc-node/blob/master/examples/error_handling/server.js\n+import { Controller } from '@nestjs/common';\n+import { GrpcMethod, RpcException } from '@nestjs/microservices';\n+import { Observable, ReplaySubject } from 'rxjs';\n+import {\n+  GreeterController,\n+  HelloReply,\n+  HelloRequest,\n+} from '../interface/helloworld';\n+import * as grpc from '@grpc/grpc-js';\n+\n+@Controller()\n+export class HelloworldController implements GreeterController {\n+  private readonly REPLY_COUNT = 5;\n+\n+  @GrpcMethod('Greeter', 'sayHello')\n+  sayHello(request: HelloRequest): HelloReply {\n+    if (request.name === '') {\n+      throw new RpcException({\n+        code: grpc.status.INVALID_ARGUMENT,\n+        message: 'request missing required field: name',\n+      });\n+    }\n+\n+    return {\n+      message: 'Hello ' + request.name,\n+    };\n+  }\n+\n+  @GrpcMethod('Greeter', 'sayHelloStreamReply')\n+  sayHelloStreamReply(request: HelloRequest): Observable<HelloReply> {\n+    const hero$ = new ReplaySubject<HelloReply>();\n+\n+    if (request.name === '') {\n+      hero$.error(\n+        new RpcException({\n+          code: grpc.status.INVALID_ARGUMENT,\n+          message: 'request missing required field: name',\n+        }),\n+      );\n+\n+      return hero$.asObservable();\n+    }\n+\n+    for (let i = 0; i < this.REPLY_COUNT; i++) {\n+      hero$.next({ message: 'Hello ' + request.name });\n+    }\n+    hero$.complete();\n+\n+    return hero$.asObservable();\n+  }",
        "comment_created_at": "2024-03-26T21:16:19+00:00",
        "comment_author": "ssilve1989",
        "comment_body": "Why is this using a ReplaySubject? This can be written in multiple other ways without the need of a ReplaySubject. The most concise of which would be \r\n```ts\r\n  sayHelloStreamReply({ name }: HelloRequest): Observable<HelloReply> {\r\n    if (!name) {\r\n      throw new RpcException({\r\n        code: status.INVALID_ARGUMENT,\r\n        message: 'request missing required field: name',\r\n      });\r\n    }\r\n\r\n    return of({ message: `Hello ${name}` }).pipe(repeat(this.REPLY_COUNT));\r\n  }\r\n  ```\r\n\r\nbut even, so I would caution showing an example of streaming synchronous replies like this. When the list of emissions is sufficiently large this can block the event loop writing out all the messages not allowing anything else to occur. This often results in health check failures in environments like kubernetes. Ideally each emission is written out asynchronously which can be achieved with `scheduled` and an async scheduler. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1541340902",
        "repo_full_name": "nestjs/nest",
        "pr_number": 13327,
        "pr_file": "sample/04-grpc/server/src/helloworld/helloworld.controller.ts",
        "discussion_id": "1540122387",
        "commented_code": "@@ -0,0 +1,52 @@\n+// https://github.com/grpc/grpc-node/blob/master/examples/error_handling/server.js\n+import { Controller } from '@nestjs/common';\n+import { GrpcMethod, RpcException } from '@nestjs/microservices';\n+import { Observable, ReplaySubject } from 'rxjs';\n+import {\n+  GreeterController,\n+  HelloReply,\n+  HelloRequest,\n+} from '../interface/helloworld';\n+import * as grpc from '@grpc/grpc-js';\n+\n+@Controller()\n+export class HelloworldController implements GreeterController {\n+  private readonly REPLY_COUNT = 5;\n+\n+  @GrpcMethod('Greeter', 'sayHello')\n+  sayHello(request: HelloRequest): HelloReply {\n+    if (request.name === '') {\n+      throw new RpcException({\n+        code: grpc.status.INVALID_ARGUMENT,\n+        message: 'request missing required field: name',\n+      });\n+    }\n+\n+    return {\n+      message: 'Hello ' + request.name,\n+    };\n+  }\n+\n+  @GrpcMethod('Greeter', 'sayHelloStreamReply')\n+  sayHelloStreamReply(request: HelloRequest): Observable<HelloReply> {\n+    const hero$ = new ReplaySubject<HelloReply>();\n+\n+    if (request.name === '') {\n+      hero$.error(\n+        new RpcException({\n+          code: grpc.status.INVALID_ARGUMENT,\n+          message: 'request missing required field: name',\n+        }),\n+      );\n+\n+      return hero$.asObservable();\n+    }\n+\n+    for (let i = 0; i < this.REPLY_COUNT; i++) {\n+      hero$.next({ message: 'Hello ' + request.name });\n+    }\n+    hero$.complete();\n+\n+    return hero$.asObservable();\n+  }",
        "comment_created_at": "2024-03-27T15:26:31+00:00",
        "comment_author": "youngkiu",
        "comment_body": "Thank you for the code review and suggestions.\r\nI hope the sample code will greatly help developers using nest & grpc.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1871356863",
    "pr_number": 14278,
    "pr_file": "packages/core/middleware/middleware-module.ts",
    "created_at": "2024-12-05T13:08:12+00:00",
    "commented_code": "configurable: false,\n       });\n \n-      const requestProviderValue = isTreeDurable\n-        ? contextId.payload\n-        : Object.assign(request, contextId.payload);\n+      const requestProviderValue = Object.assign(request, contextId.payload);",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1871356863",
        "repo_full_name": "nestjs/nest",
        "pr_number": 14278,
        "pr_file": "packages/core/middleware/middleware-module.ts",
        "discussion_id": "1871356863",
        "commented_code": "@@ -346,9 +346,7 @@ export class MiddlewareModule<\n         configurable: false,\n       });\n \n-      const requestProviderValue = isTreeDurable\n-        ? contextId.payload\n-        : Object.assign(request, contextId.payload);\n+      const requestProviderValue = Object.assign(request, contextId.payload);",
        "comment_created_at": "2024-12-05T13:08:12+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "I think I misunderstood what this FR was about.\r\n\r\nDurable providers should not have access to the request-specific attributes (we shouldn't merge the payload with the request) simply because they are **durable** (meaning they are not removed after the request is finished processing). Merging the payload with request objects for durable providers will lead to memory leaks and unexpected behavior of the framework",
        "pr_file_module": null
      },
      {
        "comment_id": "1872550796",
        "repo_full_name": "nestjs/nest",
        "pr_number": 14278,
        "pr_file": "packages/core/middleware/middleware-module.ts",
        "discussion_id": "1871356863",
        "commented_code": "@@ -346,9 +346,7 @@ export class MiddlewareModule<\n         configurable: false,\n       });\n \n-      const requestProviderValue = isTreeDurable\n-        ? contextId.payload\n-        : Object.assign(request, contextId.payload);\n+      const requestProviderValue = Object.assign(request, contextId.payload);",
        "comment_created_at": "2024-12-06T04:21:23+00:00",
        "comment_author": "chiliman-oOo",
        "comment_body": "hmm, I understand  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1017675918",
    "pr_number": 10545,
    "pr_file": "packages/websockets/context/ws-context-creator.ts",
    "created_at": "2022-11-09T09:24:24+00:00",
    "commented_code": "};\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1017675918",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T09:24:24+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "```suggestion\r\n      Object.assign(args[0] ?? {}, {\r\n        getPattern: () => this.reflectCallbackPattern(callback),\r\n      });\r\n```\r\nHmm.. I'm wondering if this won't cause some unexpected issues 🤔 If socket represents a single connection (and so its instance object is shared?), there's a probability that 2 messages from that socket might be processed asynchronously (independently). \r\n\r\nExample:\r\n- Connection to server is established (socket instance is created)\r\n- Message A is emitted \r\n  - we mutate the \"socket instance\" enhancing it with the \"getPattern()\" method\r\n  - before this message is processed, some asynchronous operation is triggered in (guard/interceptor/wherever)\r\n- In the meantime, message B is emitted\r\n  - we mutate the same \"socket instance\" again replacing the previous \"getPattern()\" method\r\n- Async operation (mentioned above) completes and we're back to processing message A.\r\n- In another interceptor/guard we call `client.getPattern()` when processing message A but it's already overridden with the message B's \"getPattern\" implementation\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1018213882",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T17:16:30+00:00",
        "comment_author": "jmcdo29",
        "comment_body": "Rather than mutating the client, could I add a new `args` entry and let `getPattern()` retrieve `args[2]`? Would that be more \"stable\"? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1018382554",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T20:26:42+00:00",
        "comment_author": "jmcdo29",
        "comment_body": "Great call by the way! I moved `getPattern` to be a method on `WsArgumentHost` instead of under the `getClient()` so that it should be unique per request as the `WsArgumentHost` already is. Tests are still passing and the interfaces are updated. Let me know if you think of any other issues with this approach :smile_cat:",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "770285314",
    "pr_number": 8796,
    "pr_file": "packages/microservices/client/client-kafka.ts",
    "created_at": "2021-12-16T07:35:09+00:00",
    "commented_code": "const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "770285314",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-16T07:35:09+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "If someone unsubscribes before this promise resolves, a memory leak would occur (`this.routingMap.set(packet.id, callback);`)",
        "pr_file_module": null
      },
      {
        "comment_id": "772730744",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-20T23:31:16+00:00",
        "comment_author": "guiruiz",
        "comment_body": "Yeah, you were right.\r\nI implemented a flag that disables the routingMap inclusion if someone unsubscribes before the promise resolves.\r\n\r\nDon't you think that a memory leak could occur with the current prod code (before these code changes)? ",
        "pr_file_module": null
      },
      {
        "comment_id": "772891587",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-21T07:36:02+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "@guiruiz it wouldn't because `serialize` isn't async and so `this.routingMap.set` is called synchronously.",
        "pr_file_module": null
      },
      {
        "comment_id": "773496642",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-21T23:08:56+00:00",
        "comment_author": "guiruiz",
        "comment_body": "@kamilmysliwiec Hmm, that makes sense, but there is a chance to the route be included in the routingMap and the observer.complete never be called, isn't there? \r\n\r\nBTW, what do you think about my solution to avoid the memory leak in an async approach?",
        "pr_file_module": null
      },
      {
        "comment_id": "773597982",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-22T04:52:33+00:00",
        "comment_author": "guiruiz",
        "comment_body": "@kamilmysliwiec I simplified a bit the solution and wrote a unit test for this scenario.\r\nLet me know your thoughts about it.",
        "pr_file_module": null
      },
      {
        "comment_id": "778554665",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2022-01-05T05:26:51+00:00",
        "comment_author": "guiruiz",
        "comment_body": "Hey @kamilmysliwiec, any thoughts about it? 😄 ",
        "pr_file_module": null
      }
    ]
  }
]