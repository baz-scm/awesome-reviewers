[
  {
    "discussion_id": "1017675918",
    "pr_number": 10545,
    "pr_file": "packages/websockets/context/ws-context-creator.ts",
    "created_at": "2022-11-09T09:24:24+00:00",
    "commented_code": "};\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "1017675918",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T09:24:24+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "```suggestion\r\n      Object.assign(args[0] ?? {}, {\r\n        getPattern: () => this.reflectCallbackPattern(callback),\r\n      });\r\n```\r\nHmm.. I'm wondering if this won't cause some unexpected issues \ud83e\udd14 If socket represents a single connection (and so its instance object is shared?), there's a probability that 2 messages from that socket might be processed asynchronously (independently). \r\n\r\nExample:\r\n- Connection to server is established (socket instance is created)\r\n- Message A is emitted \r\n  - we mutate the \"socket instance\" enhancing it with the \"getPattern()\" method\r\n  - before this message is processed, some asynchronous operation is triggered in (guard/interceptor/wherever)\r\n- In the meantime, message B is emitted\r\n  - we mutate the same \"socket instance\" again replacing the previous \"getPattern()\" method\r\n- Async operation (mentioned above) completes and we're back to processing message A.\r\n- In another interceptor/guard we call `client.getPattern()` when processing message A but it's already overridden with the message B's \"getPattern\" implementation\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1018213882",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T17:16:30+00:00",
        "comment_author": "jmcdo29",
        "comment_body": "Rather than mutating the client, could I add a new `args` entry and let `getPattern()` retrieve `args[2]`? Would that be more \"stable\"? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1018382554",
        "repo_full_name": "nestjs/nest",
        "pr_number": 10545,
        "pr_file": "packages/websockets/context/ws-context-creator.ts",
        "discussion_id": "1017675918",
        "commented_code": "@@ -109,6 +108,9 @@ export class WsContextCreator {\n     };\n \n     return this.wsProxy.create(async (...args: unknown[]) => {\n+      Object.assign(args[0] ?? {}, {\n+        getPattern: () => this.reflectCallbackPattern(callback),\n+      });",
        "comment_created_at": "2022-11-09T20:26:42+00:00",
        "comment_author": "jmcdo29",
        "comment_body": "Great call by the way! I moved `getPattern` to be a method on `WsArgumentHost` instead of under the `getClient()` so that it should be unique per request as the `WsArgumentHost` already is. Tests are still passing and the interfaces are updated. Let me know if you think of any other issues with this approach :smile_cat:",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "770285314",
    "pr_number": 8796,
    "pr_file": "packages/microservices/client/client-kafka.ts",
    "created_at": "2021-12-16T07:35:09+00:00",
    "commented_code": "const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "770285314",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-16T07:35:09+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "If someone unsubscribes before this promise resolves, a memory leak would occur (`this.routingMap.set(packet.id, callback);`)",
        "pr_file_module": null
      },
      {
        "comment_id": "772730744",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-20T23:31:16+00:00",
        "comment_author": "guiruiz",
        "comment_body": "Yeah, you were right.\r\nI implemented a flag that disables the routingMap inclusion if someone unsubscribes before the promise resolves.\r\n\r\nDon't you think that a memory leak could occur with the current prod code (before these code changes)? ",
        "pr_file_module": null
      },
      {
        "comment_id": "772891587",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-21T07:36:02+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "@guiruiz it wouldn't because `serialize` isn't async and so `this.routingMap.set` is called synchronously.",
        "pr_file_module": null
      },
      {
        "comment_id": "773496642",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-21T23:08:56+00:00",
        "comment_author": "guiruiz",
        "comment_body": "@kamilmysliwiec Hmm, that makes sense, but there is a chance to the route be included in the routingMap and the observer.complete never be called, isn't there? \r\n\r\nBTW, what do you think about my solution to avoid the memory leak in an async approach?",
        "pr_file_module": null
      },
      {
        "comment_id": "773597982",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2021-12-22T04:52:33+00:00",
        "comment_author": "guiruiz",
        "comment_body": "@kamilmysliwiec I simplified a bit the solution and wrote a unit test for this scenario.\r\nLet me know your thoughts about it.",
        "pr_file_module": null
      },
      {
        "comment_id": "778554665",
        "repo_full_name": "nestjs/nest",
        "pr_number": 8796,
        "pr_file": "packages/microservices/client/client-kafka.ts",
        "discussion_id": "770285314",
        "commented_code": "@@ -222,23 +223,27 @@ export class ClientKafka extends ClientProxy {\n       const replyTopic = this.getResponsePatternName(pattern);\n       const replyPartition = this.getReplyTopicPartition(replyTopic);\n \n-      const serializedPacket: KafkaRequest = this.serializer.serialize(\n-        packet.data,\n-      );\n-      serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n-      serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n-      serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] = replyPartition;\n-\n-      this.routingMap.set(packet.id, callback);\n-\n-      const message = Object.assign(\n-        {\n-          topic: pattern,\n-          messages: [serializedPacket],\n-        },\n-        this.options.send || {},\n-      );\n-      this.producer.send(message).catch(err => callback({ err }));\n+      this.serializer\n+        .serialize(packet.data)\n+        .then((serializedPacket: KafkaRequest) => {\n+          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;\n+          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;\n+          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =\n+            replyPartition;\n+\n+          this.routingMap.set(packet.id, callback);",
        "comment_created_at": "2022-01-05T05:26:51+00:00",
        "comment_author": "guiruiz",
        "comment_body": "Hey @kamilmysliwiec, any thoughts about it? \ud83d\ude04 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "328693992",
    "pr_number": 3012,
    "pr_file": "packages/core/middleware/middleware-module.ts",
    "created_at": "2019-09-26T15:53:23+00:00",
    "commented_code": "undefined,\n       contextId,\n     );\n-    const middleware = instance.use.bind(instance);\n+    const middleware = (req, res, next) => {\n+      const stack: Set<NestMiddleware> = req.stack || new Set();\n+      if (!stack.has(instance)) {\n+        stack.add(instance);\n+        req.stack = stack;\n+        instance.use.apply(instance, [req, res, next]);",
    "repo_full_name": "nestjs/nest",
    "discussion_comments": [
      {
        "comment_id": "328693992",
        "repo_full_name": "nestjs/nest",
        "pr_number": 3012,
        "pr_file": "packages/core/middleware/middleware-module.ts",
        "discussion_id": "328693992",
        "commented_code": "@@ -256,7 +256,16 @@ export class MiddlewareModule {\n       undefined,\n       contextId,\n     );\n-    const middleware = instance.use.bind(instance);\n+    const middleware = (req, res, next) => {\n+      const stack: Set<NestMiddleware> = req.stack || new Set();\n+      if (!stack.has(instance)) {\n+        stack.add(instance);\n+        req.stack = stack;\n+        instance.use.apply(instance, [req, res, next]);",
        "comment_created_at": "2019-09-26T15:53:23+00:00",
        "comment_author": "kamilmysliwiec",
        "comment_body": "If someone applies 1 middleware multiple times, we should run it multiple times = no side-effects.",
        "pr_file_module": null
      }
    ]
  }
]