[
  {
    "discussion_id": "2146758528",
    "pr_number": 15360,
    "pr_file": "transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java",
    "created_at": "2025-06-14T08:39:26+00:00",
    "commented_code": "return addFirst(null, name, handler);\n     }\n \n-    private enum AddStrategy {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2146758528",
        "repo_full_name": "netty/netty",
        "pr_number": 15360,
        "pr_file": "transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java",
        "discussion_id": "2146758528",
        "commented_code": "@@ -151,16 +156,9 @@ public final ChannelPipeline addFirst(String name, ChannelHandler handler) {\n         return addFirst(null, name, handler);\n     }\n \n-    private enum AddStrategy {",
        "comment_created_at": "2025-06-14T08:39:26+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "hmm.. I think the enum is actually better and more clear then static ints. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2146795773",
        "repo_full_name": "netty/netty",
        "pr_number": 15360,
        "pr_file": "transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java",
        "discussion_id": "2146758528",
        "commented_code": "@@ -151,16 +156,9 @@ public final ChannelPipeline addFirst(String name, ChannelHandler handler) {\n         return addFirst(null, name, handler);\n     }\n \n-    private enum AddStrategy {",
        "comment_created_at": "2025-06-14T09:37:57+00:00",
        "comment_author": "He-Pin",
        "comment_body": "that true, because Java doesn't have opaque type",
        "pr_file_module": null
      },
      {
        "comment_id": "2147005474",
        "repo_full_name": "netty/netty",
        "pr_number": 15360,
        "pr_file": "transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java",
        "discussion_id": "2146758528",
        "commented_code": "@@ -151,16 +156,9 @@ public final ChannelPipeline addFirst(String name, ChannelHandler handler) {\n         return addFirst(null, name, handler);\n     }\n \n-    private enum AddStrategy {",
        "comment_created_at": "2025-06-14T15:40:12+00:00",
        "comment_author": "doom369",
        "comment_body": "- enum class consumes meta space\r\n- takes time to load a class\r\n- every enum entry is an actual object, that costs RAM\r\n- switch over int is faster than switch over enum, so saves few CPU cycles on pipeline creation\r\n\r\nAs it is used only in 1 method and not publicly exposed, the enum usage is not justified imho. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164706622",
    "pr_number": 15401,
    "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestCompressor.java",
    "created_at": "2025-06-24T19:03:57+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.compression.Brotli;\n+import io.netty.handler.codec.compression.BrotliEncoder;\n+import io.netty.handler.codec.compression.BrotliOptions;\n+import io.netty.handler.codec.compression.CompressionOptions;\n+import io.netty.handler.codec.compression.DeflateOptions;\n+import io.netty.handler.codec.compression.GzipOptions;\n+import io.netty.handler.codec.compression.SnappyFrameEncoder;\n+import io.netty.handler.codec.compression.StandardCompressionOptions;\n+import io.netty.handler.codec.compression.ZlibCodecFactory;\n+import io.netty.handler.codec.compression.ZlibWrapper;\n+import io.netty.handler.codec.compression.Zstd;\n+import io.netty.handler.codec.compression.ZstdEncoder;\n+import io.netty.handler.codec.compression.ZstdOptions;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A {@code ChannelOutboundHandler} that encodes (compresses) the body of HTTP-Requests using the given encoding.\n+ * <p>\n+ * <b>Supported encodings:</b>\n+ * <ul>\n+ * <li>gzip (default)</li>\n+ * <li>deflate</li>\n+ * <li>snappy</li>\n+ * <li>br (depends on \"com.aayushatharva.brotli4j:brotli4j\")</li>\n+ * <li>zstd (depends on \"com.github.luben:zstd-jni\")r</li>\n+ * </ul>\n+ * <p>\n+ * <b>Note for zstd:</b>\n+ * <a href=\"https://github.com/netty/netty/issues/15340\">\n+ * you should define a threshold that is greater or equal to the configured block size</a>.\n+ * <p>\n+ * <b>How-To Use</b>\n+ * <p>\n+ * For each new connection, add the handler to the end of the user pipeline.\n+ * <pre>\n+ * HttpClient\n+ *   .create()\n+ *   // add the handler\n+ *   .observe((con, newState) -> {\n+ *     // use CONFIGURED for HTTP/1.1 connections\n+ *     // use STREAM_CONFIGURED for HTTP/2 connections\n+ *     if (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED) {\n+ *       con.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\n+ *     }\n+ *   })\n+ *   .build();\n+ * </pre>\n+ */\n+public class HttpRequestCompressor extends ChannelOutboundHandlerAdapter {\n+\n+    /**\n+     * default encoding. used if no preferred encoding is set or it is not available.\n+     */\n+    public static final String DEFAULT_ENCODING = \"gzip\";\n+    private static final List<String> SUPPORTED_ENCODINGS = Arrays.asList(new String[] {\n+        \"br\",\n+        \"zstd\",\n+        \"snappy\",\n+        \"deflate\",\n+        \"gzip\"\n+    });\n+    private static final InternalLogger log = InternalLoggerFactory.getInstance(HttpRequestCompressor.class);\n+    private final int contentSizeThreshold;\n+    private final String encoding;\n+    private final Supplier<MessageToByteEncoder<ByteBuf>> encoderFactory;\n+    private EmbeddedChannel encoderChannel;\n+\n+    /**\n+     * new instance using the defaults.\n+     * shortcut for {@code new HttpRequestCompressor(DEFAULT_ENCODING)}\n+     * @see #DEFAULT_ENCODING\n+     * @see #HttpRequestCompressor(java.lang.String)\n+     */\n+    public HttpRequestCompressor() {\n+        this(DEFAULT_ENCODING);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, 0)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @see #HttpRequestCompressor(java.lang.String, int)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding) {\n+        this(preferredEncoding, 0);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding and the given threshold.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, contentSizeThreshold, null)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @see #HttpRequestCompressor(java.lang.String, int, io.netty.handler.codec.compression.CompressionOptions...)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold) {\n+        this(preferredEncoding, contentSizeThreshold, (CompressionOptions[]) null);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding, threshold and compression options.\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @param compressionOptions the desired compression options to use.\n+     * if {@code null} or empty, the defaults will be used.\n+     * @see StandardCompressionOptions#brotli() default brotli options\n+     * @see StandardCompressionOptions#gzip() default gzip options\n+     * @see StandardCompressionOptions#zstd() default zstd options\n+     * @see StandardCompressionOptions#deflate() default deflate options\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold,\n+            CompressionOptions... compressionOptions) {\n+        ObjectUtil.checkNonEmpty(preferredEncoding, \"preferredEncoding\");\n+        this.contentSizeThreshold = ObjectUtil.\n+                checkPositiveOrZero(contentSizeThreshold, \"contentSizeThreshold\");\n+\n+        if (!SUPPORTED_ENCODINGS.contains(preferredEncoding)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unsupported encoding %s. Supported encodings are: %s\",\n+                            preferredEncoding, StringUtil.join(\",\", SUPPORTED_ENCODINGS)));\n+        }\n+\n+        GzipOptions gzipOptions = null;\n+        DeflateOptions deflateOptions = null;\n+        BrotliOptions brotliOptions = null;\n+        ZstdOptions zstdOptions = null;\n+        for (CompressionOptions compressionOption : Optional.ofNullable(compressionOptions)\n+                .orElseGet(() -> new CompressionOptions[0])) {\n+            if (compressionOption instanceof BrotliOptions) {\n+                brotliOptions = (BrotliOptions) compressionOption;\n+            } else if (compressionOption instanceof GzipOptions) {\n+                gzipOptions = (GzipOptions) compressionOption;\n+            } else if (compressionOption instanceof DeflateOptions) {\n+                deflateOptions = (DeflateOptions) compressionOption;\n+            } else if (compressionOption instanceof ZstdOptions) {\n+                zstdOptions = (ZstdOptions) compressionOption;\n+            } else {\n+                log.info(\"ignoring unsupported compression option {}\",\n+                        compressionOption != null ? compressionOption.getClass() : \"null\");\n+            }\n+        }\n+\n+        if (\"br\".equals(preferredEncoding) && Brotli.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final BrotliOptions opts = Optional.ofNullable(brotliOptions)\n+                    .orElseGet(StandardCompressionOptions::brotli);\n+            encoderFactory = () -> new BrotliEncoder(opts.parameters(), false);\n+        } else if (\"zstd\".equals(preferredEncoding) && Zstd.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final ZstdOptions opts = Optional.ofNullable(zstdOptions)\n+                    .orElseGet(StandardCompressionOptions::zstd);\n+            encoderFactory = () -> new ZstdEncoder(opts.compressionLevel(), opts.blockSize(), opts.maxEncodeSize());\n+        } else if (\"snappy\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            encoderFactory = SnappyFrameEncoder::new;\n+        } else if (\"deflate\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            final DeflateOptions opts = Optional.ofNullable(deflateOptions)\n+                    .orElseGet(StandardCompressionOptions::deflate);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.ZLIB, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        } else {\n+            encoding = DEFAULT_ENCODING;\n+            final GzipOptions opts = Optional.ofNullable(gzipOptions)\n+                    .orElseGet(StandardCompressionOptions::gzip);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.GZIP, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        }\n+        if (!preferredEncoding.equals(encoding)) {\n+            log.info(\"preferred encoding {} not available, using {} as default\", preferredEncoding, encoding);\n+        }\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        if (encoderChannel != null) {\n+            throw new IllegalStateException(\"handler already added\");\n+        }\n+        encoderChannel = new EmbeddedChannel(",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2164706622",
        "repo_full_name": "netty/netty",
        "pr_number": 15401,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestCompressor.java",
        "discussion_id": "2164706622",
        "commented_code": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.compression.Brotli;\n+import io.netty.handler.codec.compression.BrotliEncoder;\n+import io.netty.handler.codec.compression.BrotliOptions;\n+import io.netty.handler.codec.compression.CompressionOptions;\n+import io.netty.handler.codec.compression.DeflateOptions;\n+import io.netty.handler.codec.compression.GzipOptions;\n+import io.netty.handler.codec.compression.SnappyFrameEncoder;\n+import io.netty.handler.codec.compression.StandardCompressionOptions;\n+import io.netty.handler.codec.compression.ZlibCodecFactory;\n+import io.netty.handler.codec.compression.ZlibWrapper;\n+import io.netty.handler.codec.compression.Zstd;\n+import io.netty.handler.codec.compression.ZstdEncoder;\n+import io.netty.handler.codec.compression.ZstdOptions;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A {@code ChannelOutboundHandler} that encodes (compresses) the body of HTTP-Requests using the given encoding.\n+ * <p>\n+ * <b>Supported encodings:</b>\n+ * <ul>\n+ * <li>gzip (default)</li>\n+ * <li>deflate</li>\n+ * <li>snappy</li>\n+ * <li>br (depends on \"com.aayushatharva.brotli4j:brotli4j\")</li>\n+ * <li>zstd (depends on \"com.github.luben:zstd-jni\")r</li>\n+ * </ul>\n+ * <p>\n+ * <b>Note for zstd:</b>\n+ * <a href=\"https://github.com/netty/netty/issues/15340\">\n+ * you should define a threshold that is greater or equal to the configured block size</a>.\n+ * <p>\n+ * <b>How-To Use</b>\n+ * <p>\n+ * For each new connection, add the handler to the end of the user pipeline.\n+ * <pre>\n+ * HttpClient\n+ *   .create()\n+ *   // add the handler\n+ *   .observe((con, newState) -> {\n+ *     // use CONFIGURED for HTTP/1.1 connections\n+ *     // use STREAM_CONFIGURED for HTTP/2 connections\n+ *     if (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED) {\n+ *       con.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\n+ *     }\n+ *   })\n+ *   .build();\n+ * </pre>\n+ */\n+public class HttpRequestCompressor extends ChannelOutboundHandlerAdapter {\n+\n+    /**\n+     * default encoding. used if no preferred encoding is set or it is not available.\n+     */\n+    public static final String DEFAULT_ENCODING = \"gzip\";\n+    private static final List<String> SUPPORTED_ENCODINGS = Arrays.asList(new String[] {\n+        \"br\",\n+        \"zstd\",\n+        \"snappy\",\n+        \"deflate\",\n+        \"gzip\"\n+    });\n+    private static final InternalLogger log = InternalLoggerFactory.getInstance(HttpRequestCompressor.class);\n+    private final int contentSizeThreshold;\n+    private final String encoding;\n+    private final Supplier<MessageToByteEncoder<ByteBuf>> encoderFactory;\n+    private EmbeddedChannel encoderChannel;\n+\n+    /**\n+     * new instance using the defaults.\n+     * shortcut for {@code new HttpRequestCompressor(DEFAULT_ENCODING)}\n+     * @see #DEFAULT_ENCODING\n+     * @see #HttpRequestCompressor(java.lang.String)\n+     */\n+    public HttpRequestCompressor() {\n+        this(DEFAULT_ENCODING);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, 0)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @see #HttpRequestCompressor(java.lang.String, int)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding) {\n+        this(preferredEncoding, 0);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding and the given threshold.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, contentSizeThreshold, null)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @see #HttpRequestCompressor(java.lang.String, int, io.netty.handler.codec.compression.CompressionOptions...)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold) {\n+        this(preferredEncoding, contentSizeThreshold, (CompressionOptions[]) null);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding, threshold and compression options.\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @param compressionOptions the desired compression options to use.\n+     * if {@code null} or empty, the defaults will be used.\n+     * @see StandardCompressionOptions#brotli() default brotli options\n+     * @see StandardCompressionOptions#gzip() default gzip options\n+     * @see StandardCompressionOptions#zstd() default zstd options\n+     * @see StandardCompressionOptions#deflate() default deflate options\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold,\n+            CompressionOptions... compressionOptions) {\n+        ObjectUtil.checkNonEmpty(preferredEncoding, \"preferredEncoding\");\n+        this.contentSizeThreshold = ObjectUtil.\n+                checkPositiveOrZero(contentSizeThreshold, \"contentSizeThreshold\");\n+\n+        if (!SUPPORTED_ENCODINGS.contains(preferredEncoding)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unsupported encoding %s. Supported encodings are: %s\",\n+                            preferredEncoding, StringUtil.join(\",\", SUPPORTED_ENCODINGS)));\n+        }\n+\n+        GzipOptions gzipOptions = null;\n+        DeflateOptions deflateOptions = null;\n+        BrotliOptions brotliOptions = null;\n+        ZstdOptions zstdOptions = null;\n+        for (CompressionOptions compressionOption : Optional.ofNullable(compressionOptions)\n+                .orElseGet(() -> new CompressionOptions[0])) {\n+            if (compressionOption instanceof BrotliOptions) {\n+                brotliOptions = (BrotliOptions) compressionOption;\n+            } else if (compressionOption instanceof GzipOptions) {\n+                gzipOptions = (GzipOptions) compressionOption;\n+            } else if (compressionOption instanceof DeflateOptions) {\n+                deflateOptions = (DeflateOptions) compressionOption;\n+            } else if (compressionOption instanceof ZstdOptions) {\n+                zstdOptions = (ZstdOptions) compressionOption;\n+            } else {\n+                log.info(\"ignoring unsupported compression option {}\",\n+                        compressionOption != null ? compressionOption.getClass() : \"null\");\n+            }\n+        }\n+\n+        if (\"br\".equals(preferredEncoding) && Brotli.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final BrotliOptions opts = Optional.ofNullable(brotliOptions)\n+                    .orElseGet(StandardCompressionOptions::brotli);\n+            encoderFactory = () -> new BrotliEncoder(opts.parameters(), false);\n+        } else if (\"zstd\".equals(preferredEncoding) && Zstd.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final ZstdOptions opts = Optional.ofNullable(zstdOptions)\n+                    .orElseGet(StandardCompressionOptions::zstd);\n+            encoderFactory = () -> new ZstdEncoder(opts.compressionLevel(), opts.blockSize(), opts.maxEncodeSize());\n+        } else if (\"snappy\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            encoderFactory = SnappyFrameEncoder::new;\n+        } else if (\"deflate\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            final DeflateOptions opts = Optional.ofNullable(deflateOptions)\n+                    .orElseGet(StandardCompressionOptions::deflate);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.ZLIB, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        } else {\n+            encoding = DEFAULT_ENCODING;\n+            final GzipOptions opts = Optional.ofNullable(gzipOptions)\n+                    .orElseGet(StandardCompressionOptions::gzip);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.GZIP, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        }\n+        if (!preferredEncoding.equals(encoding)) {\n+            log.info(\"preferred encoding {} not available, using {} as default\", preferredEncoding, encoding);\n+        }\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        if (encoderChannel != null) {\n+            throw new IllegalStateException(\"handler already added\");\n+        }\n+        encoderChannel = new EmbeddedChannel(",
        "comment_created_at": "2025-06-24T19:03:57+00:00",
        "comment_author": "yawkat",
        "comment_body": "this only works for one request",
        "pr_file_module": null
      },
      {
        "comment_id": "2169642824",
        "repo_full_name": "netty/netty",
        "pr_number": 15401,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestCompressor.java",
        "discussion_id": "2164706622",
        "commented_code": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.compression.Brotli;\n+import io.netty.handler.codec.compression.BrotliEncoder;\n+import io.netty.handler.codec.compression.BrotliOptions;\n+import io.netty.handler.codec.compression.CompressionOptions;\n+import io.netty.handler.codec.compression.DeflateOptions;\n+import io.netty.handler.codec.compression.GzipOptions;\n+import io.netty.handler.codec.compression.SnappyFrameEncoder;\n+import io.netty.handler.codec.compression.StandardCompressionOptions;\n+import io.netty.handler.codec.compression.ZlibCodecFactory;\n+import io.netty.handler.codec.compression.ZlibWrapper;\n+import io.netty.handler.codec.compression.Zstd;\n+import io.netty.handler.codec.compression.ZstdEncoder;\n+import io.netty.handler.codec.compression.ZstdOptions;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A {@code ChannelOutboundHandler} that encodes (compresses) the body of HTTP-Requests using the given encoding.\n+ * <p>\n+ * <b>Supported encodings:</b>\n+ * <ul>\n+ * <li>gzip (default)</li>\n+ * <li>deflate</li>\n+ * <li>snappy</li>\n+ * <li>br (depends on \"com.aayushatharva.brotli4j:brotli4j\")</li>\n+ * <li>zstd (depends on \"com.github.luben:zstd-jni\")r</li>\n+ * </ul>\n+ * <p>\n+ * <b>Note for zstd:</b>\n+ * <a href=\"https://github.com/netty/netty/issues/15340\">\n+ * you should define a threshold that is greater or equal to the configured block size</a>.\n+ * <p>\n+ * <b>How-To Use</b>\n+ * <p>\n+ * For each new connection, add the handler to the end of the user pipeline.\n+ * <pre>\n+ * HttpClient\n+ *   .create()\n+ *   // add the handler\n+ *   .observe((con, newState) -> {\n+ *     // use CONFIGURED for HTTP/1.1 connections\n+ *     // use STREAM_CONFIGURED for HTTP/2 connections\n+ *     if (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED) {\n+ *       con.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\n+ *     }\n+ *   })\n+ *   .build();\n+ * </pre>\n+ */\n+public class HttpRequestCompressor extends ChannelOutboundHandlerAdapter {\n+\n+    /**\n+     * default encoding. used if no preferred encoding is set or it is not available.\n+     */\n+    public static final String DEFAULT_ENCODING = \"gzip\";\n+    private static final List<String> SUPPORTED_ENCODINGS = Arrays.asList(new String[] {\n+        \"br\",\n+        \"zstd\",\n+        \"snappy\",\n+        \"deflate\",\n+        \"gzip\"\n+    });\n+    private static final InternalLogger log = InternalLoggerFactory.getInstance(HttpRequestCompressor.class);\n+    private final int contentSizeThreshold;\n+    private final String encoding;\n+    private final Supplier<MessageToByteEncoder<ByteBuf>> encoderFactory;\n+    private EmbeddedChannel encoderChannel;\n+\n+    /**\n+     * new instance using the defaults.\n+     * shortcut for {@code new HttpRequestCompressor(DEFAULT_ENCODING)}\n+     * @see #DEFAULT_ENCODING\n+     * @see #HttpRequestCompressor(java.lang.String)\n+     */\n+    public HttpRequestCompressor() {\n+        this(DEFAULT_ENCODING);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, 0)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @see #HttpRequestCompressor(java.lang.String, int)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding) {\n+        this(preferredEncoding, 0);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding and the given threshold.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, contentSizeThreshold, null)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @see #HttpRequestCompressor(java.lang.String, int, io.netty.handler.codec.compression.CompressionOptions...)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold) {\n+        this(preferredEncoding, contentSizeThreshold, (CompressionOptions[]) null);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding, threshold and compression options.\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @param compressionOptions the desired compression options to use.\n+     * if {@code null} or empty, the defaults will be used.\n+     * @see StandardCompressionOptions#brotli() default brotli options\n+     * @see StandardCompressionOptions#gzip() default gzip options\n+     * @see StandardCompressionOptions#zstd() default zstd options\n+     * @see StandardCompressionOptions#deflate() default deflate options\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold,\n+            CompressionOptions... compressionOptions) {\n+        ObjectUtil.checkNonEmpty(preferredEncoding, \"preferredEncoding\");\n+        this.contentSizeThreshold = ObjectUtil.\n+                checkPositiveOrZero(contentSizeThreshold, \"contentSizeThreshold\");\n+\n+        if (!SUPPORTED_ENCODINGS.contains(preferredEncoding)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unsupported encoding %s. Supported encodings are: %s\",\n+                            preferredEncoding, StringUtil.join(\",\", SUPPORTED_ENCODINGS)));\n+        }\n+\n+        GzipOptions gzipOptions = null;\n+        DeflateOptions deflateOptions = null;\n+        BrotliOptions brotliOptions = null;\n+        ZstdOptions zstdOptions = null;\n+        for (CompressionOptions compressionOption : Optional.ofNullable(compressionOptions)\n+                .orElseGet(() -> new CompressionOptions[0])) {\n+            if (compressionOption instanceof BrotliOptions) {\n+                brotliOptions = (BrotliOptions) compressionOption;\n+            } else if (compressionOption instanceof GzipOptions) {\n+                gzipOptions = (GzipOptions) compressionOption;\n+            } else if (compressionOption instanceof DeflateOptions) {\n+                deflateOptions = (DeflateOptions) compressionOption;\n+            } else if (compressionOption instanceof ZstdOptions) {\n+                zstdOptions = (ZstdOptions) compressionOption;\n+            } else {\n+                log.info(\"ignoring unsupported compression option {}\",\n+                        compressionOption != null ? compressionOption.getClass() : \"null\");\n+            }\n+        }\n+\n+        if (\"br\".equals(preferredEncoding) && Brotli.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final BrotliOptions opts = Optional.ofNullable(brotliOptions)\n+                    .orElseGet(StandardCompressionOptions::brotli);\n+            encoderFactory = () -> new BrotliEncoder(opts.parameters(), false);\n+        } else if (\"zstd\".equals(preferredEncoding) && Zstd.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final ZstdOptions opts = Optional.ofNullable(zstdOptions)\n+                    .orElseGet(StandardCompressionOptions::zstd);\n+            encoderFactory = () -> new ZstdEncoder(opts.compressionLevel(), opts.blockSize(), opts.maxEncodeSize());\n+        } else if (\"snappy\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            encoderFactory = SnappyFrameEncoder::new;\n+        } else if (\"deflate\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            final DeflateOptions opts = Optional.ofNullable(deflateOptions)\n+                    .orElseGet(StandardCompressionOptions::deflate);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.ZLIB, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        } else {\n+            encoding = DEFAULT_ENCODING;\n+            final GzipOptions opts = Optional.ofNullable(gzipOptions)\n+                    .orElseGet(StandardCompressionOptions::gzip);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.GZIP, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        }\n+        if (!preferredEncoding.equals(encoding)) {\n+            log.info(\"preferred encoding {} not available, using {} as default\", preferredEncoding, encoding);\n+        }\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        if (encoderChannel != null) {\n+            throw new IllegalStateException(\"handler already added\");\n+        }\n+        encoderChannel = new EmbeddedChannel(",
        "comment_created_at": "2025-06-26T18:08:02+00:00",
        "comment_author": "sephiroth-j",
        "comment_body": "Are you sure? It works fine. I can make several requests with one client and all of them are compressed. However, it is also no problem to use the `EmbeddedChannel` only in the `write` method.\r\n\r\n```java\r\nvar client = HttpClient\r\n\t.create()\r\n\t// add the handler\r\n\t.observe((con, newState) ->\r\n\t{\r\n\t\t// use CONFIGURED for HTTP/1.1 connections\r\n\t\t// use STREAM_CONFIGURED for HTTP/2 connections\r\n\t\tif (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED)\r\n\t\t{\r\n\t\t\tcon.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\r\n\t\t}\r\n\t})\r\n\t.baseUrl(\"https://httpdump.app/dumps/e29b61d4-5d4e-4fe8-831b-2d06fa6b20d7\")\r\n\t.protocol(HttpProtocol.H2, HttpProtocol.HTTP11);\r\nclient\r\n\t.post()\r\n\t.send((req, outbound) -> {\r\n\t\treturn outbound.sendString(Mono.just(\"Hello, World\"));\r\n\t})\r\n\t.response()\r\n\t.block();\r\nclient\r\n\t.post()\r\n\t.send((req, outbound) -> {\r\n\t\treturn outbound.sendString(Mono.just(\"Hello, World\"));\r\n\t})\r\n\t.response()\r\n\t.block();\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2169794112",
        "repo_full_name": "netty/netty",
        "pr_number": 15401,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestCompressor.java",
        "discussion_id": "2164706622",
        "commented_code": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.compression.Brotli;\n+import io.netty.handler.codec.compression.BrotliEncoder;\n+import io.netty.handler.codec.compression.BrotliOptions;\n+import io.netty.handler.codec.compression.CompressionOptions;\n+import io.netty.handler.codec.compression.DeflateOptions;\n+import io.netty.handler.codec.compression.GzipOptions;\n+import io.netty.handler.codec.compression.SnappyFrameEncoder;\n+import io.netty.handler.codec.compression.StandardCompressionOptions;\n+import io.netty.handler.codec.compression.ZlibCodecFactory;\n+import io.netty.handler.codec.compression.ZlibWrapper;\n+import io.netty.handler.codec.compression.Zstd;\n+import io.netty.handler.codec.compression.ZstdEncoder;\n+import io.netty.handler.codec.compression.ZstdOptions;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A {@code ChannelOutboundHandler} that encodes (compresses) the body of HTTP-Requests using the given encoding.\n+ * <p>\n+ * <b>Supported encodings:</b>\n+ * <ul>\n+ * <li>gzip (default)</li>\n+ * <li>deflate</li>\n+ * <li>snappy</li>\n+ * <li>br (depends on \"com.aayushatharva.brotli4j:brotli4j\")</li>\n+ * <li>zstd (depends on \"com.github.luben:zstd-jni\")r</li>\n+ * </ul>\n+ * <p>\n+ * <b>Note for zstd:</b>\n+ * <a href=\"https://github.com/netty/netty/issues/15340\">\n+ * you should define a threshold that is greater or equal to the configured block size</a>.\n+ * <p>\n+ * <b>How-To Use</b>\n+ * <p>\n+ * For each new connection, add the handler to the end of the user pipeline.\n+ * <pre>\n+ * HttpClient\n+ *   .create()\n+ *   // add the handler\n+ *   .observe((con, newState) -> {\n+ *     // use CONFIGURED for HTTP/1.1 connections\n+ *     // use STREAM_CONFIGURED for HTTP/2 connections\n+ *     if (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED) {\n+ *       con.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\n+ *     }\n+ *   })\n+ *   .build();\n+ * </pre>\n+ */\n+public class HttpRequestCompressor extends ChannelOutboundHandlerAdapter {\n+\n+    /**\n+     * default encoding. used if no preferred encoding is set or it is not available.\n+     */\n+    public static final String DEFAULT_ENCODING = \"gzip\";\n+    private static final List<String> SUPPORTED_ENCODINGS = Arrays.asList(new String[] {\n+        \"br\",\n+        \"zstd\",\n+        \"snappy\",\n+        \"deflate\",\n+        \"gzip\"\n+    });\n+    private static final InternalLogger log = InternalLoggerFactory.getInstance(HttpRequestCompressor.class);\n+    private final int contentSizeThreshold;\n+    private final String encoding;\n+    private final Supplier<MessageToByteEncoder<ByteBuf>> encoderFactory;\n+    private EmbeddedChannel encoderChannel;\n+\n+    /**\n+     * new instance using the defaults.\n+     * shortcut for {@code new HttpRequestCompressor(DEFAULT_ENCODING)}\n+     * @see #DEFAULT_ENCODING\n+     * @see #HttpRequestCompressor(java.lang.String)\n+     */\n+    public HttpRequestCompressor() {\n+        this(DEFAULT_ENCODING);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, 0)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @see #HttpRequestCompressor(java.lang.String, int)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding) {\n+        this(preferredEncoding, 0);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding and the given threshold.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, contentSizeThreshold, null)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @see #HttpRequestCompressor(java.lang.String, int, io.netty.handler.codec.compression.CompressionOptions...)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold) {\n+        this(preferredEncoding, contentSizeThreshold, (CompressionOptions[]) null);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding, threshold and compression options.\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @param compressionOptions the desired compression options to use.\n+     * if {@code null} or empty, the defaults will be used.\n+     * @see StandardCompressionOptions#brotli() default brotli options\n+     * @see StandardCompressionOptions#gzip() default gzip options\n+     * @see StandardCompressionOptions#zstd() default zstd options\n+     * @see StandardCompressionOptions#deflate() default deflate options\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold,\n+            CompressionOptions... compressionOptions) {\n+        ObjectUtil.checkNonEmpty(preferredEncoding, \"preferredEncoding\");\n+        this.contentSizeThreshold = ObjectUtil.\n+                checkPositiveOrZero(contentSizeThreshold, \"contentSizeThreshold\");\n+\n+        if (!SUPPORTED_ENCODINGS.contains(preferredEncoding)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unsupported encoding %s. Supported encodings are: %s\",\n+                            preferredEncoding, StringUtil.join(\",\", SUPPORTED_ENCODINGS)));\n+        }\n+\n+        GzipOptions gzipOptions = null;\n+        DeflateOptions deflateOptions = null;\n+        BrotliOptions brotliOptions = null;\n+        ZstdOptions zstdOptions = null;\n+        for (CompressionOptions compressionOption : Optional.ofNullable(compressionOptions)\n+                .orElseGet(() -> new CompressionOptions[0])) {\n+            if (compressionOption instanceof BrotliOptions) {\n+                brotliOptions = (BrotliOptions) compressionOption;\n+            } else if (compressionOption instanceof GzipOptions) {\n+                gzipOptions = (GzipOptions) compressionOption;\n+            } else if (compressionOption instanceof DeflateOptions) {\n+                deflateOptions = (DeflateOptions) compressionOption;\n+            } else if (compressionOption instanceof ZstdOptions) {\n+                zstdOptions = (ZstdOptions) compressionOption;\n+            } else {\n+                log.info(\"ignoring unsupported compression option {}\",\n+                        compressionOption != null ? compressionOption.getClass() : \"null\");\n+            }\n+        }\n+\n+        if (\"br\".equals(preferredEncoding) && Brotli.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final BrotliOptions opts = Optional.ofNullable(brotliOptions)\n+                    .orElseGet(StandardCompressionOptions::brotli);\n+            encoderFactory = () -> new BrotliEncoder(opts.parameters(), false);\n+        } else if (\"zstd\".equals(preferredEncoding) && Zstd.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final ZstdOptions opts = Optional.ofNullable(zstdOptions)\n+                    .orElseGet(StandardCompressionOptions::zstd);\n+            encoderFactory = () -> new ZstdEncoder(opts.compressionLevel(), opts.blockSize(), opts.maxEncodeSize());\n+        } else if (\"snappy\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            encoderFactory = SnappyFrameEncoder::new;\n+        } else if (\"deflate\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            final DeflateOptions opts = Optional.ofNullable(deflateOptions)\n+                    .orElseGet(StandardCompressionOptions::deflate);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.ZLIB, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        } else {\n+            encoding = DEFAULT_ENCODING;\n+            final GzipOptions opts = Optional.ofNullable(gzipOptions)\n+                    .orElseGet(StandardCompressionOptions::gzip);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.GZIP, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        }\n+        if (!preferredEncoding.equals(encoding)) {\n+            log.info(\"preferred encoding {} not available, using {} as default\", preferredEncoding, encoding);\n+        }\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        if (encoderChannel != null) {\n+            throw new IllegalStateException(\"handler already added\");\n+        }\n+        encoderChannel = new EmbeddedChannel(",
        "comment_created_at": "2025-06-26T19:16:44+00:00",
        "comment_author": "yawkat",
        "comment_body": "Yes I'm sure, probably the channel is not reused in that test.",
        "pr_file_module": null
      },
      {
        "comment_id": "2183577388",
        "repo_full_name": "netty/netty",
        "pr_number": 15401,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestCompressor.java",
        "discussion_id": "2164706622",
        "commented_code": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.http;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.compression.Brotli;\n+import io.netty.handler.codec.compression.BrotliEncoder;\n+import io.netty.handler.codec.compression.BrotliOptions;\n+import io.netty.handler.codec.compression.CompressionOptions;\n+import io.netty.handler.codec.compression.DeflateOptions;\n+import io.netty.handler.codec.compression.GzipOptions;\n+import io.netty.handler.codec.compression.SnappyFrameEncoder;\n+import io.netty.handler.codec.compression.StandardCompressionOptions;\n+import io.netty.handler.codec.compression.ZlibCodecFactory;\n+import io.netty.handler.codec.compression.ZlibWrapper;\n+import io.netty.handler.codec.compression.Zstd;\n+import io.netty.handler.codec.compression.ZstdEncoder;\n+import io.netty.handler.codec.compression.ZstdOptions;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A {@code ChannelOutboundHandler} that encodes (compresses) the body of HTTP-Requests using the given encoding.\n+ * <p>\n+ * <b>Supported encodings:</b>\n+ * <ul>\n+ * <li>gzip (default)</li>\n+ * <li>deflate</li>\n+ * <li>snappy</li>\n+ * <li>br (depends on \"com.aayushatharva.brotli4j:brotli4j\")</li>\n+ * <li>zstd (depends on \"com.github.luben:zstd-jni\")r</li>\n+ * </ul>\n+ * <p>\n+ * <b>Note for zstd:</b>\n+ * <a href=\"https://github.com/netty/netty/issues/15340\">\n+ * you should define a threshold that is greater or equal to the configured block size</a>.\n+ * <p>\n+ * <b>How-To Use</b>\n+ * <p>\n+ * For each new connection, add the handler to the end of the user pipeline.\n+ * <pre>\n+ * HttpClient\n+ *   .create()\n+ *   // add the handler\n+ *   .observe((con, newState) -> {\n+ *     // use CONFIGURED for HTTP/1.1 connections\n+ *     // use STREAM_CONFIGURED for HTTP/2 connections\n+ *     if (newState == HttpClientState.CONFIGURED || newState == HttpClientState.STREAM_CONFIGURED) {\n+ *       con.addHandlerLast(new HttpRequestCompressor(\"gzip\"));\n+ *     }\n+ *   })\n+ *   .build();\n+ * </pre>\n+ */\n+public class HttpRequestCompressor extends ChannelOutboundHandlerAdapter {\n+\n+    /**\n+     * default encoding. used if no preferred encoding is set or it is not available.\n+     */\n+    public static final String DEFAULT_ENCODING = \"gzip\";\n+    private static final List<String> SUPPORTED_ENCODINGS = Arrays.asList(new String[] {\n+        \"br\",\n+        \"zstd\",\n+        \"snappy\",\n+        \"deflate\",\n+        \"gzip\"\n+    });\n+    private static final InternalLogger log = InternalLoggerFactory.getInstance(HttpRequestCompressor.class);\n+    private final int contentSizeThreshold;\n+    private final String encoding;\n+    private final Supplier<MessageToByteEncoder<ByteBuf>> encoderFactory;\n+    private EmbeddedChannel encoderChannel;\n+\n+    /**\n+     * new instance using the defaults.\n+     * shortcut for {@code new HttpRequestCompressor(DEFAULT_ENCODING)}\n+     * @see #DEFAULT_ENCODING\n+     * @see #HttpRequestCompressor(java.lang.String)\n+     */\n+    public HttpRequestCompressor() {\n+        this(DEFAULT_ENCODING);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, 0)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @see #HttpRequestCompressor(java.lang.String, int)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding) {\n+        this(preferredEncoding, 0);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding and the given threshold.\n+     * shortcut for {@code new HttpRequestCompressor(preferredEncoding, contentSizeThreshold, null)}\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @see #HttpRequestCompressor(java.lang.String, int, io.netty.handler.codec.compression.CompressionOptions...)\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold) {\n+        this(preferredEncoding, contentSizeThreshold, (CompressionOptions[]) null);\n+    }\n+\n+    /**\n+     * new instance using the preferred encoding, threshold and compression options.\n+     * @param preferredEncoding the preferred encoding.\n+     * if unavailable, the default encoding {@link #DEFAULT_ENCODING} will be used.\n+     * @param contentSizeThreshold the size in byte the http body must have before compressing the request\n+     * @param compressionOptions the desired compression options to use.\n+     * if {@code null} or empty, the defaults will be used.\n+     * @see StandardCompressionOptions#brotli() default brotli options\n+     * @see StandardCompressionOptions#gzip() default gzip options\n+     * @see StandardCompressionOptions#zstd() default zstd options\n+     * @see StandardCompressionOptions#deflate() default deflate options\n+     */\n+    public HttpRequestCompressor(String preferredEncoding, int contentSizeThreshold,\n+            CompressionOptions... compressionOptions) {\n+        ObjectUtil.checkNonEmpty(preferredEncoding, \"preferredEncoding\");\n+        this.contentSizeThreshold = ObjectUtil.\n+                checkPositiveOrZero(contentSizeThreshold, \"contentSizeThreshold\");\n+\n+        if (!SUPPORTED_ENCODINGS.contains(preferredEncoding)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unsupported encoding %s. Supported encodings are: %s\",\n+                            preferredEncoding, StringUtil.join(\",\", SUPPORTED_ENCODINGS)));\n+        }\n+\n+        GzipOptions gzipOptions = null;\n+        DeflateOptions deflateOptions = null;\n+        BrotliOptions brotliOptions = null;\n+        ZstdOptions zstdOptions = null;\n+        for (CompressionOptions compressionOption : Optional.ofNullable(compressionOptions)\n+                .orElseGet(() -> new CompressionOptions[0])) {\n+            if (compressionOption instanceof BrotliOptions) {\n+                brotliOptions = (BrotliOptions) compressionOption;\n+            } else if (compressionOption instanceof GzipOptions) {\n+                gzipOptions = (GzipOptions) compressionOption;\n+            } else if (compressionOption instanceof DeflateOptions) {\n+                deflateOptions = (DeflateOptions) compressionOption;\n+            } else if (compressionOption instanceof ZstdOptions) {\n+                zstdOptions = (ZstdOptions) compressionOption;\n+            } else {\n+                log.info(\"ignoring unsupported compression option {}\",\n+                        compressionOption != null ? compressionOption.getClass() : \"null\");\n+            }\n+        }\n+\n+        if (\"br\".equals(preferredEncoding) && Brotli.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final BrotliOptions opts = Optional.ofNullable(brotliOptions)\n+                    .orElseGet(StandardCompressionOptions::brotli);\n+            encoderFactory = () -> new BrotliEncoder(opts.parameters(), false);\n+        } else if (\"zstd\".equals(preferredEncoding) && Zstd.isAvailable()) {\n+            encoding = preferredEncoding;\n+            final ZstdOptions opts = Optional.ofNullable(zstdOptions)\n+                    .orElseGet(StandardCompressionOptions::zstd);\n+            encoderFactory = () -> new ZstdEncoder(opts.compressionLevel(), opts.blockSize(), opts.maxEncodeSize());\n+        } else if (\"snappy\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            encoderFactory = SnappyFrameEncoder::new;\n+        } else if (\"deflate\".equals(preferredEncoding)) {\n+            encoding = preferredEncoding;\n+            final DeflateOptions opts = Optional.ofNullable(deflateOptions)\n+                    .orElseGet(StandardCompressionOptions::deflate);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.ZLIB, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        } else {\n+            encoding = DEFAULT_ENCODING;\n+            final GzipOptions opts = Optional.ofNullable(gzipOptions)\n+                    .orElseGet(StandardCompressionOptions::gzip);\n+            encoderFactory = () -> ZlibCodecFactory.newZlibEncoder(\n+                    ZlibWrapper.GZIP, opts.compressionLevel(), opts.windowBits(), opts.memLevel());\n+        }\n+        if (!preferredEncoding.equals(encoding)) {\n+            log.info(\"preferred encoding {} not available, using {} as default\", preferredEncoding, encoding);\n+        }\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        if (encoderChannel != null) {\n+            throw new IllegalStateException(\"handler already added\");\n+        }\n+        encoderChannel = new EmbeddedChannel(",
        "comment_created_at": "2025-07-03T19:03:49+00:00",
        "comment_author": "sephiroth-j",
        "comment_body": "Each request now uses a new `EmbeddedChannel`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347088945",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
    "created_at": "2019-11-16T12:09:11+00:00",
    "commented_code": "+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "347088945",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-16T12:09:11+00:00",
        "comment_author": "egahlin",
        "comment_body": "What performance issues do you see?\r\n\r\nIs it a lot of allocation? If so, there are a few tweaks that can be tried...\r\n\r\nIf it is not allocation, but many events, you could set a threshold, i.e @Threshold(\"10 ms)",
        "pr_file_module": null
      },
      {
        "comment_id": "347260318",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T09:01:29+00:00",
        "comment_author": "klaraward",
        "comment_body": "It's an extreme amount of events, which probably messes with allocation as well, I did set a threshold I think, but probably need to raise it.",
        "pr_file_module": null
      },
      {
        "comment_id": "347263104",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T09:08:45+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Maybe I am missing something but couldn't we cache the events per Channel somehow and so reduce GC pressure ?",
        "pr_file_module": null
      },
      {
        "comment_id": "347264735",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T09:12:34+00:00",
        "comment_author": "klaraward",
        "comment_body": "That sounds like a good idea. Is the ChannelHandler thread safe? If so then we could just reuse the same event for everything.",
        "pr_file_module": null
      },
      {
        "comment_id": "347265387",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T09:14:08+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Yes it is on a per `EventLoop` basis. So all the the `Channel`s that are using the same `EventLoop` will not run on a concurrent basis. That said it may be the easiest to just make it per `Channel` basis. If this is not good enough (and I assume it is) we could also use a `FastThreadLocal`.",
        "pr_file_module": null
      },
      {
        "comment_id": "347333432",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T11:38:50+00:00",
        "comment_author": "egahlin",
        "comment_body": "> It's an extreme amount of events, which probably messes with allocation as well, I did set a threshold I think, but probably need to raise it.\r\n\r\nThe JIT is usually able eliminate heap allocations, but not always. It depends on how much it must inline. If you can see event objects for the TLAB events, you could cache it, similar to what is done in the JDK. \r\n\r\nLooking up a thread local adds a cost, so should only be done if it is an allocation issue. \r\n\r\nhttps://github.com/openjdk/jdk/blob/master/src/jdk.jfr/share/classes/jdk/jfr/events/SocketReadEvent.java\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "347334745",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-18T11:42:06+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "like I said I think re-using per Channel would be the best.",
        "pr_file_module": null
      },
      {
        "comment_id": "351214112",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-27T10:41:52+00:00",
        "comment_author": "klaraward",
        "comment_body": "Is there one ChannelHandler per channel if I don't make it Sharable?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "351218313",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2019-11-27T10:50:45+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "yes the user will create one per `Channel` and add it to the `ChannelPipeline`.",
        "pr_file_module": null
      },
      {
        "comment_id": "577511017",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2021-02-17T10:50:06+00:00",
        "comment_author": "klaraward",
        "comment_body": "If I were to cache the event per channel, what kind of solution would you recommend @normanmaurer ?",
        "pr_file_module": null
      },
      {
        "comment_id": "577553979",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088945",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();",
        "comment_created_at": "2021-02-17T12:00:15+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "just store the event in the ChannelHandler as a field. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347280868",
    "pr_number": 9777,
    "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
    "created_at": "2019-11-18T09:46:36+00:00",
    "commented_code": "+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "347280868",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
        "discussion_id": "347280868",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
        "comment_created_at": "2019-11-18T09:46:36+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Add a private constructor and expose the instance as static one to reduce object allocations. This also means you will need to override `isSharable()` and return `true`.",
        "pr_file_module": null
      },
      {
        "comment_id": "347807040",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
        "discussion_id": "347280868",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
        "comment_created_at": "2019-11-19T09:17:06+00:00",
        "comment_author": "klaraward",
        "comment_body": "This goes for JfrEventHandler as well I guess?",
        "pr_file_module": null
      },
      {
        "comment_id": "347846147",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
        "discussion_id": "347280868",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
        "comment_created_at": "2019-11-19T10:32:39+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "yes as long as has not state it can be sharable ",
        "pr_file_module": null
      },
      {
        "comment_id": "348363848",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
        "discussion_id": "347280868",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
        "comment_created_at": "2019-11-20T09:10:31+00:00",
        "comment_author": "klaraward",
        "comment_body": "But we do want it do have state I guess, reusing the events per channel",
        "pr_file_module": null
      },
      {
        "comment_id": "348366468",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr-microbench/src/main/java/io/netty/handler/jfr/microbench/NoopHandler.java",
        "discussion_id": "347280868",
        "commented_code": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr.microbench;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.net.SocketAddress;\n+\n+public class NoopHandler extends ChannelDuplexHandler {\n+",
        "comment_created_at": "2019-11-20T09:15:41+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Yep if we do per Channel we should create a new handler per channel ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347282336",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
    "created_at": "2019-11-18T09:49:40+00:00",
    "commented_code": "+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "347282336",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347282336",
        "commented_code": "@@ -0,0 +1,375 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }",
        "comment_created_at": "2019-11-18T09:49:40+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "looks like the code is duplicated everywhere. Can we extract the whole `if` block in an extra method to remove code-duplication ?",
        "pr_file_module": null
      },
      {
        "comment_id": "351646787",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347282336",
        "commented_code": "@@ -0,0 +1,375 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }",
        "comment_created_at": "2019-11-28T08:36:39+00:00",
        "comment_author": "klaraward",
        "comment_body": "See @egahlin s comment on the extra frame in the stacktrace, and of the potential JIT issues when making the local event variable escape.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "589459488",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/jfr/JfrInstrumentedResourceLeakDetector.java",
    "created_at": "2021-03-08T14:26:55+00:00",
    "commented_code": "+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://wache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+/**\n+ * A {@link ResourceLeakDetector} that creates JDK Flight Recorder events for all resource leaks.\n+ */\n+public final class JfrInstrumentedResourceLeakDetector<T> extends ResourceLeakDetector<T> {\n+\n+    public JfrInstrumentedResourceLeakDetector(Class<?> resourceType, int samplingInterval) {\n+        super(resourceType, samplingInterval);\n+    }\n+\n+    @Override\n+    protected void reportTracedLeak(String resourceType, String records) {\n+        LeakEvent event = new LeakEvent();\n+        event.setResourceType(resourceType);\n+        event.setRecords(records);\n+        event.commit();\n+    }\n+\n+    @Override\n+    protected void reportUntracedLeak(String resourceType) {\n+        LeakEvent event = new LeakEvent();\n+        event.setResourceType(resourceType);\n+        event.commit();\n+    }\n+\n+    @Category({ \"Netty\", \"LeakDetection\" })",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "589459488",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrInstrumentedResourceLeakDetector.java",
        "discussion_id": "589459488",
        "commented_code": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://wache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.util.ResourceLeakDetector;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+/**\n+ * A {@link ResourceLeakDetector} that creates JDK Flight Recorder events for all resource leaks.\n+ */\n+public final class JfrInstrumentedResourceLeakDetector<T> extends ResourceLeakDetector<T> {\n+\n+    public JfrInstrumentedResourceLeakDetector(Class<?> resourceType, int samplingInterval) {\n+        super(resourceType, samplingInterval);\n+    }\n+\n+    @Override\n+    protected void reportTracedLeak(String resourceType, String records) {\n+        LeakEvent event = new LeakEvent();\n+        event.setResourceType(resourceType);\n+        event.setRecords(records);\n+        event.commit();\n+    }\n+\n+    @Override\n+    protected void reportUntracedLeak(String resourceType) {\n+        LeakEvent event = new LeakEvent();\n+        event.setResourceType(resourceType);\n+        event.commit();\n+    }\n+\n+    @Category({ \"Netty\", \"LeakDetection\" })",
        "comment_created_at": "2021-03-08T14:26:55+00:00",
        "comment_author": "egahlin",
        "comment_body": "Category should be human readable, i.e. \"Leak Detection\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "603863432",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
    "created_at": "2021-03-30T07:51:23+00:00",
    "commented_code": "+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "603863432",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T07:51:23+00:00",
        "comment_author": "bric3",
        "comment_body": "Can these new event allocation be eliminated ? I'm not well versed in Netty, so please dismiss this comment if this incorrect.\r\n\r\nSo I believe these handler's methods will be called by the event loop threads, moreover read or write method will be called really often. I suggest to reuse a single event instance per thread, eg something like :\r\n\r\n```\r\npublic final class JfrChannelHandler extends ChannelDuplexHandler {\r\n    private static ThreadLocal<ChannelReadEvent> CHANNEL_READ_EVENT = ThreadLocal.withInitial(() -> new ChannelReadEvent());\r\n\r\n    @Override\r\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\r\n        final ChannelReadEvent channelReadEvent = CHANNEL_READ_EVENT.get();\r\n        // ...\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "604017555",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T11:38:28+00:00",
        "comment_author": "klaraward",
        "comment_body": "I've spoken to @egahlin and he says that the allocations will most likely be optimized and removed, right?\r\nBut I could try this approach and do some comparisons.",
        "pr_file_module": null
      },
      {
        "comment_id": "604028329",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T11:56:32+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Generally speaking I think it is a good idea to not allocate if we can ... Just ensure the handler is not sharable anymore in this case as it has state. ",
        "pr_file_module": null
      },
      {
        "comment_id": "604033227",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T12:04:17+00:00",
        "comment_author": "bric3",
        "comment_body": "I have just looked at the [`jdk.jfr.events.SocketReadEvent`](https://github.com/openjdk/jdk8u/blob/4a4236a366eeb961baf157f0938634c1647c447f/jdk/src/share/classes/jdk/jfr/events/SocketReadEvent.java#L42-L470) in OpenJDK 8 and OpenJDK 11 and they are using the same trick. Additionally the code calls a `reset()` method right after commit.\r\n\r\nThe IO threading model is different, but I think the `ThreadLocal` can be applied.",
        "pr_file_module": null
      },
      {
        "comment_id": "604042088",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T12:17:47+00:00",
        "comment_author": "bric3",
        "comment_body": "> I've spoken to @egahlin and he says that the allocations will most likely be optimized and removed, right?\r\n> But I could try this approach and do some comparisons.\r\n\r\nOh! I know that JFR trigger a special class loading code, but I haven't dived too much how it works (how the event allocation is being optimized away during class-loading? or via the jit?).\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "604441428",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-30T21:23:53+00:00",
        "comment_author": "egahlin",
        "comment_body": "If the JIT is able to eliminate the heap allocation, it is (at least in theory) cheaper than a TL. It also works very nicely if the event is disabled.\r\n\r\nhttps://youtu.be/plYESjZ12hM?t=1126\r\n\r\n\r\nWe are trying to get rid of TLs in the JDK to better support virtual threads. We reworked SocketReadEvent so it no longer uses TLS. I think it is best to measure, but be aware of the future. Premature optimization is the root ...\r\n\r\n(Before using TL in the JDK, we proved that the JIT was not able to remove the heap allocation for the SocketReadEvent, perhaps because complex control flow with exceptions. The security events in the JDK don't use TLS)",
        "pr_file_module": null
      },
      {
        "comment_id": "604673689",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603863432",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();",
        "comment_created_at": "2021-03-31T07:53:21+00:00",
        "comment_author": "bric3",
        "comment_body": "@egahlin Thank you for this insight ! And for the presentation, it expalins very well how this works !\r\n\r\nThe video mostly insists on the tricks the JIT is performing when the vent is not enabled, in particular to eliminate the allocation, the JVM goes through _scalar replacement_ because the \"fields are not read\". But I don't think this is possible when the events are enabled, since the fields will then be read  at least for hotspot in OpenJDK 8 through OpenJDK 11, which are the most common used runtimes used in production  am I understanding this correctly, or am I misleading myself ?\r\n\r\nI am really looking forward the impressive Loom but it's still further on the road.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "603871745",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
    "created_at": "2021-03-30T08:03:39+00:00",
    "commented_code": "+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();\n+        channelReadEvent.begin();\n+        channelReadEvent.setMsg(msg);\n+        ctx.fireChannelRead(msg);\n+        channelReadEvent.end();\n+        if (channelReadEvent.shouldCommit()) {\n+            channelReadEvent.setChannel(ctx.channel());\n+            channelReadEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void read(ChannelHandlerContext ctx) {\n+        final ReadEvent readEvent = new ReadEvent();\n+        readEvent.begin();\n+        ctx.read();\n+        readEvent.end();\n+        if (readEvent.shouldCommit()) {\n+            readEvent.setChannel(ctx.channel());\n+            readEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+        final WriteEvent writeEvent = new WriteEvent();\n+        writeEvent.begin();\n+        writeEvent.setMsg(msg);\n+        ctx.write(msg, promise);\n+        writeEvent.end();\n+        if (writeEvent.shouldCommit()) {\n+            writeEvent.setChannel(ctx.channel());\n+            writeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) {\n+        final ChannelWritabilityChangedEvent channelWritabilityChangedEvent = new ChannelWritabilityChangedEvent();\n+        channelWritabilityChangedEvent.begin();\n+        channelWritabilityChangedEvent.setWasWritable(ctx.channel().isWritable());\n+        ctx.fireChannelWritabilityChanged();\n+        channelWritabilityChangedEvent.end();\n+        if (channelWritabilityChangedEvent.shouldCommit()) {\n+            channelWritabilityChangedEvent.setChannel(ctx.channel());\n+            channelWritabilityChangedEvent.setIsWritable(ctx.channel().isWritable());\n+            channelWritabilityChangedEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void flush(ChannelHandlerContext ctx) {\n+        final FlushEvent flushEvent = new FlushEvent();\n+        flushEvent.begin();\n+        ctx.flush();\n+        flushEvent.end();\n+        if (flushEvent.shouldCommit()) {\n+            flushEvent.setChannel(ctx.channel());\n+            flushEvent.commit();\n+        }\n+    }\n+\n+    // Event types\n+\n+    @Category({ \"Netty\", \"Channel\" })\n+    @Enabled(true)\n+    @Threshold(\"1 us\")\n+    private abstract static class ChannelEvent extends Event {\n+        @Label(\"Channel\")\n+        String channel;\n+        @Label(\"Long Channel ID\")\n+        String longChannelId;\n+        @Label(\"Short Channel ID\")\n+        String shortChannelId;\n+\n+        void setChannel(Channel channel) {\n+            this.channel = String.valueOf(channel);\n+            //TODO: More specific channel fields?\n+            this.longChannelId = channel.id().asLongText();\n+            this.shortChannelId = channel.id().asShortText();\n+        }\n+    }\n+\n+    @Threshold(\"20 ms\")\n+    private abstract static class ChannelIOEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Bind\")\n+    @Name(\"io.netty.channel.Bind\")\n+    private static final class BindEvent extends ChannelEvent {\n+        @Label(\"Local Address\")\n+        String localAddress;\n+\n+        void setLocalAddress(SocketAddress localAddress) {\n+            this.localAddress = String.valueOf(localAddress);\n+        }\n+    }\n+\n+    @Label(\"Write\")\n+    @Name(\"io.netty.channel.Write\")\n+    private static final class WriteEvent extends ChannelIOEvent {\n+        @Label(\"Message\")\n+        String msg;\n+\n+        void setMsg(Object msg) {\n+            this.msg = String.valueOf(msg);\n+        }\n+    }\n+\n+    @Label(\"Channel Read\")\n+    @Name(\"io.netty.channel.ChannelRead\")\n+    private static final class ChannelReadEvent extends ChannelIOEvent {\n+        @Label(\"Message\")\n+        String msg;\n+\n+        void setMsg(Object msg) {\n+            this.msg = String.valueOf(msg);\n+        }\n+    }\n+\n+    @Label(\"Channel Read Complete\")\n+    @Name(\"io.netty.channel.ChannelReadComplete\")\n+    private static final class ChannelReadCompleteEvent extends ChannelIOEvent {\n+    }\n+\n+    @Label(\"Close\")\n+    @Name(\"io.netty.channel.Close\")\n+    private static final class CloseEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Disconnect\")\n+    @Name(\"io.netty.channel.Disconnect\")\n+    private static final class DisconnectEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Connect\")\n+    @Name(\"io.netty.channel.Connect\")\n+    private static final class ConnectEvent extends ChannelEvent {\n+        @Label(\"Remote Address\")\n+        String remoteAddress;\n+        @Label(\"Local Address\")\n+        String localAddress;\n+\n+        void setRemoteAddress(SocketAddress remoteAddress) {\n+            this.remoteAddress = String.valueOf(remoteAddress);\n+        }\n+\n+        void setLocalAddress(SocketAddress localAddress) {\n+            this.localAddress = String.valueOf(localAddress);\n+        }\n+    }\n+\n+    @Label(\"Channel Registered\")\n+    @Name(\"io.netty.channel.ChannelRegistered\")\n+    private static final class ChannelRegisteredEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Unregistered\")\n+    @Name(\"io.netty.channel.ChannelUnregistered\")\n+    private static final class ChannelUnregisteredEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Writability Changed\")\n+    @Name(\"io.netty.channel.ChannelWritabilityChanged\")\n+    private static final class ChannelWritabilityChangedEvent extends ChannelEvent {\n+        @Label(\"Is Writable\")\n+        boolean isWritable;\n+        @Label(\"Was Writable\")\n+        boolean wasWritable;\n+\n+        void setIsWritable(boolean writable) {\n+            isWritable = writable;\n+        }\n+\n+        void setWasWritable(boolean wasWritable) {\n+            this.wasWritable = wasWritable;\n+        }\n+    }\n+\n+    @Label(\"Channel Inactive\")\n+    @Name(\"io.netty.channel.ChannelInactive\")\n+    private static final class ChannelInactiveEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Active\")\n+    @Name(\"io.netty.channel.ChannelActive\")\n+    private static final class ChannelActiveEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Deregister\")\n+    @Name(\"io.netty.channel.Deregister\")\n+    private static final class DeregisterEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"User Event Triggered\")\n+    @Name(\"io.netty.channel.UserEventTriggered\")\n+    private static final class UserEventTriggeredEvent extends ChannelEvent {\n+        @Label(\"User Event\")\n+        String userEvent;\n+\n+        void setUserEvent(Object evt) {\n+            this.userEvent = String.valueOf(evt);\n+        }\n+    }\n+\n+    @Label(\"Flush\")\n+    @Name(\"io.netty.channel.Flush\")\n+    private static final class FlushEvent extends ChannelIOEvent {\n+    }\n+\n+    @Label(\"Exception Caught\")\n+    @Name(\"io.netty.channel.ExceptionCaught\")\n+    private static final class ExceptionCaughtEvent extends ChannelEvent {\n+        @Label(\"Cause\")\n+        String cause;\n+\n+        void setCause(Throwable cause) {\n+            this.cause = cause.toString();",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "603871745",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrChannelHandler.java",
        "discussion_id": "603871745",
        "commented_code": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2019 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Threshold;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JDK Flight Recorder events for all Netty channel events/operations.\n+ */\n+@Sharable\n+public final class JfrChannelHandler extends ChannelDuplexHandler {\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) {\n+        final ChannelRegisteredEvent channelRegisteredEvent = new ChannelRegisteredEvent();\n+        channelRegisteredEvent.begin();\n+        ctx.fireChannelRegistered();\n+        channelRegisteredEvent.end();\n+        if (channelRegisteredEvent.shouldCommit()) {\n+            channelRegisteredEvent.setChannel(ctx.channel());\n+            channelRegisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) {\n+        final ChannelUnregisteredEvent channelUnregisteredEvent = new ChannelUnregisteredEvent();\n+        channelUnregisteredEvent.begin();\n+        ctx.fireChannelUnregistered();\n+        channelUnregisteredEvent.end();\n+        if (channelUnregisteredEvent.shouldCommit()) {\n+            channelUnregisteredEvent.setChannel(ctx.channel());\n+            channelUnregisteredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        final ChannelActiveEvent channelActiveEvent = new ChannelActiveEvent();\n+        channelActiveEvent.begin();\n+        ctx.fireChannelActive();\n+        channelActiveEvent.end();\n+        if (channelActiveEvent.shouldCommit()) {\n+            channelActiveEvent.setChannel(ctx.channel());\n+            channelActiveEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) {\n+        final ChannelInactiveEvent channelInactiveEvent = new ChannelInactiveEvent();\n+        channelInactiveEvent.begin();\n+        ctx.fireChannelInactive();\n+        channelInactiveEvent.end();\n+        if (channelInactiveEvent.shouldCommit()) {\n+            channelInactiveEvent.setChannel(ctx.channel());\n+        }\n+        channelInactiveEvent.commit();\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+        final ExceptionCaughtEvent exceptionCaughtEvent = new ExceptionCaughtEvent();\n+        exceptionCaughtEvent.begin();\n+        ctx.fireExceptionCaught(cause);\n+        exceptionCaughtEvent.end();\n+        if (exceptionCaughtEvent.shouldCommit()) {\n+            exceptionCaughtEvent.setChannel(ctx.channel());\n+            exceptionCaughtEvent.setCause(cause);\n+            exceptionCaughtEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+        final UserEventTriggeredEvent userEventTriggeredEvent = new UserEventTriggeredEvent();\n+        userEventTriggeredEvent.begin();\n+        userEventTriggeredEvent.setUserEvent(evt);\n+        ctx.fireUserEventTriggered(evt);\n+        userEventTriggeredEvent.end();\n+        if (userEventTriggeredEvent.shouldCommit()) {\n+            userEventTriggeredEvent.setChannel(ctx.channel());\n+            userEventTriggeredEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {\n+        final BindEvent bindEvent = new BindEvent();\n+        bindEvent.begin();\n+        ctx.bind(localAddress, promise);\n+        bindEvent.end();\n+        if (bindEvent.shouldCommit()) {\n+            bindEvent.setChannel(ctx.channel());\n+            bindEvent.setLocalAddress(localAddress);\n+            bindEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        final ConnectEvent connectEvent = new ConnectEvent();\n+        connectEvent.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        connectEvent.end();\n+        if (connectEvent.shouldCommit()) {\n+            connectEvent.setChannel(ctx.channel());\n+            connectEvent.setRemoteAddress(remoteAddress);\n+            connectEvent.setLocalAddress(localAddress);\n+            connectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DisconnectEvent disconnectEvent = new DisconnectEvent();\n+        disconnectEvent.begin();\n+        ctx.disconnect(promise);\n+        disconnectEvent.end();\n+        if (disconnectEvent.shouldCommit()) {\n+            disconnectEvent.setChannel(ctx.channel());\n+            disconnectEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final CloseEvent closeEvent = new CloseEvent();\n+        closeEvent.begin();\n+        ctx.close(promise);\n+        closeEvent.end();\n+        if (closeEvent.shouldCommit()) {\n+            closeEvent.setChannel(ctx.channel());\n+            closeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) {\n+        final DeregisterEvent deregisterEvent = new DeregisterEvent();\n+        deregisterEvent.begin();\n+        ctx.deregister(promise);\n+        deregisterEvent.end();\n+        if (deregisterEvent.shouldCommit()) {\n+            deregisterEvent.setChannel(ctx.channel());\n+            deregisterEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelReadComplete(ChannelHandlerContext ctx) {\n+        final ChannelReadCompleteEvent channelReadCompleteEvent = new ChannelReadCompleteEvent();\n+        channelReadCompleteEvent.begin();\n+        ctx.fireChannelReadComplete();\n+        channelReadCompleteEvent.end();\n+        if (channelReadCompleteEvent.shouldCommit()) {\n+            channelReadCompleteEvent.setChannel(ctx.channel());\n+            channelReadCompleteEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n+        final ChannelReadEvent channelReadEvent = new ChannelReadEvent();\n+        channelReadEvent.begin();\n+        channelReadEvent.setMsg(msg);\n+        ctx.fireChannelRead(msg);\n+        channelReadEvent.end();\n+        if (channelReadEvent.shouldCommit()) {\n+            channelReadEvent.setChannel(ctx.channel());\n+            channelReadEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void read(ChannelHandlerContext ctx) {\n+        final ReadEvent readEvent = new ReadEvent();\n+        readEvent.begin();\n+        ctx.read();\n+        readEvent.end();\n+        if (readEvent.shouldCommit()) {\n+            readEvent.setChannel(ctx.channel());\n+            readEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+        final WriteEvent writeEvent = new WriteEvent();\n+        writeEvent.begin();\n+        writeEvent.setMsg(msg);\n+        ctx.write(msg, promise);\n+        writeEvent.end();\n+        if (writeEvent.shouldCommit()) {\n+            writeEvent.setChannel(ctx.channel());\n+            writeEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) {\n+        final ChannelWritabilityChangedEvent channelWritabilityChangedEvent = new ChannelWritabilityChangedEvent();\n+        channelWritabilityChangedEvent.begin();\n+        channelWritabilityChangedEvent.setWasWritable(ctx.channel().isWritable());\n+        ctx.fireChannelWritabilityChanged();\n+        channelWritabilityChangedEvent.end();\n+        if (channelWritabilityChangedEvent.shouldCommit()) {\n+            channelWritabilityChangedEvent.setChannel(ctx.channel());\n+            channelWritabilityChangedEvent.setIsWritable(ctx.channel().isWritable());\n+            channelWritabilityChangedEvent.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void flush(ChannelHandlerContext ctx) {\n+        final FlushEvent flushEvent = new FlushEvent();\n+        flushEvent.begin();\n+        ctx.flush();\n+        flushEvent.end();\n+        if (flushEvent.shouldCommit()) {\n+            flushEvent.setChannel(ctx.channel());\n+            flushEvent.commit();\n+        }\n+    }\n+\n+    // Event types\n+\n+    @Category({ \"Netty\", \"Channel\" })\n+    @Enabled(true)\n+    @Threshold(\"1 us\")\n+    private abstract static class ChannelEvent extends Event {\n+        @Label(\"Channel\")\n+        String channel;\n+        @Label(\"Long Channel ID\")\n+        String longChannelId;\n+        @Label(\"Short Channel ID\")\n+        String shortChannelId;\n+\n+        void setChannel(Channel channel) {\n+            this.channel = String.valueOf(channel);\n+            //TODO: More specific channel fields?\n+            this.longChannelId = channel.id().asLongText();\n+            this.shortChannelId = channel.id().asShortText();\n+        }\n+    }\n+\n+    @Threshold(\"20 ms\")\n+    private abstract static class ChannelIOEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Bind\")\n+    @Name(\"io.netty.channel.Bind\")\n+    private static final class BindEvent extends ChannelEvent {\n+        @Label(\"Local Address\")\n+        String localAddress;\n+\n+        void setLocalAddress(SocketAddress localAddress) {\n+            this.localAddress = String.valueOf(localAddress);\n+        }\n+    }\n+\n+    @Label(\"Write\")\n+    @Name(\"io.netty.channel.Write\")\n+    private static final class WriteEvent extends ChannelIOEvent {\n+        @Label(\"Message\")\n+        String msg;\n+\n+        void setMsg(Object msg) {\n+            this.msg = String.valueOf(msg);\n+        }\n+    }\n+\n+    @Label(\"Channel Read\")\n+    @Name(\"io.netty.channel.ChannelRead\")\n+    private static final class ChannelReadEvent extends ChannelIOEvent {\n+        @Label(\"Message\")\n+        String msg;\n+\n+        void setMsg(Object msg) {\n+            this.msg = String.valueOf(msg);\n+        }\n+    }\n+\n+    @Label(\"Channel Read Complete\")\n+    @Name(\"io.netty.channel.ChannelReadComplete\")\n+    private static final class ChannelReadCompleteEvent extends ChannelIOEvent {\n+    }\n+\n+    @Label(\"Close\")\n+    @Name(\"io.netty.channel.Close\")\n+    private static final class CloseEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Disconnect\")\n+    @Name(\"io.netty.channel.Disconnect\")\n+    private static final class DisconnectEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Connect\")\n+    @Name(\"io.netty.channel.Connect\")\n+    private static final class ConnectEvent extends ChannelEvent {\n+        @Label(\"Remote Address\")\n+        String remoteAddress;\n+        @Label(\"Local Address\")\n+        String localAddress;\n+\n+        void setRemoteAddress(SocketAddress remoteAddress) {\n+            this.remoteAddress = String.valueOf(remoteAddress);\n+        }\n+\n+        void setLocalAddress(SocketAddress localAddress) {\n+            this.localAddress = String.valueOf(localAddress);\n+        }\n+    }\n+\n+    @Label(\"Channel Registered\")\n+    @Name(\"io.netty.channel.ChannelRegistered\")\n+    private static final class ChannelRegisteredEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Unregistered\")\n+    @Name(\"io.netty.channel.ChannelUnregistered\")\n+    private static final class ChannelUnregisteredEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Writability Changed\")\n+    @Name(\"io.netty.channel.ChannelWritabilityChanged\")\n+    private static final class ChannelWritabilityChangedEvent extends ChannelEvent {\n+        @Label(\"Is Writable\")\n+        boolean isWritable;\n+        @Label(\"Was Writable\")\n+        boolean wasWritable;\n+\n+        void setIsWritable(boolean writable) {\n+            isWritable = writable;\n+        }\n+\n+        void setWasWritable(boolean wasWritable) {\n+            this.wasWritable = wasWritable;\n+        }\n+    }\n+\n+    @Label(\"Channel Inactive\")\n+    @Name(\"io.netty.channel.ChannelInactive\")\n+    private static final class ChannelInactiveEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Channel Active\")\n+    @Name(\"io.netty.channel.ChannelActive\")\n+    private static final class ChannelActiveEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"Deregister\")\n+    @Name(\"io.netty.channel.Deregister\")\n+    private static final class DeregisterEvent extends ChannelEvent {\n+    }\n+\n+    @Label(\"User Event Triggered\")\n+    @Name(\"io.netty.channel.UserEventTriggered\")\n+    private static final class UserEventTriggeredEvent extends ChannelEvent {\n+        @Label(\"User Event\")\n+        String userEvent;\n+\n+        void setUserEvent(Object evt) {\n+            this.userEvent = String.valueOf(evt);\n+        }\n+    }\n+\n+    @Label(\"Flush\")\n+    @Name(\"io.netty.channel.Flush\")\n+    private static final class FlushEvent extends ChannelIOEvent {\n+    }\n+\n+    @Label(\"Exception Caught\")\n+    @Name(\"io.netty.channel.ExceptionCaught\")\n+    private static final class ExceptionCaughtEvent extends ChannelEvent {\n+        @Label(\"Cause\")\n+        String cause;\n+\n+        void setCause(Throwable cause) {\n+            this.cause = cause.toString();",
        "comment_created_at": "2021-03-30T08:03:39+00:00",
        "comment_author": "bric3",
        "comment_body": "Invoking `toString` on the `Throwable` may have a noticeable performance impact.\r\nI believe the best practice is to deconstruct the throwable with the message and the type.\r\n\r\n```\r\n@Label(\"Message\")\r\nString message;\r\n\r\n@Label(\"Class\")\r\nClass<?> thrownClass;\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2098090775",
    "pr_number": 15210,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDomainSocketChannelConfig.java",
    "created_at": "2025-05-20T14:11:08+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.MessageSizeEstimator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.WriteBufferWaterMark;\n+import io.netty.channel.socket.DuplexChannelConfig;\n+import io.netty.channel.unix.DomainSocketChannelConfig;\n+import io.netty.channel.unix.DomainSocketReadMode;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+import static io.netty.channel.ChannelOption.SO_RCVBUF;\n+import static io.netty.channel.ChannelOption.SO_SNDBUF;\n+import static io.netty.channel.unix.UnixChannelOption.DOMAIN_SOCKET_READ_MODE;\n+\n+final class IoUringDomainSocketChannelConfig extends IoUringStreamChannelConfig\n+        implements DomainSocketChannelConfig, DuplexChannelConfig {\n+    private AtomicReference<DomainSocketReadMode> mode = new AtomicReference<>(DomainSocketReadMode.BYTES);",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2098090775",
        "repo_full_name": "netty/netty",
        "pr_number": 15210,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDomainSocketChannelConfig.java",
        "discussion_id": "2098090775",
        "commented_code": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.MessageSizeEstimator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.WriteBufferWaterMark;\n+import io.netty.channel.socket.DuplexChannelConfig;\n+import io.netty.channel.unix.DomainSocketChannelConfig;\n+import io.netty.channel.unix.DomainSocketReadMode;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+import static io.netty.channel.ChannelOption.SO_RCVBUF;\n+import static io.netty.channel.ChannelOption.SO_SNDBUF;\n+import static io.netty.channel.unix.UnixChannelOption.DOMAIN_SOCKET_READ_MODE;\n+\n+final class IoUringDomainSocketChannelConfig extends IoUringStreamChannelConfig\n+        implements DomainSocketChannelConfig, DuplexChannelConfig {\n+    private AtomicReference<DomainSocketReadMode> mode = new AtomicReference<>(DomainSocketReadMode.BYTES);",
        "comment_created_at": "2025-05-20T14:11:08+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "```suggestion\r\n    private final AtomicReference<DomainSocketReadMode> mode = new AtomicReference<>(DomainSocketReadMode.BYTES);\r\n```\r\nOr you might consider using `AtomicReferenceFieldUpdater` to reduce memory overhead",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086666534",
    "pr_number": 15160,
    "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
    "created_at": "2025-05-13T12:09:10+00:00",
    "commented_code": "}\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2086666534",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-13T12:09:10+00:00",
        "comment_author": "slandelle",
        "comment_body": "I know it's too late to consider this change for 4.2 but does this chain of instanceof really perform better than having a getOpCode() method on WebSocketFrame?",
        "pr_file_module": null
      },
      {
        "comment_id": "2086698698",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-13T12:26:07+00:00",
        "comment_author": "doom369",
        "comment_body": "I had same thoughts, first branch of `instanceOf` would be most likely faster rather than polymorphic call, but if we consider multiple branches, method could be a better choice. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2088163185",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T06:39:00+00:00",
        "comment_author": "He-Pin",
        "comment_body": "at least you shold make `        if (msg instanceof BinaryWebSocketFrame) {\r\n            return OPCODE_BINARY;\r\n        }` the second case.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088180706",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T06:49:41+00:00",
        "comment_author": "doom369",
        "comment_body": "agree, fixed. however I think it would be better to send a new PR after this one to introduce an abstract method `getOpCode` in `WebSocketFrame`",
        "pr_file_module": null
      },
      {
        "comment_id": "2088352302",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T08:17:23+00:00",
        "comment_author": "laosijikaichele",
        "comment_body": "@doom369 How about directly define the `opCode` in `XXXWebSocketFrame` class itself? Which will save the `instanceof` check. I see the `opCode` is part of the WebSocket frame: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2",
        "pr_file_module": null
      },
      {
        "comment_id": "2088362283",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T08:22:54+00:00",
        "comment_author": "slandelle",
        "comment_body": "I say define a concrete method on WebSocketFrame and pass the value from the concrete classes in the constructor.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088371522",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T08:27:35+00:00",
        "comment_author": "doom369",
        "comment_body": "will this change be accepted due to back compatibility?\r\n@slandelle constructor field may increase class memory layout.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088392077",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T08:35:42+00:00",
        "comment_author": "doom369",
        "comment_body": "@normanmaurer WDYT? If I add a method to `WebSocketFrame`, will this PR be accepted?",
        "pr_file_module": null
      },
      {
        "comment_id": "2088400971",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T08:40:16+00:00",
        "comment_author": "Munoon",
        "comment_body": "> constructor field may increase class memory layout\r\n\r\nThere is no need to hold the value in a variable, since the `opCode` is known based on the class. We can just return the constant value from the method, and there will be no memory footprint.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088458253",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T09:09:22+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "@doom369 I think this would be kind of a \"breaking change\". As we could only add a default method that return something invalid by default. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2088793240",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T12:11:15+00:00",
        "comment_author": "laosijikaichele",
        "comment_body": "I made a sample commit to better show the idea: [commit](https://github.com/laosijikaichele/netty/commit/a0fe10902465632fe8fa38b4ad196217e94522f4), which I think still maintain the compatibility. WDYT? @normanmaurer @doom369 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2088986234",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T13:42:48+00:00",
        "comment_author": "doom369",
        "comment_body": "Honestly, I don't see the point in bothering here. It's a breaking change as Norman said, and most likely `instanceOf` will outperform polymorphic method call in most real scenarios.",
        "pr_file_module": null
      },
      {
        "comment_id": "2089024455",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T13:58:17+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I agree I think this is not needed",
        "pr_file_module": null
      },
      {
        "comment_id": "2089025292",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-14T13:58:39+00:00",
        "comment_author": "doom369",
        "comment_body": "For those who curious:\r\n\r\n```\r\n@Fork(value = 1)\r\n@BenchmarkMode(Mode.AverageTime)\r\n@State(Scope.Benchmark)\r\n@Warmup(iterations = 3)\r\n@Measurement(iterations = 3)\r\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\npublic class InstanceOfVSMethodCallBench2 {\r\n    private Inter[] classes;\r\n\r\n    @Test\r\n    public void bench() throws RunnerException {\r\n        Options options = new OptionsBuilder()\r\n                .include(InstanceOfVSMethodCallBench2.class.getSimpleName())\r\n                .build();\r\n        new Runner(options).run();\r\n    }\r\n\r\n    @Setup\r\n    public void setup() {\r\n        classes = new Inter[100];\r\n        int num = 0;\r\n        for (int i = 0; i < classes.length; i++) {\r\n            if (num == 0) {\r\n                classes[i] = new A();\r\n                num++;\r\n            } else if (num == 1) {\r\n                classes[i] = new B();\r\n                num++;\r\n            } else {\r\n                classes[i] = new C();\r\n                num = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Benchmark\r\n    public int instanceOf() {\r\n        int result = 0;\r\n        for (Inter claszz : classes) {\r\n            result += getCode(claszz);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Benchmark\r\n    public int method() {\r\n        int result = 0;\r\n        for (Inter claszz : classes) {\r\n            result += claszz.code();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private static int getCode(Inter inter) {\r\n        if (inter instanceof A) {\r\n            return 2;\r\n        }\r\n        if (inter instanceof B) {\r\n            return 3;\r\n        }\r\n        if (inter instanceof C) {\r\n            return 4;\r\n        }\r\n        throw new RuntimeException(\"Unknown class\");\r\n    }\r\n\r\n    public interface Inter {\r\n        default int code() {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    public static class A implements Inter {\r\n        @Override\r\n        public int code() {\r\n            return 2;\r\n        }\r\n    }\r\n\r\n    public static class B implements Inter {\r\n        @Override\r\n        public int code() {\r\n            return 3;\r\n        }\r\n    }\r\n\r\n    public static class C implements Inter {\r\n        @Override\r\n        public int code() {\r\n            return 4;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n```\r\nBenchmark                                Mode  Cnt    Score   Error  Units\r\nInstanceOfVSMethodCallBench2.instanceOf  avgt    3   50.607  8.511  ns/op\r\nInstanceOfVSMethodCallBench2.method      avgt    3  160.709  3.378  ns/op\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2097321530",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-20T08:28:20+00:00",
        "comment_author": "franz1981",
        "comment_body": "Why not having the code into a base class field and just use a non overridden code() method to read It?\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2097333144",
        "repo_full_name": "netty/netty",
        "pr_number": 15160,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
        "discussion_id": "2086666534",
        "commented_code": "@@ -229,4 +214,27 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             }\n         }\n     }\n+\n+    private static byte getOpCode(WebSocketFrame msg) {",
        "comment_created_at": "2025-05-20T08:31:16+00:00",
        "comment_author": "doom369",
        "comment_body": "additional field -> increased footprint, for a code that used in 1 place. Also, it would be not back compatible change?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1894581153",
    "pr_number": 14607,
    "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
    "created_at": "2024-12-21T07:56:08+00:00",
    "commented_code": "threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1894581153",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T07:56:08+00:00",
        "comment_author": "franz1981",
        "comment_body": "The problem of using thread local is based on the caller - not a global behaviour IMO: you want a way to instruct the allocator to...\r\n1. use thread local on the usual known platform thread type (configurable)\r\n2. not use thread local if not",
        "pr_file_module": null
      },
      {
        "comment_id": "1894581750",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T08:02:15+00:00",
        "comment_author": "laosijikaichele",
        "comment_body": "Yes, maybe this can be done by `Thread.isVirtual()`? but currently it use the constructor param to decide whether disable `threadLocal` or not, also I wonder how `AdaptivePoolingAllocator` deal with this?",
        "pr_file_module": null
      },
      {
        "comment_id": "1894582742",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T08:11:43+00:00",
        "comment_author": "franz1981",
        "comment_body": "I would instead provide some API to inject/override (not always possible to not break the public APIs) a different behaviour, instead.\r\n\r\n> also I wonder how AdaptivePoolingAllocator deal with this?\r\n\r\nthe adaptive allocator never block and not-shareable (which doesn't belong to event loops) magazine are using an mpsc recycler for ByteBuf wrappers, which belong to the magazine itself (not bound to any thread).\r\nI've implemented something similar for the non adaptive allocator some time ago, but TBH the adaptive IMO is the way to go.\r\nMaintaining a jemalloc-java version has been a PITA (no pun intended) along these year - ask @normanmaurer and @chrisvest about it...",
        "pr_file_module": null
      },
      {
        "comment_id": "1894583335",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T08:17:44+00:00",
        "comment_author": "laosijikaichele",
        "comment_body": ":smile:, Maybe it's true, but, IMHO, if the `AdaptivePoolingAllocator` wants to better deal with the memory-reusing and fragment-reduction issues, it will eventually end up with the similar approaches which `PooledByteBufAllocator` has already done...",
        "pr_file_module": null
      },
      {
        "comment_id": "1894585132",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T08:34:28+00:00",
        "comment_author": "franz1981",
        "comment_body": "Not sure, think about garbage collectors: the approach taken by the adaptive allocator is very very similar to OpenJDK TLABs which has served pretty well.\r\nClearly it work better if the allocator is used for networking and in the event loop, but the price for simplicity is to be biased specific use cases, which is a pros IMO.",
        "pr_file_module": null
      },
      {
        "comment_id": "1894587199",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1894581153",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;",
        "comment_created_at": "2024-12-21T08:52:09+00:00",
        "comment_author": "laosijikaichele",
        "comment_body": "> Clearly it work better if the allocator is used for networking and in the event loop, but the price for simplicity is to be biased specific use cases, which is a pros IMO.\r\n\r\nYes, I also like the `adaptive` one, but to cover more different use cases, this RP gives the users one more option.\r\n\r\n**UPDATE**: As said, the OpenJDK TLABs(thread-local allocation buffers) utilize the `thread-local` to improve performance, but this PR focuses on the `NON-thread-local` use case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012598702",
    "pr_number": 14962,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/CompletionQueue.java",
    "created_at": "2025-03-25T17:31:50+00:00",
    "commented_code": "private static final int CQE_RES_FIELD = 8;\n     private static final int CQE_FLAGS_FIELD = 12;\n \n-    private static final long CQE_SIZE = 16;\n-\n-    //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n-    private final long kHeadAddress;\n-    private final long kTailAddress;\n-\n-    private final long completionQueueArrayAddress;\n+    static final int CQE_SIZE = 16;\n \n+    //these unsigned integer pointers(shared with the kernel) will be changed by the kernel and us\n+    // using a VarHandle.\n+    private final ByteBuffer khead;\n+    private final ByteBuffer ktail;\n+    private final ByteBuffer completionQueueArray;\n+    private final VarHandle intHandle;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2012598702",
        "repo_full_name": "netty/netty",
        "pr_number": 14962,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/CompletionQueue.java",
        "discussion_id": "2012598702",
        "commented_code": "@@ -30,14 +32,14 @@ final class CompletionQueue {\n     private static final int CQE_RES_FIELD = 8;\n     private static final int CQE_FLAGS_FIELD = 12;\n \n-    private static final long CQE_SIZE = 16;\n-\n-    //these unsigned integer pointers(shared with the kernel) will be changed by the kernel\n-    private final long kHeadAddress;\n-    private final long kTailAddress;\n-\n-    private final long completionQueueArrayAddress;\n+    static final int CQE_SIZE = 16;\n \n+    //these unsigned integer pointers(shared with the kernel) will be changed by the kernel and us\n+    // using a VarHandle.\n+    private final ByteBuffer khead;\n+    private final ByteBuffer ktail;\n+    private final ByteBuffer completionQueueArray;\n+    private final VarHandle intHandle;",
        "comment_created_at": "2025-03-25T17:31:50+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "Please make this varhandle `static final` to get the best peak performance",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921864018",
    "pr_number": 14690,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java",
    "created_at": "2025-01-20T06:37:52+00:00",
    "commented_code": "final IoUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             final ChannelPipeline pipeline = pipeline();\n             ByteBuf byteBuf = this.readBuffer;\n+            IoUringBufferRing bufferRing = lastUsedBufferRing;\n             this.readBuffer = null;\n-            assert byteBuf != null;\n+            this.lastUsedBufferRing = null;\n \n             try {\n                 if (res < 0) {\n                     if (res == Native.ERRNO_ECANCELED_NEGATIVE) {\n-                        byteBuf.release();\n+                        if (byteBuf != null) {\n+                            //recv without buffer ring\n+                            byteBuf.release();\n+                        }\n+                        return;\n+                    }\n+\n+                    if (res == Native.ERRNO_NO_BUFFER_NEGATIVE) {\n+                        //recv with provider buffer fail!\n+                        //fallback to normal recv\n+                        bufferRing.markReadFail();\n+                        // fire the BufferRingExhaustedEvent to notify users.\n+                        // Users can then switch the ring buffer or do other things as they wish\n+                        pipeline.fireUserEventTriggered(new BufferRingExhaustedEvent(bufferRing.bufferGroupId()));",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1921864018",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java",
        "discussion_id": "1921864018",
        "commented_code": "@@ -344,19 +391,38 @@ protected void readComplete0(byte op, int res, int flags, short data, int outsta\n             final IoUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             final ChannelPipeline pipeline = pipeline();\n             ByteBuf byteBuf = this.readBuffer;\n+            IoUringBufferRing bufferRing = lastUsedBufferRing;\n             this.readBuffer = null;\n-            assert byteBuf != null;\n+            this.lastUsedBufferRing = null;\n \n             try {\n                 if (res < 0) {\n                     if (res == Native.ERRNO_ECANCELED_NEGATIVE) {\n-                        byteBuf.release();\n+                        if (byteBuf != null) {\n+                            //recv without buffer ring\n+                            byteBuf.release();\n+                        }\n+                        return;\n+                    }\n+\n+                    if (res == Native.ERRNO_NO_BUFFER_NEGATIVE) {\n+                        //recv with provider buffer fail!\n+                        //fallback to normal recv\n+                        bufferRing.markReadFail();\n+                        // fire the BufferRingExhaustedEvent to notify users.\n+                        // Users can then switch the ring buffer or do other things as they wish\n+                        pipeline.fireUserEventTriggered(new BufferRingExhaustedEvent(bufferRing.bufferGroupId()));",
        "comment_created_at": "2025-01-20T06:37:52+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I like this a lot... We could also store pre-created `BufferRingExhaustedEvent`s in `bufferRing` and return the same instance for the same id. This would reduce GC a bit.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921875563",
    "pr_number": 14690,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
    "created_at": "2025-01-20T06:52:06+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;\n+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;\n+        short oldTail = PlatformDependent.getShort(tailFieldAddress);\n+        int ringIndex = oldTail & mask;\n+        long ioUringBufAddress = ioUringBufRingAddr + (long) Native.SIZEOF_IOURING_BUF * ringIndex;\n+        PlatformDependent.putLong(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_ADDR, byteBuf.memoryAddress());\n+        PlatformDependent.putInt(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_LEN, (short) byteBuf.capacity());\n+        PlatformDependent.putShort(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_BID, bid);\n+        if (needAdvance) {\n+            advanceTail(1);\n+        }\n+    }\n+\n+    void appendBuffer(ByteBufAllocator byteBufAllocator, int count) {\n+        int expectedIndex = nextIndex + count;\n+        if (expectedIndex > entries) {\n+            throw new IllegalStateException(\"Buffer ring is full\");\n+        }\n+\n+        for (int i = 0; i < count; i++) {\n+            ByteBuf buffer = byteBufAllocator.ioBuffer(chunkSize);\n+            userspaceBufferHolder[nextIndex] = buffer;\n+            addToRing(nextIndex, false);\n+            nextIndex++;\n+        }\n+        advanceTail(count);\n+    }\n+\n+    ByteBuf borrowBuffer(int bid, int maxCap) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        ByteBuf slice = byteBuf.slice(0, maxCap);\n+        return new UserspaceIoUringBuffer(maxCap, (short) bid, slice);\n+    }\n+\n+    private void advanceTail(int count) {\n+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;\n+        short oldTail = PlatformDependent.getShort(tailFieldAddress);\n+        short newTail = (short) (oldTail + count);\n+        PlatformDependent.putShortVolatile(tailFieldAddress, newTail);\n+        hasSpareBuffer = true;\n+    }\n+\n+    public int entries() {\n+        return entries;\n+    }\n+\n+    public short bufferGroupId() {\n+        return bufferGroupId;\n+    }\n+\n+    public int chunkSize() {\n+        return chunkSize;\n+    }\n+\n+    public boolean isFull() {\n+        return nextIndex == entries;\n+    }\n+\n+    public long address() {\n+        return ioUringBufRingAddr;\n+    }\n+\n+    public void close() {\n+        Native.ioUringUnRegisterBufRing(ringFd, ioUringBufRingAddr, 4, 1);\n+        for (ByteBuf byteBuf : userspaceBufferHolder) {\n+            if (byteBuf != null) {\n+                byteBuf.release();\n+            }\n+        }\n+    }\n+\n+    public class UserspaceIoUringBuffer extends AbstractReferenceCountedByteBuf {\n+\n+        private final short bid;\n+\n+        private final ByteBuf userspaceBuffer;\n+\n+        protected UserspaceIoUringBuffer(int maxCapacity, short bid, ByteBuf userspaceBuffer) {\n+            super(maxCapacity);\n+            this.bid = bid;\n+            this.userspaceBuffer = userspaceBuffer;\n+        }\n+\n+        @Override\n+        protected void deallocate() {\n+            recycleBuffer(bid);\n+        }\n+\n+        @Override\n+        protected byte _getByte(int index) {\n+            return userspaceBuffer.getByte(index);\n+        }\n+\n+        @Override\n+        protected short _getShort(int index) {\n+            return userspaceBuffer.getShort(index);\n+        }\n+\n+        @Override\n+        protected short _getShortLE(int index) {\n+            return userspaceBuffer.getShortLE(index);\n+        }\n+\n+        @Override\n+        protected int _getUnsignedMedium(int index) {\n+            return userspaceBuffer.getUnsignedMedium(index);\n+        }\n+\n+        @Override\n+        protected int _getUnsignedMediumLE(int index) {\n+            return userspaceBuffer.getUnsignedMediumLE(index);\n+        }\n+\n+        @Override\n+        protected int _getInt(int index) {\n+            return userspaceBuffer.getInt(index);\n+        }\n+\n+        @Override\n+        protected int _getIntLE(int index) {\n+            return userspaceBuffer.getIntLE(index);\n+        }\n+\n+        @Override\n+        protected long _getLong(int index) {\n+            return userspaceBuffer.getLong(index);\n+        }\n+\n+        @Override\n+        protected long _getLongLE(int index) {\n+            return userspaceBuffer.getLongLE(index);\n+        }\n+\n+        @Override\n+        protected void _setByte(int index, int value) {\n+            userspaceBuffer.setByte(index, value);\n+        }\n+\n+        @Override\n+        protected void _setShort(int index, int value) {\n+            userspaceBuffer.setShort(index, value);\n+        }\n+\n+        @Override\n+        protected void _setShortLE(int index, int value) {\n+            userspaceBuffer.setShortLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setMedium(int index, int value) {\n+            userspaceBuffer.setMedium(index, value);\n+        }\n+\n+        @Override\n+        protected void _setMediumLE(int index, int value) {\n+            userspaceBuffer.setMediumLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setInt(int index, int value) {\n+            userspaceBuffer.setInt(index, value);\n+        }\n+\n+        @Override\n+        protected void _setIntLE(int index, int value) {\n+            userspaceBuffer.setIntLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setLong(int index, long value) {\n+            userspaceBuffer.setLong(index, value);\n+        }\n+\n+        @Override\n+        protected void _setLongLE(int index, long value) {\n+            userspaceBuffer.setLongLE(index, value);\n+        }\n+\n+        @Override\n+        public int capacity() {\n+            return maxCapacity();\n+        }\n+\n+        @Override\n+        public ByteBuf capacity(int newCapacity) {\n+            return this;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1921875563",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
        "discussion_id": "1921875563",
        "commented_code": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;\n+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;\n+        short oldTail = PlatformDependent.getShort(tailFieldAddress);\n+        int ringIndex = oldTail & mask;\n+        long ioUringBufAddress = ioUringBufRingAddr + (long) Native.SIZEOF_IOURING_BUF * ringIndex;\n+        PlatformDependent.putLong(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_ADDR, byteBuf.memoryAddress());\n+        PlatformDependent.putInt(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_LEN, (short) byteBuf.capacity());\n+        PlatformDependent.putShort(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_BID, bid);\n+        if (needAdvance) {\n+            advanceTail(1);\n+        }\n+    }\n+\n+    void appendBuffer(ByteBufAllocator byteBufAllocator, int count) {\n+        int expectedIndex = nextIndex + count;\n+        if (expectedIndex > entries) {\n+            throw new IllegalStateException(\"Buffer ring is full\");\n+        }\n+\n+        for (int i = 0; i < count; i++) {\n+            ByteBuf buffer = byteBufAllocator.ioBuffer(chunkSize);\n+            userspaceBufferHolder[nextIndex] = buffer;\n+            addToRing(nextIndex, false);\n+            nextIndex++;\n+        }\n+        advanceTail(count);\n+    }\n+\n+    ByteBuf borrowBuffer(int bid, int maxCap) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        ByteBuf slice = byteBuf.slice(0, maxCap);\n+        return new UserspaceIoUringBuffer(maxCap, (short) bid, slice);\n+    }\n+\n+    private void advanceTail(int count) {\n+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;\n+        short oldTail = PlatformDependent.getShort(tailFieldAddress);\n+        short newTail = (short) (oldTail + count);\n+        PlatformDependent.putShortVolatile(tailFieldAddress, newTail);\n+        hasSpareBuffer = true;\n+    }\n+\n+    public int entries() {\n+        return entries;\n+    }\n+\n+    public short bufferGroupId() {\n+        return bufferGroupId;\n+    }\n+\n+    public int chunkSize() {\n+        return chunkSize;\n+    }\n+\n+    public boolean isFull() {\n+        return nextIndex == entries;\n+    }\n+\n+    public long address() {\n+        return ioUringBufRingAddr;\n+    }\n+\n+    public void close() {\n+        Native.ioUringUnRegisterBufRing(ringFd, ioUringBufRingAddr, 4, 1);\n+        for (ByteBuf byteBuf : userspaceBufferHolder) {\n+            if (byteBuf != null) {\n+                byteBuf.release();\n+            }\n+        }\n+    }\n+\n+    public class UserspaceIoUringBuffer extends AbstractReferenceCountedByteBuf {\n+\n+        private final short bid;\n+\n+        private final ByteBuf userspaceBuffer;\n+\n+        protected UserspaceIoUringBuffer(int maxCapacity, short bid, ByteBuf userspaceBuffer) {\n+            super(maxCapacity);\n+            this.bid = bid;\n+            this.userspaceBuffer = userspaceBuffer;\n+        }\n+\n+        @Override\n+        protected void deallocate() {\n+            recycleBuffer(bid);\n+        }\n+\n+        @Override\n+        protected byte _getByte(int index) {\n+            return userspaceBuffer.getByte(index);\n+        }\n+\n+        @Override\n+        protected short _getShort(int index) {\n+            return userspaceBuffer.getShort(index);\n+        }\n+\n+        @Override\n+        protected short _getShortLE(int index) {\n+            return userspaceBuffer.getShortLE(index);\n+        }\n+\n+        @Override\n+        protected int _getUnsignedMedium(int index) {\n+            return userspaceBuffer.getUnsignedMedium(index);\n+        }\n+\n+        @Override\n+        protected int _getUnsignedMediumLE(int index) {\n+            return userspaceBuffer.getUnsignedMediumLE(index);\n+        }\n+\n+        @Override\n+        protected int _getInt(int index) {\n+            return userspaceBuffer.getInt(index);\n+        }\n+\n+        @Override\n+        protected int _getIntLE(int index) {\n+            return userspaceBuffer.getIntLE(index);\n+        }\n+\n+        @Override\n+        protected long _getLong(int index) {\n+            return userspaceBuffer.getLong(index);\n+        }\n+\n+        @Override\n+        protected long _getLongLE(int index) {\n+            return userspaceBuffer.getLongLE(index);\n+        }\n+\n+        @Override\n+        protected void _setByte(int index, int value) {\n+            userspaceBuffer.setByte(index, value);\n+        }\n+\n+        @Override\n+        protected void _setShort(int index, int value) {\n+            userspaceBuffer.setShort(index, value);\n+        }\n+\n+        @Override\n+        protected void _setShortLE(int index, int value) {\n+            userspaceBuffer.setShortLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setMedium(int index, int value) {\n+            userspaceBuffer.setMedium(index, value);\n+        }\n+\n+        @Override\n+        protected void _setMediumLE(int index, int value) {\n+            userspaceBuffer.setMediumLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setInt(int index, int value) {\n+            userspaceBuffer.setInt(index, value);\n+        }\n+\n+        @Override\n+        protected void _setIntLE(int index, int value) {\n+            userspaceBuffer.setIntLE(index, value);\n+        }\n+\n+        @Override\n+        protected void _setLong(int index, long value) {\n+            userspaceBuffer.setLong(index, value);\n+        }\n+\n+        @Override\n+        protected void _setLongLE(int index, long value) {\n+            userspaceBuffer.setLongLE(index, value);\n+        }\n+\n+        @Override\n+        public int capacity() {\n+            return maxCapacity();\n+        }\n+\n+        @Override\n+        public ByteBuf capacity(int newCapacity) {\n+            return this;",
        "comment_created_at": "2025-01-20T06:52:06+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "We need to fix this... Like if the capacity requested is something we can no full-fill we need to return the borrowed buffer and allocate a new one from the allocator directly to back this one ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921931656",
    "pr_number": 14690,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
    "created_at": "2025-01-20T07:48:17+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1921931656",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
        "discussion_id": "1921931656",
        "commented_code": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {",
        "comment_created_at": "2025-01-20T07:48:17+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "as all the possible `bid`s are known we should pre-create the `Runnable`s and reuse them to reduce GC pressure.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1853371480",
    "pr_number": 14487,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringFileRegion.java",
    "created_at": "2024-11-22T06:57:13+00:00",
    "commented_code": "+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.FileRegion;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+final class IoUringFileRegion implements FileRegion {\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringFileRegion.class);\n+\n+    private static final short SPLICE_TO_PIPE = 1;\n+    private static final short SPLICE_TO_SOCKET = 2;\n+\n+    private final DefaultFileRegion fileRegion;\n+    private FileDescriptor[] pipe;\n+    private int transferred;\n+    private int pipeLen;\n+\n+    IoUringFileRegion(DefaultFileRegion fileRegion) {\n+        this.fileRegion = fileRegion;\n+    }\n+\n+    void open() throws IOException {\n+        fileRegion.open();\n+        if (pipe == null) {\n+            pipe = FileDescriptor.pipe();",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1853371480",
        "repo_full_name": "netty/netty",
        "pr_number": 14487,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringFileRegion.java",
        "discussion_id": "1853371480",
        "commented_code": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.FileRegion;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+final class IoUringFileRegion implements FileRegion {\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringFileRegion.class);\n+\n+    private static final short SPLICE_TO_PIPE = 1;\n+    private static final short SPLICE_TO_SOCKET = 2;\n+\n+    private final DefaultFileRegion fileRegion;\n+    private FileDescriptor[] pipe;\n+    private int transferred;\n+    private int pipeLen;\n+\n+    IoUringFileRegion(DefaultFileRegion fileRegion) {\n+        this.fileRegion = fileRegion;\n+    }\n+\n+    void open() throws IOException {\n+        fileRegion.open();\n+        if (pipe == null) {\n+            pipe = FileDescriptor.pipe();",
        "comment_created_at": "2024-11-22T06:57:13+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "I don't think a pair of pipes should be initialized every time `IoUringFileRegion` is initiated.\r\nI think it's possible to initialize a pair of pipes lazily and then store them in the channel so that they can be reused multiple times.\r\nJust like the pipeIn and pipeOut in AbstractEpollStreamChannel. \r\n``` java\r\n  // Lazy init these if we need to splice(...)\r\n    private FileDescriptor pipeIn;\r\n    private FileDescriptor pipeOut;\r\n\r\n  // We create the pipe on the target channel as this will allow us to just handle pending writes\r\n                // later in a correct fashion without get into any ordering issues when spliceTo(...) is called\r\n                // on multiple Channels pointing to one target Channel.\r\n                FileDescriptor pipeOut = ch.pipeOut;\r\n                if (pipeOut == null) {\r\n                    // Create a new pipe as non was created before.\r\n                    FileDescriptor[] pipe = pipe();\r\n                    ch.pipeIn = pipe[0];\r\n                    pipeOut = ch.pipeOut = pipe[1];\r\n                }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1853723560",
        "repo_full_name": "netty/netty",
        "pr_number": 14487,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringFileRegion.java",
        "discussion_id": "1853371480",
        "commented_code": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.FileRegion;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+final class IoUringFileRegion implements FileRegion {\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringFileRegion.class);\n+\n+    private static final short SPLICE_TO_PIPE = 1;\n+    private static final short SPLICE_TO_SOCKET = 2;\n+\n+    private final DefaultFileRegion fileRegion;\n+    private FileDescriptor[] pipe;\n+    private int transferred;\n+    private int pipeLen;\n+\n+    IoUringFileRegion(DefaultFileRegion fileRegion) {\n+        this.fileRegion = fileRegion;\n+    }\n+\n+    void open() throws IOException {\n+        fileRegion.open();\n+        if (pipe == null) {\n+            pipe = FileDescriptor.pipe();",
        "comment_created_at": "2024-11-22T10:50:09+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I am not sure we should do this. `sendfile(...)` does create a new pair of pipes as well every time. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1853997674",
        "repo_full_name": "netty/netty",
        "pr_number": 14487,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringFileRegion.java",
        "discussion_id": "1853371480",
        "commented_code": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.FileRegion;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+final class IoUringFileRegion implements FileRegion {\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringFileRegion.class);\n+\n+    private static final short SPLICE_TO_PIPE = 1;\n+    private static final short SPLICE_TO_SOCKET = 2;\n+\n+    private final DefaultFileRegion fileRegion;\n+    private FileDescriptor[] pipe;\n+    private int transferred;\n+    private int pipeLen;\n+\n+    IoUringFileRegion(DefaultFileRegion fileRegion) {\n+        this.fileRegion = fileRegion;\n+    }\n+\n+    void open() throws IOException {\n+        fileRegion.open();\n+        if (pipe == null) {\n+            pipe = FileDescriptor.pipe();",
        "comment_created_at": "2024-11-22T14:26:38+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "> I am not sure we should do this. `sendfile(...)` does create a new pair of pipes as well every time.\r\n\r\nPerhaps we can implement the reuse of pipes,FYI:\r\n\r\nhttps://github.com/dreamlike-ocean/netty/commit/ffed09007d93f69dea2c373629af4e8fcf5d6fc5\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1860778681",
        "repo_full_name": "netty/netty",
        "pr_number": 14487,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringFileRegion.java",
        "discussion_id": "1853371480",
        "commented_code": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2024 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.FileRegion;\n+import io.netty.channel.unix.FileDescriptor;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+final class IoUringFileRegion implements FileRegion {\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringFileRegion.class);\n+\n+    private static final short SPLICE_TO_PIPE = 1;\n+    private static final short SPLICE_TO_SOCKET = 2;\n+\n+    private final DefaultFileRegion fileRegion;\n+    private FileDescriptor[] pipe;\n+    private int transferred;\n+    private int pipeLen;\n+\n+    IoUringFileRegion(DefaultFileRegion fileRegion) {\n+        this.fileRegion = fileRegion;\n+    }\n+\n+    void open() throws IOException {\n+        fileRegion.open();\n+        if (pipe == null) {\n+            pipe = FileDescriptor.pipe();",
        "comment_created_at": "2024-11-27T14:36:00+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": " I think it's still better to reuse the pipeFd and cache it within the channel",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1860253410",
    "pr_number": 14508,
    "pr_file": "buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java",
    "created_at": "2024-11-27T09:02:59+00:00",
    "commented_code": "delegate.setIndex(0, 0);\n                 allocatedBytes = 0;\n                 if (!mag.trySetNextInLine(this)) {\n+                    mag.usedMemory.getAndAdd(-capacity());",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1860253410",
        "repo_full_name": "netty/netty",
        "pr_number": 14508,
        "pr_file": "buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java",
        "discussion_id": "1860253410",
        "commented_code": "@@ -825,6 +825,7 @@ private void deallocate() {\n                 delegate.setIndex(0, 0);\n                 allocatedBytes = 0;\n                 if (!mag.trySetNextInLine(this)) {\n+                    mag.usedMemory.getAndAdd(-capacity());",
        "comment_created_at": "2024-11-27T09:02:59+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "```suggestion\r\n                    // As this Chunk does not belong to the mag anymore we need to decrease the used memory .\r\n                    mag.usedMemory.getAndAdd(-capacity());\r\n```",
        "pr_file_module": null
      }
    ]
  }
]