[
  {
    "discussion_id": "2172152436",
    "pr_number": 15399,
    "pr_file": "buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java",
    "created_at": "2025-06-27T14:19:21+00:00",
    "commented_code": "* Each chunk in this queue can be up to {@link #MAX_CHUNK_SIZE} in size, so it is recommended to use a bounded\n      * queue to limit the maximum memory usage.\n      * <p>\n-     * The default implementation will create a bounded queue with a capacity of {@link #CENTRAL_QUEUE_CAPACITY}.\n+     * The default implementation will create a bounded queue with a capacity of {@link #CHUNK_REUSE_QUEUE}.\n      *\n      * @return A new multi-producer, multi-consumer queue.\n      */\n     private static Queue<Chunk> createSharedChunkQueue() {\n-        return PlatformDependent.newFixedMpmcQueue(CENTRAL_QUEUE_CAPACITY);\n+        return PlatformDependent.newFixedMpmcQueue(CHUNK_REUSE_QUEUE);\n     }\n \n     ByteBuf allocate(int size, int maxCapacity) {\n         return allocate(size, maxCapacity, Thread.currentThread(), null);\n     }\n \n     private AdaptiveByteBuf allocate(int size, int maxCapacity, Thread currentThread, AdaptiveByteBuf buf) {\n-        boolean reallocate = buf != null;\n+        AdaptiveByteBuf allocated = null;\n         if (size <= MAX_POOLED_BUF_SIZE) {\n-            FastThreadLocal<Object> threadLocalMagazine = this.threadLocalMagazine;\n-            if (threadLocalMagazine != null && FastThreadLocalThread.currentThreadHasFastThreadLocal()) {\n-                Object mag = threadLocalMagazine.get();\n-                if (mag != NO_MAGAZINE) {\n-                    Magazine magazine = (Magazine) mag;\n-                    if (buf == null) {\n-                        buf = magazine.newBuffer();\n-                    }\n-                    boolean allocated = magazine.tryAllocate(size, maxCapacity, buf, reallocate);\n-                    assert allocated : \"Allocation of threadLocalMagazine must always succeed\";\n-                    return buf;\n-                }\n+            int index = Arrays.binarySearch(SIZE_CLASSES, size);\n+            if (index < 0) {\n+                index = -(index + 1);",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2172152436",
        "repo_full_name": "netty/netty",
        "pr_number": 15399,
        "pr_file": "buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java",
        "discussion_id": "2172152436",
        "commented_code": "@@ -213,61 +228,44 @@ protected void onRemoval(final Object value) throws Exception {\n      * Each chunk in this queue can be up to {@link #MAX_CHUNK_SIZE} in size, so it is recommended to use a bounded\n      * queue to limit the maximum memory usage.\n      * <p>\n-     * The default implementation will create a bounded queue with a capacity of {@link #CENTRAL_QUEUE_CAPACITY}.\n+     * The default implementation will create a bounded queue with a capacity of {@link #CHUNK_REUSE_QUEUE}.\n      *\n      * @return A new multi-producer, multi-consumer queue.\n      */\n     private static Queue<Chunk> createSharedChunkQueue() {\n-        return PlatformDependent.newFixedMpmcQueue(CENTRAL_QUEUE_CAPACITY);\n+        return PlatformDependent.newFixedMpmcQueue(CHUNK_REUSE_QUEUE);\n     }\n \n     ByteBuf allocate(int size, int maxCapacity) {\n         return allocate(size, maxCapacity, Thread.currentThread(), null);\n     }\n \n     private AdaptiveByteBuf allocate(int size, int maxCapacity, Thread currentThread, AdaptiveByteBuf buf) {\n-        boolean reallocate = buf != null;\n+        AdaptiveByteBuf allocated = null;\n         if (size <= MAX_POOLED_BUF_SIZE) {\n-            FastThreadLocal<Object> threadLocalMagazine = this.threadLocalMagazine;\n-            if (threadLocalMagazine != null && FastThreadLocalThread.currentThreadHasFastThreadLocal()) {\n-                Object mag = threadLocalMagazine.get();\n-                if (mag != NO_MAGAZINE) {\n-                    Magazine magazine = (Magazine) mag;\n-                    if (buf == null) {\n-                        buf = magazine.newBuffer();\n-                    }\n-                    boolean allocated = magazine.tryAllocate(size, maxCapacity, buf, reallocate);\n-                    assert allocated : \"Allocation of threadLocalMagazine must always succeed\";\n-                    return buf;\n-                }\n+            int index = Arrays.binarySearch(SIZE_CLASSES, size);\n+            if (index < 0) {\n+                index = -(index + 1);",
        "comment_created_at": "2025-06-27T14:19:21+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Maybe consider adding a comment that we +1 it as it is the \"insertion point\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2172720067",
        "repo_full_name": "netty/netty",
        "pr_number": 15399,
        "pr_file": "buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java",
        "discussion_id": "2172152436",
        "commented_code": "@@ -213,61 +228,44 @@ protected void onRemoval(final Object value) throws Exception {\n      * Each chunk in this queue can be up to {@link #MAX_CHUNK_SIZE} in size, so it is recommended to use a bounded\n      * queue to limit the maximum memory usage.\n      * <p>\n-     * The default implementation will create a bounded queue with a capacity of {@link #CENTRAL_QUEUE_CAPACITY}.\n+     * The default implementation will create a bounded queue with a capacity of {@link #CHUNK_REUSE_QUEUE}.\n      *\n      * @return A new multi-producer, multi-consumer queue.\n      */\n     private static Queue<Chunk> createSharedChunkQueue() {\n-        return PlatformDependent.newFixedMpmcQueue(CENTRAL_QUEUE_CAPACITY);\n+        return PlatformDependent.newFixedMpmcQueue(CHUNK_REUSE_QUEUE);\n     }\n \n     ByteBuf allocate(int size, int maxCapacity) {\n         return allocate(size, maxCapacity, Thread.currentThread(), null);\n     }\n \n     private AdaptiveByteBuf allocate(int size, int maxCapacity, Thread currentThread, AdaptiveByteBuf buf) {\n-        boolean reallocate = buf != null;\n+        AdaptiveByteBuf allocated = null;\n         if (size <= MAX_POOLED_BUF_SIZE) {\n-            FastThreadLocal<Object> threadLocalMagazine = this.threadLocalMagazine;\n-            if (threadLocalMagazine != null && FastThreadLocalThread.currentThreadHasFastThreadLocal()) {\n-                Object mag = threadLocalMagazine.get();\n-                if (mag != NO_MAGAZINE) {\n-                    Magazine magazine = (Magazine) mag;\n-                    if (buf == null) {\n-                        buf = magazine.newBuffer();\n-                    }\n-                    boolean allocated = magazine.tryAllocate(size, maxCapacity, buf, reallocate);\n-                    assert allocated : \"Allocation of threadLocalMagazine must always succeed\";\n-                    return buf;\n-                }\n+            int index = Arrays.binarySearch(SIZE_CLASSES, size);\n+            if (index < 0) {\n+                index = -(index + 1);",
        "comment_created_at": "2025-06-27T19:25:31+00:00",
        "comment_author": "franz1981",
        "comment_body": "Actually if we know the last/max value we should check that one first ^^ to avoid the log2(n) useless checks.\r\nIf it is stored in a static final field will be trusted and it won't cost like reaching first the array base + offset of position",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1347297733",
    "pr_number": 13647,
    "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java",
    "created_at": "2023-10-05T11:49:59+00:00",
    "commented_code": "return isInformational;\n     }\n \n+    /**\n+     * According to RFC 9113, \"Pseudo-header fields defined for requests MUST NOT appear in responses;\n+     * pseudo-header fields defined for responses MUST NOT appear in requests.\"\n+     * @return {@code true} if validation completed successfully, {@code false} if not\n+     */\n+    private boolean validatePseudoHeaders(Http2Headers headers) {\n+        boolean isResponseHeaders = connection.isServer();\n+        for (CharSequence name : headers.names()) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1347297733",
        "repo_full_name": "netty/netty",
        "pr_number": 13647,
        "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java",
        "discussion_id": "1347297733",
        "commented_code": "@@ -160,6 +160,23 @@ private static boolean validateHeadersSentState(Http2Stream stream, Http2Headers\n         return isInformational;\n     }\n \n+    /**\n+     * According to RFC 9113, \"Pseudo-header fields defined for requests MUST NOT appear in responses;\n+     * pseudo-header fields defined for responses MUST NOT appear in requests.\"\n+     * @return {@code true} if validation completed successfully, {@code false} if not\n+     */\n+    private boolean validatePseudoHeaders(Http2Headers headers) {\n+        boolean isResponseHeaders = connection.isServer();\n+        for (CharSequence name : headers.names()) {",
        "comment_created_at": "2023-10-05T11:49:59+00:00",
        "comment_author": "mostroverkhov",
        "comment_body": "headers.names() copies names into new `LinkedHashSet` - for iteration It is sufficient to use Http2Headers.iterator() which does not do redundant copy (possibly guarded by `isEmpty()` check returning `Collections.emptyIterator()`) ",
        "pr_file_module": null
      },
      {
        "comment_id": "1347949367",
        "repo_full_name": "netty/netty",
        "pr_number": 13647,
        "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java",
        "discussion_id": "1347297733",
        "commented_code": "@@ -160,6 +160,23 @@ private static boolean validateHeadersSentState(Http2Stream stream, Http2Headers\n         return isInformational;\n     }\n \n+    /**\n+     * According to RFC 9113, \"Pseudo-header fields defined for requests MUST NOT appear in responses;\n+     * pseudo-header fields defined for responses MUST NOT appear in requests.\"\n+     * @return {@code true} if validation completed successfully, {@code false} if not\n+     */\n+    private boolean validatePseudoHeaders(Http2Headers headers) {\n+        boolean isResponseHeaders = connection.isServer();\n+        for (CharSequence name : headers.names()) {",
        "comment_created_at": "2023-10-05T20:45:02+00:00",
        "comment_author": "isaacrivriv",
        "comment_body": "Will make the change, thanks for the comment!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100438661",
    "pr_number": 15222,
    "pr_file": "common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java",
    "created_at": "2025-05-21T14:24:34+00:00",
    "commented_code": "/**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public boolean willCleanupFastThreadLocals() {\n         return cleanupFastThreadLocals;\n     }\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public static boolean willCleanupFastThreadLocals(Thread thread) {\n         return thread instanceof FastThreadLocalThread &&\n                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();\n     }\n \n+    /**\n+     * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     */\n+    public static boolean currentThreadWillCleanupFastThreadLocals() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        Thread currentThread = currentThread();\n+        if (currentThread instanceof FastThreadLocalThread) {\n+            return ((FastThreadLocalThread) currentThread).willCleanupFastThreadLocals();\n+        }\n+        return isFastThreadLocalVirtualThread();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this thread supports {@link FastThreadLocal}.\n+     */\n+    public static boolean currentThreadHasFastThreadLocal() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        return currentThread() instanceof FastThreadLocalThread || isFastThreadLocalVirtualThread();\n+    }\n+\n+    private static boolean isFastThreadLocalVirtualThread() {\n+        long[] arr = fallbackThreads.get();\n+        if (arr == null) {\n+            return false;\n+        }\n+        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;\n+    }\n+\n+    /**\n+     * Run the given task with {@link FastThreadLocal} support. This call should wrap the runnable for any thread that\n+     * is long-running enough to make treating it as a {@link FastThreadLocalThread} reasonable, but that can't\n+     * actually extend this class (e.g. because it's a virtual thread). Netty will use optimizations for recyclers and\n+     * allocators as if this was a {@link FastThreadLocalThread}.\n+     * <p>This method will clean up any {@link FastThreadLocal}s at the end, and\n+     * {@link #currentThreadWillCleanupFastThreadLocals()} will return {@code true}.\n+     * <p>At the moment, {@link FastThreadLocal} uses normal {@link ThreadLocal} as the backing storage here, but in\n+     * the future this may be replaced with scoped values, if semantics can be preserved and performance is good.\n+     *\n+     * @param runnable The task to run\n+     */\n+    public static void runWithFastThreadLocal(Runnable runnable) {\n+        long id = currentThread().getId();\n+        if (currentThread() instanceof FastThreadLocalThread) {\n+            throw new IllegalStateException(\"Caller is a real FastThreadLocalThread\");\n+        }\n+        fallbackThreads.updateAndGet(arr -> {\n+            if (arr == null) {\n+                return new long[] { id };\n+            }\n+            int index = Arrays.binarySearch(arr, id);\n+            if (index >= 0) {\n+                throw new IllegalStateException(\"Reentrant call to run()\");\n+            }\n+            index = ~index;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2100438661",
        "repo_full_name": "netty/netty",
        "pr_number": 15222,
        "pr_file": "common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java",
        "discussion_id": "2100438661",
        "commented_code": "@@ -96,19 +106,108 @@ public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public boolean willCleanupFastThreadLocals() {\n         return cleanupFastThreadLocals;\n     }\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public static boolean willCleanupFastThreadLocals(Thread thread) {\n         return thread instanceof FastThreadLocalThread &&\n                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();\n     }\n \n+    /**\n+     * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     */\n+    public static boolean currentThreadWillCleanupFastThreadLocals() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        Thread currentThread = currentThread();\n+        if (currentThread instanceof FastThreadLocalThread) {\n+            return ((FastThreadLocalThread) currentThread).willCleanupFastThreadLocals();\n+        }\n+        return isFastThreadLocalVirtualThread();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this thread supports {@link FastThreadLocal}.\n+     */\n+    public static boolean currentThreadHasFastThreadLocal() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        return currentThread() instanceof FastThreadLocalThread || isFastThreadLocalVirtualThread();\n+    }\n+\n+    private static boolean isFastThreadLocalVirtualThread() {\n+        long[] arr = fallbackThreads.get();\n+        if (arr == null) {\n+            return false;\n+        }\n+        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;\n+    }\n+\n+    /**\n+     * Run the given task with {@link FastThreadLocal} support. This call should wrap the runnable for any thread that\n+     * is long-running enough to make treating it as a {@link FastThreadLocalThread} reasonable, but that can't\n+     * actually extend this class (e.g. because it's a virtual thread). Netty will use optimizations for recyclers and\n+     * allocators as if this was a {@link FastThreadLocalThread}.\n+     * <p>This method will clean up any {@link FastThreadLocal}s at the end, and\n+     * {@link #currentThreadWillCleanupFastThreadLocals()} will return {@code true}.\n+     * <p>At the moment, {@link FastThreadLocal} uses normal {@link ThreadLocal} as the backing storage here, but in\n+     * the future this may be replaced with scoped values, if semantics can be preserved and performance is good.\n+     *\n+     * @param runnable The task to run\n+     */\n+    public static void runWithFastThreadLocal(Runnable runnable) {\n+        long id = currentThread().getId();\n+        if (currentThread() instanceof FastThreadLocalThread) {\n+            throw new IllegalStateException(\"Caller is a real FastThreadLocalThread\");\n+        }\n+        fallbackThreads.updateAndGet(arr -> {\n+            if (arr == null) {\n+                return new long[] { id };\n+            }\n+            int index = Arrays.binarySearch(arr, id);\n+            if (index >= 0) {\n+                throw new IllegalStateException(\"Reentrant call to run()\");\n+            }\n+            index = ~index;",
        "comment_created_at": "2025-05-21T14:24:34+00:00",
        "comment_author": "franz1981",
        "comment_body": "the javadoc states it returns \r\n```\r\n-(insertion point) - 1\r\n```\r\nso, please add a line as\r\n```\r\n// same as -(index + 1)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2100486244",
        "repo_full_name": "netty/netty",
        "pr_number": 15222,
        "pr_file": "common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java",
        "discussion_id": "2100438661",
        "commented_code": "@@ -96,19 +106,108 @@ public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public boolean willCleanupFastThreadLocals() {\n         return cleanupFastThreadLocals;\n     }\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public static boolean willCleanupFastThreadLocals(Thread thread) {\n         return thread instanceof FastThreadLocalThread &&\n                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();\n     }\n \n+    /**\n+     * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     */\n+    public static boolean currentThreadWillCleanupFastThreadLocals() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        Thread currentThread = currentThread();\n+        if (currentThread instanceof FastThreadLocalThread) {\n+            return ((FastThreadLocalThread) currentThread).willCleanupFastThreadLocals();\n+        }\n+        return isFastThreadLocalVirtualThread();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this thread supports {@link FastThreadLocal}.\n+     */\n+    public static boolean currentThreadHasFastThreadLocal() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        return currentThread() instanceof FastThreadLocalThread || isFastThreadLocalVirtualThread();\n+    }\n+\n+    private static boolean isFastThreadLocalVirtualThread() {\n+        long[] arr = fallbackThreads.get();\n+        if (arr == null) {\n+            return false;\n+        }\n+        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;\n+    }\n+\n+    /**\n+     * Run the given task with {@link FastThreadLocal} support. This call should wrap the runnable for any thread that\n+     * is long-running enough to make treating it as a {@link FastThreadLocalThread} reasonable, but that can't\n+     * actually extend this class (e.g. because it's a virtual thread). Netty will use optimizations for recyclers and\n+     * allocators as if this was a {@link FastThreadLocalThread}.\n+     * <p>This method will clean up any {@link FastThreadLocal}s at the end, and\n+     * {@link #currentThreadWillCleanupFastThreadLocals()} will return {@code true}.\n+     * <p>At the moment, {@link FastThreadLocal} uses normal {@link ThreadLocal} as the backing storage here, but in\n+     * the future this may be replaced with scoped values, if semantics can be preserved and performance is good.\n+     *\n+     * @param runnable The task to run\n+     */\n+    public static void runWithFastThreadLocal(Runnable runnable) {\n+        long id = currentThread().getId();\n+        if (currentThread() instanceof FastThreadLocalThread) {\n+            throw new IllegalStateException(\"Caller is a real FastThreadLocalThread\");\n+        }\n+        fallbackThreads.updateAndGet(arr -> {\n+            if (arr == null) {\n+                return new long[] { id };\n+            }\n+            int index = Arrays.binarySearch(arr, id);\n+            if (index >= 0) {\n+                throw new IllegalStateException(\"Reentrant call to run()\");\n+            }\n+            index = ~index;",
        "comment_created_at": "2025-05-21T14:45:20+00:00",
        "comment_author": "yawkat",
        "comment_body": "```suggestion\r\n            index = ~index; // same as -(index + 1)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2100523902",
        "repo_full_name": "netty/netty",
        "pr_number": 15222,
        "pr_file": "common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java",
        "discussion_id": "2100438661",
        "commented_code": "@@ -96,19 +106,108 @@ public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public boolean willCleanupFastThreadLocals() {\n         return cleanupFastThreadLocals;\n     }\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public static boolean willCleanupFastThreadLocals(Thread thread) {\n         return thread instanceof FastThreadLocalThread &&\n                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();\n     }\n \n+    /**\n+     * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     */\n+    public static boolean currentThreadWillCleanupFastThreadLocals() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        Thread currentThread = currentThread();\n+        if (currentThread instanceof FastThreadLocalThread) {\n+            return ((FastThreadLocalThread) currentThread).willCleanupFastThreadLocals();\n+        }\n+        return isFastThreadLocalVirtualThread();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this thread supports {@link FastThreadLocal}.\n+     */\n+    public static boolean currentThreadHasFastThreadLocal() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        return currentThread() instanceof FastThreadLocalThread || isFastThreadLocalVirtualThread();\n+    }\n+\n+    private static boolean isFastThreadLocalVirtualThread() {\n+        long[] arr = fallbackThreads.get();\n+        if (arr == null) {\n+            return false;\n+        }\n+        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;\n+    }\n+\n+    /**\n+     * Run the given task with {@link FastThreadLocal} support. This call should wrap the runnable for any thread that\n+     * is long-running enough to make treating it as a {@link FastThreadLocalThread} reasonable, but that can't\n+     * actually extend this class (e.g. because it's a virtual thread). Netty will use optimizations for recyclers and\n+     * allocators as if this was a {@link FastThreadLocalThread}.\n+     * <p>This method will clean up any {@link FastThreadLocal}s at the end, and\n+     * {@link #currentThreadWillCleanupFastThreadLocals()} will return {@code true}.\n+     * <p>At the moment, {@link FastThreadLocal} uses normal {@link ThreadLocal} as the backing storage here, but in\n+     * the future this may be replaced with scoped values, if semantics can be preserved and performance is good.\n+     *\n+     * @param runnable The task to run\n+     */\n+    public static void runWithFastThreadLocal(Runnable runnable) {\n+        long id = currentThread().getId();\n+        if (currentThread() instanceof FastThreadLocalThread) {\n+            throw new IllegalStateException(\"Caller is a real FastThreadLocalThread\");\n+        }\n+        fallbackThreads.updateAndGet(arr -> {\n+            if (arr == null) {\n+                return new long[] { id };\n+            }\n+            int index = Arrays.binarySearch(arr, id);\n+            if (index >= 0) {\n+                throw new IllegalStateException(\"Reentrant call to run()\");\n+            }\n+            index = ~index;",
        "comment_created_at": "2025-05-21T15:00:51+00:00",
        "comment_author": "yawkat",
        "comment_body": "to be honest, i always remember the `~index` shortcut, but not the `-(index + 1)` from the javadoc :D",
        "pr_file_module": null
      },
      {
        "comment_id": "2100587898",
        "repo_full_name": "netty/netty",
        "pr_number": 15222,
        "pr_file": "common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java",
        "discussion_id": "2100438661",
        "commented_code": "@@ -96,19 +106,108 @@ public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link #run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public boolean willCleanupFastThreadLocals() {\n         return cleanupFastThreadLocals;\n     }\n \n     /**\n      * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     *\n+     * @deprecated Use {@link FastThreadLocalThread#currentThreadWillCleanupFastThreadLocals()} instead\n      */\n+    @Deprecated\n     public static boolean willCleanupFastThreadLocals(Thread thread) {\n         return thread instanceof FastThreadLocalThread &&\n                 ((FastThreadLocalThread) thread).willCleanupFastThreadLocals();\n     }\n \n+    /**\n+     * Returns {@code true} if {@link FastThreadLocal#removeAll()} will be called once {@link Thread#run()} completes.\n+     */\n+    public static boolean currentThreadWillCleanupFastThreadLocals() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        Thread currentThread = currentThread();\n+        if (currentThread instanceof FastThreadLocalThread) {\n+            return ((FastThreadLocalThread) currentThread).willCleanupFastThreadLocals();\n+        }\n+        return isFastThreadLocalVirtualThread();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this thread supports {@link FastThreadLocal}.\n+     */\n+    public static boolean currentThreadHasFastThreadLocal() {\n+        // intentionally doesn't accept a thread parameter to work with ScopedValue in the future\n+        return currentThread() instanceof FastThreadLocalThread || isFastThreadLocalVirtualThread();\n+    }\n+\n+    private static boolean isFastThreadLocalVirtualThread() {\n+        long[] arr = fallbackThreads.get();\n+        if (arr == null) {\n+            return false;\n+        }\n+        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;\n+    }\n+\n+    /**\n+     * Run the given task with {@link FastThreadLocal} support. This call should wrap the runnable for any thread that\n+     * is long-running enough to make treating it as a {@link FastThreadLocalThread} reasonable, but that can't\n+     * actually extend this class (e.g. because it's a virtual thread). Netty will use optimizations for recyclers and\n+     * allocators as if this was a {@link FastThreadLocalThread}.\n+     * <p>This method will clean up any {@link FastThreadLocal}s at the end, and\n+     * {@link #currentThreadWillCleanupFastThreadLocals()} will return {@code true}.\n+     * <p>At the moment, {@link FastThreadLocal} uses normal {@link ThreadLocal} as the backing storage here, but in\n+     * the future this may be replaced with scoped values, if semantics can be preserved and performance is good.\n+     *\n+     * @param runnable The task to run\n+     */\n+    public static void runWithFastThreadLocal(Runnable runnable) {\n+        long id = currentThread().getId();\n+        if (currentThread() instanceof FastThreadLocalThread) {\n+            throw new IllegalStateException(\"Caller is a real FastThreadLocalThread\");\n+        }\n+        fallbackThreads.updateAndGet(arr -> {\n+            if (arr == null) {\n+                return new long[] { id };\n+            }\n+            int index = Arrays.binarySearch(arr, id);\n+            if (index >= 0) {\n+                throw new IllegalStateException(\"Reentrant call to run()\");\n+            }\n+            index = ~index;",
        "comment_created_at": "2025-05-21T15:28:39+00:00",
        "comment_author": "franz1981",
        "comment_body": "I know but IDK how many folks remember about two complement by heart (I know is strange)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921870704",
    "pr_number": 14690,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
    "created_at": "2025-01-20T06:46:15+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1921870704",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
        "discussion_id": "1921870704",
        "commented_code": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;",
        "comment_created_at": "2025-01-20T06:46:15+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "nit the mask will never change so just store it as a final field in the class. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1921871067",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
        "discussion_id": "1921870704",
        "commented_code": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;",
        "comment_created_at": "2025-01-20T06:46:48+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Also to ensure this all works we need to check that `entries` is a power of two in the constructor. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1922356313",
        "repo_full_name": "netty/netty",
        "pr_number": 14690,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java",
        "discussion_id": "1921870704",
        "commented_code": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.buffer.AbstractReferenceCountedByteBuf;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+\n+final class IoUringBufferRing {\n+\n+    private final long ioUringBufRingAddr;\n+\n+    private final short entries;\n+\n+    private final short bufferGroupId;\n+\n+    private final int ringFd;\n+\n+    private final ByteBuf[] userspaceBufferHolder;\n+    private final int chunkSize;\n+    private short nextIndex;\n+    private boolean hasSpareBuffer;\n+    private IoUringIoHandler source;\n+\n+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,\n+                      short entries, short bufferGroupId,\n+                      int chunkSize, IoUringIoHandler ioUringIoHandler\n+    ) {\n+        this.ioUringBufRingAddr = ioUringBufRingAddr;\n+        this.entries = entries;\n+        this.bufferGroupId = bufferGroupId;\n+        this.ringFd = ringFd;\n+        this.userspaceBufferHolder = new ByteBuf[entries];\n+        this.nextIndex = 0;\n+        this.chunkSize = chunkSize;\n+        this.hasSpareBuffer = false;\n+        this.source = ioUringIoHandler;\n+    }\n+\n+    public void markReadFail() {\n+        hasSpareBuffer = false;\n+    }\n+\n+    public boolean hasSpareBuffer() {\n+        return hasSpareBuffer;\n+    }\n+\n+    void recycleBuffer(short bid) {\n+        source.submitBeforeIO(new Runnable() {\n+            @Override\n+            public void run() {\n+                addToRing(bid, true);\n+            }\n+        });\n+    }\n+\n+    void addToRing(short bid, boolean needAdvance) {\n+        ByteBuf byteBuf = userspaceBufferHolder[bid];\n+        int mask = entries - 1;",
        "comment_created_at": "2025-01-20T12:49:38+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "> Also to ensure this all works we need to check that `entries` is a power of two in the constructor.\r\n\r\nThis will be checked when constructing the BufferRingConfig.",
        "pr_file_module": null
      }
    ]
  }
]