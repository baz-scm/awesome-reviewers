[
  {
    "discussion_id": "347284164",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
    "created_at": "2019-11-18T09:53:13+00:00",
    "commented_code": "+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "347284164",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347284164",
        "commented_code": "@@ -0,0 +1,375 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);",
        "comment_created_at": "2019-11-18T09:53:13+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "This is not really safe imho... The `evt` may have been released at this point already or modified in another way. You will need to convert it to a string before calling `ctx.fireUserEventTriggered(...)`.",
        "pr_file_module": null
      },
      {
        "comment_id": "375695995",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347284164",
        "commented_code": "@@ -0,0 +1,375 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);",
        "comment_created_at": "2020-02-06T08:29:19+00:00",
        "comment_author": "klaraward",
        "comment_body": "What about the ctx.channel(), can you expect that to stay the same?",
        "pr_file_module": null
      },
      {
        "comment_id": "375696782",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347284164",
        "commented_code": "@@ -0,0 +1,375 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        event.end();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);",
        "comment_created_at": "2020-02-06T08:31:15+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "yes... the `Channel` that can be accessed via `ChannelHandlerContext` will never change. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952852818",
    "pr_number": 14807,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringServerChannel.java",
    "created_at": "2025-02-12T15:11:47+00:00",
    "commented_code": "} else {\n                 ioPrio = 0;\n             }\n+\n+            if (IoUring.isIOUringAcceptMultishotSupported()) {\n+                // Let's use multi-shot accept to reduce overhead.\n+                ioPrio |= Native.IORING_ACCEPT_MULTISHOT;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1952852818",
        "repo_full_name": "netty/netty",
        "pr_number": 14807,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringServerChannel.java",
        "discussion_id": "1952852818",
        "commented_code": "@@ -143,20 +144,38 @@ protected int scheduleRead0(boolean first, boolean socketIsEmpty) {\n             } else {\n                 ioPrio = 0;\n             }\n+\n+            if (IoUring.isIOUringAcceptMultishotSupported()) {\n+                // Let's use multi-shot accept to reduce overhead.\n+                ioPrio |= Native.IORING_ACCEPT_MULTISHOT;",
        "comment_created_at": "2025-02-12T15:11:47+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "\"Note that for the multishot variants, setting addr and addrlen may not make a lot of sense, as the same value would be used for every accepted connection. This means that the data written to addr may be overwritten by a new connection before the application has had time to process a past connection\"\r\n\r\nhttps://man7.org/linux/man-pages/man3/io_uring_prep_multishot_accept_direct.3.html\r\n\r\nso we should call `getpeername` in readComplete0 to get real peer address",
        "pr_file_module": null
      },
      {
        "comment_id": "1952860349",
        "repo_full_name": "netty/netty",
        "pr_number": 14807,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringServerChannel.java",
        "discussion_id": "1952852818",
        "commented_code": "@@ -143,20 +144,38 @@ protected int scheduleRead0(boolean first, boolean socketIsEmpty) {\n             } else {\n                 ioPrio = 0;\n             }\n+\n+            if (IoUring.isIOUringAcceptMultishotSupported()) {\n+                // Let's use multi-shot accept to reduce overhead.\n+                ioPrio |= Native.IORING_ACCEPT_MULTISHOT;",
        "comment_created_at": "2025-02-12T15:15:57+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Good point!",
        "pr_file_module": null
      },
      {
        "comment_id": "1952885204",
        "repo_full_name": "netty/netty",
        "pr_number": 14807,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringServerChannel.java",
        "discussion_id": "1952852818",
        "commented_code": "@@ -143,20 +144,38 @@ protected int scheduleRead0(boolean first, boolean socketIsEmpty) {\n             } else {\n                 ioPrio = 0;\n             }\n+\n+            if (IoUring.isIOUringAcceptMultishotSupported()) {\n+                // Let's use multi-shot accept to reduce overhead.\n+                ioPrio |= Native.IORING_ACCEPT_MULTISHOT;",
        "comment_created_at": "2025-02-12T15:29:00+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Fixed @dreamlike-ocean PTAL again",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945171710",
    "pr_number": 14786,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingGroupIdHandler.java",
    "created_at": "2025-02-06T17:46:10+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+/**\n+ * Handles the selection of buffer rings for recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * an this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public interface IoUringBufferRingGroupIdHandler {\n+\n+    /**\n+     * Return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+     * The buffer ring must have been configured via\n+     * {@link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}.\n+     *\n+     * @param guessedSize       the estimated size of the next read.\n+     * @return                  the group to use if non-negative. If negative no group will be used at all.\n+     */\n+    short select(int guessedSize);\n+\n+    /**\n+     * Called when a buffer ring was exhausted.\n+     *\n+     * @param id    the id of the buffer ring.\n+     */\n+    default void exhausted(short id) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1945171710",
        "repo_full_name": "netty/netty",
        "pr_number": 14786,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingGroupIdHandler.java",
        "discussion_id": "1945171710",
        "commented_code": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+/**\n+ * Handles the selection of buffer rings for recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * an this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public interface IoUringBufferRingGroupIdHandler {\n+\n+    /**\n+     * Return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+     * The buffer ring must have been configured via\n+     * {@link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}.\n+     *\n+     * @param guessedSize       the estimated size of the next read.\n+     * @return                  the group to use if non-negative. If negative no group will be used at all.\n+     */\n+    short select(int guessedSize);\n+\n+    /**\n+     * Called when a buffer ring was exhausted.\n+     *\n+     * @param id    the id of the buffer ring.\n+     */\n+    default void exhausted(short id) {",
        "comment_created_at": "2025-02-06T17:46:10+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "Since a buffer ring instance is bound to an io_uring instance, would it be better to add an iohandler parameter to identify which buffer ring of which io_uring instance is exhausted?",
        "pr_file_module": null
      },
      {
        "comment_id": "1945177371",
        "repo_full_name": "netty/netty",
        "pr_number": 14786,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingGroupIdHandler.java",
        "discussion_id": "1945171710",
        "commented_code": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+/**\n+ * Handles the selection of buffer rings for recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * an this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public interface IoUringBufferRingGroupIdHandler {\n+\n+    /**\n+     * Return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+     * The buffer ring must have been configured via\n+     * {@link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}.\n+     *\n+     * @param guessedSize       the estimated size of the next read.\n+     * @return                  the group to use if non-negative. If negative no group will be used at all.\n+     */\n+    short select(int guessedSize);\n+\n+    /**\n+     * Called when a buffer ring was exhausted.\n+     *\n+     * @param id    the id of the buffer ring.\n+     */\n+    default void exhausted(short id) {",
        "comment_created_at": "2025-02-06T17:50:43+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I basically put it here as based on this the select implementation might stop to hand out the id. That said I am currently trying to come up with a way to also get notified once there is space again as this might also effect the implementation ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1942150935",
    "pr_number": 14777,
    "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
    "created_at": "2025-02-05T02:09:05+00:00",
    "commented_code": "+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1942150935",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-05T02:09:05+00:00",
        "comment_author": "chrisvest",
        "comment_body": "Should the chooser not somehow be informed when io_uring consumes data from a buffer ring group, so it can keep track?\n\nHow are buffer rings replenished? The `IoUringIoHandlerConfig` is only processed when the IoUringHander is created, as far as I can see.",
        "pr_file_module": null
      },
      {
        "comment_id": "1942162065",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-05T02:27:17+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "When the buffer ring is exhausted, we only need to fill the io_uring_buf elements of the io_uring_buf_ring and then advance the tail to dynamically supplement the buffers. \r\n\r\nHowever, we need to consider how to handle the buffers that exceed the ring size\uff0cand the association between these buffer IDs and buffers. Perhaps using a short(buffer id) -> ByteBuf  map  can solve this problem?\r\n\r\n I think if we want to implement this feature, we can call back the chooser when the buffering is exhausted, and the chooser will return whether buffer supplementation is required.",
        "pr_file_module": null
      },
      {
        "comment_id": "1943208699",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-05T15:45:00+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I think we only need to know when the ring is exhausted and also when the ring has something spare again. After thinking a bit more about this a user might want to stop reading when the ring has nothing left and so disable auto-read and then start again once there is something to use. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1943223238",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-05T15:53:09+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "> When the buffer ring is exhausted, we only need to fill the io_uring_buf elements of the io_uring_buf_ring and then advance the tail to dynamically supplement the buffers.\r\n> \r\n> However, we need to consider how to handle the buffers that exceed the ring size\uff0cand the association between these buffer IDs and buffers. Perhaps using a short(buffer id) -> ByteBuf map can solve this problem?\r\n\r\nHmm not sure I get what you suggest here... Can you explain a bit more why there needs to be some special mapping ?\r\n> \r\n> I think if we want to implement this feature, we can call back the chooser when the buffering is exhausted, and the chooser will return whether buffer supplementation is required.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1943376197",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-05T17:28:40+00:00",
        "comment_author": "dreamlike-ocean",
        "comment_body": "I haven\u2019t fully figured out how to support dynamically adding extra buffers yet.\r\n For now, I believe the current implementation is sufficient\uff0cIoUringBufferGroupIdHandler::exhausted is enough for me",
        "pr_file_module": null
      },
      {
        "comment_id": "1944749612",
        "repo_full_name": "netty/netty",
        "pr_number": 14777,
        "pr_file": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingRecvByteBufAllocator.java",
        "discussion_id": "1942150935",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2025 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.channel.AdaptiveRecvByteBufAllocator;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.util.UncheckedBooleanSupplier;\n+\n+import java.util.Objects;\n+\n+/**\n+ * {@link RecvByteBufAllocator} that should be used if we want to use provided buffers.\n+ * It will return the buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.\n+ * <p>\n+ * Check\n+ * <a href=\"https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html\"> man io_uring_setup_buf_ring</a>\n+ * and this <a href=\"https://lwn.net/Articles/815491/\">LWN article</a> for more details.\n+ */\n+public final class IoUringBufferRingRecvByteBufAllocator implements RecvByteBufAllocator {\n+    private final RecvByteBufAllocator allocator;\n+    private final IoUringBufferGroupIdChooser idChooser;\n+\n+    /**\n+     * Interface that will return the buffer group id.\n+     */\n+    public interface IoUringBufferGroupIdChooser {\n+        /**\n+         * Return the group id that should be used for the given size. This method must return a valid group id\n+         * that was configured previously via {\n+         * @link IoUringIoHandlerConfig#addBufferRingConfig(IoUringBufferRingConfig)}\n+         *\n+         * @param sizeGuess the guess of bytes that we think we might be able to read.\n+         * @return          the group id.\n+         */\n+        short choose(int sizeGuess);",
        "comment_created_at": "2025-02-06T13:43:11+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "I wonder if we also need to notify somehow once the ring has something to use again @dreamlike-ocean \r\n",
        "pr_file_module": null
      }
    ]
  }
]