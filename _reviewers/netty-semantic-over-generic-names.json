[
  {
    "discussion_id": "1124907944",
    "pr_number": 13244,
    "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java",
    "created_at": "2023-03-03T19:10:45+00:00",
    "commented_code": "// We need to set this to false before we call flush0(...) as ChannelFutureListener may produce more data\n             // that are explicit flushed.\n             writeDoneAndNoFlush = false;\n+            windowUpdateFrameWritten = false;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1124907944",
        "repo_full_name": "netty/netty",
        "pr_number": 13244,
        "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java",
        "discussion_id": "1124907944",
        "commented_code": "@@ -1037,6 +1044,7 @@ public void flush() {\n             // We need to set this to false before we call flush0(...) as ChannelFutureListener may produce more data\n             // that are explicit flushed.\n             writeDoneAndNoFlush = false;\n+            windowUpdateFrameWritten = false;",
        "comment_created_at": "2023-03-03T19:10:45+00:00",
        "comment_author": "bryce-anderson",
        "comment_body": "There are strong parallels with the `writeDoneAndNoFlush` field. It would be good to align the names and make clear the distinction, which is only that `writeDoneAndNoFlush` includes *all* frame types (including window updates) whereas `windowUpdateFrameWritten` is only for window update frames.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2122169316",
    "pr_number": 15298,
    "pr_file": "transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java",
    "created_at": "2025-06-02T21:13:48+00:00",
    "commented_code": "pool.close();\n     }\n \n+    @Test\n+    public void testChannelReleaseHealthCheck() {\n+        Tuple t = bootstrap();\n+\n+        // Start server\n+        Channel sc = t.sb.bind(t.address).syncUninterruptibly().channel();\n+        ChannelPoolHandler handler = new TestChannelPoolHandler();\n+        InnerFixedChannelPool pool = new InnerFixedChannelPool(t.cb, handler, ChannelHealthChecker.ACTIVE,\n+                AcquireTimeoutAction.NEW, 500, 1, Integer.MAX_VALUE, true);\n+\n+        // releaseHealthCheck=true,channel=open,doHealthCheckOnRelease\n+        Channel channel = pool.acquire().syncUninterruptibly().getNow();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        Channel sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertSame(sameChannel, channel);\n+\n+        // releaseHealthCheck=true,channel=close,doHealthCheckOnRelease\n+        sameChannel.close().syncUninterruptibly();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertNotSame(sameChannel, channel);\n+\n+        // close all and create a new poll\n+        sameChannel.close().syncUninterruptibly();\n+        channel.close().syncUninterruptibly();\n+        pool.close();\n+        pool = new InnerFixedChannelPool(t.cb, handler, ChannelHealthChecker.ACTIVE,\n+                AcquireTimeoutAction.NEW, 500, 1, Integer.MAX_VALUE, false);\n+\n+        // releaseHealthCheck=false,channel=open,releaseAndOffer\n+        channel = pool.acquire().syncUninterruptibly().getNow();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertSame(sameChannel, channel);\n+\n+        // releaseHealthCheck=false,channel=close,releaseAndOffer\n+        sameChannel.close().syncUninterruptibly();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        // the acquire will do a heath check.. this is why we call the special method\n+        sameChannel = pool.pollChannel();\n+        assertSame(sameChannel, channel);\n+\n+        sc.close().syncUninterruptibly();\n+        sameChannel.close().syncUninterruptibly();\n+        channel.close().syncUninterruptibly();\n+        pool.close();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testChannelProcessingOrder(boolean orderingType) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2122169316",
        "repo_full_name": "netty/netty",
        "pr_number": 15298,
        "pr_file": "transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java",
        "discussion_id": "2122169316",
        "commented_code": "@@ -314,6 +318,96 @@ public void channelCreated(Channel ch) {\n         pool.close();\n     }\n \n+    @Test\n+    public void testChannelReleaseHealthCheck() {\n+        Tuple t = bootstrap();\n+\n+        // Start server\n+        Channel sc = t.sb.bind(t.address).syncUninterruptibly().channel();\n+        ChannelPoolHandler handler = new TestChannelPoolHandler();\n+        InnerFixedChannelPool pool = new InnerFixedChannelPool(t.cb, handler, ChannelHealthChecker.ACTIVE,\n+                AcquireTimeoutAction.NEW, 500, 1, Integer.MAX_VALUE, true);\n+\n+        // releaseHealthCheck=true,channel=open,doHealthCheckOnRelease\n+        Channel channel = pool.acquire().syncUninterruptibly().getNow();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        Channel sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertSame(sameChannel, channel);\n+\n+        // releaseHealthCheck=true,channel=close,doHealthCheckOnRelease\n+        sameChannel.close().syncUninterruptibly();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertNotSame(sameChannel, channel);\n+\n+        // close all and create a new poll\n+        sameChannel.close().syncUninterruptibly();\n+        channel.close().syncUninterruptibly();\n+        pool.close();\n+        pool = new InnerFixedChannelPool(t.cb, handler, ChannelHealthChecker.ACTIVE,\n+                AcquireTimeoutAction.NEW, 500, 1, Integer.MAX_VALUE, false);\n+\n+        // releaseHealthCheck=false,channel=open,releaseAndOffer\n+        channel = pool.acquire().syncUninterruptibly().getNow();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        sameChannel = pool.acquire().syncUninterruptibly().getNow();\n+        assertSame(sameChannel, channel);\n+\n+        // releaseHealthCheck=false,channel=close,releaseAndOffer\n+        sameChannel.close().syncUninterruptibly();\n+        pool.release(channel).syncUninterruptibly().getNow();\n+        // the acquire will do a heath check.. this is why we call the special method\n+        sameChannel = pool.pollChannel();\n+        assertSame(sameChannel, channel);\n+\n+        sc.close().syncUninterruptibly();\n+        sameChannel.close().syncUninterruptibly();\n+        channel.close().syncUninterruptibly();\n+        pool.close();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testChannelProcessingOrder(boolean orderingType) {",
        "comment_created_at": "2025-06-02T21:13:48+00:00",
        "comment_author": "chrisvest",
        "comment_body": "We could call this \"lastInFirstOutOrdering\" instead, as \"orderingType\" is too vague IMO",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347088996",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
    "created_at": "2019-11-16T12:10:40+00:00",
    "commented_code": "+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();\n+//        event.begin();\n+//        ctx.fireChannelReadComplete();\n+//        if (event.shouldCommit()) {\n+//            event.setChannel(ctx.channel());\n+//            event.commit();\n+//        }\n+//    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        ChannelReadEvent event = new ChannelReadEvent();\n+        event.begin();\n+        ctx.fireChannelRead(msg);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.msg = String.valueOf(msg);\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void read(ChannelHandlerContext ctx) throws Exception {\n+//        ReadEvent event = new ReadEvent();\n+//        event.begin();\n+//        ctx.read();\n+//        if (event.shouldCommit()) {\n+//            event.setChannel(ctx.channel());\n+//            event.commit();\n+//        }\n+//    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        WriteEvent event = new WriteEvent();\n+        event.begin();\n+        ctx.write(msg, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.msg = String.valueOf(msg);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        ChannelWritabilityChangedEvent event = new ChannelWritabilityChangedEvent();\n+        event.begin();\n+        ctx.fireChannelWritabilityChanged();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.isWritable = ctx.channel().isWritable();\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void flush(ChannelHandlerContext ctx) throws Exception {\n+        FlushEvent event = new FlushEvent();\n+        event.begin();\n+        ctx.flush();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    // Event types\n+\n+    @Category({ \"Netty\", \"ChannelHandler\" })\n+    private abstract static class ChannelEvent extends Event {\n+        @Label(\"Channel\")\n+        String channel;\n+        @Label(\"Channel ID\")\n+        String channelId;\n+\n+        void setChannel(Channel channel) {\n+            this.channel = String.valueOf(channel);\n+            //TODO: More specific channel fields?\n+            this.channelId = channel.id().asLongText();\n+        }\n+    }\n+\n+    @Label(\"Bind\")\n+    @Name(\"io.netty.channelhandler.bind\")",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "347088996",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/handler/jfr/JfrEventHandler.java",
        "discussion_id": "347088996",
        "commented_code": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.jfr;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import jdk.jfr.Category;\n+import jdk.jfr.Enabled;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import java.net.SocketAddress;\n+\n+/**\n+ * A {@link ChannelHandler} that creates JFR events for all Netty events/operations using the JDK Flight Recorder using\n+ * the jdk.jfr APIs directly.\n+ * <p>\n+ * Added for benchmark comparisons.\n+ */\n+@Sharable\n+@SuppressWarnings({ \"StringConcatenationInsideStringBufferAppend\", \"StringBufferReplaceableByString\" })\n+public class JfrEventHandler extends ChannelDuplexHandler {\n+    // TODO: Check enablement, can we ever be sure not to enable this?\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelRegisteredEvent event = new ChannelRegisteredEvent();\n+        event.begin();\n+        ctx.fireChannelRegistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        ChannelUnregisteredEvent event = new ChannelUnregisteredEvent();\n+        event.begin();\n+        ctx.fireChannelUnregistered();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelActiveEvent event = new ChannelActiveEvent();\n+        event.begin();\n+        ctx.fireChannelActive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        ChannelInactiveEvent event = new ChannelInactiveEvent();\n+        event.begin();\n+        ctx.fireChannelInactive();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        ExceptionCaughtEvent event = new ExceptionCaughtEvent();\n+        event.begin();\n+        ctx.fireExceptionCaught(cause);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        UserEventTriggeredEvent event = new UserEventTriggeredEvent();\n+        event.begin();\n+        ctx.fireUserEventTriggered(evt);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.userEvent = String.valueOf(evt);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        BindEvent event = new BindEvent();\n+        event.begin();\n+        ctx.bind(localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void connect(\n+            ChannelHandlerContext ctx,\n+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {\n+        ConnectEvent event = new ConnectEvent();\n+        event.begin();\n+        ctx.connect(remoteAddress, localAddress, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.remoteAddress = String.valueOf(remoteAddress);\n+            event.localAddress = String.valueOf(localAddress);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DisconnectEvent event = new DisconnectEvent();\n+        event.begin();\n+        ctx.disconnect(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        CloseEvent event = new CloseEvent();\n+        event.begin();\n+        ctx.close(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        DeregisterEvent event = new DeregisterEvent();\n+        event.begin();\n+        ctx.deregister(promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+//        ChannelReadCompleteEvent event = new ChannelReadCompleteEvent();\n+//        event.begin();\n+//        ctx.fireChannelReadComplete();\n+//        if (event.shouldCommit()) {\n+//            event.setChannel(ctx.channel());\n+//            event.commit();\n+//        }\n+//    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        ChannelReadEvent event = new ChannelReadEvent();\n+        event.begin();\n+        ctx.fireChannelRead(msg);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.msg = String.valueOf(msg);\n+            event.commit();\n+        }\n+    }\n+\n+// NOTE: Occurs so often, currently remove for perfomance reasons\n+//    @Override\n+//    public void read(ChannelHandlerContext ctx) throws Exception {\n+//        ReadEvent event = new ReadEvent();\n+//        event.begin();\n+//        ctx.read();\n+//        if (event.shouldCommit()) {\n+//            event.setChannel(ctx.channel());\n+//            event.commit();\n+//        }\n+//    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        WriteEvent event = new WriteEvent();\n+        event.begin();\n+        ctx.write(msg, promise);\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.msg = String.valueOf(msg);\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        ChannelWritabilityChangedEvent event = new ChannelWritabilityChangedEvent();\n+        event.begin();\n+        ctx.fireChannelWritabilityChanged();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.isWritable = ctx.channel().isWritable();\n+            event.commit();\n+        }\n+    }\n+\n+    @Override\n+    public void flush(ChannelHandlerContext ctx) throws Exception {\n+        FlushEvent event = new FlushEvent();\n+        event.begin();\n+        ctx.flush();\n+        if (event.shouldCommit()) {\n+            event.setChannel(ctx.channel());\n+            event.commit();\n+        }\n+    }\n+\n+    // Event types\n+\n+    @Category({ \"Netty\", \"ChannelHandler\" })\n+    private abstract static class ChannelEvent extends Event {\n+        @Label(\"Channel\")\n+        String channel;\n+        @Label(\"Channel ID\")\n+        String channelId;\n+\n+        void setChannel(Channel channel) {\n+            this.channel = String.valueOf(channel);\n+            //TODO: More specific channel fields?\n+            this.channelId = channel.id().asLongText();\n+        }\n+    }\n+\n+    @Label(\"Bind\")\n+    @Name(\"io.netty.channelhandler.bind\")",
        "comment_created_at": "2019-11-16T12:10:40+00:00",
        "comment_author": "egahlin",
        "comment_body": "@Name should use Java naming convention for the \"class\", i.e io.netty.channenhandler.Bind.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "381561792",
    "pr_number": 9777,
    "pr_file": "jfr/src/main/java/io/netty/jfr/JfrInstrumentedByteBufAllocator.java",
    "created_at": "2020-02-19T21:42:52+00:00",
    "commented_code": "+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.util.internal.ObjectUtil;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import static io.netty.jfr.JfrInstrumentedByteBufAllocator.AllocationType.*;\n+\n+\n+/**\n+ * A {@link ByteBufAllocator} that creates JDK Flight Recorder events for all byte buffer allocations.\n+ */\n+public final class JfrInstrumentedByteBufAllocator implements ByteBufAllocator {\n+\n+    private final ByteBufAllocator wrapped;\n+\n+    private JfrInstrumentedByteBufAllocator(ByteBufAllocator wrapped) {\n+        this.wrapped = ObjectUtil.checkNotNull(wrapped, \"wrapped\");;\n+    }\n+\n+    public static ByteBufAllocator wrap(ByteBufAllocator wrapped) {\n+        return new JfrInstrumentedByteBufAllocator(wrapped);\n+    }\n+\n+    @Override\n+    public ByteBuf buffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.commit();\n+        return wrapped.buffer();\n+    }\n+\n+    @Override\n+    public ByteBuf buffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.buffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf buffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.buffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.commit();\n+        return wrapped.ioBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.commit();\n+\n+        return wrapped.ioBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+\n+        return wrapped.ioBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.commit();\n+        return wrapped.heapBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.heapBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.heapBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.commit();\n+        return wrapped.directBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.directBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.directBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE);\n+        event.commit();\n+        return wrapped.compositeBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeHeapBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_HEAP);\n+        event.commit();\n+        return wrapped.compositeHeapBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_HEAP);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeHeapBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeDirectBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_DIRECT);\n+        event.commit();\n+        return wrapped.compositeDirectBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_DIRECT);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeDirectBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public boolean isDirectBufferPooled() {\n+        return wrapped.isDirectBufferPooled();\n+    }\n+\n+    @Override\n+    public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {\n+        return wrapped.calculateNewCapacity(minNewCapacity, maxCapacity);\n+    }\n+\n+    @Category({ \"Netty\", \"Buffer\" })\n+    @Label(\"Byte Buffer Allocation\")\n+    @Name(\"io.netty.buffer.ByteBufferAllocation\")\n+    @Description(\"Byte buffer allocation, can be of multiple types, fields filled in differently for different types.\")\n+    private static final class ByteBufAllocationEvent extends Event {\n+        @Label(\"Allocation Type\")\n+        private AllocationType allocationType;\n+        @Label(\"Initial Capacity\")\n+        private int initialCapacity;\n+        @Label(\"Initial Capacity\")\n+        private int maxCapacity;\n+        @Label(\"Max Number of Components\")\n+        private int maxNumComponents;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "381561792",
        "repo_full_name": "netty/netty",
        "pr_number": 9777,
        "pr_file": "jfr/src/main/java/io/netty/jfr/JfrInstrumentedByteBufAllocator.java",
        "discussion_id": "381561792",
        "commented_code": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.jfr;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.util.internal.ObjectUtil;\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+import static io.netty.jfr.JfrInstrumentedByteBufAllocator.AllocationType.*;\n+\n+\n+/**\n+ * A {@link ByteBufAllocator} that creates JDK Flight Recorder events for all byte buffer allocations.\n+ */\n+public final class JfrInstrumentedByteBufAllocator implements ByteBufAllocator {\n+\n+    private final ByteBufAllocator wrapped;\n+\n+    private JfrInstrumentedByteBufAllocator(ByteBufAllocator wrapped) {\n+        this.wrapped = ObjectUtil.checkNotNull(wrapped, \"wrapped\");;\n+    }\n+\n+    public static ByteBufAllocator wrap(ByteBufAllocator wrapped) {\n+        return new JfrInstrumentedByteBufAllocator(wrapped);\n+    }\n+\n+    @Override\n+    public ByteBuf buffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.commit();\n+        return wrapped.buffer();\n+    }\n+\n+    @Override\n+    public ByteBuf buffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.buffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf buffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DEFAULT_TYPE);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.buffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.commit();\n+        return wrapped.ioBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.commit();\n+\n+        return wrapped.ioBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(IO);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+\n+        return wrapped.ioBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.commit();\n+        return wrapped.heapBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.heapBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf heapBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(HEAP);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.heapBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.commit();\n+        return wrapped.directBuffer();\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer(int initialCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.setInitialCapacity(initialCapacity);\n+        event.commit();\n+        return wrapped.directBuffer(initialCapacity);\n+    }\n+\n+    @Override\n+    public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(DIRECT);\n+        event.setInitialCapacity(initialCapacity);\n+        event.setMaxCapacity(maxCapacity);\n+        event.commit();\n+        return wrapped.directBuffer(initialCapacity, maxCapacity);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE);\n+        event.commit();\n+        return wrapped.compositeBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeHeapBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_HEAP);\n+        event.commit();\n+        return wrapped.compositeHeapBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_HEAP);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeHeapBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeDirectBuffer() {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_DIRECT);\n+        event.commit();\n+        return wrapped.compositeDirectBuffer();\n+    }\n+\n+    @Override\n+    public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {\n+        ByteBufAllocationEvent event = new ByteBufAllocationEvent();\n+        event.setAllocationType(COMPOSITE_DIRECT);\n+        event.setMaxNumComponents(maxNumComponents);\n+        event.commit();\n+        return wrapped.compositeDirectBuffer(maxNumComponents);\n+    }\n+\n+    @Override\n+    public boolean isDirectBufferPooled() {\n+        return wrapped.isDirectBufferPooled();\n+    }\n+\n+    @Override\n+    public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {\n+        return wrapped.calculateNewCapacity(minNewCapacity, maxCapacity);\n+    }\n+\n+    @Category({ \"Netty\", \"Buffer\" })\n+    @Label(\"Byte Buffer Allocation\")\n+    @Name(\"io.netty.buffer.ByteBufferAllocation\")\n+    @Description(\"Byte buffer allocation, can be of multiple types, fields filled in differently for different types.\")\n+    private static final class ByteBufAllocationEvent extends Event {\n+        @Label(\"Allocation Type\")\n+        private AllocationType allocationType;\n+        @Label(\"Initial Capacity\")\n+        private int initialCapacity;\n+        @Label(\"Initial Capacity\")\n+        private int maxCapacity;\n+        @Label(\"Max Number of Components\")\n+        private int maxNumComponents;",
        "comment_created_at": "2020-02-19T21:42:52+00:00",
        "comment_author": "egahlin",
        "comment_body": "Avoid abbreviations like \"Num\". How about \"maxComponentCount\" instead?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1463223468",
    "pr_number": 13459,
    "pr_file": "common/src/main/java/io/netty/util/ResourceLeakDetector.java",
    "created_at": "2024-01-23T12:38:34+00:00",
    "commented_code": "}\n \n     private static Level level;\n+    private static final Level stableLevel;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1463223468",
        "repo_full_name": "netty/netty",
        "pr_number": 13459,
        "pr_file": "common/src/main/java/io/netty/util/ResourceLeakDetector.java",
        "discussion_id": "1463223468",
        "commented_code": "@@ -97,10 +97,12 @@ static Level parseLevel(String levelStr) {\n     }\n \n     private static Level level;\n+    private static final Level stableLevel;",
        "comment_created_at": "2024-01-23T12:38:34+00:00",
        "comment_author": "zakkak",
        "comment_body": "Maybe call it `immutableLevel`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "392160822",
    "pr_number": 9935,
    "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
    "created_at": "2020-03-13T11:00:33+00:00",
    "commented_code": "import io.netty.util.internal.RecyclableArrayList;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n+import javafx.util.Pair;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "392160822",
        "repo_full_name": "netty/netty",
        "pr_number": 9935,
        "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
        "discussion_id": "392160822",
        "commented_code": "@@ -43,6 +38,12 @@\n import io.netty.util.internal.RecyclableArrayList;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n+import javafx.util.Pair;",
        "comment_created_at": "2020-03-13T11:00:33+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "please not use `Pair`... Just use `AbstractMap.SimpleEntry` or create your own class to hold this pair. ",
        "pr_file_module": null
      },
      {
        "comment_id": "392205648",
        "repo_full_name": "netty/netty",
        "pr_number": 9935,
        "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
        "discussion_id": "392160822",
        "commented_code": "@@ -43,6 +38,12 @@\n import io.netty.util.internal.RecyclableArrayList;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n+import javafx.util.Pair;",
        "comment_created_at": "2020-03-13T12:46:38+00:00",
        "comment_author": "carryxyh",
        "comment_body": "Fixed.\r\nUse `AbstractMap.SimpleEntry` to avoid introducing more code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2105528178",
    "pr_number": 15261,
    "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java",
    "created_at": "2025-05-23T23:45:20+00:00",
    "commented_code": "private static int validateCharSequenceToken(CharSequence token) {\n         for (int i = 0, len = token.length(); i < len; i++) {\n             byte value = (byte) token.charAt(i);\n-            if (!BitSet128.contains(value, TOKEN_CHARS_HIGH, TOKEN_CHARS_LOW)) {\n+            if (!contains(value)) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n \n-    private static final long TOKEN_CHARS_HIGH;\n-    private static final long TOKEN_CHARS_LOW;\n-    static {\n-        // HEADER\n-        // header-field   = field-name \":\" OWS field-value OWS\n-        //\n-        // field-name     = token\n-        // token          = 1*tchar\n-        //\n-        // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n-        //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n-        //                    / DIGIT / ALPHA\n-        //                    ; any VCHAR, except delimiters.\n-        //  Delimiters are chosen\n-        //   from the set of US-ASCII visual characters not allowed in a token\n-        //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n-        //\n-        // COOKIE\n-        // cookie-pair       = cookie-name \"=\" cookie-value\n-        // cookie-name       = token\n-        // token          = 1*<any CHAR except CTLs or separators>\n-        // CTL = <any US-ASCII control character\n-        //       (octets 0 - 31) and DEL (127)>\n-        // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n-        //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n-        //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n-        //                      | \"{\" | \"}\" | SP | HT\n-        //\n-        // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n-        BitSet128 tokenChars = new BitSet128()\n-                .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n-                .bits('-', '.', '_', '~') // Unreserved characters.\n-                .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n-        TOKEN_CHARS_HIGH = tokenChars.high();\n-        TOKEN_CHARS_LOW = tokenChars.low();\n-    }\n-\n-    private static final class BitSet128 {\n-        private long high;\n-        private long low;\n-\n-        BitSet128 range(char fromInc, char toInc) {\n-            for (int bit = fromInc; bit <= toInc; bit++) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n-        }\n-\n-        BitSet128 bits(char... bits) {\n-            for (char bit : bits) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n+    // HEADER\n+    // header-field   = field-name \":\" OWS field-value OWS\n+    //\n+    // field-name     = token\n+    // token          = 1*tchar\n+    //\n+    // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n+    //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n+    //                    / DIGIT / ALPHA\n+    //                    ; any VCHAR, except delimiters.\n+    //  Delimiters are chosen\n+    //   from the set of US-ASCII visual characters not allowed in a token\n+    //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n+    //\n+    // COOKIE\n+    // cookie-pair       = cookie-name \"=\" cookie-value\n+    // cookie-name       = token\n+    // token          = 1*<any CHAR except CTLs or separators>\n+    // CTL = <any US-ASCII control character\n+    //       (octets 0 - 31) and DEL (127)>\n+    // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n+    //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n+    //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n+    //                      | \"{\" | \"}\" | SP | HT\n+    //\n+    // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n+\n+    //    private static final class BitSet128 {\n+    //        private long high;\n+    //        private long low;\n+    //\n+    //        BitSet128 range(char fromInc, char toInc) {\n+    //            for (int bit = fromInc; bit <= toInc; bit++) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        BitSet128 bits(char... bits) {\n+    //            for (char bit : bits) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        long high() {\n+    //            return high;\n+    //        }\n+    //\n+    //        long low() {\n+    //            return low;\n+    //        }\n+    //\n+    //        static boolean contains(byte bit, long high, long low) {\n+    //            if (bit < 0) {\n+    //                return false;\n+    //            }\n+    //            if (bit < 64) {\n+    //                return 0 != (low & 1L << bit);\n+    //            }\n+    //            return 0 != (high & 1L << bit - 64);\n+    //        }\n+    //    }\n+\n+    // BitSet128 tokenChars = new BitSet128()\n+    //        .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n+    //        .bits('-', '.', '_', '~') // Unreserved characters.\n+    //        .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n+\n+    //this constants calculated by the above code\n+    private static final long TOKEN_CHARS_HIGH = 0x57ffffffc7fffffeL;\n+    private static final long TOKEN_CHARS_LOW = 0x3ff6cfa00000000L;\n+\n+    private static boolean contains(byte bit) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2105528178",
        "repo_full_name": "netty/netty",
        "pr_number": 15261,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java",
        "discussion_id": "2105528178",
        "commented_code": "@@ -675,92 +675,102 @@ private static int validateAsciiStringToken(AsciiString token) {\n     private static int validateCharSequenceToken(CharSequence token) {\n         for (int i = 0, len = token.length(); i < len; i++) {\n             byte value = (byte) token.charAt(i);\n-            if (!BitSet128.contains(value, TOKEN_CHARS_HIGH, TOKEN_CHARS_LOW)) {\n+            if (!contains(value)) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n \n-    private static final long TOKEN_CHARS_HIGH;\n-    private static final long TOKEN_CHARS_LOW;\n-    static {\n-        // HEADER\n-        // header-field   = field-name \":\" OWS field-value OWS\n-        //\n-        // field-name     = token\n-        // token          = 1*tchar\n-        //\n-        // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n-        //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n-        //                    / DIGIT / ALPHA\n-        //                    ; any VCHAR, except delimiters.\n-        //  Delimiters are chosen\n-        //   from the set of US-ASCII visual characters not allowed in a token\n-        //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n-        //\n-        // COOKIE\n-        // cookie-pair       = cookie-name \"=\" cookie-value\n-        // cookie-name       = token\n-        // token          = 1*<any CHAR except CTLs or separators>\n-        // CTL = <any US-ASCII control character\n-        //       (octets 0 - 31) and DEL (127)>\n-        // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n-        //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n-        //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n-        //                      | \"{\" | \"}\" | SP | HT\n-        //\n-        // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n-        BitSet128 tokenChars = new BitSet128()\n-                .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n-                .bits('-', '.', '_', '~') // Unreserved characters.\n-                .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n-        TOKEN_CHARS_HIGH = tokenChars.high();\n-        TOKEN_CHARS_LOW = tokenChars.low();\n-    }\n-\n-    private static final class BitSet128 {\n-        private long high;\n-        private long low;\n-\n-        BitSet128 range(char fromInc, char toInc) {\n-            for (int bit = fromInc; bit <= toInc; bit++) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n-        }\n-\n-        BitSet128 bits(char... bits) {\n-            for (char bit : bits) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n+    // HEADER\n+    // header-field   = field-name \":\" OWS field-value OWS\n+    //\n+    // field-name     = token\n+    // token          = 1*tchar\n+    //\n+    // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n+    //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n+    //                    / DIGIT / ALPHA\n+    //                    ; any VCHAR, except delimiters.\n+    //  Delimiters are chosen\n+    //   from the set of US-ASCII visual characters not allowed in a token\n+    //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n+    //\n+    // COOKIE\n+    // cookie-pair       = cookie-name \"=\" cookie-value\n+    // cookie-name       = token\n+    // token          = 1*<any CHAR except CTLs or separators>\n+    // CTL = <any US-ASCII control character\n+    //       (octets 0 - 31) and DEL (127)>\n+    // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n+    //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n+    //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n+    //                      | \"{\" | \"}\" | SP | HT\n+    //\n+    // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n+\n+    //    private static final class BitSet128 {\n+    //        private long high;\n+    //        private long low;\n+    //\n+    //        BitSet128 range(char fromInc, char toInc) {\n+    //            for (int bit = fromInc; bit <= toInc; bit++) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        BitSet128 bits(char... bits) {\n+    //            for (char bit : bits) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        long high() {\n+    //            return high;\n+    //        }\n+    //\n+    //        long low() {\n+    //            return low;\n+    //        }\n+    //\n+    //        static boolean contains(byte bit, long high, long low) {\n+    //            if (bit < 0) {\n+    //                return false;\n+    //            }\n+    //            if (bit < 64) {\n+    //                return 0 != (low & 1L << bit);\n+    //            }\n+    //            return 0 != (high & 1L << bit - 64);\n+    //        }\n+    //    }\n+\n+    // BitSet128 tokenChars = new BitSet128()\n+    //        .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n+    //        .bits('-', '.', '_', '~') // Unreserved characters.\n+    //        .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n+\n+    //this constants calculated by the above code\n+    private static final long TOKEN_CHARS_HIGH = 0x57ffffffc7fffffeL;\n+    private static final long TOKEN_CHARS_LOW = 0x3ff6cfa00000000L;\n+\n+    private static boolean contains(byte bit) {",
        "comment_created_at": "2025-05-23T23:45:20+00:00",
        "comment_author": "chrisvest",
        "comment_body": "`contains` is too generic a name once outside the `BitSet128` class. Let's call it `isValidTokenChar` or something like that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2105753253",
        "repo_full_name": "netty/netty",
        "pr_number": 15261,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java",
        "discussion_id": "2105528178",
        "commented_code": "@@ -675,92 +675,102 @@ private static int validateAsciiStringToken(AsciiString token) {\n     private static int validateCharSequenceToken(CharSequence token) {\n         for (int i = 0, len = token.length(); i < len; i++) {\n             byte value = (byte) token.charAt(i);\n-            if (!BitSet128.contains(value, TOKEN_CHARS_HIGH, TOKEN_CHARS_LOW)) {\n+            if (!contains(value)) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n \n-    private static final long TOKEN_CHARS_HIGH;\n-    private static final long TOKEN_CHARS_LOW;\n-    static {\n-        // HEADER\n-        // header-field   = field-name \":\" OWS field-value OWS\n-        //\n-        // field-name     = token\n-        // token          = 1*tchar\n-        //\n-        // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n-        //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n-        //                    / DIGIT / ALPHA\n-        //                    ; any VCHAR, except delimiters.\n-        //  Delimiters are chosen\n-        //   from the set of US-ASCII visual characters not allowed in a token\n-        //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n-        //\n-        // COOKIE\n-        // cookie-pair       = cookie-name \"=\" cookie-value\n-        // cookie-name       = token\n-        // token          = 1*<any CHAR except CTLs or separators>\n-        // CTL = <any US-ASCII control character\n-        //       (octets 0 - 31) and DEL (127)>\n-        // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n-        //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n-        //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n-        //                      | \"{\" | \"}\" | SP | HT\n-        //\n-        // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n-        BitSet128 tokenChars = new BitSet128()\n-                .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n-                .bits('-', '.', '_', '~') // Unreserved characters.\n-                .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n-        TOKEN_CHARS_HIGH = tokenChars.high();\n-        TOKEN_CHARS_LOW = tokenChars.low();\n-    }\n-\n-    private static final class BitSet128 {\n-        private long high;\n-        private long low;\n-\n-        BitSet128 range(char fromInc, char toInc) {\n-            for (int bit = fromInc; bit <= toInc; bit++) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n-        }\n-\n-        BitSet128 bits(char... bits) {\n-            for (char bit : bits) {\n-                if (bit < 64) {\n-                    low |= 1L << bit;\n-                } else {\n-                    high |= 1L << bit - 64;\n-                }\n-            }\n-            return this;\n+    // HEADER\n+    // header-field   = field-name \":\" OWS field-value OWS\n+    //\n+    // field-name     = token\n+    // token          = 1*tchar\n+    //\n+    // tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n+    //                    / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n+    //                    / DIGIT / ALPHA\n+    //                    ; any VCHAR, except delimiters.\n+    //  Delimiters are chosen\n+    //   from the set of US-ASCII visual characters not allowed in a token\n+    //   (DQUOTE and \"(),/:;<=>?@[\\]{}\")\n+    //\n+    // COOKIE\n+    // cookie-pair       = cookie-name \"=\" cookie-value\n+    // cookie-name       = token\n+    // token          = 1*<any CHAR except CTLs or separators>\n+    // CTL = <any US-ASCII control character\n+    //       (octets 0 - 31) and DEL (127)>\n+    // separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n+    //                      | \",\" | \";\" | \":\" | \"\\\" | <\">\n+    //                      | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n+    //                      | \"{\" | \"}\" | SP | HT\n+    //\n+    // field-name's token is equivalent to cookie-name's token, we can reuse the tchar mask for both:\n+\n+    //    private static final class BitSet128 {\n+    //        private long high;\n+    //        private long low;\n+    //\n+    //        BitSet128 range(char fromInc, char toInc) {\n+    //            for (int bit = fromInc; bit <= toInc; bit++) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        BitSet128 bits(char... bits) {\n+    //            for (char bit : bits) {\n+    //                if (bit < 64) {\n+    //                    low |= 1L << bit;\n+    //                } else {\n+    //                    high |= 1L << bit - 64;\n+    //                }\n+    //            }\n+    //            return this;\n+    //        }\n+    //\n+    //        long high() {\n+    //            return high;\n+    //        }\n+    //\n+    //        long low() {\n+    //            return low;\n+    //        }\n+    //\n+    //        static boolean contains(byte bit, long high, long low) {\n+    //            if (bit < 0) {\n+    //                return false;\n+    //            }\n+    //            if (bit < 64) {\n+    //                return 0 != (low & 1L << bit);\n+    //            }\n+    //            return 0 != (high & 1L << bit - 64);\n+    //        }\n+    //    }\n+\n+    // BitSet128 tokenChars = new BitSet128()\n+    //        .range('0', '9').range('a', 'z').range('A', 'Z') // Alphanumeric.\n+    //        .bits('-', '.', '_', '~') // Unreserved characters.\n+    //        .bits('!', '#', '$', '%', '&', '\\'', '*', '+', '^', '`', '|'); // Token special characters.\n+\n+    //this constants calculated by the above code\n+    private static final long TOKEN_CHARS_HIGH = 0x57ffffffc7fffffeL;\n+    private static final long TOKEN_CHARS_LOW = 0x3ff6cfa00000000L;\n+\n+    private static boolean contains(byte bit) {",
        "comment_created_at": "2025-05-24T08:03:20+00:00",
        "comment_author": "doom369",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1942739674",
    "pr_number": 14607,
    "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
    "created_at": "2025-02-05T11:55:12+00:00",
    "commented_code": "threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;\n         }\n \n-        @Override\n-        protected synchronized PoolThreadCache initialValue() {\n-            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n-            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n-\n-            final Thread current = Thread.currentThread();\n-            final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n-\n-            if (useCacheForAllThreads ||\n-                    // If the current thread is a FastThreadLocalThread we will always use the cache\n-                    current instanceof FastThreadLocalThread ||\n-                    // The Thread is used by an EventExecutor, let's use the cache as the chances are good that we\n-                    // will allocate a lot!\n-                    executor != null) {\n-                final PoolThreadCache cache = new PoolThreadCache(\n-                        heapArena, directArena, smallCacheSize, normalCacheSize,\n-                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL, useCacheFinalizers(current));\n-\n-                if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n-                    if (executor != null) {\n-                        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n-                                DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n-                    }\n-                }\n-                return cache;\n+        private PoolArena<byte[]> attatchHeapArena() {\n+            if (heapArenas == null || heapArenas.length == 0) {\n+                return null;\n+            }\n+            if (isHeapArenasPowerOf2) {\n+                return heapArenas[(int) Thread.currentThread().getId() & (heapArenas.length - 1)];\n+            } else {\n+                return heapArenas[(int) Thread.currentThread().getId() % heapArenas.length];\n             }\n-            // No caching so just use 0 as sizes.\n-            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, false);\n         }\n \n-        @Override\n-        protected void onRemoval(PoolThreadCache threadCache) {\n-            threadCache.free(false);\n+        private PoolArena<ByteBuffer> attatchDirectArena() {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1942739674",
        "repo_full_name": "netty/netty",
        "pr_number": 14607,
        "pr_file": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
        "discussion_id": "1942739674",
        "commented_code": "@@ -515,46 +538,98 @@ public void freeThreadLocalCache() {\n         threadCache.remove();\n     }\n \n-    private final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {\n-        private final boolean useCacheForAllThreads;\n+    private final class PoolThreadLocalCache {\n+        private final FastThreadLocal<PoolThreadCache> threadLocalCache;\n+\n+        PoolThreadLocalCache(final boolean useCacheForAllThreads, boolean useThreadLocal) {\n+            if (useThreadLocal) {\n+                threadLocalCache = new FastThreadLocal<PoolThreadCache>() {\n+                    @Override\n+                    protected synchronized PoolThreadCache initialValue() {\n+                        final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n+                        final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n+                        final Thread current = Thread.currentThread();\n+                        final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n+                        if (useCacheForAllThreads ||\n+                                // If the current thread is a FastThreadLocalThread we will always use the cache\n+                                current instanceof FastThreadLocalThread ||\n+                                // The Thread is used by an EventExecutor,\n+                                // let's use the cache as the chances are good that we will allocate a lot!\n+                                executor != null) {\n+                            final PoolThreadCache cache = new PoolThreadCache(\n+                                    heapArena, directArena, smallCacheSize, normalCacheSize,\n+                                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL,\n+                                    useCacheFinalizers(current));\n+\n+                            if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n+                                if (executor != null) {\n+                                    executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n+                                            DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n+                                }\n+                            }\n+                            return cache;\n+                        }\n+                        // No caching so just use 0 as sizes.\n+                        return new PoolThreadCache(heapArena, directArena, 0, 0,\n+                                0, 0, false);\n+                    }\n+                    @Override\n+                    protected void onRemoval(PoolThreadCache threadCache) {\n+                        threadCache.free(false);\n+                    }\n+                };\n+            } else {\n+                threadLocalCache = null;\n+            }\n+        }\n \n-        PoolThreadLocalCache(boolean useCacheForAllThreads) {\n-            this.useCacheForAllThreads = useCacheForAllThreads;\n+        PoolThreadCache get() {\n+            if (threadLocalCache != null) {\n+                return threadLocalCache.get();\n+            }\n+            return PoolThreadCache.THREAD_CACHE_WITHOUT_THREAD_LOCAL;\n         }\n \n-        @Override\n-        protected synchronized PoolThreadCache initialValue() {\n-            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);\n-            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n-\n-            final Thread current = Thread.currentThread();\n-            final EventExecutor executor = ThreadExecutorMap.currentExecutor();\n-\n-            if (useCacheForAllThreads ||\n-                    // If the current thread is a FastThreadLocalThread we will always use the cache\n-                    current instanceof FastThreadLocalThread ||\n-                    // The Thread is used by an EventExecutor, let's use the cache as the chances are good that we\n-                    // will allocate a lot!\n-                    executor != null) {\n-                final PoolThreadCache cache = new PoolThreadCache(\n-                        heapArena, directArena, smallCacheSize, normalCacheSize,\n-                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL, useCacheFinalizers(current));\n-\n-                if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {\n-                    if (executor != null) {\n-                        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,\n-                                DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);\n-                    }\n-                }\n-                return cache;\n+        private PoolArena<byte[]> attatchHeapArena() {\n+            if (heapArenas == null || heapArenas.length == 0) {\n+                return null;\n+            }\n+            if (isHeapArenasPowerOf2) {\n+                return heapArenas[(int) Thread.currentThread().getId() & (heapArenas.length - 1)];\n+            } else {\n+                return heapArenas[(int) Thread.currentThread().getId() % heapArenas.length];\n             }\n-            // No caching so just use 0 as sizes.\n-            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, false);\n         }\n \n-        @Override\n-        protected void onRemoval(PoolThreadCache threadCache) {\n-            threadCache.free(false);\n+        private PoolArena<ByteBuffer> attatchDirectArena() {",
        "comment_created_at": "2025-02-05T11:55:12+00:00",
        "comment_author": "franz1981",
        "comment_body": "change it into `selectDirectArena()` since it doesn't actually attach it here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1581818387",
    "pr_number": 13998,
    "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java",
    "created_at": "2024-04-27T11:55:16+00:00",
    "commented_code": "factory.removeHttpDataFromClean(request, data);\n     }\n \n+    /**\n+     * Check if request has headers indicating that it contains form body\n+     */\n+    private boolean hasFormBody() {\n+        String contentHeader = request.headers().get(\"Content-Type\");",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "1581818387",
        "repo_full_name": "netty/netty",
        "pr_number": 13998,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java",
        "discussion_id": "1581818387",
        "commented_code": "@@ -783,6 +784,17 @@ public void removeHttpDataFromClean(InterfaceHttpData data) {\n         factory.removeHttpDataFromClean(request, data);\n     }\n \n+    /**\n+     * Check if request has headers indicating that it contains form body\n+     */\n+    private boolean hasFormBody() {\n+        String contentHeader = request.headers().get(\"Content-Type\");",
        "comment_created_at": "2024-04-27T11:55:16+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "Use static HttpHeaderNames value ",
        "pr_file_module": null
      },
      {
        "comment_id": "1581820951",
        "repo_full_name": "netty/netty",
        "pr_number": 13998,
        "pr_file": "codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java",
        "discussion_id": "1581818387",
        "commented_code": "@@ -783,6 +784,17 @@ public void removeHttpDataFromClean(InterfaceHttpData data) {\n         factory.removeHttpDataFromClean(request, data);\n     }\n \n+    /**\n+     * Check if request has headers indicating that it contains form body\n+     */\n+    private boolean hasFormBody() {\n+        String contentHeader = request.headers().get(\"Content-Type\");",
        "comment_created_at": "2024-04-27T12:15:35+00:00",
        "comment_author": "gniadeck",
        "comment_body": "fixed, also renamed the `contentHeader` variable to `contentHeaderValue` :)",
        "pr_file_module": null
      }
    ]
  }
]