[
  {
    "discussion_id": "669036489",
    "pr_number": 11448,
    "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractMapRedisMessage.java",
    "created_at": "2021-07-13T19:06:59+00:00",
    "commented_code": "+/*\n+ * Copyright 2021 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.util.AbstractReferenceCounted;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.Map;\n+\n+@UnstableApi\n+public abstract class AbstractMapRedisMessage extends AbstractReferenceCounted\n+        implements AggregatedRedisMessage {\n+\n+    private final Map<RedisMessage, RedisMessage> children;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "669036489",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractMapRedisMessage.java",
        "discussion_id": "669036489",
        "commented_code": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2021 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.util.AbstractReferenceCounted;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.Map;\n+\n+@UnstableApi\n+public abstract class AbstractMapRedisMessage extends AbstractReferenceCounted\n+        implements AggregatedRedisMessage {\n+\n+    private final Map<RedisMessage, RedisMessage> children;",
        "comment_created_at": "2021-07-13T19:06:59+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "should this be an `unmodifiable` map ?",
        "pr_file_module": null
      },
      {
        "comment_id": "669570225",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractMapRedisMessage.java",
        "discussion_id": "669036489",
        "commented_code": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2021 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.util.AbstractReferenceCounted;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.Map;\n+\n+@UnstableApi\n+public abstract class AbstractMapRedisMessage extends AbstractReferenceCounted\n+        implements AggregatedRedisMessage {\n+\n+    private final Map<RedisMessage, RedisMessage> children;",
        "comment_created_at": "2021-07-14T12:30:42+00:00",
        "comment_author": "jjz921024",
        "comment_body": "Yes, it's better",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "669042960",
    "pr_number": 11448,
    "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMapAggregator.java",
    "created_at": "2021-07-13T19:17:25+00:00",
    "commented_code": "+/*\n+ * Copyright 2016 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Aggregates {@link RedisMessage} parts into {@link MapRedisMessage}.\n+ * This decoder should be used together with {@link RedisDecoder}.\n+ */\n+@UnstableApi\n+public final class RedisMapAggregator extends MessageToMessageDecoder<RedisMessage> {\n+\n+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {\n+        if (msg instanceof MapHeaderRedisMessage) {\n+            msg = decodeRedisMapHeader((AggregatedHeaderRedisMessage) msg);\n+            if (msg == null) {\n+                return;\n+            }\n+        } else {\n+            ReferenceCountUtil.retain(msg);\n+        }\n+\n+        while (!depths.isEmpty()) {\n+            AggregateState current = depths.peek();\n+            current.add(msg);\n+\n+            // if current aggregation completed, go to parent aggregation.\n+            if (current.children.size() == current.length) {\n+                msg = new MapRedisMessage(current.children);\n+                depths.pop();\n+            } else {\n+                // not aggregated yet. try next time.\n+                return;\n+            }\n+        }\n+\n+        out.add(msg);\n+    }\n+\n+    private RedisMessage decodeRedisMapHeader(AggregatedHeaderRedisMessage header) {\n+        // encode to Null types message if map is null or empty\n+        if (header.isNull()) {\n+            return NullRedisMessage.INSTANCE;\n+        } else if (header.length() == 0L) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "669042960",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMapAggregator.java",
        "discussion_id": "669042960",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2016 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Aggregates {@link RedisMessage} parts into {@link MapRedisMessage}.\n+ * This decoder should be used together with {@link RedisDecoder}.\n+ */\n+@UnstableApi\n+public final class RedisMapAggregator extends MessageToMessageDecoder<RedisMessage> {\n+\n+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {\n+        if (msg instanceof MapHeaderRedisMessage) {\n+            msg = decodeRedisMapHeader((AggregatedHeaderRedisMessage) msg);\n+            if (msg == null) {\n+                return;\n+            }\n+        } else {\n+            ReferenceCountUtil.retain(msg);\n+        }\n+\n+        while (!depths.isEmpty()) {\n+            AggregateState current = depths.peek();\n+            current.add(msg);\n+\n+            // if current aggregation completed, go to parent aggregation.\n+            if (current.children.size() == current.length) {\n+                msg = new MapRedisMessage(current.children);\n+                depths.pop();\n+            } else {\n+                // not aggregated yet. try next time.\n+                return;\n+            }\n+        }\n+\n+        out.add(msg);\n+    }\n+\n+    private RedisMessage decodeRedisMapHeader(AggregatedHeaderRedisMessage header) {\n+        // encode to Null types message if map is null or empty\n+        if (header.isNull()) {\n+            return NullRedisMessage.INSTANCE;\n+        } else if (header.length() == 0L) {",
        "comment_created_at": "2021-07-13T19:17:25+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "nit: you can remove the else",
        "pr_file_module": null
      },
      {
        "comment_id": "669640119",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMapAggregator.java",
        "discussion_id": "669042960",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2016 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Aggregates {@link RedisMessage} parts into {@link MapRedisMessage}.\n+ * This decoder should be used together with {@link RedisDecoder}.\n+ */\n+@UnstableApi\n+public final class RedisMapAggregator extends MessageToMessageDecoder<RedisMessage> {\n+\n+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {\n+        if (msg instanceof MapHeaderRedisMessage) {\n+            msg = decodeRedisMapHeader((AggregatedHeaderRedisMessage) msg);\n+            if (msg == null) {\n+                return;\n+            }\n+        } else {\n+            ReferenceCountUtil.retain(msg);\n+        }\n+\n+        while (!depths.isEmpty()) {\n+            AggregateState current = depths.peek();\n+            current.add(msg);\n+\n+            // if current aggregation completed, go to parent aggregation.\n+            if (current.children.size() == current.length) {\n+                msg = new MapRedisMessage(current.children);\n+                depths.pop();\n+            } else {\n+                // not aggregated yet. try next time.\n+                return;\n+            }\n+        }\n+\n+        out.add(msg);\n+    }\n+\n+    private RedisMessage decodeRedisMapHeader(AggregatedHeaderRedisMessage header) {\n+        // encode to Null types message if map is null or empty\n+        if (header.isNull()) {\n+            return NullRedisMessage.INSTANCE;\n+        } else if (header.length() == 0L) {",
        "comment_created_at": "2021-07-14T13:57:03+00:00",
        "comment_author": "jjz921024",
        "comment_body": "Is `if {...} else if {...}`  better than  `if {...} if {...}` ?",
        "pr_file_module": null
      },
      {
        "comment_id": "669691832",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMapAggregator.java",
        "discussion_id": "669042960",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2016 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Aggregates {@link RedisMessage} parts into {@link MapRedisMessage}.\n+ * This decoder should be used together with {@link RedisDecoder}.\n+ */\n+@UnstableApi\n+public final class RedisMapAggregator extends MessageToMessageDecoder<RedisMessage> {\n+\n+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {\n+        if (msg instanceof MapHeaderRedisMessage) {\n+            msg = decodeRedisMapHeader((AggregatedHeaderRedisMessage) msg);\n+            if (msg == null) {\n+                return;\n+            }\n+        } else {\n+            ReferenceCountUtil.retain(msg);\n+        }\n+\n+        while (!depths.isEmpty()) {\n+            AggregateState current = depths.peek();\n+            current.add(msg);\n+\n+            // if current aggregation completed, go to parent aggregation.\n+            if (current.children.size() == current.length) {\n+                msg = new MapRedisMessage(current.children);\n+                depths.pop();\n+            } else {\n+                // not aggregated yet. try next time.\n+                return;\n+            }\n+        }\n+\n+        out.add(msg);\n+    }\n+\n+    private RedisMessage decodeRedisMapHeader(AggregatedHeaderRedisMessage header) {\n+        // encode to Null types message if map is null or empty\n+        if (header.isNull()) {\n+            return NullRedisMessage.INSTANCE;\n+        } else if (header.length() == 0L) {",
        "comment_created_at": "2021-07-14T14:53:30+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "we usually only do `if` in this case if the other `if` returns. This way the indention is less ",
        "pr_file_module": null
      },
      {
        "comment_id": "669734611",
        "repo_full_name": "netty/netty",
        "pr_number": 11448,
        "pr_file": "codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMapAggregator.java",
        "discussion_id": "669042960",
        "commented_code": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2016 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package io.netty.handler.codec.redis;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.MessageToMessageDecoder;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.internal.UnstableApi;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Aggregates {@link RedisMessage} parts into {@link MapRedisMessage}.\n+ * This decoder should be used together with {@link RedisDecoder}.\n+ */\n+@UnstableApi\n+public final class RedisMapAggregator extends MessageToMessageDecoder<RedisMessage> {\n+\n+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {\n+        if (msg instanceof MapHeaderRedisMessage) {\n+            msg = decodeRedisMapHeader((AggregatedHeaderRedisMessage) msg);\n+            if (msg == null) {\n+                return;\n+            }\n+        } else {\n+            ReferenceCountUtil.retain(msg);\n+        }\n+\n+        while (!depths.isEmpty()) {\n+            AggregateState current = depths.peek();\n+            current.add(msg);\n+\n+            // if current aggregation completed, go to parent aggregation.\n+            if (current.children.size() == current.length) {\n+                msg = new MapRedisMessage(current.children);\n+                depths.pop();\n+            } else {\n+                // not aggregated yet. try next time.\n+                return;\n+            }\n+        }\n+\n+        out.add(msg);\n+    }\n+\n+    private RedisMessage decodeRedisMapHeader(AggregatedHeaderRedisMessage header) {\n+        // encode to Null types message if map is null or empty\n+        if (header.isNull()) {\n+            return NullRedisMessage.INSTANCE;\n+        } else if (header.length() == 0L) {",
        "comment_created_at": "2021-07-14T15:42:13+00:00",
        "comment_author": "jjz921024",
        "comment_body": "Got it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "660139679",
    "pr_number": 11419,
    "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
    "created_at": "2021-06-28T21:50:02+00:00",
    "commented_code": "}\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                bufferPromise = promise;\n+                return ctx.newPromise();\n+            } else {\n+                return promise;\n+            }\n+        } else {\n+            final ChannelPromise p;",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "660139679",
        "repo_full_name": "netty/netty",
        "pr_number": 11419,
        "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
        "discussion_id": "660139679",
        "commented_code": "@@ -254,6 +259,47 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws\n         }\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                bufferPromise = promise;\n+                return ctx.newPromise();\n+            } else {\n+                return promise;\n+            }\n+        } else {\n+            final ChannelPromise p;",
        "comment_created_at": "2021-06-28T21:50:02+00:00",
        "comment_author": "NiteshKant",
        "comment_body": "nit: For readability, move the variable to the branches where it is required.\r\n\r\n```java\r\n            if (buffer.isReadable()) {\r\n                if (out.isReadable()) {\r\n                    final ChannelPromise prev = bufferPromise;\r\n                    bufferPromise = promise;\r\n                    return prev;\r\n                } else {\r\n                    bufferPromise.addListener(new ChannelPromiseNotifier(promise));\r\n                    return ctx.newPromise();\r\n                }\r\n            } else {\r\n                bufferPromise.addListener(new ChannelPromiseNotifier(promise));\r\n                final ChannelPromise prev = bufferPromise;\r\n                bufferPromise = null;\r\n                return prev;\r\n            }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "660766678",
        "repo_full_name": "netty/netty",
        "pr_number": 11419,
        "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
        "discussion_id": "660139679",
        "commented_code": "@@ -254,6 +259,47 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws\n         }\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                bufferPromise = promise;\n+                return ctx.newPromise();\n+            } else {\n+                return promise;\n+            }\n+        } else {\n+            final ChannelPromise p;",
        "comment_created_at": "2021-06-29T16:09:35+00:00",
        "comment_author": "TommyWind",
        "comment_body": "++ done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "663160763",
    "pr_number": 11419,
    "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
    "created_at": "2021-07-02T17:32:30+00:00",
    "commented_code": "}\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+                bufferPromise = null;\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                if (out.isReadable()) {\n+                    // The second half of msg got buffered in #buffer and the first half went into out so both have to\n+                    // succeed for msg's promise to succeed. We create a new promise for the part of the message in\n+                    // out because we started without a pending #bufferPromise.\n+                    return combinedPromise(ctx, promise, ctx.newPromise());\n+                }\n+                bufferPromise = promise;\n+                // out is empty and we just return a new promise as out does not contain any part of msg\n+                return ctx.newPromise();\n+            }\n+            return promise;\n+        }\n+        if (buffer.isReadable()) {\n+            if (out.isReadable()) {\n+                // the second half of msg got buffered in #buffer and the first half went into out so both have to\n+                // succeed for msg's promise to succeed so we associate #bufferPromise with out\n+                return combinedPromise(ctx, promise, bufferPromise);\n+            }\n+            bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+            // out is empty and we just return a new promise as out does not contain any part of msg\n+            return ctx.newPromise();\n+        }\n+        // msg exactly filled up a frame so both the previously buffered data as well as msg are now in out so we\n+        // notify both simultaneously through #bufferPromise\n+        bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+        final ChannelPromise prev = bufferPromise;\n+        bufferPromise = null;\n+        return prev;\n+    }\n+\n+    /**\n+     * This method handles the promise ({@code msgPromise}) to notify for a message that is split between the current\n+     * output buffer and {@link #buffer}. In this case {@code msgPromise} is notified with success once the current\n+     * {@link #bufferPromise} succeeds and the promise ({@code outPromise}) associated with the current write buffer\n+     * succeeds. If either of the two do not succeed then the {@code msgPromise} must fail.\n+     *\n+     * @param ctx        the {@link ChannelHandlerContext} which this {@link Lz4FrameEncoder} belongs to\n+     * @param msgPromise promise to notify once all of a message has been written\n+     * @param outPromise promise to notify once the current write buffer has been written\n+     * @return           the given {@code outPromise}\n+     */\n+    private ChannelPromise combinedPromise(final ChannelHandlerContext ctx, final ChannelPromise msgPromise,",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "663160763",
        "repo_full_name": "netty/netty",
        "pr_number": 11419,
        "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
        "discussion_id": "663160763",
        "commented_code": "@@ -254,6 +259,82 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws\n         }\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+                bufferPromise = null;\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                if (out.isReadable()) {\n+                    // The second half of msg got buffered in #buffer and the first half went into out so both have to\n+                    // succeed for msg's promise to succeed. We create a new promise for the part of the message in\n+                    // out because we started without a pending #bufferPromise.\n+                    return combinedPromise(ctx, promise, ctx.newPromise());\n+                }\n+                bufferPromise = promise;\n+                // out is empty and we just return a new promise as out does not contain any part of msg\n+                return ctx.newPromise();\n+            }\n+            return promise;\n+        }\n+        if (buffer.isReadable()) {\n+            if (out.isReadable()) {\n+                // the second half of msg got buffered in #buffer and the first half went into out so both have to\n+                // succeed for msg's promise to succeed so we associate #bufferPromise with out\n+                return combinedPromise(ctx, promise, bufferPromise);\n+            }\n+            bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+            // out is empty and we just return a new promise as out does not contain any part of msg\n+            return ctx.newPromise();\n+        }\n+        // msg exactly filled up a frame so both the previously buffered data as well as msg are now in out so we\n+        // notify both simultaneously through #bufferPromise\n+        bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+        final ChannelPromise prev = bufferPromise;\n+        bufferPromise = null;\n+        return prev;\n+    }\n+\n+    /**\n+     * This method handles the promise ({@code msgPromise}) to notify for a message that is split between the current\n+     * output buffer and {@link #buffer}. In this case {@code msgPromise} is notified with success once the current\n+     * {@link #bufferPromise} succeeds and the promise ({@code outPromise}) associated with the current write buffer\n+     * succeeds. If either of the two do not succeed then the {@code msgPromise} must fail.\n+     *\n+     * @param ctx        the {@link ChannelHandlerContext} which this {@link Lz4FrameEncoder} belongs to\n+     * @param msgPromise promise to notify once all of a message has been written\n+     * @param outPromise promise to notify once the current write buffer has been written\n+     * @return           the given {@code outPromise}\n+     */\n+    private ChannelPromise combinedPromise(final ChannelHandlerContext ctx, final ChannelPromise msgPromise,",
        "comment_created_at": "2021-07-02T17:32:30+00:00",
        "comment_author": "NiteshKant",
        "comment_body": "IMHO adding this method adds confusion than making code readable. The fact that it also has a side effect of updating `bufferPromise` but the name does not reflect the side-effect makes it more confusing. My suggestion would be to inline this method and if you want, have the `ChannelFutureListener` used here be a static inner class that you can reuse.",
        "pr_file_module": null
      },
      {
        "comment_id": "663923358",
        "repo_full_name": "netty/netty",
        "pr_number": 11419,
        "pr_file": "codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java",
        "discussion_id": "663160763",
        "commented_code": "@@ -254,6 +259,82 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws\n         }\n     }\n \n+    @Override\n+    protected ChannelPromise encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out, ChannelPromise promise)\n+            throws Exception {\n+        try {\n+            encode(ctx, msg, out);\n+        } catch (Exception e) {\n+            if (bufferPromise != null) {\n+                bufferPromise.tryFailure(e);\n+                bufferPromise = null;\n+            }\n+            throw e;\n+        }\n+\n+        if (bufferPromise == null) {\n+            if (finished) {\n+                return promise;\n+            }\n+            if (buffer.isReadable()) {\n+                if (out.isReadable()) {\n+                    // The second half of msg got buffered in #buffer and the first half went into out so both have to\n+                    // succeed for msg's promise to succeed. We create a new promise for the part of the message in\n+                    // out because we started without a pending #bufferPromise.\n+                    return combinedPromise(ctx, promise, ctx.newPromise());\n+                }\n+                bufferPromise = promise;\n+                // out is empty and we just return a new promise as out does not contain any part of msg\n+                return ctx.newPromise();\n+            }\n+            return promise;\n+        }\n+        if (buffer.isReadable()) {\n+            if (out.isReadable()) {\n+                // the second half of msg got buffered in #buffer and the first half went into out so both have to\n+                // succeed for msg's promise to succeed so we associate #bufferPromise with out\n+                return combinedPromise(ctx, promise, bufferPromise);\n+            }\n+            bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+            // out is empty and we just return a new promise as out does not contain any part of msg\n+            return ctx.newPromise();\n+        }\n+        // msg exactly filled up a frame so both the previously buffered data as well as msg are now in out so we\n+        // notify both simultaneously through #bufferPromise\n+        bufferPromise.addListener(new ChannelPromiseNotifier(promise));\n+        final ChannelPromise prev = bufferPromise;\n+        bufferPromise = null;\n+        return prev;\n+    }\n+\n+    /**\n+     * This method handles the promise ({@code msgPromise}) to notify for a message that is split between the current\n+     * output buffer and {@link #buffer}. In this case {@code msgPromise} is notified with success once the current\n+     * {@link #bufferPromise} succeeds and the promise ({@code outPromise}) associated with the current write buffer\n+     * succeeds. If either of the two do not succeed then the {@code msgPromise} must fail.\n+     *\n+     * @param ctx        the {@link ChannelHandlerContext} which this {@link Lz4FrameEncoder} belongs to\n+     * @param msgPromise promise to notify once all of a message has been written\n+     * @param outPromise promise to notify once the current write buffer has been written\n+     * @return           the given {@code outPromise}\n+     */\n+    private ChannelPromise combinedPromise(final ChannelHandlerContext ctx, final ChannelPromise msgPromise,",
        "comment_created_at": "2021-07-05T13:15:15+00:00",
        "comment_author": "TommyWind",
        "comment_body": "Right, extracted a `static` inner class for the listener now and inlined the rest of the logic. Much easier to read indeed, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "388806721",
    "pr_number": 9935,
    "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
    "created_at": "2020-03-06T09:49:51+00:00",
    "commented_code": "@Override\n     protected void doBeginRead() throws Exception {\n-        // NOOP\n+        // read from tempInboundMessages and fire channelRead.\n+        if (!tempInboundMessages().isEmpty()) {\n+            Object msg;\n+            while ((msg = tempInboundMessages().poll()) != null) {\n+                ChannelPipeline p = pipeline();\n+                p.fireChannelRead(msg);\n+            }",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "388806721",
        "repo_full_name": "netty/netty",
        "pr_number": 9935,
        "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
        "discussion_id": "388806721",
        "commented_code": "@@ -723,7 +747,17 @@ protected void doClose() throws Exception {\n \n     @Override\n     protected void doBeginRead() throws Exception {\n-        // NOOP\n+        // read from tempInboundMessages and fire channelRead.\n+        if (!tempInboundMessages().isEmpty()) {\n+            Object msg;\n+            while ((msg = tempInboundMessages().poll()) != null) {\n+                ChannelPipeline p = pipeline();\n+                p.fireChannelRead(msg);\n+            }",
        "comment_created_at": "2020-03-06T09:49:51+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "please use the same style we use everywhere else in netty:\r\n\r\n```\r\nfor (;;) {\r\n    Object msg = tempInboundMessages().poll()\r\n    if (msg == null) {\r\n        break;\r\n    }\r\n    pipeline.fireChannelRead(msg);\r\n}\r\n....\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "388864854",
        "repo_full_name": "netty/netty",
        "pr_number": 9935,
        "pr_file": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
        "discussion_id": "388806721",
        "commented_code": "@@ -723,7 +747,17 @@ protected void doClose() throws Exception {\n \n     @Override\n     protected void doBeginRead() throws Exception {\n-        // NOOP\n+        // read from tempInboundMessages and fire channelRead.\n+        if (!tempInboundMessages().isEmpty()) {\n+            Object msg;\n+            while ((msg = tempInboundMessages().poll()) != null) {\n+                ChannelPipeline p = pipeline();\n+                p.fireChannelRead(msg);\n+            }",
        "comment_created_at": "2020-03-06T12:00:30+00:00",
        "comment_author": "carryxyh",
        "comment_body": "done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006238025",
    "pr_number": 14947,
    "pr_file": "common/src/main/java/io/netty/util/AsciiString.java",
    "created_at": "2025-03-20T18:38:47+00:00",
    "commented_code": "return true;\n         }\n \n-        final int thatEnd = start + length;\n-        for (int i = start, j = thisStart + arrayOffset(); i < thatEnd; i++, j++) {\n-            if (b2c(value[j]) != string.charAt(i)) {\n-                return false;\n+        if (string instanceof AsciiString) {\n+            final AsciiString asciiString = (AsciiString) string;\n+            return PlatformDependent.equals(value, thisStart + offset, asciiString.value,\n+                                            start + asciiString.offset, length);\n+        } else {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "2006238025",
        "repo_full_name": "netty/netty",
        "pr_number": 14947,
        "pr_file": "common/src/main/java/io/netty/util/AsciiString.java",
        "discussion_id": "2006238025",
        "commented_code": "@@ -833,10 +833,16 @@ public boolean regionMatches(int thisStart, CharSequence string, int start, int\n             return true;\n         }\n \n-        final int thatEnd = start + length;\n-        for (int i = start, j = thisStart + arrayOffset(); i < thatEnd; i++, j++) {\n-            if (b2c(value[j]) != string.charAt(i)) {\n-                return false;\n+        if (string instanceof AsciiString) {\n+            final AsciiString asciiString = (AsciiString) string;\n+            return PlatformDependent.equals(value, thisStart + offset, asciiString.value,\n+                                            start + asciiString.offset, length);\n+        } else {",
        "comment_created_at": "2025-03-20T18:38:47+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "nit: you can remove the `else` as we return in the if block ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "693995762",
    "pr_number": 11603,
    "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/h2new/AbstractHttp2StreamFramesValidator.java",
    "created_at": "2021-08-23T13:56:24+00:00",
    "commented_code": "+/*\n+ * Copyright 2021 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package io.netty.handler.codec.h2new;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerAdapter;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.Promise;\n+import io.netty.util.internal.logging.InternalLogger;\n+\n+import static io.netty.handler.codec.h2new.GoAwayManager.ProtocolErrorEvent.PROTOCOL_ERROR_EVENT_NO_DEBUG_DATA;\n+import static io.netty.util.internal.logging.InternalLoggerFactory.getInstance;\n+\n+/**\n+ * A {@link ChannelHandler} that validates frames exchanged on a stream.\n+ */\n+abstract class AbstractHttp2StreamFramesValidator extends ChannelHandlerAdapter {\n+    private static final InternalLogger logger = getInstance(AbstractHttp2StreamFramesValidator.class);\n+\n+    @Override\n+    public final void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (!(msg instanceof Http2Frame)) {\n+            ctx.fireChannelRead(msg);\n+            return;\n+        }\n+\n+        if (validateFrameRead(ctx, (Http2Frame) msg)) {",
    "repo_full_name": "netty/netty",
    "discussion_comments": [
      {
        "comment_id": "693995762",
        "repo_full_name": "netty/netty",
        "pr_number": 11603,
        "pr_file": "codec-http2/src/main/java/io/netty/handler/codec/h2new/AbstractHttp2StreamFramesValidator.java",
        "discussion_id": "693995762",
        "commented_code": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2021 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package io.netty.handler.codec.h2new;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerAdapter;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.Promise;\n+import io.netty.util.internal.logging.InternalLogger;\n+\n+import static io.netty.handler.codec.h2new.GoAwayManager.ProtocolErrorEvent.PROTOCOL_ERROR_EVENT_NO_DEBUG_DATA;\n+import static io.netty.util.internal.logging.InternalLoggerFactory.getInstance;\n+\n+/**\n+ * A {@link ChannelHandler} that validates frames exchanged on a stream.\n+ */\n+abstract class AbstractHttp2StreamFramesValidator extends ChannelHandlerAdapter {\n+    private static final InternalLogger logger = getInstance(AbstractHttp2StreamFramesValidator.class);\n+\n+    @Override\n+    public final void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (!(msg instanceof Http2Frame)) {\n+            ctx.fireChannelRead(msg);\n+            return;\n+        }\n+\n+        if (validateFrameRead(ctx, (Http2Frame) msg)) {",
        "comment_created_at": "2021-08-23T13:56:24+00:00",
        "comment_author": "normanmaurer",
        "comment_body": "nit: you could simplify this by using:\r\n\r\n```java\r\nif (!(msg instanceof Http2Frame) || validateFrameRead(ctx, (Http2Frame) msg) {\r\n    ctx.fireChannelRead(msg);\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]