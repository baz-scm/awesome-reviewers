[
  {
    "discussion_id": "2030261276",
    "pr_number": 57775,
    "pr_file": "test/parallel/test-fs-stat-abort-test.js",
    "created_at": "2025-04-06T20:29:06+00:00",
    "commented_code": "+'use strict';\n+\n+require('../common');\n+const test = require('node:test');\n+const assert = require('node:assert');\n+const fs = require('node:fs');\n+\n+const filePath = './temp.txt';\n+fs.writeFileSync(filePath, 'Test');\n+\n+test('fs.stat should throw AbortError when abort signal is triggered', async () => {\n+  const controller = new AbortController();\n+  controller.abort();\n+  const { signal } = controller;\n+\n+  const statPromise = new Promise((resolve, reject) => {\n+    fs.stat(filePath, { signal }, (err, stats) => {\n+      if (err) {\n+        return reject(err);\n+      }\n+      resolve(stats);\n+    });\n+  });\n+\n+  await assert.rejects(statPromise, { name: 'AbortError' });",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2030261276",
        "repo_full_name": "nodejs/node",
        "pr_number": 57775,
        "pr_file": "test/parallel/test-fs-stat-abort-test.js",
        "discussion_id": "2030261276",
        "commented_code": "@@ -0,0 +1,28 @@\n+'use strict';\n+\n+require('../common');\n+const test = require('node:test');\n+const assert = require('node:assert');\n+const fs = require('node:fs');\n+\n+const filePath = './temp.txt';\n+fs.writeFileSync(filePath, 'Test');\n+\n+test('fs.stat should throw AbortError when abort signal is triggered', async () => {\n+  const controller = new AbortController();\n+  controller.abort();\n+  const { signal } = controller;\n+\n+  const statPromise = new Promise((resolve, reject) => {\n+    fs.stat(filePath, { signal }, (err, stats) => {\n+      if (err) {\n+        return reject(err);\n+      }\n+      resolve(stats);\n+    });\n+  });\n+\n+  await assert.rejects(statPromise, { name: 'AbortError' });",
        "comment_created_at": "2025-04-06T20:29:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n  const { promise, resolve, reject } = Promise.withResolvers();\r\n  fs.stat(filePath, { signal }, (err, stats) => {\r\n    if (err) {\r\n      return reject(err);\r\n    }\r\n    resolve(stats);\r\n  });\r\n\r\n  await assert.rejects(promise, { name: 'AbortError' });\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160088477",
    "pr_number": 58664,
    "pr_file": "test/parallel/test-stream-readable-to-web-termination-byob.js",
    "created_at": "2025-06-21T17:11:33+00:00",
    "commented_code": "+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+{\n+  const r = Readable.from([]);\n+  // Cancelling reader while closing should not cause uncaught exceptions\n+  r.on('close', () => reader.cancel());\n+\n+  const reader = Readable.toWeb(r, { type: 'bytes' }).getReader({ mode: 'byob' });\n+  reader.read(new Uint8Array(16));",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160088477",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-termination-byob.js",
        "discussion_id": "2160088477",
        "commented_code": "@@ -0,0 +1,11 @@\n+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+{\n+  const r = Readable.from([]);\n+  // Cancelling reader while closing should not cause uncaught exceptions\n+  r.on('close', () => reader.cancel());\n+\n+  const reader = Readable.toWeb(r, { type: 'bytes' }).getReader({ mode: 'byob' });\n+  reader.read(new Uint8Array(16));",
        "comment_created_at": "2025-06-21T17:11:33+00:00",
        "comment_author": "jasnell",
        "comment_body": "should the read at least be awaited?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160222664",
    "pr_number": 58666,
    "pr_file": "test/parallel/test-web-locks.js",
    "created_at": "2025-06-22T04:58:24+00:00",
    "commented_code": "+'use strict';\n+// Flags: --expose-gc\n+\n+require('../common');\n+const { describe, it } = require('node:test');\n+const assert = require('node:assert');\n+const { Worker } = require('worker_threads');\n+\n+describe('Web Locks with worker threads', () => {\n+  it('should handle exclusive locks', async () => {\n+    const worker = new Worker(`\n+      const { parentPort } = require('worker_threads');\n+      const assert = require('node:assert');\n+      \n+      navigator.locks.request('exclusive-test', async (lock) => {\n+        assert.strictEqual(lock.mode, 'exclusive');\n+        parentPort.postMessage({ success: true });\n+      }).catch(err => parentPort.postMessage({ error: err.message }));",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160222664",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "test/parallel/test-web-locks.js",
        "discussion_id": "2160222664",
        "commented_code": "@@ -0,0 +1,176 @@\n+'use strict';\n+// Flags: --expose-gc\n+\n+require('../common');\n+const { describe, it } = require('node:test');\n+const assert = require('node:assert');\n+const { Worker } = require('worker_threads');\n+\n+describe('Web Locks with worker threads', () => {\n+  it('should handle exclusive locks', async () => {\n+    const worker = new Worker(`\n+      const { parentPort } = require('worker_threads');\n+      const assert = require('node:assert');\n+      \n+      navigator.locks.request('exclusive-test', async (lock) => {\n+        assert.strictEqual(lock.mode, 'exclusive');\n+        parentPort.postMessage({ success: true });\n+      }).catch(err => parentPort.postMessage({ error: err.message }));",
        "comment_created_at": "2025-06-22T04:58:24+00:00",
        "comment_author": "jasnell",
        "comment_body": "It doesn't necessarily need to be done in this PR (but would need to be done before this graduates from experimental), but we should make sure that this plays well with AsyncLocalStorage. Specifically, something like the following should work:\r\n\r\n```\r\nconst als = new AsyncLocalStorage();\r\nals.run(123, () => {\r\n  navigator.locks.request('exclusive-test', async (lock) => {\r\n    assert.strictEqual(als.getStore(), 123);\r\n  });\r\n});\r\n```\r\n\r\nThis would suggest that the lock request is capable of capturing the current async context frame and restoring it when the lock has been acquired and the callback is invoked.",
        "pr_file_module": null
      },
      {
        "comment_id": "2160426541",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "test/parallel/test-web-locks.js",
        "discussion_id": "2160222664",
        "commented_code": "@@ -0,0 +1,176 @@\n+'use strict';\n+// Flags: --expose-gc\n+\n+require('../common');\n+const { describe, it } = require('node:test');\n+const assert = require('node:assert');\n+const { Worker } = require('worker_threads');\n+\n+describe('Web Locks with worker threads', () => {\n+  it('should handle exclusive locks', async () => {\n+    const worker = new Worker(`\n+      const { parentPort } = require('worker_threads');\n+      const assert = require('node:assert');\n+      \n+      navigator.locks.request('exclusive-test', async (lock) => {\n+        assert.strictEqual(lock.mode, 'exclusive');\n+        parentPort.postMessage({ success: true });\n+      }).catch(err => parentPort.postMessage({ error: err.message }));",
        "comment_created_at": "2025-06-22T18:35:01+00:00",
        "comment_author": "IlyasShabi",
        "comment_body": "I added a [test](https://github.com/nodejs/node/pull/58666/files#diff-43b814c3b4b1a7ea09d2bf9c7b856da949bcb12366c4e64a705e0700a96595b3R178) to check we are preserving asl context across lock callback ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118865315",
    "pr_number": 58536,
    "pr_file": "lib/internal/fs/promises.js",
    "created_at": "2025-06-01T08:11:39+00:00",
    "commented_code": ");\n     }\n \n-\n     const readFn = FunctionPrototypeBind(this.read, this);\n-    const ondone = FunctionPrototypeBind(this[kUnref], this);\n+    const ondone = async () => {\n+      this[kUnref]();\n+      if (options.autoClose) this.close();",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118865315",
        "repo_full_name": "nodejs/node",
        "pr_number": 58536,
        "pr_file": "lib/internal/fs/promises.js",
        "discussion_id": "2118865315",
        "commented_code": "@@ -301,9 +307,11 @@ class FileHandle extends EventEmitter {\n       );\n     }\n \n-\n     const readFn = FunctionPrototypeBind(this.read, this);\n-    const ondone = FunctionPrototypeBind(this[kUnref], this);\n+    const ondone = async () => {\n+      this[kUnref]();\n+      if (options.autoClose) this.close();",
        "comment_created_at": "2025-06-01T08:11:39+00:00",
        "comment_author": "LiviaMedeiros",
        "comment_body": "Shouldn't we await here?\r\n```suggestion\r\n      if (options.autoClose) await this.close();\r\n```",
        "pr_file_module": null
      }
    ]
  }
]