[
  {
    "discussion_id": "2146757758",
    "pr_number": 58664,
    "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
    "created_at": "2025-06-14T08:36:30+00:00",
    "commented_code": "+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto) { common.skip('missing crypto'); }\n+\n+const { Readable } = require('stream');\n+const process = require('process');\n+const { randomBytes } = require('crypto');\n+const assert = require('assert');\n+\n+// Based on: https://github.com/nodejs/node/issues/46347#issuecomment-1413886707\n+// edit: make it cross-platform as /dev/urandom is not available on Windows\n+{\n+  let currentMemoryUsage = process.memoryUsage().arrayBuffers;\n+\n+  // We initialize a stream, but not start consuming it\n+  const randomNodeStream = new Readable({\n+    read(size) {\n+      randomBytes(size, (err, buffer) => {\n+        if (err) {\n+          // If an error occurs, emit an 'error' event\n+          this.emit('error', err);\n+          return;\n+        }\n+\n+        // Push the random bytes to the stream\n+        this.push(buffer);\n+      });\n+    }\n+  });\n+  // after 2 seconds, it'll get converted to web stream\n+  let randomWebStream;\n+\n+  // We check memory usage every second\n+  // since it's a stream, it shouldn't be higher than the chunk size\n+  const reportMemoryUsage = () => {\n+    const { arrayBuffers } = process.memoryUsage();\n+    currentMemoryUsage = arrayBuffers;\n+\n+    assert(currentMemoryUsage <= 256 * 1024 * 1024);\n+  };\n+  setInterval(reportMemoryUsage, 1000);\n+\n+  // after 1 second we use Readable.toWeb\n+  // memory usage should stay pretty much the same since it's still a stream\n+  setTimeout(() => {\n+    randomWebStream = Readable.toWeb(randomNodeStream, { type: 'bytes' });\n+  }, 1000);\n+\n+  // after 2 seconds we start consuming the stream\n+  // memory usage will grow, but the old chunks should be garbage-collected pretty quickly\n+  setTimeout(async () => {\n+\n+    const reader = randomWebStream.getReader({ mode: 'byob' });\n+\n+    let done = false;\n+    while (!done) {\n+      // Read a 16 bytes of data from the stream\n+      const result = await reader.read(new Uint8Array(16));\n+      done = result.done;\n+      // We consume the stream, but we don't do anything with the data\n+      // This is to ensure that the stream is being consumed\n+      // and that the memory usage is being reported correctly\n+    }\n+  }, 2000);\n+\n+  setTimeout(() => {\n+    // Test considered passed if we don't crash\n+    process.exit(0);\n+  }, 5000);",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2146757758",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
        "discussion_id": "2146757758",
        "commented_code": "@@ -0,0 +1,70 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto) { common.skip('missing crypto'); }\n+\n+const { Readable } = require('stream');\n+const process = require('process');\n+const { randomBytes } = require('crypto');\n+const assert = require('assert');\n+\n+// Based on: https://github.com/nodejs/node/issues/46347#issuecomment-1413886707\n+// edit: make it cross-platform as /dev/urandom is not available on Windows\n+{\n+  let currentMemoryUsage = process.memoryUsage().arrayBuffers;\n+\n+  // We initialize a stream, but not start consuming it\n+  const randomNodeStream = new Readable({\n+    read(size) {\n+      randomBytes(size, (err, buffer) => {\n+        if (err) {\n+          // If an error occurs, emit an 'error' event\n+          this.emit('error', err);\n+          return;\n+        }\n+\n+        // Push the random bytes to the stream\n+        this.push(buffer);\n+      });\n+    }\n+  });\n+  // after 2 seconds, it'll get converted to web stream\n+  let randomWebStream;\n+\n+  // We check memory usage every second\n+  // since it's a stream, it shouldn't be higher than the chunk size\n+  const reportMemoryUsage = () => {\n+    const { arrayBuffers } = process.memoryUsage();\n+    currentMemoryUsage = arrayBuffers;\n+\n+    assert(currentMemoryUsage <= 256 * 1024 * 1024);\n+  };\n+  setInterval(reportMemoryUsage, 1000);\n+\n+  // after 1 second we use Readable.toWeb\n+  // memory usage should stay pretty much the same since it's still a stream\n+  setTimeout(() => {\n+    randomWebStream = Readable.toWeb(randomNodeStream, { type: 'bytes' });\n+  }, 1000);\n+\n+  // after 2 seconds we start consuming the stream\n+  // memory usage will grow, but the old chunks should be garbage-collected pretty quickly\n+  setTimeout(async () => {\n+\n+    const reader = randomWebStream.getReader({ mode: 'byob' });\n+\n+    let done = false;\n+    while (!done) {\n+      // Read a 16 bytes of data from the stream\n+      const result = await reader.read(new Uint8Array(16));\n+      done = result.done;\n+      // We consume the stream, but we don't do anything with the data\n+      // This is to ensure that the stream is being consumed\n+      // and that the memory usage is being reported correctly\n+    }\n+  }, 2000);\n+\n+  setTimeout(() => {\n+    // Test considered passed if we don't crash\n+    process.exit(0);\n+  }, 5000);",
        "comment_created_at": "2025-06-14T08:36:30+00:00",
        "comment_author": "mcollina",
        "comment_body": "This would cause much flakyness and generic slowness. Don't use timers.",
        "pr_file_module": null
      },
      {
        "comment_id": "2146914422",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
        "discussion_id": "2146757758",
        "commented_code": "@@ -0,0 +1,70 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto) { common.skip('missing crypto'); }\n+\n+const { Readable } = require('stream');\n+const process = require('process');\n+const { randomBytes } = require('crypto');\n+const assert = require('assert');\n+\n+// Based on: https://github.com/nodejs/node/issues/46347#issuecomment-1413886707\n+// edit: make it cross-platform as /dev/urandom is not available on Windows\n+{\n+  let currentMemoryUsage = process.memoryUsage().arrayBuffers;\n+\n+  // We initialize a stream, but not start consuming it\n+  const randomNodeStream = new Readable({\n+    read(size) {\n+      randomBytes(size, (err, buffer) => {\n+        if (err) {\n+          // If an error occurs, emit an 'error' event\n+          this.emit('error', err);\n+          return;\n+        }\n+\n+        // Push the random bytes to the stream\n+        this.push(buffer);\n+      });\n+    }\n+  });\n+  // after 2 seconds, it'll get converted to web stream\n+  let randomWebStream;\n+\n+  // We check memory usage every second\n+  // since it's a stream, it shouldn't be higher than the chunk size\n+  const reportMemoryUsage = () => {\n+    const { arrayBuffers } = process.memoryUsage();\n+    currentMemoryUsage = arrayBuffers;\n+\n+    assert(currentMemoryUsage <= 256 * 1024 * 1024);\n+  };\n+  setInterval(reportMemoryUsage, 1000);\n+\n+  // after 1 second we use Readable.toWeb\n+  // memory usage should stay pretty much the same since it's still a stream\n+  setTimeout(() => {\n+    randomWebStream = Readable.toWeb(randomNodeStream, { type: 'bytes' });\n+  }, 1000);\n+\n+  // after 2 seconds we start consuming the stream\n+  // memory usage will grow, but the old chunks should be garbage-collected pretty quickly\n+  setTimeout(async () => {\n+\n+    const reader = randomWebStream.getReader({ mode: 'byob' });\n+\n+    let done = false;\n+    while (!done) {\n+      // Read a 16 bytes of data from the stream\n+      const result = await reader.read(new Uint8Array(16));\n+      done = result.done;\n+      // We consume the stream, but we don't do anything with the data\n+      // This is to ensure that the stream is being consumed\n+      // and that the memory usage is being reported correctly\n+    }\n+  }, 2000);\n+\n+  setTimeout(() => {\n+    // Test considered passed if we don't crash\n+    process.exit(0);\n+  }, 5000);",
        "comment_created_at": "2025-06-14T12:17:18+00:00",
        "comment_author": "seriousme",
        "comment_body": "The problem in the doc generation seems to be fixed now with [fix: correct link from webstream to streamduplextowebstreamduplex](https://github.com/nodejs/node/pull/58664/commits/423decc77e6c420d29858b4e9d0c66975e91a514)\r\n\r\nWith regards to the use of timers during tests:\r\n`test/parallel/test-stream-readable-to-web-byob.js`\r\nis a slightly modified copy of the aready existing: \r\n`test/parallel/test-stream-readable-to-web.js`\r\nwhich also uses timers:\r\n\r\nhttps://github.com/nodejs/node/blob/5fe78006834011621969a76b4f2d98c0e0039b33/test/parallel/test-stream-readable-to-web.js#L58-L62\r\n\r\nDo you have any suggestions on how to code these tests without using timers?\r\n\r\nKind regards,\r\nHans",
        "pr_file_module": null
      },
      {
        "comment_id": "2149715667",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
        "discussion_id": "2146757758",
        "commented_code": "@@ -0,0 +1,70 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto) { common.skip('missing crypto'); }\n+\n+const { Readable } = require('stream');\n+const process = require('process');\n+const { randomBytes } = require('crypto');\n+const assert = require('assert');\n+\n+// Based on: https://github.com/nodejs/node/issues/46347#issuecomment-1413886707\n+// edit: make it cross-platform as /dev/urandom is not available on Windows\n+{\n+  let currentMemoryUsage = process.memoryUsage().arrayBuffers;\n+\n+  // We initialize a stream, but not start consuming it\n+  const randomNodeStream = new Readable({\n+    read(size) {\n+      randomBytes(size, (err, buffer) => {\n+        if (err) {\n+          // If an error occurs, emit an 'error' event\n+          this.emit('error', err);\n+          return;\n+        }\n+\n+        // Push the random bytes to the stream\n+        this.push(buffer);\n+      });\n+    }\n+  });\n+  // after 2 seconds, it'll get converted to web stream\n+  let randomWebStream;\n+\n+  // We check memory usage every second\n+  // since it's a stream, it shouldn't be higher than the chunk size\n+  const reportMemoryUsage = () => {\n+    const { arrayBuffers } = process.memoryUsage();\n+    currentMemoryUsage = arrayBuffers;\n+\n+    assert(currentMemoryUsage <= 256 * 1024 * 1024);\n+  };\n+  setInterval(reportMemoryUsage, 1000);\n+\n+  // after 1 second we use Readable.toWeb\n+  // memory usage should stay pretty much the same since it's still a stream\n+  setTimeout(() => {\n+    randomWebStream = Readable.toWeb(randomNodeStream, { type: 'bytes' });\n+  }, 1000);\n+\n+  // after 2 seconds we start consuming the stream\n+  // memory usage will grow, but the old chunks should be garbage-collected pretty quickly\n+  setTimeout(async () => {\n+\n+    const reader = randomWebStream.getReader({ mode: 'byob' });\n+\n+    let done = false;\n+    while (!done) {\n+      // Read a 16 bytes of data from the stream\n+      const result = await reader.read(new Uint8Array(16));\n+      done = result.done;\n+      // We consume the stream, but we don't do anything with the data\n+      // This is to ensure that the stream is being consumed\n+      // and that the memory usage is being reported correctly\n+    }\n+  }, 2000);\n+\n+  setTimeout(() => {\n+    // Test considered passed if we don't crash\n+    process.exit(0);\n+  }, 5000);",
        "comment_created_at": "2025-06-16T11:29:05+00:00",
        "comment_author": "seriousme",
        "comment_body": " I noticed that  test/parallel/test-stream-readable-to-web.js is doing a rather crude memory leak test. Which indeed does not make sense to replicate for this bytestream case as the new code only modifies the parameters for the creation of a new ReadableStream and does not touch any buffers itself.\r\n\r\nTherefore I replaced the memory leak test by a simple test to make sure that the bytestream works as intented. This test does not need timers at all. \r\n\r\nKind regards,\r\nHans",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160087455",
    "pr_number": 58664,
    "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
    "created_at": "2025-06-21T17:07:31+00:00",
    "commented_code": "+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+const assert = require('assert');\n+let count = 0;\n+\n+const nodeStream = new Readable({\n+  read(size) {\n+    if (this.destroyed) {\n+      return;\n+    }\n+    // Simulate a stream that pushes sequences of 16 bytes\n+    const buffer = Buffer.alloc(size);\n+    for (let i = 0; i < size; i++) {\n+      buffer[i] = count++ % 16;\n+    }\n+    this.push(buffer);\n+  }\n+});\n+\n+// Test validation of 'type' option\n+assert.throws(\n+  () => {\n+    Readable.toWeb(nodeStream, { type: 'wrong type' });\n+  },\n+  {\n+    code: 'ERR_INVALID_ARG_VALUE'\n+  }\n+);\n+\n+// Test normal operation with ReadableByteStream\n+const webStream = Readable.toWeb(nodeStream, { type: 'bytes' });\n+const reader = webStream.getReader({ mode: 'byob' });\n+\n+for (let i = 0; i < 1000; i++) {\n+  // Read 16 bytes of data from the stream\n+  const receive = new Uint8Array(16);\n+  reader.read(receive).then((result) => {\n+    // Verify the data received\n+    assert.strictEqual(result.value[7], 7);\n+    assert.strictEqual(result.value[15], 15);",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160087455",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
        "discussion_id": "2160087455",
        "commented_code": "@@ -0,0 +1,46 @@\n+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+const assert = require('assert');\n+let count = 0;\n+\n+const nodeStream = new Readable({\n+  read(size) {\n+    if (this.destroyed) {\n+      return;\n+    }\n+    // Simulate a stream that pushes sequences of 16 bytes\n+    const buffer = Buffer.alloc(size);\n+    for (let i = 0; i < size; i++) {\n+      buffer[i] = count++ % 16;\n+    }\n+    this.push(buffer);\n+  }\n+});\n+\n+// Test validation of 'type' option\n+assert.throws(\n+  () => {\n+    Readable.toWeb(nodeStream, { type: 'wrong type' });\n+  },\n+  {\n+    code: 'ERR_INVALID_ARG_VALUE'\n+  }\n+);\n+\n+// Test normal operation with ReadableByteStream\n+const webStream = Readable.toWeb(nodeStream, { type: 'bytes' });\n+const reader = webStream.getReader({ mode: 'byob' });\n+\n+for (let i = 0; i < 1000; i++) {\n+  // Read 16 bytes of data from the stream\n+  const receive = new Uint8Array(16);\n+  reader.read(receive).then((result) => {\n+    // Verify the data received\n+    assert.strictEqual(result.value[7], 7);\n+    assert.strictEqual(result.value[15], 15);",
        "comment_created_at": "2025-06-21T17:07:31+00:00",
        "comment_author": "jasnell",
        "comment_body": "Nit: you can use `deepStrictEqual` to compare the full `result` to an expectation",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160087636",
    "pr_number": 58664,
    "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
    "created_at": "2025-06-21T17:08:28+00:00",
    "commented_code": "+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+const assert = require('assert');\n+let count = 0;\n+\n+const nodeStream = new Readable({\n+  read(size) {\n+    if (this.destroyed) {\n+      return;\n+    }\n+    // Simulate a stream that pushes sequences of 16 bytes\n+    const buffer = Buffer.alloc(size);\n+    for (let i = 0; i < size; i++) {\n+      buffer[i] = count++ % 16;\n+    }\n+    this.push(buffer);\n+  }\n+});\n+\n+// Test validation of 'type' option\n+assert.throws(\n+  () => {\n+    Readable.toWeb(nodeStream, { type: 'wrong type' });\n+  },\n+  {\n+    code: 'ERR_INVALID_ARG_VALUE'\n+  }\n+);\n+\n+// Test normal operation with ReadableByteStream\n+const webStream = Readable.toWeb(nodeStream, { type: 'bytes' });\n+const reader = webStream.getReader({ mode: 'byob' });\n+\n+for (let i = 0; i < 1000; i++) {\n+  // Read 16 bytes of data from the stream\n+  const receive = new Uint8Array(16);\n+  reader.read(receive).then((result) => {",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160087636",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-byob.js",
        "discussion_id": "2160087636",
        "commented_code": "@@ -0,0 +1,46 @@\n+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+const assert = require('assert');\n+let count = 0;\n+\n+const nodeStream = new Readable({\n+  read(size) {\n+    if (this.destroyed) {\n+      return;\n+    }\n+    // Simulate a stream that pushes sequences of 16 bytes\n+    const buffer = Buffer.alloc(size);\n+    for (let i = 0; i < size; i++) {\n+      buffer[i] = count++ % 16;\n+    }\n+    this.push(buffer);\n+  }\n+});\n+\n+// Test validation of 'type' option\n+assert.throws(\n+  () => {\n+    Readable.toWeb(nodeStream, { type: 'wrong type' });\n+  },\n+  {\n+    code: 'ERR_INVALID_ARG_VALUE'\n+  }\n+);\n+\n+// Test normal operation with ReadableByteStream\n+const webStream = Readable.toWeb(nodeStream, { type: 'bytes' });\n+const reader = webStream.getReader({ mode: 'byob' });\n+\n+for (let i = 0; i < 1000; i++) {\n+  // Read 16 bytes of data from the stream\n+  const receive = new Uint8Array(16);\n+  reader.read(receive).then((result) => {",
        "comment_created_at": "2025-06-21T17:08:28+00:00",
        "comment_author": "jasnell",
        "comment_body": "The callback passed to the `then` should be wrapped with a `common.mustCall(...)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160088054",
    "pr_number": 58664,
    "pr_file": "test/parallel/test-stream-readable-to-web-termination-byob.js",
    "created_at": "2025-06-21T17:10:17+00:00",
    "commented_code": "+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+{\n+  const r = Readable.from([]);\n+  // Cancelling reader while closing should not cause uncaught exceptions\n+  r.on('close', () => reader.cancel());",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160088054",
        "repo_full_name": "nodejs/node",
        "pr_number": 58664,
        "pr_file": "test/parallel/test-stream-readable-to-web-termination-byob.js",
        "discussion_id": "2160088054",
        "commented_code": "@@ -0,0 +1,11 @@\n+'use strict';\n+require('../common');\n+const { Readable } = require('stream');\n+{\n+  const r = Readable.from([]);\n+  // Cancelling reader while closing should not cause uncaught exceptions\n+  r.on('close', () => reader.cancel());",
        "comment_created_at": "2025-06-21T17:10:17+00:00",
        "comment_author": "jasnell",
        "comment_body": "Wrap the callback in `common.mustCall(...)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156616511",
    "pr_number": 58762,
    "pr_file": "test/parallel/test-tap-yaml-date-serialization.js",
    "created_at": "2025-06-19T09:55:46+00:00",
    "commented_code": "+'use strict';\n+\n+const common = require('../common');\n+const assert = require('node:assert');\n+const { test } = require('node:test');\n+\n+// Test jsToYaml functionality for Date objects by testing the fix directly\n+test('jsToYaml should serialize Date objects correctly', () => {\n+  // Since jsToYaml is not exported, we'll test this by ensuring that our fix \n+  // prevents the Date object from being processed as a regular object with methods.\n+  // This test verifies the fix exists in the code.\n+  \n+  const tapReporterPath = require.resolve('../../lib/internal/test_runner/reporter/tap.js');\n+  const fs = require('fs');\n+  const tapReporterSource = fs.readFileSync(tapReporterPath, 'utf8');\n+  \n+  // Verify that the fix is present in the source code\n+  // The fix adds an early return after Date processing to prevent object enumeration\n+  assert(tapReporterSource.includes('return result; // Early return to prevent processing Date as object'),\n+         'TAP reporter should contain the Date serialization fix');\n+  \n+  // Verify that Date ISO conversion happens with the early return\n+  assert(tapReporterSource.includes('DatePrototypeToISOString(value)'),\n+         'Date processing should be present');\n+         \n+  // Verify the exact pattern: Date processing followed by early return\n+  const fixPattern = /DatePrototypeToISOString\\(value\\);[\\s\\S]*?return result; \\/\\/ Early return to prevent processing Date as object/;\n+  assert(fixPattern.test(tapReporterSource),\n+         'Date processing should be followed by early return to prevent object processing');",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2156616511",
        "repo_full_name": "nodejs/node",
        "pr_number": 58762,
        "pr_file": "test/parallel/test-tap-yaml-date-serialization.js",
        "discussion_id": "2156616511",
        "commented_code": "@@ -0,0 +1,30 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('node:assert');\n+const { test } = require('node:test');\n+\n+// Test jsToYaml functionality for Date objects by testing the fix directly\n+test('jsToYaml should serialize Date objects correctly', () => {\n+  // Since jsToYaml is not exported, we'll test this by ensuring that our fix \n+  // prevents the Date object from being processed as a regular object with methods.\n+  // This test verifies the fix exists in the code.\n+  \n+  const tapReporterPath = require.resolve('../../lib/internal/test_runner/reporter/tap.js');\n+  const fs = require('fs');\n+  const tapReporterSource = fs.readFileSync(tapReporterPath, 'utf8');\n+  \n+  // Verify that the fix is present in the source code\n+  // The fix adds an early return after Date processing to prevent object enumeration\n+  assert(tapReporterSource.includes('return result; // Early return to prevent processing Date as object'),\n+         'TAP reporter should contain the Date serialization fix');\n+  \n+  // Verify that Date ISO conversion happens with the early return\n+  assert(tapReporterSource.includes('DatePrototypeToISOString(value)'),\n+         'Date processing should be present');\n+         \n+  // Verify the exact pattern: Date processing followed by early return\n+  const fixPattern = /DatePrototypeToISOString\\(value\\);[\\s\\S]*?return result; \\/\\/ Early return to prevent processing Date as object/;\n+  assert(fixPattern.test(tapReporterSource),\n+         'Date processing should be followed by early return to prevent object processing');",
        "comment_created_at": "2025-06-19T09:55:46+00:00",
        "comment_author": "pmarchini",
        "comment_body": "This kind of test is way too fragile and white-box.\r\n\r\nA general suggestion (which also applies here): coupling a test with implementation details leads to tests that are not resistant against refactoring.  \r\nFurthermore, this test doesn‚Äôt check the actual output, but only that the code is present and must be changed.\r\n\r\n\r\nI would suggest adding a snapshot test in this case, as it covers only the behaviour without checking internal logic!",
        "pr_file_module": null
      },
      {
        "comment_id": "2156719512",
        "repo_full_name": "nodejs/node",
        "pr_number": 58762,
        "pr_file": "test/parallel/test-tap-yaml-date-serialization.js",
        "discussion_id": "2156616511",
        "commented_code": "@@ -0,0 +1,30 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('node:assert');\n+const { test } = require('node:test');\n+\n+// Test jsToYaml functionality for Date objects by testing the fix directly\n+test('jsToYaml should serialize Date objects correctly', () => {\n+  // Since jsToYaml is not exported, we'll test this by ensuring that our fix \n+  // prevents the Date object from being processed as a regular object with methods.\n+  // This test verifies the fix exists in the code.\n+  \n+  const tapReporterPath = require.resolve('../../lib/internal/test_runner/reporter/tap.js');\n+  const fs = require('fs');\n+  const tapReporterSource = fs.readFileSync(tapReporterPath, 'utf8');\n+  \n+  // Verify that the fix is present in the source code\n+  // The fix adds an early return after Date processing to prevent object enumeration\n+  assert(tapReporterSource.includes('return result; // Early return to prevent processing Date as object'),\n+         'TAP reporter should contain the Date serialization fix');\n+  \n+  // Verify that Date ISO conversion happens with the early return\n+  assert(tapReporterSource.includes('DatePrototypeToISOString(value)'),\n+         'Date processing should be present');\n+         \n+  // Verify the exact pattern: Date processing followed by early return\n+  const fixPattern = /DatePrototypeToISOString\\(value\\);[\\s\\S]*?return result; \\/\\/ Early return to prevent processing Date as object/;\n+  assert(fixPattern.test(tapReporterSource),\n+         'Date processing should be followed by early return to prevent object processing');",
        "comment_created_at": "2025-06-19T10:54:16+00:00",
        "comment_author": "Ronitsabhaya75",
        "comment_body": "Thanks for the excellent feedback! You're absolutely right about both points:\r\n\r\n## üîß **Mixed Date/Non-Date Edge Cases**\r\nI tested the scenarios where actual vs expected aren't both native Dates, and they work correctly with the fix:\r\n\r\n```javascript\r\n// Date vs String - shows clear distinction\r\nexpected: '2023-01-01T12:00:00.000Z'  // String (with quotes)\r\nactual: 2023-01-01T13:00:00.000Z      // Date (clean ISO)\r\n\r\n// Date vs Object - proper object enumeration vs clean Date\r\nexpected: { toISOString: [Function], valueOf: [Function] }\r\nactual: 2023-01-01T13:00:00.000Z\r\n```\r\n\r\nThe fix correctly handles all combinations because it only affects Date object serialization specifically.\r\n\r\n## üß™ **Replaced Fragile White-Box Test with Robust Behavioral Testing**\r\n\r\nYou're absolutely right that the original test was too fragile and implementation-coupled. I've completely rewritten the testing approach:\r\n\r\n**‚ùå Before** (fragile):\r\n```javascript\r\n// Checking implementation details - breaks on refactoring  \r\nassert(tapReporterSource.includes('return result; // Early return...'))\r\n```\r\n\r\n**‚úÖ After** (robust):\r\n- **`test/fixtures/test-runner/output/tap_date_serialization.js`** - Test scenarios with various Date combinations\r\n- **`test/fixtures/test-runner/output/tap_date_serialization.snapshot`** - Expected TAP output\r\n- **Added to `test/parallel/test-runner-output.mjs`** - Integrated with existing snapshot testing\r\n\r\nThis approach:\r\n- ‚úÖ Tests actual behavior, not implementation details\r\n- ‚úÖ Resistant to refactoring (tests TAP output format)\r\n- ‚úÖ Covers edge cases (Date vs Date, Date vs String, nested Dates)\r\n- ‚úÖ Validates that Date objects don't leak their methods/properties\r\n- ‚úÖ Follows Node.js testing patterns\r\n\r\nThe snapshot test ensures clean output like `expected: 2023-01-01T12:00:00.000Z` instead of verbose object dumps, which addresses the ISO string visibility concern too.",
        "pr_file_module": null
      }
    ]
  }
]