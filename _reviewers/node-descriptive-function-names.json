[
  {
    "discussion_id": "2143836010",
    "pr_number": 58087,
    "pr_file": "lib/internal/blocklist.js",
    "created_at": "2025-06-12T23:49:24+00:00",
    "commented_code": "return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n   }\n \n+  /*\n+  * @param {string[]} data\n+  * @example\n+  * const data = [\n+  *   \"Subnet: IPv4 192.168.1.0/24\",\n+  *   \"Address: IPv4 10.0.0.5\",\n+  *   \"Range: IPv4 192.168.2.1-192.168.2.10\",\n+  *   \"Range: IPv4 10.0.0.1-10.0.0.10\"\n+  * ];\n+  */\n+  // TODO: Add IPv6 support\n+  #parseIPInfo(data) {\n+    for (const item of data) {\n+      const subnetMatch = item.match(\n+        /Subnet: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})\\/(\\d{1,2})/,\n+      );\n+      if (subnetMatch) {\n+        const { 1: network, 2: prefix } = subnetMatch;\n+        this.addSubnet(network, NumberParseInt(prefix));\n+        continue;\n+      }\n+\n+      const addressMatch = item.match(/Address: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})/);\n+      if (addressMatch) {\n+        const { 1: address } = addressMatch;\n+        this.addAddress(address);\n+        continue;\n+      }\n+\n+      const rangeMatch = item.match(\n+        /Range: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})-(\\d{1,3}(?:\\.\\d{1,3}){3})/,\n+      );\n+      if (rangeMatch) {\n+        const { 1: start, 2: end } = rangeMatch;\n+        this.addRange(start, end);\n+        continue;\n+      }\n+    }\n+  }\n+  toJson() {",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2143836010",
        "repo_full_name": "nodejs/node",
        "pr_number": 58087,
        "pr_file": "lib/internal/blocklist.js",
        "discussion_id": "2143836010",
        "commented_code": "@@ -139,6 +143,55 @@ class BlockList {\n     return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n   }\n \n+  /*\n+  * @param {string[]} data\n+  * @example\n+  * const data = [\n+  *   \"Subnet: IPv4 192.168.1.0/24\",\n+  *   \"Address: IPv4 10.0.0.5\",\n+  *   \"Range: IPv4 192.168.2.1-192.168.2.10\",\n+  *   \"Range: IPv4 10.0.0.1-10.0.0.10\"\n+  * ];\n+  */\n+  // TODO: Add IPv6 support\n+  #parseIPInfo(data) {\n+    for (const item of data) {\n+      const subnetMatch = item.match(\n+        /Subnet: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})\\/(\\d{1,2})/,\n+      );\n+      if (subnetMatch) {\n+        const { 1: network, 2: prefix } = subnetMatch;\n+        this.addSubnet(network, NumberParseInt(prefix));\n+        continue;\n+      }\n+\n+      const addressMatch = item.match(/Address: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})/);\n+      if (addressMatch) {\n+        const { 1: address } = addressMatch;\n+        this.addAddress(address);\n+        continue;\n+      }\n+\n+      const rangeMatch = item.match(\n+        /Range: IPv4 (\\d{1,3}(?:\\.\\d{1,3}){3})-(\\d{1,3}(?:\\.\\d{1,3}){3})/,\n+      );\n+      if (rangeMatch) {\n+        const { 1: start, 2: end } = rangeMatch;\n+        this.addRange(start, end);\n+        continue;\n+      }\n+    }\n+  }\n+  toJson() {",
        "comment_created_at": "2025-06-12T23:49:24+00:00",
        "comment_author": "jasnell",
        "comment_body": "Let's name this method `toJSON` to that it works seamlessly with `JSON.stringify(...)` ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159345077",
    "pr_number": 57214,
    "pr_file": "lib/wasi.js",
    "created_at": "2025-06-20T16:30:12+00:00",
    "commented_code": "this[kInstance] = undefined;\n   }\n \n+  setupInstance(instance, memory) {",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2159345077",
        "repo_full_name": "nodejs/node",
        "pr_number": 57214,
        "pr_file": "lib/wasi.js",
        "discussion_id": "2159345077",
        "commented_code": "@@ -118,14 +114,30 @@ class WASI {\n     this[kInstance] = undefined;\n   }\n \n+  setupInstance(instance, memory) {",
        "comment_created_at": "2025-06-20T16:30:12+00:00",
        "comment_author": "guybedford",
        "comment_body": "This works great, I'd just make two suggestions - changing the name to `setupBindings()` or `finalizeBindings()` and having a `{ memory }` object for extensibility as the second argument.\r\n\r\n1. Formally speaking, we are not setting up the instance here, rather we are setting up the WASI host bindings themselves, closing the loop on the deferred instance bindings being passed back to WASI. Therefore I think `setupBindings()`, `finalizeBindings()` or `finalizeWASI()` or something like that might make more sense as a name than `setupInstance()`.\r\n2. Right now we just want to bind `memory`, but in theory there might be benefit in future binding other things like tables or function registrations from the instance. To give some flexibility it would help to have `setupBindings(instance, { memory = instance.exports.memory } = {})` as the signature.\r\n\r\nOtherwise the overall approach seems great to me though.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173746299",
    "pr_number": 58874,
    "pr_file": "lib/metrics.js",
    "created_at": "2025-06-29T12:45:22+00:00",
    "commented_code": "+/**\n+ * A metrics provider which reports to diagnostics_channel.\n+ *\n+ * # Metric Types\n+ *\n+ * - Counter: An increasing or decreasing value.\n+ * - Gauge: A snapshot of a single value in time.\n+ * - Meter: A number of events per interval.\n+ * - Timer: A duration in milliseconds.\n+ * - UniqueSet: A unique count of number of unique values seen.\n+ * - PeriodicGauge: A gauge which periodically updates its value by calling a function.\n+ *\n+ * # Exporting Metrics\n+ *\n+ * Several text format exporters are provided as streams:\n+ * - Statsd\n+ * - Dogstatsd\n+ * - Graphite\n+ * - Prometheus\n+ *\n+ * # TODO(qard):\n+ * - Histograms\n+ * - Distributions/Summaries\n+ */\n+\n+'use strict';\n+\n+const {\n+  ArrayPrototypeJoin,\n+  ArrayPrototypeMap,\n+  MathFloor,\n+  ObjectAssign,\n+  ObjectEntries,\n+  ObjectFreeze,\n+  ObjectKeys,\n+  SafeMap,\n+  SafeWeakSet,\n+  SymbolDispose,\n+} = primordials;\n+\n+const {\n+  codes: {\n+    ERR_INVALID_ARG_TYPE,\n+    ERR_INVALID_ARG_VALUE,\n+  },\n+} = require('internal/errors');\n+const { setInterval, clearInterval } = require('internal/timers');\n+\n+const {\n+  channel,\n+  hasChannel,\n+  subscribe,\n+  unsubscribe,\n+} = require('diagnostics_channel');\n+const { performance } = require('perf_hooks');\n+const { Transform } = require('stream');\n+\n+const newMetricChannel = channel('metrics:new');\n+\n+/**\n+ * Mix two metadata objects together.\n+ * @param {object} a The first metadata object.\n+ * @param {object} b The second metadata object.\n+ * @returns {object} The mixed metadata.\n+ * @private\n+ */\n+function mixMeta(a, b) {\n+  if (a === undefined) return b;\n+  if (b === undefined) return a;\n+  return ObjectAssign({}, a, b);\n+}\n+\n+/**\n+ * Represents a single reported metric.\n+ */\n+class MetricReport {\n+  /**\n+   * The type of metric.\n+   * @property {string} type\n+   */\n+\n+  /**\n+   * The name of the metric.\n+   * @property {string} name\n+   */\n+\n+  /**\n+   * The value of the metric.\n+   * @property {number} value\n+   */\n+\n+  /**\n+   * Additional metadata to include with the report.\n+   * @property {object} meta\n+   */\n+\n+  /**\n+   * Constructs a new metric report.\n+   * @param {string} type The type of metric.\n+   * @param {string} name The name of the metric.\n+   * @param {number} value The value of the metric.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  constructor(type, name, value, meta) {\n+    this.type = type;\n+    this.name = name;\n+    this.value = value;\n+    this.meta = meta;\n+    this.time = performance.now();\n+    ObjectFreeze(this);\n+  }\n+\n+  /**\n+   * Convert the metric report to a statsd-compatible string.\n+   * @returns {string} The statsd-formatted metric report.\n+   */\n+  toStatsd() {\n+    const { type, name, value } = this;\n+    return `${name}:${value}|${this.#statsdType(type)}`;\n+  }\n+\n+  /*\n+   * Convert the metric type to a statsd type.\n+   *\n+   * @param {string} type The metric type.\n+   * @returns {string} The statsd type.\n+   * @private\n+   */\n+  #statsdType(type) {\n+    return {\n+      counter: 'c',\n+      gauge: 'g',\n+      meter: 'm',\n+      periodicGauge: 'g',\n+      timer: 'ms',\n+      uniqueSet: 's',\n+    }[type];\n+  }\n+\n+  /**\n+   * Convert the metric report to a Dogstatsd-compatible string.\n+   * @returns {string} The Dogstatsd-formatted metric report.\n+   */\n+  toDogStatsd() {\n+    return `${this.toStatsd()}${this.#dogstatsdTags()}`;\n+  }\n+\n+  /*\n+   * Pack metadata into Dogstatsd-compatible tags.\n+   *\n+   * @returns {string} The packed metadata.\n+   * @private\n+   */\n+  #dogstatsdTags() {\n+    const entries = ObjectEntries(this.meta);\n+    const pairs = ArrayPrototypeMap(entries, ({ 0: k, 1: v }) => `${k}:${v}`);\n+    const tags = ArrayPrototypeJoin(pairs, ',');\n+    return tags.length ? `|${tags}` : '';\n+  }\n+\n+  /**\n+   * Convert the metric report to a graphite-compatible string.\n+   * @returns {string} The graphite-formatted metric report.\n+   */\n+  toGraphite() {\n+    const { name, value, time } = this;\n+    return `${name} ${value} ${MathFloor(time / 1000)}`;\n+  }\n+\n+  /**\n+   * Convert the metric report to a Prometheus-compatible string.\n+   * @returns {string} The Prometheus-formatted metric report.\n+   */\n+  toPrometheus() {\n+    const { name, value, time } = this;\n+    return `${name}${this.#prometheusLabels()} ${value} ${time}`;\n+  }\n+\n+  /*\n+   * Pack metadata into Prometheus-compatible labels.\n+   *\n+   * @returns {string} The packed metadata.\n+   * @private\n+   */\n+  #prometheusLabels() {\n+    const entries = ObjectEntries(this.meta);\n+    const pairs = ArrayPrototypeMap(entries, ({ 0: k, 1: v }) => `${k}=\"${v}\"`);\n+    const labels = ArrayPrototypeJoin(pairs, ',');\n+    return labels.length ? `{${labels}}` : '';\n+  }\n+}\n+\n+/**\n+ * Represents a metric which can be reported to.\n+ */\n+class Metric {\n+  #channel;\n+\n+  /**\n+   * The type of metric.\n+   * @property {string} type\n+   */\n+\n+  /**\n+   * The name of the metric.\n+   * @property {string} name\n+   */\n+\n+  /**\n+   * Additional metadata to include with the metric.\n+   * @property {object} meta\n+   */\n+\n+  /**\n+   * Constructs a new metric.\n+   * @param {string} type The type of metric.\n+   * @param {string} name The name of the metric.\n+   * @param {object} [meta] Additional metadata to include with the metric.\n+   */\n+  constructor(type, name, meta) {\n+    if (!metricTypeNames.includes(type)) {\n+      throw new ERR_INVALID_ARG_VALUE('type', type, wrongTypeErr);\n+    }\n+    if (typeof name !== 'string' || !name) {\n+      throw new ERR_INVALID_ARG_TYPE('name', ['string'], name);\n+    }\n+    if (meta !== undefined && typeof meta !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE('meta', ['object', 'undefined'], meta);\n+    }\n+\n+    this.type = type;\n+    this.name = name;\n+    this.meta = meta;\n+\n+    // Before acquiring the channel, check if it already exists.\n+    const exists = hasChannel(this.channelName);\n+    this.#channel = channel(this.channelName);\n+\n+    // If the channel is new and there are new channel subscribers,\n+    // publish the metric to the new metric channel.\n+    if (!exists && newMetricChannel.hasSubscribers) {\n+      newMetricChannel.publish(this);\n+    }\n+\n+    ObjectFreeze(this);\n+  }\n+\n+  /**\n+   * The channel name of the metric.\n+   * @property {string} channelName\n+   */\n+  get channelName() {\n+    return `metrics:${this.type}:${this.name}`;\n+  }\n+\n+  /**\n+   * The channel for this metric.\n+   * @property {Channel} channel\n+   */\n+  get channel() {\n+    return this.#channel;\n+  }\n+\n+  /**\n+   * Whether the metric should report values. If there are no subscribers,\n+   * metric preparation and report construction can be skipped.\n+   * @property {boolean} shouldReport\n+   */\n+  get shouldReport() {\n+    return this.#channel.hasSubscribers;\n+  }\n+\n+  /**\n+   * Report a value to the metric.\n+   * @param {number} value The value to report.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  report(value, meta) {\n+    // Skip report construction if there are no subscribers.\n+    if (!this.shouldReport) return;\n+    const report = new MetricReport(this.type, this.name, value,\n+                                    mixMeta(this.meta, meta));\n+    this.#channel.publish(report);\n+  }\n+}\n+\n+/**\n+ * Represents a snapshot of a value in time. Will report the value every time\n+ * reset() is called, or when applyDelta() is called with a non-zero value.\n+ */\n+class Gauge {\n+  /**\n+   * The metric to report to.\n+   * @property {Metric} metric\n+   */\n+\n+  /**\n+   * The value of the gauge.\n+   * @property {number} value\n+   */\n+\n+  /**\n+   * @param {Metric} metric The metric to report to.\n+   */\n+  constructor(metric) {\n+    if (!(metric instanceof Metric)) {\n+      throw new ERR_INVALID_ARG_TYPE('metric', ['Metric'], metric);\n+    }\n+    this.metric = metric;\n+    this.value = 0;\n+  }\n+\n+  /**\n+   * Set the gauge value.\n+   * @param {number} value The value to set the gauge to.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  reset(value = 0, meta) {\n+    this.value = value;\n+    this.metric.report(value, meta);\n+  }\n+\n+  /**\n+   * Apply a delta to the gauge.\n+   * @param {number} value The delta to apply to the gauge.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  applyDelta(value, meta) {\n+    this.reset(this.value + value, meta);\n+  }\n+}\n+\n+/**\n+ * Number of events per interval. This will report at every mark() call,\n+ * but will report an aggregate value if a sliding window of marks which\n+ * occurred within the interval period.\n+ */\n+class Meter extends Gauge {\n+  #window;\n+\n+  /**\n+   * The metric to report to.\n+   * @property {Metric} metric\n+   */\n+\n+  /**\n+   * The interval in milliseconds to aggregate marks over.\n+   * @property {number} interval\n+   */\n+\n+  /**\n+   * Construct a new meter.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {number} interval The interval in milliseconds to aggregate marks over.\n+   */\n+  constructor(metric, interval) {\n+    super(metric);\n+    if (typeof interval !== 'number' || interval <= 0) {\n+      throw new ERR_INVALID_ARG_TYPE('interval', ['number'], interval);\n+    }\n+    this.interval = interval;\n+    this.#window = [];\n+  }\n+\n+  /**\n+   * Mark an event in the meter.\n+   * @param {number} [n] The number of events to mark. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  mark(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    const now = performance.now();\n+    this.#window.push({ value: n, time: now });\n+\n+    let { value } = this;\n+    while (this.#window.length && (now - this.#window[0].time) > this.interval) {\n+      const cached = this.#window.shift();\n+      value -= cached.value;\n+    }\n+\n+    value += n;\n+    this.reset(value, meta);\n+  }\n+}\n+\n+/**\n+ * An increasing or decreasing value.\n+ */\n+class Counter extends Gauge {\n+  /**\n+   * Increment the counter. Negative values invert to positive.\n+   * @param {number} [n] The amount to increment the counter by. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  increment(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    this.applyDelta(n, meta);\n+  }\n+\n+  /**\n+   * Decrement the counter. Negative values invert to positive.\n+   * @param {number} [n] The amount to decrement the counter by. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  decrement(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    this.applyDelta(-n, meta);\n+  }\n+}\n+\n+/**\n+ * A floating point number which represents a length of time in milliseconds.\n+ */\n+class Timer extends Gauge {\n+  #meta;\n+\n+  /**\n+   * The start time of the timer.\n+   * @property {number} start\n+   */\n+\n+  /**\n+   * End time of timer. If undefined, timer is still running.\n+   * @property {number|undefined} end\n+   */\n+\n+  /**\n+   * Duration of timer in milliseconds. If undefined, timer is still running.\n+   * @property {number|undefined} duration\n+   */\n+\n+  /**\n+   * Construct a new timer.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  constructor(metric, meta) {\n+    super(metric);\n+    if (meta !== undefined && typeof meta !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE('meta', ['object', 'undefined'], meta);\n+    }\n+    this.#meta = meta;\n+\n+    this.start = performance.now();\n+    this.end = undefined;\n+    this.duration = undefined;\n+  }\n+\n+  /**\n+   * Additional metadata to include with the report.\n+   * @property {object} meta\n+   */\n+  get meta() {\n+    return mixMeta(this.metric.meta, this.#meta);\n+  }\n+\n+  /**\n+   * Stop the timer and report the duration.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   * @returns {number} The duration in milliseconds.\n+   */\n+  stop(meta) {\n+    if (this.end !== undefined) return;\n+    if (!this.metric.shouldReport) return;\n+    this.end = performance.now();\n+    this.duration = this.end - this.start;\n+    this.reset(this.duration, mixMeta(this.#meta, meta));\n+    return this.duration;\n+  }\n+\n+  /**\n+   * Support `using` syntax to automatically stop the timer when done.\n+   */\n+  [SymbolDispose]() {\n+    this.stop();\n+  }\n+}\n+\n+/**\n+ * A count of the number of unique values that have been seen.\n+ */\n+class UniqueSet extends Gauge {\n+  // Use a weak set to track unique values without retaining references.\n+  #seen = new SafeWeakSet();\n+\n+  /**\n+   * The number of unique values seen.\n+   * @property {number} count\n+   */\n+  count = 0;\n+\n+  /**\n+   * Add value to set. If value was not already present, report it.\n+   * @param {any} value The value to track in the set.\n+   * @param {object} meta Additional metadata to include with the report.\n+   */\n+  add(value, meta) {\n+    // If already seen, do nothing.\n+    if (this.#seen.has(value)) {\n+      return;\n+    }\n+\n+    this.count += 1;\n+    this.#seen.add(value);\n+    this.reset(this.count, meta);\n+  }\n+}\n+\n+/**\n+ * A gauge which periodically updates its value by calling a function and\n+ * setting the value to the result.\n+ */\n+class PeriodicGauge extends Gauge {\n+  #timer;\n+  #interval;\n+  #fn;\n+\n+  /**\n+   * Construct a new periodic gauge.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {number} interval The interval in milliseconds to update the gauge.\n+   * @param {Function} fn The function to call to update the gauge.\n+   */\n+  constructor(metric, interval, fn) {\n+    super(metric);\n+\n+    if (typeof interval !== 'number' || interval <= 0) {\n+      throw new ERR_INVALID_ARG_TYPE('interval', ['number'], interval);\n+    }\n+    if (typeof fn !== 'function') {\n+      throw new ERR_INVALID_ARG_TYPE('fn', ['function'], fn);\n+    }\n+\n+    this.#timer = undefined;\n+    this.#interval = interval;\n+    this.#fn = fn;\n+\n+    this.schedule();\n+  }\n+\n+  /**\n+   * Schedule the update timer.\n+   */\n+  schedule() {",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2173746299",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "lib/metrics.js",
        "discussion_id": "2173746299",
        "commented_code": "@@ -0,0 +1,848 @@\n+/**\n+ * A metrics provider which reports to diagnostics_channel.\n+ *\n+ * # Metric Types\n+ *\n+ * - Counter: An increasing or decreasing value.\n+ * - Gauge: A snapshot of a single value in time.\n+ * - Meter: A number of events per interval.\n+ * - Timer: A duration in milliseconds.\n+ * - UniqueSet: A unique count of number of unique values seen.\n+ * - PeriodicGauge: A gauge which periodically updates its value by calling a function.\n+ *\n+ * # Exporting Metrics\n+ *\n+ * Several text format exporters are provided as streams:\n+ * - Statsd\n+ * - Dogstatsd\n+ * - Graphite\n+ * - Prometheus\n+ *\n+ * # TODO(qard):\n+ * - Histograms\n+ * - Distributions/Summaries\n+ */\n+\n+'use strict';\n+\n+const {\n+  ArrayPrototypeJoin,\n+  ArrayPrototypeMap,\n+  MathFloor,\n+  ObjectAssign,\n+  ObjectEntries,\n+  ObjectFreeze,\n+  ObjectKeys,\n+  SafeMap,\n+  SafeWeakSet,\n+  SymbolDispose,\n+} = primordials;\n+\n+const {\n+  codes: {\n+    ERR_INVALID_ARG_TYPE,\n+    ERR_INVALID_ARG_VALUE,\n+  },\n+} = require('internal/errors');\n+const { setInterval, clearInterval } = require('internal/timers');\n+\n+const {\n+  channel,\n+  hasChannel,\n+  subscribe,\n+  unsubscribe,\n+} = require('diagnostics_channel');\n+const { performance } = require('perf_hooks');\n+const { Transform } = require('stream');\n+\n+const newMetricChannel = channel('metrics:new');\n+\n+/**\n+ * Mix two metadata objects together.\n+ * @param {object} a The first metadata object.\n+ * @param {object} b The second metadata object.\n+ * @returns {object} The mixed metadata.\n+ * @private\n+ */\n+function mixMeta(a, b) {\n+  if (a === undefined) return b;\n+  if (b === undefined) return a;\n+  return ObjectAssign({}, a, b);\n+}\n+\n+/**\n+ * Represents a single reported metric.\n+ */\n+class MetricReport {\n+  /**\n+   * The type of metric.\n+   * @property {string} type\n+   */\n+\n+  /**\n+   * The name of the metric.\n+   * @property {string} name\n+   */\n+\n+  /**\n+   * The value of the metric.\n+   * @property {number} value\n+   */\n+\n+  /**\n+   * Additional metadata to include with the report.\n+   * @property {object} meta\n+   */\n+\n+  /**\n+   * Constructs a new metric report.\n+   * @param {string} type The type of metric.\n+   * @param {string} name The name of the metric.\n+   * @param {number} value The value of the metric.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  constructor(type, name, value, meta) {\n+    this.type = type;\n+    this.name = name;\n+    this.value = value;\n+    this.meta = meta;\n+    this.time = performance.now();\n+    ObjectFreeze(this);\n+  }\n+\n+  /**\n+   * Convert the metric report to a statsd-compatible string.\n+   * @returns {string} The statsd-formatted metric report.\n+   */\n+  toStatsd() {\n+    const { type, name, value } = this;\n+    return `${name}:${value}|${this.#statsdType(type)}`;\n+  }\n+\n+  /*\n+   * Convert the metric type to a statsd type.\n+   *\n+   * @param {string} type The metric type.\n+   * @returns {string} The statsd type.\n+   * @private\n+   */\n+  #statsdType(type) {\n+    return {\n+      counter: 'c',\n+      gauge: 'g',\n+      meter: 'm',\n+      periodicGauge: 'g',\n+      timer: 'ms',\n+      uniqueSet: 's',\n+    }[type];\n+  }\n+\n+  /**\n+   * Convert the metric report to a Dogstatsd-compatible string.\n+   * @returns {string} The Dogstatsd-formatted metric report.\n+   */\n+  toDogStatsd() {\n+    return `${this.toStatsd()}${this.#dogstatsdTags()}`;\n+  }\n+\n+  /*\n+   * Pack metadata into Dogstatsd-compatible tags.\n+   *\n+   * @returns {string} The packed metadata.\n+   * @private\n+   */\n+  #dogstatsdTags() {\n+    const entries = ObjectEntries(this.meta);\n+    const pairs = ArrayPrototypeMap(entries, ({ 0: k, 1: v }) => `${k}:${v}`);\n+    const tags = ArrayPrototypeJoin(pairs, ',');\n+    return tags.length ? `|${tags}` : '';\n+  }\n+\n+  /**\n+   * Convert the metric report to a graphite-compatible string.\n+   * @returns {string} The graphite-formatted metric report.\n+   */\n+  toGraphite() {\n+    const { name, value, time } = this;\n+    return `${name} ${value} ${MathFloor(time / 1000)}`;\n+  }\n+\n+  /**\n+   * Convert the metric report to a Prometheus-compatible string.\n+   * @returns {string} The Prometheus-formatted metric report.\n+   */\n+  toPrometheus() {\n+    const { name, value, time } = this;\n+    return `${name}${this.#prometheusLabels()} ${value} ${time}`;\n+  }\n+\n+  /*\n+   * Pack metadata into Prometheus-compatible labels.\n+   *\n+   * @returns {string} The packed metadata.\n+   * @private\n+   */\n+  #prometheusLabels() {\n+    const entries = ObjectEntries(this.meta);\n+    const pairs = ArrayPrototypeMap(entries, ({ 0: k, 1: v }) => `${k}=\"${v}\"`);\n+    const labels = ArrayPrototypeJoin(pairs, ',');\n+    return labels.length ? `{${labels}}` : '';\n+  }\n+}\n+\n+/**\n+ * Represents a metric which can be reported to.\n+ */\n+class Metric {\n+  #channel;\n+\n+  /**\n+   * The type of metric.\n+   * @property {string} type\n+   */\n+\n+  /**\n+   * The name of the metric.\n+   * @property {string} name\n+   */\n+\n+  /**\n+   * Additional metadata to include with the metric.\n+   * @property {object} meta\n+   */\n+\n+  /**\n+   * Constructs a new metric.\n+   * @param {string} type The type of metric.\n+   * @param {string} name The name of the metric.\n+   * @param {object} [meta] Additional metadata to include with the metric.\n+   */\n+  constructor(type, name, meta) {\n+    if (!metricTypeNames.includes(type)) {\n+      throw new ERR_INVALID_ARG_VALUE('type', type, wrongTypeErr);\n+    }\n+    if (typeof name !== 'string' || !name) {\n+      throw new ERR_INVALID_ARG_TYPE('name', ['string'], name);\n+    }\n+    if (meta !== undefined && typeof meta !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE('meta', ['object', 'undefined'], meta);\n+    }\n+\n+    this.type = type;\n+    this.name = name;\n+    this.meta = meta;\n+\n+    // Before acquiring the channel, check if it already exists.\n+    const exists = hasChannel(this.channelName);\n+    this.#channel = channel(this.channelName);\n+\n+    // If the channel is new and there are new channel subscribers,\n+    // publish the metric to the new metric channel.\n+    if (!exists && newMetricChannel.hasSubscribers) {\n+      newMetricChannel.publish(this);\n+    }\n+\n+    ObjectFreeze(this);\n+  }\n+\n+  /**\n+   * The channel name of the metric.\n+   * @property {string} channelName\n+   */\n+  get channelName() {\n+    return `metrics:${this.type}:${this.name}`;\n+  }\n+\n+  /**\n+   * The channel for this metric.\n+   * @property {Channel} channel\n+   */\n+  get channel() {\n+    return this.#channel;\n+  }\n+\n+  /**\n+   * Whether the metric should report values. If there are no subscribers,\n+   * metric preparation and report construction can be skipped.\n+   * @property {boolean} shouldReport\n+   */\n+  get shouldReport() {\n+    return this.#channel.hasSubscribers;\n+  }\n+\n+  /**\n+   * Report a value to the metric.\n+   * @param {number} value The value to report.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  report(value, meta) {\n+    // Skip report construction if there are no subscribers.\n+    if (!this.shouldReport) return;\n+    const report = new MetricReport(this.type, this.name, value,\n+                                    mixMeta(this.meta, meta));\n+    this.#channel.publish(report);\n+  }\n+}\n+\n+/**\n+ * Represents a snapshot of a value in time. Will report the value every time\n+ * reset() is called, or when applyDelta() is called with a non-zero value.\n+ */\n+class Gauge {\n+  /**\n+   * The metric to report to.\n+   * @property {Metric} metric\n+   */\n+\n+  /**\n+   * The value of the gauge.\n+   * @property {number} value\n+   */\n+\n+  /**\n+   * @param {Metric} metric The metric to report to.\n+   */\n+  constructor(metric) {\n+    if (!(metric instanceof Metric)) {\n+      throw new ERR_INVALID_ARG_TYPE('metric', ['Metric'], metric);\n+    }\n+    this.metric = metric;\n+    this.value = 0;\n+  }\n+\n+  /**\n+   * Set the gauge value.\n+   * @param {number} value The value to set the gauge to.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  reset(value = 0, meta) {\n+    this.value = value;\n+    this.metric.report(value, meta);\n+  }\n+\n+  /**\n+   * Apply a delta to the gauge.\n+   * @param {number} value The delta to apply to the gauge.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  applyDelta(value, meta) {\n+    this.reset(this.value + value, meta);\n+  }\n+}\n+\n+/**\n+ * Number of events per interval. This will report at every mark() call,\n+ * but will report an aggregate value if a sliding window of marks which\n+ * occurred within the interval period.\n+ */\n+class Meter extends Gauge {\n+  #window;\n+\n+  /**\n+   * The metric to report to.\n+   * @property {Metric} metric\n+   */\n+\n+  /**\n+   * The interval in milliseconds to aggregate marks over.\n+   * @property {number} interval\n+   */\n+\n+  /**\n+   * Construct a new meter.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {number} interval The interval in milliseconds to aggregate marks over.\n+   */\n+  constructor(metric, interval) {\n+    super(metric);\n+    if (typeof interval !== 'number' || interval <= 0) {\n+      throw new ERR_INVALID_ARG_TYPE('interval', ['number'], interval);\n+    }\n+    this.interval = interval;\n+    this.#window = [];\n+  }\n+\n+  /**\n+   * Mark an event in the meter.\n+   * @param {number} [n] The number of events to mark. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  mark(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    const now = performance.now();\n+    this.#window.push({ value: n, time: now });\n+\n+    let { value } = this;\n+    while (this.#window.length && (now - this.#window[0].time) > this.interval) {\n+      const cached = this.#window.shift();\n+      value -= cached.value;\n+    }\n+\n+    value += n;\n+    this.reset(value, meta);\n+  }\n+}\n+\n+/**\n+ * An increasing or decreasing value.\n+ */\n+class Counter extends Gauge {\n+  /**\n+   * Increment the counter. Negative values invert to positive.\n+   * @param {number} [n] The amount to increment the counter by. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  increment(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    this.applyDelta(n, meta);\n+  }\n+\n+  /**\n+   * Decrement the counter. Negative values invert to positive.\n+   * @param {number} [n] The amount to decrement the counter by. Defaults to 1.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  decrement(n = 1, meta) {\n+    if (!this.metric.shouldReport) return;\n+\n+    if (typeof n === 'object') {\n+      meta = n;\n+      n = 1;\n+    }\n+\n+    this.applyDelta(-n, meta);\n+  }\n+}\n+\n+/**\n+ * A floating point number which represents a length of time in milliseconds.\n+ */\n+class Timer extends Gauge {\n+  #meta;\n+\n+  /**\n+   * The start time of the timer.\n+   * @property {number} start\n+   */\n+\n+  /**\n+   * End time of timer. If undefined, timer is still running.\n+   * @property {number|undefined} end\n+   */\n+\n+  /**\n+   * Duration of timer in milliseconds. If undefined, timer is still running.\n+   * @property {number|undefined} duration\n+   */\n+\n+  /**\n+   * Construct a new timer.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   */\n+  constructor(metric, meta) {\n+    super(metric);\n+    if (meta !== undefined && typeof meta !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE('meta', ['object', 'undefined'], meta);\n+    }\n+    this.#meta = meta;\n+\n+    this.start = performance.now();\n+    this.end = undefined;\n+    this.duration = undefined;\n+  }\n+\n+  /**\n+   * Additional metadata to include with the report.\n+   * @property {object} meta\n+   */\n+  get meta() {\n+    return mixMeta(this.metric.meta, this.#meta);\n+  }\n+\n+  /**\n+   * Stop the timer and report the duration.\n+   * @param {object} [meta] Additional metadata to include with the report.\n+   * @returns {number} The duration in milliseconds.\n+   */\n+  stop(meta) {\n+    if (this.end !== undefined) return;\n+    if (!this.metric.shouldReport) return;\n+    this.end = performance.now();\n+    this.duration = this.end - this.start;\n+    this.reset(this.duration, mixMeta(this.#meta, meta));\n+    return this.duration;\n+  }\n+\n+  /**\n+   * Support `using` syntax to automatically stop the timer when done.\n+   */\n+  [SymbolDispose]() {\n+    this.stop();\n+  }\n+}\n+\n+/**\n+ * A count of the number of unique values that have been seen.\n+ */\n+class UniqueSet extends Gauge {\n+  // Use a weak set to track unique values without retaining references.\n+  #seen = new SafeWeakSet();\n+\n+  /**\n+   * The number of unique values seen.\n+   * @property {number} count\n+   */\n+  count = 0;\n+\n+  /**\n+   * Add value to set. If value was not already present, report it.\n+   * @param {any} value The value to track in the set.\n+   * @param {object} meta Additional metadata to include with the report.\n+   */\n+  add(value, meta) {\n+    // If already seen, do nothing.\n+    if (this.#seen.has(value)) {\n+      return;\n+    }\n+\n+    this.count += 1;\n+    this.#seen.add(value);\n+    this.reset(this.count, meta);\n+  }\n+}\n+\n+/**\n+ * A gauge which periodically updates its value by calling a function and\n+ * setting the value to the result.\n+ */\n+class PeriodicGauge extends Gauge {\n+  #timer;\n+  #interval;\n+  #fn;\n+\n+  /**\n+   * Construct a new periodic gauge.\n+   * @param {Metric} metric The metric to report to.\n+   * @param {number} interval The interval in milliseconds to update the gauge.\n+   * @param {Function} fn The function to call to update the gauge.\n+   */\n+  constructor(metric, interval, fn) {\n+    super(metric);\n+\n+    if (typeof interval !== 'number' || interval <= 0) {\n+      throw new ERR_INVALID_ARG_TYPE('interval', ['number'], interval);\n+    }\n+    if (typeof fn !== 'function') {\n+      throw new ERR_INVALID_ARG_TYPE('fn', ['function'], fn);\n+    }\n+\n+    this.#timer = undefined;\n+    this.#interval = interval;\n+    this.#fn = fn;\n+\n+    this.schedule();\n+  }\n+\n+  /**\n+   * Schedule the update timer.\n+   */\n+  schedule() {",
        "comment_created_at": "2025-06-29T12:45:22+00:00",
        "comment_author": "jasnell",
        "comment_body": "For the `IntervalHistogram` (https://nodejs.org/docs/latest/api/perf_hooks.html#class-intervalhistogram-extends-histogram) we use `enable()` and `disable()`. Not critical but I'd prefer to keep the API names consistent.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182813302",
    "pr_number": 58942,
    "pr_file": "lib/internal/crypto/hash.js",
    "created_at": "2025-07-03T13:33:57+00:00",
    "commented_code": "const kState = Symbol('kState');\n const kFinalized = Symbol('kFinalized');\n \n+/**\n+ * @param {string} name\n+ */\n+function normalizeAlgorithm(name) {\n+  return StringPrototypeReplace(StringPrototypeToLowerCase(name), '-', '');\n+}\n+\n+const emitDeprecationWarning = getDeprecationWarningEmitter(",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2182813302",
        "repo_full_name": "nodejs/node",
        "pr_number": 58942,
        "pr_file": "lib/internal/crypto/hash.js",
        "discussion_id": "2182813302",
        "commented_code": "@@ -63,6 +66,25 @@ const LazyTransform = require('internal/streams/lazy_transform');\n const kState = Symbol('kState');\n const kFinalized = Symbol('kFinalized');\n \n+/**\n+ * @param {string} name\n+ */\n+function normalizeAlgorithm(name) {\n+  return StringPrototypeReplace(StringPrototypeToLowerCase(name), '-', '');\n+}\n+\n+const emitDeprecationWarning = getDeprecationWarningEmitter(",
        "comment_created_at": "2025-07-03T13:33:57+00:00",
        "comment_author": "aduh95",
        "comment_body": "nit\r\n```suggestion\r\nconst emitDeprecationWarningIfAlgoIsShake = getDeprecationWarningEmitter(\r\n```\r\nor\r\n```suggestion\r\nconst maybeEmitDeprecationWarning = getDeprecationWarningEmitter(\r\n```",
        "pr_file_module": null
      }
    ]
  }
]