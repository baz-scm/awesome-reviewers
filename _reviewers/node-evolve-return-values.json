[
  {
    "discussion_id": "2173770340",
    "pr_number": 58875,
    "pr_file": "doc/api/util.md",
    "created_at": "2025-06-29T13:58:46+00:00",
    "commented_code": "// Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\n\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\n\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2173770340",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-06-29T13:58:46+00:00",
        "comment_author": "jasnell",
        "comment_body": "I don't think the `enableHelpPrinting` here is a good idea. Instead, the return value of `parseArgs` should just be capable of returning the serialized help text. Allowing for something like,\r\n\r\n```\r\nconst result = parseArgs(...);\r\nconsole.log(result.printUsage());\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2174764495",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-06-30T10:36:16+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "Hey @jasnell So we wouldn't have this flag or anything checking `-h, --help` to print the help text internally?",
        "pr_file_module": null
      },
      {
        "comment_id": "2174782835",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-06-30T10:47:29+00:00",
        "comment_author": "jasnell",
        "comment_body": "We can have something, yes, but having these kinds of side effects on the constructor can be problematic",
        "pr_file_module": null
      },
      {
        "comment_id": "2178700073",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-01T23:02:20+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "Hey @jasnell I made some changes so that we have the serialized help text available in `printUsage`.\r\nI still kept `enableHelpPrinting` for now because with the `-h, --help` check, I can't think of another way to do this control when displaying the help text",
        "pr_file_module": null
      },
      {
        "comment_id": "2178711380",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-01T23:18:17+00:00",
        "comment_author": "ljharb",
        "comment_body": "Can't you key on the presence of help text, and `--help`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2182561891",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-03T11:37:24+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "It might actually be a good approach, it wasn't an option that already existed, so it probably wouldn't impact old users.\r\nWould it be valid to think that whenever someone uses a `--help` they would also like a general text at the beginning of the help output?",
        "pr_file_module": null
      },
      {
        "comment_id": "2183226258",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-03T16:34:18+00:00",
        "comment_author": "ljharb",
        "comment_body": "My expectation would be that anyone who is explicitly defining a `help` won't be providing help text, and we can also throw an error if both `help` and help text are defined.\r\n\r\nI can't conceive of a scenario where `foo --help` would not be desired to print help text and exit zero, for any foo.",
        "pr_file_module": null
      },
      {
        "comment_id": "2185230444",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-04T12:22:59+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "> My expectation would be that anyone who is explicitly defining a `help` won't be providing help text, and we can also throw an error if both `help` and help text are defined.\r\n\r\nHey, sorry, I didn't fully get it! Don't we want to general help text from args to replace the use of `enableHelpPrinting` boolean with `-h --help` to print + exit?\r\n\r\nSomething like:\r\n```mjs\r\nconst args = ['--help'];\r\nconst options = {\r\n  verbose: {\r\n    type: 'boolean',\r\n    short: 'v',\r\n    help: 'Enable verbose output',\r\n  },\r\n  help: {\r\n    type: 'boolean',\r\n    short: 'h',\r\n    help: 'Prints command line options',\r\n  },\r\n};\r\n\r\nparseArgs({\r\n  args,\r\n  options,\r\n  help: 'My CLI Tool'\r\n});\r\n// My CLI Tool\r\n//\r\n// -v, --verbose             Enable verbose output\r\n// -h, --help.               Prints command line options\r\n// exit\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2190887979",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-07T19:40:15+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "Hey, I removed `enableHelpPrinting` flag and now we're checking for `-h --help` with general help text provided to have the behavior of print + exit code",
        "pr_file_module": null
      },
      {
        "comment_id": "2190985296",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-07T20:47:21+00:00",
        "comment_author": "bakkot",
        "comment_body": "There is not agreement on this point, I think. @ljharb wants `parseArgs` to look for `--help` and do the printing itself. I read @jasnell above and @shadowspawn [here](https://github.com/nodejs/node/pull/58875#discussion_r2183929493) as preferring not to have that behavior, and instead just making it return the formatted text, with the user checking `--help` themselves.\r\n\r\nI am also in the camp of preferring not to do the automatic printing. Functions called called `parse` should not also be implementing other behavior. Besides, there's just too many cases where you want don't want that behavior. For example, if you're building a CLI app with [subcommands](https://gist.github.com/bakkot/d14826a356fa7ac7e5d9385c2c794432), you may be initially invoking `parseArgs` just to get the tokens array, in which case you _definitely_ don't want it adding any behavior other than parsing.\r\n\r\nI could live with the automatic printing if it was off by default, but it's hardly any more work for the user to define and check for `values.help` themselves, so personally I don't see much point. Either way, I think you'll need to get agreement on what behavior to have before this can go forward.",
        "pr_file_module": null
      },
      {
        "comment_id": "2191013481",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-07T21:07:34+00:00",
        "comment_author": "ljharb",
        "comment_body": "It's fine with me if it doesn't do the automatic printing - in that case, the presence of the help text should be sufficient to cause it to be returned whether `--help` is passed or not, and no extra config would be needed.",
        "pr_file_module": null
      },
      {
        "comment_id": "2191031323",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-07T21:22:41+00:00",
        "comment_author": "bakkot",
        "comment_body": "That sounds good to me!",
        "pr_file_module": null
      },
      {
        "comment_id": "2195469359",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-09T16:33:45+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "@bakkot Thanks for the mediation!\r\n\r\n@ljharb just to double check, when you say:\r\n> the presence of the help text should be sufficient to cause it to be returned whether `--help` is passed or not, and no extra config would be needed.\r\n\r\nDoes it mean what we have in the serialized help text available as it is now in `result.printUsage`, or something beyond that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2199573365",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2173770340",
        "commented_code": "@@ -2025,6 +2036,104 @@ console.log(values, positionals);\n // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n ```\n \n+### `parseArgs` help text\n+\n+`parseArgs` can generate and display help text for command-line options. To enable\n+this functionality, add `help` text to individual options and optionally provide\n+general help text via the `help` config property.\n+\n+```mjs\n+import { parseArgs } from 'node:util';\n+\n+const options = {\n+  verbose: {\n+    type: 'boolean',\n+    short: 'v',\n+    help: 'Enable verbose output',\n+  },\n+  file: {\n+    type: 'string',\n+    short: 'f',\n+    help: 'Input file path',\n+  },\n+  output: {\n+    type: 'string',\n+    help: 'Output directory',\n+  },\n+};\n+\n+// Get help text in result\n+const result = parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+});\n+\n+if (result.printUsage) {\n+  console.log(result.printUsage.join('\\n'));\n+  // Prints:\n+  // My CLI Tool v1.0\n+  //\n+  // Process files with various options.\n+  // -v, --verbose             Enable verbose output\n+  // -f, --file <arg>           Input file path\n+  // --output <arg>            Output directory\n+}\n+\n+// Or automatically print help and exit\n+parseArgs({\n+  options,\n+  help: 'My CLI Tool v1.0\\n\\nProcess files with various options.',\n+  enableHelpPrinting: true,\n+});",
        "comment_created_at": "2025-07-11T04:44:42+00:00",
        "comment_author": "shadowspawn",
        "comment_body": "> Does it mean what we have in the serialized help text available as it is now\r\n\r\nYes, I think so.\r\n\r\nSo if the author passes in some `help` strings, they get back something they can show the user themselves.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178710929",
    "pr_number": 58875,
    "pr_file": "doc/api/util.md",
    "created_at": "2025-07-01T23:17:33+00:00",
    "commented_code": "the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2178710929",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-01T23:17:33+00:00",
        "comment_author": "ljharb",
        "comment_body": "when would you want the help text present, but `--help` not to print the help?",
        "pr_file_module": null
      },
      {
        "comment_id": "2182551028",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-03T11:31:11+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "Hey, the idea was to check `-h --help` presence with `enableHelpPrinting` to have that behaviour of printing + exit, If we don't have both of them present, the formatted string will only be returned in `printUsage` with the general `help` args plus the help texts for each option that were made available, does that make sense?",
        "pr_file_module": null
      },
      {
        "comment_id": "2183217508",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-03T16:30:24+00:00",
        "comment_author": "ljharb",
        "comment_body": "Not really - the formatted string should always be returned with printUsage if help text is present, and `--help` should just always work when help text is present.",
        "pr_file_module": null
      },
      {
        "comment_id": "2183929493",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-03T23:30:46+00:00",
        "comment_author": "shadowspawn",
        "comment_body": "> when would you want the help text present, but `--help` not to print the help?\r\n\r\nWhen you are using a different option for displaying the help, such as with localised text.\r\n\r\nThe ability to specify a custom trigger option for the help would be full featured, but potentially excessive. I was thinking just the ability to get the help text returned allows the end-user to easily use their own option in the normal way and trigger the display of the help text themselves. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2184289134",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-04T04:11:31+00:00",
        "comment_author": "ljharb",
        "comment_body": "The user provided the help text - why would they need it back? Localization would be on their end, before invoking parseArgs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2185246302",
        "repo_full_name": "nodejs/node",
        "pr_number": 58875,
        "pr_file": "doc/api/util.md",
        "discussion_id": "2178710929",
        "commented_code": "@@ -1973,13 +1978,19 @@ changes:\n     the built-in behavior, from adding additional checks through to reprocessing\n     the tokens in different ways.\n     **Default:** `false`.\n+  * `help` {string} General help text to display at the beginning of help output.\n+  * `enableHelpPrinting` {boolean} When `true`, if any options have help text",
        "comment_created_at": "2025-07-04T12:30:27+00:00",
        "comment_author": "miguelmarcondesf",
        "comment_body": "> Not really - the formatted string should always be returned with printUsage if help text is present, and `--help` should just always work when help text is present.\r\n\r\nYes, I think I got confused in my explanation. Both features will only work if the help text is present, but for print+exit, we will have `-h --help` also provided as args.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135702323",
    "pr_number": 58453,
    "pr_file": "doc/api/events.md",
    "created_at": "2025-06-09T13:15:04+00:00",
    "commented_code": "The `'removeListener'` event is emitted _after_ the `listener` is removed.\n \n+### `emitter.addDisposableListener(eventName, listener[, options])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+> Stability: 1 - Experimental\n+\n+* `eventName` {string|symbol} The name of the event.\n+* `listener` {Function} The callback function\n+* `options` {Object}\n+  * `once` {boolean} If `true`, the listener will be removed after being called\n+    once.\n+* Returns: {Object} An object with a dispose method that will remove the listener.\n+  The function will also have a `Symbol.dispose` method so the function can\n+  be used with the `using` keyword.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2135702323",
        "repo_full_name": "nodejs/node",
        "pr_number": 58453,
        "pr_file": "doc/api/events.md",
        "discussion_id": "2135702323",
        "commented_code": "@@ -504,6 +504,33 @@ changes:\n \n The `'removeListener'` event is emitted _after_ the `listener` is removed.\n \n+### `emitter.addDisposableListener(eventName, listener[, options])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+> Stability: 1 - Experimental\n+\n+* `eventName` {string|symbol} The name of the event.\n+* `listener` {Function} The callback function\n+* `options` {Object}\n+  * `once` {boolean} If `true`, the listener will be removed after being called\n+    once.\n+* Returns: {Object} An object with a dispose method that will remove the listener.\n+  The function will also have a `Symbol.dispose` method so the function can\n+  be used with the `using` keyword.",
        "comment_created_at": "2025-06-09T13:15:04+00:00",
        "comment_author": "legendecas",
        "comment_body": "Returning an anonymous object in the API makes it hard to discover, like searching API interfaces with `[Symbol.dispose]` method. Additionally, the properties of the anynomous objects are not as clear as a named types. I'd prefer a named interface for the event listener disposable type.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2117990632",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T15:55:28+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```js\n+using resource = new MyResource();\n+await using asyncResource = new MyResource();\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+Also note that the `Symbol.dispose` and `Symbol.asyncDispose` methods are called\n+in both successful and exceptional exits from the scopes in which the using\n+keyword is used. This means that if an exception is thrown within the scope,\n+the disposal methods will still be called. However, when the disposal methods\n+are called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+1. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed.\n+1. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+1. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+1. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+      error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { dispoable: true })` would act differently in older versions",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2117990632",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2117990632",
        "commented_code": "@@ -0,0 +1,304 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```js\n+using resource = new MyResource();\n+await using asyncResource = new MyResource();\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+Also note that the `Symbol.dispose` and `Symbol.asyncDispose` methods are called\n+in both successful and exceptional exits from the scopes in which the using\n+keyword is used. This means that if an exception is thrown within the scope,\n+the disposal methods will still be called. However, when the disposal methods\n+are called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+1. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed.\n+1. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+1. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+1. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+      error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { dispoable: true })` would act differently in older versions",
        "comment_created_at": "2025-05-31T15:55:28+00:00",
        "comment_author": "LiviaMedeiros",
        "comment_body": "```suggestion\r\n`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118033840",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T16:24:40+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { dispoable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118033840",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118033840",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { dispoable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity",
        "comment_created_at": "2025-05-31T16:24:40+00:00",
        "comment_author": "dario-piotrowicz",
        "comment_body": "Could/should we also have a deprecation strategy/guideline in this case?\r\n\r\nFor example, `the introduction of disposable variants should whenever possible be accompanied by the deprecation of their non-disposable equivalent`?\r\n\r\nIn that way this could help not increasing the APIs surface that the user needs to be aware of and we need to maintain?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2118102443",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118033840",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { dispoable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity",
        "comment_created_at": "2025-05-31T17:41:08+00:00",
        "comment_author": "jasnell",
        "comment_body": "Hmm.. good question. I really don't know.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119291239",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-01T16:10:16+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2119291239",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2119291239",
        "commented_code": "@@ -0,0 +1,317 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.",
        "comment_created_at": "2025-06-01T16:10:16+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n   return type of an existing API is a breaking change.\r\n4. When an existing API signature does not lend itself easily to supporting making\r\n    the return value disposable and a new API needs to be introduced, it is worth\r\n    considering whether the existing API should be deprecated in favor of the new.\r\n    Deprecation is never a decision to be taken lightly, however, as it can have major\r\n    ecosystem impact.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126998245",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-04T16:25:09+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+4. When an existing API signature does not lend itself easily to supporting making\n+    the return value disposable and a new API needs to be introduced, it is worth\n+    considering whether the existing API should be deprecated in favor of the new.\n+    Deprecation is never a decision to be taken lightly, however, as it can have major\n+    ecosystem impact.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2126998245",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2126998245",
        "commented_code": "@@ -0,0 +1,329 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+4. When an existing API signature does not lend itself easily to supporting making\n+    the return value disposable and a new API needs to be introduced, it is worth\n+    considering whether the existing API should be deprecated in favor of the new.\n+    Deprecation is never a decision to be taken lightly, however, as it can have major\n+    ecosystem impact.",
        "comment_created_at": "2025-06-04T16:25:09+00:00",
        "comment_author": "tniessen",
        "comment_body": "```suggestion\r\n4. When an existing API signature does not lend itself easily to supporting making\r\n   the return value disposable and a new API needs to be introduced, it is worth\r\n   considering whether the existing API should be deprecated in favor of the new.\r\n   Deprecation is never a decision to be taken lightly, however, as it can have major\r\n   ecosystem impact.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2135712176",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-09T13:21:03+00:00",
    "commented_code": "+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2135712176",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-09T13:21:03+00:00",
        "comment_author": "legendecas",
        "comment_body": "I'd disagree with recommending returning an anonymous objects in an API design guideline. We should recommend structured API to improve comprehensiveness and discoverablity.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136048526",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-09T16:34:07+00:00",
        "comment_author": "bakkot",
        "comment_body": "@legendecas The problem is that lots of APIs need a bespoke disposable which isn't used for anything else, and adding a new class for every such API ends up littering lots of little classes all over the place. See e.g. https://github.com/nodejs/node/pull/58516 for such an API. I think anonymous objects are better than having a separate class for each such API.\r\n\r\n(But if you disagree, leave a comment on that PR as well.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2137954638",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-10T13:46:50+00:00",
        "comment_author": "jasnell",
        "comment_body": "This is likely something that can be best handled in documentation than code. For instance, in code we can have it be a fully anonymous object:\r\n\r\n```js\r\nreturn {\r\n  dispose() { ... },\r\n  [Symbol.dispose]() { this.dispose(); }\r\n}\r\n```\r\n\r\nWhile in documentation is can at least *appear* to be a named interface:\r\n\r\n```markdown\r\n### `foo()`\r\n\r\n* Returns {Disposable}\r\n\r\n### `Disposable`\r\n\r\n#### `disposable.dispose()`\r\n\r\n#### `disposable[Symbol.dispose]`\r\n```\r\n\r\nSo I'd suggest that we're talking about a documentation difference here, not necessarily a coding difference.",
        "pr_file_module": null
      },
      {
        "comment_id": "2137956269",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-10T13:47:35+00:00",
        "comment_author": "legendecas",
        "comment_body": "I think the question is more like how user anticipates with a disposable API. If an API returns an object, it should be easy to know what users can do with the object. \r\n\r\nhttps://github.com/nodejs/node/pull/58516 is an example that there are more properties than the documented `path` on the returned anonymous object, like `remove()`. It is not ideal to just say \"the returned object has property A, B, and C\". We should document every public API and its behavior clearly if possible.\r\n\r\nRegarding \"adding a new class for every such API ends up littering lots of little classes all over the place\", IMO this is a question on if it is worthwhile to add a new API to add disposable support. If an API already returns an object, there is no need to add a new disposable class for it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2160218178",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-22T04:24:30+00:00",
        "comment_author": "jasnell",
        "comment_body": "I'm not suggesting that we would leave things undocumented. I'm saying that we don't always need formal classes in the actual implementation. For some return values we can safely rely on documentation-only and leave the actual implementation as anonymous objects. We even have existing precedence for this in the current documentation. See, for instance, all of the \"Class\" documentations for Web Crypto operations here: https://nodejs.org/docs/latest/api/webcrypto.html#algorithm-parameters ... the things like `AesDerivedKeyParams` is documented as a class but, in reality, there is no actual class named `AesDerivedKeyParams` in the source.",
        "pr_file_module": null
      },
      {
        "comment_id": "2162907775",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2135712176",
        "commented_code": "@@ -0,0 +1,403 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Avoid, as much as possible, using both `Symbol.dispose` and `Symbl.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:",
        "comment_created_at": "2025-06-24T03:55:06+00:00",
        "comment_author": "jasnell",
        "comment_body": "I've expanded the document to include coverage of documentation of anonymous dispoables.",
        "pr_file_module": null
      }
    ]
  }
]