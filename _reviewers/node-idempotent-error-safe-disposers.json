[
  {
    "discussion_id": "2117975305",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T15:41:17+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```js\n+using resource = new MyResource();\n+await using asyncResource = new MyResource();\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+Also note that the `Symbol.dispose` and `Symbol.asyncDispose` methods are called\n+in both successful and exceptional exits from the scopes in which the using\n+keyword is used. This means that if an exception is thrown within the scope,\n+the disposal methods will still be called. However, when the disposal methods\n+are called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+1. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2117975305",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2117975305",
        "commented_code": "@@ -0,0 +1,304 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```js\n+using resource = new MyResource();\n+await using asyncResource = new MyResource();\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+Also note that the `Symbol.dispose` and `Symbol.asyncDispose` methods are called\n+in both successful and exceptional exits from the scopes in which the using\n+keyword is used. This means that if an exception is thrown within the scope,\n+the disposal methods will still be called. However, when the disposal methods\n+are called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+1. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed.",
        "comment_created_at": "2025-05-31T15:41:17+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n   closed. If there is no difference in disposing in success or exception contexts,\r\n   then separate disposal methods are unnecessary.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118027775",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T16:15:38+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118027775",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118027775",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can",
        "comment_created_at": "2025-05-31T16:15:38+00:00",
        "comment_author": "bakkot",
        "comment_body": "I'm not sure about this advice - for example, my intention is to add an `fs/promises` version of `mkdtempDisposable` to that PR, which would do an async `rm` on the directory. That seems fine? I've done the same thing manually with `try`/`finally` in the past.\r\n\r\nThis is largely equivalent to \"avoid `await` in `finally` blocks\". I would certainly advise people to be cautious about doing an `await` in a `finally`, but not necessarily to avoid it outright. Sometimes cleanup really is asynchronous and there's no avoiding it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2118102272",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118027775",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can",
        "comment_created_at": "2025-05-31T17:40:25+00:00",
        "comment_author": "jasnell",
        "comment_body": "We can definitely soften this but I think the guideline is correct. Most of the time disposal should be sync as much as possible. There are likely exceptions to that rule, of course. Will think about how to soften this a bit to say it's ok to use but should be intentional?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118036464",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T16:27:40+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118036464",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118036464",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.",
        "comment_created_at": "2025-05-31T16:27:40+00:00",
        "comment_author": "LiviaMedeiros",
        "comment_body": "Does this rule apply to resources that are initialized asynchronously but can be synchronously disposed of?\r\nFor example, let's say, we can implement [`filehandle.close()`](https://nodejs.org/api/fs.html#filehandleclose) in sync (and sane) way internally. Should we prefer `Symbol.dispose` in that case? From userspace perspective, I'd expect a rule of thumb that it should be\r\n```mjs\r\nusing handle = createDisposableResource();\r\n// or\r\nawait using handle = await createDisposableResource();\r\n// but usually not:\r\nusing handle = await createDisposableResource();\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2118057067",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118036464",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.",
        "comment_created_at": "2025-05-31T16:51:48+00:00",
        "comment_author": "bakkot",
        "comment_body": "I don't agree with that rule of thumb, fwiw - \"async creation, sync cleanup\" is a pretty common case. (Also \"sync creation, async cleanup\", although less commonly - web streams are an example.)\r\n\r\nAlso, any sync disposable can be used as an async disposable, so there's never a benefit to _only_ having `asyncDispose` when sync disposal is possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118212858",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T20:02:10+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118212858",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-05-31T20:02:10+00:00",
        "comment_author": "Flarna",
        "comment_body": "Why is it better to explicit dispose instead of relying on `using`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2118396550",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-05-31T23:32:12+00:00",
        "comment_author": "jasnell",
        "comment_body": "Consider the following two cases:\r\n\r\n```\r\n{\r\n  using foo = new MyDisposable();\r\n}\r\n\r\n{\r\n  using foo = new MyDisposable();\r\n  throw new Error('boom');\r\n}\r\n```\r\n\r\nThe disposer in each case is going to be called. Unfortunately, however, the disposer has no idea if there is an exception pending or not. Let's say our `MyDisposable` has two possible modes: one is a clean, graceful async shutdown, the second is a dirty, abrupt shutdown in case of an error. Since the disposer does not know whether it is being called with a pending exception or not we cannot safely assume within the disposer that a graceful async shutdown should be used. Instead, we have to assume it is an exception case.\r\n\r\n```js\r\nclass MyDisposer {\r\n  #closed = false;\r\n  #aborted = false;\r\n\r\n  close() {\r\n    if (this.#closed) return;\r\n    this.#closed = true;\r\n  }\r\n\r\n  abort() {\r\n    this.#aborted = true;\r\n    this.close();\r\n  }\r\n\r\n  [Symbol.dispose]() {\r\n    this.abort();\r\n  }\r\n}\r\n```\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2120298812",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-02T07:31:13+00:00",
        "comment_author": "Flarna",
        "comment_body": "For such cases I understand this.\r\nBut for these I question if ERM is really the right way to go. I think it's hard to reason that you shall use `using` but additionally you shall do disposal explicit. If you don't do it it's maybe a problem or maybe not.\r\nSo what is the benefit of ERM here?\r\nI think we should use it only if disposal just works and is correct. Doing it explicit should be more for optimization then correctness.\r\n\r\nThere are other cases where explicit disposal seems wrong to me. See your comment [here](https://github.com/nodejs/node/pull/58104#discussion_r2071582204) for the proposed `AsyncLocalStore#use()` API.\r\nFor that case sequence is important therefore any manual dispose adds risk of bugs.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2126244506",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T10:19:13+00:00",
        "comment_author": "legendecas",
        "comment_body": "Agree with @Flana here. This recommendation beats the benefit of `using` greatly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2126626738",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T13:36:33+00:00",
        "comment_author": "jasnell",
        "comment_body": "> ... But for these I question if ERM is really the right way to go...\r\n\r\nGenerally I think we should be leaving the decision up to users whether to use ERM or not. These guidelines are more about what we need to do for enablement. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2127175462",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T18:15:05+00:00",
        "comment_author": "Flarna",
        "comment_body": "If we write a guideline here how APIs exposed by node itself shall look like it's not really a user decision.\r\n\r\nMy understanding of current guideline is that e.g. `AsyncLocalStore#use()` shall return a disposable which offers an `exit()` API and doc for this shall instruct users to call it instead relying on automatic dispose.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2127186802",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T18:21:06+00:00",
        "comment_author": "bakkot",
        "comment_body": "I disagree with this guideline. It is fine and good to rely on `using` in almost all cases. The relatively rare kinds of object for which you need to do explicit cleanup for successful code paths should be explicitly documented as such; it should not be a general guideline.",
        "pr_file_module": null
      },
      {
        "comment_id": "2127267652",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T19:11:50+00:00",
        "comment_author": "pimterry",
        "comment_body": "Also disagree with this position. I think:\r\n\r\n* In general abort-instead-of-close seems like a potentially destructive operation (e.g. disposable with pending operations) so doing it unexpectedly is dangerous.\r\n* An exception being thrown in a `using` scope often _does not_ mean the disposable is in a bad state and can't be cleaned up: e.g. code reading a DB may well throw an exception because a result it needs couldn't be found, but that doesn't mean the DB connection resource is bad and shouldn't be tidily closed down. Assuming the disposable should be hard-shutdown by default isn't clearly correct to me even in actual exception scenarios, unless the disposable itself is internally broken somehow.\r\n* Most disposables I can imagine would be aware of their own internal errors before disposal I would expect though (I'd be interested in counter-examples) even if they can't catch the actual exception directly, so would be able to make a clean/dirty shutdown decision themselves.\r\n* Ecosystem discussion I have seen elsewhere all tends towards using `using` as the sole cleanup method - which seems to agree with impressions elsewhere here. We have to assume many (or even most) people who use `using` will do this.\r\n* If people do use `using` for normal cleanup, then defaulting to 'assume exception & abort' implies things like silently dropping pending operations, or whatever the other downsides of untidy cleanup are, when users aren't expecting that. This will cause big problems.\r\n\r\nGiven that though, I'd prefer to lean towards dispose being clean by default. Imo, for any APIs where it's impossible to detect whether a clean disposal is safe and there is an important clean/dirty shutdown distinction, imo we need to either fix that or never make the API disposable at all, because otherwise we're creating a footgun.",
        "pr_file_module": null
      },
      {
        "comment_id": "2127326267",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-04T19:49:46+00:00",
        "comment_author": "bakkot",
        "comment_body": "To pull on this a little more: iterables are an existing feature which are similar to disposables in that there is a protocol for closing them which the language invokes automatically. Specifically, any early exit from a `for of` will call the `.return()` method of an iterable. But it will _not_ provide the iterable any indication of whether the early exit was due to an error or an explicit `return` or `break` - there is a `.throw` method on some iterables (such as generators) which can be used to inject an error into the iterable, which could in principle have been used in this case, but it is not used here (or indeed by anything in the language). Errors in the _consumer_ of the iterable are an indication that the iterable should shut down, the same as any other way the consumer might no longer need the iterable, _not_ that the iterable should handle an error condition.\r\n\r\nAnd as far as I'm aware, this has been totally fine. The cases where an iterable or any other resource needs to handle errors in the consumer differently from other kinds of shutdown are sufficiently rare that to my knowledge it has literally never come up. Obviously there will be some cases where it does come up for disposables, but I don't think they warrant the focus these guidelines currently give them, and certainly they don't warrant a general rule against relying on `using` for clean shutdown.",
        "pr_file_module": null
      },
      {
        "comment_id": "2127812729",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-05T02:19:16+00:00",
        "comment_author": "jasnell",
        "comment_body": "Updated the language on this in the doc, please take another look!",
        "pr_file_module": null
      },
      {
        "comment_id": "2127852870",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-05T03:09:29+00:00",
        "comment_author": "bakkot",
        "comment_body": "New wording is much better, thanks.\r\n\r\nI think it might benefit from being more explicit that we're talking about errors _in the consumer_, and errors _in the object_ should be handled by having try/catch within the object's methods. So like:\r\n\r\n> Disposers should assume that they may be called due to an exception in the consumer. (Exceptions in the object itself should be tracked by the object.) As such, if the object has not been explicitly closed when the disposal method is called, the object should be disposed as if an exception had occurred in the consumer. For instance, [...]\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2137758344",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118212858",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();",
        "comment_created_at": "2025-06-10T12:24:09+00:00",
        "comment_author": "Flarna",
        "comment_body": "Agree, new wording is much better. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2118407291",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-05-31T23:45:33+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2118407291",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2118407291",
        "commented_code": "@@ -0,0 +1,307 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+langauge in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.\n+",
        "comment_created_at": "2025-05-31T23:45:33+00:00",
        "comment_author": "Renegade334",
        "comment_body": "This is probably worth explicitly stating (wording up for grabs):\r\n\r\n```suggestion\r\n6. Asynchronous disposers, by definition, are able to yield to other tasks\r\n   while waiting for their disposal task(s) to complete. This means that, as a\r\n   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\r\n   must `await` at least one asynchronous disposal task. If either of these\r\n   criteria is not met, then the disposer is actually a synchronous disposer in\r\n   disguise, and will block the execution thread until it returns; such a\r\n   disposer should instead be declared using `Symbol.dispose`.\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119281999",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-01T16:03:29+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2119281999",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2119281999",
        "commented_code": "@@ -0,0 +1,309 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate.",
        "comment_created_at": "2025-06-01T16:03:29+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n   be synchronous and immediate. Avoiding async disposal is not always possible,\r\n   however, as some types of disposable objects require asynchronous cleanup.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119294949",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-01T16:13:11+00:00",
    "commented_code": "+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+4. When an existing API signature does not lend itself easily to supporting making\n+    the return value disposable and a new API needs to be introduced, it is worth\n+    considering whether the existing API should be deprecated in favor of the new.\n+    Deprecation is never a decision to be taken lightly, however, as it can have major\n+    ecosystem impact.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();\n+    return;\n+  }\n+  // do other stuff\n+  res.close();\n+}\n+```",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2119294949",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2119294949",
        "commented_code": "@@ -0,0 +1,322 @@\n+# Explicit Resource Management (ERM) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is strongly recommended to just generally avoid\n+   use of `Symbol.asyncDispose` as much as possible. Asynchronous disposal can\n+   lead delaying the handling of exceptions and can make it difficult to\n+   reason about the state of the object while the disposal is in progress and\n+   is often an anti-pattern. Disposal in an exception context should always\n+   be synchronous and immediate. Avoiding async disposal is not always possible,\n+   however, as some types of disposable objects require asynchronous cleanup.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+\n+### Example Disposable Object\n+\n+```js\n+class MyDisposableResource {\n+  constructor() {\n+    this.closed = false;\n+  }\n+\n+  doSomething() {\n+    if (maybeShouldThrow()) {\n+      throw new Error('Something went wrong');\n+    }\n+  }\n+\n+  close() {\n+    // Gracefully close the resource.\n+    if (this.closed) return;\n+    this.closed = true;\n+    console.log('Resource closed');\n+  }\n+\n+  abort(maybeError) {\n+    // Abort the resource, optionally with an exception. Calling this\n+    // method multiple times should not cause any issues or additional\n+    // side effects.\n+    if (this.closed) return;\n+    this.closed = true;\n+    if (maybeError) {\n+      console.error('Resource aborted due to error:', maybeError);\n+    } else {\n+      console.log('Resource aborted');\n+    }\n+  }\n+\n+  [Symbol.dispose]() {\n+    // Note that when this is called, we cannot pass any pending\n+    // exceptions to the abort method because we do not know if\n+    // there is a pending exception or not.\n+    this.abort();\n+  }\n+}\n+```\n+\n+Then in use:\n+\n+```js\n+{\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+}\n+```\n+\n+Here, if an error is thrown in the `doSomething()` method, the `Symbol.dispose`\n+method will still be called when the block exits, ensuring that the resource is\n+disposed of properly using the `abort()` method. If no error is thrown, the\n+`close()` method is called explicitly to gracefully close the resource. When the\n+block exits, the `Symbol.dispose` method is still called but it will be a non-op\n+since the resource has already been closed.\n+\n+To deal with errors that may occur during disposal, it is necessary to wrap\n+the disposal block in a try-catch:\n+\n+```js\n+try {\n+  using resource = new MyDisposableResource();\n+  // Do something with the resource that might throw an error\n+  resource.doSomething();\n+  resource.close();\n+} catch (error) {\n+  // Error might be the actual error thrown in the block, or might\n+  // be a SupressedError if an error was thrown during disposal and\n+  // there was a pending exception already.\n+  if (error instanceof SuppressedError) {\n+    console.error('An error occurred during disposal masking pending error:',\n+                  error.error, error.suppressed);\n+  } else {\n+    console.error('An error occurred:', error);\n+  }\n+}\n+```\n+\n+## Guidelines for Introducing ERM into Existing APIs\n+\n+Introducing ERM capabilities into existing APIs can be tricky.\n+\n+The best way to understand the issues is to look at a real world example. PR\n+[58516](https://github.com/nodejs/node/pull/58516) is a good case. This PR\n+sought to introduce ERM capabilities into the `fs.mkdtemp` API such that a\n+temporary directory could be created and automatically disposed of when the\n+scope in which it was created exited. However, the existing implementation of\n+the `fs.mkdtemp` API returns a string value that cannot be made disposable.\n+There are also sync, callback, and promise-based variations of the existing\n+API that further complicate the situation.\n+\n+In the initial proposal, the `fs.mkdtemp` API was changed to return an object\n+that implements the `Symbol.dispose` method but only if a specific option is\n+provided. This would mean that the return value of the API would become\n+polymorphic, returning different types based on how it was called. This adds\n+a lot of complexity to the API and makes it difficult to reason about the\n+return value. It also makes it difficult to programmatically detect whether\n+the version of the API being used supports ERM capabilities or not. That is,\n+`fs.mkdtemp('...', { disposable: true })` would act differently in older versions\n+of Node.js than in newer versions with no way to detect this at runtime other\n+than to inspect the return value.\n+\n+Some APIs that already return object that can be made disposable do not have\n+this kind of issue. For example, the `setTimeout` API in Node.js returns an\n+object that implements the `Symbol.dispose` method. This change was made without\n+much fanfare because the return value of the API was already an object.\n+\n+So, some APIs can be made disposable easily without any issues while others\n+require more thought and consideration. The following guidelines can help\n+when introducing ERM capabilities into existing APIs:\n+\n+1. Avoid polymorphic return values: If an API already returns a value that\n+   can be made disposable and it makes sense to make it disposable, do so. Do\n+   not, however, make the return value polymorphic determined by an option\n+   passed into the API.\n+2. Introduce new API variants that are ERM capable: If an existing API\n+   cannot be made disposable without changing the return type or making it\n+   polymorphic, consider introducing a new API variant that is ERM capable.\n+   For example, `fs.mkdtempDisposable` could be introduced to return a\n+   disposable object while the existing `fs.mkdtemp` API continues to return\n+   a string. Yes, it means more APIs to maintain but it avoids the complexity\n+   and confusion of polymorphic return values.\n+3. If adding a new API variant is not ideal, remember that changing the\n+   return type of an existing API is a breaking change.\n+4. When an existing API signature does not lend itself easily to supporting making\n+    the return value disposable and a new API needs to be introduced, it is worth\n+    considering whether the existing API should be deprecated in favor of the new.\n+    Deprecation is never a decision to be taken lightly, however, as it can have major\n+    ecosystem impact.\n+\n+## Guidelines for using disposable objects\n+\n+Because disposable objects can be disposed of at any time, it is important\n+to be careful when using them. Here are some guidelines for using disposable:\n+\n+1. Never use `using` or `await using` with disposable objects that you\n+   do not own. For instance, the following code is problematic if you\n+   are not the owner of `someObject`:\n+\n+```js\n+function foo(someObject) {\n+  using resource = someObject;\n+}\n+```\n+\n+The reason this is problematic is that the `using` statement will\n+call the `Symbol.dispose` method on `someObject` when the block exits,\n+but you do not control the lifecycle of `someObject`. If `someObject`\n+is disposed of, it may lead to unexpected behavior in the rest of the\n+code that called the `foo` function.\n+\n+2. Always explicitly dispose of objects in successful code paths, including\n+   early returns. For example:\n+\n+```js\n+function foo() {\n+  using res = new MyDisposableResource();\n+  if (someCondition) {\n+    // Early return, ensure the resource is disposed of\n+    res.close();\n+    return;\n+  }\n+  // do other stuff\n+  res.close();\n+}\n+```",
        "comment_created_at": "2025-06-01T16:13:11+00:00",
        "comment_author": "jasnell",
        "comment_body": "````suggestion\r\n```\r\n\r\nThis is because of the fact that, when the disposer is called, it has no way\r\nof knowing if there is a pending exception or not and it is generally safest\r\nto assume that it is being called in an exceptional state. While some types\r\nof disposable objects make no differentiation between dispose in success\r\nand dispose in exception cases, those that do otherwise have no way of\r\ndifferentiating the conditions from within the disposer itself.\r\n````",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2127329621",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-04T19:52:14+00:00",
    "commented_code": "+# Explicit Resource Management Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2127329621",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2127329621",
        "commented_code": "@@ -0,0 +1,329 @@\n+# Explicit Resource Management Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using ERM in the Node.js\n+project -- specifically, guidelines around how to make objects disposable and\n+how to introduce ERM capabilities into existing APIs.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MyResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of ERM makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, ERM does not imply ownership of the object. It\n+is not a form of RAII (Resource Acquisition Is Initialization) as seen in some\n+other languages and there is no notion of exclusive ownership of the object.\n+A disposable object can become disposed at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the using keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context in which they were called. These\n+methods will not receive any information about the exception that was thrown\n+or whether an exception was thrown at all. This means that it is safest to\n+assume that the disposal methods will be called in a context where the object\n+may not be in a valid state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, that\n+   the object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. Disposers may throw their own exceptions but this is not recommended.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown. It is, however, not possible to\n+   completely prevent exceptions from being thrown in the disposal methods\n+   so this guideline is more of a recommendation than a hard rule.",
        "comment_created_at": "2025-06-04T19:52:14+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n3. It is recommended to avoid throwing errors within disposers.\r\n   If a disposer throws an exception while there is another pending\r\n   exception, then both exceptions will be wrapped in a `SupressedError`\r\n   that masks both. This makes it difficult to understand the context\r\n   in which the exceptions were thrown.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160218739",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-22T04:27:53+00:00",
    "commented_code": "+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Because the disposal process is strictly ordered, there is an intrinsic\n+   expectation that all tasks performed by a single disposer are fully complete\n+   at the point that the disposer returns. This means, for example, that\n+   \"callback-style\" APIs must not be invoked within a disposer, unless they are\n+   promisified and awaited. Any Promise created within a disposer must be\n+   awaited, to ensure its resolution prior to the disposer returning.\n+8. Avoid, as much as possible, using both `Symbol.dispose` and `Symbol.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  #disposed = false;\n+  dispose() {\n+    if (this.#disposed) return;\n+    this.#disposed = true;\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:\n+\n+```js\n+function getDisposable() {\n+  return {\n+    [Symbol.dispose]() {\n+      console.log('Resource disposed');\n+    },\n+  };",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2160218739",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2160218739",
        "commented_code": "@@ -0,0 +1,410 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this is mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that it is being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SupressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should delegate to\n+   these explicit disposal methods.\n+5. Because it is safest to assume that the disposal method will be called\n+   in an exception context, it is generally recommended to prefer use of\n+   `Symbol.dispose` over `Symbol.asyncDispose` when possible. Asynchronous\n+   disposal can lead delaying the handling of exceptions and can make it\n+   difficult to reason about the state of the object while the disposal is\n+   in progress. Disposal in an exception context is preferably synchronous\n+   and immediate. That said, for some types of objects async disposal is not\n+   avoidable.\n+6. Asynchronous disposers, by definition, are able to yield to other tasks\n+   while waiting for their disposal task(s) to complete. This means that, as a\n+   minimum, a `Symbol.asyncDispose` method must be an `async` function, and\n+   must `await` at least one asynchronous disposal task. If either of these\n+   criteria is not met, then the disposer is actually a synchronous disposer in\n+   disguise, and will block the execution thread until it returns; such a\n+   disposer should instead be declared using `Symbol.dispose`.\n+7. Because the disposal process is strictly ordered, there is an intrinsic\n+   expectation that all tasks performed by a single disposer are fully complete\n+   at the point that the disposer returns. This means, for example, that\n+   \"callback-style\" APIs must not be invoked within a disposer, unless they are\n+   promisified and awaited. Any Promise created within a disposer must be\n+   awaited, to ensure its resolution prior to the disposer returning.\n+8. Avoid, as much as possible, using both `Symbol.dispose` and `Symbol.asyncDispose`\n+   in the same object. This can make it difficult to reason about which method\n+   will be called in a given context and could lead to unexpected behavior or\n+   subtle bugs. This is not a firm rule, however. Sometimes it may make sense\n+   to define both but likely not.\n+\n+### Example Disposable Objects\n+\n+A disposable object can be quite simple:\n+\n+```js\n+class MyResource {\n+  #disposed = false;\n+  dispose() {\n+    if (this.#disposed) return;\n+    this.#disposed = true;\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{ using myDisposable = new MyResource(); }\n+```\n+\n+Or even fully anonymous objects:\n+\n+```js\n+function getDisposable() {\n+  return {\n+    [Symbol.dispose]() {\n+      console.log('Resource disposed');\n+    },\n+  };",
        "comment_created_at": "2025-06-22T04:27:53+00:00",
        "comment_author": "jasnell",
        "comment_body": "```suggestion\r\n  let disposed = false;\r\n  return {\r\n    dispose() {\r\n      if (disposed) return;\r\n      diposed = true;\r\n      console.log('Resource disposed');\r\n    }\r\n    [Symbol.dispose]() {\r\n      this.dispose();\r\n    },\r\n  };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163596975",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-24T10:43:19+00:00",
    "commented_code": "+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2163596975",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2163596975",
        "commented_code": "@@ -0,0 +1,453 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+There is a significant caveat to this document, however. Explicit resource\n+management is brand new and there is not a body of experience to draw from",
        "comment_created_at": "2025-06-24T10:43:19+00:00",
        "comment_author": "Renegade334",
        "comment_body": "Personal preference, but this feels like it could be less dramatic.\r\n\r\n```suggestion\r\nThe caveat to this guidance is that explicit resource management is a brand new\r\nlanguage feature, and there is not an existing body of experience to draw from\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166188903",
    "pr_number": 58526,
    "pr_file": "doc/contributing/erm-guidelines.md",
    "created_at": "2025-06-25T08:53:42+00:00",
    "commented_code": "+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+The caveat to this guidance is that explicit resource management is a brand new\n+language feature, and there is not an existing body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this in mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that they are being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SuppressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should then invoke\n+   these explicit disposal methods in an idempotent manner.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2166188903",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2166188903",
        "commented_code": "@@ -0,0 +1,454 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+The caveat to this guidance is that explicit resource management is a brand new\n+language feature, and there is not an existing body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this in mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that they are being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SuppressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should then invoke\n+   these explicit disposal methods in an idempotent manner.",
        "comment_created_at": "2025-06-25T08:53:42+00:00",
        "comment_author": "LiviaMedeiros",
        "comment_body": "Being pedantic here...\r\n1. The \"explicit disposal methods\" sounds incorrect in this context. Maybe \"named disposal methods\", or \"conventional disposal methods\"?\r\n\r\n2. Nothing stops the userland code from calling `[Symbol.dispose]()` directly, so technically implementing an ERM disposer is enough, and adding a string-named method sounds like an unnecessary code duplication.\r\n\r\nAlso this *slightly* contradicts with the statement from above:\r\n> Importantly, it is necessary to understand that the design of using makes it possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose` methods directly, outside of the using or await using statements.\r\n\r\n<hr />\r\n\r\nThus said, I agree with this recommendation but I think this whole part should be reworded. It must be clear that this is simply a recommended best practice, and it should provide the rationale behind it.\r\n\r\nThe issue is that if userland is forced to call ERM disposers directly, it would hurt readability and obscure debugging in case of error: people should always see `[Symbol.dispose]()` in their stack trace if `using` was used, and conventional method otherwise.\r\n\r\nTherefore, it's Node.js's responsibility to provide conventional method, and maybe even highlight in the API docs that for direct calls it's preferable over ERM disposers.",
        "pr_file_module": null
      },
      {
        "comment_id": "2173729073",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2166188903",
        "commented_code": "@@ -0,0 +1,454 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+The caveat to this guidance is that explicit resource management is a brand new\n+language feature, and there is not an existing body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this in mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that they are being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SuppressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should then invoke\n+   these explicit disposal methods in an idempotent manner.",
        "comment_created_at": "2025-06-29T11:39:27+00:00",
        "comment_author": "jasnell",
        "comment_body": "Hmm.. I'm not sure how best to change this to address your comment here. Would you mind if we push any update on this one to another edit PR?",
        "pr_file_module": null
      },
      {
        "comment_id": "2173741886",
        "repo_full_name": "nodejs/node",
        "pr_number": 58526,
        "pr_file": "doc/contributing/erm-guidelines.md",
        "discussion_id": "2166188903",
        "commented_code": "@@ -0,0 +1,454 @@\n+# Explicit Resource Management (`using`) Guidelines\n+\n+Explicit Resource Management is a capability that was introduced to the JavaScript\n+language in 2025. It provides a way of marking objects as disposable resources such\n+that the JavaScript engine will automatically invoke disposal methods when the\n+object is no longer in scope. For example:\n+\n+```js\n+class MyResource {\n+  dispose() {\n+    console.log('Resource disposed');\n+  }\n+\n+  [Symbol.dispose]() {\n+    this.dispose();\n+  }\n+}\n+\n+{\n+  using resource = new MyResource();\n+  // When this block exits, the `Symbol.dispose` method will be called\n+  // automatically by the JavaScript engine.\n+}\n+```\n+\n+This document outlines some specific guidelines for using explicit resource\n+management in the Node.js project -- specifically, guidelines around how to\n+make objects disposable and how to introduce the new capabilities into existing\n+APIs.\n+\n+The caveat to this guidance is that explicit resource management is a brand new\n+language feature, and there is not an existing body of experience to draw from\n+when writing these guidelines. The points outlined here are based on the\n+current understanding of how the mechanism works and how it is expected to\n+be used. As such, these guidelines may change over time as more experience\n+is gained with explicit resource management in Node.js and the ecosystem.\n+It is always a good idea to check the latest version of this document, and\n+more importantly, to suggest changes to it based on evolving understanding,\n+needs, and experience.\n+\n+## Some background\n+\n+Objects can be made disposable by implementing either, or both, the\n+`Symbol.dispose` and `Symbol.asyncDispose` methods:\n+\n+```js\n+class MySyncResource {\n+  [Symbol.dispose]() {\n+    // Synchronous disposal logic\n+  }\n+}\n+\n+class MyAsyncDisposableResource {\n+  async [Symbol.asyncDispose]() {\n+    // Asynchronous disposal logic\n+  }\n+}\n+```\n+\n+An object that implements `Symbol.dispose` can be used with the `using`\n+statement, which will automatically call the `Symbol.dispose` method when the\n+object goes out of scope. If an object implements `Symbol.asyncDispose`, it can\n+be used with the `await using` statement in an asynchronous context. It is\n+worth noting here that `await using` means the disposal is asynchronous,\n+not the initialization.\n+\n+```mjs\n+{\n+  using resource = new MyResource();\n+  await using asyncResource = new MyResource();\n+}\n+```\n+\n+Importantly, it is necessary to understand that the design of `using` makes it\n+possible for user code to call the `Symbol.dispose` or `Symbol.asyncDispose`\n+methods directly, outside of the `using` or `await using` statements. These\n+can also be called multiple times and by any code that is holding a reference\n+to the object. That is to say, explicit resource management does not imply\n+ownership of the object. It is not a form of RAII (Resource Acquisition Is\n+Initialization) as seen in some other languages and there is no notion of\n+exclusive ownership of the object. A disposable object can become disposed\n+at any time.\n+\n+The `Symbol.dispose` and `Symbol.asyncDispose` methods are called in both\n+successful and exceptional exits from the scopes in which the `using` keyword\n+is used. This means that if an exception is thrown within the scope, the\n+disposal methods will still be called. However, when the disposal methods are\n+called they are not aware of the context. These methods will not receive any\n+information about the exception that was thrown or whether an exception was\n+thrown at all. This means that it is often safest to assume that the disposal\n+methods will be called in a context where the object may not be in a valid\n+state or that an exception may be pending.\n+\n+## Guidelines for Disposable Objects\n+\n+So with this in mind, it is necessary to outline some guidelines for disposers:\n+\n+1. Disposers should be idempotent. Multiple calls to the disposal methods\n+   should not cause any issues or have any additional side effects.\n+2. Disposers should assume that they are being called in an exception context.\n+   Always assume there is likely a pending exception and that if the object\n+   has not been explicitly closed when the disposal method is called, the\n+   object should be disposed as if an exception had occurred. For instance,\n+   if the object API exposes both a `close()` method and an `abort()` method,\n+   the disposal method should call `abort()` if the object is not already\n+   closed. If there is no difference in disposing in success or exception\n+   contexts, then separate disposal methods are unnecessary.\n+3. It is recommended to avoid throwing errors within disposers.\n+   If a disposer throws an exception while there is another pending\n+   exception, then both exceptions will be wrapped in a `SuppressedError`\n+   that masks both. This makes it difficult to understand the context\n+   in which the exceptions were thrown.\n+4. Disposable objects should expose explicit disposal methods in addition\n+   to the `Symbol.dispose` and `Symbol.asyncDispose` methods. This allows\n+   user code to explicitly dispose of the object without using the `using`\n+   or `await using` statements. For example, a disposable object might\n+   expose a `close()` method that can be called to dispose of the object.\n+   The `Symbol.dispose` and `Symbol.asyncDispose` methods should then invoke\n+   these explicit disposal methods in an idempotent manner.",
        "comment_created_at": "2025-06-29T12:27:51+00:00",
        "comment_author": "LiviaMedeiros",
        "comment_body": "Sure, it's good as it is now.\r\nI'll try to address it and make follow-up PR, editing this and the API docs.",
        "pr_file_module": null
      }
    ]
  }
]