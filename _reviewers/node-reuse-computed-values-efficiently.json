[
  {
    "discussion_id": "2162934528",
    "pr_number": 58666,
    "pr_file": "src/node_locks.cc",
    "created_at": "2025-06-24T04:28:27+00:00",
    "commented_code": "+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+void LockManager::CleanupStolenLocks(Environment* env) {\n+  std::vector<std::u16string> resources_to_clean;\n+\n+  // Collect resources to clean\n+  {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    for (auto resource_iter = held_locks_.begin();\n+         resource_iter != held_locks_.end();\n+         ++resource_iter) {\n+      auto& resource_locks = resource_iter->second;\n+      bool has_stolen_from_other_env = false;\n+\n+      // Check if this resource has stolen locks from other environments\n+      for (const auto& lock_ptr : resource_locks) {\n+        if (lock_ptr->is_stolen() && lock_ptr->env() != env) {\n+          has_stolen_from_other_env = true;\n+          break;\n+        }\n+      }\n+\n+      if (has_stolen_from_other_env) {\n+        resources_to_clean.push_back(resource_iter->first);\n+      }\n+    }\n+  }\n+\n+  // Clean up resources\n+  for (const auto& resource_name : resources_to_clean) {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    auto resource_iter = held_locks_.find(resource_name);\n+    if (resource_iter != held_locks_.end()) {\n+      auto& resource_locks = resource_iter->second;\n+\n+      // Remove stolen locks from other environments\n+      for (auto lock_iter = resource_locks.begin();\n+           lock_iter != resource_locks.end();) {\n+        if ((*lock_iter)->is_stolen() && (*lock_iter)->env() != env) {\n+          lock_iter = resource_locks.erase(lock_iter);\n+        } else {\n+          ++lock_iter;\n+        }\n+      }\n+\n+      if (resource_locks.empty()) {\n+        held_locks_.erase(resource_iter);\n+      }\n+    }\n+  }\n+}\n+\n+/**\n+ * Web Locks algorithm implementation\n+ * https://w3c.github.io/web-locks/#algorithms\n+ */\n+void LockManager::ProcessQueue(Environment* env) {\n+  Isolate* isolate = env->isolate();\n+  HandleScope handle_scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  // Remove locks that were stolen from this Environment first\n+  CleanupStolenLocks(env);\n+\n+  while (true) {\n+    std::unique_ptr<LockRequest> grantable_request;\n+    std::unique_ptr<LockRequest> if_available_request;\n+    std::unordered_set<Environment*> other_envs_to_wake;\n+\n+    {\n+      std::unordered_map<std::u16string, LockRequest*> first_seen_for_resource;\n+\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      for (auto queue_iter = pending_queue_.begin();\n+           queue_iter != pending_queue_.end();\n+           ++queue_iter) {\n+        LockRequest* request = queue_iter->get();\n+\n+        // Collect unique environments to wake up later\n+        if (request->env() != env) {\n+          other_envs_to_wake.insert(request->env());\n+          continue;\n+        }\n+\n+        // During a single pass, the first time we see a resource name is the\n+        // earliest pending request\n+        auto& first_for_resource = first_seen_for_resource[request->name()];\n+        if (first_for_resource == nullptr) {\n+          first_for_resource = request;  // Mark as first seen for this resource\n+        }\n+\n+        bool has_earlier_request_for_same_resource =\n+            (first_for_resource != request);\n+\n+        if (has_earlier_request_for_same_resource || !IsGrantable(request)) {\n+          if (request->if_available()) {\n+            // ifAvailable request when resource not available: grant with null\n+            if_available_request = std::move(*queue_iter);\n+            pending_queue_.erase(queue_iter);\n+            break;\n+          }\n+          continue;\n+        }\n+\n+        // Found a request that can be granted normally\n+        grantable_request = std::move(*queue_iter);\n+        pending_queue_.erase(queue_iter);\n+        break;\n+      }\n+    }\n+\n+    // Wake each environment only once\n+    for (Environment* target_env : other_envs_to_wake) {\n+      WakeEnvironment(target_env);\n+    }\n+\n+    /**\n+     * ifAvailable:\n+     *  Grant the lock only if it is immediately available;\n+     *  otherwise invoke the callback with null and resolve the promises.\n+     *  Check wrapCallback function in locks.js\n+     */\n+    if (if_available_request) {\n+      Local<Value> null_arg = Null(isolate);\n+      Local<Value> callback_result;\n+      {\n+        TryCatchScope try_catch_scope(env);\n+        if (!if_available_request->callback()\n+                 ->Call(context, Undefined(isolate), 1, &null_arg)\n+                 .ToLocal(&callback_result)) {\n+          if_available_request->waiting_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          if_available_request->released_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          return;\n+        }\n+      }\n+      if_available_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      if_available_request->released_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      return;\n+    }\n+\n+    if (!grantable_request) return;\n+\n+    // Handle steal operations with minimal mutex scope\n+    if (grantable_request->steal()) {\n+      std::unordered_set<Environment*> envs_to_notify;\n+\n+      {\n+        Mutex::ScopedLock scoped_lock(mutex_);\n+        auto held_locks_iter = held_locks_.find(grantable_request->name());\n+        if (held_locks_iter != held_locks_.end()) {\n+          // Mark existing locks as stolen and collect environments to notify\n+          for (auto& existing_lock : held_locks_iter->second) {\n+            existing_lock->mark_stolen();\n+            envs_to_notify.insert(existing_lock->env());\n+\n+            // Immediately reject the stolen lock's released_promise\n+            Local<String> error_string;\n+            if (!String::NewFromUtf8(isolate, kLockStolenError)\n+                     .ToLocal(&error_string)) {\n+              return;\n+            }\n+            Local<Value> error = Exception::Error(error_string);\n+            existing_lock->released_promise()->Reject(context, error).Check();\n+          }\n+\n+          // Remove stolen locks from current environment immediately\n+          for (auto lock_iter = held_locks_iter->second.begin();\n+               lock_iter != held_locks_iter->second.end();) {\n+            if ((*lock_iter)->env() == env) {\n+              lock_iter = held_locks_iter->second.erase(lock_iter);\n+            } else {\n+              ++lock_iter;\n+            }\n+          }\n+\n+          if (held_locks_iter->second.empty()) {\n+            held_locks_.erase(held_locks_iter);\n+          }\n+        }\n+      }\n+\n+      // Wake other environments\n+      for (Environment* target_env : envs_to_notify) {\n+        if (target_env != env) {\n+          WakeEnvironment(target_env);\n+        }\n+      }\n+    }\n+\n+    // Create and store the new granted lock\n+    auto granted_lock =\n+        std::make_shared<Lock>(env,\n+                               grantable_request->name(),\n+                               grantable_request->mode(),\n+                               grantable_request->client_id(),\n+                               grantable_request->waiting_promise(),\n+                               grantable_request->released_promise());\n+    {\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      held_locks_[grantable_request->name()].push_back(granted_lock);\n+    }\n+\n+    // Call user callback\n+    Local<Object> lock_info_obj =\n+        CreateLockInfoObject(isolate,\n+                             context,\n+                             grantable_request->name(),\n+                             grantable_request->mode(),\n+                             grantable_request->client_id());\n+    if (lock_info_obj.IsEmpty()) {\n+      return;\n+    }\n+    Local<Value> callback_arg = lock_info_obj;\n+    Local<Value> callback_result;\n+    {\n+      TryCatchScope try_catch_scope(env);\n+      if (!grantable_request->callback()\n+               ->Call(context, Undefined(isolate), 1, &callback_arg)\n+               .ToLocal(&callback_result)) {\n+        grantable_request->waiting_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        return;\n+      }\n+    }\n+\n+    // Allocate a LockHolder on the heap to safely manage the lock's lifetime\n+    // until the user's callback promise settles.\n+    auto* fulfill_holder = new LockHolder(granted_lock);\n+    auto* reject_holder = new LockHolder(granted_lock);\n+    Local<Function> on_fulfilled_callback;\n+    Local<Function> on_rejected_callback;\n+\n+    if (!Function::New(context,\n+                       OnLockCallbackFulfilled,\n+                       External::New(isolate, fulfill_holder))\n+             .ToLocal(&on_fulfilled_callback) ||\n+        !Function::New(context,\n+                       OnLockCallbackRejected,\n+                       External::New(isolate, reject_holder))\n+             .ToLocal(&on_rejected_callback)) {\n+      delete fulfill_holder;\n+      delete reject_holder;\n+      return;\n+    }\n+\n+    // Handle promise chain\n+    if (callback_result->IsPromise()) {\n+      Local<Promise> promise = callback_result.As<Promise>();\n+      if (promise->State() == Promise::kRejected) {\n+        Local<Value> rejection_value = promise->Result();\n+        grantable_request->waiting_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        delete fulfill_holder;\n+        delete reject_holder;\n+        {\n+          Mutex::ScopedLock scoped_lock(mutex_);\n+          ReleaseLock(granted_lock.get());\n+        }\n+        ProcessQueue(env);\n+        return;\n+      } else {\n+        grantable_request->waiting_promise()\n+            ->Resolve(context, callback_result)\n+            .Check();\n+        USE(promise->Then(\n+            context, on_fulfilled_callback, on_rejected_callback));\n+      }\n+    } else {\n+      grantable_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      Local<Value> promise_args[] = {callback_result};\n+      USE(on_fulfilled_callback->Call(\n+          context, Undefined(isolate), 1, promise_args));\n+      delete reject_holder;\n+    }\n+  }\n+}\n+\n+/**\n+ * name        : string   – resource identifier\n+ * clientId    : string   – client identifier\n+ * mode        : string   – lock mode\n+ * steal       : boolean  – whether to steal existing locks\n+ * ifAvailable : boolean  – only grant if immediately available\n+ * callback    : Function - JS callback\n+ */\n+void LockManager::Request(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  CHECK_EQ(args.Length(), 6);\n+  CHECK(args[0]->IsString());\n+  CHECK(args[1]->IsString());\n+  CHECK(args[2]->IsString());\n+  CHECK(args[3]->IsBoolean());\n+  CHECK(args[4]->IsBoolean());\n+  CHECK(args[5]->IsFunction());\n+\n+  Local<String> resource_name_str = args[0].As<String>();\n+  TwoByteValue resource_name_utf16(isolate, resource_name_str);\n+  std::u16string resource_name(\n+      reinterpret_cast<const char16_t*>(*resource_name_utf16),\n+      resource_name_utf16.length());\n+  String::Utf8Value client_id_utf8(isolate, args[1]);\n+  std::string client_id(*client_id_utf8);\n+  String::Utf8Value mode_utf8(isolate, args[2]);\n+  std::string mode_str(*mode_utf8);\n+  bool steal = args[3]->BooleanValue(isolate);\n+  bool if_available = args[4]->BooleanValue(isolate);\n+  Local<Function> callback = args[5].As<Function>();\n+\n+  Lock::Mode lock_mode =\n+      mode_str == kSharedMode ? Lock::Mode::Shared : Lock::Mode::Exclusive;\n+\n+  Local<Promise::Resolver> waiting_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&waiting_promise)) {\n+    return;\n+  }\n+  Local<Promise::Resolver> released_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&released_promise)) {\n+    return;\n+  }\n+\n+  args.GetReturnValue().Set(released_promise->GetPromise());\n+\n+  LockManager* manager = GetCurrent();\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    // Register cleanup hook for the environment only once\n+    if (manager->registered_envs_.insert(env).second) {\n+      env->AddCleanupHook(LockManager::OnEnvironmentCleanup, env);\n+    }\n+\n+    auto lock_request = std::make_unique<LockRequest>(env,\n+                                                      waiting_promise,\n+                                                      released_promise,\n+                                                      callback,\n+                                                      resource_name,\n+                                                      lock_mode,\n+                                                      client_id,\n+                                                      steal,\n+                                                      if_available);\n+    // Steal requests get priority by going to front of queue\n+    if (steal) {\n+      manager->pending_queue_.emplace_front(std::move(lock_request));\n+    } else {\n+      manager->pending_queue_.push_back(std::move(lock_request));\n+    }\n+  }\n+\n+  manager->ProcessQueue(env);\n+}\n+\n+void LockManager::Query(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  Local<Promise::Resolver> resolver;\n+  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {\n+    return;\n+  }\n+  args.GetReturnValue().Set(resolver->GetPromise());\n+\n+  Local<Object> result = Object::New(isolate);\n+  Local<Array> held_list = Array::New(isolate);\n+  Local<Array> pending_list = Array::New(isolate);\n+  LockManager* manager = GetCurrent();\n+\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    uint32_t index = 0;\n+    for (const auto& resource_entry : manager->held_locks_) {\n+      for (const auto& held_lock : resource_entry.second) {\n+        if (held_lock->env() == env) {\n+          Local<Object> lock_info =",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2162934528",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2162934528",
        "commented_code": "@@ -0,0 +1,738 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+void LockManager::CleanupStolenLocks(Environment* env) {\n+  std::vector<std::u16string> resources_to_clean;\n+\n+  // Collect resources to clean\n+  {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    for (auto resource_iter = held_locks_.begin();\n+         resource_iter != held_locks_.end();\n+         ++resource_iter) {\n+      auto& resource_locks = resource_iter->second;\n+      bool has_stolen_from_other_env = false;\n+\n+      // Check if this resource has stolen locks from other environments\n+      for (const auto& lock_ptr : resource_locks) {\n+        if (lock_ptr->is_stolen() && lock_ptr->env() != env) {\n+          has_stolen_from_other_env = true;\n+          break;\n+        }\n+      }\n+\n+      if (has_stolen_from_other_env) {\n+        resources_to_clean.push_back(resource_iter->first);\n+      }\n+    }\n+  }\n+\n+  // Clean up resources\n+  for (const auto& resource_name : resources_to_clean) {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    auto resource_iter = held_locks_.find(resource_name);\n+    if (resource_iter != held_locks_.end()) {\n+      auto& resource_locks = resource_iter->second;\n+\n+      // Remove stolen locks from other environments\n+      for (auto lock_iter = resource_locks.begin();\n+           lock_iter != resource_locks.end();) {\n+        if ((*lock_iter)->is_stolen() && (*lock_iter)->env() != env) {\n+          lock_iter = resource_locks.erase(lock_iter);\n+        } else {\n+          ++lock_iter;\n+        }\n+      }\n+\n+      if (resource_locks.empty()) {\n+        held_locks_.erase(resource_iter);\n+      }\n+    }\n+  }\n+}\n+\n+/**\n+ * Web Locks algorithm implementation\n+ * https://w3c.github.io/web-locks/#algorithms\n+ */\n+void LockManager::ProcessQueue(Environment* env) {\n+  Isolate* isolate = env->isolate();\n+  HandleScope handle_scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  // Remove locks that were stolen from this Environment first\n+  CleanupStolenLocks(env);\n+\n+  while (true) {\n+    std::unique_ptr<LockRequest> grantable_request;\n+    std::unique_ptr<LockRequest> if_available_request;\n+    std::unordered_set<Environment*> other_envs_to_wake;\n+\n+    {\n+      std::unordered_map<std::u16string, LockRequest*> first_seen_for_resource;\n+\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      for (auto queue_iter = pending_queue_.begin();\n+           queue_iter != pending_queue_.end();\n+           ++queue_iter) {\n+        LockRequest* request = queue_iter->get();\n+\n+        // Collect unique environments to wake up later\n+        if (request->env() != env) {\n+          other_envs_to_wake.insert(request->env());\n+          continue;\n+        }\n+\n+        // During a single pass, the first time we see a resource name is the\n+        // earliest pending request\n+        auto& first_for_resource = first_seen_for_resource[request->name()];\n+        if (first_for_resource == nullptr) {\n+          first_for_resource = request;  // Mark as first seen for this resource\n+        }\n+\n+        bool has_earlier_request_for_same_resource =\n+            (first_for_resource != request);\n+\n+        if (has_earlier_request_for_same_resource || !IsGrantable(request)) {\n+          if (request->if_available()) {\n+            // ifAvailable request when resource not available: grant with null\n+            if_available_request = std::move(*queue_iter);\n+            pending_queue_.erase(queue_iter);\n+            break;\n+          }\n+          continue;\n+        }\n+\n+        // Found a request that can be granted normally\n+        grantable_request = std::move(*queue_iter);\n+        pending_queue_.erase(queue_iter);\n+        break;\n+      }\n+    }\n+\n+    // Wake each environment only once\n+    for (Environment* target_env : other_envs_to_wake) {\n+      WakeEnvironment(target_env);\n+    }\n+\n+    /**\n+     * ifAvailable:\n+     *  Grant the lock only if it is immediately available;\n+     *  otherwise invoke the callback with null and resolve the promises.\n+     *  Check wrapCallback function in locks.js\n+     */\n+    if (if_available_request) {\n+      Local<Value> null_arg = Null(isolate);\n+      Local<Value> callback_result;\n+      {\n+        TryCatchScope try_catch_scope(env);\n+        if (!if_available_request->callback()\n+                 ->Call(context, Undefined(isolate), 1, &null_arg)\n+                 .ToLocal(&callback_result)) {\n+          if_available_request->waiting_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          if_available_request->released_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          return;\n+        }\n+      }\n+      if_available_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      if_available_request->released_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      return;\n+    }\n+\n+    if (!grantable_request) return;\n+\n+    // Handle steal operations with minimal mutex scope\n+    if (grantable_request->steal()) {\n+      std::unordered_set<Environment*> envs_to_notify;\n+\n+      {\n+        Mutex::ScopedLock scoped_lock(mutex_);\n+        auto held_locks_iter = held_locks_.find(grantable_request->name());\n+        if (held_locks_iter != held_locks_.end()) {\n+          // Mark existing locks as stolen and collect environments to notify\n+          for (auto& existing_lock : held_locks_iter->second) {\n+            existing_lock->mark_stolen();\n+            envs_to_notify.insert(existing_lock->env());\n+\n+            // Immediately reject the stolen lock's released_promise\n+            Local<String> error_string;\n+            if (!String::NewFromUtf8(isolate, kLockStolenError)\n+                     .ToLocal(&error_string)) {\n+              return;\n+            }\n+            Local<Value> error = Exception::Error(error_string);\n+            existing_lock->released_promise()->Reject(context, error).Check();\n+          }\n+\n+          // Remove stolen locks from current environment immediately\n+          for (auto lock_iter = held_locks_iter->second.begin();\n+               lock_iter != held_locks_iter->second.end();) {\n+            if ((*lock_iter)->env() == env) {\n+              lock_iter = held_locks_iter->second.erase(lock_iter);\n+            } else {\n+              ++lock_iter;\n+            }\n+          }\n+\n+          if (held_locks_iter->second.empty()) {\n+            held_locks_.erase(held_locks_iter);\n+          }\n+        }\n+      }\n+\n+      // Wake other environments\n+      for (Environment* target_env : envs_to_notify) {\n+        if (target_env != env) {\n+          WakeEnvironment(target_env);\n+        }\n+      }\n+    }\n+\n+    // Create and store the new granted lock\n+    auto granted_lock =\n+        std::make_shared<Lock>(env,\n+                               grantable_request->name(),\n+                               grantable_request->mode(),\n+                               grantable_request->client_id(),\n+                               grantable_request->waiting_promise(),\n+                               grantable_request->released_promise());\n+    {\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      held_locks_[grantable_request->name()].push_back(granted_lock);\n+    }\n+\n+    // Call user callback\n+    Local<Object> lock_info_obj =\n+        CreateLockInfoObject(isolate,\n+                             context,\n+                             grantable_request->name(),\n+                             grantable_request->mode(),\n+                             grantable_request->client_id());\n+    if (lock_info_obj.IsEmpty()) {\n+      return;\n+    }\n+    Local<Value> callback_arg = lock_info_obj;\n+    Local<Value> callback_result;\n+    {\n+      TryCatchScope try_catch_scope(env);\n+      if (!grantable_request->callback()\n+               ->Call(context, Undefined(isolate), 1, &callback_arg)\n+               .ToLocal(&callback_result)) {\n+        grantable_request->waiting_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        return;\n+      }\n+    }\n+\n+    // Allocate a LockHolder on the heap to safely manage the lock's lifetime\n+    // until the user's callback promise settles.\n+    auto* fulfill_holder = new LockHolder(granted_lock);\n+    auto* reject_holder = new LockHolder(granted_lock);\n+    Local<Function> on_fulfilled_callback;\n+    Local<Function> on_rejected_callback;\n+\n+    if (!Function::New(context,\n+                       OnLockCallbackFulfilled,\n+                       External::New(isolate, fulfill_holder))\n+             .ToLocal(&on_fulfilled_callback) ||\n+        !Function::New(context,\n+                       OnLockCallbackRejected,\n+                       External::New(isolate, reject_holder))\n+             .ToLocal(&on_rejected_callback)) {\n+      delete fulfill_holder;\n+      delete reject_holder;\n+      return;\n+    }\n+\n+    // Handle promise chain\n+    if (callback_result->IsPromise()) {\n+      Local<Promise> promise = callback_result.As<Promise>();\n+      if (promise->State() == Promise::kRejected) {\n+        Local<Value> rejection_value = promise->Result();\n+        grantable_request->waiting_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        delete fulfill_holder;\n+        delete reject_holder;\n+        {\n+          Mutex::ScopedLock scoped_lock(mutex_);\n+          ReleaseLock(granted_lock.get());\n+        }\n+        ProcessQueue(env);\n+        return;\n+      } else {\n+        grantable_request->waiting_promise()\n+            ->Resolve(context, callback_result)\n+            .Check();\n+        USE(promise->Then(\n+            context, on_fulfilled_callback, on_rejected_callback));\n+      }\n+    } else {\n+      grantable_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      Local<Value> promise_args[] = {callback_result};\n+      USE(on_fulfilled_callback->Call(\n+          context, Undefined(isolate), 1, promise_args));\n+      delete reject_holder;\n+    }\n+  }\n+}\n+\n+/**\n+ * name        : string   – resource identifier\n+ * clientId    : string   – client identifier\n+ * mode        : string   – lock mode\n+ * steal       : boolean  – whether to steal existing locks\n+ * ifAvailable : boolean  – only grant if immediately available\n+ * callback    : Function - JS callback\n+ */\n+void LockManager::Request(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  CHECK_EQ(args.Length(), 6);\n+  CHECK(args[0]->IsString());\n+  CHECK(args[1]->IsString());\n+  CHECK(args[2]->IsString());\n+  CHECK(args[3]->IsBoolean());\n+  CHECK(args[4]->IsBoolean());\n+  CHECK(args[5]->IsFunction());\n+\n+  Local<String> resource_name_str = args[0].As<String>();\n+  TwoByteValue resource_name_utf16(isolate, resource_name_str);\n+  std::u16string resource_name(\n+      reinterpret_cast<const char16_t*>(*resource_name_utf16),\n+      resource_name_utf16.length());\n+  String::Utf8Value client_id_utf8(isolate, args[1]);\n+  std::string client_id(*client_id_utf8);\n+  String::Utf8Value mode_utf8(isolate, args[2]);\n+  std::string mode_str(*mode_utf8);\n+  bool steal = args[3]->BooleanValue(isolate);\n+  bool if_available = args[4]->BooleanValue(isolate);\n+  Local<Function> callback = args[5].As<Function>();\n+\n+  Lock::Mode lock_mode =\n+      mode_str == kSharedMode ? Lock::Mode::Shared : Lock::Mode::Exclusive;\n+\n+  Local<Promise::Resolver> waiting_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&waiting_promise)) {\n+    return;\n+  }\n+  Local<Promise::Resolver> released_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&released_promise)) {\n+    return;\n+  }\n+\n+  args.GetReturnValue().Set(released_promise->GetPromise());\n+\n+  LockManager* manager = GetCurrent();\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    // Register cleanup hook for the environment only once\n+    if (manager->registered_envs_.insert(env).second) {\n+      env->AddCleanupHook(LockManager::OnEnvironmentCleanup, env);\n+    }\n+\n+    auto lock_request = std::make_unique<LockRequest>(env,\n+                                                      waiting_promise,\n+                                                      released_promise,\n+                                                      callback,\n+                                                      resource_name,\n+                                                      lock_mode,\n+                                                      client_id,\n+                                                      steal,\n+                                                      if_available);\n+    // Steal requests get priority by going to front of queue\n+    if (steal) {\n+      manager->pending_queue_.emplace_front(std::move(lock_request));\n+    } else {\n+      manager->pending_queue_.push_back(std::move(lock_request));\n+    }\n+  }\n+\n+  manager->ProcessQueue(env);\n+}\n+\n+void LockManager::Query(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  Local<Promise::Resolver> resolver;\n+  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {\n+    return;\n+  }\n+  args.GetReturnValue().Set(resolver->GetPromise());\n+\n+  Local<Object> result = Object::New(isolate);\n+  Local<Array> held_list = Array::New(isolate);\n+  Local<Array> pending_list = Array::New(isolate);\n+  LockManager* manager = GetCurrent();\n+\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    uint32_t index = 0;\n+    for (const auto& resource_entry : manager->held_locks_) {\n+      for (const auto& held_lock : resource_entry.second) {\n+        if (held_lock->env() == env) {\n+          Local<Object> lock_info =",
        "comment_created_at": "2025-06-24T04:28:27+00:00",
        "comment_author": "jasnell",
        "comment_body": "You might consider moving the declaration for the `Local<Object> lock_info` to outside of the for loop and just reset it here so that we're reusing the same declaration on each iteration rather than creating a new one.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162935224",
    "pr_number": 58666,
    "pr_file": "src/node_locks.cc",
    "created_at": "2025-06-24T04:29:18+00:00",
    "commented_code": "+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+void LockManager::CleanupStolenLocks(Environment* env) {\n+  std::vector<std::u16string> resources_to_clean;\n+\n+  // Collect resources to clean\n+  {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    for (auto resource_iter = held_locks_.begin();\n+         resource_iter != held_locks_.end();\n+         ++resource_iter) {\n+      auto& resource_locks = resource_iter->second;\n+      bool has_stolen_from_other_env = false;\n+\n+      // Check if this resource has stolen locks from other environments\n+      for (const auto& lock_ptr : resource_locks) {\n+        if (lock_ptr->is_stolen() && lock_ptr->env() != env) {\n+          has_stolen_from_other_env = true;\n+          break;\n+        }\n+      }\n+\n+      if (has_stolen_from_other_env) {\n+        resources_to_clean.push_back(resource_iter->first);\n+      }\n+    }\n+  }\n+\n+  // Clean up resources\n+  for (const auto& resource_name : resources_to_clean) {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    auto resource_iter = held_locks_.find(resource_name);\n+    if (resource_iter != held_locks_.end()) {\n+      auto& resource_locks = resource_iter->second;\n+\n+      // Remove stolen locks from other environments\n+      for (auto lock_iter = resource_locks.begin();\n+           lock_iter != resource_locks.end();) {\n+        if ((*lock_iter)->is_stolen() && (*lock_iter)->env() != env) {\n+          lock_iter = resource_locks.erase(lock_iter);\n+        } else {\n+          ++lock_iter;\n+        }\n+      }\n+\n+      if (resource_locks.empty()) {\n+        held_locks_.erase(resource_iter);\n+      }\n+    }\n+  }\n+}\n+\n+/**\n+ * Web Locks algorithm implementation\n+ * https://w3c.github.io/web-locks/#algorithms\n+ */\n+void LockManager::ProcessQueue(Environment* env) {\n+  Isolate* isolate = env->isolate();\n+  HandleScope handle_scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  // Remove locks that were stolen from this Environment first\n+  CleanupStolenLocks(env);\n+\n+  while (true) {\n+    std::unique_ptr<LockRequest> grantable_request;\n+    std::unique_ptr<LockRequest> if_available_request;\n+    std::unordered_set<Environment*> other_envs_to_wake;\n+\n+    {\n+      std::unordered_map<std::u16string, LockRequest*> first_seen_for_resource;\n+\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      for (auto queue_iter = pending_queue_.begin();\n+           queue_iter != pending_queue_.end();\n+           ++queue_iter) {\n+        LockRequest* request = queue_iter->get();\n+\n+        // Collect unique environments to wake up later\n+        if (request->env() != env) {\n+          other_envs_to_wake.insert(request->env());\n+          continue;\n+        }\n+\n+        // During a single pass, the first time we see a resource name is the\n+        // earliest pending request\n+        auto& first_for_resource = first_seen_for_resource[request->name()];\n+        if (first_for_resource == nullptr) {\n+          first_for_resource = request;  // Mark as first seen for this resource\n+        }\n+\n+        bool has_earlier_request_for_same_resource =\n+            (first_for_resource != request);\n+\n+        if (has_earlier_request_for_same_resource || !IsGrantable(request)) {\n+          if (request->if_available()) {\n+            // ifAvailable request when resource not available: grant with null\n+            if_available_request = std::move(*queue_iter);\n+            pending_queue_.erase(queue_iter);\n+            break;\n+          }\n+          continue;\n+        }\n+\n+        // Found a request that can be granted normally\n+        grantable_request = std::move(*queue_iter);\n+        pending_queue_.erase(queue_iter);\n+        break;\n+      }\n+    }\n+\n+    // Wake each environment only once\n+    for (Environment* target_env : other_envs_to_wake) {\n+      WakeEnvironment(target_env);\n+    }\n+\n+    /**\n+     * ifAvailable:\n+     *  Grant the lock only if it is immediately available;\n+     *  otherwise invoke the callback with null and resolve the promises.\n+     *  Check wrapCallback function in locks.js\n+     */\n+    if (if_available_request) {\n+      Local<Value> null_arg = Null(isolate);\n+      Local<Value> callback_result;\n+      {\n+        TryCatchScope try_catch_scope(env);\n+        if (!if_available_request->callback()\n+                 ->Call(context, Undefined(isolate), 1, &null_arg)\n+                 .ToLocal(&callback_result)) {\n+          if_available_request->waiting_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          if_available_request->released_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          return;\n+        }\n+      }\n+      if_available_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      if_available_request->released_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      return;\n+    }\n+\n+    if (!grantable_request) return;\n+\n+    // Handle steal operations with minimal mutex scope\n+    if (grantable_request->steal()) {\n+      std::unordered_set<Environment*> envs_to_notify;\n+\n+      {\n+        Mutex::ScopedLock scoped_lock(mutex_);\n+        auto held_locks_iter = held_locks_.find(grantable_request->name());\n+        if (held_locks_iter != held_locks_.end()) {\n+          // Mark existing locks as stolen and collect environments to notify\n+          for (auto& existing_lock : held_locks_iter->second) {\n+            existing_lock->mark_stolen();\n+            envs_to_notify.insert(existing_lock->env());\n+\n+            // Immediately reject the stolen lock's released_promise\n+            Local<String> error_string;\n+            if (!String::NewFromUtf8(isolate, kLockStolenError)\n+                     .ToLocal(&error_string)) {\n+              return;\n+            }\n+            Local<Value> error = Exception::Error(error_string);\n+            existing_lock->released_promise()->Reject(context, error).Check();\n+          }\n+\n+          // Remove stolen locks from current environment immediately\n+          for (auto lock_iter = held_locks_iter->second.begin();\n+               lock_iter != held_locks_iter->second.end();) {\n+            if ((*lock_iter)->env() == env) {\n+              lock_iter = held_locks_iter->second.erase(lock_iter);\n+            } else {\n+              ++lock_iter;\n+            }\n+          }\n+\n+          if (held_locks_iter->second.empty()) {\n+            held_locks_.erase(held_locks_iter);\n+          }\n+        }\n+      }\n+\n+      // Wake other environments\n+      for (Environment* target_env : envs_to_notify) {\n+        if (target_env != env) {\n+          WakeEnvironment(target_env);\n+        }\n+      }\n+    }\n+\n+    // Create and store the new granted lock\n+    auto granted_lock =\n+        std::make_shared<Lock>(env,\n+                               grantable_request->name(),\n+                               grantable_request->mode(),\n+                               grantable_request->client_id(),\n+                               grantable_request->waiting_promise(),\n+                               grantable_request->released_promise());\n+    {\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      held_locks_[grantable_request->name()].push_back(granted_lock);\n+    }\n+\n+    // Call user callback\n+    Local<Object> lock_info_obj =\n+        CreateLockInfoObject(isolate,\n+                             context,\n+                             grantable_request->name(),\n+                             grantable_request->mode(),\n+                             grantable_request->client_id());\n+    if (lock_info_obj.IsEmpty()) {\n+      return;\n+    }\n+    Local<Value> callback_arg = lock_info_obj;\n+    Local<Value> callback_result;\n+    {\n+      TryCatchScope try_catch_scope(env);\n+      if (!grantable_request->callback()\n+               ->Call(context, Undefined(isolate), 1, &callback_arg)\n+               .ToLocal(&callback_result)) {\n+        grantable_request->waiting_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        return;\n+      }\n+    }\n+\n+    // Allocate a LockHolder on the heap to safely manage the lock's lifetime\n+    // until the user's callback promise settles.\n+    auto* fulfill_holder = new LockHolder(granted_lock);\n+    auto* reject_holder = new LockHolder(granted_lock);\n+    Local<Function> on_fulfilled_callback;\n+    Local<Function> on_rejected_callback;\n+\n+    if (!Function::New(context,\n+                       OnLockCallbackFulfilled,\n+                       External::New(isolate, fulfill_holder))\n+             .ToLocal(&on_fulfilled_callback) ||\n+        !Function::New(context,\n+                       OnLockCallbackRejected,\n+                       External::New(isolate, reject_holder))\n+             .ToLocal(&on_rejected_callback)) {\n+      delete fulfill_holder;\n+      delete reject_holder;\n+      return;\n+    }\n+\n+    // Handle promise chain\n+    if (callback_result->IsPromise()) {\n+      Local<Promise> promise = callback_result.As<Promise>();\n+      if (promise->State() == Promise::kRejected) {\n+        Local<Value> rejection_value = promise->Result();\n+        grantable_request->waiting_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        delete fulfill_holder;\n+        delete reject_holder;\n+        {\n+          Mutex::ScopedLock scoped_lock(mutex_);\n+          ReleaseLock(granted_lock.get());\n+        }\n+        ProcessQueue(env);\n+        return;\n+      } else {\n+        grantable_request->waiting_promise()\n+            ->Resolve(context, callback_result)\n+            .Check();\n+        USE(promise->Then(\n+            context, on_fulfilled_callback, on_rejected_callback));\n+      }\n+    } else {\n+      grantable_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      Local<Value> promise_args[] = {callback_result};\n+      USE(on_fulfilled_callback->Call(\n+          context, Undefined(isolate), 1, promise_args));\n+      delete reject_holder;\n+    }\n+  }\n+}\n+\n+/**\n+ * name        : string   – resource identifier\n+ * clientId    : string   – client identifier\n+ * mode        : string   – lock mode\n+ * steal       : boolean  – whether to steal existing locks\n+ * ifAvailable : boolean  – only grant if immediately available\n+ * callback    : Function - JS callback\n+ */\n+void LockManager::Request(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  CHECK_EQ(args.Length(), 6);\n+  CHECK(args[0]->IsString());\n+  CHECK(args[1]->IsString());\n+  CHECK(args[2]->IsString());\n+  CHECK(args[3]->IsBoolean());\n+  CHECK(args[4]->IsBoolean());\n+  CHECK(args[5]->IsFunction());\n+\n+  Local<String> resource_name_str = args[0].As<String>();\n+  TwoByteValue resource_name_utf16(isolate, resource_name_str);\n+  std::u16string resource_name(\n+      reinterpret_cast<const char16_t*>(*resource_name_utf16),\n+      resource_name_utf16.length());\n+  String::Utf8Value client_id_utf8(isolate, args[1]);\n+  std::string client_id(*client_id_utf8);\n+  String::Utf8Value mode_utf8(isolate, args[2]);\n+  std::string mode_str(*mode_utf8);\n+  bool steal = args[3]->BooleanValue(isolate);\n+  bool if_available = args[4]->BooleanValue(isolate);\n+  Local<Function> callback = args[5].As<Function>();\n+\n+  Lock::Mode lock_mode =\n+      mode_str == kSharedMode ? Lock::Mode::Shared : Lock::Mode::Exclusive;\n+\n+  Local<Promise::Resolver> waiting_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&waiting_promise)) {\n+    return;\n+  }\n+  Local<Promise::Resolver> released_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&released_promise)) {\n+    return;\n+  }\n+\n+  args.GetReturnValue().Set(released_promise->GetPromise());\n+\n+  LockManager* manager = GetCurrent();\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    // Register cleanup hook for the environment only once\n+    if (manager->registered_envs_.insert(env).second) {\n+      env->AddCleanupHook(LockManager::OnEnvironmentCleanup, env);\n+    }\n+\n+    auto lock_request = std::make_unique<LockRequest>(env,\n+                                                      waiting_promise,\n+                                                      released_promise,\n+                                                      callback,\n+                                                      resource_name,\n+                                                      lock_mode,\n+                                                      client_id,\n+                                                      steal,\n+                                                      if_available);\n+    // Steal requests get priority by going to front of queue\n+    if (steal) {\n+      manager->pending_queue_.emplace_front(std::move(lock_request));\n+    } else {\n+      manager->pending_queue_.push_back(std::move(lock_request));\n+    }\n+  }\n+\n+  manager->ProcessQueue(env);\n+}\n+\n+void LockManager::Query(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  Local<Promise::Resolver> resolver;\n+  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {\n+    return;\n+  }\n+  args.GetReturnValue().Set(resolver->GetPromise());\n+\n+  Local<Object> result = Object::New(isolate);\n+  Local<Array> held_list = Array::New(isolate);\n+  Local<Array> pending_list = Array::New(isolate);\n+  LockManager* manager = GetCurrent();\n+\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    uint32_t index = 0;\n+    for (const auto& resource_entry : manager->held_locks_) {\n+      for (const auto& held_lock : resource_entry.second) {\n+        if (held_lock->env() == env) {\n+          Local<Object> lock_info =\n+              CreateLockInfoObject(isolate,\n+                                   context,\n+                                   held_lock->name(),\n+                                   held_lock->mode(),\n+                                   held_lock->client_id());\n+          if (lock_info.IsEmpty()) {\n+            return;\n+          }\n+          held_list->Set(context, index++, lock_info).Check();\n+        }\n+      }\n+    }\n+\n+    index = 0;\n+    for (const auto& pending_request : manager->pending_queue_) {\n+      if (pending_request->env() == env) {\n+        Local<Object> lock_info =",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2162935224",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2162935224",
        "commented_code": "@@ -0,0 +1,738 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+void LockManager::CleanupStolenLocks(Environment* env) {\n+  std::vector<std::u16string> resources_to_clean;\n+\n+  // Collect resources to clean\n+  {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    for (auto resource_iter = held_locks_.begin();\n+         resource_iter != held_locks_.end();\n+         ++resource_iter) {\n+      auto& resource_locks = resource_iter->second;\n+      bool has_stolen_from_other_env = false;\n+\n+      // Check if this resource has stolen locks from other environments\n+      for (const auto& lock_ptr : resource_locks) {\n+        if (lock_ptr->is_stolen() && lock_ptr->env() != env) {\n+          has_stolen_from_other_env = true;\n+          break;\n+        }\n+      }\n+\n+      if (has_stolen_from_other_env) {\n+        resources_to_clean.push_back(resource_iter->first);\n+      }\n+    }\n+  }\n+\n+  // Clean up resources\n+  for (const auto& resource_name : resources_to_clean) {\n+    Mutex::ScopedLock scoped_lock(mutex_);\n+\n+    auto resource_iter = held_locks_.find(resource_name);\n+    if (resource_iter != held_locks_.end()) {\n+      auto& resource_locks = resource_iter->second;\n+\n+      // Remove stolen locks from other environments\n+      for (auto lock_iter = resource_locks.begin();\n+           lock_iter != resource_locks.end();) {\n+        if ((*lock_iter)->is_stolen() && (*lock_iter)->env() != env) {\n+          lock_iter = resource_locks.erase(lock_iter);\n+        } else {\n+          ++lock_iter;\n+        }\n+      }\n+\n+      if (resource_locks.empty()) {\n+        held_locks_.erase(resource_iter);\n+      }\n+    }\n+  }\n+}\n+\n+/**\n+ * Web Locks algorithm implementation\n+ * https://w3c.github.io/web-locks/#algorithms\n+ */\n+void LockManager::ProcessQueue(Environment* env) {\n+  Isolate* isolate = env->isolate();\n+  HandleScope handle_scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  // Remove locks that were stolen from this Environment first\n+  CleanupStolenLocks(env);\n+\n+  while (true) {\n+    std::unique_ptr<LockRequest> grantable_request;\n+    std::unique_ptr<LockRequest> if_available_request;\n+    std::unordered_set<Environment*> other_envs_to_wake;\n+\n+    {\n+      std::unordered_map<std::u16string, LockRequest*> first_seen_for_resource;\n+\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      for (auto queue_iter = pending_queue_.begin();\n+           queue_iter != pending_queue_.end();\n+           ++queue_iter) {\n+        LockRequest* request = queue_iter->get();\n+\n+        // Collect unique environments to wake up later\n+        if (request->env() != env) {\n+          other_envs_to_wake.insert(request->env());\n+          continue;\n+        }\n+\n+        // During a single pass, the first time we see a resource name is the\n+        // earliest pending request\n+        auto& first_for_resource = first_seen_for_resource[request->name()];\n+        if (first_for_resource == nullptr) {\n+          first_for_resource = request;  // Mark as first seen for this resource\n+        }\n+\n+        bool has_earlier_request_for_same_resource =\n+            (first_for_resource != request);\n+\n+        if (has_earlier_request_for_same_resource || !IsGrantable(request)) {\n+          if (request->if_available()) {\n+            // ifAvailable request when resource not available: grant with null\n+            if_available_request = std::move(*queue_iter);\n+            pending_queue_.erase(queue_iter);\n+            break;\n+          }\n+          continue;\n+        }\n+\n+        // Found a request that can be granted normally\n+        grantable_request = std::move(*queue_iter);\n+        pending_queue_.erase(queue_iter);\n+        break;\n+      }\n+    }\n+\n+    // Wake each environment only once\n+    for (Environment* target_env : other_envs_to_wake) {\n+      WakeEnvironment(target_env);\n+    }\n+\n+    /**\n+     * ifAvailable:\n+     *  Grant the lock only if it is immediately available;\n+     *  otherwise invoke the callback with null and resolve the promises.\n+     *  Check wrapCallback function in locks.js\n+     */\n+    if (if_available_request) {\n+      Local<Value> null_arg = Null(isolate);\n+      Local<Value> callback_result;\n+      {\n+        TryCatchScope try_catch_scope(env);\n+        if (!if_available_request->callback()\n+                 ->Call(context, Undefined(isolate), 1, &null_arg)\n+                 .ToLocal(&callback_result)) {\n+          if_available_request->waiting_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          if_available_request->released_promise()\n+              ->Reject(context, try_catch_scope.Exception())\n+              .Check();\n+          return;\n+        }\n+      }\n+      if_available_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      if_available_request->released_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      return;\n+    }\n+\n+    if (!grantable_request) return;\n+\n+    // Handle steal operations with minimal mutex scope\n+    if (grantable_request->steal()) {\n+      std::unordered_set<Environment*> envs_to_notify;\n+\n+      {\n+        Mutex::ScopedLock scoped_lock(mutex_);\n+        auto held_locks_iter = held_locks_.find(grantable_request->name());\n+        if (held_locks_iter != held_locks_.end()) {\n+          // Mark existing locks as stolen and collect environments to notify\n+          for (auto& existing_lock : held_locks_iter->second) {\n+            existing_lock->mark_stolen();\n+            envs_to_notify.insert(existing_lock->env());\n+\n+            // Immediately reject the stolen lock's released_promise\n+            Local<String> error_string;\n+            if (!String::NewFromUtf8(isolate, kLockStolenError)\n+                     .ToLocal(&error_string)) {\n+              return;\n+            }\n+            Local<Value> error = Exception::Error(error_string);\n+            existing_lock->released_promise()->Reject(context, error).Check();\n+          }\n+\n+          // Remove stolen locks from current environment immediately\n+          for (auto lock_iter = held_locks_iter->second.begin();\n+               lock_iter != held_locks_iter->second.end();) {\n+            if ((*lock_iter)->env() == env) {\n+              lock_iter = held_locks_iter->second.erase(lock_iter);\n+            } else {\n+              ++lock_iter;\n+            }\n+          }\n+\n+          if (held_locks_iter->second.empty()) {\n+            held_locks_.erase(held_locks_iter);\n+          }\n+        }\n+      }\n+\n+      // Wake other environments\n+      for (Environment* target_env : envs_to_notify) {\n+        if (target_env != env) {\n+          WakeEnvironment(target_env);\n+        }\n+      }\n+    }\n+\n+    // Create and store the new granted lock\n+    auto granted_lock =\n+        std::make_shared<Lock>(env,\n+                               grantable_request->name(),\n+                               grantable_request->mode(),\n+                               grantable_request->client_id(),\n+                               grantable_request->waiting_promise(),\n+                               grantable_request->released_promise());\n+    {\n+      Mutex::ScopedLock scoped_lock(mutex_);\n+      held_locks_[grantable_request->name()].push_back(granted_lock);\n+    }\n+\n+    // Call user callback\n+    Local<Object> lock_info_obj =\n+        CreateLockInfoObject(isolate,\n+                             context,\n+                             grantable_request->name(),\n+                             grantable_request->mode(),\n+                             grantable_request->client_id());\n+    if (lock_info_obj.IsEmpty()) {\n+      return;\n+    }\n+    Local<Value> callback_arg = lock_info_obj;\n+    Local<Value> callback_result;\n+    {\n+      TryCatchScope try_catch_scope(env);\n+      if (!grantable_request->callback()\n+               ->Call(context, Undefined(isolate), 1, &callback_arg)\n+               .ToLocal(&callback_result)) {\n+        grantable_request->waiting_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, try_catch_scope.Exception())\n+            .Check();\n+        return;\n+      }\n+    }\n+\n+    // Allocate a LockHolder on the heap to safely manage the lock's lifetime\n+    // until the user's callback promise settles.\n+    auto* fulfill_holder = new LockHolder(granted_lock);\n+    auto* reject_holder = new LockHolder(granted_lock);\n+    Local<Function> on_fulfilled_callback;\n+    Local<Function> on_rejected_callback;\n+\n+    if (!Function::New(context,\n+                       OnLockCallbackFulfilled,\n+                       External::New(isolate, fulfill_holder))\n+             .ToLocal(&on_fulfilled_callback) ||\n+        !Function::New(context,\n+                       OnLockCallbackRejected,\n+                       External::New(isolate, reject_holder))\n+             .ToLocal(&on_rejected_callback)) {\n+      delete fulfill_holder;\n+      delete reject_holder;\n+      return;\n+    }\n+\n+    // Handle promise chain\n+    if (callback_result->IsPromise()) {\n+      Local<Promise> promise = callback_result.As<Promise>();\n+      if (promise->State() == Promise::kRejected) {\n+        Local<Value> rejection_value = promise->Result();\n+        grantable_request->waiting_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        grantable_request->released_promise()\n+            ->Reject(context, rejection_value)\n+            .Check();\n+        delete fulfill_holder;\n+        delete reject_holder;\n+        {\n+          Mutex::ScopedLock scoped_lock(mutex_);\n+          ReleaseLock(granted_lock.get());\n+        }\n+        ProcessQueue(env);\n+        return;\n+      } else {\n+        grantable_request->waiting_promise()\n+            ->Resolve(context, callback_result)\n+            .Check();\n+        USE(promise->Then(\n+            context, on_fulfilled_callback, on_rejected_callback));\n+      }\n+    } else {\n+      grantable_request->waiting_promise()\n+          ->Resolve(context, callback_result)\n+          .Check();\n+      Local<Value> promise_args[] = {callback_result};\n+      USE(on_fulfilled_callback->Call(\n+          context, Undefined(isolate), 1, promise_args));\n+      delete reject_holder;\n+    }\n+  }\n+}\n+\n+/**\n+ * name        : string   – resource identifier\n+ * clientId    : string   – client identifier\n+ * mode        : string   – lock mode\n+ * steal       : boolean  – whether to steal existing locks\n+ * ifAvailable : boolean  – only grant if immediately available\n+ * callback    : Function - JS callback\n+ */\n+void LockManager::Request(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  CHECK_EQ(args.Length(), 6);\n+  CHECK(args[0]->IsString());\n+  CHECK(args[1]->IsString());\n+  CHECK(args[2]->IsString());\n+  CHECK(args[3]->IsBoolean());\n+  CHECK(args[4]->IsBoolean());\n+  CHECK(args[5]->IsFunction());\n+\n+  Local<String> resource_name_str = args[0].As<String>();\n+  TwoByteValue resource_name_utf16(isolate, resource_name_str);\n+  std::u16string resource_name(\n+      reinterpret_cast<const char16_t*>(*resource_name_utf16),\n+      resource_name_utf16.length());\n+  String::Utf8Value client_id_utf8(isolate, args[1]);\n+  std::string client_id(*client_id_utf8);\n+  String::Utf8Value mode_utf8(isolate, args[2]);\n+  std::string mode_str(*mode_utf8);\n+  bool steal = args[3]->BooleanValue(isolate);\n+  bool if_available = args[4]->BooleanValue(isolate);\n+  Local<Function> callback = args[5].As<Function>();\n+\n+  Lock::Mode lock_mode =\n+      mode_str == kSharedMode ? Lock::Mode::Shared : Lock::Mode::Exclusive;\n+\n+  Local<Promise::Resolver> waiting_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&waiting_promise)) {\n+    return;\n+  }\n+  Local<Promise::Resolver> released_promise;\n+  if (!Promise::Resolver::New(context).ToLocal(&released_promise)) {\n+    return;\n+  }\n+\n+  args.GetReturnValue().Set(released_promise->GetPromise());\n+\n+  LockManager* manager = GetCurrent();\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    // Register cleanup hook for the environment only once\n+    if (manager->registered_envs_.insert(env).second) {\n+      env->AddCleanupHook(LockManager::OnEnvironmentCleanup, env);\n+    }\n+\n+    auto lock_request = std::make_unique<LockRequest>(env,\n+                                                      waiting_promise,\n+                                                      released_promise,\n+                                                      callback,\n+                                                      resource_name,\n+                                                      lock_mode,\n+                                                      client_id,\n+                                                      steal,\n+                                                      if_available);\n+    // Steal requests get priority by going to front of queue\n+    if (steal) {\n+      manager->pending_queue_.emplace_front(std::move(lock_request));\n+    } else {\n+      manager->pending_queue_.push_back(std::move(lock_request));\n+    }\n+  }\n+\n+  manager->ProcessQueue(env);\n+}\n+\n+void LockManager::Query(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env->context();\n+\n+  Local<Promise::Resolver> resolver;\n+  if (!Promise::Resolver::New(context).ToLocal(&resolver)) {\n+    return;\n+  }\n+  args.GetReturnValue().Set(resolver->GetPromise());\n+\n+  Local<Object> result = Object::New(isolate);\n+  Local<Array> held_list = Array::New(isolate);\n+  Local<Array> pending_list = Array::New(isolate);\n+  LockManager* manager = GetCurrent();\n+\n+  {\n+    Mutex::ScopedLock scoped_lock(manager->mutex_);\n+\n+    uint32_t index = 0;\n+    for (const auto& resource_entry : manager->held_locks_) {\n+      for (const auto& held_lock : resource_entry.second) {\n+        if (held_lock->env() == env) {\n+          Local<Object> lock_info =\n+              CreateLockInfoObject(isolate,\n+                                   context,\n+                                   held_lock->name(),\n+                                   held_lock->mode(),\n+                                   held_lock->client_id());\n+          if (lock_info.IsEmpty()) {\n+            return;\n+          }\n+          held_list->Set(context, index++, lock_info).Check();\n+        }\n+      }\n+    }\n+\n+    index = 0;\n+    for (const auto& pending_request : manager->pending_queue_) {\n+      if (pending_request->env() == env) {\n+        Local<Object> lock_info =",
        "comment_created_at": "2025-06-24T04:29:18+00:00",
        "comment_author": "jasnell",
        "comment_body": "Same here... if the `Local<Object> lock_info;` is moved outside of the for loops then it can just be reused here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161774530",
    "pr_number": 58797,
    "pr_file": "src/compile_cache.cc",
    "created_at": "2025-06-23T14:28:20+00:00",
    "commented_code": "Debug(\" success, size=%d\n\", total_read);\n }\n \n+#ifdef _WIN32\n+constexpr bool IsWindowsDeviceRoot(const char c) noexcept {\n+  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n+}\n+#endif\n+\n+static std::string NormalisePath(std::string_view path) {\n+  std::string normalised_string(path);\n+  constexpr std::string_view file_scheme = \"file://\";\n+  if (normalised_string.rfind(file_scheme, 0) == 0) {\n+    normalised_string.erase(0, file_scheme.size());\n+  }\n+\n+#ifdef _WIN32\n+  if (normalised_string.size() > 2 &&\n+      IsWindowsDeviceRoot(normalised_string[0]) &&\n+      normalised_string[1] == ':' &&\n+      (normalised_string[2] == '/' || normalised_string[2] == '\\\\')) {\n+    normalised_string[0] = ToLower(normalised_string[0]);\n+  }\n+#endif\n+  for (char& c : normalised_string) {\n+    if (c == '\\\\') {\n+      c = '/';\n+    }\n+  }\n+\n+  if (!normalised_string.empty() && normalised_string.back() == '/') {\n+    normalised_string.pop_back();\n+  }\n+\n+  normalised_string = NormalizeString(normalised_string, false, \"/\");\n+  return normalised_string;\n+}\n+\n+// Check if a path looks like an absolute path or file URL.\n+static bool IsAbsoluteFilePath(std::string_view path) {\n+  if (path.rfind(\"file://\", 0) == 0) {\n+    return true;\n+  }\n+#ifdef _WIN32\n+  if (path.size() > 2 && IsWindowsDeviceRoot(path[0]) &&\n+      (path[1] == ':' && (path[2] == '/' || path[2] == '\\\\')))\n+    return true;\n+  if (path.size() > 1 && path[0] == '\\\\' && path[1] == '\\\\') return true;\n+#else\n+  if (path.size() > 0 && path[0] == '/') return true;\n+#endif\n+  return false;\n+}\n+\n+static std::string GetRelativePath(std::string_view path,\n+                                   std::string_view base) {\n+// On Windows, the native encoding is UTF-16, so we need to convert\n+// the paths to wide strings before using std::filesystem::path.\n+// On other platforms, std::filesystem::path can handle UTF-8 directly.\n+#ifdef _WIN32\n+  std::wstring wpath = ConvertToWideString(std::string(path), CP_UTF8);\n+  std::wstring wbase = ConvertToWideString(std::string(base), CP_UTF8);\n+  std::filesystem::path relative =\n+      std::filesystem::path(wpath).lexically_relative(\n+          std::filesystem::path(wbase));\n+  if (relative.empty()) {\n+    return std::string();\n+  }\n+  std::string relative_path = ConvertWideToUTF8(relative.wstring());\n+  return relative_path;\n+#else\n+  std::filesystem::path relative =\n+      std::filesystem::path(path).lexically_relative(\n+          std::filesystem::path(base));\n+  if (relative.empty()) {\n+    return std::string();\n+  }\n+  return relative.generic_string();\n+#endif\n+}\n+\n CompileCacheEntry* CompileCacheHandler::GetOrInsert(Local<String> code,\n                                                     Local<String> filename,\n                                                     CachedCodeType type) {\n   DCHECK(!compile_cache_dir_.empty());\n \n   Utf8Value filename_utf8(isolate_, filename);\n-  uint32_t key = GetCacheKey(filename_utf8.ToStringView(), type);\n+  std::string file_path = filename_utf8.ToString();\n+  // If the relative path is enabled, we try to use a relative path\n+  // from the compile cache directory to the file path\n+  if (use_relative_ && IsAbsoluteFilePath(file_path)) {\n+    // Normalise the paths to ensure they are consistent.\n+    std::string normalised_file_path = NormalisePath(file_path);\n+    std::string normalised_cache_dir =",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2161774530",
        "repo_full_name": "nodejs/node",
        "pr_number": 58797,
        "pr_file": "src/compile_cache.cc",
        "discussion_id": "2161774530",
        "commented_code": "@@ -223,13 +229,109 @@ void CompileCacheHandler::ReadCacheFile(CompileCacheEntry* entry) {\n   Debug(\" success, size=%d\\n\", total_read);\n }\n \n+#ifdef _WIN32\n+constexpr bool IsWindowsDeviceRoot(const char c) noexcept {\n+  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n+}\n+#endif\n+\n+static std::string NormalisePath(std::string_view path) {\n+  std::string normalised_string(path);\n+  constexpr std::string_view file_scheme = \"file://\";\n+  if (normalised_string.rfind(file_scheme, 0) == 0) {\n+    normalised_string.erase(0, file_scheme.size());\n+  }\n+\n+#ifdef _WIN32\n+  if (normalised_string.size() > 2 &&\n+      IsWindowsDeviceRoot(normalised_string[0]) &&\n+      normalised_string[1] == ':' &&\n+      (normalised_string[2] == '/' || normalised_string[2] == '\\\\')) {\n+    normalised_string[0] = ToLower(normalised_string[0]);\n+  }\n+#endif\n+  for (char& c : normalised_string) {\n+    if (c == '\\\\') {\n+      c = '/';\n+    }\n+  }\n+\n+  if (!normalised_string.empty() && normalised_string.back() == '/') {\n+    normalised_string.pop_back();\n+  }\n+\n+  normalised_string = NormalizeString(normalised_string, false, \"/\");\n+  return normalised_string;\n+}\n+\n+// Check if a path looks like an absolute path or file URL.\n+static bool IsAbsoluteFilePath(std::string_view path) {\n+  if (path.rfind(\"file://\", 0) == 0) {\n+    return true;\n+  }\n+#ifdef _WIN32\n+  if (path.size() > 2 && IsWindowsDeviceRoot(path[0]) &&\n+      (path[1] == ':' && (path[2] == '/' || path[2] == '\\\\')))\n+    return true;\n+  if (path.size() > 1 && path[0] == '\\\\' && path[1] == '\\\\') return true;\n+#else\n+  if (path.size() > 0 && path[0] == '/') return true;\n+#endif\n+  return false;\n+}\n+\n+static std::string GetRelativePath(std::string_view path,\n+                                   std::string_view base) {\n+// On Windows, the native encoding is UTF-16, so we need to convert\n+// the paths to wide strings before using std::filesystem::path.\n+// On other platforms, std::filesystem::path can handle UTF-8 directly.\n+#ifdef _WIN32\n+  std::wstring wpath = ConvertToWideString(std::string(path), CP_UTF8);\n+  std::wstring wbase = ConvertToWideString(std::string(base), CP_UTF8);\n+  std::filesystem::path relative =\n+      std::filesystem::path(wpath).lexically_relative(\n+          std::filesystem::path(wbase));\n+  if (relative.empty()) {\n+    return std::string();\n+  }\n+  std::string relative_path = ConvertWideToUTF8(relative.wstring());\n+  return relative_path;\n+#else\n+  std::filesystem::path relative =\n+      std::filesystem::path(path).lexically_relative(\n+          std::filesystem::path(base));\n+  if (relative.empty()) {\n+    return std::string();\n+  }\n+  return relative.generic_string();\n+#endif\n+}\n+\n CompileCacheEntry* CompileCacheHandler::GetOrInsert(Local<String> code,\n                                                     Local<String> filename,\n                                                     CachedCodeType type) {\n   DCHECK(!compile_cache_dir_.empty());\n \n   Utf8Value filename_utf8(isolate_, filename);\n-  uint32_t key = GetCacheKey(filename_utf8.ToStringView(), type);\n+  std::string file_path = filename_utf8.ToString();\n+  // If the relative path is enabled, we try to use a relative path\n+  // from the compile cache directory to the file path\n+  if (use_relative_ && IsAbsoluteFilePath(file_path)) {\n+    // Normalise the paths to ensure they are consistent.\n+    std::string normalised_file_path = NormalisePath(file_path);\n+    std::string normalised_cache_dir =",
        "comment_created_at": "2025-06-23T14:28:20+00:00",
        "comment_author": "joyeecheung",
        "comment_body": "This is something we can just compute once and store in the CompileCacheHandler instance. This is currently being repeatedly computed for every path match even though it's the same every time.",
        "pr_file_module": null
      }
    ]
  }
]