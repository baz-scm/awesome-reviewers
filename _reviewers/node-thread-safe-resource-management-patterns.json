[
  {
    "discussion_id": "2084610989",
    "pr_number": 58077,
    "pr_file": "src/inspector/network_agent.cc",
    "created_at": "2025-05-12T12:53:50+00:00",
    "commented_code": "return protocol::DispatchResponse::Success();\n }\n \n+std::tuple<int, std::string, std::string> NetworkAgent::spawnFetchProcess(\n+    std::string_view code, Environment* env, std::string_view url) {\n+  std::string stdout_result;\n+  std::string stderr_result;\n+  uv_loop_t* loop = new uv_loop_t;\n+  uv_loop_init(loop);\n+  uv_process_t child;\n+  uv_pipe_t stdout_pipe;\n+  uv_pipe_init(loop, &stdout_pipe, 0);\n+  uv_pipe_t stderr_pipe;\n+  uv_pipe_init(loop, &stderr_pipe, 0);\n+\n+  uv_process_options_t uv_process_options;\n+  std::string command =\n+      env->exec_path() + \" --eval \\\"\" + code.data() + \"\\\" -- \" + url.data();\n+\n+  const char* file = env->exec_path().c_str();\n+  char* args[] = {const_cast<char*>(file),\n+                  const_cast<char*>(\"--eval\"),\n+                  reinterpret_cast<char*>(const_cast<char*>(code.data())),\n+                  reinterpret_cast<char*>(const_cast<char*>(url.data())),\n+                  nullptr};\n+\n+  uv_stdio_container_t stdio[3];\n+  uv_process_options.file = file;\n+  uv_process_options.args = args;\n+  uv_process_options.flags = 0;\n+  uv_process_options.stdio_count = 3;\n+  uv_process_options.stdio = stdio;\n+  uv_process_options.cwd = nullptr;\n+  uv_process_options.env = nullptr;\n+\n+  uv_process_options.exit_cb =\n+      [](uv_process_t* req, int64_t exit_status, int term_signal) {\n+        uv_close(reinterpret_cast<uv_handle_t*>(req), nullptr);\n+      };\n+\n+  stdio[0].flags = UV_INHERIT_FD;\n+  stdio[0].data.fd = 0;\n+  stdio[1].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[1].data.stream = reinterpret_cast<uv_stream_t*>(&stdout_pipe);\n+  stdio[2].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[2].data.stream = reinterpret_cast<uv_stream_t*>(&stderr_pipe);\n+\n+  int r = uv_spawn(loop, &child, &uv_process_options);\n+\n+  if (r != 0) {\n+    uv_loop_close(loop);\n+    delete loop;\n+    return {r, stdout_result, stderr_result};\n+  }\n+\n+  auto alloc_cb =\n+      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {\n+        buf->base = static_cast<char*>(malloc(suggested_size));\n+        buf->len = suggested_size;\n+      };\n+\n+  auto read_cb = [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    auto* response = static_cast<std::string*>(stream->data);\n+    if (nread > 0) {\n+      response->append(buf->base, nread);\n+    } else if (nread < 0) {\n+      if (!response->empty() && response->back() == '\n') {\n+        response->pop_back();\n+      }\n+      uv_close(reinterpret_cast<uv_handle_t*>(stream), nullptr);\n+    }\n+    if (buf->base) free(buf->base);\n+  };\n+\n+  stdout_pipe.data = &stdout_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stdout_pipe), alloc_cb, read_cb);\n+\n+  stderr_pipe.data = &stderr_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stderr_pipe), alloc_cb, read_cb);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_walk(\n+      loop,\n+      [](uv_handle_t* handle, void*) {\n+        if (!uv_is_closing(handle)) {\n+          uv_close(handle, nullptr);\n+        }\n+      },\n+      nullptr);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_loop_close(loop);\n+  delete loop;\n+  return {r, stdout_result, stderr_result};\n+}\n+\n+protocol::DispatchResponse NetworkAgent::loadNetworkResource(\n+    const protocol::String& in_url,\n+    std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult>*\n+        out_resource) {\n+  if (!env_->options()->experimental_inspector_network_resource) {\n+    return protocol::DispatchResponse::MethodNotFound(\n+        \"Network.loadNetworkResource is not supported in this environment. \"\n+        \"Please enable the experimental-inspector-network-resource option.\");\n+  }\n+  DCHECK(io_agent_);\n+\n+  std::string code = R\"(\n+      fetch(process.argv[1], {signal: AbortSignal.timeout(2000) }).then(res => {\n+        if (res.ok) {\n+          res.text().then(console.log)\n+        } else {\n+          throw new Error('Network error: ' + res.status);\n+        }\n+      })\n+    )\";\n+\n+  auto [r, response, err] = spawnFetchProcess(code, env_, in_url);",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2084610989",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_agent.cc",
        "discussion_id": "2084610989",
        "commented_code": "@@ -211,6 +221,146 @@ protocol::DispatchResponse NetworkAgent::disable() {\n   return protocol::DispatchResponse::Success();\n }\n \n+std::tuple<int, std::string, std::string> NetworkAgent::spawnFetchProcess(\n+    std::string_view code, Environment* env, std::string_view url) {\n+  std::string stdout_result;\n+  std::string stderr_result;\n+  uv_loop_t* loop = new uv_loop_t;\n+  uv_loop_init(loop);\n+  uv_process_t child;\n+  uv_pipe_t stdout_pipe;\n+  uv_pipe_init(loop, &stdout_pipe, 0);\n+  uv_pipe_t stderr_pipe;\n+  uv_pipe_init(loop, &stderr_pipe, 0);\n+\n+  uv_process_options_t uv_process_options;\n+  std::string command =\n+      env->exec_path() + \" --eval \\\"\" + code.data() + \"\\\" -- \" + url.data();\n+\n+  const char* file = env->exec_path().c_str();\n+  char* args[] = {const_cast<char*>(file),\n+                  const_cast<char*>(\"--eval\"),\n+                  reinterpret_cast<char*>(const_cast<char*>(code.data())),\n+                  reinterpret_cast<char*>(const_cast<char*>(url.data())),\n+                  nullptr};\n+\n+  uv_stdio_container_t stdio[3];\n+  uv_process_options.file = file;\n+  uv_process_options.args = args;\n+  uv_process_options.flags = 0;\n+  uv_process_options.stdio_count = 3;\n+  uv_process_options.stdio = stdio;\n+  uv_process_options.cwd = nullptr;\n+  uv_process_options.env = nullptr;\n+\n+  uv_process_options.exit_cb =\n+      [](uv_process_t* req, int64_t exit_status, int term_signal) {\n+        uv_close(reinterpret_cast<uv_handle_t*>(req), nullptr);\n+      };\n+\n+  stdio[0].flags = UV_INHERIT_FD;\n+  stdio[0].data.fd = 0;\n+  stdio[1].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[1].data.stream = reinterpret_cast<uv_stream_t*>(&stdout_pipe);\n+  stdio[2].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[2].data.stream = reinterpret_cast<uv_stream_t*>(&stderr_pipe);\n+\n+  int r = uv_spawn(loop, &child, &uv_process_options);\n+\n+  if (r != 0) {\n+    uv_loop_close(loop);\n+    delete loop;\n+    return {r, stdout_result, stderr_result};\n+  }\n+\n+  auto alloc_cb =\n+      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {\n+        buf->base = static_cast<char*>(malloc(suggested_size));\n+        buf->len = suggested_size;\n+      };\n+\n+  auto read_cb = [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    auto* response = static_cast<std::string*>(stream->data);\n+    if (nread > 0) {\n+      response->append(buf->base, nread);\n+    } else if (nread < 0) {\n+      if (!response->empty() && response->back() == '\\n') {\n+        response->pop_back();\n+      }\n+      uv_close(reinterpret_cast<uv_handle_t*>(stream), nullptr);\n+    }\n+    if (buf->base) free(buf->base);\n+  };\n+\n+  stdout_pipe.data = &stdout_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stdout_pipe), alloc_cb, read_cb);\n+\n+  stderr_pipe.data = &stderr_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stderr_pipe), alloc_cb, read_cb);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_walk(\n+      loop,\n+      [](uv_handle_t* handle, void*) {\n+        if (!uv_is_closing(handle)) {\n+          uv_close(handle, nullptr);\n+        }\n+      },\n+      nullptr);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_loop_close(loop);\n+  delete loop;\n+  return {r, stdout_result, stderr_result};\n+}\n+\n+protocol::DispatchResponse NetworkAgent::loadNetworkResource(\n+    const protocol::String& in_url,\n+    std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult>*\n+        out_resource) {\n+  if (!env_->options()->experimental_inspector_network_resource) {\n+    return protocol::DispatchResponse::MethodNotFound(\n+        \"Network.loadNetworkResource is not supported in this environment. \"\n+        \"Please enable the experimental-inspector-network-resource option.\");\n+  }\n+  DCHECK(io_agent_);\n+\n+  std::string code = R\"(\n+      fetch(process.argv[1], {signal: AbortSignal.timeout(2000) }).then(res => {\n+        if (res.ok) {\n+          res.text().then(console.log)\n+        } else {\n+          throw new Error('Network error: ' + res.status);\n+        }\n+      })\n+    )\";\n+\n+  auto [r, response, err] = spawnFetchProcess(code, env_, in_url);",
        "comment_created_at": "2025-05-12T12:53:50+00:00",
        "comment_author": "legendecas",
        "comment_body": "I am not a fan of spawning a Node.js process for each `Network.loadNetworkResource` request from devtools frontend. A devtool frontend may call this method multiple times simultaneously if there are several source maps and spawning a Node.js process for each of them seems superfluous and resource draining.\r\n\r\nAs an alternative, we could expose this as a hook to JS inspector API so that it will be properly covered by environment variables like `HTTP_PROXY` and the permission model. Additionally, this allows the JS API hook to filter which domain the process is allowed to send request to.",
        "pr_file_module": null
      },
      {
        "comment_id": "2094299784",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_agent.cc",
        "discussion_id": "2084610989",
        "commented_code": "@@ -211,6 +221,146 @@ protocol::DispatchResponse NetworkAgent::disable() {\n   return protocol::DispatchResponse::Success();\n }\n \n+std::tuple<int, std::string, std::string> NetworkAgent::spawnFetchProcess(\n+    std::string_view code, Environment* env, std::string_view url) {\n+  std::string stdout_result;\n+  std::string stderr_result;\n+  uv_loop_t* loop = new uv_loop_t;\n+  uv_loop_init(loop);\n+  uv_process_t child;\n+  uv_pipe_t stdout_pipe;\n+  uv_pipe_init(loop, &stdout_pipe, 0);\n+  uv_pipe_t stderr_pipe;\n+  uv_pipe_init(loop, &stderr_pipe, 0);\n+\n+  uv_process_options_t uv_process_options;\n+  std::string command =\n+      env->exec_path() + \" --eval \\\"\" + code.data() + \"\\\" -- \" + url.data();\n+\n+  const char* file = env->exec_path().c_str();\n+  char* args[] = {const_cast<char*>(file),\n+                  const_cast<char*>(\"--eval\"),\n+                  reinterpret_cast<char*>(const_cast<char*>(code.data())),\n+                  reinterpret_cast<char*>(const_cast<char*>(url.data())),\n+                  nullptr};\n+\n+  uv_stdio_container_t stdio[3];\n+  uv_process_options.file = file;\n+  uv_process_options.args = args;\n+  uv_process_options.flags = 0;\n+  uv_process_options.stdio_count = 3;\n+  uv_process_options.stdio = stdio;\n+  uv_process_options.cwd = nullptr;\n+  uv_process_options.env = nullptr;\n+\n+  uv_process_options.exit_cb =\n+      [](uv_process_t* req, int64_t exit_status, int term_signal) {\n+        uv_close(reinterpret_cast<uv_handle_t*>(req), nullptr);\n+      };\n+\n+  stdio[0].flags = UV_INHERIT_FD;\n+  stdio[0].data.fd = 0;\n+  stdio[1].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[1].data.stream = reinterpret_cast<uv_stream_t*>(&stdout_pipe);\n+  stdio[2].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[2].data.stream = reinterpret_cast<uv_stream_t*>(&stderr_pipe);\n+\n+  int r = uv_spawn(loop, &child, &uv_process_options);\n+\n+  if (r != 0) {\n+    uv_loop_close(loop);\n+    delete loop;\n+    return {r, stdout_result, stderr_result};\n+  }\n+\n+  auto alloc_cb =\n+      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {\n+        buf->base = static_cast<char*>(malloc(suggested_size));\n+        buf->len = suggested_size;\n+      };\n+\n+  auto read_cb = [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    auto* response = static_cast<std::string*>(stream->data);\n+    if (nread > 0) {\n+      response->append(buf->base, nread);\n+    } else if (nread < 0) {\n+      if (!response->empty() && response->back() == '\\n') {\n+        response->pop_back();\n+      }\n+      uv_close(reinterpret_cast<uv_handle_t*>(stream), nullptr);\n+    }\n+    if (buf->base) free(buf->base);\n+  };\n+\n+  stdout_pipe.data = &stdout_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stdout_pipe), alloc_cb, read_cb);\n+\n+  stderr_pipe.data = &stderr_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stderr_pipe), alloc_cb, read_cb);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_walk(\n+      loop,\n+      [](uv_handle_t* handle, void*) {\n+        if (!uv_is_closing(handle)) {\n+          uv_close(handle, nullptr);\n+        }\n+      },\n+      nullptr);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_loop_close(loop);\n+  delete loop;\n+  return {r, stdout_result, stderr_result};\n+}\n+\n+protocol::DispatchResponse NetworkAgent::loadNetworkResource(\n+    const protocol::String& in_url,\n+    std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult>*\n+        out_resource) {\n+  if (!env_->options()->experimental_inspector_network_resource) {\n+    return protocol::DispatchResponse::MethodNotFound(\n+        \"Network.loadNetworkResource is not supported in this environment. \"\n+        \"Please enable the experimental-inspector-network-resource option.\");\n+  }\n+  DCHECK(io_agent_);\n+\n+  std::string code = R\"(\n+      fetch(process.argv[1], {signal: AbortSignal.timeout(2000) }).then(res => {\n+        if (res.ok) {\n+          res.text().then(console.log)\n+        } else {\n+          throw new Error('Network error: ' + res.status);\n+        }\n+      })\n+    )\";\n+\n+  auto [r, response, err] = spawnFetchProcess(code, env_, in_url);",
        "comment_created_at": "2025-05-18T01:25:49+00:00",
        "comment_author": "islandryu",
        "comment_body": "If we hook into the JavaScript side, wouldn\u2019t it end up running on the same event loop as the main script?\r\nIf the code breaks before the fetch process for loadNetworkResource completes, it could cause a problem where the resource can\u2019t be fully retrieved.\r\n\r\nThat said, as you pointed out, spawning a new process every time would consume a lot of resources, which is also problematic.\r\nSo I\u2019m considering other approaches that don\u2019t interfere with the event loop.",
        "pr_file_module": null
      },
      {
        "comment_id": "2098075677",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_agent.cc",
        "discussion_id": "2084610989",
        "commented_code": "@@ -211,6 +221,146 @@ protocol::DispatchResponse NetworkAgent::disable() {\n   return protocol::DispatchResponse::Success();\n }\n \n+std::tuple<int, std::string, std::string> NetworkAgent::spawnFetchProcess(\n+    std::string_view code, Environment* env, std::string_view url) {\n+  std::string stdout_result;\n+  std::string stderr_result;\n+  uv_loop_t* loop = new uv_loop_t;\n+  uv_loop_init(loop);\n+  uv_process_t child;\n+  uv_pipe_t stdout_pipe;\n+  uv_pipe_init(loop, &stdout_pipe, 0);\n+  uv_pipe_t stderr_pipe;\n+  uv_pipe_init(loop, &stderr_pipe, 0);\n+\n+  uv_process_options_t uv_process_options;\n+  std::string command =\n+      env->exec_path() + \" --eval \\\"\" + code.data() + \"\\\" -- \" + url.data();\n+\n+  const char* file = env->exec_path().c_str();\n+  char* args[] = {const_cast<char*>(file),\n+                  const_cast<char*>(\"--eval\"),\n+                  reinterpret_cast<char*>(const_cast<char*>(code.data())),\n+                  reinterpret_cast<char*>(const_cast<char*>(url.data())),\n+                  nullptr};\n+\n+  uv_stdio_container_t stdio[3];\n+  uv_process_options.file = file;\n+  uv_process_options.args = args;\n+  uv_process_options.flags = 0;\n+  uv_process_options.stdio_count = 3;\n+  uv_process_options.stdio = stdio;\n+  uv_process_options.cwd = nullptr;\n+  uv_process_options.env = nullptr;\n+\n+  uv_process_options.exit_cb =\n+      [](uv_process_t* req, int64_t exit_status, int term_signal) {\n+        uv_close(reinterpret_cast<uv_handle_t*>(req), nullptr);\n+      };\n+\n+  stdio[0].flags = UV_INHERIT_FD;\n+  stdio[0].data.fd = 0;\n+  stdio[1].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[1].data.stream = reinterpret_cast<uv_stream_t*>(&stdout_pipe);\n+  stdio[2].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[2].data.stream = reinterpret_cast<uv_stream_t*>(&stderr_pipe);\n+\n+  int r = uv_spawn(loop, &child, &uv_process_options);\n+\n+  if (r != 0) {\n+    uv_loop_close(loop);\n+    delete loop;\n+    return {r, stdout_result, stderr_result};\n+  }\n+\n+  auto alloc_cb =\n+      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {\n+        buf->base = static_cast<char*>(malloc(suggested_size));\n+        buf->len = suggested_size;\n+      };\n+\n+  auto read_cb = [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    auto* response = static_cast<std::string*>(stream->data);\n+    if (nread > 0) {\n+      response->append(buf->base, nread);\n+    } else if (nread < 0) {\n+      if (!response->empty() && response->back() == '\\n') {\n+        response->pop_back();\n+      }\n+      uv_close(reinterpret_cast<uv_handle_t*>(stream), nullptr);\n+    }\n+    if (buf->base) free(buf->base);\n+  };\n+\n+  stdout_pipe.data = &stdout_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stdout_pipe), alloc_cb, read_cb);\n+\n+  stderr_pipe.data = &stderr_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stderr_pipe), alloc_cb, read_cb);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_walk(\n+      loop,\n+      [](uv_handle_t* handle, void*) {\n+        if (!uv_is_closing(handle)) {\n+          uv_close(handle, nullptr);\n+        }\n+      },\n+      nullptr);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_loop_close(loop);\n+  delete loop;\n+  return {r, stdout_result, stderr_result};\n+}\n+\n+protocol::DispatchResponse NetworkAgent::loadNetworkResource(\n+    const protocol::String& in_url,\n+    std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult>*\n+        out_resource) {\n+  if (!env_->options()->experimental_inspector_network_resource) {\n+    return protocol::DispatchResponse::MethodNotFound(\n+        \"Network.loadNetworkResource is not supported in this environment. \"\n+        \"Please enable the experimental-inspector-network-resource option.\");\n+  }\n+  DCHECK(io_agent_);\n+\n+  std::string code = R\"(\n+      fetch(process.argv[1], {signal: AbortSignal.timeout(2000) }).then(res => {\n+        if (res.ok) {\n+          res.text().then(console.log)\n+        } else {\n+          throw new Error('Network error: ' + res.status);\n+        }\n+      })\n+    )\";\n+\n+  auto [r, response, err] = spawnFetchProcess(code, env_, in_url);",
        "comment_created_at": "2025-05-20T14:05:09+00:00",
        "comment_author": "joyeecheung",
        "comment_body": "Maybe spawning a worker thread would be a good enough compromise for the moment?",
        "pr_file_module": null
      },
      {
        "comment_id": "2099730929",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_agent.cc",
        "discussion_id": "2084610989",
        "commented_code": "@@ -211,6 +221,146 @@ protocol::DispatchResponse NetworkAgent::disable() {\n   return protocol::DispatchResponse::Success();\n }\n \n+std::tuple<int, std::string, std::string> NetworkAgent::spawnFetchProcess(\n+    std::string_view code, Environment* env, std::string_view url) {\n+  std::string stdout_result;\n+  std::string stderr_result;\n+  uv_loop_t* loop = new uv_loop_t;\n+  uv_loop_init(loop);\n+  uv_process_t child;\n+  uv_pipe_t stdout_pipe;\n+  uv_pipe_init(loop, &stdout_pipe, 0);\n+  uv_pipe_t stderr_pipe;\n+  uv_pipe_init(loop, &stderr_pipe, 0);\n+\n+  uv_process_options_t uv_process_options;\n+  std::string command =\n+      env->exec_path() + \" --eval \\\"\" + code.data() + \"\\\" -- \" + url.data();\n+\n+  const char* file = env->exec_path().c_str();\n+  char* args[] = {const_cast<char*>(file),\n+                  const_cast<char*>(\"--eval\"),\n+                  reinterpret_cast<char*>(const_cast<char*>(code.data())),\n+                  reinterpret_cast<char*>(const_cast<char*>(url.data())),\n+                  nullptr};\n+\n+  uv_stdio_container_t stdio[3];\n+  uv_process_options.file = file;\n+  uv_process_options.args = args;\n+  uv_process_options.flags = 0;\n+  uv_process_options.stdio_count = 3;\n+  uv_process_options.stdio = stdio;\n+  uv_process_options.cwd = nullptr;\n+  uv_process_options.env = nullptr;\n+\n+  uv_process_options.exit_cb =\n+      [](uv_process_t* req, int64_t exit_status, int term_signal) {\n+        uv_close(reinterpret_cast<uv_handle_t*>(req), nullptr);\n+      };\n+\n+  stdio[0].flags = UV_INHERIT_FD;\n+  stdio[0].data.fd = 0;\n+  stdio[1].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[1].data.stream = reinterpret_cast<uv_stream_t*>(&stdout_pipe);\n+  stdio[2].flags =\n+      static_cast<uv_stdio_flags>(UV_CREATE_PIPE | UV_WRITABLE_PIPE);\n+  stdio[2].data.stream = reinterpret_cast<uv_stream_t*>(&stderr_pipe);\n+\n+  int r = uv_spawn(loop, &child, &uv_process_options);\n+\n+  if (r != 0) {\n+    uv_loop_close(loop);\n+    delete loop;\n+    return {r, stdout_result, stderr_result};\n+  }\n+\n+  auto alloc_cb =\n+      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {\n+        buf->base = static_cast<char*>(malloc(suggested_size));\n+        buf->len = suggested_size;\n+      };\n+\n+  auto read_cb = [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    auto* response = static_cast<std::string*>(stream->data);\n+    if (nread > 0) {\n+      response->append(buf->base, nread);\n+    } else if (nread < 0) {\n+      if (!response->empty() && response->back() == '\\n') {\n+        response->pop_back();\n+      }\n+      uv_close(reinterpret_cast<uv_handle_t*>(stream), nullptr);\n+    }\n+    if (buf->base) free(buf->base);\n+  };\n+\n+  stdout_pipe.data = &stdout_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stdout_pipe), alloc_cb, read_cb);\n+\n+  stderr_pipe.data = &stderr_result;\n+  uv_read_start(\n+      reinterpret_cast<uv_stream_t*>(&stderr_pipe), alloc_cb, read_cb);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_walk(\n+      loop,\n+      [](uv_handle_t* handle, void*) {\n+        if (!uv_is_closing(handle)) {\n+          uv_close(handle, nullptr);\n+        }\n+      },\n+      nullptr);\n+\n+  uv_run(loop, UV_RUN_DEFAULT);\n+\n+  uv_loop_close(loop);\n+  delete loop;\n+  return {r, stdout_result, stderr_result};\n+}\n+\n+protocol::DispatchResponse NetworkAgent::loadNetworkResource(\n+    const protocol::String& in_url,\n+    std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult>*\n+        out_resource) {\n+  if (!env_->options()->experimental_inspector_network_resource) {\n+    return protocol::DispatchResponse::MethodNotFound(\n+        \"Network.loadNetworkResource is not supported in this environment. \"\n+        \"Please enable the experimental-inspector-network-resource option.\");\n+  }\n+  DCHECK(io_agent_);\n+\n+  std::string code = R\"(\n+      fetch(process.argv[1], {signal: AbortSignal.timeout(2000) }).then(res => {\n+        if (res.ok) {\n+          res.text().then(console.log)\n+        } else {\n+          throw new Error('Network error: ' + res.status);\n+        }\n+      })\n+    )\";\n+\n+  auto [r, response, err] = spawnFetchProcess(code, env_, in_url);",
        "comment_created_at": "2025-05-21T08:46:30+00:00",
        "comment_author": "islandryu",
        "comment_body": "That sounds like a good.\r\nI had excluded worker_thread from consideration because it also gets targeted by the debugger,\r\nbut I\u2019ll add a flag to prevent it from being targeted by the debugger.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2171982716",
    "pr_number": 58077,
    "pr_file": "src/inspector/network_resource_manager.h",
    "created_at": "2025-06-27T12:50:10+00:00",
    "commented_code": "+// network_resource_manager.h\n+#ifndef SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+#define SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+\n+#include <atomic>\n+#include <string>\n+#include <unordered_map>\n+\n+namespace node {\n+namespace inspector {\n+\n+class NetworkResourceManager {\n+ public:\n+  static void Put(const std::string& url, const std::string& data);",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2171982716",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_resource_manager.h",
        "discussion_id": "2171982716",
        "commented_code": "@@ -0,0 +1,34 @@\n+// network_resource_manager.h\n+#ifndef SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+#define SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+\n+#include <atomic>\n+#include <string>\n+#include <unordered_map>\n+\n+namespace node {\n+namespace inspector {\n+\n+class NetworkResourceManager {\n+ public:\n+  static void Put(const std::string& url, const std::string& data);",
        "comment_created_at": "2025-06-27T12:50:10+00:00",
        "comment_author": "legendecas",
        "comment_body": "The `put` can be invoked from `worker_threads` as well. This should avoid to be a static instance to be thread-safe.",
        "pr_file_module": null
      },
      {
        "comment_id": "2173812403",
        "repo_full_name": "nodejs/node",
        "pr_number": 58077,
        "pr_file": "src/inspector/network_resource_manager.h",
        "discussion_id": "2171982716",
        "commented_code": "@@ -0,0 +1,34 @@\n+// network_resource_manager.h\n+#ifndef SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+#define SRC_INSPECTOR_NETWORK_RESOURCE_MANAGER_H_\n+\n+#include <atomic>\n+#include <string>\n+#include <unordered_map>\n+\n+namespace node {\n+namespace inspector {\n+\n+class NetworkResourceManager {\n+ public:\n+  static void Put(const std::string& url, const std::string& data);",
        "comment_created_at": "2025-06-29T15:52:24+00:00",
        "comment_author": "islandryu",
        "comment_body": "I replaced the static class with an instance-based implementation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2138801283",
    "pr_number": 58666,
    "pr_file": "src/node_locks.cc",
    "created_at": "2025-06-10T21:32:16+00:00",
    "commented_code": "+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+namespace worker {\n+namespace locks {\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+Lock::~Lock() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+LockRequest::~LockRequest() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+  callback_.Reset();\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::kExclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::kExclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback settles\n+static void OnLockCallbackSettled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<std::shared_ptr<Lock>*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = *lock_holder;\n+  delete lock_holder;",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2138801283",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2138801283",
        "commented_code": "@@ -0,0 +1,684 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+namespace worker {\n+namespace locks {\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+Lock::~Lock() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+LockRequest::~LockRequest() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+  callback_.Reset();\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::kExclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::kExclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback settles\n+static void OnLockCallbackSettled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<std::shared_ptr<Lock>*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = *lock_holder;\n+  delete lock_holder;",
        "comment_created_at": "2025-06-10T21:32:16+00:00",
        "comment_author": "jasnell",
        "comment_body": "This pattern looks... odd... and likely a bit error prone. We generally prefer the use of smart pointers to explicit use of `delete` and this could use some comments around it so it's clear what is happening here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140913983",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2138801283",
        "commented_code": "@@ -0,0 +1,684 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+namespace worker {\n+namespace locks {\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+static Local<Object> CreateLockInfoObject(Isolate* isolate,\n+                                          Local<Context> context,\n+                                          const std::u16string& name,\n+                                          Lock::Mode mode,\n+                                          const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+Lock::~Lock() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+LockRequest::~LockRequest() {\n+  waiting_promise_.Reset();\n+  released_promise_.Reset();\n+  callback_.Reset();\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::kExclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::kExclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback settles\n+static void OnLockCallbackSettled(\n+    const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<std::shared_ptr<Lock>*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = *lock_holder;\n+  delete lock_holder;",
        "comment_created_at": "2025-06-11T19:27:05+00:00",
        "comment_author": "IlyasShabi",
        "comment_body": "Im using a `LockHolder` class instead of the raw pointer to shared_ptr pattern,  I think that this eliminates error prone design as you said. could you please double check?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174766646",
    "pr_number": 58666,
    "pr_file": "src/node_locks.cc",
    "created_at": "2025-06-30T10:37:36+00:00",
    "commented_code": "+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2174766646",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2174766646",
        "commented_code": "@@ -0,0 +1,934 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
        "comment_created_at": "2025-06-30T10:37:36+00:00",
        "comment_author": "jasnell",
        "comment_body": "These's aren't correct here. You really should not be holding a `v8::Global<T>` inside a `v8::External`, then deleting it like this. It's fine to use indirection through another type... e.g. having the `External` hold an instance of a struct that is holding the `Global<T>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2179546834",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2174766646",
        "commented_code": "@@ -0,0 +1,934 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
        "comment_created_at": "2025-07-02T09:13:19+00:00",
        "comment_author": "IlyasShabi",
        "comment_body": "I did experiment with a wrapper that let the callback own a\u2028`std::unique_ptr`, so the `Global<\u2026>` would be reset automatically, but that changed the timing of the reset and introduced a race that broke the WPT and hanging tests sometimes.\r\n\r\nI think that the current pattern is also valid since the Global is reset and freed immediately in the callback and the raw pointer\u2019s ownership is transferred with `release()`. Wdyt ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2180048287",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2174766646",
        "commented_code": "@@ -0,0 +1,934 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
        "comment_created_at": "2025-07-02T13:19:08+00:00",
        "comment_author": "jasnell",
        "comment_body": "I ought to be able to take another look this afternoon. Just catching up after two week of being out of the office ;-) ... just mentioning because I didn't want you to feel I was ignoring your pings on this ;-) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2182279827",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2174766646",
        "commented_code": "@@ -0,0 +1,934 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
        "comment_created_at": "2025-07-03T09:13:03+00:00",
        "comment_author": "IlyasShabi",
        "comment_body": "Take your time, thanks for your help ",
        "pr_file_module": null
      },
      {
        "comment_id": "2197061970",
        "repo_full_name": "nodejs/node",
        "pr_number": 58666,
        "pr_file": "src/node_locks.cc",
        "discussion_id": "2174766646",
        "commented_code": "@@ -0,0 +1,934 @@\n+#include \"node_locks.h\"\n+\n+#include \"env-inl.h\"\n+#include \"node_errors.h\"\n+#include \"node_external_reference.h\"\n+#include \"node_internals.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node::worker::locks {\n+\n+using node::errors::TryCatchScope;\n+using v8::Array;\n+using v8::Context;\n+using v8::Exception;\n+using v8::External;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::Global;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::ObjectTemplate;\n+using v8::Promise;\n+using v8::String;\n+using v8::Value;\n+\n+static constexpr const char* kSharedMode = \"shared\";\n+static constexpr const char* kExclusiveMode = \"exclusive\";\n+static constexpr const char* kLockStolenError = \"LOCK_STOLEN\";\n+\n+// Reject two promises and return `false` on failure.\n+static bool RejectBoth(v8::Local<v8::Context> ctx,\n+                       v8::Local<v8::Promise::Resolver> first,\n+                       v8::Local<v8::Promise::Resolver> second,\n+                       v8::Local<v8::Value> reason) {\n+  if (first->Reject(ctx, reason).IsNothing()) return false;\n+  if (second->Reject(ctx, reason).IsNothing()) return false;\n+\n+  return true;\n+}\n+\n+static MaybeLocal<Object> CreateLockInfoObject(Isolate* isolate,\n+                                               Local<Context> context,\n+                                               const std::u16string& name,\n+                                               Lock::Mode mode,\n+                                               const std::string& client_id);\n+\n+Lock::Lock(Environment* env,\n+           const std::u16string& name,\n+           Mode mode,\n+           const std::string& client_id,\n+           Local<Promise::Resolver> waiting,\n+           Local<Promise::Resolver> released)\n+    : env_(env), name_(name), mode_(mode), client_id_(client_id) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+}\n+\n+LockRequest::LockRequest(Environment* env,\n+                         Local<Promise::Resolver> waiting,\n+                         Local<Promise::Resolver> released,\n+                         Local<Function> callback,\n+                         const std::u16string& name,\n+                         Lock::Mode mode,\n+                         const std::string& client_id,\n+                         bool steal,\n+                         bool if_available)\n+    : env_(env),\n+      name_(name),\n+      mode_(mode),\n+      client_id_(client_id),\n+      steal_(steal),\n+      if_available_(if_available) {\n+  waiting_promise_.Reset(env_->isolate(), waiting);\n+  released_promise_.Reset(env_->isolate(), released);\n+  callback_.Reset(env_->isolate(), callback);\n+}\n+\n+bool LockManager::IsGrantable(const LockRequest* request) const {\n+  // Steal requests bypass all normal granting rules\n+  if (request->steal()) return true;\n+\n+  auto held_locks_iter = held_locks_.find(request->name());\n+  // No existing locks for this resource name\n+  if (held_locks_iter == held_locks_.end()) return true;\n+\n+  // Exclusive requests cannot coexist with any existing locks\n+  if (request->mode() == Lock::Mode::Exclusive) return false;\n+\n+  // For shared requests, check if any existing lock is exclusive\n+  for (const auto& existing_lock : held_locks_iter->second) {\n+    if (existing_lock->mode() == Lock::Mode::Exclusive) return false;\n+  }\n+  // All existing locks are shared, so this shared request can be granted\n+  return true;\n+}\n+\n+// Called when the user callback promise fulfills\n+static void OnLockCallbackFulfilled(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  // Extract the LockHolder from V8 External data\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  // Release the lock and continue processing the queue.\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], false);\n+}\n+\n+// Called when the user callback promise rejects\n+static void OnLockCallbackRejected(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  Environment* env = Environment::GetCurrent(info);\n+\n+  auto* lock_holder =\n+      static_cast<LockHolder*>(info.Data().As<External>()->Value());\n+  std::shared_ptr<Lock> lock = lock_holder->lock();\n+  delete lock_holder;\n+\n+  LockManager::GetCurrent()->ReleaseLockAndProcessQueue(\n+      env, lock, info[0], true);\n+}\n+\n+// Called when the promise returned from the user's callback resolves\n+static void OnIfAvailableFulfill(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(\n+      info.Data().As<External>()->Value());\n+  USE(holder->Get(info.GetIsolate())\n+          ->Resolve(info.GetIsolate()->GetCurrentContext(), info[0]));\n+  holder->Reset();\n+  delete holder;\n+}\n+\n+// Called when the promise returned from the user's callback rejects\n+static void OnIfAvailableReject(const FunctionCallbackInfo<Value>& info) {\n+  HandleScope handle_scope(info.GetIsolate());\n+  auto* holder = static_cast<Global<Promise::Resolver>*>(",
        "comment_created_at": "2025-07-10T09:02:58+00:00",
        "comment_author": "IlyasShabi",
        "comment_body": "@jasnell Did you manage to take another look on this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945610664",
    "pr_number": 56929,
    "pr_file": "src/inspector/main_thread_interface.cc",
    "created_at": "2025-02-06T23:26:23+00:00",
    "commented_code": "}\n \n void MainThreadInterface::DispatchMessages() {\n-  if (dispatching_messages_)\n-    return;\n-  dispatching_messages_ = true;\n-  bool had_messages = false;\n-  do {\n-    if (dispatching_message_queue_.empty()) {\n-      Mutex::ScopedLock scoped_lock(requests_lock_);\n-      requests_.swap(dispatching_message_queue_);\n-    }\n-    had_messages = !dispatching_message_queue_.empty();\n-    while (!dispatching_message_queue_.empty()) {\n-      MessageQueue::value_type task;\n-      std::swap(dispatching_message_queue_.front(), task);\n-      dispatching_message_queue_.pop_front();\n-\n-      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());\n-      task->Call(this);\n-    }\n-  } while (had_messages);\n-  dispatching_messages_ = false;\n+  bool expected = false;\n+  // compare_exchange_strong returns true if the value was successfully changed\n+  // from false to true.\n+  if (dispatching_messages_.compare_exchange_strong(\n+          expected,\n+          true,\n+          std::memory_order_acquire,\n+          std::memory_order_relaxed)) {\n+    bool had_messages = false;\n+    do {\n+      if (dispatching_message_queue_.empty()) {\n+        Mutex::ScopedLock scoped_lock(requests_lock_);\n+        requests_.swap(dispatching_message_queue_);\n+      }\n+      had_messages = !dispatching_message_queue_.empty();\n+      while (!dispatching_message_queue_.empty()) {\n+        MessageQueue::value_type task;\n+        std::swap(dispatching_message_queue_.front(), task);\n+        dispatching_message_queue_.pop_front();\n+\n+        v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "1945610664",
        "repo_full_name": "nodejs/node",
        "pr_number": 56929,
        "pr_file": "src/inspector/main_thread_interface.cc",
        "discussion_id": "1945610664",
        "commented_code": "@@ -240,26 +240,32 @@ void MainThreadInterface::StopWaitingForFrontendEvent() {\n }\n \n void MainThreadInterface::DispatchMessages() {\n-  if (dispatching_messages_)\n-    return;\n-  dispatching_messages_ = true;\n-  bool had_messages = false;\n-  do {\n-    if (dispatching_message_queue_.empty()) {\n-      Mutex::ScopedLock scoped_lock(requests_lock_);\n-      requests_.swap(dispatching_message_queue_);\n-    }\n-    had_messages = !dispatching_message_queue_.empty();\n-    while (!dispatching_message_queue_.empty()) {\n-      MessageQueue::value_type task;\n-      std::swap(dispatching_message_queue_.front(), task);\n-      dispatching_message_queue_.pop_front();\n-\n-      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());\n-      task->Call(this);\n-    }\n-  } while (had_messages);\n-  dispatching_messages_ = false;\n+  bool expected = false;\n+  // compare_exchange_strong returns true if the value was successfully changed\n+  // from false to true.\n+  if (dispatching_messages_.compare_exchange_strong(\n+          expected,\n+          true,\n+          std::memory_order_acquire,\n+          std::memory_order_relaxed)) {\n+    bool had_messages = false;\n+    do {\n+      if (dispatching_message_queue_.empty()) {\n+        Mutex::ScopedLock scoped_lock(requests_lock_);\n+        requests_.swap(dispatching_message_queue_);\n+      }\n+      had_messages = !dispatching_message_queue_.empty();\n+      while (!dispatching_message_queue_.empty()) {\n+        MessageQueue::value_type task;\n+        std::swap(dispatching_message_queue_.front(), task);\n+        dispatching_message_queue_.pop_front();\n+\n+        v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());",
        "comment_created_at": "2025-02-06T23:26:23+00:00",
        "comment_author": "legendecas",
        "comment_body": "`MainThreadInterface::DispatchMessages` accesses the `Isolate` and can only be accessed on the JavaScript thread. The `dispatching_messages_` is only a guard for re-entrance and is not intended to be used across multiple threads.\r\n\r\nhttps://github.com/nodejs/node/blob/4355b3f16294aaf456ed6b9f2fc05bb0d407d788/src/inspector/main_thread_interface.cc#L222-L224\r\n\r\nThe `MainThreadInterface::Post` can be invoked from another IO thread, but not all methods are. I don't think making `dispatching_messages_` is necessary.",
        "pr_file_module": null
      }
    ]
  }
]