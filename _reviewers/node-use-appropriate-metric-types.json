[
  {
    "discussion_id": "2173808984",
    "pr_number": 58874,
    "pr_file": "doc/api/metrics.md",
    "created_at": "2025-06-29T15:41:15+00:00",
    "commented_code": "+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/metrics.js -->\n+\n+The `node:metrics` module provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The module can be accessed using:\n+\n+```mjs\n+import * as metrics from 'node:metrics';\n+```\n+\n+```cjs\n+const metrics = require('node:metrics');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { counter, timer, statsdStream } from 'node:metrics';\n+import { createWriteStream } from 'node:fs';\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+```cjs\n+const { counter, timer, statsdStream } = require('node:metrics');\n+const { createWriteStream } = require('node:fs');\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+## Metric Types\n+\n+### `metrics.counter(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the counter metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Counter}\n+\n+Creates a counter metric that tracks cumulative values.\n+\n+```mjs\n+import { counter } from 'node:metrics';\n+\n+const errorCount = counter('errors.total', { component: 'database' });\n+\n+errorCount.increment();     // Increment by 1\n+errorCount.increment(5);    // Increment by 5\n+errorCount.decrement(2);    // Decrement by 2\n+```\n+\n+\n+### `metrics.gauge(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the gauge metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Gauge}\n+\n+Creates a gauge metric that represents a single value at a point in time.\n+\n+```mjs\n+import { gauge } from 'node:metrics';\n+import { memoryUsage } from 'node:process';\n+\n+const memory = gauge('memory.usage.bytes');\n+\n+memory.reset(memoryUsage().heapUsed);\n+memory.applyDelta(1024);  // Add 1024 to current value",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2173808984",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "doc/api/metrics.md",
        "discussion_id": "2173808984",
        "commented_code": "@@ -0,0 +1,1040 @@\n+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/metrics.js -->\n+\n+The `node:metrics` module provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The module can be accessed using:\n+\n+```mjs\n+import * as metrics from 'node:metrics';\n+```\n+\n+```cjs\n+const metrics = require('node:metrics');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { counter, timer, statsdStream } from 'node:metrics';\n+import { createWriteStream } from 'node:fs';\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+```cjs\n+const { counter, timer, statsdStream } = require('node:metrics');\n+const { createWriteStream } = require('node:fs');\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+## Metric Types\n+\n+### `metrics.counter(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the counter metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Counter}\n+\n+Creates a counter metric that tracks cumulative values.\n+\n+```mjs\n+import { counter } from 'node:metrics';\n+\n+const errorCount = counter('errors.total', { component: 'database' });\n+\n+errorCount.increment();     // Increment by 1\n+errorCount.increment(5);    // Increment by 5\n+errorCount.decrement(2);    // Decrement by 2\n+```\n+\n+\n+### `metrics.gauge(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the gauge metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Gauge}\n+\n+Creates a gauge metric that represents a single value at a point in time.\n+\n+```mjs\n+import { gauge } from 'node:metrics';\n+import { memoryUsage } from 'node:process';\n+\n+const memory = gauge('memory.usage.bytes');\n+\n+memory.reset(memoryUsage().heapUsed);\n+memory.applyDelta(1024);  // Add 1024 to current value",
        "comment_created_at": "2025-06-29T15:41:15+00:00",
        "comment_author": "jasnell",
        "comment_body": "One additional type of Guage that might be useful is a `HighwaterMarkGauge` whose value only every actually increases. For instance, suppose we are tracking deltas like:\r\n\r\n```js\r\ngauge.applyDelta(10);  // Records the stored highwater mark value as 10\r\ngauge.applyDelta(-5);  // Stored highwater mark value is still 10\r\ngauge.applyDelta(10);  // Stored highwater mark value is 15\r\ngauge.applyDelta(-15);  // Stored highwater mark value is still 15\r\ngauge.applyDelta(10);  // Stored highwater mark value is still 15\r\ngauge.applyDelta(10);  // Stored highwater mark value is 20\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175497702",
    "pr_number": 58874,
    "pr_file": "doc/api/metrics.md",
    "created_at": "2025-06-30T16:42:34+00:00",
    "commented_code": "+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/metrics.js -->\n+\n+The `node:metrics` module provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The module can be accessed using:\n+\n+```mjs\n+import * as metrics from 'node:metrics';\n+```\n+\n+```cjs\n+const metrics = require('node:metrics');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { counter, timer, statsdStream } from 'node:metrics';\n+import { createWriteStream } from 'node:fs';\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+```cjs\n+const { counter, timer, statsdStream } = require('node:metrics');\n+const { createWriteStream } = require('node:fs');\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+## Metric Types\n+\n+### `metrics.counter(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the counter metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Counter}\n+\n+Creates a counter metric that tracks cumulative values.\n+\n+```mjs\n+import { counter } from 'node:metrics';\n+\n+const errorCount = counter('errors.total', { component: 'database' });\n+\n+errorCount.increment();     // Increment by 1\n+errorCount.increment(5);    // Increment by 5\n+errorCount.decrement(2);    // Decrement by 2\n+```\n+\n+\n+### `metrics.gauge(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the gauge metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Gauge}\n+\n+Creates a gauge metric that represents a single value at a point in time.\n+\n+```mjs\n+import { gauge } from 'node:metrics';\n+import { memoryUsage } from 'node:process';\n+\n+const memory = gauge('memory.usage.bytes');\n+\n+memory.reset(memoryUsage().heapUsed);\n+memory.applyDelta(1024);  // Add 1024 to current value\n+```\n+\n+### `metrics.meter(name, interval[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the meter metric.\n+* `interval` {number} The time window in milliseconds for rate calculation.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Meter}\n+\n+Creates a meter metric that measures the rate of events over time.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const requestRate = meter('requests.rate', 60000); // 1 minute window\n+\n+requestRate.mark();     // Mark one event\n+requestRate.mark(10);   // Mark 10 events\n+```\n+\n+### `metrics.timer(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the timer metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.TimerFactory}\n+\n+Creates a timer factory for measuring durations.\n+\n+```mjs\n+import { timer } from 'node:metrics';\n+\n+const dbQueryTimer = timer('db.query.duration');\n+\n+const t = dbQueryTimer.create({ query: 'SELECT * FROM users' });\n+// Perform database query...\n+const duration = t.stop(); // Returns duration in milliseconds\n+```\n+\n+### `metrics.uniqueSet(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the unique set metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.UniqueSet}\n+\n+Creates a unique set metric which counts distinct objects. Uniqueness is\n+determined through a `WeakSet`, so it follows the same identity rules.\n+\n+```mjs\n+import { uniqueSet } from 'node:metrics';\n+\n+const uniqueUsers = uniqueSet('users.unique');\n+\n+uniqueUsers.add(user);        // Only counted once per unique value\n+uniqueUsers.add(anotherUser);\n+```\n+\n+### `metrics.periodicGauge(name, interval, fn[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the periodic gauge metric.\n+* `interval` {number} The interval in milliseconds between samples.\n+* `fn` {Function} A function that returns the current value.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.PeriodicGauge}\n+\n+Creates a gauge that automatically samples a value at regular intervals.\n+\n+```mjs\n+import { periodicGauge } from 'node:metrics';\n+import { cpuUsage } from 'node:process';\n+\n+const cpu = periodicGauge('cpu.usage', 5000, () => {\n+  return cpuUsage().user;\n+});\n+\n+// Stop sampling when no longer needed\n+cpu.stop();\n+```\n+\n+## Classes\n+\n+### Class: `MetricReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Represents a single metric measurement.\n+\n+#### `metricReport.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metricReport.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metricReport.value`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The numeric value of the measurement.\n+\n+#### `metricReport.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the measurement.\n+\n+#### `metricReport.time`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The `performance.now()` timestamp when the measurement was recorded in\n+milliseconds since `performance.timeOrigin`.\n+\n+#### `metricReport.toStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a StatsD-compatible string.\n+\n+```js\n+console.log(report.toStatsd()); // 'api.calls:1|c'\n+```\n+\n+#### `metricReport.toDogStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a DogStatsD-compatible string with tags.\n+\n+```js\n+console.log(report.toDogStatsd()); // 'api.calls:1|c|service:web'\n+```\n+\n+#### `metricReport.toGraphite()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Graphite-compatible string.\n+\n+```js\n+console.log(report.toGraphite()); // 'api.calls 1 1234567890'\n+```\n+\n+#### `metricReport.toPrometheus()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Prometheus-compatible string.\n+\n+```js\n+console.log(report.toPrometheus()); // 'api_calls{service=\"web\"} 1 1234567890.123'\n+```\n+\n+### Class: `Metric`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Manages the lifecycle of a metric channel and provides methods for reporting\n+values to it. Each metric type holds a `Metric` instance which it reports to.\n+\n+#### `metric.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metric.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metric.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the metric.\n+\n+#### `metric.channelName`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the diagnostics_channel used for this metric.\n+\n+#### `metric.channel`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Channel}\n+\n+The diagnostics channel instance used for this metric.\n+\n+#### `metric.shouldReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {boolean}\n+\n+Indicates whether the metric should report values. This can be used to\n+conditionally enable or disable value preparation work.\n+\n+#### `metric.report(value[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {number} The value to report.\n+* `meta` {Object} Additional metadata for this report.\n+* Returns: {metrics.MetricReport}\n+\n+Reports a value for the metric, creating a `MetricReport` instance.\n+This bypasses the metric type specific methods, allowing direct reporting\n+to a channel.\n+\n+Generally this method should not be used directly. Instead, use the\n+specific methods provided by each metric type (e.g., `increment`, `reset`,\n+`mark`, etc.) which internally call this method with the appropriate value and\n+metadata.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const apiCalls = meter('api.calls', { service: 'web' });\n+\n+apiCalls.metric.report(1); // Reports a value of 1\n+apiCalls.metric.report(5, { endpoint: '/api/users' }); // Reports 5 with metadata\n+```\n+\n+### Class: `Counter`\n+\n+* Extends: {metrics.Gauge}\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+A metric that only increases or decreases.",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2175497702",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "doc/api/metrics.md",
        "discussion_id": "2175497702",
        "commented_code": "@@ -0,0 +1,1040 @@\n+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/metrics.js -->\n+\n+The `node:metrics` module provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The module can be accessed using:\n+\n+```mjs\n+import * as metrics from 'node:metrics';\n+```\n+\n+```cjs\n+const metrics = require('node:metrics');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { counter, timer, statsdStream } from 'node:metrics';\n+import { createWriteStream } from 'node:fs';\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+```cjs\n+const { counter, timer, statsdStream } = require('node:metrics');\n+const { createWriteStream } = require('node:fs');\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+## Metric Types\n+\n+### `metrics.counter(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the counter metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Counter}\n+\n+Creates a counter metric that tracks cumulative values.\n+\n+```mjs\n+import { counter } from 'node:metrics';\n+\n+const errorCount = counter('errors.total', { component: 'database' });\n+\n+errorCount.increment();     // Increment by 1\n+errorCount.increment(5);    // Increment by 5\n+errorCount.decrement(2);    // Decrement by 2\n+```\n+\n+\n+### `metrics.gauge(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the gauge metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Gauge}\n+\n+Creates a gauge metric that represents a single value at a point in time.\n+\n+```mjs\n+import { gauge } from 'node:metrics';\n+import { memoryUsage } from 'node:process';\n+\n+const memory = gauge('memory.usage.bytes');\n+\n+memory.reset(memoryUsage().heapUsed);\n+memory.applyDelta(1024);  // Add 1024 to current value\n+```\n+\n+### `metrics.meter(name, interval[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the meter metric.\n+* `interval` {number} The time window in milliseconds for rate calculation.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Meter}\n+\n+Creates a meter metric that measures the rate of events over time.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const requestRate = meter('requests.rate', 60000); // 1 minute window\n+\n+requestRate.mark();     // Mark one event\n+requestRate.mark(10);   // Mark 10 events\n+```\n+\n+### `metrics.timer(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the timer metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.TimerFactory}\n+\n+Creates a timer factory for measuring durations.\n+\n+```mjs\n+import { timer } from 'node:metrics';\n+\n+const dbQueryTimer = timer('db.query.duration');\n+\n+const t = dbQueryTimer.create({ query: 'SELECT * FROM users' });\n+// Perform database query...\n+const duration = t.stop(); // Returns duration in milliseconds\n+```\n+\n+### `metrics.uniqueSet(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the unique set metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.UniqueSet}\n+\n+Creates a unique set metric which counts distinct objects. Uniqueness is\n+determined through a `WeakSet`, so it follows the same identity rules.\n+\n+```mjs\n+import { uniqueSet } from 'node:metrics';\n+\n+const uniqueUsers = uniqueSet('users.unique');\n+\n+uniqueUsers.add(user);        // Only counted once per unique value\n+uniqueUsers.add(anotherUser);\n+```\n+\n+### `metrics.periodicGauge(name, interval, fn[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the periodic gauge metric.\n+* `interval` {number} The interval in milliseconds between samples.\n+* `fn` {Function} A function that returns the current value.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.PeriodicGauge}\n+\n+Creates a gauge that automatically samples a value at regular intervals.\n+\n+```mjs\n+import { periodicGauge } from 'node:metrics';\n+import { cpuUsage } from 'node:process';\n+\n+const cpu = periodicGauge('cpu.usage', 5000, () => {\n+  return cpuUsage().user;\n+});\n+\n+// Stop sampling when no longer needed\n+cpu.stop();\n+```\n+\n+## Classes\n+\n+### Class: `MetricReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Represents a single metric measurement.\n+\n+#### `metricReport.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metricReport.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metricReport.value`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The numeric value of the measurement.\n+\n+#### `metricReport.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the measurement.\n+\n+#### `metricReport.time`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The `performance.now()` timestamp when the measurement was recorded in\n+milliseconds since `performance.timeOrigin`.\n+\n+#### `metricReport.toStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a StatsD-compatible string.\n+\n+```js\n+console.log(report.toStatsd()); // 'api.calls:1|c'\n+```\n+\n+#### `metricReport.toDogStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a DogStatsD-compatible string with tags.\n+\n+```js\n+console.log(report.toDogStatsd()); // 'api.calls:1|c|service:web'\n+```\n+\n+#### `metricReport.toGraphite()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Graphite-compatible string.\n+\n+```js\n+console.log(report.toGraphite()); // 'api.calls 1 1234567890'\n+```\n+\n+#### `metricReport.toPrometheus()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Prometheus-compatible string.\n+\n+```js\n+console.log(report.toPrometheus()); // 'api_calls{service=\"web\"} 1 1234567890.123'\n+```\n+\n+### Class: `Metric`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Manages the lifecycle of a metric channel and provides methods for reporting\n+values to it. Each metric type holds a `Metric` instance which it reports to.\n+\n+#### `metric.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metric.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metric.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the metric.\n+\n+#### `metric.channelName`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the diagnostics_channel used for this metric.\n+\n+#### `metric.channel`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Channel}\n+\n+The diagnostics channel instance used for this metric.\n+\n+#### `metric.shouldReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {boolean}\n+\n+Indicates whether the metric should report values. This can be used to\n+conditionally enable or disable value preparation work.\n+\n+#### `metric.report(value[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {number} The value to report.\n+* `meta` {Object} Additional metadata for this report.\n+* Returns: {metrics.MetricReport}\n+\n+Reports a value for the metric, creating a `MetricReport` instance.\n+This bypasses the metric type specific methods, allowing direct reporting\n+to a channel.\n+\n+Generally this method should not be used directly. Instead, use the\n+specific methods provided by each metric type (e.g., `increment`, `reset`,\n+`mark`, etc.) which internally call this method with the appropriate value and\n+metadata.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const apiCalls = meter('api.calls', { service: 'web' });\n+\n+apiCalls.metric.report(1); // Reports a value of 1\n+apiCalls.metric.report(5, { endpoint: '/api/users' }); // Reports 5 with metadata\n+```\n+\n+### Class: `Counter`\n+\n+* Extends: {metrics.Gauge}\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+A metric that only increases or decreases.",
        "comment_created_at": "2025-06-30T16:42:34+00:00",
        "comment_author": "legendecas",
        "comment_body": "It is important to have a monotonic counter (increase only) to allow backends like Prometheus to calculate on this metric correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2187346861",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "doc/api/metrics.md",
        "discussion_id": "2175497702",
        "commented_code": "@@ -0,0 +1,1040 @@\n+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/metrics.js -->\n+\n+The `node:metrics` module provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The module can be accessed using:\n+\n+```mjs\n+import * as metrics from 'node:metrics';\n+```\n+\n+```cjs\n+const metrics = require('node:metrics');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { counter, timer, statsdStream } from 'node:metrics';\n+import { createWriteStream } from 'node:fs';\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+```cjs\n+const { counter, timer, statsdStream } = require('node:metrics');\n+const { createWriteStream } = require('node:fs');\n+\n+// Create a counter metric\n+const apiCalls = counter('api.calls', { service: 'web' });\n+\n+// Create a timer factory\n+const requestTimer = timer('api.request.duration', { service: 'web' });\n+\n+// Export metrics to StatsD format\n+const statsd = statsdStream();\n+statsd.pipe(createWriteStream('metrics.log'));\n+\n+// Use metrics in your application\n+function handleRequest(req, res) {\n+  const timer = requestTimer.create({ endpoint: req.url });\n+\n+  apiCalls.increment();\n+\n+  // Process request...\n+\n+  timer.stop();\n+}\n+```\n+\n+## Metric Types\n+\n+### `metrics.counter(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the counter metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Counter}\n+\n+Creates a counter metric that tracks cumulative values.\n+\n+```mjs\n+import { counter } from 'node:metrics';\n+\n+const errorCount = counter('errors.total', { component: 'database' });\n+\n+errorCount.increment();     // Increment by 1\n+errorCount.increment(5);    // Increment by 5\n+errorCount.decrement(2);    // Decrement by 2\n+```\n+\n+\n+### `metrics.gauge(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the gauge metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Gauge}\n+\n+Creates a gauge metric that represents a single value at a point in time.\n+\n+```mjs\n+import { gauge } from 'node:metrics';\n+import { memoryUsage } from 'node:process';\n+\n+const memory = gauge('memory.usage.bytes');\n+\n+memory.reset(memoryUsage().heapUsed);\n+memory.applyDelta(1024);  // Add 1024 to current value\n+```\n+\n+### `metrics.meter(name, interval[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the meter metric.\n+* `interval` {number} The time window in milliseconds for rate calculation.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.Meter}\n+\n+Creates a meter metric that measures the rate of events over time.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const requestRate = meter('requests.rate', 60000); // 1 minute window\n+\n+requestRate.mark();     // Mark one event\n+requestRate.mark(10);   // Mark 10 events\n+```\n+\n+### `metrics.timer(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the timer metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.TimerFactory}\n+\n+Creates a timer factory for measuring durations.\n+\n+```mjs\n+import { timer } from 'node:metrics';\n+\n+const dbQueryTimer = timer('db.query.duration');\n+\n+const t = dbQueryTimer.create({ query: 'SELECT * FROM users' });\n+// Perform database query...\n+const duration = t.stop(); // Returns duration in milliseconds\n+```\n+\n+### `metrics.uniqueSet(name[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the unique set metric.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.UniqueSet}\n+\n+Creates a unique set metric which counts distinct objects. Uniqueness is\n+determined through a `WeakSet`, so it follows the same identity rules.\n+\n+```mjs\n+import { uniqueSet } from 'node:metrics';\n+\n+const uniqueUsers = uniqueSet('users.unique');\n+\n+uniqueUsers.add(user);        // Only counted once per unique value\n+uniqueUsers.add(anotherUser);\n+```\n+\n+### `metrics.periodicGauge(name, interval, fn[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `name` {string} The name of the periodic gauge metric.\n+* `interval` {number} The interval in milliseconds between samples.\n+* `fn` {Function} A function that returns the current value.\n+* `meta` {Object} Optional metadata to attach to all reports.\n+* Returns: {metrics.PeriodicGauge}\n+\n+Creates a gauge that automatically samples a value at regular intervals.\n+\n+```mjs\n+import { periodicGauge } from 'node:metrics';\n+import { cpuUsage } from 'node:process';\n+\n+const cpu = periodicGauge('cpu.usage', 5000, () => {\n+  return cpuUsage().user;\n+});\n+\n+// Stop sampling when no longer needed\n+cpu.stop();\n+```\n+\n+## Classes\n+\n+### Class: `MetricReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Represents a single metric measurement.\n+\n+#### `metricReport.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metricReport.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metricReport.value`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The numeric value of the measurement.\n+\n+#### `metricReport.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the measurement.\n+\n+#### `metricReport.time`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {number}\n+\n+The `performance.now()` timestamp when the measurement was recorded in\n+milliseconds since `performance.timeOrigin`.\n+\n+#### `metricReport.toStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a StatsD-compatible string.\n+\n+```js\n+console.log(report.toStatsd()); // 'api.calls:1|c'\n+```\n+\n+#### `metricReport.toDogStatsd()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a DogStatsD-compatible string with tags.\n+\n+```js\n+console.log(report.toDogStatsd()); // 'api.calls:1|c|service:web'\n+```\n+\n+#### `metricReport.toGraphite()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Graphite-compatible string.\n+\n+```js\n+console.log(report.toGraphite()); // 'api.calls 1 1234567890'\n+```\n+\n+#### `metricReport.toPrometheus()`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string}\n+\n+Formats the metric report as a Prometheus-compatible string.\n+\n+```js\n+console.log(report.toPrometheus()); // 'api_calls{service=\"web\"} 1 1234567890.123'\n+```\n+\n+### Class: `Metric`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Manages the lifecycle of a metric channel and provides methods for reporting\n+values to it. Each metric type holds a `Metric` instance which it reports to.\n+\n+#### `metric.type`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The type of the metric (e.g., 'counter', 'gauge', 'meter', 'periodicGauge',\n+'timer', 'uniqueSet').\n+\n+#### `metric.name`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the metric.\n+\n+#### `metric.meta`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Object}\n+\n+Additional metadata associated with the metric.\n+\n+#### `metric.channelName`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {string}\n+\n+The name of the diagnostics_channel used for this metric.\n+\n+#### `metric.channel`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {Channel}\n+\n+The diagnostics channel instance used for this metric.\n+\n+#### `metric.shouldReport`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {boolean}\n+\n+Indicates whether the metric should report values. This can be used to\n+conditionally enable or disable value preparation work.\n+\n+#### `metric.report(value[, meta])`\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {number} The value to report.\n+* `meta` {Object} Additional metadata for this report.\n+* Returns: {metrics.MetricReport}\n+\n+Reports a value for the metric, creating a `MetricReport` instance.\n+This bypasses the metric type specific methods, allowing direct reporting\n+to a channel.\n+\n+Generally this method should not be used directly. Instead, use the\n+specific methods provided by each metric type (e.g., `increment`, `reset`,\n+`mark`, etc.) which internally call this method with the appropriate value and\n+metadata.\n+\n+```mjs\n+import { meter } from 'node:metrics';\n+\n+const apiCalls = meter('api.calls', { service: 'web' });\n+\n+apiCalls.metric.report(1); // Reports a value of 1\n+apiCalls.metric.report(5, { endpoint: '/api/users' }); // Reports 5 with metadata\n+```\n+\n+### Class: `Counter`\n+\n+* Extends: {metrics.Gauge}\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+A metric that only increases or decreases.",
        "comment_created_at": "2025-07-05T14:51:50+00:00",
        "comment_author": "Qard",
        "comment_body": "Yep, going to get to that. I'm working on figuring out a good modelling for having multiple counter types to be able to express that effectively.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2187794051",
    "pr_number": 58874,
    "pr_file": "doc/api/metrics.md",
    "created_at": "2025-07-05T22:33:20+00:00",
    "commented_code": "+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/internal/perf/metrics.js -->\n+\n+The metrics API provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The metrics API can be accessed using:\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+```\n+\n+```cjs\n+const { metrics } = require('node:perf_hooks');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+const { createCounter } = metrics;\n+\n+// Create counter metrics\n+const apiCalls = createCounter('api.calls', { service: 'web' });\n+const requestDuration = createCounter('api.request.duration.ms', { service: 'web' });",
    "repo_full_name": "nodejs/node",
    "discussion_comments": [
      {
        "comment_id": "2187794051",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "doc/api/metrics.md",
        "discussion_id": "2187794051",
        "commented_code": "@@ -0,0 +1,635 @@\n+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/internal/perf/metrics.js -->\n+\n+The metrics API provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The metrics API can be accessed using:\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+```\n+\n+```cjs\n+const { metrics } = require('node:perf_hooks');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+const { createCounter } = metrics;\n+\n+// Create counter metrics\n+const apiCalls = createCounter('api.calls', { service: 'web' });\n+const requestDuration = createCounter('api.request.duration.ms', { service: 'web' });",
        "comment_created_at": "2025-07-05T22:33:20+00:00",
        "comment_author": "legendecas",
        "comment_body": "Using counters to record durations is not a good practice in real life. It is not a single counter value been incremented. It should be represented by a distribution of values, like Histogram.\r\n\r\nThe API should distinguish between counters and histograms.",
        "pr_file_module": null
      },
      {
        "comment_id": "2187950782",
        "repo_full_name": "nodejs/node",
        "pr_number": 58874,
        "pr_file": "doc/api/metrics.md",
        "discussion_id": "2187794051",
        "commented_code": "@@ -0,0 +1,635 @@\n+# Metrics\n+\n+<!--introduced_in=REPLACEME-->\n+\n+> Stability: 1 - Experimental\n+\n+<!-- source_link=lib/internal/perf/metrics.js -->\n+\n+The metrics API provides an API for application instrumentation and\n+performance monitoring. It offers various metric types and built-in exporters\n+for popular monitoring systems.\n+\n+The metrics API can be accessed using:\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+```\n+\n+```cjs\n+const { metrics } = require('node:perf_hooks');\n+```\n+\n+## Overview\n+\n+The metrics API enables developers to instrument their applications with custom\n+metrics that can be collected and exported to monitoring systems. All metrics\n+publish their data through the `node:diagnostics_channel` module, allowing for\n+flexible consumption patterns.\n+\n+### Example\n+\n+```mjs\n+import { metrics } from 'node:perf_hooks';\n+const { createCounter } = metrics;\n+\n+// Create counter metrics\n+const apiCalls = createCounter('api.calls', { service: 'web' });\n+const requestDuration = createCounter('api.request.duration.ms', { service: 'web' });",
        "comment_created_at": "2025-07-06T03:39:47+00:00",
        "comment_author": "Qard",
        "comment_body": "Yes, there will be histogram timers eventually, just haven't got to that yet. But counting total time spent on things is definitely valuable too.",
        "pr_file_module": null
      }
    ]
  }
]