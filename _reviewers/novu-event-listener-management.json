[
  {
    "discussion_id": "2090749789",
    "pr_number": 8310,
    "pr_file": "packages/js/src/ui/components/primitives/Collapsible.tsx",
    "created_at": "2025-05-15T09:40:54+00:00",
    "commented_code": "-import { type Component, JSX, createEffect, createSignal } from 'solid-js';\n+import { type Component, JSX, createEffect, createSignal, onCleanup } from 'solid-js';\n import { useStyle } from '../../helpers';\n \n type CollapsibleProps = JSX.IntrinsicElements['div'] & {\n   class?: string;\n   open: boolean;\n };\n \n+const isInterpolateSizeSupported = () => {\n+  return CSS.supports('interpolate-size', 'allow-keywords');\n+};\n+\n export const Collapsible: Component<CollapsibleProps> = (props) => {\n+  const supportsInterpolateSize = isInterpolateSizeSupported();\n   const style = useStyle();\n   let contentRef: HTMLDivElement | undefined;\n   const [enableTransition, setEnableTransition] = createSignal(false);\n+  const [scrollHeight, setScrollHeight] = createSignal(0);\n+\n+  const updateScrollHeight = () => {\n+    setScrollHeight(contentRef?.scrollHeight || 0);\n+  };\n \n   createEffect(() => {\n     // Delay applying transitions until after the initial render\n     requestAnimationFrame(() => setEnableTransition(true));\n+\n+    const resizeObserver = new ResizeObserver(() => {\n+      updateScrollHeight();\n+    });\n+    if (contentRef && !supportsInterpolateSize) {\n+      resizeObserver.observe(contentRef);\n+    }",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2090749789",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8310,
        "pr_file": "packages/js/src/ui/components/primitives/Collapsible.tsx",
        "discussion_id": "2090749789",
        "commented_code": "@@ -1,32 +1,64 @@\n-import { type Component, JSX, createEffect, createSignal } from 'solid-js';\n+import { type Component, JSX, createEffect, createSignal, onCleanup } from 'solid-js';\n import { useStyle } from '../../helpers';\n \n type CollapsibleProps = JSX.IntrinsicElements['div'] & {\n   class?: string;\n   open: boolean;\n };\n \n+const isInterpolateSizeSupported = () => {\n+  return CSS.supports('interpolate-size', 'allow-keywords');\n+};\n+\n export const Collapsible: Component<CollapsibleProps> = (props) => {\n+  const supportsInterpolateSize = isInterpolateSizeSupported();\n   const style = useStyle();\n   let contentRef: HTMLDivElement | undefined;\n   const [enableTransition, setEnableTransition] = createSignal(false);\n+  const [scrollHeight, setScrollHeight] = createSignal(0);\n+\n+  const updateScrollHeight = () => {\n+    setScrollHeight(contentRef?.scrollHeight || 0);\n+  };\n \n   createEffect(() => {\n     // Delay applying transitions until after the initial render\n     requestAnimationFrame(() => setEnableTransition(true));\n+\n+    const resizeObserver = new ResizeObserver(() => {\n+      updateScrollHeight();\n+    });\n+    if (contentRef && !supportsInterpolateSize) {\n+      resizeObserver.observe(contentRef);\n+    }",
        "comment_created_at": "2025-05-15T09:40:54+00:00",
        "comment_author": "LetItRock",
        "comment_body": "use the resize observer as the fallback to the browsers that don't support `interpolate-size`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077895855",
    "pr_number": 8262,
    "pr_file": "packages/js/src/ui/components/primitives/Popover/PopoverContent.tsx",
    "created_at": "2025-05-07T15:14:53+00:00",
    "commented_code": "export const PopoverContent = (props: PopoverContentProps) => {\n   const { open, onClose, reference, floating } = usePopover();\n   const { active } = useFocusManager();\n+  const { containerElement } = useAppearance();\n \n-  const handleClickOutside = (e: MouseEvent) => {\n+  const handleClickOutside: EventListener = (e) => {\n     // Don't count the trigger as outside click\n     if (reference()?.contains(e.target as Node)) {\n       return;\n     }\n \n-    if (active() !== floating() || floating()?.contains(e.target as Node)) {\n+    const container = containerElement();\n+\n+    if (\n+      active() !== floating() ||\n+      floating()?.contains(e.target as Node) ||\n+      (container && (e.target as Element).shadowRoot === container)\n+    ) {\n       return;\n     }\n \n     onClose();\n   };\n \n-  const handleEscapeKey = (e: KeyboardEvent) => {\n+  const handleEscapeKey: EventListener = (e) => {\n     if (active() !== floating()) {\n       return;\n     }\n \n-    if (e.key === 'Escape') {\n+    if (e instanceof KeyboardEvent && e.key === 'Escape') {\n       onClose();\n     }\n   };\n \n   onMount(() => {\n     document.body.addEventListener('click', handleClickOutside);\n+    containerElement()?.addEventListener('click', handleClickOutside);",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2077895855",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8262,
        "pr_file": "packages/js/src/ui/components/primitives/Popover/PopoverContent.tsx",
        "discussion_id": "2077895855",
        "commented_code": "@@ -41,37 +41,46 @@ type PopoverContentProps = JSX.IntrinsicElements['div'] & { appearanceKey?: Appe\n export const PopoverContent = (props: PopoverContentProps) => {\n   const { open, onClose, reference, floating } = usePopover();\n   const { active } = useFocusManager();\n+  const { containerElement } = useAppearance();\n \n-  const handleClickOutside = (e: MouseEvent) => {\n+  const handleClickOutside: EventListener = (e) => {\n     // Don't count the trigger as outside click\n     if (reference()?.contains(e.target as Node)) {\n       return;\n     }\n \n-    if (active() !== floating() || floating()?.contains(e.target as Node)) {\n+    const container = containerElement();\n+\n+    if (\n+      active() !== floating() ||\n+      floating()?.contains(e.target as Node) ||\n+      (container && (e.target as Element).shadowRoot === container)\n+    ) {\n       return;\n     }\n \n     onClose();\n   };\n \n-  const handleEscapeKey = (e: KeyboardEvent) => {\n+  const handleEscapeKey: EventListener = (e) => {\n     if (active() !== floating()) {\n       return;\n     }\n \n-    if (e.key === 'Escape') {\n+    if (e instanceof KeyboardEvent && e.key === 'Escape') {\n       onClose();\n     }\n   };\n \n   onMount(() => {\n     document.body.addEventListener('click', handleClickOutside);\n+    containerElement()?.addEventListener('click', handleClickOutside);",
        "comment_created_at": "2025-05-07T15:14:53+00:00",
        "comment_author": "LetItRock",
        "comment_body": "listen to the `containerElement` internal clicks, for example, outside clicks to close the dropdowns",
        "pr_file_module": null
      }
    ]
  }
]