[
  {
    "discussion_id": "2142920350",
    "pr_number": 8510,
    "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.tsx",
    "created_at": "2025-06-12T14:26:24+00:00",
    "commented_code": "return acc;\n   }, []);\n \n-  const baseVariables = Array.from(new Map([...jitVariables, ...variables].map((item) => [item.name, item])).values());\n+  const prefix = searchText.split('.')[0];\n+  const localVariable = scopedVariables.find((v) => v.name === prefix);\n+  let combinedVariables = [...jitVariables, ...allVariables];\n+\n+  if (localVariable) {\n+    combinedVariables = [\n+      ...jitVariables,\n+      {\n+        name: searchText,\n+        displayLabel: searchText,\n+        type: 'local',\n+      },\n+      ...allVariables,\n+    ];\n+  }",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2142920350",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8510,
        "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.tsx",
        "discussion_id": "2142920350",
        "commented_code": "@@ -281,7 +292,23 @@ function getMatchingVariables(\n     return acc;\n   }, []);\n \n-  const baseVariables = Array.from(new Map([...jitVariables, ...variables].map((item) => [item.name, item])).values());\n+  const prefix = searchText.split('.')[0];\n+  const localVariable = scopedVariables.find((v) => v.name === prefix);\n+  let combinedVariables = [...jitVariables, ...allVariables];\n+\n+  if (localVariable) {\n+    combinedVariables = [\n+      ...jitVariables,\n+      {\n+        name: searchText,\n+        displayLabel: searchText,\n+        type: 'local',\n+      },\n+      ...allVariables,\n+    ];\n+  }",
        "comment_created_at": "2025-06-12T14:26:24+00:00",
        "comment_author": "LetItRock",
        "comment_body": "if we found the local variable for the prefix that the user typed, for example `product.name` where `product` is prefix, then the `product.name` will be added to the suggestions list as it's valid local variable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142922309",
    "pr_number": 8510,
    "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.tsx",
    "created_at": "2025-06-12T14:27:18+00:00",
    "commented_code": "const word = context.matchBefore(/\\{\\{([^}]*)/);\n     if (!word) return null;\n \n-    const options = completions(variables, onCreateNewVariable, isPayloadSchemaEnabled)(context);\n+    const scopedVariables = getVariablesAtPositionWithLoopProperties(context.state.doc.toString(), context.pos);",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2142922309",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8510,
        "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.tsx",
        "discussion_id": "2142922309",
        "commented_code": "@@ -303,7 +330,13 @@ export function createAutocompleteSource(\n     const word = context.matchBefore(/\\{\\{([^}]*)/);\n     if (!word) return null;\n \n-    const options = completions(variables, onCreateNewVariable, isPayloadSchemaEnabled)(context);\n+    const scopedVariables = getVariablesAtPositionWithLoopProperties(context.state.doc.toString(), context.pos);",
        "comment_created_at": "2025-06-12T14:27:18+00:00",
        "comment_author": "LetItRock",
        "comment_body": "find all the scoped variables for the current cursor position",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2090717888",
    "pr_number": 8310,
    "pr_file": "packages/js/src/ui/components/elements/Preferences/Preferences.tsx",
    "created_at": "2025-05-15T09:29:05+00:00",
    "commented_code": "}));\n   });\n \n-  const optimisticUpdate =\n-    (preference?: Preference) =>\n-    async ({ channel, enabled }: { channel: ChannelType; enabled: boolean }) => {\n-      await preference?.update({\n-        channels: {\n-          [channel]: enabled,\n-        },\n-      });\n-    };\n+  const updatePreference = (preference?: Preference) => async (channels: ChannelPreference) => {\n+    await preference?.update({\n+      channels,\n+    });\n+  };\n+\n+  const bulkUpdatePreferences = (preferences: Preference[]) => async (channels: ChannelPreference) => {\n+    await novu.preferences.bulkUpdate(\n+      preferences.map((el) => {\n+        const oldChannels = Object.keys(el.channels);\n+        const channelsToUpdate = Object.keys(channels)\n+          .filter((channel) => oldChannels.includes(channel))\n+          .reduce((acc, channel) => {\n+            acc[channel as keyof ChannelPreference] = channels[channel as keyof ChannelPreference];\n+\n+            return acc;\n+          }, {} as ChannelPreference);\n+\n+        return { preference: el, channels: channelsToUpdate };\n+      })\n+    );\n+  };\n+\n+  const groupedPreferences = createMemo(() => {\n+    const workflowPreferences = allPreferences().workflowPreferences ?? [];\n+\n+    return (\n+      preferenceGroups()?.map((group) => {\n+        const { filter } = group;\n+        if (typeof filter === 'function') {\n+          const preferences = filter({ preferences: workflowPreferences });\n+\n+          return { name: group.name, preferences };\n+        }\n+\n+        if (typeof filter === 'object') {\n+          return {\n+            name: group.name,\n+            preferences: workflowPreferences.filter((preference) => {\n+              const workflowId = preference.workflow?.id || preference.workflow?.identifier;\n+\n+              return (\n+                filter.workflowIds?.includes(workflowId ?? '') ||\n+                filter.tags?.some((tag) => preference.workflow?.tags?.includes(tag))\n+              );\n+            }),\n+          };\n+        }\n+\n+        return {\n+          name: group.name,\n+          preferences: [],\n+        };\n+      }) ?? []\n+    );\n+  });",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2090717888",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8310,
        "pr_file": "packages/js/src/ui/components/elements/Preferences/Preferences.tsx",
        "discussion_id": "2090717888",
        "commented_code": "@@ -40,178 +38,94 @@ export const Preferences = () => {\n     }));\n   });\n \n-  const optimisticUpdate =\n-    (preference?: Preference) =>\n-    async ({ channel, enabled }: { channel: ChannelType; enabled: boolean }) => {\n-      await preference?.update({\n-        channels: {\n-          [channel]: enabled,\n-        },\n-      });\n-    };\n+  const updatePreference = (preference?: Preference) => async (channels: ChannelPreference) => {\n+    await preference?.update({\n+      channels,\n+    });\n+  };\n+\n+  const bulkUpdatePreferences = (preferences: Preference[]) => async (channels: ChannelPreference) => {\n+    await novu.preferences.bulkUpdate(\n+      preferences.map((el) => {\n+        const oldChannels = Object.keys(el.channels);\n+        const channelsToUpdate = Object.keys(channels)\n+          .filter((channel) => oldChannels.includes(channel))\n+          .reduce((acc, channel) => {\n+            acc[channel as keyof ChannelPreference] = channels[channel as keyof ChannelPreference];\n+\n+            return acc;\n+          }, {} as ChannelPreference);\n+\n+        return { preference: el, channels: channelsToUpdate };\n+      })\n+    );\n+  };\n+\n+  const groupedPreferences = createMemo(() => {\n+    const workflowPreferences = allPreferences().workflowPreferences ?? [];\n+\n+    return (\n+      preferenceGroups()?.map((group) => {\n+        const { filter } = group;\n+        if (typeof filter === 'function') {\n+          const preferences = filter({ preferences: workflowPreferences });\n+\n+          return { name: group.name, preferences };\n+        }\n+\n+        if (typeof filter === 'object') {\n+          return {\n+            name: group.name,\n+            preferences: workflowPreferences.filter((preference) => {\n+              const workflowId = preference.workflow?.id || preference.workflow?.identifier;\n+\n+              return (\n+                filter.workflowIds?.includes(workflowId ?? '') ||\n+                filter.tags?.some((tag) => preference.workflow?.tags?.includes(tag))\n+              );\n+            }),\n+          };\n+        }\n+\n+        return {\n+          name: group.name,\n+          preferences: [],\n+        };\n+      }) ?? []\n+    );\n+  });",
        "comment_created_at": "2025-05-15T09:29:05+00:00",
        "comment_author": "LetItRock",
        "comment_body": "calculate groups and their preferences by using filters for `tags, workflowIds`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2034847509",
    "pr_number": 8097,
    "pr_file": "apps/dashboard/src/components/workflow-editor/workflow-provider.tsx",
    "created_at": "2025-04-09T09:04:12+00:00",
    "commented_code": ");\n   }, [workflow, stepSlug]);\n \n+  const isStepAfterDigest = useMemo(() => {",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2034847509",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8097,
        "pr_file": "apps/dashboard/src/components/workflow-editor/workflow-provider.tsx",
        "discussion_id": "2034847509",
        "commented_code": "@@ -58,6 +59,25 @@ export const WorkflowProvider = ({ children }: { children: ReactNode }) => {\n     );\n   }, [workflow, stepSlug]);\n \n+  const isStepAfterDigest = useMemo(() => {",
        "comment_created_at": "2025-04-09T09:04:12+00:00",
        "comment_author": "BiswaViraj",
        "comment_body": "checks if the current step has any digest step before it",
        "pr_file_module": null
      },
      {
        "comment_id": "2036700961",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8097,
        "pr_file": "apps/dashboard/src/components/workflow-editor/workflow-provider.tsx",
        "discussion_id": "2034847509",
        "commented_code": "@@ -58,6 +59,25 @@ export const WorkflowProvider = ({ children }: { children: ReactNode }) => {\n     );\n   }, [workflow, stepSlug]);\n \n+  const isStepAfterDigest = useMemo(() => {",
        "comment_created_at": "2025-04-10T07:34:58+00:00",
        "comment_author": "LetItRock",
        "comment_body": "we need to have here a similar code that will return the \"closest\" digest step, and use that step to generate the `countSummary` and `sentenceSummary` templates, because the digest step id is not constant:\r\n\r\n![Screenshot 2025-04-10 at 09 27 15](https://github.com/user-attachments/assets/ecf69675-9668-40ad-b122-cd854fa3dcc0)\r\n",
        "pr_file_module": null
      }
    ]
  }
]