[
  {
    "discussion_id": "2265153591",
    "pr_number": 8890,
    "pr_file": "apps/worker/src/app/workflow/services/step-template-fetcher.service.ts",
    "created_at": "2025-08-10T07:26:07+00:00",
    "commented_code": "+import { Injectable } from '@nestjs/common';\n+import { PinoLogger } from '@novu/application-generic';\n+import { NotificationStepEntity, NotificationTemplateRepository } from '@novu/dal';\n+\n+@Injectable()\n+export class StepTemplateFetcher {",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2265153591",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8890,
        "pr_file": "apps/worker/src/app/workflow/services/step-template-fetcher.service.ts",
        "discussion_id": "2265153591",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Injectable } from '@nestjs/common';\n+import { PinoLogger } from '@novu/application-generic';\n+import { NotificationStepEntity, NotificationTemplateRepository } from '@novu/dal';\n+\n+@Injectable()\n+export class StepTemplateFetcher {",
        "comment_created_at": "2025-08-10T07:26:07+00:00",
        "comment_author": "djabarovgeorge",
        "comment_body": "personal preference not to use the naming template as it can confuse. \n```suggestion\nexport class WorkflowStepFetcher {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2257300885",
    "pr_number": 8870,
    "pr_file": "packages/shared/src/consts/severity.ts",
    "created_at": "2025-08-06T14:05:59+00:00",
    "commented_code": "+export enum SeverityLevel {",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2257300885",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8870,
        "pr_file": "packages/shared/src/consts/severity.ts",
        "discussion_id": "2257300885",
        "commented_code": "@@ -0,0 +1,6 @@\n+export enum SeverityLevel {",
        "comment_created_at": "2025-08-06T14:05:59+00:00",
        "comment_author": "scopsy",
        "comment_body": "Not critical, but usually we suffix with Enum, \n```suggestion\nexport enum SeverityLevelEnum {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161439551",
    "pr_number": 8553,
    "pr_file": "apps/api/src/app/shared/framework/analytics-logs.interceptor.ts",
    "created_at": "2025-06-23T11:55:39+00:00",
    "commented_code": "+import {\n+  SetMetadata,\n+  applyDecorators,\n+  ExecutionContext,\n+  Injectable,\n+  CallHandler,\n+  NestInterceptor,\n+} from '@nestjs/common';\n+import { Observable } from 'rxjs';\n+import { tap } from 'rxjs/operators';\n+import { FeatureFlagsService, PinoLogger, HttpLogRepository, HttpLog } from '@novu/application-generic';\n+import { UserSessionData, FeatureFlagsKeysEnum } from '@novu/shared';\n+import { getClientIp } from 'request-ip';\n+import { sanitizePayload, retryWithBackoff } from '../../../utils/payload-sanitizer';\n+import { TriggerEventResponseDto } from '../../events/dtos/trigger-event-response.dto';\n+\n+const LOG_ANALYTICS_KEY = 'logAnalytics';\n+\n+export enum ANALYTICS_STRATEGY {\n+  BASIC = 'basic',\n+  EVENTS = 'events',\n+}\n+\n+/**\n+ * Analytics Logs Decorator & Interceptor\n+ *\n+ * Usage:\n+ *   1. Add @LogAnalytics() to a controller or route handler to enable analytics logging for that endpoint.\n+ *      - At the controller level: all routes in the controller will be logged.\n+ *      - At the method level: only that route will be logged.\n+ *   2. The AnalyticsLogsInterceptor is registered globally and will log requests to ClickHouse\n+ *      only for endpoints decorated with @LogAnalytics().\n+ *\n+ * Example (controller-level):\n+ *   @LogAnalytics()\n+ *   @Controller('events')\n+ *   export class EventsController { ... }\n+ *\n+ * Example (method-level):\n+ *   @Post('/trigger')\n+ *   @LogAnalytics()\n+ *   async trigger(...) { ... }\n+ *\n+ * Notes:\n+ *   - Logging is opt-in and non-intrusive.\n+ *   - The interceptor is extensible for future options (e.g., sampling, custom log fields).\n+ */\n+\n+export function LogAnalytics(strategy: ANALYTICS_STRATEGY = ANALYTICS_STRATEGY.BASIC): MethodDecorator {\n+  return applyDecorators(SetMetadata(LOG_ANALYTICS_KEY, strategy));\n+}\n+\n+export function getAnalyticsStrategy(context: ExecutionContext): ANALYTICS_STRATEGY {\n+  return context.getHandler && Reflect.getMetadata(LOG_ANALYTICS_KEY, context.getHandler());\n+}\n+\n+export function isLogAnalytics(context: ExecutionContext): boolean {\n+  return getAnalyticsStrategy(context) !== undefined;\n+}",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2161439551",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8553,
        "pr_file": "apps/api/src/app/shared/framework/analytics-logs.interceptor.ts",
        "discussion_id": "2161439551",
        "commented_code": "@@ -0,0 +1,143 @@\n+import {\n+  SetMetadata,\n+  applyDecorators,\n+  ExecutionContext,\n+  Injectable,\n+  CallHandler,\n+  NestInterceptor,\n+} from '@nestjs/common';\n+import { Observable } from 'rxjs';\n+import { tap } from 'rxjs/operators';\n+import { FeatureFlagsService, PinoLogger, HttpLogRepository, HttpLog } from '@novu/application-generic';\n+import { UserSessionData, FeatureFlagsKeysEnum } from '@novu/shared';\n+import { getClientIp } from 'request-ip';\n+import { sanitizePayload, retryWithBackoff } from '../../../utils/payload-sanitizer';\n+import { TriggerEventResponseDto } from '../../events/dtos/trigger-event-response.dto';\n+\n+const LOG_ANALYTICS_KEY = 'logAnalytics';\n+\n+export enum ANALYTICS_STRATEGY {\n+  BASIC = 'basic',\n+  EVENTS = 'events',\n+}\n+\n+/**\n+ * Analytics Logs Decorator & Interceptor\n+ *\n+ * Usage:\n+ *   1. Add @LogAnalytics() to a controller or route handler to enable analytics logging for that endpoint.\n+ *      - At the controller level: all routes in the controller will be logged.\n+ *      - At the method level: only that route will be logged.\n+ *   2. The AnalyticsLogsInterceptor is registered globally and will log requests to ClickHouse\n+ *      only for endpoints decorated with @LogAnalytics().\n+ *\n+ * Example (controller-level):\n+ *   @LogAnalytics()\n+ *   @Controller('events')\n+ *   export class EventsController { ... }\n+ *\n+ * Example (method-level):\n+ *   @Post('/trigger')\n+ *   @LogAnalytics()\n+ *   async trigger(...) { ... }\n+ *\n+ * Notes:\n+ *   - Logging is opt-in and non-intrusive.\n+ *   - The interceptor is extensible for future options (e.g., sampling, custom log fields).\n+ */\n+\n+export function LogAnalytics(strategy: ANALYTICS_STRATEGY = ANALYTICS_STRATEGY.BASIC): MethodDecorator {\n+  return applyDecorators(SetMetadata(LOG_ANALYTICS_KEY, strategy));\n+}\n+\n+export function getAnalyticsStrategy(context: ExecutionContext): ANALYTICS_STRATEGY {\n+  return context.getHandler && Reflect.getMetadata(LOG_ANALYTICS_KEY, context.getHandler());\n+}\n+\n+export function isLogAnalytics(context: ExecutionContext): boolean {\n+  return getAnalyticsStrategy(context) !== undefined;\n+}",
        "comment_created_at": "2025-06-23T11:55:39+00:00",
        "comment_author": "LetItRock",
        "comment_body": "no need to export and it should be called like `shouldLogAnalytics`",
        "pr_file_module": null
      },
      {
        "comment_id": "2166634787",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8553,
        "pr_file": "apps/api/src/app/shared/framework/analytics-logs.interceptor.ts",
        "discussion_id": "2161439551",
        "commented_code": "@@ -0,0 +1,143 @@\n+import {\n+  SetMetadata,\n+  applyDecorators,\n+  ExecutionContext,\n+  Injectable,\n+  CallHandler,\n+  NestInterceptor,\n+} from '@nestjs/common';\n+import { Observable } from 'rxjs';\n+import { tap } from 'rxjs/operators';\n+import { FeatureFlagsService, PinoLogger, HttpLogRepository, HttpLog } from '@novu/application-generic';\n+import { UserSessionData, FeatureFlagsKeysEnum } from '@novu/shared';\n+import { getClientIp } from 'request-ip';\n+import { sanitizePayload, retryWithBackoff } from '../../../utils/payload-sanitizer';\n+import { TriggerEventResponseDto } from '../../events/dtos/trigger-event-response.dto';\n+\n+const LOG_ANALYTICS_KEY = 'logAnalytics';\n+\n+export enum ANALYTICS_STRATEGY {\n+  BASIC = 'basic',\n+  EVENTS = 'events',\n+}\n+\n+/**\n+ * Analytics Logs Decorator & Interceptor\n+ *\n+ * Usage:\n+ *   1. Add @LogAnalytics() to a controller or route handler to enable analytics logging for that endpoint.\n+ *      - At the controller level: all routes in the controller will be logged.\n+ *      - At the method level: only that route will be logged.\n+ *   2. The AnalyticsLogsInterceptor is registered globally and will log requests to ClickHouse\n+ *      only for endpoints decorated with @LogAnalytics().\n+ *\n+ * Example (controller-level):\n+ *   @LogAnalytics()\n+ *   @Controller('events')\n+ *   export class EventsController { ... }\n+ *\n+ * Example (method-level):\n+ *   @Post('/trigger')\n+ *   @LogAnalytics()\n+ *   async trigger(...) { ... }\n+ *\n+ * Notes:\n+ *   - Logging is opt-in and non-intrusive.\n+ *   - The interceptor is extensible for future options (e.g., sampling, custom log fields).\n+ */\n+\n+export function LogAnalytics(strategy: ANALYTICS_STRATEGY = ANALYTICS_STRATEGY.BASIC): MethodDecorator {\n+  return applyDecorators(SetMetadata(LOG_ANALYTICS_KEY, strategy));\n+}\n+\n+export function getAnalyticsStrategy(context: ExecutionContext): ANALYTICS_STRATEGY {\n+  return context.getHandler && Reflect.getMetadata(LOG_ANALYTICS_KEY, context.getHandler());\n+}\n+\n+export function isLogAnalytics(context: ExecutionContext): boolean {\n+  return getAnalyticsStrategy(context) !== undefined;\n+}",
        "comment_created_at": "2025-06-25T12:47:36+00:00",
        "comment_author": "djabarovgeorge",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2079135294",
    "pr_number": 8259,
    "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.ts",
    "created_at": "2025-05-08T08:05:40+00:00",
    "commented_code": ".map((f) => createCompletionOption(f.value, 'function'));\n }\n \n-function isValidDynamicPath(searchText: string): boolean {\n-  return VALID_DYNAMIC_PATHS.some((path) =>\n-    typeof path === 'string' ? searchText.startsWith(path) : path.test(searchText)\n-  );\n-}\n-\n-function validateSubscriberField(searchText: string, matches: LiquidVariable[]): LiquidVariable[] {\n-  const parts = searchText.split('.');\n-\n-  if (parts.length === 2 && parts[0] === 'subscriber') {\n-    if (!matches.some((v) => v.name === searchText)) {\n-      return [];\n-    }\n-  }\n-\n-  return matches;\n-}\n-\n-function validateStepId(searchText: string, variables: LiquidVariable[]): boolean {\n-  if (!searchText.startsWith('steps.')) return true;\n-\n-  const stepMatch = searchText.match(/^steps\\.([^.]+)/);\n-  if (!stepMatch) return true;\n-\n-  const stepId = stepMatch[1];\n-  return variables.some((v) => v.name.startsWith(`steps.${stepId}.`));\n-}\n-\n function getMatchingVariables(searchText: string, variables: LiquidVariable[]): LiquidVariable[] {\n   if (!searchText) return variables;\n \n   const searchLower = searchText.toLowerCase();\n \n-  // Handle root prefixes and their partials\n-  for (const [root, prefix] of Object.entries(ROOT_PREFIXES)) {\n-    if (searchLower.startsWith(root) || root.startsWith(searchLower)) {\n-      let matches = variables.filter((v) => v.name.startsWith(prefix));\n-\n-      // Special handling for subscriber fields\n-      if (prefix === 'subscriber.') {\n-        matches = validateSubscriberField(searchText, matches);\n-      }\n-\n-      // Allow new paths for dynamic paths\n-      if (isValidDynamicPath(searchText)) {\n-        if (!matches.some((v) => v.name === searchText)) {\n-          matches.push({ name: searchText } as LiquidVariable);\n-        }\n-      }\n-\n-      return matches;\n-    }\n-  }\n-\n   // Handle dot endings\n   if (searchText.endsWith('.')) {\n     const prefix = searchText.slice(0, -1);\n     return variables.filter((v) => v.name.startsWith(prefix));\n   }\n \n-  // Validate step ID exists\n-  if (!validateStepId(searchText, variables)) {\n-    return [];\n-  }\n+  // Filter jit step namespaces out of the returned variables from the server\n+  const stepPayloadNamespaces = variables.reduce<string[]>((acc, variableItem) => {\n+    const match = variableItem.name.match(STEP_PAYLOAD_REGEX);\n+\n+    if (match) {\n+      acc.push(match[0]);\n+    }\n+\n+    return acc;\n+  }, []);\n+\n+  // Create JIT variables based on the search text e.g. payload.foo, subscriber.data.foo, steps.digest-step.events[0].payload.foo\n+  const jitVariables = [PAYLOAD_NAMESPACE, SUBSCRIBER_DATA_NAMESPACE, ...stepPayloadNamespaces].reduce<\n+    LiquidVariable[]\n+  >((acc, namespace) => {\n+    if (searchText.startsWith(namespace) && searchText !== namespace) {\n+      // Ensure that if the user types payload.foo the first suggestion is payload.foo\n+      acc.push({ name: searchText, type: 'variable' });\n+    } else if (!searchText.startsWith(namespace)) {\n+      // For all other values, suggest payload.whatever, subscriber.data.whatever\n+      acc.push({\n+        name: `${namespace}.${searchLower.trim()}`,",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2079135294",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8259,
        "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.ts",
        "discussion_id": "2079135294",
        "commented_code": "@@ -149,73 +146,56 @@ function getFilterCompletions(afterPipe: string): CompletionOption[] {\n     .map((f) => createCompletionOption(f.value, 'function'));\n }\n \n-function isValidDynamicPath(searchText: string): boolean {\n-  return VALID_DYNAMIC_PATHS.some((path) =>\n-    typeof path === 'string' ? searchText.startsWith(path) : path.test(searchText)\n-  );\n-}\n-\n-function validateSubscriberField(searchText: string, matches: LiquidVariable[]): LiquidVariable[] {\n-  const parts = searchText.split('.');\n-\n-  if (parts.length === 2 && parts[0] === 'subscriber') {\n-    if (!matches.some((v) => v.name === searchText)) {\n-      return [];\n-    }\n-  }\n-\n-  return matches;\n-}\n-\n-function validateStepId(searchText: string, variables: LiquidVariable[]): boolean {\n-  if (!searchText.startsWith('steps.')) return true;\n-\n-  const stepMatch = searchText.match(/^steps\\.([^.]+)/);\n-  if (!stepMatch) return true;\n-\n-  const stepId = stepMatch[1];\n-  return variables.some((v) => v.name.startsWith(`steps.${stepId}.`));\n-}\n-\n function getMatchingVariables(searchText: string, variables: LiquidVariable[]): LiquidVariable[] {\n   if (!searchText) return variables;\n \n   const searchLower = searchText.toLowerCase();\n \n-  // Handle root prefixes and their partials\n-  for (const [root, prefix] of Object.entries(ROOT_PREFIXES)) {\n-    if (searchLower.startsWith(root) || root.startsWith(searchLower)) {\n-      let matches = variables.filter((v) => v.name.startsWith(prefix));\n-\n-      // Special handling for subscriber fields\n-      if (prefix === 'subscriber.') {\n-        matches = validateSubscriberField(searchText, matches);\n-      }\n-\n-      // Allow new paths for dynamic paths\n-      if (isValidDynamicPath(searchText)) {\n-        if (!matches.some((v) => v.name === searchText)) {\n-          matches.push({ name: searchText } as LiquidVariable);\n-        }\n-      }\n-\n-      return matches;\n-    }\n-  }\n-\n   // Handle dot endings\n   if (searchText.endsWith('.')) {\n     const prefix = searchText.slice(0, -1);\n     return variables.filter((v) => v.name.startsWith(prefix));\n   }\n \n-  // Validate step ID exists\n-  if (!validateStepId(searchText, variables)) {\n-    return [];\n-  }\n+  // Filter jit step namespaces out of the returned variables from the server\n+  const stepPayloadNamespaces = variables.reduce<string[]>((acc, variableItem) => {\n+    const match = variableItem.name.match(STEP_PAYLOAD_REGEX);\n+\n+    if (match) {\n+      acc.push(match[0]);\n+    }\n+\n+    return acc;\n+  }, []);\n+\n+  // Create JIT variables based on the search text e.g. payload.foo, subscriber.data.foo, steps.digest-step.events[0].payload.foo\n+  const jitVariables = [PAYLOAD_NAMESPACE, SUBSCRIBER_DATA_NAMESPACE, ...stepPayloadNamespaces].reduce<\n+    LiquidVariable[]\n+  >((acc, namespace) => {\n+    if (searchText.startsWith(namespace) && searchText !== namespace) {\n+      // Ensure that if the user types payload.foo the first suggestion is payload.foo\n+      acc.push({ name: searchText, type: 'variable' });\n+    } else if (!searchText.startsWith(namespace)) {\n+      // For all other values, suggest payload.whatever, subscriber.data.whatever\n+      acc.push({\n+        name: `${namespace}.${searchLower.trim()}`,",
        "comment_created_at": "2025-05-08T08:05:40+00:00",
        "comment_author": "LetItRock",
        "comment_body": "we shouldn't use `searchLower` as in the result it will suggest me wrong variable name; for example I have variable in my payload `firstName`, so I typed `{{firstName}}`, but in the dropdown it suggests `payload.firstname`\r\n\r\n![Screenshot 2025-05-08 at 10 05 16](https://github.com/user-attachments/assets/59669a0e-3386-459d-996e-38c11cc29983)",
        "pr_file_module": null
      },
      {
        "comment_id": "2083611395",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8259,
        "pr_file": "apps/dashboard/src/utils/liquid-autocomplete.ts",
        "discussion_id": "2079135294",
        "commented_code": "@@ -149,73 +146,56 @@ function getFilterCompletions(afterPipe: string): CompletionOption[] {\n     .map((f) => createCompletionOption(f.value, 'function'));\n }\n \n-function isValidDynamicPath(searchText: string): boolean {\n-  return VALID_DYNAMIC_PATHS.some((path) =>\n-    typeof path === 'string' ? searchText.startsWith(path) : path.test(searchText)\n-  );\n-}\n-\n-function validateSubscriberField(searchText: string, matches: LiquidVariable[]): LiquidVariable[] {\n-  const parts = searchText.split('.');\n-\n-  if (parts.length === 2 && parts[0] === 'subscriber') {\n-    if (!matches.some((v) => v.name === searchText)) {\n-      return [];\n-    }\n-  }\n-\n-  return matches;\n-}\n-\n-function validateStepId(searchText: string, variables: LiquidVariable[]): boolean {\n-  if (!searchText.startsWith('steps.')) return true;\n-\n-  const stepMatch = searchText.match(/^steps\\.([^.]+)/);\n-  if (!stepMatch) return true;\n-\n-  const stepId = stepMatch[1];\n-  return variables.some((v) => v.name.startsWith(`steps.${stepId}.`));\n-}\n-\n function getMatchingVariables(searchText: string, variables: LiquidVariable[]): LiquidVariable[] {\n   if (!searchText) return variables;\n \n   const searchLower = searchText.toLowerCase();\n \n-  // Handle root prefixes and their partials\n-  for (const [root, prefix] of Object.entries(ROOT_PREFIXES)) {\n-    if (searchLower.startsWith(root) || root.startsWith(searchLower)) {\n-      let matches = variables.filter((v) => v.name.startsWith(prefix));\n-\n-      // Special handling for subscriber fields\n-      if (prefix === 'subscriber.') {\n-        matches = validateSubscriberField(searchText, matches);\n-      }\n-\n-      // Allow new paths for dynamic paths\n-      if (isValidDynamicPath(searchText)) {\n-        if (!matches.some((v) => v.name === searchText)) {\n-          matches.push({ name: searchText } as LiquidVariable);\n-        }\n-      }\n-\n-      return matches;\n-    }\n-  }\n-\n   // Handle dot endings\n   if (searchText.endsWith('.')) {\n     const prefix = searchText.slice(0, -1);\n     return variables.filter((v) => v.name.startsWith(prefix));\n   }\n \n-  // Validate step ID exists\n-  if (!validateStepId(searchText, variables)) {\n-    return [];\n-  }\n+  // Filter jit step namespaces out of the returned variables from the server\n+  const stepPayloadNamespaces = variables.reduce<string[]>((acc, variableItem) => {\n+    const match = variableItem.name.match(STEP_PAYLOAD_REGEX);\n+\n+    if (match) {\n+      acc.push(match[0]);\n+    }\n+\n+    return acc;\n+  }, []);\n+\n+  // Create JIT variables based on the search text e.g. payload.foo, subscriber.data.foo, steps.digest-step.events[0].payload.foo\n+  const jitVariables = [PAYLOAD_NAMESPACE, SUBSCRIBER_DATA_NAMESPACE, ...stepPayloadNamespaces].reduce<\n+    LiquidVariable[]\n+  >((acc, namespace) => {\n+    if (searchText.startsWith(namespace) && searchText !== namespace) {\n+      // Ensure that if the user types payload.foo the first suggestion is payload.foo\n+      acc.push({ name: searchText, type: 'variable' });\n+    } else if (!searchText.startsWith(namespace)) {\n+      // For all other values, suggest payload.whatever, subscriber.data.whatever\n+      acc.push({\n+        name: `${namespace}.${searchLower.trim()}`,",
        "comment_created_at": "2025-05-11T20:13:45+00:00",
        "comment_author": "SokratisVidros",
        "comment_body": "I love the attention to detail. Good catch. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084868758",
    "pr_number": 8292,
    "pr_file": "apps/api/src/app/inbox/dtos/bulk-update-preferences-request.dto.ts",
    "created_at": "2025-05-12T14:52:52+00:00",
    "commented_code": "+import { IsArray, IsDefined, IsString, ValidateNested } from 'class-validator';\n+import { Type } from 'class-transformer';\n+\n+import { UpdatePreferencesRequestDto } from './update-preferences-request.dto';\n+\n+export class BulkUpdatePreferenceItemDto extends UpdatePreferencesRequestDto {\n+  @IsDefined()\n+  @IsString()\n+  readonly workflowIdOrInternalId: string;",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2084868758",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8292,
        "pr_file": "apps/api/src/app/inbox/dtos/bulk-update-preferences-request.dto.ts",
        "discussion_id": "2084868758",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { IsArray, IsDefined, IsString, ValidateNested } from 'class-validator';\n+import { Type } from 'class-transformer';\n+\n+import { UpdatePreferencesRequestDto } from './update-preferences-request.dto';\n+\n+export class BulkUpdatePreferenceItemDto extends UpdatePreferencesRequestDto {\n+  @IsDefined()\n+  @IsString()\n+  readonly workflowIdOrInternalId: string;",
        "comment_created_at": "2025-05-12T14:52:52+00:00",
        "comment_author": "scopsy",
        "comment_body": "Do we have this pattern in other places? wonder if it's better to just stick to workflowId, it's hard for me to see if anyone will ever user the internal id for this",
        "pr_file_module": null
      },
      {
        "comment_id": "2085033003",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8292,
        "pr_file": "apps/api/src/app/inbox/dtos/bulk-update-preferences-request.dto.ts",
        "discussion_id": "2084868758",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { IsArray, IsDefined, IsString, ValidateNested } from 'class-validator';\n+import { Type } from 'class-transformer';\n+\n+import { UpdatePreferencesRequestDto } from './update-preferences-request.dto';\n+\n+export class BulkUpdatePreferenceItemDto extends UpdatePreferencesRequestDto {\n+  @IsDefined()\n+  @IsString()\n+  readonly workflowIdOrInternalId: string;",
        "comment_created_at": "2025-05-12T16:20:06+00:00",
        "comment_author": "LetItRock",
        "comment_body": "@scopsy the workflow controller uses `workflowId` as the path param, so I'll stick to that name",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2054510328",
    "pr_number": 8178,
    "pr_file": "apps/api/src/app/workflows-v2/usecases/build-step-issues/build-step-issues.usecase.ts",
    "created_at": "2025-04-22T17:03:11+00:00",
    "commented_code": "// eslint-disable-next-line no-param-reassign\n         issues.controls[controlKey] = liquidTemplateIssues.invalidVariables.map((error) => {",
    "repo_full_name": "novuhq/novu",
    "discussion_comments": [
      {
        "comment_id": "2054510328",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8178,
        "pr_file": "apps/api/src/app/workflows-v2/usecases/build-step-issues/build-step-issues.usecase.ts",
        "discussion_id": "2054510328",
        "commented_code": "@@ -148,6 +148,13 @@ export class BuildStepIssuesUsecase {\n         // eslint-disable-next-line no-param-reassign\n         issues.controls[controlKey] = liquidTemplateIssues.invalidVariables.map((error) => {",
        "comment_created_at": "2025-04-22T17:03:11+00:00",
        "comment_author": "SokratisVidros",
        "comment_body": "```suggestion\r\n        issues.controls[controlKey] = liquidTemplateIssues.invalidVariables.map((variable) => {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2054510682",
        "repo_full_name": "novuhq/novu",
        "pr_number": 8178,
        "pr_file": "apps/api/src/app/workflows-v2/usecases/build-step-issues/build-step-issues.usecase.ts",
        "discussion_id": "2054510328",
        "commented_code": "@@ -148,6 +148,13 @@ export class BuildStepIssuesUsecase {\n         // eslint-disable-next-line no-param-reassign\n         issues.controls[controlKey] = liquidTemplateIssues.invalidVariables.map((error) => {",
        "comment_created_at": "2025-04-22T17:03:26+00:00",
        "comment_author": "SokratisVidros",
        "comment_body": "Please apply the proper naming in the iteration, this is a variable, not an error.",
        "pr_file_module": null
      }
    ]
  }
]