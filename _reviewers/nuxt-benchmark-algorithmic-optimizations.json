[
  {
    "discussion_id": "2055572704",
    "pr_number": 31192,
    "pr_file": "packages/nuxt/src/components/plugins/lazy-hydration-transform.ts",
    "created_at": "2025-04-23T08:52:17+00:00",
    "commented_code": "return isVue(id)\n     },\n     async transform (code) {\n+      const codeWithoutComments = code\n+        .replace(MULTI_LINE_COMMENT_RE, '')\n+        .replace(SINGLE_LINE_COMMENT_RE, '\n')\n+\n+      const variables = new Set<string>()\n+      if (codeWithoutComments !== code) {\n+        for (const regex of EXCLUDE_RE) {\n+          for (const match of codeWithoutComments.matchAll(regex)) {\n+            if (!match[1]) { continue }\n+            variables.add(match[1])\n+          }\n+        }\n+      }\n+",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "2055572704",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31192,
        "pr_file": "packages/nuxt/src/components/plugins/lazy-hydration-transform.ts",
        "discussion_id": "2055572704",
        "commented_code": "@@ -41,6 +54,20 @@ export const LazyHydrationTransformPlugin = (options: LoaderOptions) => createUn\n       return isVue(id)\n     },\n     async transform (code) {\n+      const codeWithoutComments = code\n+        .replace(MULTI_LINE_COMMENT_RE, '')\n+        .replace(SINGLE_LINE_COMMENT_RE, '\\n')\n+\n+      const variables = new Set<string>()\n+      if (codeWithoutComments !== code) {\n+        for (const regex of EXCLUDE_RE) {\n+          for (const match of codeWithoutComments.matchAll(regex)) {\n+            if (!match[1]) { continue }\n+            variables.add(match[1])\n+          }\n+        }\n+      }\n+",
        "comment_created_at": "2025-04-23T08:52:17+00:00",
        "comment_author": "danielroe",
        "comment_body": "I'm not sure this is quite right. Do we only want to scan variables if the code has comments? And I think we should respect 'scope' rather than looking for any variable anywhere in the code.\r\n\r\nIn general I'd prefer to avoid using regexp for this. I feel a parsing-based scope-tracking approach would be sounder (but we can make that performant by only parsing the code if it code contains some of the 'reserved' names - if not we have a 'fast path' without parsing)",
        "pr_file_module": null
      },
      {
        "comment_id": "2055664244",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31192,
        "pr_file": "packages/nuxt/src/components/plugins/lazy-hydration-transform.ts",
        "discussion_id": "2055572704",
        "commented_code": "@@ -41,6 +54,20 @@ export const LazyHydrationTransformPlugin = (options: LoaderOptions) => createUn\n       return isVue(id)\n     },\n     async transform (code) {\n+      const codeWithoutComments = code\n+        .replace(MULTI_LINE_COMMENT_RE, '')\n+        .replace(SINGLE_LINE_COMMENT_RE, '\\n')\n+\n+      const variables = new Set<string>()\n+      if (codeWithoutComments !== code) {\n+        for (const regex of EXCLUDE_RE) {\n+          for (const match of codeWithoutComments.matchAll(regex)) {\n+            if (!match[1]) { continue }\n+            variables.add(match[1])\n+          }\n+        }\n+      }\n+",
        "comment_created_at": "2025-04-23T09:38:09+00:00",
        "comment_author": "Mini-ghost",
        "comment_body": "Thank you for pointing that out. I realized we probably shouldn\u2019t restrict variable scanning to cases where comments are present, so I\u2019ve submitted a corrected version accordingly.\r\n\r\nAlso, I just wanted to confirm, were you suggesting that using a JavaScript AST parser such as `acorn` might be a more reliable approach compared to using regular expressions?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1916654871",
    "pr_number": 30592,
    "pr_file": "packages/kit/src/utils.ts",
    "created_at": "2025-01-15T13:30:34+00:00",
    "commented_code": "export function filterInPlace<T> (array: T[], predicate: (item: T, index: number, arr: T[]) => unknown) {\n   for (let i = array.length; i--; i >= 0) {\n     if (!predicate(array[i]!, i, array)) {\n-      array.splice(i, 1)\n+      const last = --array.length\n+      if (i < last) {\n+        array[i] = array[last]!",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1916654871",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30592,
        "pr_file": "packages/kit/src/utils.ts",
        "discussion_id": "1916654871",
        "commented_code": "@@ -12,7 +12,10 @@ export function toArray<T> (value: T | T[]): T[] {\n export function filterInPlace<T> (array: T[], predicate: (item: T, index: number, arr: T[]) => unknown) {\n   for (let i = array.length; i--; i >= 0) {\n     if (!predicate(array[i]!, i, array)) {\n-      array.splice(i, 1)\n+      const last = --array.length\n+      if (i < last) {\n+        array[i] = array[last]!",
        "comment_created_at": "2025-01-15T13:30:34+00:00",
        "comment_author": "danielroe",
        "comment_body": "by this point `array[last]` will always be undefined because you've reduced the size of the array.\r\n\r\nhere's a functioning solution:\r\n\r\n```suggestion\r\n      const lastItem = data[data.length - 1]\r\n      if (i < --data.length) {\r\n        array[i] = lastItem\r\n```\r\n\r\nhowever, it's not faster than the existing implementation (see [benchmark](https://jsbenchmark.com/#eyJjYXNlcyI6W3siaWQiOiJXR01CMEJLVXgwbUJDYVc3NmFHSVciLCJjb2RlIjoibGV0IGEgPSBEQVRBXG5hID0gZmlsdGVyKGEsIGkgPT4gaSAlIDUwID09PSAwKVxuYSA9IGZpbHRlcihhLCBpID0-IGkgJSAxMCA9PT0gMClcbmEgPSBmaWx0ZXIoYSwgaSA9PiBpICUgMiA9PT0gMCkiLCJuYW1lIjoiZmlsdGVyIiwiZGVwZW5kZW5jaWVzIjpbXX0seyJpZCI6Ik9VSnozNU1QTkdhWVZ2eVo3S3A1UiIsImNvZGUiOiJsZXQgYSA9IERBVEFcbmEgPSBmaWx0ZXJJblBsYWNlKGEsIGkgPT4gaSAlIDUwID09PSAwKVxuYSA9IGZpbHRlckluUGxhY2UoYSwgaSA9PiBpICUgMTAgPT09IDApXG5hID0gZmlsdGVySW5QbGFjZShhLCBpID0-IGkgJSAyID09PSAwKSIsIm5hbWUiOiJmaWx0ZXJJblBsYWNlIiwiZGVwZW5kZW5jaWVzIjpbXX0seyJpZCI6InctMm8ybWt5VzBmUXZpdi1CTUdmbiIsImNvZGUiOiJsZXQgYSA9IERBVEFcbmEgPSB0dXJib0ZpbHRlckluUGxhY2UoYSwgaSA9PiBpICUgNTAgPT09IDApXG5hID0gdHVyYm9GaWx0ZXJJblBsYWNlKGEsIGkgPT4gaSAlIDEwID09PSAwKVxuYSA9IHR1cmJvRmlsdGVySW5QbGFjZShhLCBpID0-IGkgJSAyID09PSAwKSIsImRlcGVuZGVuY2llcyI6W10sIm5hbWUiOiJ0dXJib0ZpbHRlciJ9XSwiY29uZmlnIjp7Im5hbWUiOiJCYXNpYyBleGFtcGxlIiwicGFyYWxsZWwiOmZhbHNlLCJnbG9iYWxUZXN0Q29uZmlnIjp7ImRlcGVuZGVuY2llcyI6W119LCJkYXRhQ29kZSI6Imdsb2JhbFRoaXMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGRhdGEsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gZGF0YS5maWx0ZXIocHJlZGljYXRlKVxufVxuXG5nbG9iYWxUaGlzLmZpbHRlckluUGxhY2UgPSBmdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGRhdGEsIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGg7IGktLTsgaT49MCkge1xuICAgIGlmICghcHJlZGljYXRlKGRhdGFbaV0sIGksIGRhdGEpKVxuICAgICAgZGF0YS5zcGxpY2UoaSwgMSlcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5nbG9iYWxUaGlzLnR1cmJvRmlsdGVySW5QbGFjZSA9IGZ1bmN0aW9uIHR1cmJvRmlsdGVyKGRhdGEsIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGg7IGktLTsgaSA-PSAwKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUoZGF0YVtpXSwgaSwgZGF0YSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJdGVtID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdXG4gICAgICBpZiAoaSA8IC0tZGF0YS5sZW5ndGgpIGRhdGFbaV0gPSBsYXN0SXRlbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5yZXR1cm4gWy4uLkFycmF5KDUwMDAwKS5rZXlzKCksLi4uQXJyYXkoNTAwMDApLmtleXMoKSwuLi5BcnJheSg1MDAwMCkua2V5cygpXSJ9fQ))\r\n\r\nand @antfu is right - the performance improvement is probably not noticeable in a Nuxt app, and we do probably need to keep the order of the items in the array. (but I'd be open for metrics showing otherwise!)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1630929557",
    "pr_number": 27475,
    "pr_file": "packages/nuxt/src/core/nuxt.ts",
    "created_at": "2024-06-07T09:25:14+00:00",
    "commented_code": "watchedPaths.add(mod)\n       if (specifiedModules.has(mod)) { continue }\n       specifiedModules.add(mod)\n-      modulesToInstall.push(mod)\n+      modulesToInstall.add(mod)\n     }\n   }\n \n   // Register user and then ad-hoc modules\n-  modulesToInstall.push(...nuxt.options.modules, ...nuxt.options._modules)\n+  for (const key of ['modules', '_modules'] as const) {\n+    for (const item of nuxt.options[key]) {\n+      if (item) {",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1630929557",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27475,
        "pr_file": "packages/nuxt/src/core/nuxt.ts",
        "discussion_id": "1630929557",
        "commented_code": "@@ -300,12 +300,18 @@ async function initNuxt (nuxt: Nuxt) {\n       watchedPaths.add(mod)\n       if (specifiedModules.has(mod)) { continue }\n       specifiedModules.add(mod)\n-      modulesToInstall.push(mod)\n+      modulesToInstall.add(mod)\n     }\n   }\n \n   // Register user and then ad-hoc modules\n-  modulesToInstall.push(...nuxt.options.modules, ...nuxt.options._modules)\n+  for (const key of ['modules', '_modules'] as const) {\n+    for (const item of nuxt.options[key]) {\n+      if (item) {",
        "comment_created_at": "2024-06-07T09:25:14+00:00",
        "comment_author": "pi0",
        "comment_body": "Should we normalize options to one format to dedup more? (array/object/string)",
        "pr_file_module": null
      },
      {
        "comment_id": "1630941672",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27475,
        "pr_file": "packages/nuxt/src/core/nuxt.ts",
        "discussion_id": "1630929557",
        "commented_code": "@@ -300,12 +300,18 @@ async function initNuxt (nuxt: Nuxt) {\n       watchedPaths.add(mod)\n       if (specifiedModules.has(mod)) { continue }\n       specifiedModules.add(mod)\n-      modulesToInstall.push(mod)\n+      modulesToInstall.add(mod)\n     }\n   }\n \n   // Register user and then ad-hoc modules\n-  modulesToInstall.push(...nuxt.options.modules, ...nuxt.options._modules)\n+  for (const key of ['modules', '_modules'] as const) {\n+    for (const item of nuxt.options[key]) {\n+      if (item) {",
        "comment_created_at": "2024-06-07T09:34:49+00:00",
        "comment_author": "danielroe",
        "comment_body": "Unfortunately I don't think that would work with a Set - though maybe we could use an object and iterate over its keys? What do you think about perf tradeoff?",
        "pr_file_module": null
      },
      {
        "comment_id": "1630945162",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27475,
        "pr_file": "packages/nuxt/src/core/nuxt.ts",
        "discussion_id": "1630929557",
        "commented_code": "@@ -300,12 +300,18 @@ async function initNuxt (nuxt: Nuxt) {\n       watchedPaths.add(mod)\n       if (specifiedModules.has(mod)) { continue }\n       specifiedModules.add(mod)\n-      modulesToInstall.push(mod)\n+      modulesToInstall.add(mod)\n     }\n   }\n \n   // Register user and then ad-hoc modules\n-  modulesToInstall.push(...nuxt.options.modules, ...nuxt.options._modules)\n+  for (const key of ['modules', '_modules'] as const) {\n+    for (const item of nuxt.options[key]) {\n+      if (item) {",
        "comment_created_at": "2024-06-07T09:37:50+00:00",
        "comment_author": "pi0",
        "comment_body": "Keyed object (or map?) makes sense!",
        "pr_file_module": null
      }
    ]
  }
]