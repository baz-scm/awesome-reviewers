[
  {
    "discussion_id": "1983211161",
    "pr_number": 31230,
    "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
    "created_at": "2025-03-06T11:47:02+00:00",
    "commented_code": "import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\n' + stack.map(l => '  ' + l.text).join('  \n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1983211161",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31230,
        "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
        "discussion_id": "1983211161",
        "commented_code": "@@ -1,54 +1,44 @@\n import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\\n' + stack.map(l => '  ' + l.text).join('  \\n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
        "comment_created_at": "2025-03-06T11:47:02+00:00",
        "comment_author": "pi0",
        "comment_body": "We are discarding any possible future headers from default handler (including important cache control for not caching errors in browser). could add `...defaultError.headers`",
        "pr_file_module": null
      },
      {
        "comment_id": "1983215565",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31230,
        "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
        "discussion_id": "1983211161",
        "commented_code": "@@ -1,54 +1,44 @@\n import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\\n' + stack.map(l => '  ' + l.text).join('  \\n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
        "comment_created_at": "2025-03-06T11:50:27+00:00",
        "comment_author": "danielroe",
        "comment_body": "I was wanting to avoid fragility in case you changed case of headers or added some additional ones that would break JS-enabled error pages (as we render in Nuxt).",
        "pr_file_module": null
      },
      {
        "comment_id": "1983222859",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31230,
        "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
        "discussion_id": "1983211161",
        "commented_code": "@@ -1,54 +1,44 @@\n import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\\n' + stack.map(l => '  ' + l.text).join('  \\n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
        "comment_created_at": "2025-03-06T11:55:49+00:00",
        "comment_author": "pi0",
        "comment_body": "i intentionally made them lowercase (in https://github.com/nitrojs/nitro/pull/3161) since we exposed it now, so it should be safe with lowercase. i suggest to keep extending.",
        "pr_file_module": null
      },
      {
        "comment_id": "1983224149",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31230,
        "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
        "discussion_id": "1983211161",
        "commented_code": "@@ -1,54 +1,44 @@\n import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\\n' + stack.map(l => '  ' + l.text).join('  \\n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
        "comment_created_at": "2025-03-06T11:56:41+00:00",
        "comment_author": "danielroe",
        "comment_body": "`Cache-Control` doesn't seem to be lowercase, fyi, in dev, though it is in prod",
        "pr_file_module": null
      },
      {
        "comment_id": "1983230917",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31230,
        "pr_file": "packages/nuxt/src/core/runtime/nitro/handlers/error.ts",
        "discussion_id": "1983211161",
        "commented_code": "@@ -1,54 +1,44 @@\n import { joinURL, withQuery } from 'ufo'\n import type { NitroErrorHandler } from 'nitropack'\n-import type { H3Error } from 'h3'\n-import { getRequestHeaders, send, setResponseHeader, setResponseStatus } from 'h3'\n-\n-import type { NuxtPayload } from 'nuxt/app'\n+import { getRequestHeaders, send, setResponseHeader, setResponseHeaders, setResponseStatus } from 'h3'\n \n+import { isJsonRequest } from '../utils/error'\n import { useRuntimeConfig } from '#internal/nitro'\n import { useNitroApp } from '#internal/nitro/app'\n-import { isJsonRequest, normalizeError } from '#internal/nitro/utils'\n-\n-export default <NitroErrorHandler> async function errorhandler (error: H3Error, event) {\n-  // Parse and normalize error\n-  const { stack, statusCode, statusMessage, message } = normalizeError(error)\n+import type { NuxtPayload } from '#app/nuxt'\n \n-  // Create an error object\n-  const errorObject = {\n-    url: event.path,\n-    statusCode,\n-    statusMessage,\n-    message,\n-    stack: import.meta.dev && statusCode !== 404\n-      ? `<pre>${stack.map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')}</pre>`\n-      : '',\n-    // TODO: check and validate error.data for serialisation into query\n-    data: error.data as any,\n-  } satisfies Partial<NuxtPayload['error']> & { url: string }\n-\n-  // Console output\n-  if (error.unhandled || error.fatal) {\n-    const tags = [\n-      '[nuxt]',\n-      '[request error]',\n-      error.unhandled && '[unhandled]',\n-      error.fatal && '[fatal]',\n-      Number(errorObject.statusCode) !== 200 && `[${errorObject.statusCode}]`,\n-    ].filter(Boolean).join(' ')\n-    console.error(tags, (error.message || error.toString() || 'internal server error') + '\\n' + stack.map(l => '  ' + l.text).join('  \\n'))\n+export default <NitroErrorHandler> async function errorhandler (error, event, { defaultHandler }) {\n+  if (isJsonRequest(event)) {\n+    // let Nitro handle JSON errors\n+    return\n   }\n+  // invoke default Nitro error handler (which will log appropriately if required)\n+  const defaultError = await defaultHandler(error, event, { json: true })\n \n   if (event.handled) { return }\n \n-  // Set response code and message\n-  setResponseStatus(event, (errorObject.statusCode !== 200 && errorObject.statusCode) as any as number || 500, errorObject.statusMessage)\n+  // let Nitro handle redirect if appropriate\n+  const statusCode = error.statusCode || 500\n+  if (statusCode === 404 && defaultError.status === 302) {\n+    return defaultError\n+  }\n \n-  // JSON response\n-  if (isJsonRequest(event)) {\n-    setResponseHeader(event, 'Content-Type', 'application/json')\n-    return send(event, JSON.stringify(errorObject))\n+  if (import.meta.dev && typeof defaultError.body !== 'string' && Array.isArray(defaultError.body.stack)) {\n+    // normalize to string format expected by nuxt `error.vue`\n+    defaultError.body.stack = defaultError.body.stack.join('\\n')\n   }\n \n+  const errorObject = defaultError.body as Pick<NonNullable<NuxtPayload['error']>, 'error' | 'statusCode' | 'statusMessage' | 'message' | 'stack'> & { url: string, data: any }\n+  errorObject.message ||= 'Server Error'\n+\n+  setResponseHeaders(event, {\n+    'x-content-type-options': defaultError.headers['x-content-type-options'],",
        "comment_created_at": "2025-03-06T12:01:49+00:00",
        "comment_author": "pi0",
        "comment_body": "https://github.com/nitrojs/nitro/commit/e3866d04130b6ac9deb712a1f92515e85e880c43",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1926669835",
    "pr_number": 30717,
    "pr_file": "packages/nuxt/src/pages/utils.ts",
    "created_at": "2025-01-23T09:42:16+00:00",
    "commented_code": "})\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1926669835",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-23T09:42:16+00:00",
        "comment_author": "danielroe",
        "comment_body": "would it resolve it just to do something like:\r\n\r\n```suggestion\r\n  return JSON.parse(JSON.stringify(extractedMeta))\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1926694952",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-23T09:58:42+00:00",
        "comment_author": "xjccc",
        "comment_body": "```\r\n  if (absolutePath in metaCache && metaCache[absolutePath]) {\r\n    return metaCache[absolutePath]\r\n  }\r\n```\r\n\r\nI think it's the reason here? Has `key of absolutePath` cache, `return the first cache`?\r\n\r\nBecause the file is the same by `page:extends`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1926838721",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-23T11:39:04+00:00",
        "comment_author": "danielroe",
        "comment_body": "yes, we'd also have to update it there too",
        "pr_file_module": null
      },
      {
        "comment_id": "1927975783",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-24T01:49:10+00:00",
        "comment_author": "xjccc",
        "comment_body": "Yes, you are right. Thank you very much. I will update it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1927986625",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-24T02:08:02+00:00",
        "comment_author": "xjccc",
        "comment_body": "Oh.. `extraxtedMeta` has `Set` properties. So, `JSON.stringify` has some problem.. Is there any good solutions?",
        "pr_file_module": null
      },
      {
        "comment_id": "1928216093",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-24T07:25:54+00:00",
        "comment_author": "danielroe",
        "comment_body": "we could use klona",
        "pr_file_module": null
      },
      {
        "comment_id": "1928293090",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-24T08:08:48+00:00",
        "comment_author": "xjccc",
        "comment_body": "I have changed this. Please check it out. Thank you very much. \u2764",
        "pr_file_module": null
      },
      {
        "comment_id": "1928355691",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30717,
        "pr_file": "packages/nuxt/src/pages/utils.ts",
        "discussion_id": "1926669835",
        "commented_code": "@@ -313,7 +316,7 @@ export async function getRouteMeta (contents: string, absolutePath: string, extr\n     })\n   }\n \n-  metaCache[absolutePath] = extractedMeta\n+  metaCache[cacheKey] = extractedMeta\n   return extractedMeta",
        "comment_created_at": "2025-01-24T09:02:52+00:00",
        "comment_author": "danielroe",
        "comment_body": "you had some nice tests in the previous commit\u2026. is it worth keeping them?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1279371073",
    "pr_number": 21641,
    "pr_file": "packages/nuxt/src/app/composables/manifest.ts",
    "created_at": "2023-07-31T14:20:05+00:00",
    "commented_code": "+import { joinURL } from 'ufo'\n+import { useRuntimeConfig } from '#app'\n+\n+export interface NuxtAppManifest {\n+  id: string\n+  timestamp: number\n+  routeRules: Record<string, any>\n+  prerendered: string[]\n+}\n+\n+let manifest: Promise<NuxtAppManifest>\n+\n+export function getAppManifest (): Promise<NuxtAppManifest> {\n+  const config = useRuntimeConfig()\n+  // TODO: use build id injected\n+  manifest = manifest || $fetch(joinURL(config.app.cdnURL || config.app.baseURL, '_builds/latest.json'))",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1279371073",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 21641,
        "pr_file": "packages/nuxt/src/app/composables/manifest.ts",
        "discussion_id": "1279371073",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { joinURL } from 'ufo'\n+import { useRuntimeConfig } from '#app'\n+\n+export interface NuxtAppManifest {\n+  id: string\n+  timestamp: number\n+  routeRules: Record<string, any>\n+  prerendered: string[]\n+}\n+\n+let manifest: Promise<NuxtAppManifest>\n+\n+export function getAppManifest (): Promise<NuxtAppManifest> {\n+  const config = useRuntimeConfig()\n+  // TODO: use build id injected\n+  manifest = manifest || $fetch(joinURL(config.app.cdnURL || config.app.baseURL, '_builds/latest.json'))",
        "comment_created_at": "2023-07-31T14:20:05+00:00",
        "comment_author": "pi0",
        "comment_body": "It would be nice if we can handle promise rejections to clear value and improve error",
        "pr_file_module": null
      },
      {
        "comment_id": "1279375487",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 21641,
        "pr_file": "packages/nuxt/src/app/composables/manifest.ts",
        "discussion_id": "1279371073",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { joinURL } from 'ufo'\n+import { useRuntimeConfig } from '#app'\n+\n+export interface NuxtAppManifest {\n+  id: string\n+  timestamp: number\n+  routeRules: Record<string, any>\n+  prerendered: string[]\n+}\n+\n+let manifest: Promise<NuxtAppManifest>\n+\n+export function getAppManifest (): Promise<NuxtAppManifest> {\n+  const config = useRuntimeConfig()\n+  // TODO: use build id injected\n+  manifest = manifest || $fetch(joinURL(config.app.cdnURL || config.app.baseURL, '_builds/latest.json'))",
        "comment_created_at": "2023-07-31T14:22:40+00:00",
        "comment_author": "pi0",
        "comment_body": "PS: We need a ttl somehow. User opens page and fetches manifest > a deploy happens > client side navigation is again not aware of updates!",
        "pr_file_module": null
      },
      {
        "comment_id": "1298153536",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 21641,
        "pr_file": "packages/nuxt/src/app/composables/manifest.ts",
        "discussion_id": "1279371073",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { joinURL } from 'ufo'\n+import { useRuntimeConfig } from '#app'\n+\n+export interface NuxtAppManifest {\n+  id: string\n+  timestamp: number\n+  routeRules: Record<string, any>\n+  prerendered: string[]\n+}\n+\n+let manifest: Promise<NuxtAppManifest>\n+\n+export function getAppManifest (): Promise<NuxtAppManifest> {\n+  const config = useRuntimeConfig()\n+  // TODO: use build id injected\n+  manifest = manifest || $fetch(joinURL(config.app.cdnURL || config.app.baseURL, '_builds/latest.json'))",
        "comment_created_at": "2023-08-18T08:13:34+00:00",
        "comment_author": "danielroe",
        "comment_body": "excellent point. on it \ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "1298444523",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 21641,
        "pr_file": "packages/nuxt/src/app/composables/manifest.ts",
        "discussion_id": "1279371073",
        "commented_code": "@@ -0,0 +1,18 @@\n+import { joinURL } from 'ufo'\n+import { useRuntimeConfig } from '#app'\n+\n+export interface NuxtAppManifest {\n+  id: string\n+  timestamp: number\n+  routeRules: Record<string, any>\n+  prerendered: string[]\n+}\n+\n+let manifest: Promise<NuxtAppManifest>\n+\n+export function getAppManifest (): Promise<NuxtAppManifest> {\n+  const config = useRuntimeConfig()\n+  // TODO: use build id injected\n+  manifest = manifest || $fetch(joinURL(config.app.cdnURL || config.app.baseURL, '_builds/latest.json'))",
        "comment_created_at": "2023-08-18T13:19:45+00:00",
        "comment_author": "danielroe",
        "comment_body": "actually, seems I already implemented at https://github.com/nuxt/nuxt/commit/4f85cff8d94c575c5f4238a4a8f8472beb1bce5d. Review very appreciated \ud83d\ude4f ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1721645867",
    "pr_number": 28594,
    "pr_file": "packages/schema/src/config/common.ts",
    "created_at": "2024-08-19T11:29:47+00:00",
    "commented_code": "* ```\n    */\n   buildDir: {\n-    $resolve: async (val: string | undefined, get): Promise<string> => resolve(await get('rootDir') as string, val || '.nuxt'),\n+    $resolve: async (val: string | undefined, get): Promise<string> => {\n+      const rootDir = await get('rootDir') as string\n+\n+      if (val) {\n+        return resolve(rootDir, val)\n+      }\n+\n+      const defaultBuildDir = resolve(rootDir, '.nuxt')\n+\n+      const isDev = await get('dev') as boolean\n+      if (isDev) {\n+        return defaultBuildDir\n+      }\n+\n+      const buildId = await get('buildId') as string\n+\n+      // TODO: nuxi CLI should ensure .nuxt dir exists\n+      if (!existsSync(defaultBuildDir)) {\n+        // This is to ensure that types continue to work for CI builds\n+        return defaultBuildDir\n+      }\n+\n+      // TODO: handle build caching\n+      return resolve(rootDir, 'node_modules/.cache/nuxt/builds', buildId)",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1721645867",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 28594,
        "pr_file": "packages/schema/src/config/common.ts",
        "discussion_id": "1721645867",
        "commented_code": "@@ -175,7 +175,31 @@ export default defineUntypedSchema({\n    * ```\n    */\n   buildDir: {\n-    $resolve: async (val: string | undefined, get): Promise<string> => resolve(await get('rootDir') as string, val || '.nuxt'),\n+    $resolve: async (val: string | undefined, get): Promise<string> => {\n+      const rootDir = await get('rootDir') as string\n+\n+      if (val) {\n+        return resolve(rootDir, val)\n+      }\n+\n+      const defaultBuildDir = resolve(rootDir, '.nuxt')\n+\n+      const isDev = await get('dev') as boolean\n+      if (isDev) {\n+        return defaultBuildDir\n+      }\n+\n+      const buildId = await get('buildId') as string\n+\n+      // TODO: nuxi CLI should ensure .nuxt dir exists\n+      if (!existsSync(defaultBuildDir)) {\n+        // This is to ensure that types continue to work for CI builds\n+        return defaultBuildDir\n+      }\n+\n+      // TODO: handle build caching\n+      return resolve(rootDir, 'node_modules/.cache/nuxt/builds', buildId)",
        "comment_created_at": "2024-08-19T11:29:47+00:00",
        "comment_author": "pi0",
        "comment_body": "(maybe in later pr) we probably need to take care about GC. Size of this dir can be so big over the time. One fast start might be to keep `.cache/nuxt/builds.json` with id + date (so we can gc)",
        "pr_file_module": null
      },
      {
        "comment_id": "1721647852",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 28594,
        "pr_file": "packages/schema/src/config/common.ts",
        "discussion_id": "1721645867",
        "commented_code": "@@ -175,7 +175,31 @@ export default defineUntypedSchema({\n    * ```\n    */\n   buildDir: {\n-    $resolve: async (val: string | undefined, get): Promise<string> => resolve(await get('rootDir') as string, val || '.nuxt'),\n+    $resolve: async (val: string | undefined, get): Promise<string> => {\n+      const rootDir = await get('rootDir') as string\n+\n+      if (val) {\n+        return resolve(rootDir, val)\n+      }\n+\n+      const defaultBuildDir = resolve(rootDir, '.nuxt')\n+\n+      const isDev = await get('dev') as boolean\n+      if (isDev) {\n+        return defaultBuildDir\n+      }\n+\n+      const buildId = await get('buildId') as string\n+\n+      // TODO: nuxi CLI should ensure .nuxt dir exists\n+      if (!existsSync(defaultBuildDir)) {\n+        // This is to ensure that types continue to work for CI builds\n+        return defaultBuildDir\n+      }\n+\n+      // TODO: handle build caching\n+      return resolve(rootDir, 'node_modules/.cache/nuxt/builds', buildId)",
        "comment_created_at": "2024-08-19T11:31:41+00:00",
        "comment_author": "danielroe",
        "comment_body": "Agreed!",
        "pr_file_module": null
      }
    ]
  }
]