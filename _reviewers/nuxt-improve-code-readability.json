[
  {
    "discussion_id": "1642930101",
    "pr_number": 25906,
    "pr_file": "packages/nuxt/src/core/app.ts",
    "created_at": "2024-06-17T14:41:03+00:00",
    "commented_code": "checkDeps(name)\n   }\n }\n+\n+const ORDERED_FILE_RE = /^\\d+\\./\n+\n+function sortMiddleware (middleware: NuxtMiddleware[]) {\n+  const orderedMiddleware: NuxtMiddleware[] = []\n+  const unorderedMiddleware: NuxtMiddleware[] = []\n+\n+  for (const mw of middleware) {\n+    const bucket = mw.global && ORDERED_FILE_RE.test(filename(mw.path)) ? orderedMiddleware : unorderedMiddleware\n+    bucket.push(mw)\n+  }\n+\n+  return [\n+    ...orderedMiddleware.sort((l, r) => filename(l.path).localeCompare(filename(r.path))),\n+    ...unorderedMiddleware\n+  ]\n+}\n+\n+function sortPlugins (plugins: NuxtPlugin[]) {\n+  const orderedPlugins: NuxtPlugin[] = []\n+  const unorderedPlugins: NuxtPlugin[] = []\n+\n+  for (const plugin of plugins) {\n+    const bucket = ORDERED_FILE_RE.test(filename(plugin.src)) ? orderedPlugins : unorderedPlugins\n+    bucket.push(plugin)\n+  }\n+\n+  return [\n+    ...orderedPlugins.sort((l, r) => filename(l.src).localeCompare(filename(r.src))),\n+    ...unorderedPlugins\n+  ]\n+}\n+\n+function uniquePlugins (plugins: NuxtPlugin[]) {\n+  const pluginFlags = new Set<string>()\n+  const bucket: NuxtPlugin[] = []\n+  for (const plugin of [...plugins].reverse()) {\n+    const name = plugin.name ? plugin.name : filename(plugin.src)\n+    const mode = plugin.mode ? plugin.mode : 'all'\n+    const flag = `${name}.${mode}`\n+    if (pluginFlags.has(flag)) {\n+      continue\n+    }\n+    pluginFlags.add(flag)\n+    bucket.push(plugin)\n+  }\n+  return bucket.reverse()",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1642930101",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 25906,
        "pr_file": "packages/nuxt/src/core/app.ts",
        "discussion_id": "1642930101",
        "commented_code": "@@ -252,3 +254,51 @@ export function checkForCircularDependencies (_plugins: Array<NuxtPlugin & Omit<\n     checkDeps(name)\n   }\n }\n+\n+const ORDERED_FILE_RE = /^\\d+\\./\n+\n+function sortMiddleware (middleware: NuxtMiddleware[]) {\n+  const orderedMiddleware: NuxtMiddleware[] = []\n+  const unorderedMiddleware: NuxtMiddleware[] = []\n+\n+  for (const mw of middleware) {\n+    const bucket = mw.global && ORDERED_FILE_RE.test(filename(mw.path)) ? orderedMiddleware : unorderedMiddleware\n+    bucket.push(mw)\n+  }\n+\n+  return [\n+    ...orderedMiddleware.sort((l, r) => filename(l.path).localeCompare(filename(r.path))),\n+    ...unorderedMiddleware\n+  ]\n+}\n+\n+function sortPlugins (plugins: NuxtPlugin[]) {\n+  const orderedPlugins: NuxtPlugin[] = []\n+  const unorderedPlugins: NuxtPlugin[] = []\n+\n+  for (const plugin of plugins) {\n+    const bucket = ORDERED_FILE_RE.test(filename(plugin.src)) ? orderedPlugins : unorderedPlugins\n+    bucket.push(plugin)\n+  }\n+\n+  return [\n+    ...orderedPlugins.sort((l, r) => filename(l.src).localeCompare(filename(r.src))),\n+    ...unorderedPlugins\n+  ]\n+}\n+\n+function uniquePlugins (plugins: NuxtPlugin[]) {\n+  const pluginFlags = new Set<string>()\n+  const bucket: NuxtPlugin[] = []\n+  for (const plugin of [...plugins].reverse()) {\n+    const name = plugin.name ? plugin.name : filename(plugin.src)\n+    const mode = plugin.mode ? plugin.mode : 'all'\n+    const flag = `${name}.${mode}`\n+    if (pluginFlags.has(flag)) {\n+      continue\n+    }\n+    pluginFlags.add(flag)\n+    bucket.push(plugin)\n+  }\n+  return bucket.reverse()",
        "comment_created_at": "2024-06-17T14:41:03+00:00",
        "comment_author": "Kronhyx",
        "comment_body": "```suggestion\r\nfunction uniquePlugins (plugins: NuxtPlugin[]) {\r\n  const pluginFlags = new Set<string>()\r\n  const bucket: NuxtPlugin[] = []\r\n\r\n  for (const plugin of [...plugins].reverse()) {\r\n    const name = plugin.name ? plugin.name : filename(plugin.src)\r\n    const mode = plugin.mode ? plugin.mode : 'all'\r\n    const flag = `${name}.${mode}`\r\n\r\n    if (pluginFlags.has(flag)) {\r\n      continue\r\n    }\r\n\r\n    pluginFlags.add(flag)\r\n    bucket.push(plugin)\r\n  }\r\n\r\n  return bucket.reverse()\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1642932058",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 25906,
        "pr_file": "packages/nuxt/src/core/app.ts",
        "discussion_id": "1642930101",
        "commented_code": "@@ -252,3 +254,51 @@ export function checkForCircularDependencies (_plugins: Array<NuxtPlugin & Omit<\n     checkDeps(name)\n   }\n }\n+\n+const ORDERED_FILE_RE = /^\\d+\\./\n+\n+function sortMiddleware (middleware: NuxtMiddleware[]) {\n+  const orderedMiddleware: NuxtMiddleware[] = []\n+  const unorderedMiddleware: NuxtMiddleware[] = []\n+\n+  for (const mw of middleware) {\n+    const bucket = mw.global && ORDERED_FILE_RE.test(filename(mw.path)) ? orderedMiddleware : unorderedMiddleware\n+    bucket.push(mw)\n+  }\n+\n+  return [\n+    ...orderedMiddleware.sort((l, r) => filename(l.path).localeCompare(filename(r.path))),\n+    ...unorderedMiddleware\n+  ]\n+}\n+\n+function sortPlugins (plugins: NuxtPlugin[]) {\n+  const orderedPlugins: NuxtPlugin[] = []\n+  const unorderedPlugins: NuxtPlugin[] = []\n+\n+  for (const plugin of plugins) {\n+    const bucket = ORDERED_FILE_RE.test(filename(plugin.src)) ? orderedPlugins : unorderedPlugins\n+    bucket.push(plugin)\n+  }\n+\n+  return [\n+    ...orderedPlugins.sort((l, r) => filename(l.src).localeCompare(filename(r.src))),\n+    ...unorderedPlugins\n+  ]\n+}\n+\n+function uniquePlugins (plugins: NuxtPlugin[]) {\n+  const pluginFlags = new Set<string>()\n+  const bucket: NuxtPlugin[] = []\n+  for (const plugin of [...plugins].reverse()) {\n+    const name = plugin.name ? plugin.name : filename(plugin.src)\n+    const mode = plugin.mode ? plugin.mode : 'all'\n+    const flag = `${name}.${mode}`\n+    if (pluginFlags.has(flag)) {\n+      continue\n+    }\n+    pluginFlags.add(flag)\n+    bucket.push(plugin)\n+  }\n+  return bucket.reverse()",
        "comment_created_at": "2024-06-17T14:42:22+00:00",
        "comment_author": "Kronhyx",
        "comment_body": "add line breaks to improve readability",
        "pr_file_module": null
      },
      {
        "comment_id": "1928868874",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 25906,
        "pr_file": "packages/nuxt/src/core/app.ts",
        "discussion_id": "1642930101",
        "commented_code": "@@ -252,3 +254,51 @@ export function checkForCircularDependencies (_plugins: Array<NuxtPlugin & Omit<\n     checkDeps(name)\n   }\n }\n+\n+const ORDERED_FILE_RE = /^\\d+\\./\n+\n+function sortMiddleware (middleware: NuxtMiddleware[]) {\n+  const orderedMiddleware: NuxtMiddleware[] = []\n+  const unorderedMiddleware: NuxtMiddleware[] = []\n+\n+  for (const mw of middleware) {\n+    const bucket = mw.global && ORDERED_FILE_RE.test(filename(mw.path)) ? orderedMiddleware : unorderedMiddleware\n+    bucket.push(mw)\n+  }\n+\n+  return [\n+    ...orderedMiddleware.sort((l, r) => filename(l.path).localeCompare(filename(r.path))),\n+    ...unorderedMiddleware\n+  ]\n+}\n+\n+function sortPlugins (plugins: NuxtPlugin[]) {\n+  const orderedPlugins: NuxtPlugin[] = []\n+  const unorderedPlugins: NuxtPlugin[] = []\n+\n+  for (const plugin of plugins) {\n+    const bucket = ORDERED_FILE_RE.test(filename(plugin.src)) ? orderedPlugins : unorderedPlugins\n+    bucket.push(plugin)\n+  }\n+\n+  return [\n+    ...orderedPlugins.sort((l, r) => filename(l.src).localeCompare(filename(r.src))),\n+    ...unorderedPlugins\n+  ]\n+}\n+\n+function uniquePlugins (plugins: NuxtPlugin[]) {\n+  const pluginFlags = new Set<string>()\n+  const bucket: NuxtPlugin[] = []\n+  for (const plugin of [...plugins].reverse()) {\n+    const name = plugin.name ? plugin.name : filename(plugin.src)\n+    const mode = plugin.mode ? plugin.mode : 'all'\n+    const flag = `${name}.${mode}`\n+    if (pluginFlags.has(flag)) {\n+      continue\n+    }\n+    pluginFlags.add(flag)\n+    bucket.push(plugin)\n+  }\n+  return bucket.reverse()",
        "comment_created_at": "2025-01-24T15:30:37+00:00",
        "comment_author": "oemer-aran",
        "comment_body": "@markthree Any reason leaving this PR? I would really love this to be merged to remove some ugly workarounds! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1444070394",
    "pr_number": 24960,
    "pr_file": "packages/nuxt/src/pages/runtime/router.options.ts",
    "created_at": "2024-01-07T20:49:54+00:00",
    "commented_code": "// Default router options\n // https://router.vuejs.org/api/#routeroptions\n-export default <RouterConfig> {\n-  scrollBehavior (to, from, savedPosition) {\n+export default <RouterConfig>{\n+  scrollBehavior: (\n+    to: RouteLocationNormalized,\n+    from: RouteLocationNormalized,\n+    savedPosition: ScrollPosition | null\n+  ) => {\n+    // Check if the navigation is the first page load\n+    const isFirstLoad = from === START_LOCATION\n     const nuxtApp = useNuxtApp()\n     // @ts-expect-error untyped, nuxt-injected option\n-    const behavior = useRouter().options?.scrollBehaviorType ?? 'auto'\n+    const scrollBehaviourType = useRouter().options?.scrollBehaviorType ?? 'auto'\n \n-    // By default when the returned position is falsy or an empty object, vue-router will retain the current scroll position\n-    // savedPosition is only available for popstate navigations (back button)\n-    let position: ScrollPosition = savedPosition || undefined\n+    // Handle page reload scenario where the saved position should be used\n+    if (isFirstLoad && savedPosition) {\n+      // Restore browser's default scroll behavior to auto (vue-router sets this when using custom ScrollBehavior)\n+      // to avoid page jumps on load\n+      window.history.scrollRestoration = 'auto'\n+      return savedPosition\n+    } else {\n+      // For other navigations, ensure manual scrollRestoration\n+      window.history.scrollRestoration = 'manual'\n+    }\n \n+    // Check if the route explicitly disables automatic scroll to top\n     const routeAllowsScrollToTop = typeof to.meta.scrollToTop === 'function' ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop\n-\n-    // Scroll to top if route is changed by default\n-    if (!position && from && to && routeAllowsScrollToTop !== false && isChangingPage(to, from)) {\n-      position = { left: 0, top: 0 }\n+    if (routeAllowsScrollToTop === false) {\n+      return false // Do not scroll to top if the route disallows it\n     }\n \n-    // Hash routes on the same page, no page hook is fired so resolve here\n-    if (to.path === from.path) {\n-      if (from.hash && !to.hash) {\n-        return { left: 0, top: 0 }\n+    const calculatePosition = (behavior: ScrollBehavior): ScrollPosition => {",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1444070394",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 24960,
        "pr_file": "packages/nuxt/src/pages/runtime/router.options.ts",
        "discussion_id": "1444070394",
        "commented_code": "@@ -11,43 +11,70 @@ type ScrollPosition = Awaited<ReturnType<RouterScrollBehavior>>\n \n // Default router options\n // https://router.vuejs.org/api/#routeroptions\n-export default <RouterConfig> {\n-  scrollBehavior (to, from, savedPosition) {\n+export default <RouterConfig>{\n+  scrollBehavior: (\n+    to: RouteLocationNormalized,\n+    from: RouteLocationNormalized,\n+    savedPosition: ScrollPosition | null\n+  ) => {\n+    // Check if the navigation is the first page load\n+    const isFirstLoad = from === START_LOCATION\n     const nuxtApp = useNuxtApp()\n     // @ts-expect-error untyped, nuxt-injected option\n-    const behavior = useRouter().options?.scrollBehaviorType ?? 'auto'\n+    const scrollBehaviourType = useRouter().options?.scrollBehaviorType ?? 'auto'\n \n-    // By default when the returned position is falsy or an empty object, vue-router will retain the current scroll position\n-    // savedPosition is only available for popstate navigations (back button)\n-    let position: ScrollPosition = savedPosition || undefined\n+    // Handle page reload scenario where the saved position should be used\n+    if (isFirstLoad && savedPosition) {\n+      // Restore browser's default scroll behavior to auto (vue-router sets this when using custom ScrollBehavior)\n+      // to avoid page jumps on load\n+      window.history.scrollRestoration = 'auto'\n+      return savedPosition\n+    } else {\n+      // For other navigations, ensure manual scrollRestoration\n+      window.history.scrollRestoration = 'manual'\n+    }\n \n+    // Check if the route explicitly disables automatic scroll to top\n     const routeAllowsScrollToTop = typeof to.meta.scrollToTop === 'function' ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop\n-\n-    // Scroll to top if route is changed by default\n-    if (!position && from && to && routeAllowsScrollToTop !== false && isChangingPage(to, from)) {\n-      position = { left: 0, top: 0 }\n+    if (routeAllowsScrollToTop === false) {\n+      return false // Do not scroll to top if the route disallows it\n     }\n \n-    // Hash routes on the same page, no page hook is fired so resolve here\n-    if (to.path === from.path) {\n-      if (from.hash && !to.hash) {\n-        return { left: 0, top: 0 }\n+    const calculatePosition = (behavior: ScrollBehavior): ScrollPosition => {",
        "comment_created_at": "2024-01-07T20:49:54+00:00",
        "comment_author": "TheAlexLichter",
        "comment_body": "Could we move this out of the function and pass the `to` as well? \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1444074656",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 24960,
        "pr_file": "packages/nuxt/src/pages/runtime/router.options.ts",
        "discussion_id": "1444070394",
        "commented_code": "@@ -11,43 +11,70 @@ type ScrollPosition = Awaited<ReturnType<RouterScrollBehavior>>\n \n // Default router options\n // https://router.vuejs.org/api/#routeroptions\n-export default <RouterConfig> {\n-  scrollBehavior (to, from, savedPosition) {\n+export default <RouterConfig>{\n+  scrollBehavior: (\n+    to: RouteLocationNormalized,\n+    from: RouteLocationNormalized,\n+    savedPosition: ScrollPosition | null\n+  ) => {\n+    // Check if the navigation is the first page load\n+    const isFirstLoad = from === START_LOCATION\n     const nuxtApp = useNuxtApp()\n     // @ts-expect-error untyped, nuxt-injected option\n-    const behavior = useRouter().options?.scrollBehaviorType ?? 'auto'\n+    const scrollBehaviourType = useRouter().options?.scrollBehaviorType ?? 'auto'\n \n-    // By default when the returned position is falsy or an empty object, vue-router will retain the current scroll position\n-    // savedPosition is only available for popstate navigations (back button)\n-    let position: ScrollPosition = savedPosition || undefined\n+    // Handle page reload scenario where the saved position should be used\n+    if (isFirstLoad && savedPosition) {\n+      // Restore browser's default scroll behavior to auto (vue-router sets this when using custom ScrollBehavior)\n+      // to avoid page jumps on load\n+      window.history.scrollRestoration = 'auto'\n+      return savedPosition\n+    } else {\n+      // For other navigations, ensure manual scrollRestoration\n+      window.history.scrollRestoration = 'manual'\n+    }\n \n+    // Check if the route explicitly disables automatic scroll to top\n     const routeAllowsScrollToTop = typeof to.meta.scrollToTop === 'function' ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop\n-\n-    // Scroll to top if route is changed by default\n-    if (!position && from && to && routeAllowsScrollToTop !== false && isChangingPage(to, from)) {\n-      position = { left: 0, top: 0 }\n+    if (routeAllowsScrollToTop === false) {\n+      return false // Do not scroll to top if the route disallows it\n     }\n \n-    // Hash routes on the same page, no page hook is fired so resolve here\n-    if (to.path === from.path) {\n-      if (from.hash && !to.hash) {\n-        return { left: 0, top: 0 }\n+    const calculatePosition = (behavior: ScrollBehavior): ScrollPosition => {",
        "comment_created_at": "2024-01-07T21:20:32+00:00",
        "comment_author": "bernhardberger",
        "comment_body": "Also needs `savedPosition`.\r\n\r\nI've moved it out of the function now. I agree with you for the sake of code readability.",
        "pr_file_module": null
      }
    ]
  }
]