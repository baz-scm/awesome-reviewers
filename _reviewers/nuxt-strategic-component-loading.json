[
  {
    "discussion_id": "2024322392",
    "pr_number": 31624,
    "pr_file": "docs/2.guide/5.best-practices/performance.md",
    "created_at": "2025-04-02T08:21:36+00:00",
    "commented_code": "+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "2024322392",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-02T08:21:36+00:00",
        "comment_author": "cernymatej",
        "comment_body": "since, as far as I'm aware, plugins are still sequential by default at the moment, I think it would be a good idea to recommend to use the object syntax for plugins and set the `parallel: true` option with the possibility to set plugin dependencies using `dependsOn:`",
        "pr_file_module": null
      },
      {
        "comment_id": "2024354105",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-02T08:39:58+00:00",
        "comment_author": "Baroshem",
        "comment_body": "I think this is covered in the plugins file created by @huang-julien in the main branch.\n\nBut you are correct :) \n\nMaybe we could sdd a link to the page created by Julien?",
        "pr_file_module": null
      },
      {
        "comment_id": "2024396764",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-02T08:58:33+00:00",
        "comment_author": "danielroe",
        "comment_body": "This will only have an effect if plugins are asynchronous. I think I would first advise avoiding any async activity in a plugin, and then fall back to making plugins `parallel`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2024593223",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-02T10:59:28+00:00",
        "comment_author": "Baroshem",
        "comment_body": "@danielroe \n\nWould you like me to include this info here in the performance best practices or should it be included in the pkugins page by Julien?",
        "pr_file_module": null
      },
      {
        "comment_id": "2024693971",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-02T12:10:15+00:00",
        "comment_author": "huang-julien",
        "comment_body": "I think the performance section could be split into several pages maybe ? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2026457937",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-03T08:18:30+00:00",
        "comment_author": "Baroshem",
        "comment_body": "I have been thinking about it but maybe we could do it after merging that? Let's treat it as a MVP to see how these docs look like and if they will grow, we can split this page into separate ones :)\r\n\r\nVercel has separate docs for images, fonts, scripts, etc (but Next Image is part of the main framework while in Nuxt case the Nuxt Image has its own documentation and a separate module) and Vue documentation keeps everything in one page - that is why I was not sure whether to split it or not :) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2027152445",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024322392",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:\n+\n+```html\n+<template>\n+  <div>\n+    <!-- this will automatically be rendered on the server, meaning your markdown parsing + highlighting libraries are not included in your client bundle. -->\n+    <HighlightedMarkdown markdown=\"# Headline\" />\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#server-components).\n+\n+### Hybrid Rendering\n+\n+In more complex applications, we may need a full control over how our application is rendered to support cases where some pages could be generated at build time, while others should be client-side rendered\n+\n+Hybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL:\n+\n+```ts\n+export default defineNuxtConfig({\n+  routeRules: {\n+    '/': {\n+      prerender: true\n+    },\n+    '/products/**': {\n+      swr: 3600\n+    },\n+    '/blog': {\n+      isr: 3600\n+    },\n+    '/admin/**': {\n+      ssr: false\n+    },\n+  }\n+})\n+```\n+\n+Nuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/concepts/rendering#hybrid-rendering).\n+\n+### Lazy Loading Components\n+\n+To dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n+\n+```html\n+<script setup lang=\"ts\">\n+const show = ref(false)\n+</script>\n+\n+<template>\n+  <div>\n+    <h1>Mountains</h1>\n+    <LazyMountainsList v-if=\"show\" />\n+    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n+  </div>\n+</template>\n+```\n+\n+By using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#dynamic-imports).\n+\n+### Lazy Hydration\n+\n+To utilize lazy components even further, you can implement the concept of delayed hydration (added in Nuxt 3.16) that allows you to control when components become interactive contributing to better performance. If you are not on Nuxt 3.16 yet, you can use [this](https://github.com/Baroshem/nuxt-lazy-hydrate) third-party module to handle lazy hydration in your app.\n+\n+```html\n+<template>\n+  <div>\n+    <LazyMyComponent hydrate-on-visible />\n+  </div>\n+</template>\n+```\n+\n+To optimize your app, you may want to delay the hydration of some components until they're visible, or until the browser is done with more important tasks.\n+\n+Read more about it [here](https://nuxt.com/docs/guide/directory-structure/components#delayed-or-lazy-hydration).\n+\n+### Fetching data\n+\n+To avoid fetching same data twice (once on the server and once on client) Nuxt provides composables `useFetch` and `useAsyncData` - they ensure that if an API call is made on the server, the data is forwarded to the client in the payload instead of being fetched again.\n+\n+```ts\n+<script setup lang=\"ts\">\n+const { data } = await useAsyncData('users', () => fetchUsers())\n+</script>\n+```\n+\n+The first argument of `useAsyncData` is a unique key used to cache the response of the second argument, the querying function.\n+\n+Data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue\u2019s Suspense. This feature can be ignored on client-side navigation with the `lazy` option but requires manual handling of loading state:\n+\n+```html\n+<script setup lang=\"ts\">\n+const { status, data: posts } = useFetch('/api/posts', {\n+  lazy: true // <- will not block the client side navigation\n+})\n+</script>\n+\n+<template>\n+  <!-- you will need to handle a loading state -->\n+  <div v-if=\"status === 'pending'\">\n+    Loading ...\n+  </div>\n+  <div v-else>\n+    <div v-for=\"post in posts\">\n+      <!-- do something -->\n+    </div>\n+  </div>\n+</template>\n+```\n+\n+Read more about it [here](https://nuxt.com/docs/getting-started/data-fetching).\n+\n+## Plug-in Solutions\n+\n+Apart from the built-in features, Nuxt offers multiple plug-in solutions such as modules to improve performance even further. These modules help efficiently handle assets such as images, custom fonts, or third party scripts because they can negatively impact the Performance and User Experience of your Nuxt application. Below, you will learn how you can optimize them to deliver the best experience and improve Core Web Vitals.\n+\n+### Images\n+\n+Not optimized images can have a significant impact on your website performance, specifically targeting the [Largest Contentful Paint (LCP)](https://web.dev/articles/lcp) score.\n+\n+Thankfully, in Nuxt we can use [Nuxt Image](https://image.nuxt.com/) module that is a plug-and-play image optimization for Nuxt apps. It allows to resize and transform your images using built-in optimizer or your favorite images CDN.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=_UBff2eqGY0\" target=\"_blank\"}\n+Watch the video by LearnVue about Nuxt Image\n+::\n+\n+`<NuxtImg>` is a drop-in replacement for the native `<img>` tag that comes with following enhancements:\n+\n+* Uses built-in provider to optimize local and remote images\n+* Converts `src` to provider optimized URLs with modern formats such as WebP or Avif\n+* Automatically resizes images based on `width` and `height`\n+* Generates responsive `sizes` when providing sizes option\n+* Supports native `lazy loading` as well as other `<img>` attributes\n+\n+Images in your website can usually be separated by importance; the ones that are needed to be delivered first at initial load (i.e. `Largest Contentful Paint`), and the ones that can be loaded later or when specifically needed. For that, we could use the following optimizations:\n+\n+```html\n+<template>\n+  <!-- \ud83d\udea8 Needs to be loaded ASAP -->\n+  <NuxtImg\n+    src=\"/hero-banner.jpg\"\n+    format=\"webp\"\n+    preload\n+    loading=\"eager\"\n+    fetch-priority=\"high\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+\n+  <!-- \ud83d\udc0c Can be loaded later -->\n+  <NuxtImg\n+    src=\"/facebook-logo.jpg\"\n+    format=\"webp\"\n+    loading=\"lazy\"\n+    fetch-priority=\"low\"\n+    width=\"200\"\n+    height=\"100\"\n+  />\n+</template>\n+```\n+\n+Check out all the available options [here](https://image.nuxt.com/usage/nuxt-img).\n+\n+### Fonts\n+\n+[Nuxt Fonts](https://fonts.nuxt.com/) will automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.\n+\n+It includes built-in automatic self-hosting for any font file which means you can optimally load web fonts with reduced layout shift, thanks to the underlying package [Fontaine](https://github.com/unjs/fontaine).\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://www.youtube.com/watch?v=D3F683UViBY\" target=\"_blank\"}\n+Watch the talk by Daniel Roe about the idea behind Nuxt Fonts\n+::\n+\n+Nuxt Fonts processes all your CSS and does the following things automatically when it encounters a font-family declaration.\n+\n+1. **Resolves fonts** \u2013 Looks for font files in public/, then checks web providers like Google, Bunny, and Fontshare.\n+2. **Generates @font-face rules** \u2013 Injects CSS rules to load fonts from the correct sources.\n+3. **Proxies & caches fonts** \u2013 Rewrites URLs to `/_fonts`, downloads and caches fonts locally.\n+4. **Creates fallback metrics** \u2013 Adjusts local system fonts to match web fonts, reducing layout shift ([CLS](https://web.dev/articles/cls)).\n+5. **Includes fonts in build** \u2013 Bundles fonts with your project, hashing file names and setting long-lived cache headers.\n+\n+It supports multiple providers that are designed to be pluggable and extensible, so no matter your setup you should be able to use an existing provider or write your own.\n+\n+### Scripts\n+\n+Third-party resources like analytics tools, video embeds, maps, and social media integrations enhance website functionality but can significantly degrade user experience and negatively impact [Interaction to Next Paint (INP)](https://web.dev/articles/inp?hl=en) and Largest Contentful Paint (LCP) scores.\n+\n+[Nuxt Scripts](https://scripts.nuxt.com/) lets you load third-party scripts with better performance, privacy, security and DX.\n+\n+::tip{icon=\"i-lucide-video\" to=\"https://youtu.be/sjMqUUvH9AE\" target=\"_blank\"}\n+Watch the video by Alex Lichter about Nuxt Scripts\n+::\n+\n+Nuxt Scripts provides an abstraction layer on top of third-party scripts, providing SSR support and type-safety and while still giving you full low-level control over how a script is loaded.\n+\n+```ts\n+const { onLoaded, proxy } = useScriptGoogleAnalytics(\n+  { \n+    id: 'G-1234567',\n+    scriptOptions: {\n+      trigger: 'manual',\n+    },\n+  },\n+)\n+// queue events to be sent when ga loads\n+proxy.gtag('config', 'UA-123456789-1')\n+// or wait until ga is loaded\n+onLoaded((gtag) => {\n+  // script loaded\n+})\n+```\n+\n+Check out all available script options in the registry [here](https://scripts.nuxt.com/scripts).\n+\n+## Profiling Tools\n+\n+To improve performance, we need to first know how to measure it, starting with measuring performance during development - on local environment, and then moving to auditing application that are deployed on production.\n+\n+### Nuxi Analyze\n+\n+[This](https://nuxt.com/docs/api/commands/analyze) command of `nuxi` allows to analyze the production bundle or your Nuxt application. It leverages `vite-bundle-visualizer` (similar to `webpack-bundle-analyzer`) to generate a visual representation of your application's bundle, making it easier to identify which components take up the most space.\n+\n+When you see a large block in the visualization, it often signals an opportunity for optimization\u2014whether by splitting it into smaller parts, implementing lazy loading, or replacing it with a more efficient alternative, especially for third-party libraries.\n+\n+Large blocks containing multiple elements can often be reduced by importing only the necessary components rather than entire modules while large standalone blocks may be better suited for lazy loading rather than being included in the main bundle.\n+\n+### Nuxt DevTools\n+\n+The [Nuxt DevTools](https://devtools.nuxt.com/) gives you insights and transparency about your Nuxt App to identify performance gaps and seamlessly manage your app configurations.\n+\n+![Nuxt DevTools example](https://user-images.githubusercontent.com/11247099/217670806-fb39aeff-3881-44e5-b9c8-6c757f5925fc.png)\n+\n+It comes with several features we can use to measure performance of Nuxt apps:\n+1. **Timeline** \u2013 Tracks time spent on rendering, updating, and initializing components to identify performance bottlenecks.  \n+2. **Assets** \u2013 Displays file sizes (e.g., images) without transformations.  \n+3. **Render Tree** \u2013 Shows connections between Vue components, scripts, and styles to optimize dynamic loading.  \n+4. **Inspect** \u2013 Lists all files used in the Vue app with their size and evaluation time.\n+\n+### Chrome DevTools\n+\n+Chrome DevTools come with two useful tabs for measuring performance; `Performance` and `Lighthouse`.\n+\n+When you open the [Performance](https://developer.chrome.com/docs/devtools/performance/overview) panel, it instantly shows your local **Largest Contentful Paint (LCP)** and **Cumulative Layout Shift (CLS)** scores (good, needs improvement, or bad).  \n+\n+If you interact with the page, it also captures **Interaction to Next Paint (INP)**, giving you a full view of your Core Web Vitals based on your device and network.\n+\n+![Chrome DevTools Performance Panel](https://developer.chrome.com/static/docs/devtools/performance/image/cpu-throttling_856.png)\n+\n+[Lighthouse](https://developer.chrome.com/docs/devtools/lighthouse) audits performance, accessibility, SEO, progressive web apps, and best practices. It runs tests on your page and generates a report. Use failing audits as a guide to improve your site.\n+\n+![Lighthouse](https://developer.chrome.com/static/docs/lighthouse/images/lighthouse-overview_720.png)\n+\n+Each audit has a reference document explaining why the audit is important, as well as how to fix it.\n+\n+### PageSpeed Insights\n+\n+[PageSpeed Insights (PSI)](https://developers.google.com/speed/docs/insights/v5/about) reports on the user experience of a page on both mobile and desktop devices, and provides suggestions on how that page may be improved.\n+\n+It provides both lab and field data about a page. Lab data is useful for debugging issues, as it is collected in a controlled environment while field data is useful for capturing true, real-world user experience.\n+\n+### Web Page Test\n+\n+[WebPageTest](https://www.webpagetest.org/) is a web performance tool providing deep diagnostic information about how a page performs under a variety of conditions.\n+\n+Each test can be run from different locations around the world, on real browsers, over any number of customizable network conditions.\n+\n+## Common problems\n+\n+When building more complex Nuxt applications, you will probably encounter some of the problems listed below. Understanding these problems and fixing them will help you improve performance of your website.\n+\n+### Overusing plugins\n+\n+**Problem**: A large number of plugins can cause performance issues, especially if they require expensive computations or take too long to initialize. Since plugins run during the hydration phase, inefficient setups can block rendering and degrade the user experience.\n+\n+**Solution**: Inspect your plugins and see if some of them could be implemented rather as a composable or utility function instead.\n+",
        "comment_created_at": "2025-04-03T14:37:16+00:00",
        "comment_author": "danielroe",
        "comment_body": "let's start with a single page. we can update the plugins PR from Julien to augment this page + later see if we need to split.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2024429292",
    "pr_number": 31624,
    "pr_file": "docs/2.guide/5.best-practices/performance.md",
    "created_at": "2025-04-02T09:16:01+00:00",
    "commented_code": "+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "2024429292",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-02T09:16:01+00:00",
        "comment_author": "huang-julien",
        "comment_body": "Server components are enabled automatically if you use it in your project. \r\n\r\nBut I'm not actually sure about whether would should mention it or not in the best practices as islands can easily lead to bad practices (due to request waterfall)\r\n\r\nAlso because we don't actually have public benchmarks about that (I do but internally at work... And 1 project doesn't count)",
        "pr_file_module": null
      },
      {
        "comment_id": "2024466957",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-02T09:37:13+00:00",
        "comment_author": "Mini-ghost",
        "comment_body": "Would it generally be more recommended to use a Lazy Hydration Component with `hydrate-never` rather than using an Islands Component (Server Component) in most cases?",
        "pr_file_module": null
      },
      {
        "comment_id": "2024590120",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-02T10:57:14+00:00",
        "comment_author": "Baroshem",
        "comment_body": "@huang-julien so you would not include server components at all in this best practices guide?",
        "pr_file_module": null
      },
      {
        "comment_id": "2024692687",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-02T12:09:27+00:00",
        "comment_author": "huang-julien",
        "comment_body": "let's not add it first :+1:",
        "pr_file_module": null
      },
      {
        "comment_id": "2024698741",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-02T12:13:27+00:00",
        "comment_author": "danielroe",
        "comment_body": "lazy hydration with `hydrate-never` will still hydrate things on client-side navigation unless it was part of the initial render.",
        "pr_file_module": null
      },
      {
        "comment_id": "2026582793",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-03T09:29:30+00:00",
        "comment_author": "Baroshem",
        "comment_body": "@danielroe what would be your opinion on that? Should we not add it to the performance best practices?",
        "pr_file_module": null
      },
      {
        "comment_id": "2027151311",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-03T14:36:35+00:00",
        "comment_author": "danielroe",
        "comment_body": "if Julien says we should omit server components for now, let's do omit that section for now.\r\n\r\nIt's still worth mentioning lazy hydration.",
        "pr_file_module": null
      },
      {
        "comment_id": "2027335029",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31624,
        "pr_file": "docs/2.guide/5.best-practices/performance.md",
        "discussion_id": "2024429292",
        "commented_code": "@@ -0,0 +1,346 @@\n+---\n+navigation.title: 'Nuxt Performance'\n+title: Nuxt performance\n+description: Best practices for improving performance of Nuxt apps\n+---\n+\n+# Performance\n+\n+Nuxt comes with several built-in optimizations designed to improve your application's performance and contribute to better [Core Web Vitals](https://web.dev/articles/vitals) score. Additionally, there are also multiple plug-in solutions such as modules that will help improve performance and User Experience even more. This guide outlines best practices to optimize performance of your Nuxt application.\n+\n+## Built-in Solutions\n+\n+Nuxt offers several built-in solutions that help you optimize performance of your website. Understanding how this works and how you can further customize it to suit your needs is crucial for achieving blazingly fast performance.\n+\n+### Links\n+\n+`<NuxtLink>` is a drop-in replacement for both Vue Router's `<RouterLink>` component and HTML's `<a>` tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\n+\n+```html\n+<template>\n+  <NuxtLink to=\"/about\">About page</NuxtLink>\n+</template>\n+\n+<!-- Which will render to with Vue Router & Smart Prefetching -->\n+<a href=\"/about\">About page</a>\n+```\n+\n+Nuxt automatically includes smart prefetching. That means it detects when a link is visible (by default), either in the viewport or when scrolling and prefetches the JavaScript for those pages so that they are ready when the user clicks the link.\n+\n+Read more about it [here](https://nuxt.com/docs/api/components/nuxt-link).\n+\n+### Server Components\n+\n+Server components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n+\n+Server components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your `nuxt.config.ts`, name the file like `HighlightedMarkdown.server.vue`, and use it like following:",
        "comment_created_at": "2025-04-03T16:08:05+00:00",
        "comment_author": "Baroshem",
        "comment_body": "Ok, will remove it then but keep the hydration part :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1646935527",
    "pr_number": 26468,
    "pr_file": "docs/2.guide/2.directory-structure/1.components.md",
    "created_at": "2024-06-20T04:47:32+00:00",
    "commented_code": "</template>\n ```\n \n+## Delayed Hydration\n+\n+In real world applications, some pages may include a lot of content and a lot of components, and most of the time not all of them need to be interactive as soon as the page is loaded. Having them all load eagerly can negatively impact performance and increase bundle size.",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1646935527",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 26468,
        "pr_file": "docs/2.guide/2.directory-structure/1.components.md",
        "discussion_id": "1646935527",
        "commented_code": "@@ -119,6 +119,79 @@ const show = ref(false)\n </template>\n ```\n \n+## Delayed Hydration\n+\n+In real world applications, some pages may include a lot of content and a lot of components, and most of the time not all of them need to be interactive as soon as the page is loaded. Having them all load eagerly can negatively impact performance and increase bundle size.",
        "comment_created_at": "2024-06-20T04:47:32+00:00",
        "comment_author": "harlan-zw",
        "comment_body": "It may be useful to outline the difference with Lazy prefixed components as it might seem like Lazy should solve this already.\r\n\r\nSome rough prose, feel free to word however you like\r\n\r\n> While Lazy prefixed components are useful for controlling the chunk size of your app, they won't necessarily improve the loading performance. This is because the async component is loaded eagerly with the rest of the page's scripts.\r\n\r\n> Delayed hydration components fix this, allowing you to load the component just in time to maintain a good user experience while providing the performance benefit of not loading the component immediately.",
        "pr_file_module": null
      },
      {
        "comment_id": "1647044081",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 26468,
        "pr_file": "docs/2.guide/2.directory-structure/1.components.md",
        "discussion_id": "1646935527",
        "commented_code": "@@ -119,6 +119,79 @@ const show = ref(false)\n </template>\n ```\n \n+## Delayed Hydration\n+\n+In real world applications, some pages may include a lot of content and a lot of components, and most of the time not all of them need to be interactive as soon as the page is loaded. Having them all load eagerly can negatively impact performance and increase bundle size.",
        "comment_created_at": "2024-06-20T06:45:33+00:00",
        "comment_author": "GalacticHypernova",
        "comment_body": "Rephrased it, let me know what you think!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1673458417",
    "pr_number": 28062,
    "pr_file": "docs/2.guide/2.directory-structure/1.components.md",
    "created_at": "2024-07-11T06:13:02+00:00",
    "commented_code": "Server components (and islands) must have a single root element. (HTML comments are considered elements as well.)\n ::\n \n+::alert{type=warning}\n+It is not recommanded to nest island within islands as you will have a waterfall of fetch requests.",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1673458417",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 28062,
        "pr_file": "docs/2.guide/2.directory-structure/1.components.md",
        "discussion_id": "1673458417",
        "commented_code": "@@ -303,6 +303,10 @@ Server-only components use [`<NuxtIsland>`](/docs/api/components/nuxt-island) un\n Server components (and islands) must have a single root element. (HTML comments are considered elements as well.)\n ::\n \n+::alert{type=warning}\n+It is not recommanded to nest island within islands as you will have a waterfall of fetch requests.",
        "comment_created_at": "2024-07-11T06:13:02+00:00",
        "comment_author": "danielroe",
        "comment_body": "I'm worried we might give the wrong impression, as these all take place in the same network request, with additional server components rendered with 'internal' fetches.\r\n\r\n```suggestion\r\nBe careful when nesting islands within other islands as each island adds some extra overhead.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]