[
  {
    "discussion_id": "1802591030",
    "pr_number": 29566,
    "pr_file": "docs/3.api/2.composables/use-async-data.md",
    "created_at": "2024-10-16T08:18:31+00:00",
    "commented_code": "pick?: string[]\n   watch?: WatchSource[]\n   getCachedData?: (key: string, nuxtApp: NuxtApp) => DataT\n+  pollEvery?: number",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1802591030",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 29566,
        "pr_file": "docs/3.api/2.composables/use-async-data.md",
        "discussion_id": "1802591030",
        "commented_code": "@@ -127,6 +128,7 @@ type AsyncDataOptions<DataT> = {\n   pick?: string[]\n   watch?: WatchSource[]\n   getCachedData?: (key: string, nuxtApp: NuxtApp) => DataT\n+  pollEvery?: number",
        "comment_created_at": "2024-10-16T08:18:31+00:00",
        "comment_author": "daniluk4000",
        "comment_body": "I could suggest to MAYBE rename this to refreshEvery to match native function, but that's for Nuxt team to decide I guess",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1641916421",
    "pr_number": 27287,
    "pr_file": "docs/2.guide/4.recipes/4.sessions-and-authentication.md",
    "created_at": "2024-06-16T16:37:48+00:00",
    "commented_code": "+---\n+title: 'Sessions and Authentication'\n+description: \"User registration and authentication is an extremely common requirement in web apps. This recipe will show you how to implement basic user registration and authentication in you Nuxt app.\"\n+---\n+\n+\n+## Introduction\n+\n+In this recipe we'll be setting up user registration, login, sessions, and authentication in a full-stack Nuxt app.\n+ We'll be using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils) by [Altinux (S\u00e9bastien Chopin)](https://github.com/Atinux) which provides convenient utilities for managing front-end and back-end session data. We'll install and use this to get the core session management functionality we're going to need to manage user logins. For the database ORM we'll be using [Drizzle](https://orm.drizzle.team/) with [db0](https://db0.unjs.io/), but you can use any ORM or database connection strategy you prefer.\n+\n+You'll need a `users` table in your database with the following columns:\n+- `id` (int, primary key, auto increment)\n+- `email` (varchar)\n+- `password` (varchar)\n+\n+Additionally, we'll use [nuxt-aut-utils](https://github.com/Atinux/nuxt-auth-utils) by [Atinux](https://github.com/Atinux) to handle the authentication and session management.\n+\n+## Steps\n+\n+### 1. Install nuxt-auth-utils\n+\n+\n+Install the [auth-utils](https://github.com/Atinux/nuxt-auth-utils) module using the `nuxi` CLI.\n+\n+\n+```bash\n+npx nuxi@latest module add auth-utils\n+```\n+\n+### 1a. (Optional) Add a session encryption key\n+\n+Session cookies are encrypted. The encryption key is set from the `.env` file. This key will be added to your `.env` automatically when running in development mode the first time. However, you'll need to add this to your production environment before deploying.\n+\n+```dotenv [.env]\n+NUXT_SESSION_PASSWORD=password-with-at-least-32-characters\n+```\n+\n+### 2. Create a registration page\n+\n+The first page we'll need is a page for users to register and create new accounts. Create a new Vue page in your Nuxt app at `/pages/register.vue` for user registration. This page should have a form with fields for email and password. We'll intercept the form submission using `@submit.prevent` and use the [`$fetch`](/docs/getting-started/data-fetching#fetch) utility to post the data to `/api/register`. This form POST will be received by Nuxt in an API route which we will set up next. \n+\n+If the request is successful, we'll navigate to the (soon to be created) `/users` page, which will be guarded and only be visible to logged in users.\n+\n+Here's an example registration form for reference:\n+\n+```vue [pages/register.vue]\n+<script setup lang=\"ts\">\n+  const form = ref({\n+    name: \"\",\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/register\", {\n+        method: \"POST\",\n+        body: form.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error Registering User\";\n+      return;\n+    }\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"name\" class=\"block text-sm uppercase\">Name</label>\n+\n+        <input id=\"name\" name=\"name\" v-model=\"form.name\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Register</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 3. Create an API route for registration\n+\n+With the user interface created we'll need to add a route to receive the registration form data. This route should accept a POST request with the email and password in the request body. It should hash the password and insert the user into the database. This route will only accept POST requests, so we'll follow the instructions for [API route methods](https://nuxt.com/docs/guide/directory-structure/server#matching-http-method) and name the file with `*.post.ts` to restrict the endpoint to only accept POST.\n+\n+After we've successfully registered the user and stored the record in the database we can log them in by calling the `replaceUserSession` utility function from auth-utils. This utility function is automatically imported by the auth-utils module. We're using `replaceUserSession` here to make sure that any existing session data is cleared and replaced with the user login we're performing now.\n+\n+The example file below is a very simple example of registration. You would probably want to add some error handling and nice response messages.\n+\n+```typescript [/server/api/register.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const body = await readBody(event);\n+\n+  const db = await getDatabase();\n+\n+  // has the password before creating the user record\n+  const passwordHash = bcrypt.hashSync(body.password, 12);\n+  await db.insert(users).values({\n+    name: body.name,\n+    email: body.email,\n+    password: passwordHash,\n+  });\n+\n+  // get the user record we just created\n+  const user = (await db.select().from(users).where(eq(users.email, body.email)).limit(1))[0];\n+  // log the user in as the user that was just created\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+  \n+  \n+  await auth.login(event, user);\n+});\n+```\n+\n+### 4. Create a login page\n+\n+When registered users return to your site they'll need to be able to log back in. Create a new page at `/pages/login.vue` in your Nuxt app for user login. This page should have a form with fields for email and password and should submit a POST request to `/api/login`.\n+\n+Like the registration page, we'll intercept the form submission using `@submit.prevent` and use [`$fetch`](https://nuxt.com/docs/getting-started/data-fetching#fetch) to post the data to `/api/login`.\n+\n+This is a very simple login form example, so you'd definitely want to add more validation and error checking in a real-world application.\n+\n+```vue [/pages/login.vue]\n+<script setup lang=\"ts\">\n+  import { ref } from \"vue\";\n+\n+  const form = ref({\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/auth/login\", {\n+        method: \"POST\",\n+        body: loginForm.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error logging in\";\n+      return;\n+    }\n+\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    \n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in. This will perform a full-page load.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Login</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 5. Create an API route for login\n+\n+With the login form created, we need to create an API route to handle the login request. This route should accept a POST request with the email and password in the request body and check the email and password against the database. If the user and password match, we'll set a session cookie to log the user in.\n+\n+This server API route should be at `/server/api/auth/login.post.ts`. Just like the registration form endpoint, suffixing the filename in `.post.ts.` means that this handler will only respond to post requests.\n+\n+```typescript [/server/api/auth/login.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import { eq } from \"drizzle-orm\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const db = await getDatabase();\n+\n+  const foundUser = (\n+    await db\n+      .select({ id: users.id, name: users.name, email: users.email, password: users.password })\n+      .from(users)\n+      .where(eq(users.email, email))\n+      .limit(1)\n+  )?.[0];\n+\n+  // compare the password hash\n+  if (!foundUser || !bcrypt.compareSync(password, foundUser.password)) {\n+    // return an error if the user is not found or the password doesn't match\n+    throw createError({\n+      statusCode: 401,\n+      statusMessage: \"Invalid email or password\",\n+    });\n+  }\n+\n+  // log in as the selected user\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+});\n+\n+\n+```\n+\n+The user should now be logged in! With the session set, we can get the current user session in any API route or page by calling `getUserSession(event)` which is auto-imported as a util function from the `nuxt-auth-utils` package.\n+\n+### 6. Create a logout API route\n+\n+Users need to be able to log out, so we should create an API route to allow them to do this. This should require post request as well, just like login. We'll clear the session when this endpoint is called.\n+\n+We'll use the `clearUserSession` from the `auth-utils` module to log the user out and clear the session data. This function is automatically imported from the module by Nuxt, so we don't need to manually import it.\n+\n+```typescript [server/api/auth/logout.post.ts]\n+export default defineEventHandler(async (event) => {\n+  // Clear the current user session\n+  await clearUserSession(event);\n+});\n+```\n+\n+### 7. Protect your server route\n+\n+Protecting server routes is key to making sure your data are safe. Front-end middleware is helpful for the user, but without back-end protection your data can still be accessed. Because of this, it is critical that we protect any API routes with sensitive data. For these sensitive routes, we should return a 401 error if the user is not logged in.\n+\n+The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session. We can use this to protect our different endpoints. Like many of the other utilities from the auth module, it is automatically imported in our server endpoints.\n+\n+In the example below, we use the `requireUserSession` utility function to protect the `/server/api/users.get.ts` server route. This route will only be accessible to logged-in users.\n+\n+```typescript [/server/api/users.get.ts]\n+import getDatabase from \"~/database/database\";\n+import users from \"~/database/schema/users\";\n+import requireUserLoggedIn from \"~/server/utils/requireUserLoggedIn\";\n+\n+export default defineEventHandler(async (event) => {\n+  // make sure the user is logged in\n+  // This will throw a 401 error if the request doesn't come from a valid user session\n+  await requireUserSession(event);\n+\n+  // If we make it hear, the user is authenticated. It's safe to fetch and return data\n+  const db = await getDatabase();\n+  \n+  // Send back the list of users\n+  const userList = await db.select({ name: users.name, id: users.id }).from(users).limit(10);\n+\n+  return userList;\n+});\n+```\n+\n+### 8. Create a front-end middleware to protect routes",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1641916421",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27287,
        "pr_file": "docs/2.guide/4.recipes/4.sessions-and-authentication.md",
        "discussion_id": "1641916421",
        "commented_code": "@@ -0,0 +1,403 @@\n+---\n+title: 'Sessions and Authentication'\n+description: \"User registration and authentication is an extremely common requirement in web apps. This recipe will show you how to implement basic user registration and authentication in you Nuxt app.\"\n+---\n+\n+\n+## Introduction\n+\n+In this recipe we'll be setting up user registration, login, sessions, and authentication in a full-stack Nuxt app.\n+ We'll be using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils) by [Altinux (S\u00e9bastien Chopin)](https://github.com/Atinux) which provides convenient utilities for managing front-end and back-end session data. We'll install and use this to get the core session management functionality we're going to need to manage user logins. For the database ORM we'll be using [Drizzle](https://orm.drizzle.team/) with [db0](https://db0.unjs.io/), but you can use any ORM or database connection strategy you prefer.\n+\n+You'll need a `users` table in your database with the following columns:\n+- `id` (int, primary key, auto increment)\n+- `email` (varchar)\n+- `password` (varchar)\n+\n+Additionally, we'll use [nuxt-aut-utils](https://github.com/Atinux/nuxt-auth-utils) by [Atinux](https://github.com/Atinux) to handle the authentication and session management.\n+\n+## Steps\n+\n+### 1. Install nuxt-auth-utils\n+\n+\n+Install the [auth-utils](https://github.com/Atinux/nuxt-auth-utils) module using the `nuxi` CLI.\n+\n+\n+```bash\n+npx nuxi@latest module add auth-utils\n+```\n+\n+### 1a. (Optional) Add a session encryption key\n+\n+Session cookies are encrypted. The encryption key is set from the `.env` file. This key will be added to your `.env` automatically when running in development mode the first time. However, you'll need to add this to your production environment before deploying.\n+\n+```dotenv [.env]\n+NUXT_SESSION_PASSWORD=password-with-at-least-32-characters\n+```\n+\n+### 2. Create a registration page\n+\n+The first page we'll need is a page for users to register and create new accounts. Create a new Vue page in your Nuxt app at `/pages/register.vue` for user registration. This page should have a form with fields for email and password. We'll intercept the form submission using `@submit.prevent` and use the [`$fetch`](/docs/getting-started/data-fetching#fetch) utility to post the data to `/api/register`. This form POST will be received by Nuxt in an API route which we will set up next. \n+\n+If the request is successful, we'll navigate to the (soon to be created) `/users` page, which will be guarded and only be visible to logged in users.\n+\n+Here's an example registration form for reference:\n+\n+```vue [pages/register.vue]\n+<script setup lang=\"ts\">\n+  const form = ref({\n+    name: \"\",\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/register\", {\n+        method: \"POST\",\n+        body: form.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error Registering User\";\n+      return;\n+    }\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"name\" class=\"block text-sm uppercase\">Name</label>\n+\n+        <input id=\"name\" name=\"name\" v-model=\"form.name\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Register</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 3. Create an API route for registration\n+\n+With the user interface created we'll need to add a route to receive the registration form data. This route should accept a POST request with the email and password in the request body. It should hash the password and insert the user into the database. This route will only accept POST requests, so we'll follow the instructions for [API route methods](https://nuxt.com/docs/guide/directory-structure/server#matching-http-method) and name the file with `*.post.ts` to restrict the endpoint to only accept POST.\n+\n+After we've successfully registered the user and stored the record in the database we can log them in by calling the `replaceUserSession` utility function from auth-utils. This utility function is automatically imported by the auth-utils module. We're using `replaceUserSession` here to make sure that any existing session data is cleared and replaced with the user login we're performing now.\n+\n+The example file below is a very simple example of registration. You would probably want to add some error handling and nice response messages.\n+\n+```typescript [/server/api/register.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const body = await readBody(event);\n+\n+  const db = await getDatabase();\n+\n+  // has the password before creating the user record\n+  const passwordHash = bcrypt.hashSync(body.password, 12);\n+  await db.insert(users).values({\n+    name: body.name,\n+    email: body.email,\n+    password: passwordHash,\n+  });\n+\n+  // get the user record we just created\n+  const user = (await db.select().from(users).where(eq(users.email, body.email)).limit(1))[0];\n+  // log the user in as the user that was just created\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+  \n+  \n+  await auth.login(event, user);\n+});\n+```\n+\n+### 4. Create a login page\n+\n+When registered users return to your site they'll need to be able to log back in. Create a new page at `/pages/login.vue` in your Nuxt app for user login. This page should have a form with fields for email and password and should submit a POST request to `/api/login`.\n+\n+Like the registration page, we'll intercept the form submission using `@submit.prevent` and use [`$fetch`](https://nuxt.com/docs/getting-started/data-fetching#fetch) to post the data to `/api/login`.\n+\n+This is a very simple login form example, so you'd definitely want to add more validation and error checking in a real-world application.\n+\n+```vue [/pages/login.vue]\n+<script setup lang=\"ts\">\n+  import { ref } from \"vue\";\n+\n+  const form = ref({\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/auth/login\", {\n+        method: \"POST\",\n+        body: loginForm.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error logging in\";\n+      return;\n+    }\n+\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    \n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in. This will perform a full-page load.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Login</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 5. Create an API route for login\n+\n+With the login form created, we need to create an API route to handle the login request. This route should accept a POST request with the email and password in the request body and check the email and password against the database. If the user and password match, we'll set a session cookie to log the user in.\n+\n+This server API route should be at `/server/api/auth/login.post.ts`. Just like the registration form endpoint, suffixing the filename in `.post.ts.` means that this handler will only respond to post requests.\n+\n+```typescript [/server/api/auth/login.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import { eq } from \"drizzle-orm\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const db = await getDatabase();\n+\n+  const foundUser = (\n+    await db\n+      .select({ id: users.id, name: users.name, email: users.email, password: users.password })\n+      .from(users)\n+      .where(eq(users.email, email))\n+      .limit(1)\n+  )?.[0];\n+\n+  // compare the password hash\n+  if (!foundUser || !bcrypt.compareSync(password, foundUser.password)) {\n+    // return an error if the user is not found or the password doesn't match\n+    throw createError({\n+      statusCode: 401,\n+      statusMessage: \"Invalid email or password\",\n+    });\n+  }\n+\n+  // log in as the selected user\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+});\n+\n+\n+```\n+\n+The user should now be logged in! With the session set, we can get the current user session in any API route or page by calling `getUserSession(event)` which is auto-imported as a util function from the `nuxt-auth-utils` package.\n+\n+### 6. Create a logout API route\n+\n+Users need to be able to log out, so we should create an API route to allow them to do this. This should require post request as well, just like login. We'll clear the session when this endpoint is called.\n+\n+We'll use the `clearUserSession` from the `auth-utils` module to log the user out and clear the session data. This function is automatically imported from the module by Nuxt, so we don't need to manually import it.\n+\n+```typescript [server/api/auth/logout.post.ts]\n+export default defineEventHandler(async (event) => {\n+  // Clear the current user session\n+  await clearUserSession(event);\n+});\n+```\n+\n+### 7. Protect your server route\n+\n+Protecting server routes is key to making sure your data are safe. Front-end middleware is helpful for the user, but without back-end protection your data can still be accessed. Because of this, it is critical that we protect any API routes with sensitive data. For these sensitive routes, we should return a 401 error if the user is not logged in.\n+\n+The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session. We can use this to protect our different endpoints. Like many of the other utilities from the auth module, it is automatically imported in our server endpoints.\n+\n+In the example below, we use the `requireUserSession` utility function to protect the `/server/api/users.get.ts` server route. This route will only be accessible to logged-in users.\n+\n+```typescript [/server/api/users.get.ts]\n+import getDatabase from \"~/database/database\";\n+import users from \"~/database/schema/users\";\n+import requireUserLoggedIn from \"~/server/utils/requireUserLoggedIn\";\n+\n+export default defineEventHandler(async (event) => {\n+  // make sure the user is logged in\n+  // This will throw a 401 error if the request doesn't come from a valid user session\n+  await requireUserSession(event);\n+\n+  // If we make it hear, the user is authenticated. It's safe to fetch and return data\n+  const db = await getDatabase();\n+  \n+  // Send back the list of users\n+  const userList = await db.select({ name: users.name, id: users.id }).from(users).limit(10);\n+\n+  return userList;\n+});\n+```\n+\n+### 8. Create a front-end middleware to protect routes",
        "comment_created_at": "2024-06-16T16:37:48+00:00",
        "comment_author": "GalacticHypernova",
        "comment_body": "Here too we should consider using the more friendly client-side term in favor of front-end",
        "pr_file_module": null
      },
      {
        "comment_id": "1641922272",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27287,
        "pr_file": "docs/2.guide/4.recipes/4.sessions-and-authentication.md",
        "discussion_id": "1641916421",
        "commented_code": "@@ -0,0 +1,403 @@\n+---\n+title: 'Sessions and Authentication'\n+description: \"User registration and authentication is an extremely common requirement in web apps. This recipe will show you how to implement basic user registration and authentication in you Nuxt app.\"\n+---\n+\n+\n+## Introduction\n+\n+In this recipe we'll be setting up user registration, login, sessions, and authentication in a full-stack Nuxt app.\n+ We'll be using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils) by [Altinux (S\u00e9bastien Chopin)](https://github.com/Atinux) which provides convenient utilities for managing front-end and back-end session data. We'll install and use this to get the core session management functionality we're going to need to manage user logins. For the database ORM we'll be using [Drizzle](https://orm.drizzle.team/) with [db0](https://db0.unjs.io/), but you can use any ORM or database connection strategy you prefer.\n+\n+You'll need a `users` table in your database with the following columns:\n+- `id` (int, primary key, auto increment)\n+- `email` (varchar)\n+- `password` (varchar)\n+\n+Additionally, we'll use [nuxt-aut-utils](https://github.com/Atinux/nuxt-auth-utils) by [Atinux](https://github.com/Atinux) to handle the authentication and session management.\n+\n+## Steps\n+\n+### 1. Install nuxt-auth-utils\n+\n+\n+Install the [auth-utils](https://github.com/Atinux/nuxt-auth-utils) module using the `nuxi` CLI.\n+\n+\n+```bash\n+npx nuxi@latest module add auth-utils\n+```\n+\n+### 1a. (Optional) Add a session encryption key\n+\n+Session cookies are encrypted. The encryption key is set from the `.env` file. This key will be added to your `.env` automatically when running in development mode the first time. However, you'll need to add this to your production environment before deploying.\n+\n+```dotenv [.env]\n+NUXT_SESSION_PASSWORD=password-with-at-least-32-characters\n+```\n+\n+### 2. Create a registration page\n+\n+The first page we'll need is a page for users to register and create new accounts. Create a new Vue page in your Nuxt app at `/pages/register.vue` for user registration. This page should have a form with fields for email and password. We'll intercept the form submission using `@submit.prevent` and use the [`$fetch`](/docs/getting-started/data-fetching#fetch) utility to post the data to `/api/register`. This form POST will be received by Nuxt in an API route which we will set up next. \n+\n+If the request is successful, we'll navigate to the (soon to be created) `/users` page, which will be guarded and only be visible to logged in users.\n+\n+Here's an example registration form for reference:\n+\n+```vue [pages/register.vue]\n+<script setup lang=\"ts\">\n+  const form = ref({\n+    name: \"\",\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/register\", {\n+        method: \"POST\",\n+        body: form.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error Registering User\";\n+      return;\n+    }\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"name\" class=\"block text-sm uppercase\">Name</label>\n+\n+        <input id=\"name\" name=\"name\" v-model=\"form.name\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Register</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 3. Create an API route for registration\n+\n+With the user interface created we'll need to add a route to receive the registration form data. This route should accept a POST request with the email and password in the request body. It should hash the password and insert the user into the database. This route will only accept POST requests, so we'll follow the instructions for [API route methods](https://nuxt.com/docs/guide/directory-structure/server#matching-http-method) and name the file with `*.post.ts` to restrict the endpoint to only accept POST.\n+\n+After we've successfully registered the user and stored the record in the database we can log them in by calling the `replaceUserSession` utility function from auth-utils. This utility function is automatically imported by the auth-utils module. We're using `replaceUserSession` here to make sure that any existing session data is cleared and replaced with the user login we're performing now.\n+\n+The example file below is a very simple example of registration. You would probably want to add some error handling and nice response messages.\n+\n+```typescript [/server/api/register.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const body = await readBody(event);\n+\n+  const db = await getDatabase();\n+\n+  // has the password before creating the user record\n+  const passwordHash = bcrypt.hashSync(body.password, 12);\n+  await db.insert(users).values({\n+    name: body.name,\n+    email: body.email,\n+    password: passwordHash,\n+  });\n+\n+  // get the user record we just created\n+  const user = (await db.select().from(users).where(eq(users.email, body.email)).limit(1))[0];\n+  // log the user in as the user that was just created\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+  \n+  \n+  await auth.login(event, user);\n+});\n+```\n+\n+### 4. Create a login page\n+\n+When registered users return to your site they'll need to be able to log back in. Create a new page at `/pages/login.vue` in your Nuxt app for user login. This page should have a form with fields for email and password and should submit a POST request to `/api/login`.\n+\n+Like the registration page, we'll intercept the form submission using `@submit.prevent` and use [`$fetch`](https://nuxt.com/docs/getting-started/data-fetching#fetch) to post the data to `/api/login`.\n+\n+This is a very simple login form example, so you'd definitely want to add more validation and error checking in a real-world application.\n+\n+```vue [/pages/login.vue]\n+<script setup lang=\"ts\">\n+  import { ref } from \"vue\";\n+\n+  const form = ref({\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/auth/login\", {\n+        method: \"POST\",\n+        body: loginForm.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error logging in\";\n+      return;\n+    }\n+\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    \n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in. This will perform a full-page load.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Login</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 5. Create an API route for login\n+\n+With the login form created, we need to create an API route to handle the login request. This route should accept a POST request with the email and password in the request body and check the email and password against the database. If the user and password match, we'll set a session cookie to log the user in.\n+\n+This server API route should be at `/server/api/auth/login.post.ts`. Just like the registration form endpoint, suffixing the filename in `.post.ts.` means that this handler will only respond to post requests.\n+\n+```typescript [/server/api/auth/login.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import { eq } from \"drizzle-orm\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const db = await getDatabase();\n+\n+  const foundUser = (\n+    await db\n+      .select({ id: users.id, name: users.name, email: users.email, password: users.password })\n+      .from(users)\n+      .where(eq(users.email, email))\n+      .limit(1)\n+  )?.[0];\n+\n+  // compare the password hash\n+  if (!foundUser || !bcrypt.compareSync(password, foundUser.password)) {\n+    // return an error if the user is not found or the password doesn't match\n+    throw createError({\n+      statusCode: 401,\n+      statusMessage: \"Invalid email or password\",\n+    });\n+  }\n+\n+  // log in as the selected user\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+});\n+\n+\n+```\n+\n+The user should now be logged in! With the session set, we can get the current user session in any API route or page by calling `getUserSession(event)` which is auto-imported as a util function from the `nuxt-auth-utils` package.\n+\n+### 6. Create a logout API route\n+\n+Users need to be able to log out, so we should create an API route to allow them to do this. This should require post request as well, just like login. We'll clear the session when this endpoint is called.\n+\n+We'll use the `clearUserSession` from the `auth-utils` module to log the user out and clear the session data. This function is automatically imported from the module by Nuxt, so we don't need to manually import it.\n+\n+```typescript [server/api/auth/logout.post.ts]\n+export default defineEventHandler(async (event) => {\n+  // Clear the current user session\n+  await clearUserSession(event);\n+});\n+```\n+\n+### 7. Protect your server route\n+\n+Protecting server routes is key to making sure your data are safe. Front-end middleware is helpful for the user, but without back-end protection your data can still be accessed. Because of this, it is critical that we protect any API routes with sensitive data. For these sensitive routes, we should return a 401 error if the user is not logged in.\n+\n+The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session. We can use this to protect our different endpoints. Like many of the other utilities from the auth module, it is automatically imported in our server endpoints.\n+\n+In the example below, we use the `requireUserSession` utility function to protect the `/server/api/users.get.ts` server route. This route will only be accessible to logged-in users.\n+\n+```typescript [/server/api/users.get.ts]\n+import getDatabase from \"~/database/database\";\n+import users from \"~/database/schema/users\";\n+import requireUserLoggedIn from \"~/server/utils/requireUserLoggedIn\";\n+\n+export default defineEventHandler(async (event) => {\n+  // make sure the user is logged in\n+  // This will throw a 401 error if the request doesn't come from a valid user session\n+  await requireUserSession(event);\n+\n+  // If we make it hear, the user is authenticated. It's safe to fetch and return data\n+  const db = await getDatabase();\n+  \n+  // Send back the list of users\n+  const userList = await db.select({ name: users.name, id: users.id }).from(users).limit(10);\n+\n+  return userList;\n+});\n+```\n+\n+### 8. Create a front-end middleware to protect routes",
        "comment_created_at": "2024-06-16T17:08:15+00:00",
        "comment_author": "Smef",
        "comment_body": "I've replaced \"front-end\" with \"client-side\" and \"back-end\" with \"server-side\" throughout the document.",
        "pr_file_module": null
      },
      {
        "comment_id": "1641922702",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27287,
        "pr_file": "docs/2.guide/4.recipes/4.sessions-and-authentication.md",
        "discussion_id": "1641916421",
        "commented_code": "@@ -0,0 +1,403 @@\n+---\n+title: 'Sessions and Authentication'\n+description: \"User registration and authentication is an extremely common requirement in web apps. This recipe will show you how to implement basic user registration and authentication in you Nuxt app.\"\n+---\n+\n+\n+## Introduction\n+\n+In this recipe we'll be setting up user registration, login, sessions, and authentication in a full-stack Nuxt app.\n+ We'll be using [Nuxt Auth Utils](https://github.com/Atinux/nuxt-auth-utils) by [Altinux (S\u00e9bastien Chopin)](https://github.com/Atinux) which provides convenient utilities for managing front-end and back-end session data. We'll install and use this to get the core session management functionality we're going to need to manage user logins. For the database ORM we'll be using [Drizzle](https://orm.drizzle.team/) with [db0](https://db0.unjs.io/), but you can use any ORM or database connection strategy you prefer.\n+\n+You'll need a `users` table in your database with the following columns:\n+- `id` (int, primary key, auto increment)\n+- `email` (varchar)\n+- `password` (varchar)\n+\n+Additionally, we'll use [nuxt-aut-utils](https://github.com/Atinux/nuxt-auth-utils) by [Atinux](https://github.com/Atinux) to handle the authentication and session management.\n+\n+## Steps\n+\n+### 1. Install nuxt-auth-utils\n+\n+\n+Install the [auth-utils](https://github.com/Atinux/nuxt-auth-utils) module using the `nuxi` CLI.\n+\n+\n+```bash\n+npx nuxi@latest module add auth-utils\n+```\n+\n+### 1a. (Optional) Add a session encryption key\n+\n+Session cookies are encrypted. The encryption key is set from the `.env` file. This key will be added to your `.env` automatically when running in development mode the first time. However, you'll need to add this to your production environment before deploying.\n+\n+```dotenv [.env]\n+NUXT_SESSION_PASSWORD=password-with-at-least-32-characters\n+```\n+\n+### 2. Create a registration page\n+\n+The first page we'll need is a page for users to register and create new accounts. Create a new Vue page in your Nuxt app at `/pages/register.vue` for user registration. This page should have a form with fields for email and password. We'll intercept the form submission using `@submit.prevent` and use the [`$fetch`](/docs/getting-started/data-fetching#fetch) utility to post the data to `/api/register`. This form POST will be received by Nuxt in an API route which we will set up next. \n+\n+If the request is successful, we'll navigate to the (soon to be created) `/users` page, which will be guarded and only be visible to logged in users.\n+\n+Here's an example registration form for reference:\n+\n+```vue [pages/register.vue]\n+<script setup lang=\"ts\">\n+  const form = ref({\n+    name: \"\",\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/register\", {\n+        method: \"POST\",\n+        body: form.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error Registering User\";\n+      return;\n+    }\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"name\" class=\"block text-sm uppercase\">Name</label>\n+\n+        <input id=\"name\" name=\"name\" v-model=\"form.name\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Register</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 3. Create an API route for registration\n+\n+With the user interface created we'll need to add a route to receive the registration form data. This route should accept a POST request with the email and password in the request body. It should hash the password and insert the user into the database. This route will only accept POST requests, so we'll follow the instructions for [API route methods](https://nuxt.com/docs/guide/directory-structure/server#matching-http-method) and name the file with `*.post.ts` to restrict the endpoint to only accept POST.\n+\n+After we've successfully registered the user and stored the record in the database we can log them in by calling the `replaceUserSession` utility function from auth-utils. This utility function is automatically imported by the auth-utils module. We're using `replaceUserSession` here to make sure that any existing session data is cleared and replaced with the user login we're performing now.\n+\n+The example file below is a very simple example of registration. You would probably want to add some error handling and nice response messages.\n+\n+```typescript [/server/api/register.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const body = await readBody(event);\n+\n+  const db = await getDatabase();\n+\n+  // has the password before creating the user record\n+  const passwordHash = bcrypt.hashSync(body.password, 12);\n+  await db.insert(users).values({\n+    name: body.name,\n+    email: body.email,\n+    password: passwordHash,\n+  });\n+\n+  // get the user record we just created\n+  const user = (await db.select().from(users).where(eq(users.email, body.email)).limit(1))[0];\n+  // log the user in as the user that was just created\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+  \n+  \n+  await auth.login(event, user);\n+});\n+```\n+\n+### 4. Create a login page\n+\n+When registered users return to your site they'll need to be able to log back in. Create a new page at `/pages/login.vue` in your Nuxt app for user login. This page should have a form with fields for email and password and should submit a POST request to `/api/login`.\n+\n+Like the registration page, we'll intercept the form submission using `@submit.prevent` and use [`$fetch`](https://nuxt.com/docs/getting-started/data-fetching#fetch) to post the data to `/api/login`.\n+\n+This is a very simple login form example, so you'd definitely want to add more validation and error checking in a real-world application.\n+\n+```vue [/pages/login.vue]\n+<script setup lang=\"ts\">\n+  import { ref } from \"vue\";\n+\n+  const form = ref({\n+    email: \"\",\n+    password: \"\",\n+  });\n+\n+  const error = ref(null);\n+\n+  async function submitForm() {\n+    // clear any previous errors\n+    error.value = null;\n+\n+    // perform the login\n+    try {\n+      await $fetch(\"/api/auth/login\", {\n+        method: \"POST\",\n+        body: loginForm.value,\n+      });\n+    } catch (e) {\n+      // if there's an error, set the error message and return early\n+      error.value = \"Error logging in\";\n+      return;\n+    }\n+\n+    // Refresh the session status now that the user is logged in\n+    // This is a fetch() function from auth-utils to refresh session data in the client, and is not the same as $fetch\n+    const { fetch } = useUserSession();\n+    await fetch();\n+    \n+    // you may want to use something like Pinia to manage global state of the logged-in user\n+    // update Pinia state here...\n+\n+    // take the user to the auth-only users index page now that they're logged in\n+    await navigateTo(\"/users\");\n+\n+    // Alternative - Don't use Nuxt Router here so that we can easily trigger a whole page load and get the whole UI refreshed now that the user is logged in. This will perform a full-page load.\n+    // window.location.href = \"/users\";\n+  }\n+</script>\n+\n+<template>\n+  <div>\n+    <form class=\"space-y-2\" @submit.prevent=\"submitForm\">\n+      <div>\n+        <label for=\"email\" class=\"block text-sm uppercase\">Email</label>\n+\n+        <input id=\"email\" name=\"email\" v-model=\"form.email\" class=\"rounded-md px-2 py-1\" required />\n+      </div>\n+\n+      <div>\n+        <label for=\"password\" class=\"block text-sm uppercase\">password</label>\n+\n+        <input\n+            id=\"password\"\n+            name=\"password\"\n+            v-model=\"form.password\"\n+            class=\"rounded-md px-2 py-1\"\n+            type=\"password\"\n+            required\n+        />\n+      </div>\n+\n+      <div class=\"pt-2\">\n+        <button type=\"submit\">Login</button>\n+      </div>\n+\n+      <div v-if=\"error\">{{ error }}</div>\n+    </form>\n+  </div>\n+</template>\n+\n+```\n+\n+### 5. Create an API route for login\n+\n+With the login form created, we need to create an API route to handle the login request. This route should accept a POST request with the email and password in the request body and check the email and password against the database. If the user and password match, we'll set a session cookie to log the user in.\n+\n+This server API route should be at `/server/api/auth/login.post.ts`. Just like the registration form endpoint, suffixing the filename in `.post.ts.` means that this handler will only respond to post requests.\n+\n+```typescript [/server/api/auth/login.post.ts]\n+import users from \"~/database/schema/users\";\n+import getDatabase from \"~/database/database\";\n+import { eq } from \"drizzle-orm\";\n+import bcrypt from \"bcrypt\";\n+\n+export default defineEventHandler(async (event) => {\n+  const db = await getDatabase();\n+\n+  const foundUser = (\n+    await db\n+      .select({ id: users.id, name: users.name, email: users.email, password: users.password })\n+      .from(users)\n+      .where(eq(users.email, email))\n+      .limit(1)\n+  )?.[0];\n+\n+  // compare the password hash\n+  if (!foundUser || !bcrypt.compareSync(password, foundUser.password)) {\n+    // return an error if the user is not found or the password doesn't match\n+    throw createError({\n+      statusCode: 401,\n+      statusMessage: \"Invalid email or password\",\n+    });\n+  }\n+\n+  // log in as the selected user\n+  await replaceUserSession(event, {\n+    user: {\n+      id: user.id,\n+      name: user.name,\n+    },\n+    loggedInAt: new Date(),\n+  });\n+});\n+\n+\n+```\n+\n+The user should now be logged in! With the session set, we can get the current user session in any API route or page by calling `getUserSession(event)` which is auto-imported as a util function from the `nuxt-auth-utils` package.\n+\n+### 6. Create a logout API route\n+\n+Users need to be able to log out, so we should create an API route to allow them to do this. This should require post request as well, just like login. We'll clear the session when this endpoint is called.\n+\n+We'll use the `clearUserSession` from the `auth-utils` module to log the user out and clear the session data. This function is automatically imported from the module by Nuxt, so we don't need to manually import it.\n+\n+```typescript [server/api/auth/logout.post.ts]\n+export default defineEventHandler(async (event) => {\n+  // Clear the current user session\n+  await clearUserSession(event);\n+});\n+```\n+\n+### 7. Protect your server route\n+\n+Protecting server routes is key to making sure your data are safe. Front-end middleware is helpful for the user, but without back-end protection your data can still be accessed. Because of this, it is critical that we protect any API routes with sensitive data. For these sensitive routes, we should return a 401 error if the user is not logged in.\n+\n+The `auth-utils` module provides the `requireUserSession` utility function to help make sure that users are logged in and have an active session. We can use this to protect our different endpoints. Like many of the other utilities from the auth module, it is automatically imported in our server endpoints.\n+\n+In the example below, we use the `requireUserSession` utility function to protect the `/server/api/users.get.ts` server route. This route will only be accessible to logged-in users.\n+\n+```typescript [/server/api/users.get.ts]\n+import getDatabase from \"~/database/database\";\n+import users from \"~/database/schema/users\";\n+import requireUserLoggedIn from \"~/server/utils/requireUserLoggedIn\";\n+\n+export default defineEventHandler(async (event) => {\n+  // make sure the user is logged in\n+  // This will throw a 401 error if the request doesn't come from a valid user session\n+  await requireUserSession(event);\n+\n+  // If we make it hear, the user is authenticated. It's safe to fetch and return data\n+  const db = await getDatabase();\n+  \n+  // Send back the list of users\n+  const userList = await db.select({ name: users.name, id: users.id }).from(users).limit(10);\n+\n+  return userList;\n+});\n+```\n+\n+### 8. Create a front-end middleware to protect routes",
        "comment_created_at": "2024-06-16T17:10:26+00:00",
        "comment_author": "GalacticHypernova",
        "comment_body": "Sounds good! The less technical terms the more beginner friendly it would be",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1688805016",
    "pr_number": 28269,
    "pr_file": "docs/3.api/5.kit/14.builder.md",
    "created_at": "2024-07-23T22:49:05+00:00",
    "commented_code": "### Type\n \n ```ts\n-function extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void\n+function extendViteConfig (callback: ((config: UserConfig) => void), options?: ExtendViteConfigOptions): void",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1688805016",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 28269,
        "pr_file": "docs/3.api/5.kit/14.builder.md",
        "discussion_id": "1688805016",
        "commented_code": "@@ -112,7 +112,7 @@ Extends the Vite configuration. Callback function can be called multiple times,\n ### Type\n \n ```ts\n-function extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void\n+function extendViteConfig (callback: ((config: UserConfig) => void), options?: ExtendViteConfigOptions): void",
        "comment_created_at": "2024-07-23T22:49:05+00:00",
        "comment_author": "danielroe",
        "comment_body": "Although technically correct (as in, it's the `UserConfig` export from `vite`), this is less intuitive for users who need to know that this configuration is _vite_ configuration. Can you think of a better way of communicating it?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1596306432",
    "pr_number": 27138,
    "pr_file": "docs/1.getting-started/11.testing.md",
    "created_at": "2024-05-10T06:14:48+00:00",
    "commented_code": "```\n \n ```ts twoslash\n-import type { Component } from 'vue'\n import { it, expect } from 'vitest'\n-declare const SomeComponent: Component\n-declare const App: Component\n // ---cut---\n // tests/App.nuxt.spec.ts\n import { renderSuspended } from '@nuxt/test-utils/runtime'\n+import App from '@/app.vue'",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1596306432",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27138,
        "pr_file": "docs/1.getting-started/11.testing.md",
        "discussion_id": "1596306432",
        "commented_code": "@@ -215,13 +220,11 @@ it('can render some component', async () => {\n ```\n \n ```ts twoslash\n-import type { Component } from 'vue'\n import { it, expect } from 'vitest'\n-declare const SomeComponent: Component\n-declare const App: Component\n // ---cut---\n // tests/App.nuxt.spec.ts\n import { renderSuspended } from '@nuxt/test-utils/runtime'\n+import App from '@/app.vue'",
        "comment_created_at": "2024-05-10T06:14:48+00:00",
        "comment_author": "danielroe",
        "comment_body": "```suggestion\nimport App from '~/app.vue'\n```\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1596365437",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 27138,
        "pr_file": "docs/1.getting-started/11.testing.md",
        "discussion_id": "1596306432",
        "commented_code": "@@ -215,13 +220,11 @@ it('can render some component', async () => {\n ```\n \n ```ts twoslash\n-import type { Component } from 'vue'\n import { it, expect } from 'vitest'\n-declare const SomeComponent: Component\n-declare const App: Component\n // ---cut---\n // tests/App.nuxt.spec.ts\n import { renderSuspended } from '@nuxt/test-utils/runtime'\n+import App from '@/app.vue'",
        "comment_created_at": "2024-05-10T07:19:54+00:00",
        "comment_author": "michaelmcandrew",
        "comment_body": "Thanks - I updated the @s to ~s and gave it a conventional commit message and force pushed (which now that I have properly read the contribution docs I am thinking might not have been necessary since it'll use the PR title).\r\n\r\nAnyhow, hopefully all good now. Thanks for your help. A nice smooth process :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1185330801",
    "pr_number": 20636,
    "pr_file": "docs/2.guide/1.concepts/6.esm.md",
    "created_at": "2023-05-04T17:51:22+00:00",
    "commented_code": "### ESM Syntax\n \n-Most of the time, when people talk about ESM vs CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).\n+Most of the time, when people talk about ESM VS CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1185330801",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/2.guide/1.concepts/6.esm.md",
        "discussion_id": "1185330801",
        "commented_code": "@@ -23,7 +23,7 @@ Bundlers like webpack and Rollup support this syntax and allow you to use module\n \n ### ESM Syntax\n \n-Most of the time, when people talk about ESM vs CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).\n+Most of the time, when people talk about ESM VS CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).",
        "comment_created_at": "2023-05-04T17:51:22+00:00",
        "comment_author": "DamianGlowala",
        "comment_body": "_vs_ should remain lowercase.\r\n\r\n```suggestion\r\nMost of the time, when people talk about ESM vs CJS, they are talking about a different syntax for writing [modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1186721962",
    "pr_number": 20636,
    "pr_file": "docs/1.getting-started/3.views.md",
    "created_at": "2023-05-06T17:03:31+00:00",
    "commented_code": "```\n \n ::alert\n-If you are familiar with Vue, you might wonder where `main.js` is (the file that normally creates a Vue app). Nuxt does this behind the scene.\n+If you are familiar with Vue, you might wonder where `main.js` is (the file that creates a Vue app). Nuxt does this behind the scene.\n ::\n \n ## Components\n \n ![Components are reusable pieces of UI](/assets/docs/getting-started/views/components.svg)\n \n-Most components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the `components/` directory, and they will be automatically available across your application without having to explicitly import them.\n+Most components are reusable pieces of the UI, like buttons and menus. In Nuxt, you can create these components in the `components/` directory. They will automatically be available across your application without explicitly importing them.",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1186721962",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/1.getting-started/3.views.md",
        "discussion_id": "1186721962",
        "commented_code": "@@ -21,14 +21,14 @@ By default, Nuxt will treat this file as the **entrypoint** and render its conte\n ```\n \n ::alert\n-If you are familiar with Vue, you might wonder where `main.js` is (the file that normally creates a Vue app). Nuxt does this behind the scene.\n+If you are familiar with Vue, you might wonder where `main.js` is (the file that creates a Vue app). Nuxt does this behind the scene.\n ::\n \n ## Components\n \n ![Components are reusable pieces of UI](/assets/docs/getting-started/views/components.svg)\n \n-Most components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the `components/` directory, and they will be automatically available across your application without having to explicitly import them.\n+Most components are reusable pieces of the UI, like buttons and menus. In Nuxt, you can create these components in the `components/` directory. They will automatically be available across your application without explicitly importing them.",
        "comment_created_at": "2023-05-06T17:03:31+00:00",
        "comment_author": "DamianGlowala",
        "comment_body": "Consistency (other places are using _user interface_ rather than _UI_)\r\n```suggestion\r\nMost components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the `components/` directory. They will automatically be available across your application (no need to import them explicitly).\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1186729712",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/1.getting-started/3.views.md",
        "discussion_id": "1186721962",
        "commented_code": "@@ -21,14 +21,14 @@ By default, Nuxt will treat this file as the **entrypoint** and render its conte\n ```\n \n ::alert\n-If you are familiar with Vue, you might wonder where `main.js` is (the file that normally creates a Vue app). Nuxt does this behind the scene.\n+If you are familiar with Vue, you might wonder where `main.js` is (the file that creates a Vue app). Nuxt does this behind the scene.\n ::\n \n ## Components\n \n ![Components are reusable pieces of UI](/assets/docs/getting-started/views/components.svg)\n \n-Most components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the `components/` directory, and they will be automatically available across your application without having to explicitly import them.\n+Most components are reusable pieces of the UI, like buttons and menus. In Nuxt, you can create these components in the `components/` directory. They will automatically be available across your application without explicitly importing them.",
        "comment_created_at": "2023-05-06T18:17:18+00:00",
        "comment_author": "GalacticHypernova",
        "comment_body": "Implemented!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1192748292",
    "pr_number": 20636,
    "pr_file": "docs/2.guide/3.going-further/3.modules.md",
    "created_at": "2023-05-12T19:56:13+00:00",
    "commented_code": "#### Be TypeScript Friendly",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1192748292",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/2.guide/3.going-further/3.modules.md",
        "discussion_id": "1192748292",
        "commented_code": "@@ -574,13 +574,13 @@ Ideally, you should prefix them with your module's name (e.g. if your module is\n \n #### Be TypeScript Friendly",
        "comment_created_at": "2023-05-12T19:56:13+00:00",
        "comment_author": "DamianGlowala",
        "comment_body": "```suggestion\r\n#### Be TypeScript-friendly\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1192777112",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/2.guide/3.going-further/3.modules.md",
        "discussion_id": "1192748292",
        "commented_code": "@@ -574,13 +574,13 @@ Ideally, you should prefix them with your module's name (e.g. if your module is\n \n #### Be TypeScript Friendly",
        "comment_created_at": "2023-05-12T20:41:43+00:00",
        "comment_author": "GalacticHypernova",
        "comment_body": "Should that in that case be TypeScript-Friendly? Having friendly be lowercase seems unnatural..",
        "pr_file_module": null
      },
      {
        "comment_id": "1192959091",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 20636,
        "pr_file": "docs/2.guide/3.going-further/3.modules.md",
        "discussion_id": "1192748292",
        "commented_code": "@@ -574,13 +574,13 @@ Ideally, you should prefix them with your module's name (e.g. if your module is\n \n #### Be TypeScript Friendly",
        "comment_created_at": "2023-05-13T10:01:49+00:00",
        "comment_author": "DamianGlowala",
        "comment_body": "Yes, you are right here, as per the [APA style](https://apastyle.apa.org/style-grammar-guidelines/capitalization/title-case) that we follow. Here is a tool we can use whenever in doubt to verify the correctness of the casing (with _Title Case_ option selected): https://capitalizemytitle.com/style/APA\r\n```suggestion\r\n#### Be TypeScript-Friendly\r\n```",
        "pr_file_module": null
      }
    ]
  }
]