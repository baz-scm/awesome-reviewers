[
  {
    "discussion_id": "2163324964",
    "pr_number": 32305,
    "pr_file": "docs/2.guide/4.recipes/3.custom-usefetch.md",
    "created_at": "2025-06-24T08:42:53+00:00",
    "commented_code": "- We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)\n - If the API responds with a `401` status code, we redirect the user to the `/login` page\n \n-```ts [plugins/api.ts]\n-export default defineNuxtPlugin((nuxtApp) => {\n-  const { session } = useUserSession()\n+```ts [utils/api.ts]\n+const { session } = useUserSession()",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "2163324964",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 32305,
        "pr_file": "docs/2.guide/4.recipes/3.custom-usefetch.md",
        "discussion_id": "2163324964",
        "commented_code": "@@ -23,11 +23,10 @@ Let's pretend here that:\n - We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)\n - If the API responds with a `401` status code, we redirect the user to the `/login` page\n \n-```ts [plugins/api.ts]\n-export default defineNuxtPlugin((nuxtApp) => {\n-  const { session } = useUserSession()\n+```ts [utils/api.ts]\n+const { session } = useUserSession()",
        "comment_created_at": "2025-06-24T08:42:53+00:00",
        "comment_author": "danielroe",
        "comment_body": "composables shouldn't be called at the top level ('ambiently' in JS) - this relies on being able to access the Nuxt context and will fail on the server.",
        "pr_file_module": null
      },
      {
        "comment_id": "2163481414",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 32305,
        "pr_file": "docs/2.guide/4.recipes/3.custom-usefetch.md",
        "discussion_id": "2163324964",
        "commented_code": "@@ -23,11 +23,10 @@ Let's pretend here that:\n - We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)\n - If the API responds with a `401` status code, we redirect the user to the `/login` page\n \n-```ts [plugins/api.ts]\n-export default defineNuxtPlugin((nuxtApp) => {\n-  const { session } = useUserSession()\n+```ts [utils/api.ts]\n+const { session } = useUserSession()",
        "comment_created_at": "2025-06-24T09:46:47+00:00",
        "comment_author": "maximepvrt",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1963879862",
    "pr_number": 31005,
    "pr_file": "docs/2.guide/3.going-further/6.nuxt-app.md",
    "created_at": "2025-02-20T16:09:25+00:00",
    "commented_code": "Many composables and utilities, both built-in and user-made, may require access to the Nuxt instance. This doesn't exist everywhere on your application, because a fresh instance is created on every request.\n \n-Currently, the Nuxt context is only accessible in [plugins](/docs/guide/directory-structure/plugins), [Nuxt hooks](/docs/guide/going-further/hooks), [Nuxt middleware](/docs/guide/directory-structure/middleware), and [setup functions](https://vuejs.org/api/composition-api-setup.html) (in pages and components).\n+Currently, the Nuxt context is only accessible in [plugins](/docs/guide/directory-structure/plugins), [Nuxt hooks](/docs/guide/going-further/hooks), [Nuxt middleware](/docs/guide/directory-structure/middleware) (in named and global route middleware), and [setup functions](https://vuejs.org/api/composition-api-setup.html) (in pages and components).",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1963879862",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 31005,
        "pr_file": "docs/2.guide/3.going-further/6.nuxt-app.md",
        "discussion_id": "1963879862",
        "commented_code": "@@ -23,7 +23,7 @@ Jump over the `NuxtApp` interface documentation.\n \n Many composables and utilities, both built-in and user-made, may require access to the Nuxt instance. This doesn't exist everywhere on your application, because a fresh instance is created on every request.\n \n-Currently, the Nuxt context is only accessible in [plugins](/docs/guide/directory-structure/plugins), [Nuxt hooks](/docs/guide/going-further/hooks), [Nuxt middleware](/docs/guide/directory-structure/middleware), and [setup functions](https://vuejs.org/api/composition-api-setup.html) (in pages and components).\n+Currently, the Nuxt context is only accessible in [plugins](/docs/guide/directory-structure/plugins), [Nuxt hooks](/docs/guide/going-further/hooks), [Nuxt middleware](/docs/guide/directory-structure/middleware) (in named and global route middleware), and [setup functions](https://vuejs.org/api/composition-api-setup.html) (in pages and components).",
        "comment_created_at": "2025-02-20T16:09:25+00:00",
        "comment_author": "danielroe",
        "comment_body": "```suggestion\r\nCurrently, the Nuxt context is only accessible in [plugins](/docs/guide/directory-structure/plugins), [Nuxt hooks](/docs/guide/going-further/hooks), [Nuxt middleware](/docs/guide/directory-structure/middleware) (if wrapped in `defineNuxtRouteMiddleware`), and [setup functions](https://vuejs.org/api/composition-api-setup.html) (in pages and components).\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1930325421",
    "pr_number": 30726,
    "pr_file": "docs/2.guide/1.concepts/10.nuxt-lifecycle.md",
    "created_at": "2025-01-27T10:47:33+00:00",
    "commented_code": "+---\n+title: 'Nuxt Lifecycle'\n+description: \"Understanding the lifecycle of Nuxt applications can help you gain deeper insights into how the framework operates, especially for both server-side and client-side rendering.\"\n+---\n+\n+The goal of this chapter is to provide a high-level overview of the different parts of the framework, their execution order, and how they work together.\n+\n+## Server Side\n+\n+For Server side, the following steps are executed for every initial request to your application:\n+\n+### Step 1: Setup Nitro Server and Nitro Plugins (Once)\n+\n+Nuxt is powered by [Nitro](https://nitro.build/), a modern server engine.\n+\n+When Nitro starts, it initializes and executes the plugins under the `/server/plugins` directory. These plugins can:\n+- Capture and handle application-wide errors.\n+- Register hooks that execute when Nitro shuts down.\n+- Register hooks for request lifecycle events, such as modifying responses.\n+\n+::callout{icon=\"i-ph-lightbulb\"}\n+Nitro plugins are executed only once when the server starts.\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/server#server-plugins\"}\n+\n+### Step 2: Nitro Server Middleware\n+\n+After initializing the Nitro server, middleware under `/server/middleware` is executed for every request. Middleware can be used for tasks such as authentication, logging, or request transformation.\n+\n+::warning\n+Returning a value from middleware will terminate the request and send the returned value as the response. This behavior should generally be avoided to ensure proper request handling!\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/server#server-middleware\"}\n+\n+### Step 3: Initialize Nuxt and Execute Nuxt Server Plugins\n+\n+The Vue and Nuxt instances are created first. Afterward, Nuxt executes its server plugins. This includes:\n+- Built-in plugins, such as Vue Router and `unhead`.\n+- Custom plugins located in the `plugins/` directory, including those without a suffix (e.g., `myPlugin.ts`) and those with the `.server` suffix (e.g., `myServerPlugin.server.ts`).\n+\n+Plugins execute in a specific order and may have dependencies on one another. For more details, including execution order and parallelism, refer to the [Plugins documentation](/docs/guide/directory-structure/plugins).\n+\n+::callout{icon=\"i-ph-lightbulb\"}\n+After this step, Nuxt calls the [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/plugins\"}\n+\n+### Step 4: Route Validation\n+\n+After initializing plugins and before executing middleware, Nuxt calls the `validate` method if it is defined in the `definePageMeta` function. The `validate` method, which can be synchronous or asynchronous, is often used to validate dynamic route parameters.\n+\n+- The `validate` function should return `true` if the parameters are valid.\n+- If validation fails, it should return `false` or an object containing a `statusCode` and/or `statusMessage` to terminate the request.\n+\n+For more information, see the [Route Validation documentation](/docs/getting-started/routing#route-validation).\n+\n+:read-more{to=\"/docs/getting-started/routing#route-validation\"}\n+\n+### Step 5: Execute Nuxt Server Middleware\n+\n+Middleware allows you to run code before navigating to a particular route. It is often used for tasks such as authentication, redirection, or logging.\n+\n+In Nuxt, there are three types of middleware:\n+- **Global route middleware**\n+- **Named route middleware**\n+- **Anonymous (or inline) route middleware**\n+\n+Nuxt automatically executes global middleware for first time enter to the application and every time before route navigation. Named and anonymous middleware are executed only on the routes specified in the middleware property of the page(route) meta defined in the corresponding page components.\n+\n+For details about each type and examples, see the [Middleware documentation](/docs/guide/directory-structure/middleware).\n+\n+:read-more{to=\"/docs/guide/directory-structure/middleware\"}\n+\n+### Step 6: Setup Page and Components\n+\n+Nuxt initializes the page and its components during this step and fetches any required data with `useFetch` and `useAsyncData`. Since there are no dynamic updates and no DOM operations occur on the server, Vue lifecycle hooks such as `onBeforeMount`, `onMounted`, and subsequent hooks are **NOT** executed during SSR.\n+",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1930325421",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 30726,
        "pr_file": "docs/2.guide/1.concepts/10.nuxt-lifecycle.md",
        "discussion_id": "1930325421",
        "commented_code": "@@ -0,0 +1,135 @@\n+---\n+title: 'Nuxt Lifecycle'\n+description: \"Understanding the lifecycle of Nuxt applications can help you gain deeper insights into how the framework operates, especially for both server-side and client-side rendering.\"\n+---\n+\n+The goal of this chapter is to provide a high-level overview of the different parts of the framework, their execution order, and how they work together.\n+\n+## Server Side\n+\n+For Server side, the following steps are executed for every initial request to your application:\n+\n+### Step 1: Setup Nitro Server and Nitro Plugins (Once)\n+\n+Nuxt is powered by [Nitro](https://nitro.build/), a modern server engine.\n+\n+When Nitro starts, it initializes and executes the plugins under the `/server/plugins` directory. These plugins can:\n+- Capture and handle application-wide errors.\n+- Register hooks that execute when Nitro shuts down.\n+- Register hooks for request lifecycle events, such as modifying responses.\n+\n+::callout{icon=\"i-ph-lightbulb\"}\n+Nitro plugins are executed only once when the server starts.\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/server#server-plugins\"}\n+\n+### Step 2: Nitro Server Middleware\n+\n+After initializing the Nitro server, middleware under `/server/middleware` is executed for every request. Middleware can be used for tasks such as authentication, logging, or request transformation.\n+\n+::warning\n+Returning a value from middleware will terminate the request and send the returned value as the response. This behavior should generally be avoided to ensure proper request handling!\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/server#server-middleware\"}\n+\n+### Step 3: Initialize Nuxt and Execute Nuxt Server Plugins\n+\n+The Vue and Nuxt instances are created first. Afterward, Nuxt executes its server plugins. This includes:\n+- Built-in plugins, such as Vue Router and `unhead`.\n+- Custom plugins located in the `plugins/` directory, including those without a suffix (e.g., `myPlugin.ts`) and those with the `.server` suffix (e.g., `myServerPlugin.server.ts`).\n+\n+Plugins execute in a specific order and may have dependencies on one another. For more details, including execution order and parallelism, refer to the [Plugins documentation](/docs/guide/directory-structure/plugins).\n+\n+::callout{icon=\"i-ph-lightbulb\"}\n+After this step, Nuxt calls the [`app:created`](/docs/api/advanced/hooks#app-hooks-runtime) hook, which can be used to execute additional logic.\n+::\n+\n+:read-more{to=\"/docs/guide/directory-structure/plugins\"}\n+\n+### Step 4: Route Validation\n+\n+After initializing plugins and before executing middleware, Nuxt calls the `validate` method if it is defined in the `definePageMeta` function. The `validate` method, which can be synchronous or asynchronous, is often used to validate dynamic route parameters.\n+\n+- The `validate` function should return `true` if the parameters are valid.\n+- If validation fails, it should return `false` or an object containing a `statusCode` and/or `statusMessage` to terminate the request.\n+\n+For more information, see the [Route Validation documentation](/docs/getting-started/routing#route-validation).\n+\n+:read-more{to=\"/docs/getting-started/routing#route-validation\"}\n+\n+### Step 5: Execute Nuxt Server Middleware\n+\n+Middleware allows you to run code before navigating to a particular route. It is often used for tasks such as authentication, redirection, or logging.\n+\n+In Nuxt, there are three types of middleware:\n+- **Global route middleware**\n+- **Named route middleware**\n+- **Anonymous (or inline) route middleware**\n+\n+Nuxt automatically executes global middleware for first time enter to the application and every time before route navigation. Named and anonymous middleware are executed only on the routes specified in the middleware property of the page(route) meta defined in the corresponding page components.\n+\n+For details about each type and examples, see the [Middleware documentation](/docs/guide/directory-structure/middleware).\n+\n+:read-more{to=\"/docs/guide/directory-structure/middleware\"}\n+\n+### Step 6: Setup Page and Components\n+\n+Nuxt initializes the page and its components during this step and fetches any required data with `useFetch` and `useAsyncData`. Since there are no dynamic updates and no DOM operations occur on the server, Vue lifecycle hooks such as `onBeforeMount`, `onMounted`, and subsequent hooks are **NOT** executed during SSR.\n+",
        "comment_created_at": "2025-01-27T10:47:33+00:00",
        "comment_author": "atinux",
        "comment_body": "```suggestion\r\n\r\n::important\r\nYou should avoid code that produces side effects that need cleanup in root scope of `<script setup>`. An example of such side effects is setting up timers with `setInterval`. In client-side only code we may setup a timer and then tear it down in `onBeforeUnmount` or `onUnmounted`. However, because the unmount hooks will never be called during SSR, the timers will stay around forever. To avoid this, move your side-effect code into `onMounted` instead.\r\n::\r\n\r\n```\r\n\r\nAdding this section copied from [Vue docs](https://vuejs.org/guide/scaling-up/ssr.html#component-lifecycle-hooks) as very important to avoid memory leaks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1667006694",
    "pr_number": 28053,
    "pr_file": "docs/1.getting-started/7.state-management.md",
    "created_at": "2024-07-05T17:12:40+00:00",
    "commented_code": "## Best Practices\n \n ::warning\n-Never define `const state = ref()` outside of `<script setup>` or `setup()` function.<br>\n+Never define `const state = ref()` outside of `<script setup>` or `setup()` function.\n+For example, doing `export myState = ref({})` would result in state shared across requests on the server.<br>",
    "repo_full_name": "nuxt/nuxt",
    "discussion_comments": [
      {
        "comment_id": "1667006694",
        "repo_full_name": "nuxt/nuxt",
        "pr_number": 28053,
        "pr_file": "docs/1.getting-started/7.state-management.md",
        "discussion_id": "1667006694",
        "commented_code": "@@ -23,7 +23,8 @@ Read more about `useState` composable.\n ## Best Practices\n \n ::warning\n-Never define `const state = ref()` outside of `<script setup>` or `setup()` function.<br>\n+Never define `const state = ref()` outside of `<script setup>` or `setup()` function.\n+For example, doing `export myState = ref({})` would result in state shared across requests on the server.<br>",
        "comment_created_at": "2024-07-05T17:12:40+00:00",
        "comment_author": "danielroe",
        "comment_body": "```suggestion\r\nFor example, doing `export myState = ref({})` would result in state shared across requests on the server and can lead to memory leaks.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]