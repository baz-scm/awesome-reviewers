[
  {
    "discussion_id": "2329811892",
    "pr_number": 32560,
    "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
    "created_at": "2025-09-08T11:44:28+00:00",
    "commented_code": "}\n \n     fn draw(&mut self, f: &mut Frame<'_>, area: Rect) -> Result<()> {\n-        // --- 1. Calculate Context ---\n-        let column_visibility = self.calculate_column_visibility(area.width);\n-        // If duration column is visible and was not visible before, update live durations\n-        let previous_show_duration = self\n-            .column_visibility\n-            .as_ref()\n-            .map_or(false, |cv| cv.show_duration);\n-        if column_visibility.show_duration && !previous_show_duration {\n-            self.update_live_durations();\n-        }\n-        // Cache the column visibility\n-        self.column_visibility = Some(column_visibility.clone());\n-        let _has_narrow_area_width = area.width < 90; // Keep for backward compatibility with bottom layout\n+        // --- 1. Initial Context ---\n         let filter_is_active = self.filter_mode || !self.filter_text.is_empty();\n         let is_dimmed = !self.is_task_list_focused();\n         let has_cloud_message = self.cloud_message.is_some();\n \n         // --- 2. Determine Bottom Layout Mode ---\n         enum BottomLayoutMode {\n-            SingleLine { help_collapsed: bool }, // Pag + Cloud + Help\n-            TwoLine { help_collapsed: bool },    // Cloud / Pag + Help\n-            NoCloud { help_collapsed: bool },    // Pag + Help\n+            SingleLine { help_collapsed: bool }, // Cloud + Help\n+            TwoLine { help_collapsed: bool },    // Cloud / Help\n+            NoCloud { help_collapsed: bool },    // Help only\n         }\n         let layout_mode: BottomLayoutMode;\n \n         if has_cloud_message {\n-            // Estimate cloud width (this might overestimate if URL gets truncated, but good for initial check)\n+            // Calculate the actual cloud message width that will be rendered\n+            // This accounts for the URL-only fallback when the full message doesn't fit\n             let cloud_text_width = if let Some(message) = &self.cloud_message {\n-                let url_start_pos = message.find(\"https://\").unwrap_or(message.len());\n-                let prefix = &message[0..url_start_pos];\n-                let url = &message[url_start_pos..];\n-                (prefix.len() + url.len()) as u16\n+                if message.contains(\"https://\") {\n+                    let url_start_pos = message.find(\"https://\").unwrap_or(message.len());\n+                    let prefix = &message[0..url_start_pos];\n+                    let url = &message[url_start_pos..];\n+                    let full_message_width = (prefix.len() + url.len()) as u16;\n+                    let url_width = url.len() as u16;\n+\n+                    // Check if we'll need to fall back to URL-only rendering\n+                    // We need to account for the help text that will be on the same line\n+                    let available_for_cloud = area\n+                        .width\n+                        .saturating_sub(SCROLLBAR_WIDTH)\n+                        .saturating_sub(COLLAPSED_HELP_WIDTH)\n+                        .saturating_sub(MIN_BOTTOM_SPACING);\n+",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2329994119",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32560,
        "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
        "discussion_id": "2329811892",
        "commented_code": "@@ -1432,50 +1487,55 @@ impl Component for TasksList {\n     }\n \n     fn draw(&mut self, f: &mut Frame<'_>, area: Rect) -> Result<()> {\n-        // --- 1. Calculate Context ---\n-        let column_visibility = self.calculate_column_visibility(area.width);\n-        // If duration column is visible and was not visible before, update live durations\n-        let previous_show_duration = self\n-            .column_visibility\n-            .as_ref()\n-            .map_or(false, |cv| cv.show_duration);\n-        if column_visibility.show_duration && !previous_show_duration {\n-            self.update_live_durations();\n-        }\n-        // Cache the column visibility\n-        self.column_visibility = Some(column_visibility.clone());\n-        let _has_narrow_area_width = area.width < 90; // Keep for backward compatibility with bottom layout\n+        // --- 1. Initial Context ---\n         let filter_is_active = self.filter_mode || !self.filter_text.is_empty();\n         let is_dimmed = !self.is_task_list_focused();\n         let has_cloud_message = self.cloud_message.is_some();\n \n         // --- 2. Determine Bottom Layout Mode ---\n         enum BottomLayoutMode {\n-            SingleLine { help_collapsed: bool }, // Pag + Cloud + Help\n-            TwoLine { help_collapsed: bool },    // Cloud / Pag + Help\n-            NoCloud { help_collapsed: bool },    // Pag + Help\n+            SingleLine { help_collapsed: bool }, // Cloud + Help\n+            TwoLine { help_collapsed: bool },    // Cloud / Help\n+            NoCloud { help_collapsed: bool },    // Help only\n         }\n         let layout_mode: BottomLayoutMode;\n \n         if has_cloud_message {\n-            // Estimate cloud width (this might overestimate if URL gets truncated, but good for initial check)\n+            // Calculate the actual cloud message width that will be rendered\n+            // This accounts for the URL-only fallback when the full message doesn't fit\n             let cloud_text_width = if let Some(message) = &self.cloud_message {\n-                let url_start_pos = message.find(\"https://\").unwrap_or(message.len());\n-                let prefix = &message[0..url_start_pos];\n-                let url = &message[url_start_pos..];\n-                (prefix.len() + url.len()) as u16\n+                if message.contains(\"https://\") {\n+                    let url_start_pos = message.find(\"https://\").unwrap_or(message.len());\n+                    let prefix = &message[0..url_start_pos];\n+                    let url = &message[url_start_pos..];\n+                    let full_message_width = (prefix.len() + url.len()) as u16;\n+                    let url_width = url.len() as u16;\n+\n+                    // Check if we'll need to fall back to URL-only rendering\n+                    // We need to account for the help text that will be on the same line\n+                    let available_for_cloud = area\n+                        .width\n+                        .saturating_sub(SCROLLBAR_WIDTH)\n+                        .saturating_sub(COLLAPSED_HELP_WIDTH)\n+                        .saturating_sub(MIN_BOTTOM_SPACING);\n+",
        "comment_created_at": "2025-09-08T11:44:28+00:00",
        "comment_author": "leosvelperez",
        "comment_body": "To calculate whether a scrollbar is needed, we need to know the height, which we can only know after calculating the bottom space consumed by the help text and cloud link. Given the circular dep to calculate them, we safely reserve the space for the scrollbar.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2201350529",
    "pr_number": 31897,
    "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
    "created_at": "2025-07-11T17:09:59+00:00",
    "commented_code": "/// Updates their status to InProgress and triggers a sort.\n     pub fn start_tasks(&mut self, tasks: Vec<Task>) {\n+        let current_time = get_current_time_ms();\n         for task in tasks {\n             if let Some(task_item) = self.tasks.iter_mut().find(|t| t.name == task.id) {\n                 task_item.update_status(TaskStatus::InProgress);\n+                if task_item.start_time.is_none() {\n+                    // It should be set, but just in case\n+                    task_item.start_time = Some(current_time);\n+                }\n+                // Update duration to show \"...\" initially for non-continuous tasks\n+                if !task_item.continuous {\n+                    task_item.duration = DURATION_NOT_YET_KNOWN.to_string();",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2201350529",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31897,
        "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
        "discussion_id": "2201350529",
        "commented_code": "@@ -716,9 +718,18 @@ impl TasksList {\n \n     /// Updates their status to InProgress and triggers a sort.\n     pub fn start_tasks(&mut self, tasks: Vec<Task>) {\n+        let current_time = get_current_time_ms();\n         for task in tasks {\n             if let Some(task_item) = self.tasks.iter_mut().find(|t| t.name == task.id) {\n                 task_item.update_status(TaskStatus::InProgress);\n+                if task_item.start_time.is_none() {\n+                    // It should be set, but just in case\n+                    task_item.start_time = Some(current_time);\n+                }\n+                // Update duration to show \"...\" initially for non-continuous tasks\n+                if !task_item.continuous {\n+                    task_item.duration = DURATION_NOT_YET_KNOWN.to_string();",
        "comment_created_at": "2025-07-11T17:09:59+00:00",
        "comment_author": "FrozenPandaz",
        "comment_body": "I don't think we need to store this value in state. I think we only need to store the start time.. and ensure that it is there. (it should be as you said).\r\n\r\nI think the rest of this becomes obsolete if we calculate the elapsed time during the drawing of the duration column. So it naturally will not happen if we do not draw the column.",
        "pr_file_module": null
      },
      {
        "comment_id": "2206603892",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31897,
        "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
        "discussion_id": "2201350529",
        "commented_code": "@@ -716,9 +718,18 @@ impl TasksList {\n \n     /// Updates their status to InProgress and triggers a sort.\n     pub fn start_tasks(&mut self, tasks: Vec<Task>) {\n+        let current_time = get_current_time_ms();\n         for task in tasks {\n             if let Some(task_item) = self.tasks.iter_mut().find(|t| t.name == task.id) {\n                 task_item.update_status(TaskStatus::InProgress);\n+                if task_item.start_time.is_none() {\n+                    // It should be set, but just in case\n+                    task_item.start_time = Some(current_time);\n+                }\n+                // Update duration to show \"...\" initially for non-continuous tasks\n+                if !task_item.continuous {\n+                    task_item.duration = DURATION_NOT_YET_KNOWN.to_string();",
        "comment_created_at": "2025-07-15T07:09:42+00:00",
        "comment_author": "leosvelperez",
        "comment_body": "Like we discussed offline, we'll keep it as is because moving the calculation inside the rendering would result in many needless calculations.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200791498",
    "pr_number": 31885,
    "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
    "created_at": "2025-07-11T13:45:47+00:00",
    "commented_code": "fn draw(&mut self, f: &mut Frame<'_>, area: Rect) -> Result<()> {\n         // --- 1. Calculate Context ---\n-        let has_narrow_area_width = area.width < 90;\n+        let column_visibility = self.calculate_column_visibility(area.width);",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2200791498",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31885,
        "pr_file": "packages/nx/src/native/tui/components/tasks_list.rs",
        "discussion_id": "2200791498",
        "commented_code": "@@ -1382,7 +1412,8 @@ impl Component for TasksList {\n \n     fn draw(&mut self, f: &mut Frame<'_>, area: Rect) -> Result<()> {\n         // --- 1. Calculate Context ---\n-        let has_narrow_area_width = area.width < 90;\n+        let column_visibility = self.calculate_column_visibility(area.width);",
        "comment_created_at": "2025-07-11T13:45:47+00:00",
        "comment_author": "AgentEnder",
        "comment_body": "I wonder if we could easily do this on resize / init only? In the draw method this could waste some time (albeit not much), if its not too much work it would be better to only call when needed and store the visibility.",
        "pr_file_module": null
      }
    ]
  }
]