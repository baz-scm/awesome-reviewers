[
  {
    "discussion_id": "2454999690",
    "pr_number": 33200,
    "pr_file": "astro-docs/src/content/docs/guides/Nx Release/release-groups.mdoc",
    "created_at": "2025-10-23T12:42:26+00:00",
    "commented_code": "+---\n+title: Release Groups\n+description: Learn how to configure Nx Release to organize projects into release groups, with specific configuration for each group depending on your needs.\n+filter: 'type:Guides'\n+---\n+\n+Nx supports workspaces of any size and scale, and that means that projects can often be worked on in the same Nx workspace that have very different release requirements.\n+\n+Nx release supports the concept of release groups to allow you to configure different subsets of projects in different ways. Importantly, projects in different release groups can still depend on each other, and nx release can automatically handle updating dependencies and dependents across any number of group boundaries.\n+\n+{% aside type=\"note\" title=\"Default Group\" %}\n+Technically, even if you have no nx release configuration at all, you are always dealing with release groups. Behind the scenes, if no release groups are configured, Nx will automatically create an implicit `__default__` release group for you that includes all projects in the workspace that are able to be released.\n+\n+When you use the `\"projects\"` property in the `\"release\"` config at the top level, you are really adjusting the projects that are present in that `__default__` group.\n+{% /aside %}\n+\n+## Understanding Release Groups\n+\n+Release groups provide a way to organize your projects based on their release requirements. Each group can have its own:\n+\n+- **Projects Relationship** - Whether projects within the group are versioned independently or in lock step (fixed)\n+- **Version configuration** - Custom conventional commits, version prefixes, and more\n+- **Changelog configuration** - Different changelog formats and locations\n+- **Release tag** - Various options related to the git tags that influence the release process\n+- **Docker configuration** - Specific Docker versioning schemes\n+\n+## Creating Release Groups\n+\n+To create release groups, define them in your `nx.json` file under the `release.groups` property:",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2454999690",
        "repo_full_name": "nrwl/nx",
        "pr_number": 33200,
        "pr_file": "astro-docs/src/content/docs/guides/Nx Release/release-groups.mdoc",
        "discussion_id": "2454999690",
        "commented_code": "@@ -0,0 +1,337 @@\n+---\n+title: Release Groups\n+description: Learn how to configure Nx Release to organize projects into release groups, with specific configuration for each group depending on your needs.\n+filter: 'type:Guides'\n+---\n+\n+Nx supports workspaces of any size and scale, and that means that projects can often be worked on in the same Nx workspace that have very different release requirements.\n+\n+Nx release supports the concept of release groups to allow you to configure different subsets of projects in different ways. Importantly, projects in different release groups can still depend on each other, and nx release can automatically handle updating dependencies and dependents across any number of group boundaries.\n+\n+{% aside type=\"note\" title=\"Default Group\" %}\n+Technically, even if you have no nx release configuration at all, you are always dealing with release groups. Behind the scenes, if no release groups are configured, Nx will automatically create an implicit `__default__` release group for you that includes all projects in the workspace that are able to be released.\n+\n+When you use the `\"projects\"` property in the `\"release\"` config at the top level, you are really adjusting the projects that are present in that `__default__` group.\n+{% /aside %}\n+\n+## Understanding Release Groups\n+\n+Release groups provide a way to organize your projects based on their release requirements. Each group can have its own:\n+\n+- **Projects Relationship** - Whether projects within the group are versioned independently or in lock step (fixed)\n+- **Version configuration** - Custom conventional commits, version prefixes, and more\n+- **Changelog configuration** - Different changelog formats and locations\n+- **Release tag** - Various options related to the git tags that influence the release process\n+- **Docker configuration** - Specific Docker versioning schemes\n+\n+## Creating Release Groups\n+\n+To create release groups, define them in your `nx.json` file under the `release.groups` property:",
        "comment_created_at": "2025-10-23T12:42:26+00:00",
        "comment_author": "jaysoo",
        "comment_body": "We should also have a section for `release.group`s under the reference page: https://nx.dev/docs/reference/nx-json#release\n\nCan do a follow-up on it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2455668345",
    "pr_number": 33206,
    "pr_file": "astro-docs/src/content/docs/technologies/dotnet/Guides/migrate-from-nx-dotnet-core.mdoc",
    "created_at": "2025-10-23T15:39:04+00:00",
    "commented_code": "+---\n+title: Migrate from @nx-dotnet/core to @nx/dotnet\n+description: Step-by-step guide to migrate from the community @nx-dotnet/core plugin to the official @nx/dotnet plugin\n+sidebar:\n+  label: Migrate from @nx-dotnet/core\n+filter: 'type:Guides'\n+---\n+\n+This guide provides a streamlined migration path from the community `@nx-dotnet/core` plugin to Nx's official `@nx/dotnet` plugin.\n+\n+{% callout type=\"note\" title=\"Plugin Status\" %}\n+The `@nx-dotnet/core` plugin is deprecated in favor of the official `@nx/dotnet` plugin (available in Nx 22+), which is maintained by the Nx team and integrated directly into the Nx repository.\n+{% /callout %}\n+\n+## Why Migrate?\n+\n+The official `@nx/dotnet` plugin represents a natural evolution, building on lessons learned from the community plugin while embracing native .NET workflows:\n+\n+### Better Performance\n+\n+Significant performance improvements through efficient MSBuild analysis:\n+\n+- **Efficient dependency detection** using MSBuild APIs instead of repeated CLI calls\n+- **Smaller footprint** with minimal dependencies (2 packages vs 12+)\n+\n+### Simpler Architecture\n+\n+- **Embraces native .NET tooling**: Use `dotnet new`, `dotnet add`, etc. directly\n+- **Command-based targets**: Transparent `dotnet` commands instead of custom executors\n+- **Zero configuration**: Automatic project detection without custom config files\n+- **Minimal learning curve**: If you know the .NET CLI, you're already an expert\n+\n+### Production-Ready Support\n+\n+- **Official Nx support**: Maintained by the Nx core team\n+- **Always compatible**: Integrated into Nx releases, no version lag\n+- **MSBuild accuracy**: Uses Microsoft's official APIs for more accurate project analysis\n+- **Battle-tested**: Used in production Nx workspaces\n+\n+### Key Design Decisions\n+\n+The official plugin takes a streamlined approach:\n+\n+- **Project inference**: Automatic detection of .NET projects without configuration\n+- **MSBuild integration**: Direct use of Microsoft's APIs for accurate dependency analysis\n+- **Native CLI first**: Uses `dotnet` commands directly instead of custom wrappers\n+- **Minimal abstraction**: Simpler implementation with fewer dependencies\n+\n+This results in a faster, more reliable, and easier to maintain solution.",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2455668345",
        "repo_full_name": "nrwl/nx",
        "pr_number": 33206,
        "pr_file": "astro-docs/src/content/docs/technologies/dotnet/Guides/migrate-from-nx-dotnet-core.mdoc",
        "discussion_id": "2455668345",
        "commented_code": "@@ -0,0 +1,448 @@\n+---\n+title: Migrate from @nx-dotnet/core to @nx/dotnet\n+description: Step-by-step guide to migrate from the community @nx-dotnet/core plugin to the official @nx/dotnet plugin\n+sidebar:\n+  label: Migrate from @nx-dotnet/core\n+filter: 'type:Guides'\n+---\n+\n+This guide provides a streamlined migration path from the community `@nx-dotnet/core` plugin to Nx's official `@nx/dotnet` plugin.\n+\n+{% callout type=\"note\" title=\"Plugin Status\" %}\n+The `@nx-dotnet/core` plugin is deprecated in favor of the official `@nx/dotnet` plugin (available in Nx 22+), which is maintained by the Nx team and integrated directly into the Nx repository.\n+{% /callout %}\n+\n+## Why Migrate?\n+\n+The official `@nx/dotnet` plugin represents a natural evolution, building on lessons learned from the community plugin while embracing native .NET workflows:\n+\n+### Better Performance\n+\n+Significant performance improvements through efficient MSBuild analysis:\n+\n+- **Efficient dependency detection** using MSBuild APIs instead of repeated CLI calls\n+- **Smaller footprint** with minimal dependencies (2 packages vs 12+)\n+\n+### Simpler Architecture\n+\n+- **Embraces native .NET tooling**: Use `dotnet new`, `dotnet add`, etc. directly\n+- **Command-based targets**: Transparent `dotnet` commands instead of custom executors\n+- **Zero configuration**: Automatic project detection without custom config files\n+- **Minimal learning curve**: If you know the .NET CLI, you're already an expert\n+\n+### Production-Ready Support\n+\n+- **Official Nx support**: Maintained by the Nx core team\n+- **Always compatible**: Integrated into Nx releases, no version lag\n+- **MSBuild accuracy**: Uses Microsoft's official APIs for more accurate project analysis\n+- **Battle-tested**: Used in production Nx workspaces\n+\n+### Key Design Decisions\n+\n+The official plugin takes a streamlined approach:\n+\n+- **Project inference**: Automatic detection of .NET projects without configuration\n+- **MSBuild integration**: Direct use of Microsoft's APIs for accurate dependency analysis\n+- **Native CLI first**: Uses `dotnet` commands directly instead of custom wrappers\n+- **Minimal abstraction**: Simpler implementation with fewer dependencies\n+\n+This results in a faster, more reliable, and easier to maintain solution.",
        "comment_created_at": "2025-10-23T15:39:04+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "I'd just condense this into 1 list of section and get on with the migration guide. \r\n\r\n```suggestion\r\n- **Project inference**: Automatic detection of .NET projects without configuration with [Nx inferred targets](/docs/guides/tasks--caching/convert-to-inferred)\r\n- **MSBuild integration**: Direct use of Microsoft's APIs for accurate dependency analysis\r\n- **Native CLI first**: Uses `dotnet` commands directly instead of custom wrappers\r\n- **Minimal abstraction**: Simpler implementation with fewer dependencies\r\n\r\nThis results in a faster, and more reliable .NET plugin.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2455788096",
    "pr_number": 33206,
    "pr_file": "astro-docs/src/content/docs/technologies/dotnet/Guides/migrate-from-nx-dotnet-core.mdoc",
    "created_at": "2025-10-23T16:04:22+00:00",
    "commented_code": "+---\n+title: Migrate from @nx-dotnet/core to @nx/dotnet\n+description: Step-by-step guide to migrate from the community @nx-dotnet/core plugin to the official @nx/dotnet plugin\n+sidebar:\n+  label: Migrate from @nx-dotnet/core\n+filter: 'type:Guides'\n+---\n+\n+This guide provides a streamlined migration path from the community `@nx-dotnet/core` plugin to Nx's official `@nx/dotnet` plugin.\n+\n+{% callout type=\"note\" title=\"Plugin Status\" %}\n+The `@nx-dotnet/core` plugin is deprecated in favor of the official `@nx/dotnet` plugin (available in Nx 22+), which is maintained by the Nx team and integrated directly into the Nx repository.\n+{% /callout %}\n+\n+## Why Migrate?\n+\n+The official `@nx/dotnet` plugin represents a natural evolution, building on lessons learned from the community plugin while embracing native .NET workflows:\n+\n+### Better Performance\n+\n+Significant performance improvements through efficient MSBuild analysis:\n+\n+- **Efficient dependency detection** using MSBuild APIs instead of repeated CLI calls\n+- **Smaller footprint** with minimal dependencies (2 packages vs 12+)\n+\n+### Simpler Architecture\n+\n+- **Embraces native .NET tooling**: Use `dotnet new`, `dotnet add`, etc. directly\n+- **Command-based targets**: Transparent `dotnet` commands instead of custom executors\n+- **Zero configuration**: Automatic project detection without custom config files\n+- **Minimal learning curve**: If you know the .NET CLI, you're already an expert\n+\n+### Production-Ready Support\n+\n+- **Official Nx support**: Maintained by the Nx core team\n+- **Always compatible**: Integrated into Nx releases, no version lag\n+- **MSBuild accuracy**: Uses Microsoft's official APIs for more accurate project analysis\n+- **Battle-tested**: Used in production Nx workspaces\n+\n+### Key Design Decisions\n+\n+The official plugin takes a streamlined approach:\n+\n+- **Project inference**: Automatic detection of .NET projects without configuration\n+- **MSBuild integration**: Direct use of Microsoft's APIs for accurate dependency analysis\n+- **Native CLI first**: Uses `dotnet` commands directly instead of custom wrappers\n+- **Minimal abstraction**: Simpler implementation with fewer dependencies\n+\n+This results in a faster, more reliable, and easier to maintain solution.\n+\n+## Prerequisites\n+\n+Before starting the migration:\n+\n+- [ ] Upgrade to **.NET SDK 8.0 or later** (required)\n+- [ ] Locate your current @nx-dotnet/core configuration (see below)\n+- [ ] Review any custom generators and executors you're using\n+- [ ] Ensure your projects build successfully with current setup\n+\n+### Locating Your Configuration\n+\n+The @nx-dotnet/core plugin configuration can be in one of two places:\n+\n+**Option 1: In `nx.json` (newer default)**\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx-dotnet/core\",\n+      \"options\": {\n+        \"inferredTargets\": { ... },\n+        \"solutionFile\": \"...\",\n+        // ... other options\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+**Option 2: In `.nx-dotnet.rc.json` (legacy)**\n+\n+```json\n+{\n+  \"inferredTargets\": { ... },\n+  \"solutionFile\": \"...\",\n+  // ... other options\n+}\n+```\n+\n+{% callout type=\"note\" title=\"No Configuration?\" %}\n+If you don't have custom configuration in either location, that's fine! The plugin works with defaults, and migration will be even simpler.\n+{% /callout %}\n+\n+## Migration Steps\n+\n+### 1. Install @nx/dotnet\n+\n+```shell {% frame=\"none\" %}\n+nx add @nx/dotnet\n+```\n+\n+This automatically:\n+\n+- Adds `@nx/dotnet` to `package.json`\n+- Registers the plugin in `nx.json`\n+- Configures `production` named inputs\n+- Updates `.gitignore`\n+\n+### 2. Remove @nx-dotnet/core\n+\n+```shell {% frame=\"none\" %}\n+npm uninstall @nx-dotnet/core @nx-dotnet/utils @nx-dotnet/dotnet\n+```\n+\n+Then clean up your configuration:\n+\n+- Remove `@nx-dotnet/core` from the `plugins` array in `nx.json` (if present)\n+- Delete `.nx-dotnet.rc.json` (if it exists)\n+\n+### 3. Migrate Plugin Configuration\n+\n+Move any customized target configurations from your @nx-dotnet/core config to the new @nx/dotnet plugin options.\n+\n+**Before** (in `nx.json` or `.nx-dotnet.rc.json`):\n+\n+```json\n+{\n+  \"inferredTargets\": {\n+    \"build\": \"build\",\n+    \"test\": {\n+      \"targetName\": \"test:dotnet\",\n+      \"cache\": false\n+    }\n+  }\n+}\n+```\n+\n+**After** (in `nx.json`):\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx/dotnet\",\n+      \"options\": {\n+        \"build\": {\n+          \"targetName\": \"build\"\n+        },\n+        \"test\": {\n+          \"targetName\": \"test:dotnet\"\n+        }\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+### 4. Clear Cache and Verify\n+\n+```shell {% frame=\"none\" %}\n+nx reset\n+nx graph\n+```\n+\n+The `nx graph` command should show all your .NET projects with their dependencies correctly detected.\n+\n+## Key Workflow Changes\n+\n+Here's what changes in your day-to-day development workflow:\n+\n+| Task                      | Old (@nx-dotnet/core)                                          | New (@nx/dotnet)                                |\n+| ------------------------- | -------------------------------------------------------------- | ----------------------------------------------- |\n+| **Create application**    | `nx g @nx-dotnet/core:app my-api`                              | `dotnet new webapi -n MyApi`                    |\n+| **Create library**        | `nx g @nx-dotnet/core:lib my-lib`                              | `dotnet new classlib -n MyLib`                  |\n+| **Add project reference** | `nx g @nx-dotnet/core:project-reference --source A --target B` | `dotnet add reference ../B/B.csproj`            |\n+| **Add NuGet package**     | `nx g @nx-dotnet/core:nuget-reference`                         | `dotnet add package PackageName`                |\n+| **Build project**         | `nx build my-api`                                              | `nx build my-api` \u2705 (same)                     |\n+| **Run tests**             | `nx test my-api`                                               | `nx test my-api` \u2705 (same)                      |\n+| **Serve/watch**           | `nx serve my-api`                                              | `dotnet watch run` (or configure custom target) |\n+\n+### Targets Generated\n+\n+The plugin automatically creates these targets for .NET projects:\n+\n+| Target    | When Created        | Command                                       |\n+| --------- | ------------------- | --------------------------------------------- |\n+| `build`   | All projects        | `dotnet build --no-restore --no-dependencies` |\n+| `test`    | Test projects only  | `dotnet test --no-build --no-restore`         |\n+| `restore` | All projects        | `dotnet restore`                              |\n+| `clean`   | All projects        | `dotnet clean`                                |\n+| `publish` | Executable projects | `dotnet publish`                              |\n+| `pack`    | Library projects    | `dotnet pack`                                 |\n+\n+{% callout type=\"note\" title=\"Missing Targets\" %}\n+The `serve` and `format` targets are not automatically created. `serve` defaults to a target named `watch` now. To run it, you'd need to run something like `nx watch my-api run` or `nx run my-api:watch run`. To configure the watch target to act like `serve`, you could set the following in `nx.json`:\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx/dotnet\",\n+      \"options\": {\n+        \"watch\": {\n+          \"targetName\": \"serve\",\n+          \"args\": [\"run\"]\n+        }\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+The `format` target is not present by default. You should add it as a custom target if desired.\n+\n+{% /callout %}\n+\n+## Advanced Migration Scenarios\n+\n+### Migrating from Explicit Executor Configurations\n+\n+If you have `project.json` files that explicitly configure @nx-dotnet/core executors, you'll need to update them to use command targets.\n+\n+**Before** (`project.json`):\n+\n+```json\n+{\n+  \"name\": \"my-api\",\n+  \"targets\": {\n+    \"build\": {\n+      \"executor\": \"@nx-dotnet/core:build\",\n+      \"options\": {\n+        \"configuration\": \"Release\",\n+        \"noDependencies\": true\n+      }\n+    },\n+    \"test\": {\n+      \"executor\": \"@nx-dotnet/core:test\",\n+      \"options\": {\n+        \"testProject\": \"MyApi.Tests.csproj\"\n+      }\n+    },\n+    \"serve\": {\n+      \"executor\": \"@nx-dotnet/core:serve\",\n+      \"options\": {\n+        \"project\": \"MyApi.csproj\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+**After** (`project.json`):\n+\n+```json\n+{\n+  \"name\": \"my-api\",\n+  \"targets\": {\n+    \"build\": {\n+      \"command\": \"dotnet build\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\",\n+        \"args\": [\"--configuration\", \"Release\", \"--no-dependencies\"]\n+      }\n+    },\n+    \"test\": {\n+      \"command\": \"dotnet test MyApi.Tests.csproj\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\"\n+      }\n+    },\n+    \"serve\": {\n+      \"command\": \"dotnet watch run\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+{% callout type=\"note\" title=\"Automatic Target Inference\" %}\n+In most cases, you can delete these `project.json` files entirely. The @nx/dotnet plugin will automatically infer the correct targets based on your `.csproj` files. Only keep custom `project.json` configurations if you need non-standard options.\n+{% /callout %}\n+\n+### Migrating from `inferProjects: false`\n+\n+If you previously set `inferProjects: false` in your @nx-dotnet/core config, this option no longer exists in @nx/dotnet. The new plugin **always** infers projects automatically.\n+\n+**Why this changed:**\n+\n+- Project inference is a core feature of how Nx plugins work\n+- Manual project management doesn't align with Nx's automatic detection model\n+- Maintaining explicit project configurations is error-prone\n+\n+**Migration path:**\n+\n+1. **If you disabled inference to exclude certain projects:**\n+\n+   - Use the `exclude` property in the plugin configuration:\n+     ```json\n+     {\n+       \"plugins\": [\n+         {\n+           \"plugin\": \"@nx/dotnet\",\n+           \"exclude\": [\"legacy-projects/**\", \"temp-projects/**\"]\n+         }\n+       ]\n+     }\n+     ```\n+\n+2. **If you disabled inference to use explicit project.json files:**\n+\n+   - The new plugin will still detect your projects via `.csproj` files\n+   - You can keep `project.json` files to customize targets, but they're optional\n+   - Consider removing them to use the automatically inferred targets\n+\n+3. **If you need to completely hide projects from Nx:**\n+   - Use the `exclude` property in the plugin configuration\n+   - Or move projects outside the workspace\n+\n+## Configuration Changes\n+\n+### Module Boundaries \u2192 Nx Conformance\n+\n+If you used `moduleBoundaries` in your @nx-dotnet/core config, you may want to migrate to [Nx Conformance rules](https://nx.dev/docs/enterprise/powerpack/conformance)\n+\n+The script used to evaluate module boundaries is missing several features from the eslint and conformance implementations, and is not present in the new plugin. If you wish to continue using it, you'll need to inline the implementation in your repository and update the path in `Directory.build.targets`. Otherwise, you should remove the target from `Directory.build.targets`.\n+\n+### NuGet Package Management\n+\n+Replace the `sync` generator with MSBuild's [Central Package Management](https://learn.microsoft.com/nuget/consume-packages/central-package-management).\n+\n+Create `Directory.Packages.props` at workspace root:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\n+  </PropertyGroup>\n+  <ItemGroup>\n+    <PackageVersion Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n+    <PackageVersion Include=\"Microsoft.Extensions.Logging\" Version=\"8.0.0\" />\n+  </ItemGroup>\n+</Project>\n+```\n+\n+Update project files to remove version attributes:\n+\n+```xml\n+<!-- Before -->\n+<PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n+\n+<!-- After -->\n+<PackageReference Include=\"Newtonsoft.Json\" />",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2455788096",
        "repo_full_name": "nrwl/nx",
        "pr_number": 33206,
        "pr_file": "astro-docs/src/content/docs/technologies/dotnet/Guides/migrate-from-nx-dotnet-core.mdoc",
        "discussion_id": "2455788096",
        "commented_code": "@@ -0,0 +1,448 @@\n+---\n+title: Migrate from @nx-dotnet/core to @nx/dotnet\n+description: Step-by-step guide to migrate from the community @nx-dotnet/core plugin to the official @nx/dotnet plugin\n+sidebar:\n+  label: Migrate from @nx-dotnet/core\n+filter: 'type:Guides'\n+---\n+\n+This guide provides a streamlined migration path from the community `@nx-dotnet/core` plugin to Nx's official `@nx/dotnet` plugin.\n+\n+{% callout type=\"note\" title=\"Plugin Status\" %}\n+The `@nx-dotnet/core` plugin is deprecated in favor of the official `@nx/dotnet` plugin (available in Nx 22+), which is maintained by the Nx team and integrated directly into the Nx repository.\n+{% /callout %}\n+\n+## Why Migrate?\n+\n+The official `@nx/dotnet` plugin represents a natural evolution, building on lessons learned from the community plugin while embracing native .NET workflows:\n+\n+### Better Performance\n+\n+Significant performance improvements through efficient MSBuild analysis:\n+\n+- **Efficient dependency detection** using MSBuild APIs instead of repeated CLI calls\n+- **Smaller footprint** with minimal dependencies (2 packages vs 12+)\n+\n+### Simpler Architecture\n+\n+- **Embraces native .NET tooling**: Use `dotnet new`, `dotnet add`, etc. directly\n+- **Command-based targets**: Transparent `dotnet` commands instead of custom executors\n+- **Zero configuration**: Automatic project detection without custom config files\n+- **Minimal learning curve**: If you know the .NET CLI, you're already an expert\n+\n+### Production-Ready Support\n+\n+- **Official Nx support**: Maintained by the Nx core team\n+- **Always compatible**: Integrated into Nx releases, no version lag\n+- **MSBuild accuracy**: Uses Microsoft's official APIs for more accurate project analysis\n+- **Battle-tested**: Used in production Nx workspaces\n+\n+### Key Design Decisions\n+\n+The official plugin takes a streamlined approach:\n+\n+- **Project inference**: Automatic detection of .NET projects without configuration\n+- **MSBuild integration**: Direct use of Microsoft's APIs for accurate dependency analysis\n+- **Native CLI first**: Uses `dotnet` commands directly instead of custom wrappers\n+- **Minimal abstraction**: Simpler implementation with fewer dependencies\n+\n+This results in a faster, more reliable, and easier to maintain solution.\n+\n+## Prerequisites\n+\n+Before starting the migration:\n+\n+- [ ] Upgrade to **.NET SDK 8.0 or later** (required)\n+- [ ] Locate your current @nx-dotnet/core configuration (see below)\n+- [ ] Review any custom generators and executors you're using\n+- [ ] Ensure your projects build successfully with current setup\n+\n+### Locating Your Configuration\n+\n+The @nx-dotnet/core plugin configuration can be in one of two places:\n+\n+**Option 1: In `nx.json` (newer default)**\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx-dotnet/core\",\n+      \"options\": {\n+        \"inferredTargets\": { ... },\n+        \"solutionFile\": \"...\",\n+        // ... other options\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+**Option 2: In `.nx-dotnet.rc.json` (legacy)**\n+\n+```json\n+{\n+  \"inferredTargets\": { ... },\n+  \"solutionFile\": \"...\",\n+  // ... other options\n+}\n+```\n+\n+{% callout type=\"note\" title=\"No Configuration?\" %}\n+If you don't have custom configuration in either location, that's fine! The plugin works with defaults, and migration will be even simpler.\n+{% /callout %}\n+\n+## Migration Steps\n+\n+### 1. Install @nx/dotnet\n+\n+```shell {% frame=\"none\" %}\n+nx add @nx/dotnet\n+```\n+\n+This automatically:\n+\n+- Adds `@nx/dotnet` to `package.json`\n+- Registers the plugin in `nx.json`\n+- Configures `production` named inputs\n+- Updates `.gitignore`\n+\n+### 2. Remove @nx-dotnet/core\n+\n+```shell {% frame=\"none\" %}\n+npm uninstall @nx-dotnet/core @nx-dotnet/utils @nx-dotnet/dotnet\n+```\n+\n+Then clean up your configuration:\n+\n+- Remove `@nx-dotnet/core` from the `plugins` array in `nx.json` (if present)\n+- Delete `.nx-dotnet.rc.json` (if it exists)\n+\n+### 3. Migrate Plugin Configuration\n+\n+Move any customized target configurations from your @nx-dotnet/core config to the new @nx/dotnet plugin options.\n+\n+**Before** (in `nx.json` or `.nx-dotnet.rc.json`):\n+\n+```json\n+{\n+  \"inferredTargets\": {\n+    \"build\": \"build\",\n+    \"test\": {\n+      \"targetName\": \"test:dotnet\",\n+      \"cache\": false\n+    }\n+  }\n+}\n+```\n+\n+**After** (in `nx.json`):\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx/dotnet\",\n+      \"options\": {\n+        \"build\": {\n+          \"targetName\": \"build\"\n+        },\n+        \"test\": {\n+          \"targetName\": \"test:dotnet\"\n+        }\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+### 4. Clear Cache and Verify\n+\n+```shell {% frame=\"none\" %}\n+nx reset\n+nx graph\n+```\n+\n+The `nx graph` command should show all your .NET projects with their dependencies correctly detected.\n+\n+## Key Workflow Changes\n+\n+Here's what changes in your day-to-day development workflow:\n+\n+| Task                      | Old (@nx-dotnet/core)                                          | New (@nx/dotnet)                                |\n+| ------------------------- | -------------------------------------------------------------- | ----------------------------------------------- |\n+| **Create application**    | `nx g @nx-dotnet/core:app my-api`                              | `dotnet new webapi -n MyApi`                    |\n+| **Create library**        | `nx g @nx-dotnet/core:lib my-lib`                              | `dotnet new classlib -n MyLib`                  |\n+| **Add project reference** | `nx g @nx-dotnet/core:project-reference --source A --target B` | `dotnet add reference ../B/B.csproj`            |\n+| **Add NuGet package**     | `nx g @nx-dotnet/core:nuget-reference`                         | `dotnet add package PackageName`                |\n+| **Build project**         | `nx build my-api`                                              | `nx build my-api` \u2705 (same)                     |\n+| **Run tests**             | `nx test my-api`                                               | `nx test my-api` \u2705 (same)                      |\n+| **Serve/watch**           | `nx serve my-api`                                              | `dotnet watch run` (or configure custom target) |\n+\n+### Targets Generated\n+\n+The plugin automatically creates these targets for .NET projects:\n+\n+| Target    | When Created        | Command                                       |\n+| --------- | ------------------- | --------------------------------------------- |\n+| `build`   | All projects        | `dotnet build --no-restore --no-dependencies` |\n+| `test`    | Test projects only  | `dotnet test --no-build --no-restore`         |\n+| `restore` | All projects        | `dotnet restore`                              |\n+| `clean`   | All projects        | `dotnet clean`                                |\n+| `publish` | Executable projects | `dotnet publish`                              |\n+| `pack`    | Library projects    | `dotnet pack`                                 |\n+\n+{% callout type=\"note\" title=\"Missing Targets\" %}\n+The `serve` and `format` targets are not automatically created. `serve` defaults to a target named `watch` now. To run it, you'd need to run something like `nx watch my-api run` or `nx run my-api:watch run`. To configure the watch target to act like `serve`, you could set the following in `nx.json`:\n+\n+```json\n+{\n+  \"plugins\": [\n+    {\n+      \"plugin\": \"@nx/dotnet\",\n+      \"options\": {\n+        \"watch\": {\n+          \"targetName\": \"serve\",\n+          \"args\": [\"run\"]\n+        }\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+The `format` target is not present by default. You should add it as a custom target if desired.\n+\n+{% /callout %}\n+\n+## Advanced Migration Scenarios\n+\n+### Migrating from Explicit Executor Configurations\n+\n+If you have `project.json` files that explicitly configure @nx-dotnet/core executors, you'll need to update them to use command targets.\n+\n+**Before** (`project.json`):\n+\n+```json\n+{\n+  \"name\": \"my-api\",\n+  \"targets\": {\n+    \"build\": {\n+      \"executor\": \"@nx-dotnet/core:build\",\n+      \"options\": {\n+        \"configuration\": \"Release\",\n+        \"noDependencies\": true\n+      }\n+    },\n+    \"test\": {\n+      \"executor\": \"@nx-dotnet/core:test\",\n+      \"options\": {\n+        \"testProject\": \"MyApi.Tests.csproj\"\n+      }\n+    },\n+    \"serve\": {\n+      \"executor\": \"@nx-dotnet/core:serve\",\n+      \"options\": {\n+        \"project\": \"MyApi.csproj\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+**After** (`project.json`):\n+\n+```json\n+{\n+  \"name\": \"my-api\",\n+  \"targets\": {\n+    \"build\": {\n+      \"command\": \"dotnet build\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\",\n+        \"args\": [\"--configuration\", \"Release\", \"--no-dependencies\"]\n+      }\n+    },\n+    \"test\": {\n+      \"command\": \"dotnet test MyApi.Tests.csproj\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\"\n+      }\n+    },\n+    \"serve\": {\n+      \"command\": \"dotnet watch run\",\n+      \"options\": {\n+        \"cwd\": \"{projectRoot}\"\n+      }\n+    }\n+  }\n+}\n+```\n+\n+{% callout type=\"note\" title=\"Automatic Target Inference\" %}\n+In most cases, you can delete these `project.json` files entirely. The @nx/dotnet plugin will automatically infer the correct targets based on your `.csproj` files. Only keep custom `project.json` configurations if you need non-standard options.\n+{% /callout %}\n+\n+### Migrating from `inferProjects: false`\n+\n+If you previously set `inferProjects: false` in your @nx-dotnet/core config, this option no longer exists in @nx/dotnet. The new plugin **always** infers projects automatically.\n+\n+**Why this changed:**\n+\n+- Project inference is a core feature of how Nx plugins work\n+- Manual project management doesn't align with Nx's automatic detection model\n+- Maintaining explicit project configurations is error-prone\n+\n+**Migration path:**\n+\n+1. **If you disabled inference to exclude certain projects:**\n+\n+   - Use the `exclude` property in the plugin configuration:\n+     ```json\n+     {\n+       \"plugins\": [\n+         {\n+           \"plugin\": \"@nx/dotnet\",\n+           \"exclude\": [\"legacy-projects/**\", \"temp-projects/**\"]\n+         }\n+       ]\n+     }\n+     ```\n+\n+2. **If you disabled inference to use explicit project.json files:**\n+\n+   - The new plugin will still detect your projects via `.csproj` files\n+   - You can keep `project.json` files to customize targets, but they're optional\n+   - Consider removing them to use the automatically inferred targets\n+\n+3. **If you need to completely hide projects from Nx:**\n+   - Use the `exclude` property in the plugin configuration\n+   - Or move projects outside the workspace\n+\n+## Configuration Changes\n+\n+### Module Boundaries \u2192 Nx Conformance\n+\n+If you used `moduleBoundaries` in your @nx-dotnet/core config, you may want to migrate to [Nx Conformance rules](https://nx.dev/docs/enterprise/powerpack/conformance)\n+\n+The script used to evaluate module boundaries is missing several features from the eslint and conformance implementations, and is not present in the new plugin. If you wish to continue using it, you'll need to inline the implementation in your repository and update the path in `Directory.build.targets`. Otherwise, you should remove the target from `Directory.build.targets`.\n+\n+### NuGet Package Management\n+\n+Replace the `sync` generator with MSBuild's [Central Package Management](https://learn.microsoft.com/nuget/consume-packages/central-package-management).\n+\n+Create `Directory.Packages.props` at workspace root:\n+\n+```xml\n+<Project>\n+  <PropertyGroup>\n+    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>\n+  </PropertyGroup>\n+  <ItemGroup>\n+    <PackageVersion Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n+    <PackageVersion Include=\"Microsoft.Extensions.Logging\" Version=\"8.0.0\" />\n+  </ItemGroup>\n+</Project>\n+```\n+\n+Update project files to remove version attributes:\n+\n+```xml\n+<!-- Before -->\n+<PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\n+\n+<!-- After -->\n+<PackageReference Include=\"Newtonsoft.Json\" />",
        "comment_created_at": "2025-10-23T16:04:22+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "use diff code block\r\n````suggestion\r\n```diff {% lang=\"xml\" %}\r\n- <PackageReference Include=\"Newtonsoft.Json\" Version=\"13.0.3\" />\r\n+ <PackageReference Include=\"Newtonsoft.Json\" />\r\n````",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330454167",
    "pr_number": 32624,
    "pr_file": "astro-docs/src/content/docs/concepts/Module Federation/faster-builds.mdoc",
    "created_at": "2025-09-08T14:35:37+00:00",
    "commented_code": "In the future, Nx may automatically handle this for you.\n \n-### `apps/host/webpack.config.ts`\n+### React: `apps/host/rspack.config.js`\n+\n+With React, we use Rspack by default and generate a compliant Rspack configuration file:\n+\n+```javascript\n+import { NxAppRspackPlugin } from '@nx/rspack/app-plugin.js';\n+import { NxReactRspackPlugin } from '@nx/rspack/react-plugin.js';\n+import {\n+   NxModuleFederationPlugin,\n+   NxModuleFederationDevServerPlugin,\n+} from '@nx/module-federation/rspack.js';\n+import { join } from 'path';\n+\n+import config from './module-federation.config';\n+\n+export default {\n+   output: {\n+       path: join(__dirname, '../../dist/apps/host'),\n+       publicPath: 'auto',\n+   },\n+   devServer: {\n+       port: 4200,\n+       historyApiFallback: {\n+           index: '/index.html',\n+           disableDotRule: true,\n+           htmlAcceptHeaders: ['text/html', 'application/xhtml+xml'],\n+       },\n+   },\n+   plugins: [\n+       new NxAppRspackPlugin({\n+           tsConfig: './tsconfig.app.json',\n+           main: './src/main.ts',\n+           index: './src/index.html',\n+           baseHref: '/',\n+           assets: ['./src/favicon.ico', './src/assets'],\n+           styles: ['./src/styles.css'],\n+           outputHashing: process.env['NODE_ENV'] === 'production' ? 'all' : 'none',\n+           optimization: process.env['NODE_ENV'] === 'production',\n+       }),\n+       new NxReactRspackPlugin({\n+           // Uncomment this line if you don't want to use SVGR\n+           // See: https://react-svgr.com/\n+           // svgr: false\n+       }),\n+       new NxModuleFederationPlugin({ config }, { dts: false }),\n+       new NxModuleFederationDevServerPlugin({ config }),\n+   ],\n+};\n+\n+```\n+\n+### Angular: `apps/host/webpack.config.ts`\n \n The webpack configuration uses an utility function that Nx provides: `withModuleFederation`.\n \n ```javascript",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2330454167",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32624,
        "pr_file": "astro-docs/src/content/docs/concepts/Module Federation/faster-builds.mdoc",
        "discussion_id": "2330454167",
        "commented_code": "@@ -175,13 +181,63 @@ the `implicitDependencies` configuration.\n \n In the future, Nx may automatically handle this for you.\n \n-### `apps/host/webpack.config.ts`\n+### React: `apps/host/rspack.config.js`\n+\n+With React, we use Rspack by default and generate a compliant Rspack configuration file:\n+\n+```javascript\n+import { NxAppRspackPlugin } from '@nx/rspack/app-plugin.js';\n+import { NxReactRspackPlugin } from '@nx/rspack/react-plugin.js';\n+import {\n+   NxModuleFederationPlugin,\n+   NxModuleFederationDevServerPlugin,\n+} from '@nx/module-federation/rspack.js';\n+import { join } from 'path';\n+\n+import config from './module-federation.config';\n+\n+export default {\n+   output: {\n+       path: join(__dirname, '../../dist/apps/host'),\n+       publicPath: 'auto',\n+   },\n+   devServer: {\n+       port: 4200,\n+       historyApiFallback: {\n+           index: '/index.html',\n+           disableDotRule: true,\n+           htmlAcceptHeaders: ['text/html', 'application/xhtml+xml'],\n+       },\n+   },\n+   plugins: [\n+       new NxAppRspackPlugin({\n+           tsConfig: './tsconfig.app.json',\n+           main: './src/main.ts',\n+           index: './src/index.html',\n+           baseHref: '/',\n+           assets: ['./src/favicon.ico', './src/assets'],\n+           styles: ['./src/styles.css'],\n+           outputHashing: process.env['NODE_ENV'] === 'production' ? 'all' : 'none',\n+           optimization: process.env['NODE_ENV'] === 'production',\n+       }),\n+       new NxReactRspackPlugin({\n+           // Uncomment this line if you don't want to use SVGR\n+           // See: https://react-svgr.com/\n+           // svgr: false\n+       }),\n+       new NxModuleFederationPlugin({ config }, { dts: false }),\n+       new NxModuleFederationDevServerPlugin({ config }),\n+   ],\n+};\n+\n+```\n+\n+### Angular: `apps/host/webpack.config.ts`\n \n The webpack configuration uses an utility function that Nx provides: `withModuleFederation`.\n \n ```javascript",
        "comment_created_at": "2025-09-08T14:35:37+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "adding filename to code block\r\n```suggestion\r\n```javascript\r\n// apps/host/webpack.config.ts\r\n```",
        "pr_file_module": null
      }
    ]
  }
]