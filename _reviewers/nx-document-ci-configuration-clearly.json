[
  {
    "discussion_id": "2399236561",
    "pr_number": 32916,
    "pr_file": "astro-docs/src/content/docs/features/CI Features/self-healing-ci.mdoc",
    "created_at": "2025-10-02T15:33:04+00:00",
    "commented_code": "### Configure your CI pipeline\n \n-**Using [Nx Agents](/docs/features/ci-features/distribute-task-execution):** There's nothing to be done. You're already good to go.\n+To enable Self-Healing CI, add the following lines to your CI configuration:\n \n-**Not using Nx Agents:** Add the `fix-ci` step to your pipeline. Important: this step must run at the end with `if: always()` to ensure it executes even when previous steps fail:\n-\n-```yaml {% meta=\"{11,12}\" %}\n-// .github/workflows/ci.yml\"\n+```yaml {% meta=\"{10,14,15}\" %}\n+# .github/workflows/ci.yml\n name: CI\n \n jobs:\n   main:\n     runs-on: ubuntu-latest\n     steps:\n+      ...\n+      - name: Start CI Run\n+      - run: npx nx-cloud start-ci-run --no-distribution\n       ...\n       - run: npx nx affected -t lint test build\n \n       - run: npx nx-cloud fix-ci\n         if: always()\n ```\n \n+If you're already using [Nx Agents](/docs/features/ci-features/distribute-task-execution), then you can omit the `--no-distribution` flag and just use your usual Nx Agents configuration.",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2399236561",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32916,
        "pr_file": "astro-docs/src/content/docs/features/CI Features/self-healing-ci.mdoc",
        "discussion_id": "2399236561",
        "commented_code": "@@ -36,25 +36,71 @@ Next, check the Nx Cloud workspace settings in the Nx Cloud web application to e\n \n ### Configure your CI pipeline\n \n-**Using [Nx Agents](/docs/features/ci-features/distribute-task-execution):** There's nothing to be done. You're already good to go.\n+To enable Self-Healing CI, add the following lines to your CI configuration:\n \n-**Not using Nx Agents:** Add the `fix-ci` step to your pipeline. Important: this step must run at the end with `if: always()` to ensure it executes even when previous steps fail:\n-\n-```yaml {% meta=\"{11,12}\" %}\n-// .github/workflows/ci.yml\"\n+```yaml {% meta=\"{10,14,15}\" %}\n+# .github/workflows/ci.yml\n name: CI\n \n jobs:\n   main:\n     runs-on: ubuntu-latest\n     steps:\n+      ...\n+      - name: Start CI Run\n+      - run: npx nx-cloud start-ci-run --no-distribution\n       ...\n       - run: npx nx affected -t lint test build\n \n       - run: npx nx-cloud fix-ci\n         if: always()\n ```\n \n+If you're already using [Nx Agents](/docs/features/ci-features/distribute-task-execution), then you can omit the `--no-distribution` flag and just use your usual Nx Agents configuration.",
        "comment_created_at": "2025-10-02T15:33:04+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "```suggestion\r\nIf you're already using [Nx Agents](/docs/features/ci-features/distribute-task-execution), then you can omit the `--no-distribution` flag and use your existing Nx Agents configuration.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330460701",
    "pr_number": 32624,
    "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
    "created_at": "2025-09-08T14:37:45+00:00",
    "commented_code": "The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript\n+export default {\n+    remotes: ['shop', 'cart']\n+}\n+```\n+\n+These names match the names of the projects in the workspace. Therefore, Nx can find them in the project graph and determine the information it needs.\n+This usually amounts to Nx creating the following URLs:\n+\n+```shell {% frame=\"none\" %}\n+shop@localhost:4201\n+cart@localhost:4202\n+```\n+\n+When it comes deployment to a real server, you'll need to configure the URLs to point to their real location. For example, if you deploy the host and the remotes to three servers, each with their own domain, you'd need to configure that:\n+```shell {% frame=\"none\" %}\n+shop@https://shop.example.com\n+cart@https://cart.example.com\n+```\n+\n+The `remotes` option in the `module-federation.config.ts` file allows you to do this:\n+\n+```javascript",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2330460701",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32624,
        "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
        "discussion_id": "2330460701",
        "commented_code": "@@ -54,6 +54,81 @@ You can learn more about this experience in the [Module Federation Technical Ove\n \n The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript\n+export default {\n+    remotes: ['shop', 'cart']\n+}\n+```\n+\n+These names match the names of the projects in the workspace. Therefore, Nx can find them in the project graph and determine the information it needs.\n+This usually amounts to Nx creating the following URLs:\n+\n+```shell {% frame=\"none\" %}\n+shop@localhost:4201\n+cart@localhost:4202\n+```\n+\n+When it comes deployment to a real server, you'll need to configure the URLs to point to their real location. For example, if you deploy the host and the remotes to three servers, each with their own domain, you'd need to configure that:\n+```shell {% frame=\"none\" %}\n+shop@https://shop.example.com\n+cart@https://cart.example.com\n+```\n+\n+The `remotes` option in the `module-federation.config.ts` file allows you to do this:\n+\n+```javascript",
        "comment_created_at": "2025-09-08T14:37:45+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "```suggestion\r\n```javascript\r\n// module-federation.config.ts\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330461394",
    "pr_number": 32624,
    "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
    "created_at": "2025-09-08T14:37:59+00:00",
    "commented_code": "The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2330461394",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32624,
        "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
        "discussion_id": "2330461394",
        "commented_code": "@@ -54,6 +54,81 @@ You can learn more about this experience in the [Module Federation Technical Ove\n \n The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript",
        "comment_created_at": "2025-09-08T14:37:59+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "```suggestion\r\n```javascript\r\n// module-federation.config.ts\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2330462312",
    "pr_number": 32624,
    "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
    "created_at": "2025-09-08T14:38:18+00:00",
    "commented_code": "The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript\n+export default {\n+    remotes: ['shop', 'cart']\n+}\n+```\n+\n+These names match the names of the projects in the workspace. Therefore, Nx can find them in the project graph and determine the information it needs.\n+This usually amounts to Nx creating the following URLs:\n+\n+```shell {% frame=\"none\" %}\n+shop@localhost:4201\n+cart@localhost:4202\n+```\n+\n+When it comes deployment to a real server, you'll need to configure the URLs to point to their real location. For example, if you deploy the host and the remotes to three servers, each with their own domain, you'd need to configure that:\n+```shell {% frame=\"none\" %}\n+shop@https://shop.example.com\n+cart@https://cart.example.com\n+```\n+\n+The `remotes` option in the `module-federation.config.ts` file allows you to do this:\n+\n+```javascript\n+export default {\n+    remotes: [\n+        ['shop', 'https://shop.example.com'],\n+        ['cart', 'https://cart.example.com'],\n+    ]\n+}\n+```\n+\n+However, once you make this change, it will no longer work locally.\n+You need some mechanism to change the URLs when you're building for a production environment.\n+\n+A simple way to achieve this could be to use an environment variable:\n+\n+```javascript",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2330462312",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32624,
        "pr_file": "astro-docs/src/content/docs/technologies/module-federation/Guides/nx-module-federation-dev-server-plugin.mdoc",
        "discussion_id": "2330462312",
        "commented_code": "@@ -54,6 +54,81 @@ You can learn more about this experience in the [Module Federation Technical Ove\n \n The key difference between `NxModuleFederationDevServerPlugin` and `NxModuleFederationSSRDevServerPlugin` is that the latter will handle both `browser` and `server` bundles to support Server Side Rendering (SSR). It will also serve the host/consumer application by forking ([child_process.fork](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)) the `server.js` output from the `server` bundle of the host application.\n \n+## Deployment\n+\n+How applications are deployed depends on the teams and organizational requirements. There are two approaches:\n+\n+1. \u00c0 la carte deployments - Each application is deployed according to a release schedule, and can have different cadences.\n+2. Affected deployments - When changes are merged, use Nx to test and deploy the affected applications automatically.\n+\n+Often times, teams mix both approaches so deployments to staging (or other shared environments) are automatic. Then,\n+promotion from staging to production occurs on a set cadence (e.g. weekly releases). It is also recommended to agree on\n+a process to handle changes to core libraries (i.e. ones that are shared between applications). Since the core changes\n+affect all applications, it also blocks all other releases, thus should not occur too frequently.\n+\n+You may also choose to fully automate deployments, even to production. This type of pipeline requires good end-to-end\n+testing to provide higher confidence that the applications behave correctly. You will also need good rollback mechanisms\n+in case of a bad deployment.\n+\n+When figuring out the best deployment strategy, or even how to achieve it with Module Federation and Nx, it is worth understanding what is happening under-the-hood.\n+Each host and remote in your Module Federation system is treated like a separate application. However, when a remote is loaded into a host via Module Federation, Module Federation itself does not make any kind of distinguishment.\n+It only cares that the JS file it is trying to load is available at the pre-specified URL, such that it can make a network request to fetch the JS file.\n+\n+When working locally, Nx parses the config in `module-federation.config.ts` to determine what projects in the workspace are federated. It then reads the project graph for these projects to determine what port they will be served on and uses this information to form a URL to tell Module Federation where it will find the remote JS files.\n+You'll commonly see the following configuration in your `module-federation.config.ts`:\n+\n+```javascript\n+export default {\n+    remotes: ['shop', 'cart']\n+}\n+```\n+\n+These names match the names of the projects in the workspace. Therefore, Nx can find them in the project graph and determine the information it needs.\n+This usually amounts to Nx creating the following URLs:\n+\n+```shell {% frame=\"none\" %}\n+shop@localhost:4201\n+cart@localhost:4202\n+```\n+\n+When it comes deployment to a real server, you'll need to configure the URLs to point to their real location. For example, if you deploy the host and the remotes to three servers, each with their own domain, you'd need to configure that:\n+```shell {% frame=\"none\" %}\n+shop@https://shop.example.com\n+cart@https://cart.example.com\n+```\n+\n+The `remotes` option in the `module-federation.config.ts` file allows you to do this:\n+\n+```javascript\n+export default {\n+    remotes: [\n+        ['shop', 'https://shop.example.com'],\n+        ['cart', 'https://cart.example.com'],\n+    ]\n+}\n+```\n+\n+However, once you make this change, it will no longer work locally.\n+You need some mechanism to change the URLs when you're building for a production environment.\n+\n+A simple way to achieve this could be to use an environment variable:\n+\n+```javascript",
        "comment_created_at": "2025-09-08T14:38:18+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "```suggestion\r\n```javascript\r\n// module-federation.config.ts\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072415895",
    "pr_number": 31018,
    "pr_file": "packages/workspace/src/generators/ci-workflow/files/github/.github/workflows/__workflowFileName__.yml__tmpl__",
    "created_at": "2025-05-03T15:31:50+00:00",
    "commented_code": "with:\n           filter: tree:0\n           fetch-depth: 0\n-\n-      <% if(packageManager == 'pnpm'){ %>\n-      - uses: pnpm/action-setup@v4",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2072415895",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31018,
        "pr_file": "packages/workspace/src/generators/ci-workflow/files/github/.github/workflows/__workflowFileName__.yml__tmpl__",
        "discussion_id": "2072415895",
        "commented_code": "@@ -18,16 +18,26 @@ jobs:\n         with:\n           filter: tree:0\n           fetch-depth: 0\n-\n-      <% if(packageManager == 'pnpm'){ %>\n-      - uses: pnpm/action-setup@v4",
        "comment_created_at": "2025-05-03T15:31:50+00:00",
        "comment_author": "FrozenPandaz",
        "comment_body": "pnpm still recommends using their action to setup so I think we should keep this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072416564",
    "pr_number": 31018,
    "pr_file": "packages/workspace/src/generators/ci-workflow/__snapshots__/ci-workflow.spec.ts.snap",
    "created_at": "2025-05-03T15:37:03+00:00",
    "commented_code": "filter: tree:0\n           fetch-depth: 0\n \n-      - uses: pnpm/action-setup@v4\n+      # Cache node_modules",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2072416564",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31018,
        "pr_file": "packages/workspace/src/generators/ci-workflow/__snapshots__/ci-workflow.spec.ts.snap",
        "discussion_id": "2072416564",
        "commented_code": "@@ -1006,22 +1024,20 @@ jobs:\n           filter: tree:0\n           fetch-depth: 0\n \n-      - uses: pnpm/action-setup@v4\n+      # Cache node_modules",
        "comment_created_at": "2025-05-03T15:37:03+00:00",
        "comment_author": "FrozenPandaz",
        "comment_body": "The order should not have changed here and we should continue using the pnpm setup action since that's what they still recommend on the docs.",
        "pr_file_module": null
      }
    ]
  }
]