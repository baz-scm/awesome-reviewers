[
  {
    "discussion_id": "2421350941",
    "pr_number": 33042,
    "pr_file": "docs/blog/2025-10-14-whats-new-in-nx-self-healing-ci.md",
    "created_at": "2025-10-10T17:25:14+00:00",
    "commented_code": "+---\n+title: \"What's New in Nx Self-Healing CI\"\n+slug: 'whats-new-in-nx-self-healing-ci'\n+authors: ['Juri Strumpflohner']\n+tags: [nx, nx-cloud, release]\n+cover_image: /blog/images/articles/self-healing-ci-update-blog-hero.avif\n+description: 'Enhanced GitHub integration, interactive diffs, fine-grained task control, auto-apply fixes, and local fix application\u2014discover the latest improvements to Nx Self-Healing CI.'\n+---\n+\n+AI agents and AI-assisted coding are here to stay. Our mission: integrate it with Nx such that it's actually useful for day-to-day developer work. We've been heads-down fine-tuning [Self-Healing CI](/docs/features/ci-features/self-healing-ci), improving its correctness and making sure it shows up when it should without being annoying.\n+\n+So let me take this occasion to highlight a few things we shipped in the last weeks.\n+\n+## Enhanced GitHub Integration\n+\n+We built a dedicated view into [Nx Console](/docs/getting-started/editor-setup) to surface Self-Healing fixes directly in your editor. But sometimes you're jumping straight to GitHub (or whatever VCS you're using) to quickly check your open PRs and see if there's anything new.\n+\n+We improved the way we integrate into your GitHub PRs by posting a dedicated comment whenever Self-Healing CI finds a fix for a broken CI run:\n+\n+![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)\n+\n+It shows:\n+\n+- A summary of the reasoning behind the fix\n+- A diff view with the changes\n+\n+You then have 2 buttons for directly applying or rejecting the fix, as well as two less prominent actions for applying the fix locally (more below) and viewing the diff in Nx Cloud for a richer interactive diff experience.\n+\n+Why a comment? Self-Healing goes beyond just commenting on changed files in the PR. You might change an implementation and Self-Healing might adjust your spec files because you forgot to update those as well. So we cannot use review APIs (from GitHub, for example) as common code reviewing tools do.\n+\n+> **GitLab support is coming.** We already have a working version and are about to release it soon.\n+\n+## Redesigned Interactive Diff in Nx Cloud\n+\n+We also completely redesigned the Self-Healing CI view in the Nx Cloud application, making it more compact and easier to parse the most important information together with a richer, GitHub-like interactive diff viewer:\n+\n+![Self-Healing CI Interactive Diff](/blog/images/articles/self-healing-nx-cloud-diff-dark.avif)\n+\n+You can reach this page directly via the Nx Cloud run page whenever an AI fix is available, as well as via the dedicated Self-Healing CI GitHub comment (as discussed in the previous section).\n+\n+## Fine-Grained Control with `--fix-tasks`\n+\n+{% youtube src=\"https://youtu.be/KSb48zHbaHg\" /%}\n+\n+Not all tasks need self-healing. You can now specify exactly which tasks should be considered for automatic fixing using the `--fix-tasks` flag:\n+\n+**Only fix specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"*lint*,*format*\"\n+```\n+\n+**Exclude specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"!*deploy*,!*test*\"\n+```\n+\n+Tasks are matched using glob patterns in the format `<project>:<task>:<configuration>`, giving you fine-grained control. Commands recorded with `nx-cloud record --` are matched by their full command string (e.g., `nx-cloud record -- nx format`).\n+\n+## YOLO Mode: Auto-Apply Fixes with `--auto-apply-fixes`\n+\n+{% youtube src=\"https://youtu.be/EmZcENiCG64\" /%}\n+\n+By default, Self-Healing CI identifies broken tasks, leverages AI to develop a fix, and proposes it for approval. You're in the loop to apply, reject, or refine it.\n+\n+For some simpler tasks though, you might not even want to be bothered\u2014like formatting or linting issues, for example.\n+\n+You can now use the `--auto-apply-fixes` flag to control which tasks are eligible for being auto-applied:\n+\n+```shell\n+npx nx start-ci-run --auto-apply-fixes=\"*format*,*lint*\"\n+```\n+\n+**How it works:**\n+\n+1. AI generates a fix for the failed task\n+2. Nx Cloud runs a **verification phase** in the background to ensure the fix passes CI\n+3. If verification succeeds, the fix is **automatically pushed to your PR**\u2014no manual approval needed\n+4. If you have [Nx Console](/docs/getting-started/editor-setup), you'll get a notification that a commit has been added\n+\n+You can continue working on other things while the AI handles the fix in the background. Just pull the changes when you're ready.\n+\n+**Important:** Auto-fixes are only applied after the verification phase passes, ensuring the proposed change actually solves the problem.\n+\n+## Apply Fixes Locally for Fine-Tuning\n+\n+{% youtube src=\"https://youtu.be/37q9O-PYPlY\" /%}\n+\n+Sometimes you see a fix that's 90% there, so you can't quite approve and apply it right away\u2014you need to tweak it slightly first.\n+\n+For this, we added the ability to apply changes locally. You'll see instructions in the GitHub comment, in Nx Console, and in the Nx Cloud application. What we give you is a command you can run directly in your editor.\n+\n+![Apply Self-Healing Fixes Locally](/blog/images/articles/self-healing-apply-locally.avif)\n+\n+If you're currently on a different branch (e.g., `main`), Nx Cloud will detect the correct branch for your PR and offer to check it out automatically before applying the fix.\n+\n+## Reverting Applied Fixes\n+\n+If you accidentally applied a Self-Healing CI fix to your PR, you can easily undo it by manually reverting the Git commit. For convenience, we also added a \"Revert changes\" action to the Self-Healing CI diff viewer in the Nx Cloud application.\n+\n+![Revert Self-Healing CI Changes](/blog/images/articles/self-healing-ci-revert-changes.png)\n+\n+Just follow the Nx Cloud GitHub comment on your PR to reach this screen.\n+\n+## Wrapping Up\n+\n+You can try Self-Healing CI yourself easily by:\n+\n+1. Connecting your Nx workspace to Nx Cloud: `npx nx@latest connect`\n+2. Updating your CI config:\n+\n+```yaml\n+name: CI\n+\n+jobs:\n+  main:\n+    runs-on: ubuntu-latest\n+    steps:\n+      ...\n+      - name: Start CI Run\n+      - run: npx nx start-ci-run --no-distribution",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2421350941",
        "repo_full_name": "nrwl/nx",
        "pr_number": 33042,
        "pr_file": "docs/blog/2025-10-14-whats-new-in-nx-self-healing-ci.md",
        "discussion_id": "2421350941",
        "commented_code": "@@ -0,0 +1,132 @@\n+---\n+title: \"What's New in Nx Self-Healing CI\"\n+slug: 'whats-new-in-nx-self-healing-ci'\n+authors: ['Juri Strumpflohner']\n+tags: [nx, nx-cloud, release]\n+cover_image: /blog/images/articles/self-healing-ci-update-blog-hero.avif\n+description: 'Enhanced GitHub integration, interactive diffs, fine-grained task control, auto-apply fixes, and local fix application\u2014discover the latest improvements to Nx Self-Healing CI.'\n+---\n+\n+AI agents and AI-assisted coding are here to stay. Our mission: integrate it with Nx such that it's actually useful for day-to-day developer work. We've been heads-down fine-tuning [Self-Healing CI](/docs/features/ci-features/self-healing-ci), improving its correctness and making sure it shows up when it should without being annoying.\n+\n+So let me take this occasion to highlight a few things we shipped in the last weeks.\n+\n+## Enhanced GitHub Integration\n+\n+We built a dedicated view into [Nx Console](/docs/getting-started/editor-setup) to surface Self-Healing fixes directly in your editor. But sometimes you're jumping straight to GitHub (or whatever VCS you're using) to quickly check your open PRs and see if there's anything new.\n+\n+We improved the way we integrate into your GitHub PRs by posting a dedicated comment whenever Self-Healing CI finds a fix for a broken CI run:\n+\n+![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)\n+\n+It shows:\n+\n+- A summary of the reasoning behind the fix\n+- A diff view with the changes\n+\n+You then have 2 buttons for directly applying or rejecting the fix, as well as two less prominent actions for applying the fix locally (more below) and viewing the diff in Nx Cloud for a richer interactive diff experience.\n+\n+Why a comment? Self-Healing goes beyond just commenting on changed files in the PR. You might change an implementation and Self-Healing might adjust your spec files because you forgot to update those as well. So we cannot use review APIs (from GitHub, for example) as common code reviewing tools do.\n+\n+> **GitLab support is coming.** We already have a working version and are about to release it soon.\n+\n+## Redesigned Interactive Diff in Nx Cloud\n+\n+We also completely redesigned the Self-Healing CI view in the Nx Cloud application, making it more compact and easier to parse the most important information together with a richer, GitHub-like interactive diff viewer:\n+\n+![Self-Healing CI Interactive Diff](/blog/images/articles/self-healing-nx-cloud-diff-dark.avif)\n+\n+You can reach this page directly via the Nx Cloud run page whenever an AI fix is available, as well as via the dedicated Self-Healing CI GitHub comment (as discussed in the previous section).\n+\n+## Fine-Grained Control with `--fix-tasks`\n+\n+{% youtube src=\"https://youtu.be/KSb48zHbaHg\" /%}\n+\n+Not all tasks need self-healing. You can now specify exactly which tasks should be considered for automatic fixing using the `--fix-tasks` flag:\n+\n+**Only fix specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"*lint*,*format*\"\n+```\n+\n+**Exclude specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"!*deploy*,!*test*\"\n+```\n+\n+Tasks are matched using glob patterns in the format `<project>:<task>:<configuration>`, giving you fine-grained control. Commands recorded with `nx-cloud record --` are matched by their full command string (e.g., `nx-cloud record -- nx format`).\n+\n+## YOLO Mode: Auto-Apply Fixes with `--auto-apply-fixes`\n+\n+{% youtube src=\"https://youtu.be/EmZcENiCG64\" /%}\n+\n+By default, Self-Healing CI identifies broken tasks, leverages AI to develop a fix, and proposes it for approval. You're in the loop to apply, reject, or refine it.\n+\n+For some simpler tasks though, you might not even want to be bothered\u2014like formatting or linting issues, for example.\n+\n+You can now use the `--auto-apply-fixes` flag to control which tasks are eligible for being auto-applied:\n+\n+```shell\n+npx nx start-ci-run --auto-apply-fixes=\"*format*,*lint*\"\n+```\n+\n+**How it works:**\n+\n+1. AI generates a fix for the failed task\n+2. Nx Cloud runs a **verification phase** in the background to ensure the fix passes CI\n+3. If verification succeeds, the fix is **automatically pushed to your PR**\u2014no manual approval needed\n+4. If you have [Nx Console](/docs/getting-started/editor-setup), you'll get a notification that a commit has been added\n+\n+You can continue working on other things while the AI handles the fix in the background. Just pull the changes when you're ready.\n+\n+**Important:** Auto-fixes are only applied after the verification phase passes, ensuring the proposed change actually solves the problem.\n+\n+## Apply Fixes Locally for Fine-Tuning\n+\n+{% youtube src=\"https://youtu.be/37q9O-PYPlY\" /%}\n+\n+Sometimes you see a fix that's 90% there, so you can't quite approve and apply it right away\u2014you need to tweak it slightly first.\n+\n+For this, we added the ability to apply changes locally. You'll see instructions in the GitHub comment, in Nx Console, and in the Nx Cloud application. What we give you is a command you can run directly in your editor.\n+\n+![Apply Self-Healing Fixes Locally](/blog/images/articles/self-healing-apply-locally.avif)\n+\n+If you're currently on a different branch (e.g., `main`), Nx Cloud will detect the correct branch for your PR and offer to check it out automatically before applying the fix.\n+\n+## Reverting Applied Fixes\n+\n+If you accidentally applied a Self-Healing CI fix to your PR, you can easily undo it by manually reverting the Git commit. For convenience, we also added a \"Revert changes\" action to the Self-Healing CI diff viewer in the Nx Cloud application.\n+\n+![Revert Self-Healing CI Changes](/blog/images/articles/self-healing-ci-revert-changes.png)\n+\n+Just follow the Nx Cloud GitHub comment on your PR to reach this screen.\n+\n+## Wrapping Up\n+\n+You can try Self-Healing CI yourself easily by:\n+\n+1. Connecting your Nx workspace to Nx Cloud: `npx nx@latest connect`\n+2. Updating your CI config:\n+\n+```yaml\n+name: CI\n+\n+jobs:\n+  main:\n+    runs-on: ubuntu-latest\n+    steps:\n+      ...\n+      - name: Start CI Run\n+      - run: npx nx start-ci-run --no-distribution",
        "comment_created_at": "2025-10-10T17:25:14+00:00",
        "comment_author": "philipjfulcher",
        "comment_body": "Why the `--no-distribution` flag here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2425420146",
        "repo_full_name": "nrwl/nx",
        "pr_number": 33042,
        "pr_file": "docs/blog/2025-10-14-whats-new-in-nx-self-healing-ci.md",
        "discussion_id": "2421350941",
        "commented_code": "@@ -0,0 +1,132 @@\n+---\n+title: \"What's New in Nx Self-Healing CI\"\n+slug: 'whats-new-in-nx-self-healing-ci'\n+authors: ['Juri Strumpflohner']\n+tags: [nx, nx-cloud, release]\n+cover_image: /blog/images/articles/self-healing-ci-update-blog-hero.avif\n+description: 'Enhanced GitHub integration, interactive diffs, fine-grained task control, auto-apply fixes, and local fix application\u2014discover the latest improvements to Nx Self-Healing CI.'\n+---\n+\n+AI agents and AI-assisted coding are here to stay. Our mission: integrate it with Nx such that it's actually useful for day-to-day developer work. We've been heads-down fine-tuning [Self-Healing CI](/docs/features/ci-features/self-healing-ci), improving its correctness and making sure it shows up when it should without being annoying.\n+\n+So let me take this occasion to highlight a few things we shipped in the last weeks.\n+\n+## Enhanced GitHub Integration\n+\n+We built a dedicated view into [Nx Console](/docs/getting-started/editor-setup) to surface Self-Healing fixes directly in your editor. But sometimes you're jumping straight to GitHub (or whatever VCS you're using) to quickly check your open PRs and see if there's anything new.\n+\n+We improved the way we integrate into your GitHub PRs by posting a dedicated comment whenever Self-Healing CI finds a fix for a broken CI run:\n+\n+![Self-Healing CI GitHub Comment](/blog/images/articles/self-healing-ghcomment-dark.avif)\n+\n+It shows:\n+\n+- A summary of the reasoning behind the fix\n+- A diff view with the changes\n+\n+You then have 2 buttons for directly applying or rejecting the fix, as well as two less prominent actions for applying the fix locally (more below) and viewing the diff in Nx Cloud for a richer interactive diff experience.\n+\n+Why a comment? Self-Healing goes beyond just commenting on changed files in the PR. You might change an implementation and Self-Healing might adjust your spec files because you forgot to update those as well. So we cannot use review APIs (from GitHub, for example) as common code reviewing tools do.\n+\n+> **GitLab support is coming.** We already have a working version and are about to release it soon.\n+\n+## Redesigned Interactive Diff in Nx Cloud\n+\n+We also completely redesigned the Self-Healing CI view in the Nx Cloud application, making it more compact and easier to parse the most important information together with a richer, GitHub-like interactive diff viewer:\n+\n+![Self-Healing CI Interactive Diff](/blog/images/articles/self-healing-nx-cloud-diff-dark.avif)\n+\n+You can reach this page directly via the Nx Cloud run page whenever an AI fix is available, as well as via the dedicated Self-Healing CI GitHub comment (as discussed in the previous section).\n+\n+## Fine-Grained Control with `--fix-tasks`\n+\n+{% youtube src=\"https://youtu.be/KSb48zHbaHg\" /%}\n+\n+Not all tasks need self-healing. You can now specify exactly which tasks should be considered for automatic fixing using the `--fix-tasks` flag:\n+\n+**Only fix specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"*lint*,*format*\"\n+```\n+\n+**Exclude specific tasks:**\n+\n+```shell\n+npx nx start-ci-run --fix-tasks=\"!*deploy*,!*test*\"\n+```\n+\n+Tasks are matched using glob patterns in the format `<project>:<task>:<configuration>`, giving you fine-grained control. Commands recorded with `nx-cloud record --` are matched by their full command string (e.g., `nx-cloud record -- nx format`).\n+\n+## YOLO Mode: Auto-Apply Fixes with `--auto-apply-fixes`\n+\n+{% youtube src=\"https://youtu.be/EmZcENiCG64\" /%}\n+\n+By default, Self-Healing CI identifies broken tasks, leverages AI to develop a fix, and proposes it for approval. You're in the loop to apply, reject, or refine it.\n+\n+For some simpler tasks though, you might not even want to be bothered\u2014like formatting or linting issues, for example.\n+\n+You can now use the `--auto-apply-fixes` flag to control which tasks are eligible for being auto-applied:\n+\n+```shell\n+npx nx start-ci-run --auto-apply-fixes=\"*format*,*lint*\"\n+```\n+\n+**How it works:**\n+\n+1. AI generates a fix for the failed task\n+2. Nx Cloud runs a **verification phase** in the background to ensure the fix passes CI\n+3. If verification succeeds, the fix is **automatically pushed to your PR**\u2014no manual approval needed\n+4. If you have [Nx Console](/docs/getting-started/editor-setup), you'll get a notification that a commit has been added\n+\n+You can continue working on other things while the AI handles the fix in the background. Just pull the changes when you're ready.\n+\n+**Important:** Auto-fixes are only applied after the verification phase passes, ensuring the proposed change actually solves the problem.\n+\n+## Apply Fixes Locally for Fine-Tuning\n+\n+{% youtube src=\"https://youtu.be/37q9O-PYPlY\" /%}\n+\n+Sometimes you see a fix that's 90% there, so you can't quite approve and apply it right away\u2014you need to tweak it slightly first.\n+\n+For this, we added the ability to apply changes locally. You'll see instructions in the GitHub comment, in Nx Console, and in the Nx Cloud application. What we give you is a command you can run directly in your editor.\n+\n+![Apply Self-Healing Fixes Locally](/blog/images/articles/self-healing-apply-locally.avif)\n+\n+If you're currently on a different branch (e.g., `main`), Nx Cloud will detect the correct branch for your PR and offer to check it out automatically before applying the fix.\n+\n+## Reverting Applied Fixes\n+\n+If you accidentally applied a Self-Healing CI fix to your PR, you can easily undo it by manually reverting the Git commit. For convenience, we also added a \"Revert changes\" action to the Self-Healing CI diff viewer in the Nx Cloud application.\n+\n+![Revert Self-Healing CI Changes](/blog/images/articles/self-healing-ci-revert-changes.png)\n+\n+Just follow the Nx Cloud GitHub comment on your PR to reach this screen.\n+\n+## Wrapping Up\n+\n+You can try Self-Healing CI yourself easily by:\n+\n+1. Connecting your Nx workspace to Nx Cloud: `npx nx@latest connect`\n+2. Updating your CI config:\n+\n+```yaml\n+name: CI\n+\n+jobs:\n+  main:\n+    runs-on: ubuntu-latest\n+    steps:\n+      ...\n+      - name: Start CI Run\n+      - run: npx nx start-ci-run --no-distribution",
        "comment_created_at": "2025-10-13T07:24:47+00:00",
        "comment_author": "juristr",
        "comment_body": "Because otherwise you need to configure the full Nx agents setup, like `--distribute-on...`. It wouldn't be a lot, but I want to keep it on self-healing only.\r\n\r\nWe're also going to change and make `--no-distribution` the default, because it is odd you have to specify it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2248617906",
    "pr_number": 32196,
    "pr_file": "docs/nx-cloud/concepts/heartbeat-and-manual-shutdown-handling.md",
    "created_at": "2025-08-01T18:36:26+00:00",
    "commented_code": "+# Heartbeat and Main Job Completion Handling\n+\n+### What is the heartbeat process?\n+\n+A big challenge in building a task distribution engine is tracking when the main orchestrator job has finished (either successfully or due to an error).\n+For example, your agents might be busy running your Nx tasks, but GitHub Actions suddenly decides to kill your main job because it is consuming too many resources.\n+In that case, regardless of how you configured your pipeline or how many shutdown hooks we add to the code, we simply do not have enough time to tell Nx Cloud it can stop running tasks on agents.\n+\n+To fix this, the first time you run `nx affected` commands, we create a small background process on your main job that pings Nx Cloud every few seconds. The moment\n+we stop receiving these pings, we assume the main job has died, and we will fail the CI run and shut down the agents.\n+\n+This is useful not just for worst-case scenarios, but it also keeps your CI config simple:\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\" # start agents and tell Nx to send the below affected tasks to NxCloud rather than execute in-place\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test\n+# That's it - we don't need an extra step to tell NxCloud that we're done running Nx commands.\n+```\n+\n+\ud83d\udc46In the above case, once all the `affected` commands are executed and the main job shuts down, the heartbeat process will stop the pings. So, we'll assume the main job finished, and we can turn off the agents.\n+\n+In summary, for 99% of cases, you will never have to think about the heartbeat or care that it exists. Your CI will just work.\n+\n+### Caveats\n+\n+In some specific cases, though, the heartbeat process will not work properly. In that case, you will need to [manage completion yourself](/ci/reference/nx-cloud-cli#requireexplicitcompletion):\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\" --require-explicit-completion # this option disables the heartbeat\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test\n+- run: npx nx-cloud complete-ci-run # this now tells NxCloud to turn off the agents\n+  if: always() # IMPORTANT: Always run, even in case of failures\n+```\n+\n+When you might need to do this:\n+\n+#### CI provider unexpectedly cleans up background processes\n+\n+We've noticed that some CI providers tend to be more aggressive with background process management when moving between steps. Assume you have the following configuration:\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\"\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test # This is the point where we turn on the heartbeat.\n+- run: ./deploy-my-projects.sh\n+- run: ./publish-test-results-to-sonarqube\n+- run: npx nx affected -t e2e\n+```\n+\n+\ud83d\udc46Notice how after running `npx nx affected -t build,lint,test`, we are doing some other work (deploying the projects, uploading test results, etc.). We've seen\n+some CI providers occasionally clean up background processes when moving between steps. So, if you see your main job failing when it gets to the `npx nx affected -t e2e` tests,\n+it might be because Nx Cloud thought the distribution had ended already, and it didn't accept any new Nx tasks.\n+\n+The heartbeat process is especially vulnerable during these \"transition phases\" between steps.\n+\n+To fix this, you can either manage completion explicitly (as mentioned above) or move all your Nx tasks into a single `affected` command. Both would fix the issue.",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2248617906",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32196,
        "pr_file": "docs/nx-cloud/concepts/heartbeat-and-manual-shutdown-handling.md",
        "discussion_id": "2248617906",
        "commented_code": "@@ -0,0 +1,88 @@\n+# Heartbeat and Main Job Completion Handling\n+\n+### What is the heartbeat process?\n+\n+A big challenge in building a task distribution engine is tracking when the main orchestrator job has finished (either successfully or due to an error).\n+For example, your agents might be busy running your Nx tasks, but GitHub Actions suddenly decides to kill your main job because it is consuming too many resources.\n+In that case, regardless of how you configured your pipeline or how many shutdown hooks we add to the code, we simply do not have enough time to tell Nx Cloud it can stop running tasks on agents.\n+\n+To fix this, the first time you run `nx affected` commands, we create a small background process on your main job that pings Nx Cloud every few seconds. The moment\n+we stop receiving these pings, we assume the main job has died, and we will fail the CI run and shut down the agents.\n+\n+This is useful not just for worst-case scenarios, but it also keeps your CI config simple:\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\" # start agents and tell Nx to send the below affected tasks to NxCloud rather than execute in-place\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test\n+# That's it - we don't need an extra step to tell NxCloud that we're done running Nx commands.\n+```\n+\n+\ud83d\udc46In the above case, once all the `affected` commands are executed and the main job shuts down, the heartbeat process will stop the pings. So, we'll assume the main job finished, and we can turn off the agents.\n+\n+In summary, for 99% of cases, you will never have to think about the heartbeat or care that it exists. Your CI will just work.\n+\n+### Caveats\n+\n+In some specific cases, though, the heartbeat process will not work properly. In that case, you will need to [manage completion yourself](/ci/reference/nx-cloud-cli#requireexplicitcompletion):\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\" --require-explicit-completion # this option disables the heartbeat\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test\n+- run: npx nx-cloud complete-ci-run # this now tells NxCloud to turn off the agents\n+  if: always() # IMPORTANT: Always run, even in case of failures\n+```\n+\n+When you might need to do this:\n+\n+#### CI provider unexpectedly cleans up background processes\n+\n+We've noticed that some CI providers tend to be more aggressive with background process management when moving between steps. Assume you have the following configuration:\n+\n+```yaml\n+- run: npx nx-cloud start-ci-run --distribute-on=\"5 linux-medium-js\"\n+- run: npm ci\n+- run: npx nx affected -t build,lint,test # This is the point where we turn on the heartbeat.\n+- run: ./deploy-my-projects.sh\n+- run: ./publish-test-results-to-sonarqube\n+- run: npx nx affected -t e2e\n+```\n+\n+\ud83d\udc46Notice how after running `npx nx affected -t build,lint,test`, we are doing some other work (deploying the projects, uploading test results, etc.). We've seen\n+some CI providers occasionally clean up background processes when moving between steps. So, if you see your main job failing when it gets to the `npx nx affected -t e2e` tests,\n+it might be because Nx Cloud thought the distribution had ended already, and it didn't accept any new Nx tasks.\n+\n+The heartbeat process is especially vulnerable during these \"transition phases\" between steps.\n+\n+To fix this, you can either manage completion explicitly (as mentioned above) or move all your Nx tasks into a single `affected` command. Both would fix the issue.",
        "comment_created_at": "2025-08-01T18:36:26+00:00",
        "comment_author": "barbados-clemens",
        "comment_body": "```suggestion\r\nTo fix this, you can either manage completion explicitly (as mentioned above) or move all your Nx tasks into a single step or `nx` command. Both would fix the issue.\r\n```\r\n\r\nnot affected specific like above, but also doing a single step would probs work too. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2244964115",
    "pr_number": 32130,
    "pr_file": "docs/shared/recipes/nx-release/publish-in-ci-cd.md",
    "created_at": "2025-07-31T10:18:09+00:00",
    "commented_code": "NPM_CONFIG_PROVENANCE: true\n ```\n \n-[(See full workflow above)](#publish-in-github-actions)\n+## Publishing Docker Images (Experimental)\n+\n+{% callout type=\"warning\" title=\"Experimental Feature\" %}\n+Docker support in Nx is currently experimental and may undergo breaking changes without following semantic versioning.\n+{% /callout %}\n+\n+{% callout type=\"info\" title=\"Nx Cloud Agents Compatibility\" %}\n+Docker operations in `nx release` are currently supported in standard CI/CD environments like GitHub Actions, GitLab CI, and Jenkins.\n+\n+For Nx Cloud Agents compatibility, please contact [Nx Enterprise support](/contact/sales) to explore available options for your team.\n+{% /callout %}\n+\n+When using Nx Release with Docker images, the publishing process differs from npm packages. Docker images are built and tagged during the versioning phase, then pushed to a registry during the publish phase.\n+\n+### Docker Registry Authentication\n+\n+Before publishing Docker images, ensure you're authenticated with your Docker registry:\n+\n+```yaml {% fileName=\".github/workflows/publish.yml\" %}\n+- name: Login to Docker Hub\n+  uses: docker/login-action@v2\n+  with:\n+    username: ${{ secrets.DOCKER_USERNAME }}\n+    password: ${{ secrets.DOCKER_TOKEN }}\n+\n+- name: Build and tag Docker images\n+  run: npx nx release version --dockerVersionScheme=production\n+\n+- name: Publish Docker images\n+  run: npx nx release publish\n+```\n+\n+### Using Different Registries\n+\n+Configure alternative registries in your `nx.json`:\n+\n+```jsonc {% fileName=\"nx.json\" %}\n+{\n+  \"release\": {\n+    \"docker\": {\n+      \"registryUrl\": \"ghcr.io\", // GitHub Container Registry\n+      \"repositoryName\": \"myorg\"\n+    }\n+  }\n+}\n+```\n+\n+### Example GitHub Actions Workflow for Docker\n+\n+```yaml {% fileName=\".github/workflows/docker-publish.yml\" %}\n+name: Docker Publish\n+\n+on:\n+  push:\n+    branches: [main]\n+\n+jobs:\n+  publish:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+\n+      - name: Setup Node.js\n+        uses: actions/setup-node@v3\n+        with:\n+          node-version: 20\n+\n+      - name: Install dependencies\n+        run: npm ci\n+\n+      - name: Build applications\n+        run: npx nx run-many -t build\n+\n+      - name: Login to Docker Hub\n+        uses: docker/login-action@v2\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+\n+      - name: Release with Docker\n+        run: npx nx release --dockerVersionScheme=production",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2244964115",
        "repo_full_name": "nrwl/nx",
        "pr_number": 32130,
        "pr_file": "docs/shared/recipes/nx-release/publish-in-ci-cd.md",
        "discussion_id": "2244964115",
        "commented_code": "@@ -212,4 +226,114 @@ jobs:\n     NPM_CONFIG_PROVENANCE: true\n ```\n \n-[(See full workflow above)](#publish-in-github-actions)\n+## Publishing Docker Images (Experimental)\n+\n+{% callout type=\"warning\" title=\"Experimental Feature\" %}\n+Docker support in Nx is currently experimental and may undergo breaking changes without following semantic versioning.\n+{% /callout %}\n+\n+{% callout type=\"info\" title=\"Nx Cloud Agents Compatibility\" %}\n+Docker operations in `nx release` are currently supported in standard CI/CD environments like GitHub Actions, GitLab CI, and Jenkins.\n+\n+For Nx Cloud Agents compatibility, please contact [Nx Enterprise support](/contact/sales) to explore available options for your team.\n+{% /callout %}\n+\n+When using Nx Release with Docker images, the publishing process differs from npm packages. Docker images are built and tagged during the versioning phase, then pushed to a registry during the publish phase.\n+\n+### Docker Registry Authentication\n+\n+Before publishing Docker images, ensure you're authenticated with your Docker registry:\n+\n+```yaml {% fileName=\".github/workflows/publish.yml\" %}\n+- name: Login to Docker Hub\n+  uses: docker/login-action@v2\n+  with:\n+    username: ${{ secrets.DOCKER_USERNAME }}\n+    password: ${{ secrets.DOCKER_TOKEN }}\n+\n+- name: Build and tag Docker images\n+  run: npx nx release version --dockerVersionScheme=production\n+\n+- name: Publish Docker images\n+  run: npx nx release publish\n+```\n+\n+### Using Different Registries\n+\n+Configure alternative registries in your `nx.json`:\n+\n+```jsonc {% fileName=\"nx.json\" %}\n+{\n+  \"release\": {\n+    \"docker\": {\n+      \"registryUrl\": \"ghcr.io\", // GitHub Container Registry\n+      \"repositoryName\": \"myorg\"\n+    }\n+  }\n+}\n+```\n+\n+### Example GitHub Actions Workflow for Docker\n+\n+```yaml {% fileName=\".github/workflows/docker-publish.yml\" %}\n+name: Docker Publish\n+\n+on:\n+  push:\n+    branches: [main]\n+\n+jobs:\n+  publish:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+\n+      - name: Setup Node.js\n+        uses: actions/setup-node@v3\n+        with:\n+          node-version: 20\n+\n+      - name: Install dependencies\n+        run: npm ci\n+\n+      - name: Build applications\n+        run: npx nx run-many -t build\n+\n+      - name: Login to Docker Hub\n+        uses: docker/login-action@v2\n+        with:\n+          username: ${{ secrets.DOCKER_USERNAME }}\n+          password: ${{ secrets.DOCKER_TOKEN }}\n+\n+      - name: Release with Docker\n+        run: npx nx release --dockerVersionScheme=production",
        "comment_created_at": "2025-07-31T10:18:09+00:00",
        "comment_author": "Coly010",
        "comment_body": "We probably want `--yes` at the end of this, im not sure if nx release automatically detects ci env to not prompt",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100967138",
    "pr_number": 31261,
    "pr_file": "docs/nx-cloud/concepts/cache-security.md",
    "created_at": "2025-05-21T18:58:29+00:00",
    "commented_code": "While you can [specify a token](/ci/recipes/security/access-tokens) with the `nxCloudAccessToken` property in `nx.json`, this is visible to anyone who can view your codebase. A read-write token would give someone who may not even have permission to create a PR the access to add entries to the remote cache, which would then be used on other developer's machines and in CI. We recommend you restrict CI Access Tokens to CI use only and rely on [personal access tokens](/ci/recipes/security/personal-access-tokens) for local development instead.\n \n-### Use a Read-Write Token in CI\n+### Use Scoped Tokens in CI\n \n-If you're in an environment (like an open source project) where you can't trust the contents of a pull request, we recommend restricting the use of a [read-write token](/ci/recipes/security/access-tokens) in CI to just be used on the `main` branch. If you know that everyone who can make a PR is a trusted developer, you can extend that [read-write token](/ci/recipes/security/access-tokens) to also include pull request branches.\n+For all branches marked as protected, we recommend using a [read-write token](/ci/recipes/security/access-tokens#read-write-access).\n+`read-write` access tokens allow reading and writing from the shared primary cache for your workspace.\n+\n+In all other branches, we recommend using a [read-only token](/ci/recipes/security/access-tokens#read-only-access). A `read-only` token only allows reading from the shared primary cache, and writing to a branch specific isolated cache. This allows for your CI Pipelines to still benefit from previous computational work, without opening up the possibility of cache poisoning into your trusted environments. Learn more about [access token architecture](/ci/recipes/security/access-tokens#setting-ci-access-tokens).",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2100967138",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31261,
        "pr_file": "docs/nx-cloud/concepts/cache-security.md",
        "discussion_id": "2100967138",
        "commented_code": "@@ -32,9 +32,12 @@ You can strengthen your workspace security further by revoking all access to the\n \n While you can [specify a token](/ci/recipes/security/access-tokens) with the `nxCloudAccessToken` property in `nx.json`, this is visible to anyone who can view your codebase. A read-write token would give someone who may not even have permission to create a PR the access to add entries to the remote cache, which would then be used on other developer's machines and in CI. We recommend you restrict CI Access Tokens to CI use only and rely on [personal access tokens](/ci/recipes/security/personal-access-tokens) for local development instead.\n \n-### Use a Read-Write Token in CI\n+### Use Scoped Tokens in CI\n \n-If you're in an environment (like an open source project) where you can't trust the contents of a pull request, we recommend restricting the use of a [read-write token](/ci/recipes/security/access-tokens) in CI to just be used on the `main` branch. If you know that everyone who can make a PR is a trusted developer, you can extend that [read-write token](/ci/recipes/security/access-tokens) to also include pull request branches.\n+For all branches marked as protected, we recommend using a [read-write token](/ci/recipes/security/access-tokens#read-write-access).\n+`read-write` access tokens allow reading and writing from the shared primary cache for your workspace.\n+\n+In all other branches, we recommend using a [read-only token](/ci/recipes/security/access-tokens#read-only-access). A `read-only` token only allows reading from the shared primary cache, and writing to a branch specific isolated cache. This allows for your CI Pipelines to still benefit from previous computational work, without opening up the possibility of cache poisoning into your trusted environments. Learn more about [access token architecture](/ci/recipes/security/access-tokens#setting-ci-access-tokens).",
        "comment_created_at": "2025-05-21T18:58:29+00:00",
        "comment_author": "isaacplmann",
        "comment_body": "```suggestion\r\nIn all other branches, we recommend using a [read-only token](/ci/recipes/security/access-tokens#read-only-access). A `read-only` token only allows reading from the shared primary cache, and writing to a branch specific isolated cache. This allows your CI pipelines to share computational work within the same CI pipeline, without opening up the possibility of cache poisoning in your trusted environments. Learn more about [access token architecture](/ci/recipes/security/access-tokens#setting-ci-access-tokens).\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100978873",
    "pr_number": 31261,
    "pr_file": "docs/nx-cloud/recipes/access-tokens.md",
    "created_at": "2025-05-21T19:06:12+00:00",
    "commented_code": "### Read Only Access\n \n-The `read-only` access tokens will only read from the remote cache. New task results will not be stored in the remote cache, but cached results can be downloaded and replayed for other machines or CI pipelines to use. This option provides the benefit of remote cache hits while restricting machines without proper permissions from adding entries into the remote cache.\n+The `read-only` access tokens will only read from the remote cache. New task results will be stored in the remote cache _only_ for that specific branch in a CI context, otherwise they will not be stored in the remote cache.  \n+Cached results can be downloaded and replayed for other machines or CI pipelines to use. This option provides the benefit of remote cache hits while restricting machines without proper permissions from adding entries into the shared primary remote cache.\n \n ### Read & Write Access\n \n-The `read-write` access tokens allows task results to be stored in the remote cache for other other machines or CI pipelines to download and replay.\n+The `read-write` access tokens allows task results to be stored in the remote cache for other machines or CI pipelines to download and replay. This access level should only be used for trusted environments, such as protected branches within your CI Pipeline.\n \n ## Setting CI Access Tokens\n \n-You can configure an access token in CI by setting the `NX_CLOUD_ACCESS_TOKEN` environment variable. `NX_CLOUD_ACCESS_TOKEN` takes precedence over any authentication method in your `nx.json`.\n+You can configure an access token in CI by setting the `NX_CLOUD_ACCESS_TOKEN` environment variable.\n \n-The following example shows how to set the `NX_CLOUD_ACCESS_TOKEN` environment variable in a GitHub Actions workflow. You will need to add the `secrets.NX_CLOUD_ACCESS_TOKEN` secret to your repository based on instructions provided by your CI provider (see [GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions) or [GitLab](https://docs.gitlab.com/ee/ci/variables/#define-a-cicd-variable-in-the-ui) instructions).\n+`NX_CLOUD_ACCESS_TOKEN` takes precedence over any authentication method in your `nx.json`.\n \n-```yml {% fileName=\".github/workflows/ci.yml\" highlightLines=[\"29-32\"] %}\n+We recommend setting up a `read-write` and `read-only` in your CI based on protected vs unprotected branches. You can leverage your CI providers.",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2100978873",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31261,
        "pr_file": "docs/nx-cloud/recipes/access-tokens.md",
        "discussion_id": "2100978873",
        "commented_code": "@@ -19,21 +19,147 @@ There are currently two (2) types of CI Access Token for Nx Cloud's runner that\n \n ### Read Only Access\n \n-The `read-only` access tokens will only read from the remote cache. New task results will not be stored in the remote cache, but cached results can be downloaded and replayed for other machines or CI pipelines to use. This option provides the benefit of remote cache hits while restricting machines without proper permissions from adding entries into the remote cache.\n+The `read-only` access tokens will only read from the remote cache. New task results will be stored in the remote cache _only_ for that specific branch in a CI context, otherwise they will not be stored in the remote cache.  \n+Cached results can be downloaded and replayed for other machines or CI pipelines to use. This option provides the benefit of remote cache hits while restricting machines without proper permissions from adding entries into the shared primary remote cache.\n \n ### Read & Write Access\n \n-The `read-write` access tokens allows task results to be stored in the remote cache for other other machines or CI pipelines to download and replay.\n+The `read-write` access tokens allows task results to be stored in the remote cache for other machines or CI pipelines to download and replay. This access level should only be used for trusted environments, such as protected branches within your CI Pipeline.\n \n ## Setting CI Access Tokens\n \n-You can configure an access token in CI by setting the `NX_CLOUD_ACCESS_TOKEN` environment variable. `NX_CLOUD_ACCESS_TOKEN` takes precedence over any authentication method in your `nx.json`.\n+You can configure an access token in CI by setting the `NX_CLOUD_ACCESS_TOKEN` environment variable.\n \n-The following example shows how to set the `NX_CLOUD_ACCESS_TOKEN` environment variable in a GitHub Actions workflow. You will need to add the `secrets.NX_CLOUD_ACCESS_TOKEN` secret to your repository based on instructions provided by your CI provider (see [GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions) or [GitLab](https://docs.gitlab.com/ee/ci/variables/#define-a-cicd-variable-in-the-ui) instructions).\n+`NX_CLOUD_ACCESS_TOKEN` takes precedence over any authentication method in your `nx.json`.\n \n-```yml {% fileName=\".github/workflows/ci.yml\" highlightLines=[\"29-32\"] %}\n+We recommend setting up a `read-write` and `read-only` in your CI based on protected vs unprotected branches. You can leverage your CI providers.",
        "comment_created_at": "2025-05-21T19:06:12+00:00",
        "comment_author": "isaacplmann",
        "comment_body": "```suggestion\r\nWe recommend setting up a `read-write` token for you protected branches in CI and a `read-only` token for unprotected branches and local development. You can leverage your CI provider's environment variables management to accomplish this.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2102366826",
    "pr_number": 31261,
    "pr_file": "docs/nx-cloud/concepts/cache-security.md",
    "created_at": "2025-05-22T11:49:57+00:00",
    "commented_code": "While you can [specify a token](/ci/recipes/security/access-tokens) with the `nxCloudAccessToken` property in `nx.json`, this is visible to anyone who can view your codebase. A read-write token would give someone who may not even have permission to create a PR the access to add entries to the remote cache, which would then be used on other developer's machines and in CI. We recommend you restrict CI Access Tokens to CI use only and rely on [personal access tokens](/ci/recipes/security/personal-access-tokens) for local development instead.\n \n-### Use a Read-Write Token in CI\n+### Use Scoped Tokens in CI\n \n-If you're in an environment (like an open source project) where you can't trust the contents of a pull request, we recommend restricting the use of a [read-write token](/ci/recipes/security/access-tokens) in CI to just be used on the `main` branch. If you know that everyone who can make a PR is a trusted developer, you can extend that [read-write token](/ci/recipes/security/access-tokens) to also include pull request branches.\n+For all branches marked as protected, we recommend using a [read-write token](/ci/recipes/security/access-tokens#read-write-access).",
    "repo_full_name": "nrwl/nx",
    "discussion_comments": [
      {
        "comment_id": "2102366826",
        "repo_full_name": "nrwl/nx",
        "pr_number": 31261,
        "pr_file": "docs/nx-cloud/concepts/cache-security.md",
        "discussion_id": "2102366826",
        "commented_code": "@@ -32,9 +32,12 @@ You can strengthen your workspace security further by revoking all access to the\n \n While you can [specify a token](/ci/recipes/security/access-tokens) with the `nxCloudAccessToken` property in `nx.json`, this is visible to anyone who can view your codebase. A read-write token would give someone who may not even have permission to create a PR the access to add entries to the remote cache, which would then be used on other developer's machines and in CI. We recommend you restrict CI Access Tokens to CI use only and rely on [personal access tokens](/ci/recipes/security/personal-access-tokens) for local development instead.\n \n-### Use a Read-Write Token in CI\n+### Use Scoped Tokens in CI\n \n-If you're in an environment (like an open source project) where you can't trust the contents of a pull request, we recommend restricting the use of a [read-write token](/ci/recipes/security/access-tokens) in CI to just be used on the `main` branch. If you know that everyone who can make a PR is a trusted developer, you can extend that [read-write token](/ci/recipes/security/access-tokens) to also include pull request branches.\n+For all branches marked as protected, we recommend using a [read-write token](/ci/recipes/security/access-tokens#read-write-access).",
        "comment_created_at": "2025-05-22T11:49:57+00:00",
        "comment_author": "meeroslav",
        "comment_body": "I would elaborate on this a bit and rephrase:\r\n\r\n```suggestion\r\nWe recommend using a [read-write token](/ci/recipes/security/access-tokens#read-write-access) only for protected branches (branches that don't allow direct push).\r\n```",
        "pr_file_module": null
      }
    ]
  }
]