[
  {
    "discussion_id": "1966369391",
    "pr_number": 9282,
    "pr_file": "runner/common/types.go",
    "created_at": "2025-02-22T01:10:39+00:00",
    "commented_code": null,
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1966369391",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9282,
        "pr_file": "runner/common/types.go",
        "discussion_id": "1966369391",
        "commented_code": null,
        "comment_created_at": "2025-02-22T01:10:39+00:00",
        "comment_author": "jessegross",
        "comment_body": "Can we actually move this (and all the other data structures that get serialized to JSON) to the Ollama server? This API is left over from server.cpp but we don't need to maintain compatibility now.\r\n\r\nWe can have a single set of data structures for both sides. Some of them can also just recycled from the API package - for example, Options is basically an existing data structure with different names for compatibility, which we no longer need.",
        "pr_file_module": null
      },
      {
        "comment_id": "1968543683",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9282,
        "pr_file": "runner/common/types.go",
        "discussion_id": "1966369391",
        "commented_code": null,
        "comment_created_at": "2025-02-24T23:05:36+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "Good point, opened https://github.com/ollama/ollama/pull/9324 to address this since its a confusing diff. I'll rebase this PR on top of #9324 when possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2032115305",
    "pr_number": 10166,
    "pr_file": "api/types.go",
    "created_at": "2025-04-07T22:54:54+00:00",
    "commented_code": "Properties map[string]struct {\n \t\t\tType        PropertyType `json:\"type\"`\n \t\t\tDescription string       `json:\"description\"`\n-\t\t\tEnum        []string     `json:\"enum,omitempty\"`\n+\t\t\tEnum        []any        `json:\"enum,omitempty\"`\n \t\t} `json:\"properties\"`\n \t} `json:\"parameters\"`\n }\n \n+// https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.1.2\n+func (t *ToolFunction) UnmarshalJSON(b []byte) error {\n+\ttype Alias ToolFunction\n+\tvar a Alias\n+\tif err := json.Unmarshal(b, &a); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Validate enum arrays\n+\tfor _, prop := range a.Parameters.Properties {\n+\t\tif len(prop.Enum) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Check for uniqueness and consistent types",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2032115305",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10166,
        "pr_file": "api/types.go",
        "discussion_id": "2032115305",
        "commented_code": "@@ -217,11 +217,45 @@ type ToolFunction struct {\n \t\tProperties map[string]struct {\n \t\t\tType        PropertyType `json:\"type\"`\n \t\t\tDescription string       `json:\"description\"`\n-\t\t\tEnum        []string     `json:\"enum,omitempty\"`\n+\t\t\tEnum        []any        `json:\"enum,omitempty\"`\n \t\t} `json:\"properties\"`\n \t} `json:\"parameters\"`\n }\n \n+// https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.1.2\n+func (t *ToolFunction) UnmarshalJSON(b []byte) error {\n+\ttype Alias ToolFunction\n+\tvar a Alias\n+\tif err := json.Unmarshal(b, &a); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Validate enum arrays\n+\tfor _, prop := range a.Parameters.Properties {\n+\t\tif len(prop.Enum) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Check for uniqueness and consistent types",
        "comment_created_at": "2025-04-07T22:54:54+00:00",
        "comment_author": "mxyng",
        "comment_body": "Is this necessary? Tools should be opaque to Ollama. The only reason any fields are defined is control templating and/or parsing",
        "pr_file_module": null
      },
      {
        "comment_id": "2032118525",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10166,
        "pr_file": "api/types.go",
        "discussion_id": "2032115305",
        "commented_code": "@@ -217,11 +217,45 @@ type ToolFunction struct {\n \t\tProperties map[string]struct {\n \t\t\tType        PropertyType `json:\"type\"`\n \t\t\tDescription string       `json:\"description\"`\n-\t\t\tEnum        []string     `json:\"enum,omitempty\"`\n+\t\t\tEnum        []any        `json:\"enum,omitempty\"`\n \t\t} `json:\"properties\"`\n \t} `json:\"parameters\"`\n }\n \n+// https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.1.2\n+func (t *ToolFunction) UnmarshalJSON(b []byte) error {\n+\ttype Alias ToolFunction\n+\tvar a Alias\n+\tif err := json.Unmarshal(b, &a); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Validate enum arrays\n+\tfor _, prop := range a.Parameters.Properties {\n+\t\tif len(prop.Enum) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Check for uniqueness and consistent types",
        "comment_created_at": "2025-04-07T22:59:25+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "I suppose it doesn't have to be. To me it made more sense to have the JSON validation here vs. the SDKs/client. I don't think we have to be so strict for this as the model would consume whatever we pass it (even if incorrect from a JSON standpoint)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006283138",
    "pr_number": 9913,
    "pr_file": "runner/ollamarunner/runner.go",
    "created_at": "2025-03-20T19:05:22+00:00",
    "commented_code": "}\n \t}\n \n-\tsampler := sample.NewSampler(\n-\t\treq.Options.Temperature,\n-\t\treq.Options.TopK,\n-\t\treq.Options.TopP,\n-\t\treq.Options.MinP,\n-\t\treq.Options.Seed,\n-\t\tgrammar,\n-\t)\n+\tsampler := sample.NewSampler(req.Options, grammar)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2006283138",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9913,
        "pr_file": "runner/ollamarunner/runner.go",
        "discussion_id": "2006283138",
        "commented_code": "@@ -561,14 +561,7 @@ func (s *Server) completion(w http.ResponseWriter, r *http.Request) {\n \t\t}\n \t}\n \n-\tsampler := sample.NewSampler(\n-\t\treq.Options.Temperature,\n-\t\treq.Options.TopK,\n-\t\treq.Options.TopP,\n-\t\treq.Options.MinP,\n-\t\treq.Options.Seed,\n-\t\tgrammar,\n-\t)\n+\tsampler := sample.NewSampler(req.Options, grammar)",
        "comment_created_at": "2025-03-20T19:05:22+00:00",
        "comment_author": "jmorganca",
        "comment_body": "This is over coupling sampling with the `api.Options` type. Looser coupling is usually better. Much better that it accepts the raw float32/int values instead of passing `req` even deeper",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1984046227",
    "pr_number": 9374,
    "pr_file": "sample/samplers.go",
    "created_at": "2025-03-06T21:02:26+00:00",
    "commented_code": "import (\n \t\"errors\"\n-\t\"math\"\n-\n-\t\"golang.org/x/exp/rand\"\n-\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+\t\"math/rand/v2\"\n )\n \n+// Sampler is not thread-safe. Each goroutine should have its own instance.\n type Sampler interface {\n \tSample([]float32) (int32, error)\n }\n \n+type tokenInfo struct {\n+\tid    int32\n+\tlogit float32\n+\tprob  float32\n+}\n+\n+type tokenSliceInfo struct {\n+\ttokens []tokenInfo\n+\tsorted bool\n+\tsum    float32\n+}\n+\n type weighted struct {\n-\tsrc        rand.Source\n-\ttransforms []Transform\n+\trng        *rand.Rand\n+\ttransforms []transform\n }\n \n-// TODO(parthsareen): remove uv sample dependency https://github.com/ollama/ollama/issues/9279\n-func Weighted(seed *uint64, transforms ...Transform) Sampler {\n-\tvar src rand.Source\n-\tif seed != nil {\n-\t\tsrc = rand.NewSource(*seed)\n+func Weighted(rng *rand.Rand, transforms ...transform) Sampler {\n+\treturn &weighted{\n+\t\trng:        rng,\n+\t\ttransforms: transforms,\n \t}\n-\treturn weighted{src: src, transforms: transforms}\n }\n \n-func (s weighted) Sample(logits []float32) (int32, error) {\n-\tlogits64 := make([]float64, len(logits))\n+func (s *weighted) Sample(logits []float32) (int32, error) {\n+\ttokens := make([]tokenInfo, len(logits))\n \tfor i, v := range logits {\n-\t\tlogits64[i] = float64(v)\n+\t\ttokens[i].id = int32(i)\n+\t\ttokens[i].logit = v\n \t}\n \n+\ttokensInfo := tokenSliceInfo{tokens: tokens, sorted: false}\n \tfor _, t := range s.transforms {",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1984046227",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9374,
        "pr_file": "sample/samplers.go",
        "discussion_id": "1984046227",
        "commented_code": "@@ -2,59 +2,75 @@ package sample\n \n import (\n \t\"errors\"\n-\t\"math\"\n-\n-\t\"golang.org/x/exp/rand\"\n-\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+\t\"math/rand/v2\"\n )\n \n+// Sampler is not thread-safe. Each goroutine should have its own instance.\n type Sampler interface {\n \tSample([]float32) (int32, error)\n }\n \n+type tokenInfo struct {\n+\tid    int32\n+\tlogit float32\n+\tprob  float32\n+}\n+\n+type tokenSliceInfo struct {\n+\ttokens []tokenInfo\n+\tsorted bool\n+\tsum    float32\n+}\n+\n type weighted struct {\n-\tsrc        rand.Source\n-\ttransforms []Transform\n+\trng        *rand.Rand\n+\ttransforms []transform\n }\n \n-// TODO(parthsareen): remove uv sample dependency https://github.com/ollama/ollama/issues/9279\n-func Weighted(seed *uint64, transforms ...Transform) Sampler {\n-\tvar src rand.Source\n-\tif seed != nil {\n-\t\tsrc = rand.NewSource(*seed)\n+func Weighted(rng *rand.Rand, transforms ...transform) Sampler {\n+\treturn &weighted{\n+\t\trng:        rng,\n+\t\ttransforms: transforms,\n \t}\n-\treturn weighted{src: src, transforms: transforms}\n }\n \n-func (s weighted) Sample(logits []float32) (int32, error) {\n-\tlogits64 := make([]float64, len(logits))\n+func (s *weighted) Sample(logits []float32) (int32, error) {\n+\ttokens := make([]tokenInfo, len(logits))\n \tfor i, v := range logits {\n-\t\tlogits64[i] = float64(v)\n+\t\ttokens[i].id = int32(i)\n+\t\ttokens[i].logit = v\n \t}\n \n+\ttokensInfo := tokenSliceInfo{tokens: tokens, sorted: false}\n \tfor _, t := range s.transforms {",
        "comment_created_at": "2025-03-06T21:02:26+00:00",
        "comment_author": "jmorganca",
        "comment_body": "Instead of a list of transforms (`[]Transform`), why don't we just make helper functions like `topP` `topK` `softmax` and call them in the fixed order we use here (given the API is fixed)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1984048948",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9374,
        "pr_file": "sample/samplers.go",
        "discussion_id": "1984046227",
        "commented_code": "@@ -2,59 +2,75 @@ package sample\n \n import (\n \t\"errors\"\n-\t\"math\"\n-\n-\t\"golang.org/x/exp/rand\"\n-\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+\t\"math/rand/v2\"\n )\n \n+// Sampler is not thread-safe. Each goroutine should have its own instance.\n type Sampler interface {\n \tSample([]float32) (int32, error)\n }\n \n+type tokenInfo struct {\n+\tid    int32\n+\tlogit float32\n+\tprob  float32\n+}\n+\n+type tokenSliceInfo struct {\n+\ttokens []tokenInfo\n+\tsorted bool\n+\tsum    float32\n+}\n+\n type weighted struct {\n-\tsrc        rand.Source\n-\ttransforms []Transform\n+\trng        *rand.Rand\n+\ttransforms []transform\n }\n \n-// TODO(parthsareen): remove uv sample dependency https://github.com/ollama/ollama/issues/9279\n-func Weighted(seed *uint64, transforms ...Transform) Sampler {\n-\tvar src rand.Source\n-\tif seed != nil {\n-\t\tsrc = rand.NewSource(*seed)\n+func Weighted(rng *rand.Rand, transforms ...transform) Sampler {\n+\treturn &weighted{\n+\t\trng:        rng,\n+\t\ttransforms: transforms,\n \t}\n-\treturn weighted{src: src, transforms: transforms}\n }\n \n-func (s weighted) Sample(logits []float32) (int32, error) {\n-\tlogits64 := make([]float64, len(logits))\n+func (s *weighted) Sample(logits []float32) (int32, error) {\n+\ttokens := make([]tokenInfo, len(logits))\n \tfor i, v := range logits {\n-\t\tlogits64[i] = float64(v)\n+\t\ttokens[i].id = int32(i)\n+\t\ttokens[i].logit = v\n \t}\n \n+\ttokensInfo := tokenSliceInfo{tokens: tokens, sorted: false}\n \tfor _, t := range s.transforms {",
        "comment_created_at": "2025-03-06T21:04:01+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "Yeah - this made more sense when the package was being exposed to runner. I think it's unnecessarily abstracted",
        "pr_file_module": null
      }
    ]
  }
]