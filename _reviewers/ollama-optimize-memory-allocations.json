[
  {
    "discussion_id": "2100591460",
    "pr_number": 10747,
    "pr_file": "llama/sampling_ext.cpp",
    "created_at": "2025-05-21T15:30:23+00:00",
    "commented_code": "return common_sampler_sample(sampler, ctx, idx);\n }\n \n-int schema_to_grammar(const char *json_schema, char *grammar, size_t max_len)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2100591460",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10747,
        "pr_file": "llama/sampling_ext.cpp",
        "discussion_id": "2100591460",
        "commented_code": "@@ -45,25 +46,22 @@ llama_token common_sampler_csample(struct common_sampler *sampler, struct llama_\n     return common_sampler_sample(sampler, ctx, idx);\n }\n \n-int schema_to_grammar(const char *json_schema, char *grammar, size_t max_len)",
        "comment_created_at": "2025-05-21T15:30:23+00:00",
        "comment_author": "jmorganca",
        "comment_body": "Thanks for the PR!\r\n\r\nWould it be possible to keep the argument based return value?",
        "pr_file_module": null
      },
      {
        "comment_id": "2107741522",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10747,
        "pr_file": "llama/sampling_ext.cpp",
        "discussion_id": "2100591460",
        "commented_code": "@@ -45,25 +46,22 @@ llama_token common_sampler_csample(struct common_sampler *sampler, struct llama_\n     return common_sampler_sample(sampler, ctx, idx);\n }\n \n-int schema_to_grammar(const char *json_schema, char *grammar, size_t max_len)",
        "comment_created_at": "2025-05-26T18:45:12+00:00",
        "comment_author": "SchoofsKelvin",
        "comment_body": "Is there a specific reason to? That would require to preallocate the buffer (which this PR tries to solve instead of finetuning the formula)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2027531977",
    "pr_number": 10096,
    "pr_file": "llama/grammar.cpp",
    "created_at": "2025-04-03T18:24:31+00:00",
    "commented_code": "+// #include \"llama-grammar.h\"\n+#include \"grammar.h\"\n+\n+#include \"llama-impl.h\"\n+// #include \"llama-vocab.h\"\n+// #include \"llama-sampling.h\"\n+\n+#include <cmath>\n+#include <algorithm>\n+#include <stdexcept>\n+\n+//\n+// helpers\n+//\n+\n+// NOTE: assumes valid utf8 (but checks for overrun)\n+static std::pair<uint32_t, const char *> decode_utf8(const char * src) {\n+    static const int lookup[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4 };\n+    uint8_t  first_byte = static_cast<uint8_t>(*src);\n+    uint8_t  highbits   = first_byte >> 4;\n+    int      len        = lookup[highbits];\n+    uint8_t  mask       = (1 << (8 - len)) - 1;\n+    uint32_t value      = first_byte & mask;\n+    const char * end    = src + len; // may overrun!\n+    const char * pos    = src + 1;\n+    for ( ; pos < end && *pos; pos++) {\n+        value = (value << 6) + (static_cast<uint8_t>(*pos) & 0x3F);\n+    }\n+    return std::make_pair(value, pos);\n+}\n+\n+static std::pair<std::vector<uint32_t>, partial_utf8> decode_utf8(\n+        const std::string & src,\n+        partial_utf8 partial_start) {\n+    static const int      lookup[] = { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 4 };\n+    const char          * pos      = src.c_str();\n+    std::vector<uint32_t> code_points;\n+\n+    // common english strings have the same number of codepoints and bytes. `+ 1` for the terminating 0.\n+    code_points.reserve(src.size() + 1);\n+    uint32_t value    = partial_start.value;\n+    int      n_remain = partial_start.n_remain;\n+\n+    // continue previous decode, if applicable\n+    while (*pos != 0 && n_remain > 0) {\n+        uint8_t next_byte = static_cast<uint8_t>(*pos);\n+        if ((next_byte >> 6) != 2) {\n+            // invalid sequence, abort\n+            code_points.push_back(0);\n+            return std::make_pair(std::move(code_points), partial_utf8{ 0, -1 });\n+        }\n+        value = (value << 6) + (next_byte & 0x3F);\n+        ++pos;\n+        --n_remain;\n+    }\n+\n+    if (partial_start.n_remain > 0 && n_remain == 0) {\n+        code_points.push_back(value);\n+    }\n+\n+    // decode any subsequent utf-8 sequences, which may end in an incomplete one\n+    while (*pos != 0) {\n+        uint8_t first_byte = static_cast<uint8_t>(*pos);\n+        uint8_t highbits   = first_byte >> 4;\n+        n_remain   = lookup[highbits] - 1;\n+\n+        if (n_remain < 0) {\n+            // invalid sequence, abort\n+            code_points.clear();\n+            code_points.push_back(0);\n+            return std::make_pair(std::move(code_points), partial_utf8{ 0, n_remain });\n+        }\n+\n+        uint8_t mask  = (1 << (7 - n_remain)) - 1;\n+        value = first_byte & mask;\n+\n+        ++pos;\n+        while (*pos != 0 && n_remain > 0) {\n+            value = (value << 6) + (static_cast<uint8_t>(*pos) & 0x3F);\n+            ++pos;\n+            --n_remain;\n+        }\n+        if (n_remain == 0) {\n+            code_points.push_back(value);\n+        }\n+    }\n+    code_points.push_back(0);\n+\n+    return std::make_pair(std::move(code_points), partial_utf8{ value, n_remain });\n+}\n+\n+static bool is_digit_char(char c) {\n+    return '0' <= c && c <= '9';\n+}\n+\n+static bool is_word_char(char c) {\n+    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '-' || is_digit_char(c);\n+}\n+\n+static std::pair<uint32_t, const char *> parse_hex(const char * src, int size) {\n+    const char * pos   = src;\n+    const char * end   = src + size;\n+    uint32_t     value = 0;\n+    for ( ; pos < end && *pos; pos++) {\n+        value <<= 4;\n+        char c = *pos;\n+        if ('a' <= c && c <= 'f') {\n+            value += c - 'a' + 10;\n+        } else if ('A' <= c && c <= 'F') {\n+            value += c - 'A' + 10;\n+        } else if ('0' <= c && c <= '9') {\n+            value += c - '0';\n+        } else {\n+            break;\n+        }\n+    }\n+    if (pos != end) {\n+        throw std::runtime_error(\"expecting \" + std::to_string(size) + \" hex chars at \" + src);\n+    }\n+    return std::make_pair(value, pos);\n+}\n+\n+static const char * parse_space(const char * src, bool newline_ok) {\n+    const char * pos = src;\n+    while (*pos == ' ' || *pos == '\\t' || *pos == '#' ||\n+            (newline_ok && (*pos == '\\r' || *pos == '\n'))) {\n+        if (*pos == '#') {\n+            while (*pos && *pos != '\\r' && *pos != '\n') {\n+                pos++;\n+            }\n+        } else {\n+            pos++;\n+        }\n+    }\n+    return pos;\n+}\n+\n+static const char * parse_name(const char * src) {\n+    const char * pos = src;\n+    while (is_word_char(*pos)) {\n+        pos++;\n+    }\n+    if (pos == src) {\n+        throw std::runtime_error(std::string(\"expecting name at \") + src);\n+    }\n+    return pos;\n+}\n+\n+static const char * parse_int(const char * src) {\n+    const char * pos = src;\n+    while (is_digit_char(*pos)) {\n+        pos++;\n+    }\n+    if (pos == src) {\n+        throw std::runtime_error(std::string(\"expecting integer at \") + src);\n+    }\n+    return pos;\n+}\n+\n+static std::pair<uint32_t, const char *> parse_char(const char * src) {\n+    if (*src == '\\\\') {\n+        switch (src[1]) {\n+            case 'x': return parse_hex(src + 2, 2);\n+            case 'u': return parse_hex(src + 2, 4);\n+            case 'U': return parse_hex(src + 2, 8);\n+            case 't': return std::make_pair('\\t', src + 2);\n+            case 'r': return std::make_pair('\\r', src + 2);\n+            case 'n': return std::make_pair('\n', src + 2);\n+            case '\\\\':\n+            case '\"':\n+            case '[':\n+            case ']':\n+                      return std::make_pair(src[1], src + 2);\n+            default:\n+                      throw std::runtime_error(std::string(\"unknown escape at \") + src);\n+        }\n+    } else if (*src) {\n+        return decode_utf8(src);\n+    }\n+    throw std::runtime_error(\"unexpected end of input\");\n+}\n+\n+static void print_grammar_char(FILE * file, uint32_t c) {\n+    if (0x20 <= c && c <= 0x7f) {\n+        fprintf(file, \"%c\", static_cast<char>(c));\n+    } else {\n+        // cop out of encoding UTF-8\n+        fprintf(file, \"<U+%04X>\", c);\n+    }\n+}\n+\n+static bool is_char_element(grammar_element elem) {\n+    switch (elem.type) {\n+        case GRETYPE_CHAR:           return true;\n+        case GRETYPE_CHAR_NOT:       return true;\n+        case GRETYPE_CHAR_ALT:       return true;\n+        case GRETYPE_CHAR_RNG_UPPER: return true;\n+        case GRETYPE_CHAR_ANY:       return true;\n+        default:                           return false;\n+    }\n+}\n+\n+static void print_rule_binary(FILE * file, const grammar_rule & rule) {\n+    for (auto elem : rule) {\n+        switch (elem.type) {\n+            case GRETYPE_END:            fprintf(file, \"END\");            break;\n+            case GRETYPE_ALT:            fprintf(file, \"ALT\");            break;\n+            case GRETYPE_RULE_REF:       fprintf(file, \"RULE_REF\");       break;\n+            case GRETYPE_CHAR:           fprintf(file, \"CHAR\");           break;\n+            case GRETYPE_CHAR_NOT:       fprintf(file, \"CHAR_NOT\");       break;\n+            case GRETYPE_CHAR_RNG_UPPER: fprintf(file, \"CHAR_RNG_UPPER\"); break;\n+            case GRETYPE_CHAR_ALT:       fprintf(file, \"CHAR_ALT\");       break;\n+            case GRETYPE_CHAR_ANY:       fprintf(file, \"CHAR_ANY\");       break;\n+        }\n+        switch (elem.type) {\n+            case GRETYPE_END:\n+            case GRETYPE_ALT:\n+            case GRETYPE_RULE_REF:\n+                fprintf(file, \"(%u) \", elem.value);\n+                break;\n+            case GRETYPE_CHAR:\n+            case GRETYPE_CHAR_NOT:\n+            case GRETYPE_CHAR_RNG_UPPER:\n+            case GRETYPE_CHAR_ALT:\n+            case GRETYPE_CHAR_ANY:\n+                fprintf(file, \"(\\\"\");\n+                print_grammar_char(file, elem.value);\n+                fprintf(file, \"\\\") \");\n+                break;\n+        }\n+    }\n+    fprintf(file, \"\n\");\n+}\n+\n+static void print_rule(\n+        FILE     * file,\n+        uint32_t   rule_id,\n+        const grammar_rule & rule,\n+        const std::map<uint32_t, std::string> & symbol_id_names) {\n+    if (rule.empty() || rule.back().type != GRETYPE_END) {\n+        throw std::runtime_error(\n+            \"malformed rule, does not end with GRETYPE_END: \" + std::to_string(rule_id));\n+    }\n+    fprintf(file, \"%s ::= \", symbol_id_names.at(rule_id).c_str());\n+    for (size_t i = 0, end = rule.size() - 1; i < end; i++) {\n+        grammar_element elem = rule[i];\n+        switch (elem.type) {\n+            case GRETYPE_END:\n+                throw std::runtime_error(\n+                    \"unexpected end of rule: \" + std::to_string(rule_id) + \",\" +\n+                    std::to_string(i));\n+            case GRETYPE_ALT:\n+                fprintf(file, \"| \");\n+                break;\n+            case GRETYPE_RULE_REF:\n+                fprintf(file, \"%s \", symbol_id_names.at(elem.value).c_str());\n+                break;\n+            case GRETYPE_CHAR:\n+                fprintf(file, \"[\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_NOT:\n+                fprintf(file, \"[^\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_RNG_UPPER:\n+                if (i == 0 || !is_char_element(rule[i - 1])) {\n+                    throw std::runtime_error(\n+                        \"GRETYPE_CHAR_RNG_UPPER without preceding char: \" +\n+                        std::to_string(rule_id) + \",\" + std::to_string(i));\n+                }\n+                fprintf(file, \"-\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_ALT:\n+                if (i == 0 || !is_char_element(rule[i - 1])) {\n+                    throw std::runtime_error(\n+                        \"GRETYPE_CHAR_ALT without preceding char: \" +\n+                        std::to_string(rule_id) + \",\" + std::to_string(i));\n+                }\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_ANY:\n+                fprintf(file, \".\");\n+                break;\n+        }\n+        if (is_char_element(elem)) {\n+            switch (rule[i + 1].type) {\n+                case GRETYPE_CHAR_ALT:\n+                case GRETYPE_CHAR_RNG_UPPER:\n+                case GRETYPE_CHAR_ANY:\n+                    break;\n+                default:\n+                    fprintf(file, \"] \");\n+            }\n+        }\n+    }\n+    fprintf(file, \"\n\");\n+}\n+\n+//\n+// implementation\n+//\n+\n+uint32_t grammar_parser::get_symbol_id(const char * src, size_t len) {\n+    uint32_t next_id = static_cast<uint32_t>(symbol_ids.size());\n+    auto result = symbol_ids.emplace(std::string(src, len), next_id);\n+    return result.first->second;\n+}\n+\n+uint32_t grammar_parser::generate_symbol_id(const std::string & base_name) {\n+    uint32_t next_id = static_cast<uint32_t>(symbol_ids.size());\n+    symbol_ids[base_name + '_' + std::to_string(next_id)] = next_id;\n+    return next_id;\n+}\n+\n+void grammar_parser::add_rule(uint32_t rule_id, const grammar_rule & rule) {\n+    if (rules.size() <= rule_id) {\n+        rules.resize(rule_id + 1);\n+    }\n+    rules[rule_id] = rule;\n+}\n+\n+const char * grammar_parser::parse_alternates(\n+        const char        * src,\n+        const std::string & rule_name,\n+        uint32_t            rule_id,\n+        bool                is_nested) {\n+    grammar_rule rule;\n+    const char * pos = parse_sequence(src, rule_name, rule, is_nested);\n+    while (*pos == '|') {\n+        rule.push_back({GRETYPE_ALT, 0});\n+        pos = parse_space(pos + 1, true);\n+        pos = parse_sequence(pos, rule_name, rule, is_nested);\n+    }\n+    rule.push_back({GRETYPE_END, 0});\n+    add_rule(rule_id, rule);\n+    return pos;\n+}\n+\n+const char * grammar_parser::parse_sequence(\n+        const char         * src,\n+        const std::string  & rule_name,\n+        grammar_rule & rule,\n+        bool               is_nested) {\n+    size_t last_sym_start = rule.size();\n+    const char * pos = src;\n+\n+    auto handle_repetitions = [&](int min_times, int max_times) {\n+\n+        if (last_sym_start == rule.size()) {\n+            throw std::runtime_error(std::string(\"expecting preceding item to */+/?/{ at \") + pos);\n+        }\n+\n+        // apply transformation to previous symbol (last_sym_start to end) according to\n+        // the following rewrite rules:\n+        // S{m,n} --> S S S (m times) S'(n-m)\n+        //            S'(x)   ::= S S'(x-1) |\n+        //            (... n-m definitions of these S' rules ...)\n+        //            S'(1)   ::= S |\n+        // S{m,} -->  S S S (m times) S'\n+        //            S'     ::= S S' |\n+        // S*     --> S{0,}\n+        //        --> S'     ::= S S' |\n+        // S+     --> S{1,}\n+        //        --> S S'\n+        //            S'     ::= S S' |\n+        // S?     --> S{0,1}\n+        //        --> S'\n+        //            S'     ::= S |\n+\n+        grammar_rule prev_rule(rule.begin() + last_sym_start, rule.end());\n+        if (min_times == 0) {\n+            rule.resize(last_sym_start);\n+        } else {\n+            // Repeat the previous elements (min_times - 1) times\n+            for (int i = 1; i < min_times; i++) {\n+                rule.insert(rule.end(), prev_rule.begin(), prev_rule.end());\n+            }\n+        }\n+\n+        uint32_t last_rec_rule_id = 0;\n+        auto n_opt = max_times < 0 ? 1 : max_times - min_times;\n+\n+        grammar_rule rec_rule(prev_rule);\n+        for (int i = 0; i < n_opt; i++) {\n+            rec_rule.resize(prev_rule.size());\n+            uint32_t rec_rule_id = generate_symbol_id( rule_name);\n+            if (i > 0 || max_times < 0) {\n+                rec_rule.push_back({GRETYPE_RULE_REF, max_times < 0 ? rec_rule_id : last_rec_rule_id});\n+            }\n+            rec_rule.push_back({GRETYPE_ALT, 0});\n+            rec_rule.push_back({GRETYPE_END, 0});\n+            add_rule( rec_rule_id, rec_rule);\n+            last_rec_rule_id = rec_rule_id;\n+        }\n+        if (n_opt > 0) {\n+            rule.push_back({GRETYPE_RULE_REF, last_rec_rule_id});\n+        }\n+    };\n+\n+    while (*pos) {\n+        if (*pos == '\"') { // literal string\n+            pos++;\n+            last_sym_start = rule.size();\n+            while (*pos != '\"') {\n+                if (!*pos) {\n+                    throw std::runtime_error(\"unexpected end of input\");\n+                }\n+                auto char_pair = parse_char(pos);\n+                     pos       = char_pair.second;\n+                rule.push_back({GRETYPE_CHAR, char_pair.first});\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '[') { // char range(s)\n+            pos++;\n+            enum gretype start_type = GRETYPE_CHAR;\n+            if (*pos == '^') {\n+                pos++;\n+                start_type = GRETYPE_CHAR_NOT;\n+            }\n+            last_sym_start = rule.size();\n+            while (*pos != ']') {\n+                if (!*pos) {\n+                    throw std::runtime_error(\"unexpected end of input\");\n+                }\n+                auto char_pair = parse_char(pos);\n+                     pos       = char_pair.second;\n+                enum gretype type = last_sym_start < rule.size()\n+                    ? GRETYPE_CHAR_ALT\n+                    : start_type;\n+\n+                rule.push_back({type, char_pair.first});\n+                if (pos[0] == '-' && pos[1] != ']') {\n+                    if (!pos[1]) {\n+                        throw std::runtime_error(\"unexpected end of input\");\n+                    }\n+                    auto endchar_pair = parse_char(pos + 1);\n+                         pos          = endchar_pair.second;\n+                    rule.push_back({GRETYPE_CHAR_RNG_UPPER, endchar_pair.first});\n+                }\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (is_word_char(*pos)) { // rule reference\n+            const char * name_end    = parse_name(pos);\n+            uint32_t ref_rule_id = get_symbol_id(pos, name_end - pos);\n+            pos = parse_space(name_end, is_nested);\n+            last_sym_start = rule.size();\n+            rule.push_back({GRETYPE_RULE_REF, ref_rule_id});\n+        } else if (*pos == '(') { // grouping\n+            // parse nested alternates into synthesized rule\n+            pos = parse_space(pos + 1, true);\n+            uint32_t sub_rule_id = generate_symbol_id(rule_name);\n+            pos = parse_alternates(pos, rule_name, sub_rule_id, true);\n+            last_sym_start = rule.size();\n+            // output reference to synthesized rule\n+            rule.push_back({GRETYPE_RULE_REF, sub_rule_id});\n+            if (*pos != ')') {\n+                throw std::runtime_error(std::string(\"expecting ')' at \") + pos);\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '.') { // any char\n+            last_sym_start = rule.size();\n+            rule.push_back({GRETYPE_CHAR_ANY, 0});\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '*') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(0, -1);\n+        } else if (*pos == '+') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(1, -1);\n+        } else if (*pos == '?') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(0, 1);\n+        } else if (*pos == '{') {\n+            pos = parse_space(pos + 1, is_nested);\n+\n+            if (!is_digit_char(*pos)) {\n+                throw std::runtime_error(std::string(\"expecting an int at \") + pos);\n+            }\n+            const char * int_end = parse_int(pos);\n+            int min_times = std::stoul(std::string(pos, int_end - pos));\n+            pos = parse_space(int_end, is_nested);\n+\n+            int max_times = -1;\n+\n+            if (*pos == '}') {\n+                max_times = min_times;\n+                pos = parse_space(pos + 1, is_nested);\n+            } else if (*pos == ',') {\n+                pos = parse_space(pos + 1, is_nested);\n+\n+                if (is_digit_char(*pos)) {\n+                    const char * int_end = parse_int(pos);\n+                    max_times = std::stoul(std::string(pos, int_end - pos));\n+                    pos = parse_space(int_end, is_nested);\n+                }\n+\n+                if (*pos != '}') {\n+                    throw std::runtime_error(std::string(\"expecting '}' at \") + pos);\n+                }\n+                pos = parse_space(pos + 1, is_nested);\n+            } else {\n+                throw std::runtime_error(std::string(\"expecting ',' at \") + pos);\n+            }\n+            handle_repetitions(min_times, max_times);\n+        } else {\n+            break;\n+        }\n+    }\n+    return pos;\n+}\n+\n+const char * grammar_parser::parse_rule(const char * src) {\n+    const char * name_end = parse_name(src);\n+    const char * pos      = parse_space(name_end, false);\n+    size_t       name_len = name_end - src;\n+    uint32_t     rule_id  = get_symbol_id(src, name_len);\n+    const std::string name(src, name_len);\n+\n+    if (!(pos[0] == ':' && pos[1] == ':' && pos[2] == '=')) {\n+        throw std::runtime_error(std::string(\"expecting ::= at \") + pos);\n+    }\n+    pos = parse_space(pos + 3, true);\n+\n+    pos = parse_alternates(pos, name, rule_id, false);\n+\n+    if (*pos == '\\r') {\n+        pos += pos[1] == '\n' ? 2 : 1;\n+    } else if (*pos == '\n') {\n+        pos++;\n+    } else if (*pos) {\n+        throw std::runtime_error(std::string(\"expecting newline or end at \") + pos);\n+    }\n+    return parse_space(pos, true);\n+}\n+\n+bool grammar_parser::parse(const char * src) {\n+    try {\n+        const char * pos = parse_space(src, true);\n+        while (*pos) {\n+            pos = parse_rule(pos);\n+        }\n+        // Validate the state to ensure that all rules are defined\n+        for (const auto & rule : rules) {\n+            if (rule.empty()) {\n+                throw std::runtime_error(\"Undefined rule\");\n+            }\n+            for (const auto & elem : rule) {\n+                if (elem.type == GRETYPE_RULE_REF) {\n+                    // Ensure that the rule at that location exists\n+                    if (elem.value >= rules.size() || rules[elem.value].empty()) {\n+                        // Get the name of the rule that is missing\n+                        for (const auto & kv : symbol_ids) {\n+                            if (kv.second == elem.value) {\n+                                throw std::runtime_error(\"Undefined rule identifier '\" + kv.first + \"'\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    } catch (const std::exception & err) {\n+        fprintf(stderr, \"%s: error parsing grammar: %s\n\n%s\n\", __func__, err.what(), src);\n+        rules.clear();\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+void grammar_parser::print(FILE * file) {\n+    try {\n+        std::map<uint32_t, std::string> symbol_id_names;\n+        for (const auto & kv : symbol_ids) {\n+            symbol_id_names[kv.second] = kv.first;\n+        }\n+        for (size_t i = 0, end = rules.size(); i < end; i++) {\n+            // fprintf(file, \"%zu: \", i);\n+            // print_rule_binary(file, rules[i]);\n+            print_rule(file, uint32_t(i), rules[i], symbol_id_names);\n+            // fprintf(file, \"\n\");\n+        }\n+    } catch (const std::exception & err) {\n+        fprintf(stderr, \"\n%s: error printing grammar: %s\n\", __func__, err.what());\n+    }\n+}\n+\n+grammar_stack grammar_parser::c_rules() const {\n+    grammar_stack ret;\n+    ret.reserve(rules.size());\n+    \n+    // Only add non-empty rules\n+    for (const auto & rule : rules) {\n+        if (!rule.empty()) {\n+            ret.push_back(rule.data());\n+        } else {\n+            LLAMA_LOG_ERROR(\"empty rule found in grammar_parser::c_rules()\");\n+            return grammar_stack();  // Return empty stack on error\n+        }\n+    }\n+    \n+    if (ret.empty()) {\n+        LLAMA_LOG_ERROR(\"no valid rules found in grammar_parser::c_rules()\");\n+    }\n+    \n+    return ret;\n+}\n+\n+// returns true iff pos points to the end of one of the definitions of a rule\n+static bool grammar_is_end_of_sequence(const grammar_element * pos) {\n+    switch (pos->type) {\n+        case GRETYPE_END: return true;  // NOLINT\n+        case GRETYPE_ALT: return true;  // NOLINT\n+        default:                return false;\n+    }\n+}\n+\n+// returns true iff chr satisfies the char range at pos (regular or inverse range)\n+// asserts that pos is pointing to a char range element\n+static std::pair<bool, const grammar_element *> grammar_match_char(\n+        const grammar_element * pos,\n+        const uint32_t                chr) {\n+    bool found            = false;\n+    bool is_positive_char = pos->type == GRETYPE_CHAR || pos->type == GRETYPE_CHAR_ANY;\n+\n+    GGML_ASSERT(is_positive_char || pos->type == GRETYPE_CHAR_NOT); // NOLINT\n+\n+    do {\n+        if (pos[1].type == GRETYPE_CHAR_RNG_UPPER) {\n+            // inclusive range, e.g. [a-z]\n+            found = found || (pos->value <= chr && chr <= pos[1].value);\n+            pos += 2;\n+        } else if (pos->type == GRETYPE_CHAR_ANY) {\n+            // Any character matches \".\"\n+            found = true;\n+            pos += 1;\n+        } else {\n+            // exact char match, e.g. [a] or \"a\"\n+            found = found || pos->value == chr;\n+            pos += 1;\n+        }\n+    } while (pos->type == GRETYPE_CHAR_ALT);\n+\n+    return std::make_pair(found == is_positive_char, pos);\n+}\n+\n+// returns true iff some continuation of the given partial UTF-8 sequence could satisfy the char\n+// range at pos (regular or inverse range)\n+// asserts that pos is pointing to a char range element\n+static bool grammar_match_partial_char(\n+        const grammar_element * pos,\n+        const partial_utf8      partial_utf8) {\n+    bool is_positive_char = pos->type == GRETYPE_CHAR || pos->type == GRETYPE_CHAR_ANY;\n+    GGML_ASSERT(is_positive_char || pos->type == GRETYPE_CHAR_NOT);\n+\n+    uint32_t partial_value = partial_utf8.value;\n+    int      n_remain      = partial_utf8.n_remain;\n+\n+    // invalid sequence or 7-bit char split across 2 bytes (overlong)\n+    if (n_remain < 0 || (n_remain == 1 && partial_value < 2)) {\n+        return false;\n+    }\n+\n+    // range of possible code points this partial UTF-8 sequence could complete to\n+    uint32_t low  = partial_value << (n_remain * 6);\n+    uint32_t high = low | ((1 << (n_remain * 6)) - 1);\n+\n+    if (low == 0) {\n+        if (n_remain == 2) {\n+            low = 1 << 11;\n+        } else if (n_remain == 3) {\n+            low = 1 << 16;\n+        }\n+    }\n+\n+    do {\n+        if (pos[1].type == GRETYPE_CHAR_RNG_UPPER) {\n+            // inclusive range, e.g. [a-z]\n+            if (pos->value <= high && low <= pos[1].value) {\n+                return is_positive_char;\n+            }\n+            pos += 2;\n+        } else if (pos->type == GRETYPE_CHAR_ANY) {\n+            // Any character matches \".\"\n+            return true;\n+        } else {\n+            // exact char match, e.g. [a] or \"a\"\n+            if (low <= pos->value && pos->value <= high) {\n+                return is_positive_char;\n+            }\n+            pos += 1;\n+        }\n+    } while (pos->type == GRETYPE_CHAR_ALT);\n+\n+    return !is_positive_char;\n+}\n+\n+// transforms a grammar pushdown stack into N possible stacks, all ending\n+// at a character range (terminal element)\n+static void grammar_advance_stack(\n+        const grammar_rules  & rules,\n+        const grammar_stack  & stack,\n+              grammar_stacks & new_stacks) {\n+    if (stack.empty()) {\n+        if (std::find(new_stacks.begin(), new_stacks.end(), stack) == new_stacks.end()) {\n+            new_stacks.emplace_back(stack);\n+        }\n+        return;\n+    }\n+\n+    const grammar_element * pos = stack.back();\n+\n+    switch (pos->type) {\n+        case GRETYPE_RULE_REF: {\n+            const size_t             rule_id = static_cast<size_t>(pos->value);\n+            const grammar_element * subpos  = rules[rule_id].data();\n+            do {\n+                // init new stack without the top (pos)\n+                grammar_stack new_stack(stack.begin(), stack.end() - 1);\n+                if (!grammar_is_end_of_sequence(pos + 1)) {\n+                    // if this rule ref is followed by another element, add that to stack\n+                    new_stack.push_back(pos + 1);\n+                }\n+                if (!grammar_is_end_of_sequence(subpos)) {\n+                    // if alternate is nonempty, add to stack\n+                    new_stack.push_back(subpos);\n+                }\n+                grammar_advance_stack(rules, new_stack, new_stacks);\n+                while (!grammar_is_end_of_sequence(subpos)) {\n+                    // scan to end of alternate def\n+                    subpos++;\n+                }\n+                if (subpos->type == GRETYPE_ALT) {\n+                    // there's another alternate def of this rule to process\n+                    subpos++;\n+                } else {\n+                    break;\n+                }\n+            } while (true);\n+            break;\n+        }\n+        case GRETYPE_CHAR:\n+        case GRETYPE_CHAR_NOT:\n+        case GRETYPE_CHAR_ANY:\n+            if (std::find(new_stacks.begin(), new_stacks.end(), stack) == new_stacks.end()) {\n+                // only add the stack if it's not a duplicate of one we already have\n+                new_stacks.emplace_back(stack);\n+            }\n+            break;\n+        default:\n+            // end of alternate (GRETYPE_END, GRETYPE_ALT) or middle of char range\n+            // (GRETYPE_CHAR_ALT, GRETYPE_CHAR_RNG_UPPER); stack should never be left on\n+            // those\n+            GGML_ABORT(\"fatal error\");\n+    }\n+}\n+\n+static grammar_candidates grammar_reject_candidates(\n+        const grammar_rules      & rules,\n+        const grammar_stacks     & stacks,\n+        const grammar_candidates & candidates) {\n+    GGML_ASSERT(!stacks.empty()); // REVIEW\n+\n+    if (candidates.empty()) {\n+        return {};\n+    }\n+\n+    auto rejects = grammar_reject_candidates_for_stack(rules, stacks.front(), candidates);\n+\n+    for (size_t i = 1, size = stacks.size(); i < size; ++i) {\n+        rejects = grammar_reject_candidates_for_stack(rules, stacks[i], rejects);\n+    }\n+\n+    return rejects;\n+}\n+\n+static bool grammar_detect_left_recursion(\n+        const grammar_rules & rules,\n+        size_t rule_index,\n+        std::vector<bool> * rules_visited,\n+        std::vector<bool> * rules_in_progress,\n+        std::vector<bool> * rules_may_be_empty) {\n+    if ((*rules_in_progress)[rule_index]) {\n+        return true;\n+    }\n+\n+    (*rules_in_progress)[rule_index] = true;\n+\n+    const grammar_rule & rule = rules[rule_index];\n+\n+    // First check if the rule might produce the empty string. This could be done combined with the second\n+    // step but it's more readable as two steps.\n+    bool at_rule_start = true;\n+    for (size_t i = 0; i < rule.size(); i++) {\n+        if (grammar_is_end_of_sequence(&rule[i])) {\n+            if (at_rule_start) {\n+                (*rules_may_be_empty)[rule_index] = true;\n+                break;\n+            }\n+            at_rule_start = true;\n+        } else {\n+            at_rule_start = false;\n+        }\n+    }\n+\n+    // Second, recurse into leftmost nonterminals (or next-leftmost as long as the previous nonterminal may\n+    // be empty)\n+    bool recurse_into_nonterminal = true;\n+    for (size_t i = 0; i < rule.size(); i++) {\n+        if (rule[i].type == GRETYPE_RULE_REF && recurse_into_nonterminal) {\n+            if (grammar_detect_left_recursion(rules, (size_t)rule[i].value, rules_visited, rules_in_progress, rules_may_be_empty)) {\n+                return true;\n+            }\n+            if (!((*rules_may_be_empty)[(size_t)rule[i].value])) {\n+                recurse_into_nonterminal = false;\n+            }\n+        } else if (grammar_is_end_of_sequence(&rule[i])) {\n+            recurse_into_nonterminal = true;\n+        } else {\n+            recurse_into_nonterminal = false;\n+        }\n+    }\n+\n+    (*rules_in_progress)[rule_index] = false;\n+    (*rules_visited)[rule_index] = true;\n+\n+    return false;\n+}\n+\n+const grammar_rules & grammar_get_rules(const struct grammar * grammar) {\n+    return grammar->rules;\n+}\n+\n+grammar_stacks & grammar_get_stacks(struct grammar * grammar) {\n+    return grammar->stacks;\n+}\n+\n+void grammar_accept(struct grammar * grammar, uint32_t chr) {\n+    grammar_stacks stacks_new;\n+    stacks_new.reserve(grammar->stacks.size());\n+\n+    for (const auto & stack : grammar->stacks) {\n+        if (stack.empty()) {\n+            continue;\n+        }\n+\n+        auto match = grammar_match_char(stack.back(), chr);\n+        if (match.first) {\n+            const grammar_element * pos = match.second;\n+\n+            // update top of stack to next element, if any\n+            grammar_stack new_stack(stack.begin(), stack.end() - 1);\n+            if (!grammar_is_end_of_sequence(pos)) {\n+                new_stack.push_back(pos);\n+            }\n+            grammar_advance_stack(grammar->rules, new_stack, stacks_new);\n+        }\n+    }\n+\n+    grammar->stacks = std::move(stacks_new);\n+}\n+\n+grammar_candidates grammar_reject_candidates_for_stack(\n+        const grammar_rules      & rules,\n+        const grammar_stack      & stack,\n+        const grammar_candidates & candidates) {\n+\n+    grammar_candidates rejects;\n+    rejects.reserve(candidates.size());\n+\n+    if (stack.empty()) {\n+        for (const auto & tok : candidates) {\n+            if (*tok.code_points != 0 || tok.utf8_state.n_remain != 0) {\n+                rejects.push_back(tok);\n+            }\n+        }\n+        return rejects;\n+    }\n+\n+    const grammar_element * stack_pos = stack.back();\n+\n+    grammar_candidates next_candidates;\n+    next_candidates.reserve(candidates.size());\n+\n+    for (const auto & tok : candidates) {\n+        if (*tok.code_points == 0) {\n+            // reached end of full codepoints in token, reject iff it ended in a partial sequence\n+            // that cannot satisfy this position in grammar\n+            if (tok.utf8_state.n_remain != 0 &&\n+                    !grammar_match_partial_char(stack_pos, tok.utf8_state)) {\n+                rejects.push_back(tok);\n+            }\n+        } else if (grammar_match_char(stack_pos, *tok.code_points).first) {\n+            next_candidates.push_back({ tok.index, tok.code_points + 1, tok.utf8_state });\n+        } else {\n+            rejects.push_back(tok);\n+        }\n+    }\n+\n+    const auto * stack_pos_after = grammar_match_char(stack_pos, 0).second;\n+\n+    // update top of stack to next element, if any\n+    grammar_stack stack_after(stack.begin(), stack.end() - 1);\n+    if (!grammar_is_end_of_sequence(stack_pos_after)) {\n+        stack_after.push_back(stack_pos_after);\n+    }\n+    grammar_stacks next_stacks;\n+    grammar_advance_stack(rules, stack_after, next_stacks);\n+\n+    auto next_rejects = grammar_reject_candidates(rules, next_stacks, next_candidates);\n+    for (const auto & tok : next_rejects) {\n+        rejects.push_back({ tok.index, tok.code_points - 1, tok.utf8_state });\n+    }\n+\n+    return rejects;\n+}\n+\n+////////////////////\n+\n+struct grammar * grammar_init_impl(\n+        struct ollama_vocab * ollama_vocab,\n+        const grammar_element ** rules,\n+        size_t n_rules,\n+        size_t start_rule_index) {\n+    const grammar_element * pos;\n+\n+    // copy rule definitions into vectors\n+    grammar_rules vec_rules(n_rules);\n+    for (size_t i = 0; i < n_rules; i++) {\n+        for (pos = rules[i]; pos->type != GRETYPE_END; pos++) {\n+            vec_rules[i].push_back(*pos);\n+        }\n+        vec_rules[i].push_back({GRETYPE_END, 0});\n+    }\n+\n+    // Check for left recursion\n+    std::vector<bool> rules_visited(n_rules);\n+    std::vector<bool> rules_in_progress(n_rules);\n+    std::vector<bool> rules_may_be_empty(n_rules);\n+    for (size_t i = 0; i < n_rules; i++) {\n+        if (rules_visited[i]) {\n+            continue;\n+        }\n+        if (grammar_detect_left_recursion(vec_rules, i, &rules_visited, &rules_in_progress, &rules_may_be_empty)) {\n+            LLAMA_LOG_ERROR(\"unsupported grammar, left recursion detected for nonterminal at index %zu\", i);\n+            return nullptr;\n+        }\n+    }\n+\n+    // loop over alternates of start rule to build initial stacks\n+    grammar_stacks stacks;\n+    pos = vec_rules[start_rule_index].data();\n+    do {\n+        grammar_stack stack;\n+        if (!grammar_is_end_of_sequence(pos)) {\n+            // if alternate is nonempty, add to stack\n+            stack.push_back(pos);\n+        }\n+        grammar_advance_stack(vec_rules, stack, stacks);\n+        while (!grammar_is_end_of_sequence(pos)) {\n+            // scan to end of alternate def\n+            pos++;\n+        }\n+        if (pos->type == GRETYPE_ALT) {\n+            // there's another alternate def of this rule to process\n+            pos++;\n+        } else {\n+            break;\n+        }\n+    } while (true);\n+\n+    // Important: vec_rules has to be moved here, not copied, because stacks contains\n+    // pointers to elements of vec_rules. If vec_rules were copied into grammar\n+    // then the pointers would be invalidated when the local vec_rules goes out of scope.\n+    return new grammar {\n+        ollama_vocab,\n+        std::move(vec_rules),\n+        std::move(stacks),\n+        /* .partial_utf8 = */     {},\n+        /* .lazy =*/              false,\n+        /* .awaiting_trigger = */ false,\n+        /* .trigger_buffer = */   \"\",\n+        /* .trigger_tokens   = */ {},\n+        /* .trigger_words    = */ {},\n+    };\n+}\n+\n+struct grammar * grammar_init_impl(\n+                    struct ollama_vocab * ollama_vocab,\n+                      const char * grammar_str,\n+                      const char * grammar_root,\n+                              bool lazy,\n+                     const char ** trigger_words,\n+                            size_t num_trigger_words,\n+               const llama_token * trigger_tokens,\n+                            size_t num_trigger_tokens) {\n+    grammar_parser parser;\n+\n+    // if there is a grammar, parse it\n+    if (!parser.parse(grammar_str)) {\n+        LLAMA_LOG_ERROR(\"failed to parse grammar\");\n+        return nullptr;\n+    }\n+\n+    // will be empty (default) if there are parse errors\n+    if (parser.rules.empty()) {\n+        fprintf(stderr, \"%s: failed to parse grammar\n\", __func__);\n+        return nullptr;\n+    }\n+\n+    // Ensure that there is a \"root\" node.\n+    if (parser.symbol_ids.find(\"root\") == parser.symbol_ids.end()) {\n+        fprintf(stderr, \"%s: grammar does not contain a 'root' symbol\n\", __func__);\n+        return nullptr;\n+    }\n+\n+    std::vector<const grammar_element *> grammar_rules_vec(parser.c_rules());\n+\n+    const size_t n_rules = grammar_rules_vec.size();\n+    const size_t start_rule_index = parser.symbol_ids.at(grammar_root);\n+\n+    const grammar_element * pos;\n+\n+    // copy rule definitions into vectors\n+    grammar_rules vec_rules;\n+    vec_rules.resize(n_rules);  // Pre-allocate space for all rules\n+    \n+    for (size_t i = 0; i < n_rules; i++) {\n+        if (grammar_rules_vec[i] == nullptr) {\n+            LLAMA_LOG_ERROR(\"null rule pointer at index %zu\", i);\n+            return nullptr;\n+        }\n+        \n+        // Reserve space for the rule to avoid reallocation\n+        vec_rules[i].reserve(16);  // Start with reasonable capacity",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2027531977",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10096,
        "pr_file": "llama/grammar.cpp",
        "discussion_id": "2027531977",
        "commented_code": "@@ -0,0 +1,1261 @@\n+// #include \"llama-grammar.h\"\n+#include \"grammar.h\"\n+\n+#include \"llama-impl.h\"\n+// #include \"llama-vocab.h\"\n+// #include \"llama-sampling.h\"\n+\n+#include <cmath>\n+#include <algorithm>\n+#include <stdexcept>\n+\n+//\n+// helpers\n+//\n+\n+// NOTE: assumes valid utf8 (but checks for overrun)\n+static std::pair<uint32_t, const char *> decode_utf8(const char * src) {\n+    static const int lookup[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4 };\n+    uint8_t  first_byte = static_cast<uint8_t>(*src);\n+    uint8_t  highbits   = first_byte >> 4;\n+    int      len        = lookup[highbits];\n+    uint8_t  mask       = (1 << (8 - len)) - 1;\n+    uint32_t value      = first_byte & mask;\n+    const char * end    = src + len; // may overrun!\n+    const char * pos    = src + 1;\n+    for ( ; pos < end && *pos; pos++) {\n+        value = (value << 6) + (static_cast<uint8_t>(*pos) & 0x3F);\n+    }\n+    return std::make_pair(value, pos);\n+}\n+\n+static std::pair<std::vector<uint32_t>, partial_utf8> decode_utf8(\n+        const std::string & src,\n+        partial_utf8 partial_start) {\n+    static const int      lookup[] = { 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 4 };\n+    const char          * pos      = src.c_str();\n+    std::vector<uint32_t> code_points;\n+\n+    // common english strings have the same number of codepoints and bytes. `+ 1` for the terminating 0.\n+    code_points.reserve(src.size() + 1);\n+    uint32_t value    = partial_start.value;\n+    int      n_remain = partial_start.n_remain;\n+\n+    // continue previous decode, if applicable\n+    while (*pos != 0 && n_remain > 0) {\n+        uint8_t next_byte = static_cast<uint8_t>(*pos);\n+        if ((next_byte >> 6) != 2) {\n+            // invalid sequence, abort\n+            code_points.push_back(0);\n+            return std::make_pair(std::move(code_points), partial_utf8{ 0, -1 });\n+        }\n+        value = (value << 6) + (next_byte & 0x3F);\n+        ++pos;\n+        --n_remain;\n+    }\n+\n+    if (partial_start.n_remain > 0 && n_remain == 0) {\n+        code_points.push_back(value);\n+    }\n+\n+    // decode any subsequent utf-8 sequences, which may end in an incomplete one\n+    while (*pos != 0) {\n+        uint8_t first_byte = static_cast<uint8_t>(*pos);\n+        uint8_t highbits   = first_byte >> 4;\n+        n_remain   = lookup[highbits] - 1;\n+\n+        if (n_remain < 0) {\n+            // invalid sequence, abort\n+            code_points.clear();\n+            code_points.push_back(0);\n+            return std::make_pair(std::move(code_points), partial_utf8{ 0, n_remain });\n+        }\n+\n+        uint8_t mask  = (1 << (7 - n_remain)) - 1;\n+        value = first_byte & mask;\n+\n+        ++pos;\n+        while (*pos != 0 && n_remain > 0) {\n+            value = (value << 6) + (static_cast<uint8_t>(*pos) & 0x3F);\n+            ++pos;\n+            --n_remain;\n+        }\n+        if (n_remain == 0) {\n+            code_points.push_back(value);\n+        }\n+    }\n+    code_points.push_back(0);\n+\n+    return std::make_pair(std::move(code_points), partial_utf8{ value, n_remain });\n+}\n+\n+static bool is_digit_char(char c) {\n+    return '0' <= c && c <= '9';\n+}\n+\n+static bool is_word_char(char c) {\n+    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '-' || is_digit_char(c);\n+}\n+\n+static std::pair<uint32_t, const char *> parse_hex(const char * src, int size) {\n+    const char * pos   = src;\n+    const char * end   = src + size;\n+    uint32_t     value = 0;\n+    for ( ; pos < end && *pos; pos++) {\n+        value <<= 4;\n+        char c = *pos;\n+        if ('a' <= c && c <= 'f') {\n+            value += c - 'a' + 10;\n+        } else if ('A' <= c && c <= 'F') {\n+            value += c - 'A' + 10;\n+        } else if ('0' <= c && c <= '9') {\n+            value += c - '0';\n+        } else {\n+            break;\n+        }\n+    }\n+    if (pos != end) {\n+        throw std::runtime_error(\"expecting \" + std::to_string(size) + \" hex chars at \" + src);\n+    }\n+    return std::make_pair(value, pos);\n+}\n+\n+static const char * parse_space(const char * src, bool newline_ok) {\n+    const char * pos = src;\n+    while (*pos == ' ' || *pos == '\\t' || *pos == '#' ||\n+            (newline_ok && (*pos == '\\r' || *pos == '\\n'))) {\n+        if (*pos == '#') {\n+            while (*pos && *pos != '\\r' && *pos != '\\n') {\n+                pos++;\n+            }\n+        } else {\n+            pos++;\n+        }\n+    }\n+    return pos;\n+}\n+\n+static const char * parse_name(const char * src) {\n+    const char * pos = src;\n+    while (is_word_char(*pos)) {\n+        pos++;\n+    }\n+    if (pos == src) {\n+        throw std::runtime_error(std::string(\"expecting name at \") + src);\n+    }\n+    return pos;\n+}\n+\n+static const char * parse_int(const char * src) {\n+    const char * pos = src;\n+    while (is_digit_char(*pos)) {\n+        pos++;\n+    }\n+    if (pos == src) {\n+        throw std::runtime_error(std::string(\"expecting integer at \") + src);\n+    }\n+    return pos;\n+}\n+\n+static std::pair<uint32_t, const char *> parse_char(const char * src) {\n+    if (*src == '\\\\') {\n+        switch (src[1]) {\n+            case 'x': return parse_hex(src + 2, 2);\n+            case 'u': return parse_hex(src + 2, 4);\n+            case 'U': return parse_hex(src + 2, 8);\n+            case 't': return std::make_pair('\\t', src + 2);\n+            case 'r': return std::make_pair('\\r', src + 2);\n+            case 'n': return std::make_pair('\\n', src + 2);\n+            case '\\\\':\n+            case '\"':\n+            case '[':\n+            case ']':\n+                      return std::make_pair(src[1], src + 2);\n+            default:\n+                      throw std::runtime_error(std::string(\"unknown escape at \") + src);\n+        }\n+    } else if (*src) {\n+        return decode_utf8(src);\n+    }\n+    throw std::runtime_error(\"unexpected end of input\");\n+}\n+\n+static void print_grammar_char(FILE * file, uint32_t c) {\n+    if (0x20 <= c && c <= 0x7f) {\n+        fprintf(file, \"%c\", static_cast<char>(c));\n+    } else {\n+        // cop out of encoding UTF-8\n+        fprintf(file, \"<U+%04X>\", c);\n+    }\n+}\n+\n+static bool is_char_element(grammar_element elem) {\n+    switch (elem.type) {\n+        case GRETYPE_CHAR:           return true;\n+        case GRETYPE_CHAR_NOT:       return true;\n+        case GRETYPE_CHAR_ALT:       return true;\n+        case GRETYPE_CHAR_RNG_UPPER: return true;\n+        case GRETYPE_CHAR_ANY:       return true;\n+        default:                           return false;\n+    }\n+}\n+\n+static void print_rule_binary(FILE * file, const grammar_rule & rule) {\n+    for (auto elem : rule) {\n+        switch (elem.type) {\n+            case GRETYPE_END:            fprintf(file, \"END\");            break;\n+            case GRETYPE_ALT:            fprintf(file, \"ALT\");            break;\n+            case GRETYPE_RULE_REF:       fprintf(file, \"RULE_REF\");       break;\n+            case GRETYPE_CHAR:           fprintf(file, \"CHAR\");           break;\n+            case GRETYPE_CHAR_NOT:       fprintf(file, \"CHAR_NOT\");       break;\n+            case GRETYPE_CHAR_RNG_UPPER: fprintf(file, \"CHAR_RNG_UPPER\"); break;\n+            case GRETYPE_CHAR_ALT:       fprintf(file, \"CHAR_ALT\");       break;\n+            case GRETYPE_CHAR_ANY:       fprintf(file, \"CHAR_ANY\");       break;\n+        }\n+        switch (elem.type) {\n+            case GRETYPE_END:\n+            case GRETYPE_ALT:\n+            case GRETYPE_RULE_REF:\n+                fprintf(file, \"(%u) \", elem.value);\n+                break;\n+            case GRETYPE_CHAR:\n+            case GRETYPE_CHAR_NOT:\n+            case GRETYPE_CHAR_RNG_UPPER:\n+            case GRETYPE_CHAR_ALT:\n+            case GRETYPE_CHAR_ANY:\n+                fprintf(file, \"(\\\"\");\n+                print_grammar_char(file, elem.value);\n+                fprintf(file, \"\\\") \");\n+                break;\n+        }\n+    }\n+    fprintf(file, \"\\n\");\n+}\n+\n+static void print_rule(\n+        FILE     * file,\n+        uint32_t   rule_id,\n+        const grammar_rule & rule,\n+        const std::map<uint32_t, std::string> & symbol_id_names) {\n+    if (rule.empty() || rule.back().type != GRETYPE_END) {\n+        throw std::runtime_error(\n+            \"malformed rule, does not end with GRETYPE_END: \" + std::to_string(rule_id));\n+    }\n+    fprintf(file, \"%s ::= \", symbol_id_names.at(rule_id).c_str());\n+    for (size_t i = 0, end = rule.size() - 1; i < end; i++) {\n+        grammar_element elem = rule[i];\n+        switch (elem.type) {\n+            case GRETYPE_END:\n+                throw std::runtime_error(\n+                    \"unexpected end of rule: \" + std::to_string(rule_id) + \",\" +\n+                    std::to_string(i));\n+            case GRETYPE_ALT:\n+                fprintf(file, \"| \");\n+                break;\n+            case GRETYPE_RULE_REF:\n+                fprintf(file, \"%s \", symbol_id_names.at(elem.value).c_str());\n+                break;\n+            case GRETYPE_CHAR:\n+                fprintf(file, \"[\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_NOT:\n+                fprintf(file, \"[^\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_RNG_UPPER:\n+                if (i == 0 || !is_char_element(rule[i - 1])) {\n+                    throw std::runtime_error(\n+                        \"GRETYPE_CHAR_RNG_UPPER without preceding char: \" +\n+                        std::to_string(rule_id) + \",\" + std::to_string(i));\n+                }\n+                fprintf(file, \"-\");\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_ALT:\n+                if (i == 0 || !is_char_element(rule[i - 1])) {\n+                    throw std::runtime_error(\n+                        \"GRETYPE_CHAR_ALT without preceding char: \" +\n+                        std::to_string(rule_id) + \",\" + std::to_string(i));\n+                }\n+                print_grammar_char(file, elem.value);\n+                break;\n+            case GRETYPE_CHAR_ANY:\n+                fprintf(file, \".\");\n+                break;\n+        }\n+        if (is_char_element(elem)) {\n+            switch (rule[i + 1].type) {\n+                case GRETYPE_CHAR_ALT:\n+                case GRETYPE_CHAR_RNG_UPPER:\n+                case GRETYPE_CHAR_ANY:\n+                    break;\n+                default:\n+                    fprintf(file, \"] \");\n+            }\n+        }\n+    }\n+    fprintf(file, \"\\n\");\n+}\n+\n+//\n+// implementation\n+//\n+\n+uint32_t grammar_parser::get_symbol_id(const char * src, size_t len) {\n+    uint32_t next_id = static_cast<uint32_t>(symbol_ids.size());\n+    auto result = symbol_ids.emplace(std::string(src, len), next_id);\n+    return result.first->second;\n+}\n+\n+uint32_t grammar_parser::generate_symbol_id(const std::string & base_name) {\n+    uint32_t next_id = static_cast<uint32_t>(symbol_ids.size());\n+    symbol_ids[base_name + '_' + std::to_string(next_id)] = next_id;\n+    return next_id;\n+}\n+\n+void grammar_parser::add_rule(uint32_t rule_id, const grammar_rule & rule) {\n+    if (rules.size() <= rule_id) {\n+        rules.resize(rule_id + 1);\n+    }\n+    rules[rule_id] = rule;\n+}\n+\n+const char * grammar_parser::parse_alternates(\n+        const char        * src,\n+        const std::string & rule_name,\n+        uint32_t            rule_id,\n+        bool                is_nested) {\n+    grammar_rule rule;\n+    const char * pos = parse_sequence(src, rule_name, rule, is_nested);\n+    while (*pos == '|') {\n+        rule.push_back({GRETYPE_ALT, 0});\n+        pos = parse_space(pos + 1, true);\n+        pos = parse_sequence(pos, rule_name, rule, is_nested);\n+    }\n+    rule.push_back({GRETYPE_END, 0});\n+    add_rule(rule_id, rule);\n+    return pos;\n+}\n+\n+const char * grammar_parser::parse_sequence(\n+        const char         * src,\n+        const std::string  & rule_name,\n+        grammar_rule & rule,\n+        bool               is_nested) {\n+    size_t last_sym_start = rule.size();\n+    const char * pos = src;\n+\n+    auto handle_repetitions = [&](int min_times, int max_times) {\n+\n+        if (last_sym_start == rule.size()) {\n+            throw std::runtime_error(std::string(\"expecting preceding item to */+/?/{ at \") + pos);\n+        }\n+\n+        // apply transformation to previous symbol (last_sym_start to end) according to\n+        // the following rewrite rules:\n+        // S{m,n} --> S S S (m times) S'(n-m)\n+        //            S'(x)   ::= S S'(x-1) |\n+        //            (... n-m definitions of these S' rules ...)\n+        //            S'(1)   ::= S |\n+        // S{m,} -->  S S S (m times) S'\n+        //            S'     ::= S S' |\n+        // S*     --> S{0,}\n+        //        --> S'     ::= S S' |\n+        // S+     --> S{1,}\n+        //        --> S S'\n+        //            S'     ::= S S' |\n+        // S?     --> S{0,1}\n+        //        --> S'\n+        //            S'     ::= S |\n+\n+        grammar_rule prev_rule(rule.begin() + last_sym_start, rule.end());\n+        if (min_times == 0) {\n+            rule.resize(last_sym_start);\n+        } else {\n+            // Repeat the previous elements (min_times - 1) times\n+            for (int i = 1; i < min_times; i++) {\n+                rule.insert(rule.end(), prev_rule.begin(), prev_rule.end());\n+            }\n+        }\n+\n+        uint32_t last_rec_rule_id = 0;\n+        auto n_opt = max_times < 0 ? 1 : max_times - min_times;\n+\n+        grammar_rule rec_rule(prev_rule);\n+        for (int i = 0; i < n_opt; i++) {\n+            rec_rule.resize(prev_rule.size());\n+            uint32_t rec_rule_id = generate_symbol_id( rule_name);\n+            if (i > 0 || max_times < 0) {\n+                rec_rule.push_back({GRETYPE_RULE_REF, max_times < 0 ? rec_rule_id : last_rec_rule_id});\n+            }\n+            rec_rule.push_back({GRETYPE_ALT, 0});\n+            rec_rule.push_back({GRETYPE_END, 0});\n+            add_rule( rec_rule_id, rec_rule);\n+            last_rec_rule_id = rec_rule_id;\n+        }\n+        if (n_opt > 0) {\n+            rule.push_back({GRETYPE_RULE_REF, last_rec_rule_id});\n+        }\n+    };\n+\n+    while (*pos) {\n+        if (*pos == '\"') { // literal string\n+            pos++;\n+            last_sym_start = rule.size();\n+            while (*pos != '\"') {\n+                if (!*pos) {\n+                    throw std::runtime_error(\"unexpected end of input\");\n+                }\n+                auto char_pair = parse_char(pos);\n+                     pos       = char_pair.second;\n+                rule.push_back({GRETYPE_CHAR, char_pair.first});\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '[') { // char range(s)\n+            pos++;\n+            enum gretype start_type = GRETYPE_CHAR;\n+            if (*pos == '^') {\n+                pos++;\n+                start_type = GRETYPE_CHAR_NOT;\n+            }\n+            last_sym_start = rule.size();\n+            while (*pos != ']') {\n+                if (!*pos) {\n+                    throw std::runtime_error(\"unexpected end of input\");\n+                }\n+                auto char_pair = parse_char(pos);\n+                     pos       = char_pair.second;\n+                enum gretype type = last_sym_start < rule.size()\n+                    ? GRETYPE_CHAR_ALT\n+                    : start_type;\n+\n+                rule.push_back({type, char_pair.first});\n+                if (pos[0] == '-' && pos[1] != ']') {\n+                    if (!pos[1]) {\n+                        throw std::runtime_error(\"unexpected end of input\");\n+                    }\n+                    auto endchar_pair = parse_char(pos + 1);\n+                         pos          = endchar_pair.second;\n+                    rule.push_back({GRETYPE_CHAR_RNG_UPPER, endchar_pair.first});\n+                }\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (is_word_char(*pos)) { // rule reference\n+            const char * name_end    = parse_name(pos);\n+            uint32_t ref_rule_id = get_symbol_id(pos, name_end - pos);\n+            pos = parse_space(name_end, is_nested);\n+            last_sym_start = rule.size();\n+            rule.push_back({GRETYPE_RULE_REF, ref_rule_id});\n+        } else if (*pos == '(') { // grouping\n+            // parse nested alternates into synthesized rule\n+            pos = parse_space(pos + 1, true);\n+            uint32_t sub_rule_id = generate_symbol_id(rule_name);\n+            pos = parse_alternates(pos, rule_name, sub_rule_id, true);\n+            last_sym_start = rule.size();\n+            // output reference to synthesized rule\n+            rule.push_back({GRETYPE_RULE_REF, sub_rule_id});\n+            if (*pos != ')') {\n+                throw std::runtime_error(std::string(\"expecting ')' at \") + pos);\n+            }\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '.') { // any char\n+            last_sym_start = rule.size();\n+            rule.push_back({GRETYPE_CHAR_ANY, 0});\n+            pos = parse_space(pos + 1, is_nested);\n+        } else if (*pos == '*') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(0, -1);\n+        } else if (*pos == '+') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(1, -1);\n+        } else if (*pos == '?') {\n+            pos = parse_space(pos + 1, is_nested);\n+            handle_repetitions(0, 1);\n+        } else if (*pos == '{') {\n+            pos = parse_space(pos + 1, is_nested);\n+\n+            if (!is_digit_char(*pos)) {\n+                throw std::runtime_error(std::string(\"expecting an int at \") + pos);\n+            }\n+            const char * int_end = parse_int(pos);\n+            int min_times = std::stoul(std::string(pos, int_end - pos));\n+            pos = parse_space(int_end, is_nested);\n+\n+            int max_times = -1;\n+\n+            if (*pos == '}') {\n+                max_times = min_times;\n+                pos = parse_space(pos + 1, is_nested);\n+            } else if (*pos == ',') {\n+                pos = parse_space(pos + 1, is_nested);\n+\n+                if (is_digit_char(*pos)) {\n+                    const char * int_end = parse_int(pos);\n+                    max_times = std::stoul(std::string(pos, int_end - pos));\n+                    pos = parse_space(int_end, is_nested);\n+                }\n+\n+                if (*pos != '}') {\n+                    throw std::runtime_error(std::string(\"expecting '}' at \") + pos);\n+                }\n+                pos = parse_space(pos + 1, is_nested);\n+            } else {\n+                throw std::runtime_error(std::string(\"expecting ',' at \") + pos);\n+            }\n+            handle_repetitions(min_times, max_times);\n+        } else {\n+            break;\n+        }\n+    }\n+    return pos;\n+}\n+\n+const char * grammar_parser::parse_rule(const char * src) {\n+    const char * name_end = parse_name(src);\n+    const char * pos      = parse_space(name_end, false);\n+    size_t       name_len = name_end - src;\n+    uint32_t     rule_id  = get_symbol_id(src, name_len);\n+    const std::string name(src, name_len);\n+\n+    if (!(pos[0] == ':' && pos[1] == ':' && pos[2] == '=')) {\n+        throw std::runtime_error(std::string(\"expecting ::= at \") + pos);\n+    }\n+    pos = parse_space(pos + 3, true);\n+\n+    pos = parse_alternates(pos, name, rule_id, false);\n+\n+    if (*pos == '\\r') {\n+        pos += pos[1] == '\\n' ? 2 : 1;\n+    } else if (*pos == '\\n') {\n+        pos++;\n+    } else if (*pos) {\n+        throw std::runtime_error(std::string(\"expecting newline or end at \") + pos);\n+    }\n+    return parse_space(pos, true);\n+}\n+\n+bool grammar_parser::parse(const char * src) {\n+    try {\n+        const char * pos = parse_space(src, true);\n+        while (*pos) {\n+            pos = parse_rule(pos);\n+        }\n+        // Validate the state to ensure that all rules are defined\n+        for (const auto & rule : rules) {\n+            if (rule.empty()) {\n+                throw std::runtime_error(\"Undefined rule\");\n+            }\n+            for (const auto & elem : rule) {\n+                if (elem.type == GRETYPE_RULE_REF) {\n+                    // Ensure that the rule at that location exists\n+                    if (elem.value >= rules.size() || rules[elem.value].empty()) {\n+                        // Get the name of the rule that is missing\n+                        for (const auto & kv : symbol_ids) {\n+                            if (kv.second == elem.value) {\n+                                throw std::runtime_error(\"Undefined rule identifier '\" + kv.first + \"'\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    } catch (const std::exception & err) {\n+        fprintf(stderr, \"%s: error parsing grammar: %s\\n\\n%s\\n\", __func__, err.what(), src);\n+        rules.clear();\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+void grammar_parser::print(FILE * file) {\n+    try {\n+        std::map<uint32_t, std::string> symbol_id_names;\n+        for (const auto & kv : symbol_ids) {\n+            symbol_id_names[kv.second] = kv.first;\n+        }\n+        for (size_t i = 0, end = rules.size(); i < end; i++) {\n+            // fprintf(file, \"%zu: \", i);\n+            // print_rule_binary(file, rules[i]);\n+            print_rule(file, uint32_t(i), rules[i], symbol_id_names);\n+            // fprintf(file, \"\\n\");\n+        }\n+    } catch (const std::exception & err) {\n+        fprintf(stderr, \"\\n%s: error printing grammar: %s\\n\", __func__, err.what());\n+    }\n+}\n+\n+grammar_stack grammar_parser::c_rules() const {\n+    grammar_stack ret;\n+    ret.reserve(rules.size());\n+    \n+    // Only add non-empty rules\n+    for (const auto & rule : rules) {\n+        if (!rule.empty()) {\n+            ret.push_back(rule.data());\n+        } else {\n+            LLAMA_LOG_ERROR(\"empty rule found in grammar_parser::c_rules()\");\n+            return grammar_stack();  // Return empty stack on error\n+        }\n+    }\n+    \n+    if (ret.empty()) {\n+        LLAMA_LOG_ERROR(\"no valid rules found in grammar_parser::c_rules()\");\n+    }\n+    \n+    return ret;\n+}\n+\n+// returns true iff pos points to the end of one of the definitions of a rule\n+static bool grammar_is_end_of_sequence(const grammar_element * pos) {\n+    switch (pos->type) {\n+        case GRETYPE_END: return true;  // NOLINT\n+        case GRETYPE_ALT: return true;  // NOLINT\n+        default:                return false;\n+    }\n+}\n+\n+// returns true iff chr satisfies the char range at pos (regular or inverse range)\n+// asserts that pos is pointing to a char range element\n+static std::pair<bool, const grammar_element *> grammar_match_char(\n+        const grammar_element * pos,\n+        const uint32_t                chr) {\n+    bool found            = false;\n+    bool is_positive_char = pos->type == GRETYPE_CHAR || pos->type == GRETYPE_CHAR_ANY;\n+\n+    GGML_ASSERT(is_positive_char || pos->type == GRETYPE_CHAR_NOT); // NOLINT\n+\n+    do {\n+        if (pos[1].type == GRETYPE_CHAR_RNG_UPPER) {\n+            // inclusive range, e.g. [a-z]\n+            found = found || (pos->value <= chr && chr <= pos[1].value);\n+            pos += 2;\n+        } else if (pos->type == GRETYPE_CHAR_ANY) {\n+            // Any character matches \".\"\n+            found = true;\n+            pos += 1;\n+        } else {\n+            // exact char match, e.g. [a] or \"a\"\n+            found = found || pos->value == chr;\n+            pos += 1;\n+        }\n+    } while (pos->type == GRETYPE_CHAR_ALT);\n+\n+    return std::make_pair(found == is_positive_char, pos);\n+}\n+\n+// returns true iff some continuation of the given partial UTF-8 sequence could satisfy the char\n+// range at pos (regular or inverse range)\n+// asserts that pos is pointing to a char range element\n+static bool grammar_match_partial_char(\n+        const grammar_element * pos,\n+        const partial_utf8      partial_utf8) {\n+    bool is_positive_char = pos->type == GRETYPE_CHAR || pos->type == GRETYPE_CHAR_ANY;\n+    GGML_ASSERT(is_positive_char || pos->type == GRETYPE_CHAR_NOT);\n+\n+    uint32_t partial_value = partial_utf8.value;\n+    int      n_remain      = partial_utf8.n_remain;\n+\n+    // invalid sequence or 7-bit char split across 2 bytes (overlong)\n+    if (n_remain < 0 || (n_remain == 1 && partial_value < 2)) {\n+        return false;\n+    }\n+\n+    // range of possible code points this partial UTF-8 sequence could complete to\n+    uint32_t low  = partial_value << (n_remain * 6);\n+    uint32_t high = low | ((1 << (n_remain * 6)) - 1);\n+\n+    if (low == 0) {\n+        if (n_remain == 2) {\n+            low = 1 << 11;\n+        } else if (n_remain == 3) {\n+            low = 1 << 16;\n+        }\n+    }\n+\n+    do {\n+        if (pos[1].type == GRETYPE_CHAR_RNG_UPPER) {\n+            // inclusive range, e.g. [a-z]\n+            if (pos->value <= high && low <= pos[1].value) {\n+                return is_positive_char;\n+            }\n+            pos += 2;\n+        } else if (pos->type == GRETYPE_CHAR_ANY) {\n+            // Any character matches \".\"\n+            return true;\n+        } else {\n+            // exact char match, e.g. [a] or \"a\"\n+            if (low <= pos->value && pos->value <= high) {\n+                return is_positive_char;\n+            }\n+            pos += 1;\n+        }\n+    } while (pos->type == GRETYPE_CHAR_ALT);\n+\n+    return !is_positive_char;\n+}\n+\n+// transforms a grammar pushdown stack into N possible stacks, all ending\n+// at a character range (terminal element)\n+static void grammar_advance_stack(\n+        const grammar_rules  & rules,\n+        const grammar_stack  & stack,\n+              grammar_stacks & new_stacks) {\n+    if (stack.empty()) {\n+        if (std::find(new_stacks.begin(), new_stacks.end(), stack) == new_stacks.end()) {\n+            new_stacks.emplace_back(stack);\n+        }\n+        return;\n+    }\n+\n+    const grammar_element * pos = stack.back();\n+\n+    switch (pos->type) {\n+        case GRETYPE_RULE_REF: {\n+            const size_t             rule_id = static_cast<size_t>(pos->value);\n+            const grammar_element * subpos  = rules[rule_id].data();\n+            do {\n+                // init new stack without the top (pos)\n+                grammar_stack new_stack(stack.begin(), stack.end() - 1);\n+                if (!grammar_is_end_of_sequence(pos + 1)) {\n+                    // if this rule ref is followed by another element, add that to stack\n+                    new_stack.push_back(pos + 1);\n+                }\n+                if (!grammar_is_end_of_sequence(subpos)) {\n+                    // if alternate is nonempty, add to stack\n+                    new_stack.push_back(subpos);\n+                }\n+                grammar_advance_stack(rules, new_stack, new_stacks);\n+                while (!grammar_is_end_of_sequence(subpos)) {\n+                    // scan to end of alternate def\n+                    subpos++;\n+                }\n+                if (subpos->type == GRETYPE_ALT) {\n+                    // there's another alternate def of this rule to process\n+                    subpos++;\n+                } else {\n+                    break;\n+                }\n+            } while (true);\n+            break;\n+        }\n+        case GRETYPE_CHAR:\n+        case GRETYPE_CHAR_NOT:\n+        case GRETYPE_CHAR_ANY:\n+            if (std::find(new_stacks.begin(), new_stacks.end(), stack) == new_stacks.end()) {\n+                // only add the stack if it's not a duplicate of one we already have\n+                new_stacks.emplace_back(stack);\n+            }\n+            break;\n+        default:\n+            // end of alternate (GRETYPE_END, GRETYPE_ALT) or middle of char range\n+            // (GRETYPE_CHAR_ALT, GRETYPE_CHAR_RNG_UPPER); stack should never be left on\n+            // those\n+            GGML_ABORT(\"fatal error\");\n+    }\n+}\n+\n+static grammar_candidates grammar_reject_candidates(\n+        const grammar_rules      & rules,\n+        const grammar_stacks     & stacks,\n+        const grammar_candidates & candidates) {\n+    GGML_ASSERT(!stacks.empty()); // REVIEW\n+\n+    if (candidates.empty()) {\n+        return {};\n+    }\n+\n+    auto rejects = grammar_reject_candidates_for_stack(rules, stacks.front(), candidates);\n+\n+    for (size_t i = 1, size = stacks.size(); i < size; ++i) {\n+        rejects = grammar_reject_candidates_for_stack(rules, stacks[i], rejects);\n+    }\n+\n+    return rejects;\n+}\n+\n+static bool grammar_detect_left_recursion(\n+        const grammar_rules & rules,\n+        size_t rule_index,\n+        std::vector<bool> * rules_visited,\n+        std::vector<bool> * rules_in_progress,\n+        std::vector<bool> * rules_may_be_empty) {\n+    if ((*rules_in_progress)[rule_index]) {\n+        return true;\n+    }\n+\n+    (*rules_in_progress)[rule_index] = true;\n+\n+    const grammar_rule & rule = rules[rule_index];\n+\n+    // First check if the rule might produce the empty string. This could be done combined with the second\n+    // step but it's more readable as two steps.\n+    bool at_rule_start = true;\n+    for (size_t i = 0; i < rule.size(); i++) {\n+        if (grammar_is_end_of_sequence(&rule[i])) {\n+            if (at_rule_start) {\n+                (*rules_may_be_empty)[rule_index] = true;\n+                break;\n+            }\n+            at_rule_start = true;\n+        } else {\n+            at_rule_start = false;\n+        }\n+    }\n+\n+    // Second, recurse into leftmost nonterminals (or next-leftmost as long as the previous nonterminal may\n+    // be empty)\n+    bool recurse_into_nonterminal = true;\n+    for (size_t i = 0; i < rule.size(); i++) {\n+        if (rule[i].type == GRETYPE_RULE_REF && recurse_into_nonterminal) {\n+            if (grammar_detect_left_recursion(rules, (size_t)rule[i].value, rules_visited, rules_in_progress, rules_may_be_empty)) {\n+                return true;\n+            }\n+            if (!((*rules_may_be_empty)[(size_t)rule[i].value])) {\n+                recurse_into_nonterminal = false;\n+            }\n+        } else if (grammar_is_end_of_sequence(&rule[i])) {\n+            recurse_into_nonterminal = true;\n+        } else {\n+            recurse_into_nonterminal = false;\n+        }\n+    }\n+\n+    (*rules_in_progress)[rule_index] = false;\n+    (*rules_visited)[rule_index] = true;\n+\n+    return false;\n+}\n+\n+const grammar_rules & grammar_get_rules(const struct grammar * grammar) {\n+    return grammar->rules;\n+}\n+\n+grammar_stacks & grammar_get_stacks(struct grammar * grammar) {\n+    return grammar->stacks;\n+}\n+\n+void grammar_accept(struct grammar * grammar, uint32_t chr) {\n+    grammar_stacks stacks_new;\n+    stacks_new.reserve(grammar->stacks.size());\n+\n+    for (const auto & stack : grammar->stacks) {\n+        if (stack.empty()) {\n+            continue;\n+        }\n+\n+        auto match = grammar_match_char(stack.back(), chr);\n+        if (match.first) {\n+            const grammar_element * pos = match.second;\n+\n+            // update top of stack to next element, if any\n+            grammar_stack new_stack(stack.begin(), stack.end() - 1);\n+            if (!grammar_is_end_of_sequence(pos)) {\n+                new_stack.push_back(pos);\n+            }\n+            grammar_advance_stack(grammar->rules, new_stack, stacks_new);\n+        }\n+    }\n+\n+    grammar->stacks = std::move(stacks_new);\n+}\n+\n+grammar_candidates grammar_reject_candidates_for_stack(\n+        const grammar_rules      & rules,\n+        const grammar_stack      & stack,\n+        const grammar_candidates & candidates) {\n+\n+    grammar_candidates rejects;\n+    rejects.reserve(candidates.size());\n+\n+    if (stack.empty()) {\n+        for (const auto & tok : candidates) {\n+            if (*tok.code_points != 0 || tok.utf8_state.n_remain != 0) {\n+                rejects.push_back(tok);\n+            }\n+        }\n+        return rejects;\n+    }\n+\n+    const grammar_element * stack_pos = stack.back();\n+\n+    grammar_candidates next_candidates;\n+    next_candidates.reserve(candidates.size());\n+\n+    for (const auto & tok : candidates) {\n+        if (*tok.code_points == 0) {\n+            // reached end of full codepoints in token, reject iff it ended in a partial sequence\n+            // that cannot satisfy this position in grammar\n+            if (tok.utf8_state.n_remain != 0 &&\n+                    !grammar_match_partial_char(stack_pos, tok.utf8_state)) {\n+                rejects.push_back(tok);\n+            }\n+        } else if (grammar_match_char(stack_pos, *tok.code_points).first) {\n+            next_candidates.push_back({ tok.index, tok.code_points + 1, tok.utf8_state });\n+        } else {\n+            rejects.push_back(tok);\n+        }\n+    }\n+\n+    const auto * stack_pos_after = grammar_match_char(stack_pos, 0).second;\n+\n+    // update top of stack to next element, if any\n+    grammar_stack stack_after(stack.begin(), stack.end() - 1);\n+    if (!grammar_is_end_of_sequence(stack_pos_after)) {\n+        stack_after.push_back(stack_pos_after);\n+    }\n+    grammar_stacks next_stacks;\n+    grammar_advance_stack(rules, stack_after, next_stacks);\n+\n+    auto next_rejects = grammar_reject_candidates(rules, next_stacks, next_candidates);\n+    for (const auto & tok : next_rejects) {\n+        rejects.push_back({ tok.index, tok.code_points - 1, tok.utf8_state });\n+    }\n+\n+    return rejects;\n+}\n+\n+////////////////////\n+\n+struct grammar * grammar_init_impl(\n+        struct ollama_vocab * ollama_vocab,\n+        const grammar_element ** rules,\n+        size_t n_rules,\n+        size_t start_rule_index) {\n+    const grammar_element * pos;\n+\n+    // copy rule definitions into vectors\n+    grammar_rules vec_rules(n_rules);\n+    for (size_t i = 0; i < n_rules; i++) {\n+        for (pos = rules[i]; pos->type != GRETYPE_END; pos++) {\n+            vec_rules[i].push_back(*pos);\n+        }\n+        vec_rules[i].push_back({GRETYPE_END, 0});\n+    }\n+\n+    // Check for left recursion\n+    std::vector<bool> rules_visited(n_rules);\n+    std::vector<bool> rules_in_progress(n_rules);\n+    std::vector<bool> rules_may_be_empty(n_rules);\n+    for (size_t i = 0; i < n_rules; i++) {\n+        if (rules_visited[i]) {\n+            continue;\n+        }\n+        if (grammar_detect_left_recursion(vec_rules, i, &rules_visited, &rules_in_progress, &rules_may_be_empty)) {\n+            LLAMA_LOG_ERROR(\"unsupported grammar, left recursion detected for nonterminal at index %zu\", i);\n+            return nullptr;\n+        }\n+    }\n+\n+    // loop over alternates of start rule to build initial stacks\n+    grammar_stacks stacks;\n+    pos = vec_rules[start_rule_index].data();\n+    do {\n+        grammar_stack stack;\n+        if (!grammar_is_end_of_sequence(pos)) {\n+            // if alternate is nonempty, add to stack\n+            stack.push_back(pos);\n+        }\n+        grammar_advance_stack(vec_rules, stack, stacks);\n+        while (!grammar_is_end_of_sequence(pos)) {\n+            // scan to end of alternate def\n+            pos++;\n+        }\n+        if (pos->type == GRETYPE_ALT) {\n+            // there's another alternate def of this rule to process\n+            pos++;\n+        } else {\n+            break;\n+        }\n+    } while (true);\n+\n+    // Important: vec_rules has to be moved here, not copied, because stacks contains\n+    // pointers to elements of vec_rules. If vec_rules were copied into grammar\n+    // then the pointers would be invalidated when the local vec_rules goes out of scope.\n+    return new grammar {\n+        ollama_vocab,\n+        std::move(vec_rules),\n+        std::move(stacks),\n+        /* .partial_utf8 = */     {},\n+        /* .lazy =*/              false,\n+        /* .awaiting_trigger = */ false,\n+        /* .trigger_buffer = */   \"\",\n+        /* .trigger_tokens   = */ {},\n+        /* .trigger_words    = */ {},\n+    };\n+}\n+\n+struct grammar * grammar_init_impl(\n+                    struct ollama_vocab * ollama_vocab,\n+                      const char * grammar_str,\n+                      const char * grammar_root,\n+                              bool lazy,\n+                     const char ** trigger_words,\n+                            size_t num_trigger_words,\n+               const llama_token * trigger_tokens,\n+                            size_t num_trigger_tokens) {\n+    grammar_parser parser;\n+\n+    // if there is a grammar, parse it\n+    if (!parser.parse(grammar_str)) {\n+        LLAMA_LOG_ERROR(\"failed to parse grammar\");\n+        return nullptr;\n+    }\n+\n+    // will be empty (default) if there are parse errors\n+    if (parser.rules.empty()) {\n+        fprintf(stderr, \"%s: failed to parse grammar\\n\", __func__);\n+        return nullptr;\n+    }\n+\n+    // Ensure that there is a \"root\" node.\n+    if (parser.symbol_ids.find(\"root\") == parser.symbol_ids.end()) {\n+        fprintf(stderr, \"%s: grammar does not contain a 'root' symbol\\n\", __func__);\n+        return nullptr;\n+    }\n+\n+    std::vector<const grammar_element *> grammar_rules_vec(parser.c_rules());\n+\n+    const size_t n_rules = grammar_rules_vec.size();\n+    const size_t start_rule_index = parser.symbol_ids.at(grammar_root);\n+\n+    const grammar_element * pos;\n+\n+    // copy rule definitions into vectors\n+    grammar_rules vec_rules;\n+    vec_rules.resize(n_rules);  // Pre-allocate space for all rules\n+    \n+    for (size_t i = 0; i < n_rules; i++) {\n+        if (grammar_rules_vec[i] == nullptr) {\n+            LLAMA_LOG_ERROR(\"null rule pointer at index %zu\", i);\n+            return nullptr;\n+        }\n+        \n+        // Reserve space for the rule to avoid reallocation\n+        vec_rules[i].reserve(16);  // Start with reasonable capacity",
        "comment_created_at": "2025-04-03T18:24:31+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "Added a small reserve otherwise would not alloc correctly at times",
        "pr_file_module": null
      }
    ]
  }
]