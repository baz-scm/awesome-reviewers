[
  {
    "discussion_id": "1991408360",
    "pr_number": 9669,
    "pr_file": "sample/transforms.go",
    "created_at": "2025-03-12T12:37:05+00:00",
    "commented_code": "return ts\n }\n \n-// siftDown maintains a min-heap property by recursively moving larger elements down the heap.\n-//\n-// The heap is represented as an array where for any node at index i:\n-// - Left child is at index 2i + 1\n-// - Right child is at index 2i + 2\n-// - Parent is at index (i-1)/2\n-//\n-// The function compares a node with its children and:\n-// 1. Finds the smallest value between the node and its children\n-// 2. If the node is not the smallest, swaps it with its smallest child\n-// 3. Continues this process down the affected path until the min-heap property is restored\n-func siftDown(data []token, start, end int) {\n-\troot := start\n-\tfor {\n-\t\tchild := 2*root + 1\n-\t\tif child >= end {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Find smaller child (we want min heap)\n-\t\tif child+1 < end && data[child+1].value < data[child].value {\n-\t\t\tchild++\n-\t\t}\n-\t\t// Exit if root is already smaller than children\n-\t\tif data[root].value <= data[child].value {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Swap with smaller child and continue\n-\t\tdata[root], data[child] = data[child], data[root]\n-\t\troot = child\n-\t}\n-}\n-\n // topK limits the number of tokens considered to the k highest logits\n func topK(ts []token, k int) []token {\n \tif k >= len(ts) {\n+\t\tsortLogits(ts)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1991408360",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9669,
        "pr_file": "sample/transforms.go",
        "discussion_id": "1991408360",
        "commented_code": "@@ -31,62 +51,33 @@ func temperature(ts []token, temp float32) []token {\n \treturn ts\n }\n \n-// siftDown maintains a min-heap property by recursively moving larger elements down the heap.\n-//\n-// The heap is represented as an array where for any node at index i:\n-// - Left child is at index 2i + 1\n-// - Right child is at index 2i + 2\n-// - Parent is at index (i-1)/2\n-//\n-// The function compares a node with its children and:\n-// 1. Finds the smallest value between the node and its children\n-// 2. If the node is not the smallest, swaps it with its smallest child\n-// 3. Continues this process down the affected path until the min-heap property is restored\n-func siftDown(data []token, start, end int) {\n-\troot := start\n-\tfor {\n-\t\tchild := 2*root + 1\n-\t\tif child >= end {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Find smaller child (we want min heap)\n-\t\tif child+1 < end && data[child+1].value < data[child].value {\n-\t\t\tchild++\n-\t\t}\n-\t\t// Exit if root is already smaller than children\n-\t\tif data[root].value <= data[child].value {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Swap with smaller child and continue\n-\t\tdata[root], data[child] = data[child], data[root]\n-\t\troot = child\n-\t}\n-}\n-\n // topK limits the number of tokens considered to the k highest logits\n func topK(ts []token, k int) []token {\n \tif k >= len(ts) {\n+\t\tsortLogits(ts)",
        "comment_created_at": "2025-03-12T12:37:05+00:00",
        "comment_author": "jmorganca",
        "comment_body": "Given how rare this is, why don't we just use built-in sort for now. It will simplify the code a lot:\r\n\r\n```\r\n\tif k >= len(ts) {\r\n\t\tslices.SortFunc(ts, func(a, b token) int {\r\n\t\t\tswitch {\r\n\t\t\tcase a < b:\r\n\t\t\t\treturn -1\r\n\t\t\tcase a > b:\r\n\t\t\t\treturn 1\r\n\t\t\tdefault:\r\n\t\t\t\treturn 0\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ts\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1991414418",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9669,
        "pr_file": "sample/transforms.go",
        "discussion_id": "1991408360",
        "commented_code": "@@ -31,62 +51,33 @@ func temperature(ts []token, temp float32) []token {\n \treturn ts\n }\n \n-// siftDown maintains a min-heap property by recursively moving larger elements down the heap.\n-//\n-// The heap is represented as an array where for any node at index i:\n-// - Left child is at index 2i + 1\n-// - Right child is at index 2i + 2\n-// - Parent is at index (i-1)/2\n-//\n-// The function compares a node with its children and:\n-// 1. Finds the smallest value between the node and its children\n-// 2. If the node is not the smallest, swaps it with its smallest child\n-// 3. Continues this process down the affected path until the min-heap property is restored\n-func siftDown(data []token, start, end int) {\n-\troot := start\n-\tfor {\n-\t\tchild := 2*root + 1\n-\t\tif child >= end {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Find smaller child (we want min heap)\n-\t\tif child+1 < end && data[child+1].value < data[child].value {\n-\t\t\tchild++\n-\t\t}\n-\t\t// Exit if root is already smaller than children\n-\t\tif data[root].value <= data[child].value {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Swap with smaller child and continue\n-\t\tdata[root], data[child] = data[child], data[root]\n-\t\troot = child\n-\t}\n-}\n-\n // topK limits the number of tokens considered to the k highest logits\n func topK(ts []token, k int) []token {\n \tif k >= len(ts) {\n+\t\tsortLogits(ts)",
        "comment_created_at": "2025-03-12T12:40:58+00:00",
        "comment_author": "jmorganca",
        "comment_body": "This should be able to replace `partialSortLogits` and `sortLogits` below",
        "pr_file_module": null
      },
      {
        "comment_id": "1991798722",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9669,
        "pr_file": "sample/transforms.go",
        "discussion_id": "1991408360",
        "commented_code": "@@ -31,62 +51,33 @@ func temperature(ts []token, temp float32) []token {\n \treturn ts\n }\n \n-// siftDown maintains a min-heap property by recursively moving larger elements down the heap.\n-//\n-// The heap is represented as an array where for any node at index i:\n-// - Left child is at index 2i + 1\n-// - Right child is at index 2i + 2\n-// - Parent is at index (i-1)/2\n-//\n-// The function compares a node with its children and:\n-// 1. Finds the smallest value between the node and its children\n-// 2. If the node is not the smallest, swaps it with its smallest child\n-// 3. Continues this process down the affected path until the min-heap property is restored\n-func siftDown(data []token, start, end int) {\n-\troot := start\n-\tfor {\n-\t\tchild := 2*root + 1\n-\t\tif child >= end {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Find smaller child (we want min heap)\n-\t\tif child+1 < end && data[child+1].value < data[child].value {\n-\t\t\tchild++\n-\t\t}\n-\t\t// Exit if root is already smaller than children\n-\t\tif data[root].value <= data[child].value {\n-\t\t\tbreak\n-\t\t}\n-\t\t// Swap with smaller child and continue\n-\t\tdata[root], data[child] = data[child], data[root]\n-\t\troot = child\n-\t}\n-}\n-\n // topK limits the number of tokens considered to the k highest logits\n func topK(ts []token, k int) []token {\n \tif k >= len(ts) {\n+\t\tsortLogits(ts)",
        "comment_created_at": "2025-03-12T15:49:22+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "The speed diff is about 50 tps so had initially decided to do this. top_k is almost never set to 0 so maybe worthwhile to just rm",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1960693415",
    "pr_number": 9198,
    "pr_file": "model/process_text_spm.go",
    "created_at": "2025-02-18T22:41:56+00:00",
    "commented_code": "+package model\n+\n+import (\n+\t\"iter\"\n+\t\"log/slog\"\n+\t\"strings\"\n+\n+\t\"github.com/dlclark/regexp2\"\n+\tqueue \"github.com/emirpasic/gods/queues/priorityqueue\"",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1960693415",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9198,
        "pr_file": "model/process_text_spm.go",
        "discussion_id": "1960693415",
        "commented_code": "@@ -0,0 +1,220 @@\n+package model\n+\n+import (\n+\t\"iter\"\n+\t\"log/slog\"\n+\t\"strings\"\n+\n+\t\"github.com/dlclark/regexp2\"\n+\tqueue \"github.com/emirpasic/gods/queues/priorityqueue\"",
        "comment_created_at": "2025-02-18T22:41:56+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "The Go standard library has an example of how to build a priority queue with a heap. Should we try that instead of the dependency?\r\nhttps://pkg.go.dev/container/heap",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983904955",
    "pr_number": 9374,
    "pr_file": "sample/transforms.go",
    "created_at": "2025-03-06T19:00:41+00:00",
    "commented_code": "package sample\n \n import (\n-\t\"cmp\"\n \t\"math\"\n \t\"slices\"\n-\n-\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n )\n \n-type Transform interface {\n-\tApply([]float64) []float64\n+type transform interface {\n+\tApply(tokenSliceInfo) tokenSliceInfo\n+}\n+\n+type softmax struct{}\n+\n+func Softmax() transform {\n+\treturn softmax{}\n }\n \n-// TODO(parthsareen): potentially cache softmax values\n-func softmax(logits []float64) []float64 {\n-\tvar sum float64\n-\tprobs := make([]float64, len(logits))\n-\tfor i, v := range logits {\n-\t\tprobs[i] = math.Exp(v)\n-\t\tsum += probs[i]\n+func (s softmax) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tvar sum float32\n+\tfor i, v := range ts.tokens {\n+\t\tts.tokens[i].prob = float32(math.Exp(float64(v.logit)))\n+\t\tsum += ts.tokens[i].prob\n \t}\n \n-\tfor i := range probs {\n-\t\tprobs[i] /= sum\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].prob /= sum\n \t}\n \n-\treturn probs\n+\tts.sum = sum\n+\n+\treturn ts\n }\n \n type Temperature float64\n \n-func (t Temperature) Apply(logits []float64) []float64 {\n-\ttemp := math.Max(float64(t), 1e-7)\n+func (t Temperature) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tif t == 1 {\n+\t\treturn ts\n+\t}\n+\n+\ttemp := float32(math.Max(float64(t), 1e-7))\n+\tmaxLogit := float32(math.Inf(-1))\n+\tfor _, token := range ts.tokens {\n+\t\tif token.logit > maxLogit {\n+\t\t\tmaxLogit = token.logit\n+\t\t}\n+\t}\n \n \t// subtracting max logit to avoid under/overflow\n-\tmaxLogit := slices.Max(logits)\n-\tfor i := range logits {\n-\t\tlogits[i] = (logits[i] - maxLogit) / temp\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].logit = (ts.tokens[i].logit - maxLogit) / temp\n \t}\n \n-\treturn logits\n-}\n-\n-type logitMap struct {\n-\tindex int\n-\tlogit float64\n+\treturn ts\n }\n \n type TopK int\n \n-// TODO(parthsareen): avoid having to check all logits after this transform\n-func (k TopK) Apply(logits []float64) []float64 {\n-\tif int(k) >= len(logits) {\n-\t\treturn logits\n+// siftDown maintains min-heap property by pushing larger elements down",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1983904955",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9374,
        "pr_file": "sample/transforms.go",
        "discussion_id": "1983904955",
        "commented_code": "@@ -1,120 +1,216 @@\n package sample\n \n import (\n-\t\"cmp\"\n \t\"math\"\n \t\"slices\"\n-\n-\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n )\n \n-type Transform interface {\n-\tApply([]float64) []float64\n+type transform interface {\n+\tApply(tokenSliceInfo) tokenSliceInfo\n+}\n+\n+type softmax struct{}\n+\n+func Softmax() transform {\n+\treturn softmax{}\n }\n \n-// TODO(parthsareen): potentially cache softmax values\n-func softmax(logits []float64) []float64 {\n-\tvar sum float64\n-\tprobs := make([]float64, len(logits))\n-\tfor i, v := range logits {\n-\t\tprobs[i] = math.Exp(v)\n-\t\tsum += probs[i]\n+func (s softmax) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tvar sum float32\n+\tfor i, v := range ts.tokens {\n+\t\tts.tokens[i].prob = float32(math.Exp(float64(v.logit)))\n+\t\tsum += ts.tokens[i].prob\n \t}\n \n-\tfor i := range probs {\n-\t\tprobs[i] /= sum\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].prob /= sum\n \t}\n \n-\treturn probs\n+\tts.sum = sum\n+\n+\treturn ts\n }\n \n type Temperature float64\n \n-func (t Temperature) Apply(logits []float64) []float64 {\n-\ttemp := math.Max(float64(t), 1e-7)\n+func (t Temperature) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tif t == 1 {\n+\t\treturn ts\n+\t}\n+\n+\ttemp := float32(math.Max(float64(t), 1e-7))\n+\tmaxLogit := float32(math.Inf(-1))\n+\tfor _, token := range ts.tokens {\n+\t\tif token.logit > maxLogit {\n+\t\t\tmaxLogit = token.logit\n+\t\t}\n+\t}\n \n \t// subtracting max logit to avoid under/overflow\n-\tmaxLogit := slices.Max(logits)\n-\tfor i := range logits {\n-\t\tlogits[i] = (logits[i] - maxLogit) / temp\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].logit = (ts.tokens[i].logit - maxLogit) / temp\n \t}\n \n-\treturn logits\n-}\n-\n-type logitMap struct {\n-\tindex int\n-\tlogit float64\n+\treturn ts\n }\n \n type TopK int\n \n-// TODO(parthsareen): avoid having to check all logits after this transform\n-func (k TopK) Apply(logits []float64) []float64 {\n-\tif int(k) >= len(logits) {\n-\t\treturn logits\n+// siftDown maintains min-heap property by pushing larger elements down",
        "comment_created_at": "2025-03-06T19:00:41+00:00",
        "comment_author": "jmorganca",
        "comment_body": "I know we passed on it previously, but it's worth seeing if we can use `container/heap`  ?\r\n\r\n````\r\nimport \"container/heap\"\r\n\r\n// tokenHeap implements heap.Interface\r\ntype tokenHeap []tokenInfo\r\n\r\nfunc (h tokenHeap) Len() int           { return len(h) }\r\nfunc (h tokenHeap) Less(i, j int) bool { return h[i].logit < h[j].logit } // min-heap based on logit\r\nfunc (h tokenHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\r\n\r\nfunc (h *tokenHeap) Push(x any) {\r\n\t*h = append(*h, x.(tokenInfo))\r\n}\r\n\r\nfunc (h *tokenHeap) Pop() any {\r\n\told := *h\r\n\tn := len(old)\r\n\titem := (*h)[n-1]\r\n\t*h = (*h)[:n-1]\r\n\treturn item\r\n}\r\n\r\n### Explanation:\r\n- `Pop` should remove and return the last element of the slice after shrinking it.\r\n- This properly maintains the heap's invariants defined by the other methods (`Len`, `Less`, `Swap`).\r\n\r\n### Usage example:\r\n\r\n```go\r\nh := &tokenHeap{}\r\nheap.Init(h)\r\n\r\n// Push elements onto the heap\r\nheap.Push(h, tokenInfo{id: 1, logit: 0.9})\r\nheap.Push(h, tokenInfo{id: 2, logit: 1.2})\r\n\r\n// Pop smallest element\r\nsmallest := heap.Pop(h).(tokenInfo)\r\n```\r\n````",
        "pr_file_module": null
      },
      {
        "comment_id": "1983906352",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9374,
        "pr_file": "sample/transforms.go",
        "discussion_id": "1983904955",
        "commented_code": "@@ -1,120 +1,216 @@\n package sample\n \n import (\n-\t\"cmp\"\n \t\"math\"\n \t\"slices\"\n-\n-\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n )\n \n-type Transform interface {\n-\tApply([]float64) []float64\n+type transform interface {\n+\tApply(tokenSliceInfo) tokenSliceInfo\n+}\n+\n+type softmax struct{}\n+\n+func Softmax() transform {\n+\treturn softmax{}\n }\n \n-// TODO(parthsareen): potentially cache softmax values\n-func softmax(logits []float64) []float64 {\n-\tvar sum float64\n-\tprobs := make([]float64, len(logits))\n-\tfor i, v := range logits {\n-\t\tprobs[i] = math.Exp(v)\n-\t\tsum += probs[i]\n+func (s softmax) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tvar sum float32\n+\tfor i, v := range ts.tokens {\n+\t\tts.tokens[i].prob = float32(math.Exp(float64(v.logit)))\n+\t\tsum += ts.tokens[i].prob\n \t}\n \n-\tfor i := range probs {\n-\t\tprobs[i] /= sum\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].prob /= sum\n \t}\n \n-\treturn probs\n+\tts.sum = sum\n+\n+\treturn ts\n }\n \n type Temperature float64\n \n-func (t Temperature) Apply(logits []float64) []float64 {\n-\ttemp := math.Max(float64(t), 1e-7)\n+func (t Temperature) Apply(ts tokenSliceInfo) tokenSliceInfo {\n+\tif t == 1 {\n+\t\treturn ts\n+\t}\n+\n+\ttemp := float32(math.Max(float64(t), 1e-7))\n+\tmaxLogit := float32(math.Inf(-1))\n+\tfor _, token := range ts.tokens {\n+\t\tif token.logit > maxLogit {\n+\t\t\tmaxLogit = token.logit\n+\t\t}\n+\t}\n \n \t// subtracting max logit to avoid under/overflow\n-\tmaxLogit := slices.Max(logits)\n-\tfor i := range logits {\n-\t\tlogits[i] = (logits[i] - maxLogit) / temp\n+\tfor i := range ts.tokens {\n+\t\tts.tokens[i].logit = (ts.tokens[i].logit - maxLogit) / temp\n \t}\n \n-\treturn logits\n-}\n-\n-type logitMap struct {\n-\tindex int\n-\tlogit float64\n+\treturn ts\n }\n \n type TopK int\n \n-// TODO(parthsareen): avoid having to check all logits after this transform\n-func (k TopK) Apply(logits []float64) []float64 {\n-\tif int(k) >= len(logits) {\n-\t\treturn logits\n+// siftDown maintains min-heap property by pushing larger elements down",
        "comment_created_at": "2025-03-06T19:01:51+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "Already tried. Drops tps ~ 2 so decided to go with this approach",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983917173",
    "pr_number": 9374,
    "pr_file": "sample/samplers.go",
    "created_at": "2025-03-06T19:11:05+00:00",
    "commented_code": "import (\n \t\"errors\"\n-\t\"math\"\n-\n-\t\"golang.org/x/exp/rand\"\n-\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+\t\"math/rand/v2\"\n )\n \n+// Sampler is not thread-safe. Each goroutine should have its own instance.\n type Sampler interface {\n \tSample([]float32) (int32, error)\n }\n \n+type tokenInfo struct {\n+\tid    int32\n+\tlogit float32\n+\tprob  float32\n+}\n+\n+type tokenSliceInfo struct {\n+\ttokens []tokenInfo\n+\tsorted bool\n+\tsum    float32\n+}\n+\n type weighted struct {\n-\tsrc        rand.Source\n-\ttransforms []Transform\n+\trng        *rand.Rand\n+\ttransforms []transform\n }\n \n-// TODO(parthsareen): remove uv sample dependency https://github.com/ollama/ollama/issues/9279\n-func Weighted(seed *uint64, transforms ...Transform) Sampler {\n-\tvar src rand.Source\n-\tif seed != nil {\n-\t\tsrc = rand.NewSource(*seed)\n+func Weighted(rng *rand.Rand, transforms ...transform) Sampler {\n+\treturn &weighted{\n+\t\trng:        rng,\n+\t\ttransforms: transforms,\n \t}\n-\treturn weighted{src: src, transforms: transforms}\n }\n \n-func (s weighted) Sample(logits []float32) (int32, error) {\n-\tlogits64 := make([]float64, len(logits))\n+func (s *weighted) Sample(logits []float32) (int32, error) {\n+\ttokens := make([]tokenInfo, len(logits))\n \tfor i, v := range logits {\n-\t\tlogits64[i] = float64(v)\n+\t\ttokens[i].id = int32(i)\n+\t\ttokens[i].logit = v\n \t}\n \n+\ttokensInfo := tokenSliceInfo{tokens: tokens, sorted: false}\n \tfor _, t := range s.transforms {\n-\t\tlogits64 = t.Apply(logits64)\n+\t\ttokensInfo = t.Apply(tokensInfo)\n \t}\n \n-\tlogitsCopy := make([]float64, 0, len(logits))\n-\tindices := make([]int, 0, len(logits))\n-\tfor i, logit := range logits64 {\n-\t\tif !math.IsInf(logit, -1) {\n-\t\t\tlogitsCopy = append(logitsCopy, logit)\n-\t\t\tindices = append(indices, i)\n-\t\t}\n+\tif len(tokensInfo.tokens) == 0 {\n+\t\treturn -1, errors.New(\"no valid logits found for weighted sampling\")\n \t}\n \n-\tif len(logitsCopy) == 0 {\n-\t\treturn -1, errors.New(\"no valid logits found for weighed sampling\")\n+\t// TODO(parthsareen): fix seeded sampling https://github.com/ollama/ollama/issues/9554\n+\tvar r float32\n+\tif s.rng != nil {\n+\t\tr = s.rng.Float32()\n+\t} else {\n+\t\tr = rand.Float32()\n \t}\n-\n-\tprobs := softmax(logitsCopy)\n-\tw := sampleuv.NewWeighted(probs, s.src)\n-\tif idx, ok := w.Take(); ok {\n-\t\treturn int32(indices[idx]), nil\n+\tr *= tokensInfo.sum\n+\n+\t// Binary search for the selected index as tokens are sorted by logits",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1983917173",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9374,
        "pr_file": "sample/samplers.go",
        "discussion_id": "1983917173",
        "commented_code": "@@ -2,59 +2,75 @@ package sample\n \n import (\n \t\"errors\"\n-\t\"math\"\n-\n-\t\"golang.org/x/exp/rand\"\n-\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+\t\"math/rand/v2\"\n )\n \n+// Sampler is not thread-safe. Each goroutine should have its own instance.\n type Sampler interface {\n \tSample([]float32) (int32, error)\n }\n \n+type tokenInfo struct {\n+\tid    int32\n+\tlogit float32\n+\tprob  float32\n+}\n+\n+type tokenSliceInfo struct {\n+\ttokens []tokenInfo\n+\tsorted bool\n+\tsum    float32\n+}\n+\n type weighted struct {\n-\tsrc        rand.Source\n-\ttransforms []Transform\n+\trng        *rand.Rand\n+\ttransforms []transform\n }\n \n-// TODO(parthsareen): remove uv sample dependency https://github.com/ollama/ollama/issues/9279\n-func Weighted(seed *uint64, transforms ...Transform) Sampler {\n-\tvar src rand.Source\n-\tif seed != nil {\n-\t\tsrc = rand.NewSource(*seed)\n+func Weighted(rng *rand.Rand, transforms ...transform) Sampler {\n+\treturn &weighted{\n+\t\trng:        rng,\n+\t\ttransforms: transforms,\n \t}\n-\treturn weighted{src: src, transforms: transforms}\n }\n \n-func (s weighted) Sample(logits []float32) (int32, error) {\n-\tlogits64 := make([]float64, len(logits))\n+func (s *weighted) Sample(logits []float32) (int32, error) {\n+\ttokens := make([]tokenInfo, len(logits))\n \tfor i, v := range logits {\n-\t\tlogits64[i] = float64(v)\n+\t\ttokens[i].id = int32(i)\n+\t\ttokens[i].logit = v\n \t}\n \n+\ttokensInfo := tokenSliceInfo{tokens: tokens, sorted: false}\n \tfor _, t := range s.transforms {\n-\t\tlogits64 = t.Apply(logits64)\n+\t\ttokensInfo = t.Apply(tokensInfo)\n \t}\n \n-\tlogitsCopy := make([]float64, 0, len(logits))\n-\tindices := make([]int, 0, len(logits))\n-\tfor i, logit := range logits64 {\n-\t\tif !math.IsInf(logit, -1) {\n-\t\t\tlogitsCopy = append(logitsCopy, logit)\n-\t\t\tindices = append(indices, i)\n-\t\t}\n+\tif len(tokensInfo.tokens) == 0 {\n+\t\treturn -1, errors.New(\"no valid logits found for weighted sampling\")\n \t}\n \n-\tif len(logitsCopy) == 0 {\n-\t\treturn -1, errors.New(\"no valid logits found for weighed sampling\")\n+\t// TODO(parthsareen): fix seeded sampling https://github.com/ollama/ollama/issues/9554\n+\tvar r float32\n+\tif s.rng != nil {\n+\t\tr = s.rng.Float32()\n+\t} else {\n+\t\tr = rand.Float32()\n \t}\n-\n-\tprobs := softmax(logitsCopy)\n-\tw := sampleuv.NewWeighted(probs, s.src)\n-\tif idx, ok := w.Take(); ok {\n-\t\treturn int32(indices[idx]), nil\n+\tr *= tokensInfo.sum\n+\n+\t// Binary search for the selected index as tokens are sorted by logits",
        "comment_created_at": "2025-03-06T19:11:05+00:00",
        "comment_author": "jmorganca",
        "comment_body": "Let's use https://pkg.go.dev/slices#BinarySearchFunc vs re-implementing binary search",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1951258140",
    "pr_number": 8410,
    "pr_file": "sample/sample.go",
    "created_at": "2025-02-11T17:12:07+00:00",
    "commented_code": "+package sample\n+\n+import (\n+\t\"cmp\"\n+\t\"errors\"\n+\t\"math\"\n+\t\"slices\"\n+\n+\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Transform interface {\n+\tApply([]float64) ([]float64, error)\n+}\n+\n+type Sampler interface {\n+\tSample([]float32, ...Transform) (int, error)\n+}\n+\n+// TODO(parthsareen): potentially cache softmax values\n+func softmax(logits []float64) []float64 {\n+\tcopiedLogits := make([]float64, len(logits))\n+\tcopy(copiedLogits, logits)\n+\tfor i := range copiedLogits {\n+\t\tcopiedLogits[i] = math.Exp(copiedLogits[i])\n+\t}\n+\n+\tfloatSum := floats.Sum(copiedLogits)\n+\tfloats.Scale(1.0/floatSum, copiedLogits)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1951258140",
        "repo_full_name": "ollama/ollama",
        "pr_number": 8410,
        "pr_file": "sample/sample.go",
        "discussion_id": "1951258140",
        "commented_code": "@@ -0,0 +1,192 @@\n+package sample\n+\n+import (\n+\t\"cmp\"\n+\t\"errors\"\n+\t\"math\"\n+\t\"slices\"\n+\n+\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Transform interface {\n+\tApply([]float64) ([]float64, error)\n+}\n+\n+type Sampler interface {\n+\tSample([]float32, ...Transform) (int, error)\n+}\n+\n+// TODO(parthsareen): potentially cache softmax values\n+func softmax(logits []float64) []float64 {\n+\tcopiedLogits := make([]float64, len(logits))\n+\tcopy(copiedLogits, logits)\n+\tfor i := range copiedLogits {\n+\t\tcopiedLogits[i] = math.Exp(copiedLogits[i])\n+\t}\n+\n+\tfloatSum := floats.Sum(copiedLogits)\n+\tfloats.Scale(1.0/floatSum, copiedLogits)",
        "comment_created_at": "2025-02-11T17:12:07+00:00",
        "comment_author": "mxyng",
        "comment_body": "You don't need an explicit copy. Instead sum and copy the values while iterating\r\n```suggestion\r\n\tvar sum float64\r\n\ttt := make([]float64, len(t))\r\n\tfor i, v := range t {\r\n\t\ttt[i] = math.Exp(v)\r\n\t\tsum += tt[i]\r\n\t}\r\n\r\n\tfloats.Scale(1/sum, tt)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1951625364",
        "repo_full_name": "ollama/ollama",
        "pr_number": 8410,
        "pr_file": "sample/sample.go",
        "discussion_id": "1951258140",
        "commented_code": "@@ -0,0 +1,192 @@\n+package sample\n+\n+import (\n+\t\"cmp\"\n+\t\"errors\"\n+\t\"math\"\n+\t\"slices\"\n+\n+\tpq \"github.com/emirpasic/gods/v2/queues/priorityqueue\"\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Transform interface {\n+\tApply([]float64) ([]float64, error)\n+}\n+\n+type Sampler interface {\n+\tSample([]float32, ...Transform) (int, error)\n+}\n+\n+// TODO(parthsareen): potentially cache softmax values\n+func softmax(logits []float64) []float64 {\n+\tcopiedLogits := make([]float64, len(logits))\n+\tcopy(copiedLogits, logits)\n+\tfor i := range copiedLogits {\n+\t\tcopiedLogits[i] = math.Exp(copiedLogits[i])\n+\t}\n+\n+\tfloatSum := floats.Sum(copiedLogits)\n+\tfloats.Scale(1.0/floatSum, copiedLogits)",
        "comment_created_at": "2025-02-11T21:22:12+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "Ah nice, will add",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1960955649",
    "pr_number": 8410,
    "pr_file": "sample/samplers.go",
    "created_at": "2025-02-19T05:01:45+00:00",
    "commented_code": "+package sample\n+\n+import (\n+\t\"errors\"\n+\t\"math\"\n+\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Sampler interface {\n+\tSample([]float32) (int32, error)\n+}\n+\n+type weighted struct {\n+\tsrc        rand.Source\n+\ttransforms []Transform\n+}\n+\n+func Weighted(seed *int64, transforms ...Transform) Sampler {\n+\tvar src rand.Source\n+\tif seed != nil {\n+\t\tsrc = rand.NewSource(uint64(*seed))\n+\t}\n+\treturn weighted{src: src, transforms: transforms}\n+}\n+\n+func (s weighted) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\tlogitsCopy := make([]float64, 0, len(logits))\n+\tindices := make([]int, 0, len(logits))\n+\tfor i, logit := range logits64 {\n+\t\tif !math.IsInf(logit, -1) {\n+\t\t\tlogitsCopy = append(logitsCopy, logit)\n+\t\t\tindices = append(indices, i)\n+\t\t}\n+\t}\n+\n+\tif len(logitsCopy) == 0 {\n+\t\treturn -1, errors.New(\"no valid logits found for weighed sampling\")\n+\t}\n+\n+\tprobs := softmax(logitsCopy)\n+\tw := sampleuv.NewWeighted(probs, s.src)\n+\tif idx, ok := w.Take(); ok {\n+\t\treturn int32(indices[idx]), nil\n+\t}\n+\treturn -1, errors.New(\"weighed sampler failed, no valid token found\")\n+}\n+\n+type greedy struct {\n+\ttransforms []Transform\n+}\n+\n+func Greedy(transforms ...Transform) Sampler {\n+\treturn greedy{transforms: transforms}\n+}\n+\n+func (s greedy) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\treturn int32(floats.MaxIdx(logits64)), nil",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1960955649",
        "repo_full_name": "ollama/ollama",
        "pr_number": 8410,
        "pr_file": "sample/samplers.go",
        "discussion_id": "1960955649",
        "commented_code": "@@ -0,0 +1,87 @@\n+package sample\n+\n+import (\n+\t\"errors\"\n+\t\"math\"\n+\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Sampler interface {\n+\tSample([]float32) (int32, error)\n+}\n+\n+type weighted struct {\n+\tsrc        rand.Source\n+\ttransforms []Transform\n+}\n+\n+func Weighted(seed *int64, transforms ...Transform) Sampler {\n+\tvar src rand.Source\n+\tif seed != nil {\n+\t\tsrc = rand.NewSource(uint64(*seed))\n+\t}\n+\treturn weighted{src: src, transforms: transforms}\n+}\n+\n+func (s weighted) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\tlogitsCopy := make([]float64, 0, len(logits))\n+\tindices := make([]int, 0, len(logits))\n+\tfor i, logit := range logits64 {\n+\t\tif !math.IsInf(logit, -1) {\n+\t\t\tlogitsCopy = append(logitsCopy, logit)\n+\t\t\tindices = append(indices, i)\n+\t\t}\n+\t}\n+\n+\tif len(logitsCopy) == 0 {\n+\t\treturn -1, errors.New(\"no valid logits found for weighed sampling\")\n+\t}\n+\n+\tprobs := softmax(logitsCopy)\n+\tw := sampleuv.NewWeighted(probs, s.src)\n+\tif idx, ok := w.Take(); ok {\n+\t\treturn int32(indices[idx]), nil\n+\t}\n+\treturn -1, errors.New(\"weighed sampler failed, no valid token found\")\n+}\n+\n+type greedy struct {\n+\ttransforms []Transform\n+}\n+\n+func Greedy(transforms ...Transform) Sampler {\n+\treturn greedy{transforms: transforms}\n+}\n+\n+func (s greedy) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\treturn int32(floats.MaxIdx(logits64)), nil",
        "comment_created_at": "2025-02-19T05:01:45+00:00",
        "comment_author": "jmorganca",
        "comment_body": "I believe you can use `slices.Indexfunc` instead of this dependency, something like:\r\n\r\n```\r\nimport \"slices\"\r\n\r\nfunc maxIdx(vals []float64) int {\r\n    if len(vals) == 0 {\r\n        return -1\r\n    }\r\n    maxVal := slices.Max(vals)\r\n    return slices.IndexFunc(vals, func(v float64) bool {\r\n        return v == maxVal\r\n    })\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1962440769",
        "repo_full_name": "ollama/ollama",
        "pr_number": 8410,
        "pr_file": "sample/samplers.go",
        "discussion_id": "1960955649",
        "commented_code": "@@ -0,0 +1,87 @@\n+package sample\n+\n+import (\n+\t\"errors\"\n+\t\"math\"\n+\n+\t\"golang.org/x/exp/rand\"\n+\t\"gonum.org/v1/gonum/floats\"\n+\t\"gonum.org/v1/gonum/stat/sampleuv\"\n+)\n+\n+type Sampler interface {\n+\tSample([]float32) (int32, error)\n+}\n+\n+type weighted struct {\n+\tsrc        rand.Source\n+\ttransforms []Transform\n+}\n+\n+func Weighted(seed *int64, transforms ...Transform) Sampler {\n+\tvar src rand.Source\n+\tif seed != nil {\n+\t\tsrc = rand.NewSource(uint64(*seed))\n+\t}\n+\treturn weighted{src: src, transforms: transforms}\n+}\n+\n+func (s weighted) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\tlogitsCopy := make([]float64, 0, len(logits))\n+\tindices := make([]int, 0, len(logits))\n+\tfor i, logit := range logits64 {\n+\t\tif !math.IsInf(logit, -1) {\n+\t\t\tlogitsCopy = append(logitsCopy, logit)\n+\t\t\tindices = append(indices, i)\n+\t\t}\n+\t}\n+\n+\tif len(logitsCopy) == 0 {\n+\t\treturn -1, errors.New(\"no valid logits found for weighed sampling\")\n+\t}\n+\n+\tprobs := softmax(logitsCopy)\n+\tw := sampleuv.NewWeighted(probs, s.src)\n+\tif idx, ok := w.Take(); ok {\n+\t\treturn int32(indices[idx]), nil\n+\t}\n+\treturn -1, errors.New(\"weighed sampler failed, no valid token found\")\n+}\n+\n+type greedy struct {\n+\ttransforms []Transform\n+}\n+\n+func Greedy(transforms ...Transform) Sampler {\n+\treturn greedy{transforms: transforms}\n+}\n+\n+func (s greedy) Sample(logits []float32) (int32, error) {\n+\tlogits64 := make([]float64, len(logits))\n+\tfor i, v := range logits {\n+\t\tlogits64[i] = float64(v)\n+\t}\n+\n+\tvar err error\n+\tfor _, t := range s.transforms {\n+\t\tlogits64, err = t.Apply(logits64)\n+\t\tif err != nil {\n+\t\t\treturn -1, err\n+\t\t}\n+\t}\n+\n+\treturn int32(floats.MaxIdx(logits64)), nil",
        "comment_created_at": "2025-02-19T22:09:16+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "Yeah I'm just going to write a for loop instead",
        "pr_file_module": null
      }
    ]
  }
]