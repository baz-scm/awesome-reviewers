[
  {
    "discussion_id": "1974221702",
    "pr_number": 9379,
    "pr_file": "server/create.go",
    "created_at": "2025-02-27T19:32:06+00:00",
    "commented_code": "return nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1974221702",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-27T19:32:06+00:00",
        "comment_author": "bmizerany",
        "comment_body": "I don't see requiring only absolute here. I wonder if adding the valid cases in tests (as per my comment below) would flush out if we need that requirement or not.",
        "pr_file_module": null
      },
      {
        "comment_id": "1974465756",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-27T23:01:10+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "The os.Root validation allows relative paths that stay within the root directory but rejects absolute paths and any paths that attempt to escape the root boundary. Added some test cases to demonstrate this, I don't see why we should allow the absolute paths. Let me know if I'm missing something.",
        "pr_file_module": null
      },
      {
        "comment_id": "1974679214",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-28T02:48:34+00:00",
        "comment_author": "bmizerany",
        "comment_body": "My thoughts were that we join the tempDir with all paths, and require they be absolute. Relative is awkward from the API perspective because it has no concept of a root directory. It just takes arbitrary file paths.\r\n\r\nI think we take a stance one way or the other:\r\n\r\n> NOTE: In either of the below, Ollama never attempts to coearce a path into the required form. Instead it rejects the whole request and nothing else happens.\r\n\r\n**Absolute Paths only:**\r\n\r\n- All paths in `files` MUST be absolute\r\n- All paths are represented in the temp directory as `filepath.Join(tmpDir, absPath)`\r\n- All joined temp paths are, as an added measure, checked with os.Root to ensure they, even at lower levels, are not attempting anything sly.\r\n\r\nExamples:\r\n\r\n```\r\n/x/y/x (valid)\r\n/a/b (valid)\r\n/o/l/l/a/m/a (valid)\r\n\r\n./x/y (invalid)\r\n../x (invalid)\r\n/a/../../b (invalid)\r\n```\r\n\r\n**Relative (rooted) Paths only:**\r\n\r\n- All paths in `files` MUST be relative to `./`\r\n- All paths will not start with `/` or `./` or `../` - `./` is implied.\r\n- All paths MUST NOT start with a `.` or `..` or `/`\r\n- All paths are represented in the temp directory as `filepath.Join(tmpDir, relPath)`\r\n- All joined temp paths are, as an added measure, checked with os.Root to ensure they, even at lower levels, are not attempting anything sly.\r\n\r\nExamples:\r\n\r\n```\r\nx/y/x (valid)\r\na/b (valid)\r\no/l/l/a/m/a (valid)\r\n\r\n./x/y (invalid)\r\n../x (invalid)\r\n/y (invalid)\r\na/../../b (invalid)\r\n```\r\n\r\n\r\nBy choosing one or the other, the code is more straight-forward, easier to reason about, and easier to maintain its stability and correctness.\r\n\r\nAlso, just to make sure it is clear: The provided paths (in whichever form we require) are always joined with the tmpDir BEFORE we pass to `(*os.Root).Stat`",
        "pr_file_module": null
      },
      {
        "comment_id": "1974797911",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-28T05:20:04+00:00",
        "comment_author": "bmizerany",
        "comment_body": "Also, if we mix, what happens if we have both:\r\n\r\n```\r\nfilepath.Join(tmpDir, \"/a/b\")\r\nfilepath.Join(tmpDir, \"a/b\")\r\n```\r\n\r\n?",
        "pr_file_module": null
      },
      {
        "comment_id": "1975945415",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-28T19:56:49+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "I agree with your assessment of the \"Relative (rooted) Paths only\" approach. Here's how I would clarify it:\r\n\r\n### Relative (rooted) Paths only:\r\n\r\nAll paths in files MUST be relative to the current directory (without any traversal components):\r\n- Paths MUST NOT start with \"/\" (absolute paths)\r\n- Paths MUST NOT start with \"./\" or \"../\" (explicit current/parent directory references)\r\n- Paths MUST NOT be just \".\" or \"..\"\r\n- Paths MUST NOT contain traversal sequences anywhere (\"/../\", \"/./\") \r\n- Paths MUST NOT end with traversal components (\"/..\") or current directory references (\"/.\")\r\n- All paths are represented in the temp directory as filepath.Join(tmpDir, relPath)\r\n- All joined temp paths are, as an added measure, checked to ensure they remain within the base directory\r\n\r\n### Valid Examples:\r\n- \"x/y/z\" - Simple nested path\r\n- \"a/b\" - Simple path with one directory\r\n- \"o/l/l/a/m/a\" - Multiple nested directories\r\n- \"file.txt\" - File in root\r\n- \"dir/file.txt\" - File in subdirectory\r\n- \"a/b/\" - Paths with trailing slash\r\n- \"a//b\" - Paths with double slash (will be normalized)\r\n\r\n### Invalid Examples:\r\n- \"/y\" - Absolute path\r\n- \"./x/y\" - Starts with current directory reference\r\n- \"../x\" - Starts with parent directory reference\r\n- \".\" - Current directory only\r\n- \"..\" - Parent directory only\r\n- \"a/../b\" - Contains traversal component\r\n- \"a/./b\" - Contains current directory reference\r\n- \"a/../../b\" - Contains traversal beyond boundaries\r\n- \"a/b/..\" - Ends with parent directory reference\r\n- \"a/b/.\" - Ends with current directory reference\r\n\r\n> Also, just to make sure it is clear: The provided paths (in whichever form we require) are always joined with the tmpDir BEFORE we pass to (*os.Root).Stat\r\n\r\nThis will not work since its an absolute path to the temp dir. `os.Root` rejects absolute paths. i've tweaked the logic to create/open the file through the root interface, which will properly validate containment regardless of whether the file exists or not.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1976007956",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1974221702",
        "commented_code": "@@ -221,13 +230,26 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tfp = filepath.Clean(fp)",
        "comment_created_at": "2025-02-28T21:04:17+00:00",
        "comment_author": "bmizerany",
        "comment_body": "> This will not work since its an absolute path to the temp dir. os.Root rejects absolute paths. \r\n\r\nI wasn't thinking right there. Looks awesome.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1976070131",
    "pr_number": 9379,
    "pr_file": "server/create.go",
    "created_at": "2025-02-28T22:20:26+00:00",
    "commented_code": "return nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tif !fs.ValidPath(fp) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", errFilePath, fp)\n+\t\t}",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1976070131",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1976070131",
        "commented_code": "@@ -221,8 +230,22 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tif !fs.ValidPath(fp) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", errFilePath, fp)\n+\t\t}",
        "comment_created_at": "2025-02-28T22:20:26+00:00",
        "comment_author": "mxyng",
        "comment_body": "Is this not already covered by `root.Stat`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1976074560",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1976070131",
        "commented_code": "@@ -221,8 +230,22 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tif !fs.ValidPath(fp) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", errFilePath, fp)\n+\t\t}",
        "comment_created_at": "2025-02-28T22:24:28+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "The os.Root doesn't quite work in this case, if you prefix the invalid path with a directory name, than it is seen as safe, since that results in a fs.ErrNotExist",
        "pr_file_module": null
      },
      {
        "comment_id": "1976076128",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1976070131",
        "commented_code": "@@ -221,8 +230,22 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tif !fs.ValidPath(fp) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", errFilePath, fp)\n+\t\t}",
        "comment_created_at": "2025-02-28T22:25:50+00:00",
        "comment_author": "mxyng",
        "comment_body": "Also didn't this already get checked in `CreateHandler?`",
        "pr_file_module": null
      },
      {
        "comment_id": "1976077964",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9379,
        "pr_file": "server/create.go",
        "discussion_id": "1976070131",
        "commented_code": "@@ -221,8 +230,22 @@ func convertFromSafetensors(files map[string]string, baseLayers []*layerGGML, is\n \t\treturn nil, err\n \t}\n \tdefer os.RemoveAll(tmpDir)\n+\t// Set up a root to validate paths\n+\troot, err := os.OpenRoot(tmpDir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer root.Close()\n \n \tfor fp, digest := range files {\n+\t\tif !fs.ValidPath(fp) {\n+\t\t\treturn nil, fmt.Errorf(\"%w: %s\", errFilePath, fp)\n+\t\t}",
        "comment_created_at": "2025-02-28T22:28:08+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "Yup, checking both since I dont want to rely on this only being called through createHandler, but want to fail fast if I can",
        "pr_file_module": null
      }
    ]
  }
]