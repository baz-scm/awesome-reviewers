[
  {
    "discussion_id": "2103553639",
    "pr_number": 10584,
    "pr_file": "cmd/cmd.go",
    "created_at": "2025-05-22T23:19:03+00:00",
    "commented_code": "return rootCmd\n }\n+\n+// If the user has explicitly set thinking options, either through the CLI or\n+// through the `/set think` or `set nothink` interactive options, then we\n+// respect them. Otherwise, we check model capabilities to see if the model\n+// supports thinking. If the model does support thinking, we enable it.\n+// Otherwise, we unset the thinking option (which is different than setting it\n+// to false).\n+//\n+// If capabilities are not provided, we fetch them from the server.\n+func inferThinkingOption(caps *[]model.Capability, runOpts *runOptions, explicitlySetByUser bool) (error, *bool) {",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2103553639",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10584,
        "pr_file": "cmd/cmd.go",
        "discussion_id": "2103553639",
        "commented_code": "@@ -1488,3 +1580,45 @@ func NewCLI() *cobra.Command {\n \n \treturn rootCmd\n }\n+\n+// If the user has explicitly set thinking options, either through the CLI or\n+// through the `/set think` or `set nothink` interactive options, then we\n+// respect them. Otherwise, we check model capabilities to see if the model\n+// supports thinking. If the model does support thinking, we enable it.\n+// Otherwise, we unset the thinking option (which is different than setting it\n+// to false).\n+//\n+// If capabilities are not provided, we fetch them from the server.\n+func inferThinkingOption(caps *[]model.Capability, runOpts *runOptions, explicitlySetByUser bool) (error, *bool) {",
        "comment_created_at": "2025-05-22T23:19:03+00:00",
        "comment_author": "ParthSareen",
        "comment_body": "nit errors are usually on the right in go:\r\n```suggestion\r\nfunc inferThinkingOption(caps *[]model.Capability, runOpts *runOptions, explicitlySetByUser bool) (*bool, error) {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2109824042",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10584,
        "pr_file": "cmd/cmd.go",
        "discussion_id": "2103553639",
        "commented_code": "@@ -1488,3 +1580,45 @@ func NewCLI() *cobra.Command {\n \n \treturn rootCmd\n }\n+\n+// If the user has explicitly set thinking options, either through the CLI or\n+// through the `/set think` or `set nothink` interactive options, then we\n+// respect them. Otherwise, we check model capabilities to see if the model\n+// supports thinking. If the model does support thinking, we enable it.\n+// Otherwise, we unset the thinking option (which is different than setting it\n+// to false).\n+//\n+// If capabilities are not provided, we fetch them from the server.\n+func inferThinkingOption(caps *[]model.Capability, runOpts *runOptions, explicitlySetByUser bool) (error, *bool) {",
        "comment_created_at": "2025-05-27T17:55:50+00:00",
        "comment_author": "drifkin",
        "comment_body": "thank you! I keep forgetting the order \ud83d\ude35\u200d\ud83d\udcab",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057109318",
    "pr_number": 10363,
    "pr_file": "fs/ggml/gguf.go",
    "created_at": "2025-04-24T00:45:27+00:00",
    "commented_code": "if err := binary.Write(w, binary.LittleEndian, uint64(len(s))); err != nil {\n \t\treturn err\n \t}\n-\n-\treturn binary.Write(w, binary.LittleEndian, s)\n+\tif t == ggufTypeString {\n+\t\tfor _, s := range s {\n+\t\t\tstr := any(s).(string)\n+\t\t\tif err := binary.Write(w, binary.LittleEndian, uint64(len(str))); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err := io.Copy(w, strings.NewReader(str))\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\treturn binary.Write(w, binary.LittleEndian, s)",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2057109318",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10363,
        "pr_file": "fs/ggml/gguf.go",
        "discussion_id": "2057109318",
        "commented_code": "@@ -498,8 +499,21 @@ func writeGGUFArray[S ~[]E, E any](w io.Writer, t uint32, s S) error {\n \tif err := binary.Write(w, binary.LittleEndian, uint64(len(s))); err != nil {\n \t\treturn err\n \t}\n-\n-\treturn binary.Write(w, binary.LittleEndian, s)\n+\tif t == ggufTypeString {\n+\t\tfor _, s := range s {\n+\t\t\tstr := any(s).(string)\n+\t\t\tif err := binary.Write(w, binary.LittleEndian, uint64(len(str))); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t_, err := io.Copy(w, strings.NewReader(str))\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\treturn binary.Write(w, binary.LittleEndian, s)",
        "comment_created_at": "2025-04-24T00:45:27+00:00",
        "comment_author": "jmorganca",
        "comment_body": "Nit: we can short circuit return above instead of the else",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2023622179",
    "pr_number": 10066,
    "pr_file": "server/images.go",
    "created_at": "2025-04-01T20:19:39+00:00",
    "commented_code": "Template *template.Template\n }\n \n-// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n-// any missing or unknown capabilities\n-func (m *Model) CheckCapabilities(caps ...Capability) error {\n-\tvar errs []error\n-\tfor _, cap := range caps {\n-\t\tswitch cap {\n-\t\tcase CapabilityCompletion:\n-\t\t\tr, err := os.Open(m.ModelPath)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tdefer r.Close()\n+// Capabilities returns the capabilities that the model supports\n+func (m *Model) Capabilities() []model.Capability {\n+\tcapabilities := []model.Capability{}\n \n-\t\t\t// TODO(mxyng): decode the GGML into model to avoid doing this multiple times\n-\t\t\tf, _, err := ggml.Decode(r, 0)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t// Check for completion capability\n+\tr, err := os.Open(m.ModelPath)\n+\tif err == nil {\n+\t\tdefer r.Close()\n \n+\t\tf, _, err := ggml.Decode(r, 0)\n+\t\tif err == nil {\n \t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.pooling_type\", f.KV().Architecture())]; ok {\n-\t\t\t\terrs = append(errs, errCapabilityCompletion)\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityEmbedding)\n+\t\t\t} else {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityCompletion)\n \t\t\t}\n-\t\tcase CapabilityTools:\n-\t\t\tif !slices.Contains(m.Template.Vars(), \"tools\") {\n-\t\t\t\terrs = append(errs, errCapabilityTools)\n+\t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.vision.block_count\", f.KV().Architecture())]; ok {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityVision)\n \t\t\t}\n-\t\tcase CapabilityInsert:\n-\t\t\tvars := m.Template.Vars()\n-\t\t\tif !slices.Contains(vars, \"suffix\") {\n-\t\t\t\terrs = append(errs, errCapabilityInsert)\n+\t\t} else {\n+\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n+\t\t}\n+\t} else {\n+\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n+\t}\n+\n+\tif m.Template == nil {\n+\t\treturn capabilities\n+\t}\n+\n+\t// Check for tools capability\n+\tif slices.Contains(m.Template.Vars(), \"tools\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityTools)\n+\t}\n+\n+\t// Check for insert capability\n+\tif slices.Contains(m.Template.Vars(), \"suffix\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityInsert)\n+\t}\n+\n+\treturn capabilities\n+}\n+\n+// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n+// any missing or unknown capabilities\n+func (m *Model) CheckCapabilities(caps ...model.Capability) error {\n+\tmodelCaps := m.Capabilities()",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2023622179",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10066,
        "pr_file": "server/images.go",
        "discussion_id": "2023622179",
        "commented_code": "@@ -72,38 +66,71 @@ type Model struct {\n \tTemplate *template.Template\n }\n \n-// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n-// any missing or unknown capabilities\n-func (m *Model) CheckCapabilities(caps ...Capability) error {\n-\tvar errs []error\n-\tfor _, cap := range caps {\n-\t\tswitch cap {\n-\t\tcase CapabilityCompletion:\n-\t\t\tr, err := os.Open(m.ModelPath)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tdefer r.Close()\n+// Capabilities returns the capabilities that the model supports\n+func (m *Model) Capabilities() []model.Capability {\n+\tcapabilities := []model.Capability{}\n \n-\t\t\t// TODO(mxyng): decode the GGML into model to avoid doing this multiple times\n-\t\t\tf, _, err := ggml.Decode(r, 0)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t// Check for completion capability\n+\tr, err := os.Open(m.ModelPath)\n+\tif err == nil {\n+\t\tdefer r.Close()\n \n+\t\tf, _, err := ggml.Decode(r, 0)\n+\t\tif err == nil {\n \t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.pooling_type\", f.KV().Architecture())]; ok {\n-\t\t\t\terrs = append(errs, errCapabilityCompletion)\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityEmbedding)\n+\t\t\t} else {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityCompletion)\n \t\t\t}\n-\t\tcase CapabilityTools:\n-\t\t\tif !slices.Contains(m.Template.Vars(), \"tools\") {\n-\t\t\t\terrs = append(errs, errCapabilityTools)\n+\t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.vision.block_count\", f.KV().Architecture())]; ok {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityVision)\n \t\t\t}\n-\t\tcase CapabilityInsert:\n-\t\t\tvars := m.Template.Vars()\n-\t\t\tif !slices.Contains(vars, \"suffix\") {\n-\t\t\t\terrs = append(errs, errCapabilityInsert)\n+\t\t} else {\n+\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n+\t\t}\n+\t} else {\n+\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n+\t}\n+\n+\tif m.Template == nil {\n+\t\treturn capabilities\n+\t}\n+\n+\t// Check for tools capability\n+\tif slices.Contains(m.Template.Vars(), \"tools\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityTools)\n+\t}\n+\n+\t// Check for insert capability\n+\tif slices.Contains(m.Template.Vars(), \"suffix\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityInsert)\n+\t}\n+\n+\treturn capabilities\n+}\n+\n+// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n+// any missing or unknown capabilities\n+func (m *Model) CheckCapabilities(caps ...model.Capability) error {\n+\tmodelCaps := m.Capabilities()",
        "comment_created_at": "2025-04-01T20:19:39+00:00",
        "comment_author": "pdevine",
        "comment_body": "The nested switch statements feel really fussy to me. I think this would be easier like:\n```\ncapErrMap := map[model.Capability]error{\n    model.CapabilityCompletion: errCapabilityCompletion,\n    modelCapability.Tools: errCapabilityTools,\n    ...\n}\n\nyou could then just do something like:\n\nfor _, cap := range caps {\n    errCap, ok := capErrMap[cap]\n    if !ok {\n        return fmt.Errorf(\"unknown capability: %s\", cap)\n    }\n    if !slices.Contains(modelCaps, cap) {\n        errs = append(errs, errCap)\n    }\n}\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2023699907",
        "repo_full_name": "ollama/ollama",
        "pr_number": 10066,
        "pr_file": "server/images.go",
        "discussion_id": "2023622179",
        "commented_code": "@@ -72,38 +66,71 @@ type Model struct {\n \tTemplate *template.Template\n }\n \n-// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n-// any missing or unknown capabilities\n-func (m *Model) CheckCapabilities(caps ...Capability) error {\n-\tvar errs []error\n-\tfor _, cap := range caps {\n-\t\tswitch cap {\n-\t\tcase CapabilityCompletion:\n-\t\t\tr, err := os.Open(m.ModelPath)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tdefer r.Close()\n+// Capabilities returns the capabilities that the model supports\n+func (m *Model) Capabilities() []model.Capability {\n+\tcapabilities := []model.Capability{}\n \n-\t\t\t// TODO(mxyng): decode the GGML into model to avoid doing this multiple times\n-\t\t\tf, _, err := ggml.Decode(r, 0)\n-\t\t\tif err != nil {\n-\t\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t// Check for completion capability\n+\tr, err := os.Open(m.ModelPath)\n+\tif err == nil {\n+\t\tdefer r.Close()\n \n+\t\tf, _, err := ggml.Decode(r, 0)\n+\t\tif err == nil {\n \t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.pooling_type\", f.KV().Architecture())]; ok {\n-\t\t\t\terrs = append(errs, errCapabilityCompletion)\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityEmbedding)\n+\t\t\t} else {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityCompletion)\n \t\t\t}\n-\t\tcase CapabilityTools:\n-\t\t\tif !slices.Contains(m.Template.Vars(), \"tools\") {\n-\t\t\t\terrs = append(errs, errCapabilityTools)\n+\t\t\tif _, ok := f.KV()[fmt.Sprintf(\"%s.vision.block_count\", f.KV().Architecture())]; ok {\n+\t\t\t\tcapabilities = append(capabilities, model.CapabilityVision)\n \t\t\t}\n-\t\tcase CapabilityInsert:\n-\t\t\tvars := m.Template.Vars()\n-\t\t\tif !slices.Contains(vars, \"suffix\") {\n-\t\t\t\terrs = append(errs, errCapabilityInsert)\n+\t\t} else {\n+\t\t\tslog.Error(\"couldn't decode ggml\", \"error\", err)\n+\t\t}\n+\t} else {\n+\t\tslog.Error(\"couldn't open model file\", \"error\", err)\n+\t}\n+\n+\tif m.Template == nil {\n+\t\treturn capabilities\n+\t}\n+\n+\t// Check for tools capability\n+\tif slices.Contains(m.Template.Vars(), \"tools\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityTools)\n+\t}\n+\n+\t// Check for insert capability\n+\tif slices.Contains(m.Template.Vars(), \"suffix\") {\n+\t\tcapabilities = append(capabilities, model.CapabilityInsert)\n+\t}\n+\n+\treturn capabilities\n+}\n+\n+// CheckCapabilities checks if the model has the specified capabilities returning an error describing\n+// any missing or unknown capabilities\n+func (m *Model) CheckCapabilities(caps ...model.Capability) error {\n+\tmodelCaps := m.Capabilities()",
        "comment_created_at": "2025-04-01T21:26:34+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "Nice, this is easier to read. Made the change.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006944736",
    "pr_number": 9892,
    "pr_file": "kvcache/causal.go",
    "created_at": "2025-03-21T06:44:02+00:00",
    "commented_code": "}\n \t}\n \n-\treturn 0, fmt.Errorf(\"%w (length: %v)\", ErrKvCacheFull, c.Capacity)\n+\treturn 0, fmt.Errorf(\"%w (length: %v)\", ErrKvCacheFull, len(c.cells))\n+}\n+\n+func (c *Causal) updateSlidingWindow() {\n+\tif c.windowSize != math.MaxInt32 {",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "2006944736",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9892,
        "pr_file": "kvcache/causal.go",
        "discussion_id": "2006944736",
        "commented_code": "@@ -210,7 +218,49 @@ func (c *Causal) findStartLoc() (int, error) {\n \t\t}\n \t}\n \n-\treturn 0, fmt.Errorf(\"%w (length: %v)\", ErrKvCacheFull, c.Capacity)\n+\treturn 0, fmt.Errorf(\"%w (length: %v)\", ErrKvCacheFull, len(c.cells))\n+}\n+\n+func (c *Causal) updateSlidingWindow() {\n+\tif c.windowSize != math.MaxInt32 {",
        "comment_created_at": "2025-03-21T06:44:02+00:00",
        "comment_author": "jmorganca",
        "comment_body": "nit/optional, but we could return early here\r\n\r\n```\r\nif c.windowSize == math.MaxInt32 {\r\n    return\r\n}\r\n\r\n...\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993955559",
    "pr_number": 9703,
    "pr_file": "fs/ggml/ggml.go",
    "created_at": "2025-03-13T16:57:08+00:00",
    "commented_code": "}\n \n func (llm GGML) VisionGraphSize() (weights, graphSize uint64) {\n-\tswitch llm.KV().Architecture() {\n-\tcase \"mllama\":\n-\t\tfor _, layer := range llm.Tensors().GroupLayers()[\"v\"] {\n-\t\t\tweights += layer.Size()\n+\tfor name, layer := range llm.Tensors().GroupLayers() {\n+\t\tif strings.HasPrefix(name, \"v.\") {\n+\t\t\tfor _, tensor := range layer {\n+\t\t\t\tweights += tensor.Size()\n+\t\t\t}\n \t\t}\n+\t}\n \n+\tswitch llm.KV().Architecture() {",
    "repo_full_name": "ollama/ollama",
    "discussion_comments": [
      {
        "comment_id": "1993955559",
        "repo_full_name": "ollama/ollama",
        "pr_number": 9703,
        "pr_file": "fs/ggml/ggml.go",
        "discussion_id": "1993955559",
        "commented_code": "@@ -579,12 +579,16 @@ func (f GGML) GraphSize(context, batch uint64, kvCacheType string) (kv, partialO\n }\n \n func (llm GGML) VisionGraphSize() (weights, graphSize uint64) {\n-\tswitch llm.KV().Architecture() {\n-\tcase \"mllama\":\n-\t\tfor _, layer := range llm.Tensors().GroupLayers()[\"v\"] {\n-\t\t\tweights += layer.Size()\n+\tfor name, layer := range llm.Tensors().GroupLayers() {\n+\t\tif strings.HasPrefix(name, \"v.\") {\n+\t\t\tfor _, tensor := range layer {\n+\t\t\t\tweights += tensor.Size()\n+\t\t\t}\n \t\t}\n+\t}\n \n+\tswitch llm.KV().Architecture() {",
        "comment_created_at": "2025-03-13T16:57:08+00:00",
        "comment_author": "BruceMacD",
        "comment_body": "Consider using an if statement instead of a switch with a single case, as it would be more idiomatic Go for this scenario and potentially improve readability.",
        "pr_file_module": null
      }
    ]
  }
]