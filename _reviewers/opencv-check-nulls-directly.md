---
title: Check nulls directly
description: Check objects directly for null/empty state instead of using separate
  tracking variables. Always perform null checks early in your functions, before entering
  resource-intensive blocks or operations that assume non-null values.
repository: opencv/opencv
label: Null Handling
language: Other
comments_count: 2
repository_stars: 82865
---

Check objects directly for null/empty state instead of using separate tracking variables. Always perform null checks early in your functions, before entering resource-intensive blocks or operations that assume non-null values.

**Don't do this:**
```cpp
// Using a separate boolean flag to track object state
std::shared_ptr<dnn::Net> qbar_sr;
bool net_loaded_ = false;  // Redundant tracking variable

void someFunction() {
    if (net_loaded_) {  // Indirect check through tracking variable
        qbar_sr->performOperation();
    }
}
```

**Do this instead:**
```cpp
// Check the object directly
std::shared_ptr<dnn::Net> qbar_sr;

void someFunction() {
    if (qbar_sr) {  // Direct check of the object itself
        qbar_sr->performOperation();
    }
}
```

And always check for null parameters at the beginning of functions:

```cpp
void processData(const char* name) {
    // Check nulls early, before any processing or resource allocation
    if (name == NULL) {
        handleError("NULL name parameter");
        return;
    }
    
    // Now it's safe to use the parameter
    processName(name);
}
```

This approach improves code readability, reduces state tracking errors, and prevents null dereference bugs by ensuring validation happens before any operations that assume non-null values.


[
  {
    "discussion_id": "1856452050",
    "pr_number": 26499,
    "pr_file": "modules/objdetect/src/qrcode_sr_scale/super_scale.hpp",
    "created_at": "2024-11-25T11:32:54+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n//\n// Tencent is pleased to support the open source community by making WeChat QRCode available.\n// Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n\n#ifndef __SCALE_SUPER_SCALE_HPP_\n#define __SCALE_SUPER_SCALE_HPP_\n\n#include <stdio.h>\n#include \"opencv2/dnn.hpp\"\n#include \"opencv2/imgproc.hpp\"\nusing namespace std;\n\nnamespace cv {\nclass SuperScale {\npublic:\n    SuperScale(){};\n    ~SuperScale(){};\n    int init(const std::string &config_path);\n    std::vector<float> getScaleList(const int width, const int height);\n    Mat ProcessImageScale(const Mat &src, float scale, const bool &use_sr, int sr_max_size = 160);\n\nprivate:\n    std::shared_ptr<dnn::Net> qbar_sr;\n    bool net_loaded_ = false;",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1856452050",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26499,
        "pr_file": "modules/objdetect/src/qrcode_sr_scale/super_scale.hpp",
        "discussion_id": "1856452050",
        "commented_code": "@@ -0,0 +1,31 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+//\n+// Tencent is pleased to support the open source community by making WeChat QRCode available.\n+// Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n+\n+#ifndef __SCALE_SUPER_SCALE_HPP_\n+#define __SCALE_SUPER_SCALE_HPP_\n+\n+#include <stdio.h>\n+#include \"opencv2/dnn.hpp\"\n+#include \"opencv2/imgproc.hpp\"\n+using namespace std;\n+\n+namespace cv {\n+class SuperScale {\n+public:\n+    SuperScale(){};\n+    ~SuperScale(){};\n+    int init(const std::string &config_path);\n+    std::vector<float> getScaleList(const int width, const int height);\n+    Mat ProcessImageScale(const Mat &src, float scale, const bool &use_sr, int sr_max_size = 160);\n+\n+private:\n+    std::shared_ptr<dnn::Net> qbar_sr;\n+    bool net_loaded_ = false;",
        "comment_created_at": "2024-11-25T11:32:54+00:00",
        "comment_author": "dkurt",
        "comment_body": "Check `qbar_sr` is not empty instead of separate boolean flag",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1910095401",
    "pr_number": 26660,
    "pr_file": "modules/highgui/src/window_cocoa.mm",
    "created_at": "2025-01-10T09:42:19+00:00",
    "commented_code": "if( floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_5 )\n        [application setActivationPolicy:NSApplicationActivationPolicyRegular];\n#endif\n    //[application finishLaunching];\n    //atexit(icvCocoaCleanup);\n\n    setlocale(LC_NUMERIC,\"C\");\n\n    return 0;\n}\n\nstatic CVWindow *cvGetWindow(const char *name) {\n    //cout << \"cvGetWindow\" << endl;\n    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n    NSString *cvname = [NSString stringWithFormat:@\"%s\", name];\n    CVWindow* retval = (CVWindow*) [windows valueForKey:cvname] ;\n    //cout << \"retain count: \" << [retval retainCount] << endl;\n    //retval = [retval retain];\n    //cout << \"retain count: \" << [retval retainCount] << endl;\n    [localpool drain];\n    //cout << \"retain count: \" << [retval retainCount] << endl;\n    return retval;\n    @autoreleasepool{\n        NSString *cvname = [NSString stringWithFormat:@\"%s\", name];\n        CVWindow* retval = (CVWindow*) [windows valueForKey:cvname];\n        return retval;\n    }\n}\n\nCV_IMPL int cvStartWindowThread()\n{\n    //cout << \"cvStartWindowThread\" << endl;\n    return 0;\n}\n\nCV_IMPL void cvDestroyWindow( const char* name)\n{\n\n    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n    //cout << \"cvDestroyWindow\" << endl;\n    CVWindow *window = cvGetWindow(name);\n    if(window) {\n        if ([window styleMask] & NSFullScreenWindowMask) {\n            [window toggleFullScreen:nil];\n    @autoreleasepool {\n        CVWindow *window = cvGetWindow(name);\n        if(window) {\n            if ([window styleMask] & NSFullScreenWindowMask) {\n                [window toggleFullScreen:nil];\n            }\n            [window close];\n                [windows removeObjectForKey:[NSString stringWithFormat:@\"%s\", name]];\n        }\n        [window close];\n        [windows removeObjectForKey:[NSString stringWithFormat:@\"%s\", name]];\n    }\n    [localpool drain];\n}\n\n\nCV_IMPL void cvDestroyAllWindows( void )\n{\n    //cout << \"cvDestroyAllWindows\" << endl;\n    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n    NSDictionary* list = [NSDictionary dictionaryWithDictionary:windows];\n    for(NSString *key in list) {\n        cvDestroyWindow([key cStringUsingEncoding:NSASCIIStringEncoding]);\n    @autoreleasepool {\n        NSDictionary* list = [NSDictionary dictionaryWithDictionary:windows];\n        for(NSString *key in list) {\n            cvDestroyWindow([key cStringUsingEncoding:NSASCIIStringEncoding]);\n        }\n    }\n    [localpool drain];\n}\n\n\nCV_IMPL void cvShowImage( const char* name, const CvArr* arr)\n{\n    //cout << \"cvShowImage\" << endl;\n    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n    CVWindow *window = cvGetWindow(name);\n    if(!window)\n    {\n        cvNamedWindow(name, CV_WINDOW_AUTOSIZE);\n        window = cvGetWindow(name);\n    }\n    @autoreleasepool{\n        CVWindow *window = cvGetWindow(name);\n        if(!window)\n        {\n            cvNamedWindow(name, CV_WINDOW_AUTOSIZE);\n            window = cvGetWindow(name);\n        }\n\n    if(window)\n    {\n        bool empty = [[window contentView] image] == nil;\n        NSRect vrectOld = [[window contentView] frame];\n        NSSize oldImageSize = [[[window contentView] image] size];\n        [[window contentView] setImageData:(CvArr *)arr];\n        if([window autosize] || [window firstContent] || empty)\n        if(window)\n        {\n            NSSize imageSize = [[[window contentView] image] size];\n            // Only adjust the image size if the new image is a different size from the previous\n            if (oldImageSize.height != imageSize.height || oldImageSize.width != imageSize.width)\n            bool empty = [[window contentView] image] == nil;\n            NSRect vrectOld = [[window contentView] frame];\n            NSSize oldImageSize = [[[window contentView] image] size];\n            [[window contentView] setImageData:(CvArr *)arr];\n            if([window autosize] || [window firstContent] || empty)\n            {\n                //Set new view size considering sliders (reserve height and min width)\n                NSSize scaledImageSize = imageSize;\n                if ([[window contentView] respondsToSelector:@selector(convertSizeFromBacking:)])\n                NSSize imageSize = [[[window contentView] image] size];\n                // Only adjust the image size if the new image is a different size from the previous\n                if (oldImageSize.height != imageSize.height || oldImageSize.width != imageSize.width)\n                {\n                    // Only resize for retina displays if the image is bigger than the screen\n                    NSSize screenSize = NSScreen.mainScreen.visibleFrame.size;\n                    CGFloat titleBarHeight = window.frame.size.height - [window contentRectForFrameRect:window.frame].size.height;\n                    screenSize.height -= titleBarHeight;\n                    if (imageSize.width > screenSize.width || imageSize.height > screenSize.height)\n                    //Set new view size considering sliders (reserve height and min width)\n                    NSSize scaledImageSize = imageSize;\n                    if ([[window contentView] respondsToSelector:@selector(convertSizeFromBacking:)])\n                    {\n                        CGFloat fx = screenSize.width/std::max(imageSize.width, (CGFloat)1.f);\n                        CGFloat fy = screenSize.height/std::max(imageSize.height, (CGFloat)1.f);\n                        CGFloat min_f = std::min(fx, fy);\n                        scaledImageSize = [[window contentView] convertSizeFromBacking:imageSize];\n                        scaledImageSize.width = std::min(scaledImageSize.width, min_f*imageSize.width);\n                        scaledImageSize.height = std::min(scaledImageSize.height, min_f*imageSize.height);\n                        // Only resize for retina displays if the image is bigger than the screen\n                        NSSize screenSize = NSScreen.mainScreen.visibleFrame.size;\n                        CGFloat titleBarHeight = window.frame.size.height - [window contentRectForFrameRect:window.frame].size.height;\n                        screenSize.height -= titleBarHeight;\n                        if (imageSize.width > screenSize.width || imageSize.height > screenSize.height)\n                        {\n                            CGFloat fx = screenSize.width/std::max(imageSize.width, (CGFloat)1.f);\n                            CGFloat fy = screenSize.height/std::max(imageSize.height, (CGFloat)1.f);\n                            CGFloat min_f = std::min(fx, fy);\n                            scaledImageSize = [[window contentView] convertSizeFromBacking:imageSize];\n                            scaledImageSize.width = std::min(scaledImageSize.width, min_f*imageSize.width);\n                            scaledImageSize.height = std::min(scaledImageSize.height, min_f*imageSize.height);\n                        }\n                    }\n                }\n                NSSize contentSize = vrectOld.size;\n                contentSize.height = scaledImageSize.height + [window contentView].sliderHeight;\n                contentSize.width = std::max<int>(scaledImageSize.width, MIN_SLIDER_WIDTH);\n                [window setContentSize:contentSize]; //adjust sliders to fit new window size\n                if([window firstContent])\n                {\n                    int x = [window x0];\n                    int y = [window y0];\n                    if(x >= 0 && y >= 0)\n                    NSSize contentSize = vrectOld.size;\n                    contentSize.height = scaledImageSize.height + [window contentView].sliderHeight;\n                    contentSize.width = std::max<int>(scaledImageSize.width, MIN_SLIDER_WIDTH);\n                    [window setContentSize:contentSize]; //adjust sliders to fit new window size\n                    if([window firstContent])\n                    {\n                        y = [[window screen] visibleFrame].size.height - y;\n                        [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n                        int x = [window x0];\n                        int y = [window y0];\n                        if(x >= 0 && y >= 0)\n                        {\n                            y = [[window screen] visibleFrame].size.height - y;\n                            [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n                        }\n                    }\n                }\n            }\n            [window setFirstContent:NO];\n        }\n        [window setFirstContent:NO];\n    }\n    [localpool drain];\n}\n\nCV_IMPL void cvResizeWindow( const char* name, int width, int height)\n{\n\n    //cout << \"cvResizeWindow\" << endl;\n    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n    CVWindow *window = cvGetWindow(name);\n    if(window && ![window autosize]) {\n        height += [window contentView].sliderHeight;\n        NSSize size = { (CGFloat)width, (CGFloat)height };\n        [window setContentSize:size];\n    @autoreleasepool{\n        CVWindow *window = cvGetWindow(name);\n        if(window && ![window autosize]) {\n            height += [window contentView].sliderHeight;\n            NSSize size = { (CGFloat)width, (CGFloat)height };\n            [window setContentSize:size];\n        }\n    }\n    [localpool drain];\n}\n\nCV_IMPL void cvMoveWindow( const char* name, int x, int y)\n{\n    CV_FUNCNAME(\"cvMoveWindow\");\n    __BEGIN__;\n\n    NSAutoreleasePool* localpool1 = [[NSAutoreleasePool alloc] init];\n    CVWindow *window = nil;\n    __BEGIN__;\n    @autoreleasepool{\n        CVWindow *window = nil;\n\n    if(name == NULL)\n        CV_ERROR( CV_StsNullPtr, \"NULL window name\" );\n    //cout << \"cvMoveWindow\"<< endl;\n    window = cvGetWindow(name);\n    if(window) {\n        if([window firstContent]) {\n            [window setX0:x];\n            [window setY0:y];\n        }\n        else {\n            y = [[window screen] visibleFrame].size.height - y;\n            [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n        if(name == NULL)\n            CV_ERROR( CV_StsNullPtr, \"NULL window name\" );\n        window = cvGetWindow(name);\n        if(window) {\n            if([window firstContent]) {\n                [window setX0:x];\n                [window setY0:y];\n            }\n            else {\n                y = [[window screen] visibleFrame].size.height - y;\n                [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n            }\n        }\n    }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1910095401",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26660,
        "pr_file": "modules/highgui/src/window_cocoa.mm",
        "discussion_id": "1910095401",
        "commented_code": "@@ -161,162 +146,145 @@ CV_IMPL int cvInitSystem( int , char** )\n     if( floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_5 )\n         [application setActivationPolicy:NSApplicationActivationPolicyRegular];\n #endif\n-    //[application finishLaunching];\n-    //atexit(icvCocoaCleanup);\n-\n     setlocale(LC_NUMERIC,\"C\");\n \n     return 0;\n }\n \n static CVWindow *cvGetWindow(const char *name) {\n-    //cout << \"cvGetWindow\" << endl;\n-    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n-    NSString *cvname = [NSString stringWithFormat:@\"%s\", name];\n-    CVWindow* retval = (CVWindow*) [windows valueForKey:cvname] ;\n-    //cout << \"retain count: \" << [retval retainCount] << endl;\n-    //retval = [retval retain];\n-    //cout << \"retain count: \" << [retval retainCount] << endl;\n-    [localpool drain];\n-    //cout << \"retain count: \" << [retval retainCount] << endl;\n-    return retval;\n+    @autoreleasepool{\n+        NSString *cvname = [NSString stringWithFormat:@\"%s\", name];\n+        CVWindow* retval = (CVWindow*) [windows valueForKey:cvname];\n+        return retval;\n+    }\n }\n \n CV_IMPL int cvStartWindowThread()\n {\n-    //cout << \"cvStartWindowThread\" << endl;\n     return 0;\n }\n \n CV_IMPL void cvDestroyWindow( const char* name)\n {\n-\n-    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n-    //cout << \"cvDestroyWindow\" << endl;\n-    CVWindow *window = cvGetWindow(name);\n-    if(window) {\n-        if ([window styleMask] & NSFullScreenWindowMask) {\n-            [window toggleFullScreen:nil];\n+    @autoreleasepool {\n+        CVWindow *window = cvGetWindow(name);\n+        if(window) {\n+            if ([window styleMask] & NSFullScreenWindowMask) {\n+                [window toggleFullScreen:nil];\n+            }\n+            [window close];\n+                [windows removeObjectForKey:[NSString stringWithFormat:@\"%s\", name]];\n         }\n-        [window close];\n-        [windows removeObjectForKey:[NSString stringWithFormat:@\"%s\", name]];\n     }\n-    [localpool drain];\n }\n \n \n CV_IMPL void cvDestroyAllWindows( void )\n {\n-    //cout << \"cvDestroyAllWindows\" << endl;\n-    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n-    NSDictionary* list = [NSDictionary dictionaryWithDictionary:windows];\n-    for(NSString *key in list) {\n-        cvDestroyWindow([key cStringUsingEncoding:NSASCIIStringEncoding]);\n+    @autoreleasepool {\n+        NSDictionary* list = [NSDictionary dictionaryWithDictionary:windows];\n+        for(NSString *key in list) {\n+            cvDestroyWindow([key cStringUsingEncoding:NSASCIIStringEncoding]);\n+        }\n     }\n-    [localpool drain];\n }\n \n \n CV_IMPL void cvShowImage( const char* name, const CvArr* arr)\n {\n-    //cout << \"cvShowImage\" << endl;\n-    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n-    CVWindow *window = cvGetWindow(name);\n-    if(!window)\n-    {\n-        cvNamedWindow(name, CV_WINDOW_AUTOSIZE);\n-        window = cvGetWindow(name);\n-    }\n+    @autoreleasepool{\n+        CVWindow *window = cvGetWindow(name);\n+        if(!window)\n+        {\n+            cvNamedWindow(name, CV_WINDOW_AUTOSIZE);\n+            window = cvGetWindow(name);\n+        }\n \n-    if(window)\n-    {\n-        bool empty = [[window contentView] image] == nil;\n-        NSRect vrectOld = [[window contentView] frame];\n-        NSSize oldImageSize = [[[window contentView] image] size];\n-        [[window contentView] setImageData:(CvArr *)arr];\n-        if([window autosize] || [window firstContent] || empty)\n+        if(window)\n         {\n-            NSSize imageSize = [[[window contentView] image] size];\n-            // Only adjust the image size if the new image is a different size from the previous\n-            if (oldImageSize.height != imageSize.height || oldImageSize.width != imageSize.width)\n+            bool empty = [[window contentView] image] == nil;\n+            NSRect vrectOld = [[window contentView] frame];\n+            NSSize oldImageSize = [[[window contentView] image] size];\n+            [[window contentView] setImageData:(CvArr *)arr];\n+            if([window autosize] || [window firstContent] || empty)\n             {\n-                //Set new view size considering sliders (reserve height and min width)\n-                NSSize scaledImageSize = imageSize;\n-                if ([[window contentView] respondsToSelector:@selector(convertSizeFromBacking:)])\n+                NSSize imageSize = [[[window contentView] image] size];\n+                // Only adjust the image size if the new image is a different size from the previous\n+                if (oldImageSize.height != imageSize.height || oldImageSize.width != imageSize.width)\n                 {\n-                    // Only resize for retina displays if the image is bigger than the screen\n-                    NSSize screenSize = NSScreen.mainScreen.visibleFrame.size;\n-                    CGFloat titleBarHeight = window.frame.size.height - [window contentRectForFrameRect:window.frame].size.height;\n-                    screenSize.height -= titleBarHeight;\n-                    if (imageSize.width > screenSize.width || imageSize.height > screenSize.height)\n+                    //Set new view size considering sliders (reserve height and min width)\n+                    NSSize scaledImageSize = imageSize;\n+                    if ([[window contentView] respondsToSelector:@selector(convertSizeFromBacking:)])\n                     {\n-                        CGFloat fx = screenSize.width/std::max(imageSize.width, (CGFloat)1.f);\n-                        CGFloat fy = screenSize.height/std::max(imageSize.height, (CGFloat)1.f);\n-                        CGFloat min_f = std::min(fx, fy);\n-                        scaledImageSize = [[window contentView] convertSizeFromBacking:imageSize];\n-                        scaledImageSize.width = std::min(scaledImageSize.width, min_f*imageSize.width);\n-                        scaledImageSize.height = std::min(scaledImageSize.height, min_f*imageSize.height);\n+                        // Only resize for retina displays if the image is bigger than the screen\n+                        NSSize screenSize = NSScreen.mainScreen.visibleFrame.size;\n+                        CGFloat titleBarHeight = window.frame.size.height - [window contentRectForFrameRect:window.frame].size.height;\n+                        screenSize.height -= titleBarHeight;\n+                        if (imageSize.width > screenSize.width || imageSize.height > screenSize.height)\n+                        {\n+                            CGFloat fx = screenSize.width/std::max(imageSize.width, (CGFloat)1.f);\n+                            CGFloat fy = screenSize.height/std::max(imageSize.height, (CGFloat)1.f);\n+                            CGFloat min_f = std::min(fx, fy);\n+                            scaledImageSize = [[window contentView] convertSizeFromBacking:imageSize];\n+                            scaledImageSize.width = std::min(scaledImageSize.width, min_f*imageSize.width);\n+                            scaledImageSize.height = std::min(scaledImageSize.height, min_f*imageSize.height);\n+                        }\n                     }\n-                }\n-                NSSize contentSize = vrectOld.size;\n-                contentSize.height = scaledImageSize.height + [window contentView].sliderHeight;\n-                contentSize.width = std::max<int>(scaledImageSize.width, MIN_SLIDER_WIDTH);\n-                [window setContentSize:contentSize]; //adjust sliders to fit new window size\n-                if([window firstContent])\n-                {\n-                    int x = [window x0];\n-                    int y = [window y0];\n-                    if(x >= 0 && y >= 0)\n+                    NSSize contentSize = vrectOld.size;\n+                    contentSize.height = scaledImageSize.height + [window contentView].sliderHeight;\n+                    contentSize.width = std::max<int>(scaledImageSize.width, MIN_SLIDER_WIDTH);\n+                    [window setContentSize:contentSize]; //adjust sliders to fit new window size\n+                    if([window firstContent])\n                     {\n-                        y = [[window screen] visibleFrame].size.height - y;\n-                        [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n+                        int x = [window x0];\n+                        int y = [window y0];\n+                        if(x >= 0 && y >= 0)\n+                        {\n+                            y = [[window screen] visibleFrame].size.height - y;\n+                            [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n+                        }\n                     }\n                 }\n             }\n+            [window setFirstContent:NO];\n         }\n-        [window setFirstContent:NO];\n     }\n-    [localpool drain];\n }\n \n CV_IMPL void cvResizeWindow( const char* name, int width, int height)\n {\n-\n-    //cout << \"cvResizeWindow\" << endl;\n-    NSAutoreleasePool* localpool = [[NSAutoreleasePool alloc] init];\n-    CVWindow *window = cvGetWindow(name);\n-    if(window && ![window autosize]) {\n-        height += [window contentView].sliderHeight;\n-        NSSize size = { (CGFloat)width, (CGFloat)height };\n-        [window setContentSize:size];\n+    @autoreleasepool{\n+        CVWindow *window = cvGetWindow(name);\n+        if(window && ![window autosize]) {\n+            height += [window contentView].sliderHeight;\n+            NSSize size = { (CGFloat)width, (CGFloat)height };\n+            [window setContentSize:size];\n+        }\n     }\n-    [localpool drain];\n }\n \n CV_IMPL void cvMoveWindow( const char* name, int x, int y)\n {\n     CV_FUNCNAME(\"cvMoveWindow\");\n-    __BEGIN__;\n \n-    NSAutoreleasePool* localpool1 = [[NSAutoreleasePool alloc] init];\n-    CVWindow *window = nil;\n+    __BEGIN__;\n+    @autoreleasepool{\n+        CVWindow *window = nil;\n \n-    if(name == NULL)\n-        CV_ERROR( CV_StsNullPtr, \"NULL window name\" );\n-    //cout << \"cvMoveWindow\"<< endl;\n-    window = cvGetWindow(name);\n-    if(window) {\n-        if([window firstContent]) {\n-            [window setX0:x];\n-            [window setY0:y];\n-        }\n-        else {\n-            y = [[window screen] visibleFrame].size.height - y;\n-            [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n+        if(name == NULL)\n+            CV_ERROR( CV_StsNullPtr, \"NULL window name\" );\n+        window = cvGetWindow(name);\n+        if(window) {\n+            if([window firstContent]) {\n+                [window setX0:x];\n+                [window setY0:y];\n+            }\n+            else {\n+                y = [[window screen] visibleFrame].size.height - y;\n+                [window setFrameTopLeftPoint:NSMakePoint(x, y)];\n+            }\n         }\n     }",
        "comment_created_at": "2025-01-10T09:42:19+00:00",
        "comment_author": "VadimLevin",
        "comment_body": "\r\n```objc\r\nif (name == NULL) {\r\n    CV_ERROR( CV_StsNullPtr, \"NULL window name\" );\r\n}\r\n@autoreleasepool {\r\n        CVWindow *window = GetWindow(name);\r\n```",
        "pr_file_module": null
      }
    ]
  }
]
