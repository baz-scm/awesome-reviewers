[
  {
    "discussion_id": "2172502541",
    "pr_number": 27460,
    "pr_file": "modules/gapi/src/backends/ov/govbackend.cpp",
    "created_at": "2025-06-27T17:15:47+00:00",
    "commented_code": "const std::vector<ade::NodeHandle> &nodes)\n    : m_g(g), m_gm(m_g) {\n\n    if(cv::gapi::getCompileArg<std::reference_wrapper<cv::gapi::wip::ov::workload_type>>(compileArgs).has_value()) {",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2172502541",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27460,
        "pr_file": "modules/gapi/src/backends/ov/govbackend.cpp",
        "discussion_id": "2172502541",
        "commented_code": "@@ -1542,6 +1542,10 @@ cv::gimpl::ov::GOVExecutable::GOVExecutable(const ade::Graph &g,\n                                             const std::vector<ade::NodeHandle> &nodes)\n     : m_g(g), m_gm(m_g) {\n \n+    if(cv::gapi::getCompileArg<std::reference_wrapper<cv::gapi::wip::ov::workload_type>>(compileArgs).has_value()) {",
        "comment_created_at": "2025-06-27T17:15:47+00:00",
        "comment_author": "AsyaPronina",
        "comment_body": "Better to split this check for two lines: to retrieve compile arg and then check if it `has_value()`",
        "pr_file_module": null
      },
      {
        "comment_id": "2172504387",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27460,
        "pr_file": "modules/gapi/src/backends/ov/govbackend.cpp",
        "discussion_id": "2172502541",
        "commented_code": "@@ -1542,6 +1542,10 @@ cv::gimpl::ov::GOVExecutable::GOVExecutable(const ade::Graph &g,\n                                             const std::vector<ade::NodeHandle> &nodes)\n     : m_g(g), m_gm(m_g) {\n \n+    if(cv::gapi::getCompileArg<std::reference_wrapper<cv::gapi::wip::ov::workload_type>>(compileArgs).has_value()) {",
        "comment_created_at": "2025-06-27T17:16:22+00:00",
        "comment_author": "AsyaPronina",
        "comment_body": "or might be create a brief alias for `std::reference_wrapper` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1851047891",
    "pr_number": 26366,
    "pr_file": "modules/features2d/src/orb.cpp",
    "created_at": "2024-11-20T22:12:40+00:00",
    "commented_code": "bool useOCL = false;\n#endif\n\n    Mat image = _image.getMat(), mask = _mask.getMat();\n    Mat image = _image.getMat(), mask;\n    if (!_mask.empty())\n    {\n        cv::threshold(_mask.getMat(), mask, 0, 255, cv::THRESH_BINARY);",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1851047891",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26366,
        "pr_file": "modules/features2d/src/orb.cpp",
        "discussion_id": "1851047891",
        "commented_code": "@@ -1036,7 +1036,11 @@ void ORB_Impl::detectAndCompute( InputArray _image, InputArray _mask,\n     bool useOCL = false;\n #endif\n \n-    Mat image = _image.getMat(), mask = _mask.getMat();\n+    Mat image = _image.getMat(), mask;\n+    if (!_mask.empty())\n+    {\n+        cv::threshold(_mask.getMat(), mask, 0, 255, cv::THRESH_BINARY);",
        "comment_created_at": "2024-11-20T22:12:40+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "threshold(_mask, mask, 0, 255, THRESH_BINARY);",
        "pr_file_module": null
      },
      {
        "comment_id": "1851260237",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26366,
        "pr_file": "modules/features2d/src/orb.cpp",
        "discussion_id": "1851047891",
        "commented_code": "@@ -1036,7 +1036,11 @@ void ORB_Impl::detectAndCompute( InputArray _image, InputArray _mask,\n     bool useOCL = false;\n #endif\n \n-    Mat image = _image.getMat(), mask = _mask.getMat();\n+    Mat image = _image.getMat(), mask;\n+    if (!_mask.empty())\n+    {\n+        cv::threshold(_mask.getMat(), mask, 0, 255, cv::THRESH_BINARY);",
        "comment_created_at": "2024-11-21T03:21:15+00:00",
        "comment_author": "shyama7004",
        "comment_body": "Your snippet does the same thing but in a concise way:), do you want me to implement this change?",
        "pr_file_module": null
      },
      {
        "comment_id": "1851462580",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26366,
        "pr_file": "modules/features2d/src/orb.cpp",
        "discussion_id": "1851047891",
        "commented_code": "@@ -1036,7 +1036,11 @@ void ORB_Impl::detectAndCompute( InputArray _image, InputArray _mask,\n     bool useOCL = false;\n #endif\n \n-    Mat image = _image.getMat(), mask = _mask.getMat();\n+    Mat image = _image.getMat(), mask;\n+    if (!_mask.empty())\n+    {\n+        cv::threshold(_mask.getMat(), mask, 0, 255, cv::THRESH_BINARY);",
        "comment_created_at": "2024-11-21T06:58:16+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "yes exactly does the same thing.\r\nno need to `cv::` prefix and `.getMat()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1450572150",
    "pr_number": 24768,
    "pr_file": "modules/dnn/src/layers/nary_eltwise_layers.cpp",
    "created_at": "2024-01-12T15:02:26+00:00",
    "commented_code": "return Ptr<BackendNode>(new InfEngineNgraphNode(node));\n    }\n#endif\n\n#ifdef HAVE_VULKAN\n    virtual Ptr<BackendNode> initVkCom(const std::vector<Ptr<BackendWrapper> > &inputs,\n                                       std::vector<Ptr<BackendWrapper> > &outputs) CV_OVERRIDE\n    {\n        std::vector<Ptr<VkComBackendWrapper>> inputWrappers;\n        std::vector<MatShape> inputShapes;\n        std::transform(inputs.begin(), inputs.end(), std::back_inserter(inputWrappers), [] (const Ptr<BackendWrapper>& w) { return w.dynamicCast<VkComBackendWrapper>(); });\n        for (const auto &ptr: inputWrappers) {\n            CV_Assert(ptr);\n        }\n        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(inputShapes), [] (const Ptr<VkComBackendWrapper>& w) { return shape(*(w->getMat())); });\n        auto outputWrapper = outputs[0].dynamicCast<VkComBackendWrapper>();\n        CV_Assert(outputWrapper);\n        auto outputShape = shape(*(outputWrapper->getMat()));\n        std::vector<Mat> vkBlobs; // TODO(vk) what\n\n        // collect all input\n        int ninputs = inputs.size();\n        std::vector<const char*> v_inp;\n        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->template ptr<const char>(); });\n        // const char** inp = v_inp.data();\n\n        // collect ndims of all input\n        std::vector<int> v_inp_dims;\n        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_dims), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->dims; });\n        const int* inp_ndims = v_inp_dims.data();\n\n        // collect shapes of all input\n        std::vector<const int*> v_inp_shape;\n        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_shape), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->size.p; });\n        const int** inp_shape = v_inp_shape.data();\n\n        // collect steps of all input\n        std::vector<const size_t*> v_inp_step;\n        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_step), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->step.p; });\n        const size_t** inp_step = v_inp_step.data();\n\n        // collect info of output (ndims, shape, step)\n        // char* out = outputWrapper->getMat()->ptr<char>();\n        int out_ndims = outputWrapper->getMat()->dims;\n        const int* out_shape = outputWrapper->getMat()->size.p;\n        const size_t* out_step = outputWrapper->getMat()->step.p;\n\n        // find max ndims for broadcasting\n        int i, max_ndims = out_ndims > 2 ? out_ndims : 2;\n        for(i = 0; i < ninputs; i++)\n            max_ndims = max_ndims > inp_ndims[i] ? max_ndims : inp_ndims[i];\n\n        // buf holds the following buffers for inputs & output:\n        //  * orig_shapes, shapes (result_shape), orig_steps, steps (result_step), (ninputs+1)*4 elements in total\n        //  * ptrs, (ninputs+1)*1 elements in total\n        //  * shape_buf & step_buf, (ninputs+1)*2*max_ndims elements in total\n        //  * all_ndims, (ninputs+1)*1 elements in total\n        //  * all_type_sizes, (ninputs+1)*1 elements in total\n        AutoBuffer<size_t> buf((ninputs + 1) * (2 * max_ndims + 7));\n\n        int** orig_shapes = (int**)buf.data();\n        int** shapes = orig_shapes + ninputs + 1;\n        size_t** orig_steps = (size_t**)(shapes + ninputs + 1);\n        size_t** steps = orig_steps + ninputs + 1;\n\n        char** ptrs = (char**)(steps + ninputs + 1);\n\n        size_t* step_buf = (size_t*)(ptrs + ninputs + 1);\n        int* shape_buf = (int*)(step_buf + (ninputs + 1)*max_ndims);\n\n        int* all_ndims = shape_buf + (ninputs + 1)*max_ndims;\n        size_t* all_type_sizes = (size_t*)(all_ndims + ninputs + 1);\n\n        for(i = 0; i <= ninputs; i++) {\n            all_ndims[i] = i == 0 ? out_ndims : inp_ndims[i-1];\n            all_type_sizes[i] = i == 0 ? outputWrapper->getMat()->elemSize() : inputWrappers[i-1]->getMat()->elemSize();\n            orig_shapes[i] = (int*)(i == 0 ? out_shape : inp_shape ? inp_shape[i-1] : 0);\n            orig_steps[i] = (size_t*)(i == 0 ? out_step : inp_step ? inp_step[i-1] : 0);\n            shapes[i] = shape_buf + max_ndims*i;\n            steps[i] = step_buf + max_ndims*i;\n        }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1450572150",
        "repo_full_name": "opencv/opencv",
        "pr_number": 24768,
        "pr_file": "modules/dnn/src/layers/nary_eltwise_layers.cpp",
        "discussion_id": "1450572150",
        "commented_code": "@@ -928,6 +936,96 @@ class NaryEltwiseLayerImpl CV_FINAL : public NaryEltwiseLayer\n         return Ptr<BackendNode>(new InfEngineNgraphNode(node));\n     }\n #endif\n+\n+#ifdef HAVE_VULKAN\n+    virtual Ptr<BackendNode> initVkCom(const std::vector<Ptr<BackendWrapper> > &inputs,\n+                                       std::vector<Ptr<BackendWrapper> > &outputs) CV_OVERRIDE\n+    {\n+        std::vector<Ptr<VkComBackendWrapper>> inputWrappers;\n+        std::vector<MatShape> inputShapes;\n+        std::transform(inputs.begin(), inputs.end(), std::back_inserter(inputWrappers), [] (const Ptr<BackendWrapper>& w) { return w.dynamicCast<VkComBackendWrapper>(); });\n+        for (const auto &ptr: inputWrappers) {\n+            CV_Assert(ptr);\n+        }\n+        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(inputShapes), [] (const Ptr<VkComBackendWrapper>& w) { return shape(*(w->getMat())); });\n+        auto outputWrapper = outputs[0].dynamicCast<VkComBackendWrapper>();\n+        CV_Assert(outputWrapper);\n+        auto outputShape = shape(*(outputWrapper->getMat()));\n+        std::vector<Mat> vkBlobs; // TODO(vk) what\n+\n+        // collect all input\n+        int ninputs = inputs.size();\n+        std::vector<const char*> v_inp;\n+        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->template ptr<const char>(); });\n+        // const char** inp = v_inp.data();\n+\n+        // collect ndims of all input\n+        std::vector<int> v_inp_dims;\n+        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_dims), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->dims; });\n+        const int* inp_ndims = v_inp_dims.data();\n+\n+        // collect shapes of all input\n+        std::vector<const int*> v_inp_shape;\n+        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_shape), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->size.p; });\n+        const int** inp_shape = v_inp_shape.data();\n+\n+        // collect steps of all input\n+        std::vector<const size_t*> v_inp_step;\n+        std::transform(inputWrappers.begin(), inputWrappers.end(), std::back_inserter(v_inp_step), [] (const Ptr<VkComBackendWrapper> &w) { return (w->getMat())->step.p; });\n+        const size_t** inp_step = v_inp_step.data();\n+\n+        // collect info of output (ndims, shape, step)\n+        // char* out = outputWrapper->getMat()->ptr<char>();\n+        int out_ndims = outputWrapper->getMat()->dims;\n+        const int* out_shape = outputWrapper->getMat()->size.p;\n+        const size_t* out_step = outputWrapper->getMat()->step.p;\n+\n+        // find max ndims for broadcasting\n+        int i, max_ndims = out_ndims > 2 ? out_ndims : 2;\n+        for(i = 0; i < ninputs; i++)\n+            max_ndims = max_ndims > inp_ndims[i] ? max_ndims : inp_ndims[i];\n+\n+        // buf holds the following buffers for inputs & output:\n+        //  * orig_shapes, shapes (result_shape), orig_steps, steps (result_step), (ninputs+1)*4 elements in total\n+        //  * ptrs, (ninputs+1)*1 elements in total\n+        //  * shape_buf & step_buf, (ninputs+1)*2*max_ndims elements in total\n+        //  * all_ndims, (ninputs+1)*1 elements in total\n+        //  * all_type_sizes, (ninputs+1)*1 elements in total\n+        AutoBuffer<size_t> buf((ninputs + 1) * (2 * max_ndims + 7));\n+\n+        int** orig_shapes = (int**)buf.data();\n+        int** shapes = orig_shapes + ninputs + 1;\n+        size_t** orig_steps = (size_t**)(shapes + ninputs + 1);\n+        size_t** steps = orig_steps + ninputs + 1;\n+\n+        char** ptrs = (char**)(steps + ninputs + 1);\n+\n+        size_t* step_buf = (size_t*)(ptrs + ninputs + 1);\n+        int* shape_buf = (int*)(step_buf + (ninputs + 1)*max_ndims);\n+\n+        int* all_ndims = shape_buf + (ninputs + 1)*max_ndims;\n+        size_t* all_type_sizes = (size_t*)(all_ndims + ninputs + 1);\n+\n+        for(i = 0; i <= ninputs; i++) {\n+            all_ndims[i] = i == 0 ? out_ndims : inp_ndims[i-1];\n+            all_type_sizes[i] = i == 0 ? outputWrapper->getMat()->elemSize() : inputWrappers[i-1]->getMat()->elemSize();\n+            orig_shapes[i] = (int*)(i == 0 ? out_shape : inp_shape ? inp_shape[i-1] : 0);\n+            orig_steps[i] = (size_t*)(i == 0 ? out_step : inp_step ? inp_step[i-1] : 0);\n+            shapes[i] = shape_buf + max_ndims*i;\n+            steps[i] = step_buf + max_ndims*i;\n+        }",
        "comment_created_at": "2024-01-12T15:02:26+00:00",
        "comment_author": "fengyuentau",
        "comment_body": "Since they share the same code with CPU implementation, could you extract and make it a function to call to reduce duplicate code?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1977140260",
    "pr_number": 26934,
    "pr_file": "modules/objdetect/src/aruco/aruco_detector.cpp",
    "created_at": "2025-03-03T09:17:51+00:00",
    "commented_code": "RefineParameters refineParams;\n    ArucoDetectorImpl() {}\n\n    ArucoDetectorImpl(const Dictionary &_dictionary, const DetectorParameters &_detectorParams,\n                      const RefineParameters& _refineParams): dictionary(_dictionary),\n                      detectorParams(_detectorParams), refineParams(_refineParams) {}\n    ArucoDetectorImpl(const vector<Dictionary>&_dictionaries, const DetectorParameters &_detectorParams,\n                      const RefineParameters& _refineParams): dictionaries(_dictionaries),\n                      detectorParams(_detectorParams), refineParams(_refineParams) {\n                          CV_Assert(!dictionaries.empty());\n                      }\n\n    /*\n     * @brief Detect markers either using multiple or just first dictionary\n     */\n    void detectMarkers(InputArray _image, OutputArrayOfArrays _corners, OutputArray _ids,\n            OutputArrayOfArrays _rejectedImgPoints, OutputArray _dictIndices, DictionaryMode dictMode) {\n        CV_Assert(!_image.empty());\n\n        CV_Assert(detectorParams.markerBorderBits > 0);\n        // check that the parameters are set correctly if Aruco3 is used\n        CV_Assert(!(detectorParams.useAruco3Detection == true &&\n                    detectorParams.minSideLengthCanonicalImg == 0 &&\n                    detectorParams.minMarkerLengthRatioOriginalImg == 0.0));\n\n        Mat grey;\n        _convertToGrey(_image, grey);\n\n        // Aruco3 functionality is the extension of Aruco.\n        // The description can be found in:\n        // [1] Speeded up detection of squared fiducial markers, 2018, FJ Romera-Ramirez et al.\n        // if Aruco3 functionality if not wanted\n        // change some parameters to be sure to turn it off\n        if (!detectorParams.useAruco3Detection) {\n            detectorParams.minMarkerLengthRatioOriginalImg = 0.0;\n            detectorParams.minSideLengthCanonicalImg = 0;\n        }\n        else {\n            // always turn on corner refinement in case of Aruco3, due to upsampling\n            detectorParams.cornerRefinementMethod = (int)CORNER_REFINE_SUBPIX;\n            // only CORNER_REFINE_SUBPIX implement correctly for useAruco3Detection\n            // Todo: update other CORNER_REFINE methods\n        }\n\n        /// Step 0: equation (2) from paper [1]\n        const float fxfy = (!detectorParams.useAruco3Detection ? 1.f : detectorParams.minSideLengthCanonicalImg /\n                (detectorParams.minSideLengthCanonicalImg + std::max(grey.cols, grey.rows)*\n                 detectorParams.minMarkerLengthRatioOriginalImg));\n\n        /// Step 1: create image pyramid. Section 3.4. in [1]\n        vector<Mat> grey_pyramid;\n        int closest_pyr_image_idx = 0, num_levels = 0;\n        //// Step 1.1: resize image with equation (1) from paper [1]\n        if (detectorParams.useAruco3Detection) {\n            const float scale_pyr = 2.f;\n            const float img_area = static_cast<float>(grey.rows*grey.cols);\n            const float min_area_marker = static_cast<float>(detectorParams.minSideLengthCanonicalImg*\n                    detectorParams.minSideLengthCanonicalImg);\n            // find max level\n            num_levels = static_cast<int>(log2(img_area / min_area_marker)/scale_pyr);\n            // the closest pyramid image to the downsampled segmentation image\n            // will later be used as start index for corner upsampling\n            const float scale_img_area = img_area * fxfy * fxfy;\n            closest_pyr_image_idx = cvRound(log2(img_area / scale_img_area)/scale_pyr);\n        }\n        buildPyramid(grey, grey_pyramid, num_levels);\n\n        // resize to segmentation image\n        // in this reduces size the contours will be detected\n        if (fxfy != 1.f)\n            resize(grey, grey, Size(cvRound(fxfy * grey.cols), cvRound(fxfy * grey.rows)));\n\n        /// STEP 2: Detect marker candidates\n        vector<vector<Point2f> > candidates;\n        vector<vector<Point> > contours;\n        vector<int> ids;\n\n        /// STEP 2.a Detect marker candidates :: using AprilTag\n        if(detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_APRILTAG){\n            _apriltag(grey, detectorParams, candidates, contours);\n        }\n        /// STEP 2.b Detect marker candidates :: traditional way\n        else {\n            detectCandidates(grey, candidates, contours);\n        }\n\n        /// STEP 2.c FILTER OUT NEAR CANDIDATE PAIRS\n        vector<int> dictIndices;\n        vector<vector<Point2f>> rejectedImgPoints;\n        if (DictionaryMode::Single == dictMode) {\n            Dictionary& dictionary = dictionaries.at(0);\n            auto selectedCandidates = filterTooCloseCandidates(candidates, contours, dictionary.markerSize);\n            candidates.clear();\n            contours.clear();\n\n            /// STEP 2: Check candidate codification (identify markers)\n            identifyCandidates(grey, grey_pyramid, selectedCandidates, candidates, contours,\n                    ids, dictionary, rejectedImgPoints);\n\n            /// STEP 3: Corner refinement :: use corner subpix\n            if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {\n                CV_Assert(detectorParams.cornerRefinementWinSize > 0 && detectorParams.cornerRefinementMaxIterations > 0 &&\n                        detectorParams.cornerRefinementMinAccuracy > 0);\n                // Do subpixel estimation. In Aruco3 start on the lowest pyramid level and upscale the corners\n                parallel_for_(Range(0, (int)candidates.size()), [&](const Range& range) {\n                    const int begin = range.start;\n                    const int end = range.end;\n\n                    for (int i = begin; i < end; i++) {\n                        if (detectorParams.useAruco3Detection) {\n                            const float scale_init = (float) grey_pyramid[closest_pyr_image_idx].cols / grey.cols;\n                            findCornerInPyrImage(scale_init, closest_pyr_image_idx, grey_pyramid, Mat(candidates[i]), detectorParams);\n                        } else {\n                            int cornerRefinementWinSize = std::max(1, cvRound(detectorParams.relativeCornerRefinmentWinSize*\n                                        getAverageModuleSize(candidates[i], dictionary.markerSize, detectorParams.markerBorderBits)));\n                            cornerRefinementWinSize = min(cornerRefinementWinSize, detectorParams.cornerRefinementWinSize);\n                            cornerSubPix(grey, Mat(candidates[i]), Size(cornerRefinementWinSize, cornerRefinementWinSize), Size(-1, -1),\n                                    TermCriteria(TermCriteria::MAX_ITER | TermCriteria::EPS,\n                                        detectorParams.cornerRefinementMaxIterations,\n                                        detectorParams.cornerRefinementMinAccuracy));\n                        }\n                    }\n                });\n            }\n        } else if (DictionaryMode::Multi == dictMode) {\n            unordered_set<int> uniqueMarkerSizes;\n            for (const Dictionary& dictionary : dictionaries) {\n                uniqueMarkerSizes.insert(dictionary.markerSize);\n            }\n\n            // create at max 4 marker candidate trees for each dictionary size\n            vector<vector<MarkerCandidateTree>> candidatesPerDictionarySize = {{}, {}, {}, {}};\n            for (int markerSize : uniqueMarkerSizes) {\n                // min marker size is 4, so subtract 4 to get index\n                const auto dictionarySizeIndex = markerSize - 4;\n                // copy candidates\n                vector<vector<Point2f>> candidatesCopy = candidates;\n                vector<vector<Point> > contoursCopy = contours;\n                candidatesPerDictionarySize[dictionarySizeIndex] = filterTooCloseCandidates(candidatesCopy, contoursCopy, markerSize);\n            }\n            candidates.clear();\n            contours.clear();\n\n            /// STEP 2: Check candidate codification (identify markers)\n            int dictIndex = 0;\n            for (const Dictionary&  currentDictionary : dictionaries) {\n                const auto dictionarySizeIndex = currentDictionary.markerSize - 4;\n                // temporary variable to store the current candidates\n                vector<vector<Point2f>> currentCandidates;\n                identifyCandidates(grey, grey_pyramid, candidatesPerDictionarySize[dictionarySizeIndex], currentCandidates, contours,\n                        ids, currentDictionary, rejectedImgPoints);\n                if (_dictIndices.needed()) {\n                    dictIndices.insert(dictIndices.end(), currentCandidates.size(), dictIndex);\n                }\n\n                /// STEP 3: Corner refinement :: use corner subpix\n                if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1977140260",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26934,
        "pr_file": "modules/objdetect/src/aruco/aruco_detector.cpp",
        "discussion_id": "1977140260",
        "commented_code": "@@ -651,9 +657,257 @@ struct ArucoDetector::ArucoDetectorImpl {\n     RefineParameters refineParams;\n     ArucoDetectorImpl() {}\n \n-    ArucoDetectorImpl(const Dictionary &_dictionary, const DetectorParameters &_detectorParams,\n-                      const RefineParameters& _refineParams): dictionary(_dictionary),\n-                      detectorParams(_detectorParams), refineParams(_refineParams) {}\n+    ArucoDetectorImpl(const vector<Dictionary>&_dictionaries, const DetectorParameters &_detectorParams,\n+                      const RefineParameters& _refineParams): dictionaries(_dictionaries),\n+                      detectorParams(_detectorParams), refineParams(_refineParams) {\n+                          CV_Assert(!dictionaries.empty());\n+                      }\n+\n+    /*\n+     * @brief Detect markers either using multiple or just first dictionary\n+     */\n+    void detectMarkers(InputArray _image, OutputArrayOfArrays _corners, OutputArray _ids,\n+            OutputArrayOfArrays _rejectedImgPoints, OutputArray _dictIndices, DictionaryMode dictMode) {\n+        CV_Assert(!_image.empty());\n+\n+        CV_Assert(detectorParams.markerBorderBits > 0);\n+        // check that the parameters are set correctly if Aruco3 is used\n+        CV_Assert(!(detectorParams.useAruco3Detection == true &&\n+                    detectorParams.minSideLengthCanonicalImg == 0 &&\n+                    detectorParams.minMarkerLengthRatioOriginalImg == 0.0));\n+\n+        Mat grey;\n+        _convertToGrey(_image, grey);\n+\n+        // Aruco3 functionality is the extension of Aruco.\n+        // The description can be found in:\n+        // [1] Speeded up detection of squared fiducial markers, 2018, FJ Romera-Ramirez et al.\n+        // if Aruco3 functionality if not wanted\n+        // change some parameters to be sure to turn it off\n+        if (!detectorParams.useAruco3Detection) {\n+            detectorParams.minMarkerLengthRatioOriginalImg = 0.0;\n+            detectorParams.minSideLengthCanonicalImg = 0;\n+        }\n+        else {\n+            // always turn on corner refinement in case of Aruco3, due to upsampling\n+            detectorParams.cornerRefinementMethod = (int)CORNER_REFINE_SUBPIX;\n+            // only CORNER_REFINE_SUBPIX implement correctly for useAruco3Detection\n+            // Todo: update other CORNER_REFINE methods\n+        }\n+\n+        /// Step 0: equation (2) from paper [1]\n+        const float fxfy = (!detectorParams.useAruco3Detection ? 1.f : detectorParams.minSideLengthCanonicalImg /\n+                (detectorParams.minSideLengthCanonicalImg + std::max(grey.cols, grey.rows)*\n+                 detectorParams.minMarkerLengthRatioOriginalImg));\n+\n+        /// Step 1: create image pyramid. Section 3.4. in [1]\n+        vector<Mat> grey_pyramid;\n+        int closest_pyr_image_idx = 0, num_levels = 0;\n+        //// Step 1.1: resize image with equation (1) from paper [1]\n+        if (detectorParams.useAruco3Detection) {\n+            const float scale_pyr = 2.f;\n+            const float img_area = static_cast<float>(grey.rows*grey.cols);\n+            const float min_area_marker = static_cast<float>(detectorParams.minSideLengthCanonicalImg*\n+                    detectorParams.minSideLengthCanonicalImg);\n+            // find max level\n+            num_levels = static_cast<int>(log2(img_area / min_area_marker)/scale_pyr);\n+            // the closest pyramid image to the downsampled segmentation image\n+            // will later be used as start index for corner upsampling\n+            const float scale_img_area = img_area * fxfy * fxfy;\n+            closest_pyr_image_idx = cvRound(log2(img_area / scale_img_area)/scale_pyr);\n+        }\n+        buildPyramid(grey, grey_pyramid, num_levels);\n+\n+        // resize to segmentation image\n+        // in this reduces size the contours will be detected\n+        if (fxfy != 1.f)\n+            resize(grey, grey, Size(cvRound(fxfy * grey.cols), cvRound(fxfy * grey.rows)));\n+\n+        /// STEP 2: Detect marker candidates\n+        vector<vector<Point2f> > candidates;\n+        vector<vector<Point> > contours;\n+        vector<int> ids;\n+\n+        /// STEP 2.a Detect marker candidates :: using AprilTag\n+        if(detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_APRILTAG){\n+            _apriltag(grey, detectorParams, candidates, contours);\n+        }\n+        /// STEP 2.b Detect marker candidates :: traditional way\n+        else {\n+            detectCandidates(grey, candidates, contours);\n+        }\n+\n+        /// STEP 2.c FILTER OUT NEAR CANDIDATE PAIRS\n+        vector<int> dictIndices;\n+        vector<vector<Point2f>> rejectedImgPoints;\n+        if (DictionaryMode::Single == dictMode) {\n+            Dictionary& dictionary = dictionaries.at(0);\n+            auto selectedCandidates = filterTooCloseCandidates(candidates, contours, dictionary.markerSize);\n+            candidates.clear();\n+            contours.clear();\n+\n+            /// STEP 2: Check candidate codification (identify markers)\n+            identifyCandidates(grey, grey_pyramid, selectedCandidates, candidates, contours,\n+                    ids, dictionary, rejectedImgPoints);\n+\n+            /// STEP 3: Corner refinement :: use corner subpix\n+            if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {\n+                CV_Assert(detectorParams.cornerRefinementWinSize > 0 && detectorParams.cornerRefinementMaxIterations > 0 &&\n+                        detectorParams.cornerRefinementMinAccuracy > 0);\n+                // Do subpixel estimation. In Aruco3 start on the lowest pyramid level and upscale the corners\n+                parallel_for_(Range(0, (int)candidates.size()), [&](const Range& range) {\n+                    const int begin = range.start;\n+                    const int end = range.end;\n+\n+                    for (int i = begin; i < end; i++) {\n+                        if (detectorParams.useAruco3Detection) {\n+                            const float scale_init = (float) grey_pyramid[closest_pyr_image_idx].cols / grey.cols;\n+                            findCornerInPyrImage(scale_init, closest_pyr_image_idx, grey_pyramid, Mat(candidates[i]), detectorParams);\n+                        } else {\n+                            int cornerRefinementWinSize = std::max(1, cvRound(detectorParams.relativeCornerRefinmentWinSize*\n+                                        getAverageModuleSize(candidates[i], dictionary.markerSize, detectorParams.markerBorderBits)));\n+                            cornerRefinementWinSize = min(cornerRefinementWinSize, detectorParams.cornerRefinementWinSize);\n+                            cornerSubPix(grey, Mat(candidates[i]), Size(cornerRefinementWinSize, cornerRefinementWinSize), Size(-1, -1),\n+                                    TermCriteria(TermCriteria::MAX_ITER | TermCriteria::EPS,\n+                                        detectorParams.cornerRefinementMaxIterations,\n+                                        detectorParams.cornerRefinementMinAccuracy));\n+                        }\n+                    }\n+                });\n+            }\n+        } else if (DictionaryMode::Multi == dictMode) {\n+            unordered_set<int> uniqueMarkerSizes;\n+            for (const Dictionary& dictionary : dictionaries) {\n+                uniqueMarkerSizes.insert(dictionary.markerSize);\n+            }\n+\n+            // create at max 4 marker candidate trees for each dictionary size\n+            vector<vector<MarkerCandidateTree>> candidatesPerDictionarySize = {{}, {}, {}, {}};\n+            for (int markerSize : uniqueMarkerSizes) {\n+                // min marker size is 4, so subtract 4 to get index\n+                const auto dictionarySizeIndex = markerSize - 4;\n+                // copy candidates\n+                vector<vector<Point2f>> candidatesCopy = candidates;\n+                vector<vector<Point> > contoursCopy = contours;\n+                candidatesPerDictionarySize[dictionarySizeIndex] = filterTooCloseCandidates(candidatesCopy, contoursCopy, markerSize);\n+            }\n+            candidates.clear();\n+            contours.clear();\n+\n+            /// STEP 2: Check candidate codification (identify markers)\n+            int dictIndex = 0;\n+            for (const Dictionary&  currentDictionary : dictionaries) {\n+                const auto dictionarySizeIndex = currentDictionary.markerSize - 4;\n+                // temporary variable to store the current candidates\n+                vector<vector<Point2f>> currentCandidates;\n+                identifyCandidates(grey, grey_pyramid, candidatesPerDictionarySize[dictionarySizeIndex], currentCandidates, contours,\n+                        ids, currentDictionary, rejectedImgPoints);\n+                if (_dictIndices.needed()) {\n+                    dictIndices.insert(dictIndices.end(), currentCandidates.size(), dictIndex);\n+                }\n+\n+                /// STEP 3: Corner refinement :: use corner subpix\n+                if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {",
        "comment_created_at": "2025-03-03T09:17:51+00:00",
        "comment_author": "mshabunin",
        "comment_body": "Is it possible to extract this large block to separate function to reduce code duplication?",
        "pr_file_module": null
      },
      {
        "comment_id": "1979573764",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26934,
        "pr_file": "modules/objdetect/src/aruco/aruco_detector.cpp",
        "discussion_id": "1977140260",
        "commented_code": "@@ -651,9 +657,257 @@ struct ArucoDetector::ArucoDetectorImpl {\n     RefineParameters refineParams;\n     ArucoDetectorImpl() {}\n \n-    ArucoDetectorImpl(const Dictionary &_dictionary, const DetectorParameters &_detectorParams,\n-                      const RefineParameters& _refineParams): dictionary(_dictionary),\n-                      detectorParams(_detectorParams), refineParams(_refineParams) {}\n+    ArucoDetectorImpl(const vector<Dictionary>&_dictionaries, const DetectorParameters &_detectorParams,\n+                      const RefineParameters& _refineParams): dictionaries(_dictionaries),\n+                      detectorParams(_detectorParams), refineParams(_refineParams) {\n+                          CV_Assert(!dictionaries.empty());\n+                      }\n+\n+    /*\n+     * @brief Detect markers either using multiple or just first dictionary\n+     */\n+    void detectMarkers(InputArray _image, OutputArrayOfArrays _corners, OutputArray _ids,\n+            OutputArrayOfArrays _rejectedImgPoints, OutputArray _dictIndices, DictionaryMode dictMode) {\n+        CV_Assert(!_image.empty());\n+\n+        CV_Assert(detectorParams.markerBorderBits > 0);\n+        // check that the parameters are set correctly if Aruco3 is used\n+        CV_Assert(!(detectorParams.useAruco3Detection == true &&\n+                    detectorParams.minSideLengthCanonicalImg == 0 &&\n+                    detectorParams.minMarkerLengthRatioOriginalImg == 0.0));\n+\n+        Mat grey;\n+        _convertToGrey(_image, grey);\n+\n+        // Aruco3 functionality is the extension of Aruco.\n+        // The description can be found in:\n+        // [1] Speeded up detection of squared fiducial markers, 2018, FJ Romera-Ramirez et al.\n+        // if Aruco3 functionality if not wanted\n+        // change some parameters to be sure to turn it off\n+        if (!detectorParams.useAruco3Detection) {\n+            detectorParams.minMarkerLengthRatioOriginalImg = 0.0;\n+            detectorParams.minSideLengthCanonicalImg = 0;\n+        }\n+        else {\n+            // always turn on corner refinement in case of Aruco3, due to upsampling\n+            detectorParams.cornerRefinementMethod = (int)CORNER_REFINE_SUBPIX;\n+            // only CORNER_REFINE_SUBPIX implement correctly for useAruco3Detection\n+            // Todo: update other CORNER_REFINE methods\n+        }\n+\n+        /// Step 0: equation (2) from paper [1]\n+        const float fxfy = (!detectorParams.useAruco3Detection ? 1.f : detectorParams.minSideLengthCanonicalImg /\n+                (detectorParams.minSideLengthCanonicalImg + std::max(grey.cols, grey.rows)*\n+                 detectorParams.minMarkerLengthRatioOriginalImg));\n+\n+        /// Step 1: create image pyramid. Section 3.4. in [1]\n+        vector<Mat> grey_pyramid;\n+        int closest_pyr_image_idx = 0, num_levels = 0;\n+        //// Step 1.1: resize image with equation (1) from paper [1]\n+        if (detectorParams.useAruco3Detection) {\n+            const float scale_pyr = 2.f;\n+            const float img_area = static_cast<float>(grey.rows*grey.cols);\n+            const float min_area_marker = static_cast<float>(detectorParams.minSideLengthCanonicalImg*\n+                    detectorParams.minSideLengthCanonicalImg);\n+            // find max level\n+            num_levels = static_cast<int>(log2(img_area / min_area_marker)/scale_pyr);\n+            // the closest pyramid image to the downsampled segmentation image\n+            // will later be used as start index for corner upsampling\n+            const float scale_img_area = img_area * fxfy * fxfy;\n+            closest_pyr_image_idx = cvRound(log2(img_area / scale_img_area)/scale_pyr);\n+        }\n+        buildPyramid(grey, grey_pyramid, num_levels);\n+\n+        // resize to segmentation image\n+        // in this reduces size the contours will be detected\n+        if (fxfy != 1.f)\n+            resize(grey, grey, Size(cvRound(fxfy * grey.cols), cvRound(fxfy * grey.rows)));\n+\n+        /// STEP 2: Detect marker candidates\n+        vector<vector<Point2f> > candidates;\n+        vector<vector<Point> > contours;\n+        vector<int> ids;\n+\n+        /// STEP 2.a Detect marker candidates :: using AprilTag\n+        if(detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_APRILTAG){\n+            _apriltag(grey, detectorParams, candidates, contours);\n+        }\n+        /// STEP 2.b Detect marker candidates :: traditional way\n+        else {\n+            detectCandidates(grey, candidates, contours);\n+        }\n+\n+        /// STEP 2.c FILTER OUT NEAR CANDIDATE PAIRS\n+        vector<int> dictIndices;\n+        vector<vector<Point2f>> rejectedImgPoints;\n+        if (DictionaryMode::Single == dictMode) {\n+            Dictionary& dictionary = dictionaries.at(0);\n+            auto selectedCandidates = filterTooCloseCandidates(candidates, contours, dictionary.markerSize);\n+            candidates.clear();\n+            contours.clear();\n+\n+            /// STEP 2: Check candidate codification (identify markers)\n+            identifyCandidates(grey, grey_pyramid, selectedCandidates, candidates, contours,\n+                    ids, dictionary, rejectedImgPoints);\n+\n+            /// STEP 3: Corner refinement :: use corner subpix\n+            if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {\n+                CV_Assert(detectorParams.cornerRefinementWinSize > 0 && detectorParams.cornerRefinementMaxIterations > 0 &&\n+                        detectorParams.cornerRefinementMinAccuracy > 0);\n+                // Do subpixel estimation. In Aruco3 start on the lowest pyramid level and upscale the corners\n+                parallel_for_(Range(0, (int)candidates.size()), [&](const Range& range) {\n+                    const int begin = range.start;\n+                    const int end = range.end;\n+\n+                    for (int i = begin; i < end; i++) {\n+                        if (detectorParams.useAruco3Detection) {\n+                            const float scale_init = (float) grey_pyramid[closest_pyr_image_idx].cols / grey.cols;\n+                            findCornerInPyrImage(scale_init, closest_pyr_image_idx, grey_pyramid, Mat(candidates[i]), detectorParams);\n+                        } else {\n+                            int cornerRefinementWinSize = std::max(1, cvRound(detectorParams.relativeCornerRefinmentWinSize*\n+                                        getAverageModuleSize(candidates[i], dictionary.markerSize, detectorParams.markerBorderBits)));\n+                            cornerRefinementWinSize = min(cornerRefinementWinSize, detectorParams.cornerRefinementWinSize);\n+                            cornerSubPix(grey, Mat(candidates[i]), Size(cornerRefinementWinSize, cornerRefinementWinSize), Size(-1, -1),\n+                                    TermCriteria(TermCriteria::MAX_ITER | TermCriteria::EPS,\n+                                        detectorParams.cornerRefinementMaxIterations,\n+                                        detectorParams.cornerRefinementMinAccuracy));\n+                        }\n+                    }\n+                });\n+            }\n+        } else if (DictionaryMode::Multi == dictMode) {\n+            unordered_set<int> uniqueMarkerSizes;\n+            for (const Dictionary& dictionary : dictionaries) {\n+                uniqueMarkerSizes.insert(dictionary.markerSize);\n+            }\n+\n+            // create at max 4 marker candidate trees for each dictionary size\n+            vector<vector<MarkerCandidateTree>> candidatesPerDictionarySize = {{}, {}, {}, {}};\n+            for (int markerSize : uniqueMarkerSizes) {\n+                // min marker size is 4, so subtract 4 to get index\n+                const auto dictionarySizeIndex = markerSize - 4;\n+                // copy candidates\n+                vector<vector<Point2f>> candidatesCopy = candidates;\n+                vector<vector<Point> > contoursCopy = contours;\n+                candidatesPerDictionarySize[dictionarySizeIndex] = filterTooCloseCandidates(candidatesCopy, contoursCopy, markerSize);\n+            }\n+            candidates.clear();\n+            contours.clear();\n+\n+            /// STEP 2: Check candidate codification (identify markers)\n+            int dictIndex = 0;\n+            for (const Dictionary&  currentDictionary : dictionaries) {\n+                const auto dictionarySizeIndex = currentDictionary.markerSize - 4;\n+                // temporary variable to store the current candidates\n+                vector<vector<Point2f>> currentCandidates;\n+                identifyCandidates(grey, grey_pyramid, candidatesPerDictionarySize[dictionarySizeIndex], currentCandidates, contours,\n+                        ids, currentDictionary, rejectedImgPoints);\n+                if (_dictIndices.needed()) {\n+                    dictIndices.insert(dictIndices.end(), currentCandidates.size(), dictIndex);\n+                }\n+\n+                /// STEP 3: Corner refinement :: use corner subpix\n+                if (detectorParams.cornerRefinementMethod == (int)CORNER_REFINE_SUBPIX) {",
        "comment_created_at": "2025-03-04T14:27:21+00:00",
        "comment_author": "BenjaminKnecht",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "723912815",
    "pr_number": 20371,
    "pr_file": "modules/core/src/opengl.cpp",
    "created_at": "2021-10-07T07:22:56+00:00",
    "commented_code": "#endif\n}\n\n\n////////////////////////////////////////////////////////////////////////\n// ogl::Attribute\n\ncv::ogl::Attribute::Attribute(Buffer buffer, size_t stride, size_t offset, int size, Type type, bool integer, bool normalized, unsigned int shader_loc)",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "723912815",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/core/src/opengl.cpp",
        "discussion_id": "723912815",
        "commented_code": "@@ -1405,6 +1412,574 @@ void cv::ogl::Arrays::bind() const\n #endif\n }\n \n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Attribute\n+\n+cv::ogl::Attribute::Attribute(Buffer buffer, size_t stride, size_t offset, int size, Type type, bool integer, bool normalized, unsigned int shader_loc)",
        "comment_created_at": "2021-10-07T07:22:56+00:00",
        "comment_author": "JulieBar",
        "comment_body": "there is no need for an explicit constructor, an initialization list can be used",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "724440487",
    "pr_number": 20371,
    "pr_file": "modules/core/src/opengl.cpp",
    "created_at": "2021-10-07T18:42:17+00:00",
    "commented_code": "#endif\n}\n\n\n////////////////////////////////////////////////////////////////////////\n// ogl::Attribute\n\ncv::ogl::Attribute::Attribute(Buffer buffer, size_t stride, size_t offset, int size, Type type, bool integer, bool normalized, unsigned int shader_loc)\n{\n    buffer_ = buffer;\n    stride_ = stride;\n    offset_ = offset;\n    size_ = size;\n    type_ = type;\n    integer_ = integer;\n    normalized_ = normalized;\n    shader_loc_ = shader_loc;\n}\n\n////////////////////////////////////////////////////////////////////////\n// ogl::VertexArray\n\n#ifndef HAVE_OPENGL\n\nclass cv::ogl::VertexArray::Impl\n{\n};\n\n#else\n\nclass cv::ogl::VertexArray::Impl\n{\npublic:\n    static const Ptr<Impl>& empty();\n\n    Impl(GLuint vaId, bool autoRelease);\n    Impl(std::initializer_list<Attribute> attributes, bool autoRelease);\n    ~Impl();\n\n    void bind();\n\n    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n\n    GLuint vaId() const { return vaId_; }\n\nprivate:\n    Impl();\n\n    GLuint vaId_;\n    bool autoRelease_;\n};\n\nconst Ptr<cv::ogl::VertexArray::Impl>& cv::ogl::VertexArray::Impl::empty()\n{\n    static Ptr<Impl> p(new Impl);\n    return p;\n}\n\ncv::ogl::VertexArray::Impl::Impl() : vaId_(0), autoRelease_(false)\n{\n}\n\ncv::ogl::VertexArray::Impl::Impl(GLuint vaId, bool autoRelease) : vaId_(vaId), autoRelease_(autoRelease)\n{\n    CV_Assert( gl::IsVertexArray(vaId) == gl::TRUE_ );\n}\n\ncv::ogl::VertexArray::Impl::Impl(std::initializer_list<Attribute> attributes, bool autoRelease) : vaId_(0), autoRelease_(autoRelease)\n{\n    gl::GenVertexArrays(1, &vaId_);\n    CV_CheckGlError();\n\n    CV_Assert( vaId_ != 0 );\n    gl::BindVertexArray(vaId_);\n    CV_CheckGlError();\n\n    for (auto& attribute : attributes)\n    {\n        attribute.buffer_.bind(Buffer::ARRAY_BUFFER);\n        if (attribute.integer_)\n        {\n            gl::VertexAttribIPointer(\n                attribute.shader_loc_,\n                attribute.size_,\n                attribute.type_,\n                attribute.stride_,\n                (const void*)attribute.offset_\n            );\n            CV_CheckGlError();\n        }\n        else\n        {\n            gl::VertexAttribPointer(\n                attribute.shader_loc_,\n                attribute.size_,\n                attribute.type_,\n                attribute.normalized_,\n                attribute.stride_,\n                (const void*)attribute.offset_\n            );\n            CV_CheckGlError();\n        }\n\n        gl::EnableVertexAttribArray(attribute.shader_loc_);\n        CV_CheckGlError();\n    }\n}\n\ncv::ogl::VertexArray::Impl::~Impl()\n{\n    if (autoRelease_ && vaId_)\n        gl::DeleteVertexArrays(1, &vaId_);\n}\n\nvoid cv::ogl::VertexArray::Impl::bind()\n{\n    gl::BindVertexArray(vaId_);\n    CV_CheckGlError();\n}\n\n#endif // HAVE_OPENGL\n\ncv::ogl::VertexArray::VertexArray()\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    impl_ = Impl::empty();\n#endif\n}\n\ncv::ogl::VertexArray::VertexArray(std::initializer_list<Attribute> attributes, bool autoRelease)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(attributes);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(attributes, autoRelease));\n#endif\n}\n\nvoid cv::ogl::VertexArray::create(std::initializer_list<Attribute> attributes, bool autoRelease)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(attributes);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(attributes, autoRelease));\n#endif\n}\n\nvoid cv::ogl::VertexArray::release()\n{\n#ifdef HAVE_OPENGL\n    if (impl_)\n        impl_->setAutoRelease(true);\n    impl_ = Impl::empty();\n#endif\n}\n\nvoid cv::ogl::VertexArray::setAutoRelease(bool flag)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(flag);\n    throw_no_ogl();\n#else\n    impl_->setAutoRelease(flag);\n#endif\n}\n\nvoid cv::ogl::VertexArray::bind() const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    impl_->bind();\n#endif\n}\n\nvoid cv::ogl::VertexArray::unbind()\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    gl::BindVertexArray(0);\n#endif\n}\n\nunsigned int cv::ogl::VertexArray::vaId() const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    return impl_->vaId();\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////\n// ogl::Shader\n\n#ifndef HAVE_OPENGL\n\nclass cv::ogl::Shader::Impl\n{\n};\n\n#else\n\nclass cv::ogl::Shader::Impl\n{\npublic:\n    static const Ptr<Impl>& empty();\n\n    Impl(GLuint shaderId, bool autoRelease);\n    Impl(const char* src, GLenum type, bool autoRelease);\n    ~Impl();\n\n    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n\n    GLuint shaderId() const { return shaderId_; }\n\nprivate:\n    Impl();\n\n    GLuint shaderId_;\n    bool autoRelease_;\n};\n\nconst Ptr<cv::ogl::Shader::Impl>& cv::ogl::Shader::Impl::empty()\n{\n    static Ptr<Impl> p(new Impl);\n    return p;\n}\n\ncv::ogl::Shader::Impl::Impl() : shaderId_(0), autoRelease_(false)\n{\n}\n\ncv::ogl::Shader::Impl::Impl(GLuint shaderId, bool autoRelease) : shaderId_(shaderId), autoRelease_(autoRelease)\n{\n    CV_Assert( gl::IsShader(shaderId) == gl::TRUE_ );\n}\n\ncv::ogl::Shader::Impl::Impl(const char* src, GLenum type, bool autoRelease) : shaderId_(0), autoRelease_(autoRelease)\n{\n    shaderId_ = gl::CreateShader(type);\n    CV_CheckGlError();\n\n    CV_Assert( shaderId_ != 0 );\n\n    GLint status;\n    gl::ShaderSource(shaderId_, 1, &src, 0);\n    gl::CompileShader(shaderId_);\n    gl::GetShaderiv(shaderId_, gl::COMPILE_STATUS, &status);\n    if (!status) {\n        String info_log;\n        gl::GetShaderiv(shaderId_, gl::INFO_LOG_LENGTH, &status);\n        info_log.resize(status);\n        gl::GetShaderInfoLog(shaderId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n        CV_Error(Error::OpenGlApiCallError, info_log);\n    }\n\n    CV_CheckGlError();\n}\n\ncv::ogl::Shader::Impl::~Impl()\n{\n    if (autoRelease_ && shaderId_)\n        gl::DeleteShader(shaderId_);\n}\n\n#endif // HAVE_OPENGL\n\ncv::ogl::Shader::Shader() : type_(Type::VERTEX)\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    impl_ = Impl::empty();\n#endif\n}\n\ncv::ogl::Shader::Shader(const char* src, Type type, bool autoRelease) : type_(type)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(src);\n    CV_UNUSED(type);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(src, type, autoRelease));\n#endif\n}\n\nvoid cv::ogl::Shader::create(const char* src, Type type, bool autoRelease)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(src);\n    CV_UNUSED(type);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(src, type, autoRelease));\n    type_ = type;\n#endif\n}\n\nvoid cv::ogl::Shader::release()\n{\n#ifdef HAVE_OPENGL\n    if (impl_)\n        impl_->setAutoRelease(true);\n    impl_ = Impl::empty();\n#endif\n}\n\nvoid cv::ogl::Shader::setAutoRelease(bool flag)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(flag);\n    throw_no_ogl();\n#else\n    impl_->setAutoRelease(flag);\n#endif\n}\n\nunsigned int cv::ogl::Shader::shaderId() const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    return impl_->shaderId();\n#endif\n}\n\n////////////////////////////////////////////////////////////////////////\n// ogl::Program\n\n#ifndef HAVE_OPENGL\n\nclass cv::ogl::Program::Impl\n{\n};\n\n#else\n\nclass cv::ogl::Program::Impl\n{\npublic:\n    static const Ptr<Impl>& empty();\n\n    Impl(GLuint programId, bool autoRelease);\n    Impl(Shader vert, Shader frag, bool autoRelease);\n    ~Impl();\n\n    void bind();\n\n    int getAttributeLocation(const char* name) const;\n    int getUniformLocation(const char* name) const;\n\n    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n\n    GLuint programId() const { return programId_; }\n\nprivate:\n    Impl();\n\n    Shader vert_;\n    Shader frag_;\n    GLuint programId_;\n    bool autoRelease_;\n};\n\nconst Ptr<cv::ogl::Program::Impl>& cv::ogl::Program::Impl::empty()\n{\n    static Ptr<Impl> p(new Impl);\n    return p;\n}\n\ncv::ogl::Program::Impl::Impl() : programId_(0), autoRelease_(false)\n{\n}\n\ncv::ogl::Program::Impl::Impl(GLuint programId, bool autoRelease) : programId_(programId), autoRelease_(autoRelease)\n{\n    CV_Assert( gl::IsProgram(programId) == gl::TRUE_ );\n}\n\ncv::ogl::Program::Impl::Impl(Shader vert, Shader frag, bool autoRelease) : programId_(0), autoRelease_(autoRelease)\n{\n    programId_ = gl::CreateProgram();\n    CV_CheckGlError();\n\n    CV_Assert( programId_ != 0 );\n\n    gl::AttachShader(programId_, vert.shaderId());\n    CV_CheckGlError();\n\n    gl::AttachShader(programId_, frag.shaderId());\n    CV_CheckGlError();\n\n    GLint status;\n    gl::LinkProgram(programId_);\n    gl::GetProgramiv(programId_, gl::LINK_STATUS, &status);\n    if (!status) {\n        String info_log;\n        gl::GetProgramiv(programId_, gl::INFO_LOG_LENGTH, &status);\n        info_log.resize(status);\n        gl::GetProgramInfoLog(programId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n        CV_Error(Error::OpenGlApiCallError, info_log);\n    }\n    \n    CV_CheckGlError();\n\n    vert_ = vert;\n    frag_ = frag;\n}\n\ncv::ogl::Program::Impl::~Impl()\n{\n    if (autoRelease_ && programId_)\n        gl::DeleteProgram(programId_);\n}\n\nvoid cv::ogl::Program::Impl::bind()\n{\n    gl::UseProgram(programId_);\n    CV_CheckGlError();\n}\n\nint cv::ogl::Program::Impl::getAttributeLocation(const char* name) const\n{\n    int location = gl::GetAttribLocation(programId_, name);\n    if (location < 0)\n    {\n        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n    }\n    CV_CheckGlError();\n    return location;\n}\n\nint cv::ogl::Program::Impl::getUniformLocation(const char* name) const\n{\n    int location = gl::GetUniformLocation(programId_, name);\n    if (location < 0)\n    {\n        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n    }\n    CV_CheckGlError();\n    return location;\n}\n\n#endif // HAVE_OPENGL\n\ncv::ogl::Program::Program()\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    impl_ = Impl::empty();\n#endif\n}\n\ncv::ogl::Program::Program(Shader vert, Shader frag, bool autoRelease)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(vert);\n    CV_UNUSED(frag);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(vert, frag, autoRelease));\n#endif\n}\n\nvoid cv::ogl::Program::create(Shader vert, Shader frag, bool autoRelease)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(vert);\n    CV_UNUSED(frag);\n    CV_UNUSED(autoRelease);\n    throw_no_ogl();\n#else\n    impl_.reset(new Impl(vert, frag, autoRelease));\n#endif\n}\n\nvoid cv::ogl::Program::release()\n{\n#ifdef HAVE_OPENGL\n    if (impl_)\n        impl_->setAutoRelease(true);\n    impl_ = Impl::empty();\n#endif\n}\n\nvoid cv::ogl::Program::setAutoRelease(bool flag)\n{\n#ifndef HAVE_OPENGL\n    CV_UNUSED(flag);\n    throw_no_ogl();\n#else\n    impl_->setAutoRelease(flag);\n#endif\n}\n\nvoid cv::ogl::Program::bind() const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    impl_->bind();\n#endif\n}\n\nvoid cv::ogl::Program::unbind()\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    gl::UseProgram(0);\n#endif\n}\n\nint cv::ogl::Program::getAttributeLocation(const char* name) const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    return impl_->getAttributeLocation(name);\n#endif\n}\n\nint cv::ogl::Program::getUniformLocation(const char* name) const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    return impl_->getUniformLocation(name);\n#endif\n}\n\nvoid cv::ogl::Program::setUniformVec3(int loc, Vec3f vec)\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    gl::Uniform3f(loc, vec(0), vec(1), vec(2));\n#endif\n}\n\nvoid cv::ogl::Program::setUniformMat4x4(int loc, Matx44f mat)\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    gl::UniformMatrix4fv(loc, 1, true, mat.val);\n#endif\n}\n\nunsigned int cv::ogl::Program::programId() const\n{\n#ifndef HAVE_OPENGL\n    throw_no_ogl();\n#else\n    return impl_->programId();\n#endif\n}",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "724440487",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/core/src/opengl.cpp",
        "discussion_id": "724440487",
        "commented_code": "@@ -1405,6 +1412,574 @@ void cv::ogl::Arrays::bind() const\n #endif\n }\n \n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Attribute\n+\n+cv::ogl::Attribute::Attribute(Buffer buffer, size_t stride, size_t offset, int size, Type type, bool integer, bool normalized, unsigned int shader_loc)\n+{\n+    buffer_ = buffer;\n+    stride_ = stride;\n+    offset_ = offset;\n+    size_ = size;\n+    type_ = type;\n+    integer_ = integer;\n+    normalized_ = normalized;\n+    shader_loc_ = shader_loc;\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::VertexArray\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::VertexArray::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::VertexArray::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint vaId, bool autoRelease);\n+    Impl(std::initializer_list<Attribute> attributes, bool autoRelease);\n+    ~Impl();\n+\n+    void bind();\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint vaId() const { return vaId_; }\n+\n+private:\n+    Impl();\n+\n+    GLuint vaId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::VertexArray::Impl>& cv::ogl::VertexArray::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl() : vaId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl(GLuint vaId, bool autoRelease) : vaId_(vaId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsVertexArray(vaId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl(std::initializer_list<Attribute> attributes, bool autoRelease) : vaId_(0), autoRelease_(autoRelease)\n+{\n+    gl::GenVertexArrays(1, &vaId_);\n+    CV_CheckGlError();\n+\n+    CV_Assert( vaId_ != 0 );\n+    gl::BindVertexArray(vaId_);\n+    CV_CheckGlError();\n+\n+    for (auto& attribute : attributes)\n+    {\n+        attribute.buffer_.bind(Buffer::ARRAY_BUFFER);\n+        if (attribute.integer_)\n+        {\n+            gl::VertexAttribIPointer(\n+                attribute.shader_loc_,\n+                attribute.size_,\n+                attribute.type_,\n+                attribute.stride_,\n+                (const void*)attribute.offset_\n+            );\n+            CV_CheckGlError();\n+        }\n+        else\n+        {\n+            gl::VertexAttribPointer(\n+                attribute.shader_loc_,\n+                attribute.size_,\n+                attribute.type_,\n+                attribute.normalized_,\n+                attribute.stride_,\n+                (const void*)attribute.offset_\n+            );\n+            CV_CheckGlError();\n+        }\n+\n+        gl::EnableVertexAttribArray(attribute.shader_loc_);\n+        CV_CheckGlError();\n+    }\n+}\n+\n+cv::ogl::VertexArray::Impl::~Impl()\n+{\n+    if (autoRelease_ && vaId_)\n+        gl::DeleteVertexArrays(1, &vaId_);\n+}\n+\n+void cv::ogl::VertexArray::Impl::bind()\n+{\n+    gl::BindVertexArray(vaId_);\n+    CV_CheckGlError();\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::VertexArray::VertexArray()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::VertexArray::VertexArray(std::initializer_list<Attribute> attributes, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(attributes);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(attributes, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::create(std::initializer_list<Attribute> attributes, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(attributes);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(attributes, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::bind() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_->bind();\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::unbind()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::BindVertexArray(0);\n+#endif\n+}\n+\n+unsigned int cv::ogl::VertexArray::vaId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->vaId();\n+#endif\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Shader\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::Shader::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::Shader::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint shaderId, bool autoRelease);\n+    Impl(const char* src, GLenum type, bool autoRelease);\n+    ~Impl();\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint shaderId() const { return shaderId_; }\n+\n+private:\n+    Impl();\n+\n+    GLuint shaderId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::Shader::Impl>& cv::ogl::Shader::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::Shader::Impl::Impl() : shaderId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::Shader::Impl::Impl(GLuint shaderId, bool autoRelease) : shaderId_(shaderId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsShader(shaderId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::Shader::Impl::Impl(const char* src, GLenum type, bool autoRelease) : shaderId_(0), autoRelease_(autoRelease)\n+{\n+    shaderId_ = gl::CreateShader(type);\n+    CV_CheckGlError();\n+\n+    CV_Assert( shaderId_ != 0 );\n+\n+    GLint status;\n+    gl::ShaderSource(shaderId_, 1, &src, 0);\n+    gl::CompileShader(shaderId_);\n+    gl::GetShaderiv(shaderId_, gl::COMPILE_STATUS, &status);\n+    if (!status) {\n+        String info_log;\n+        gl::GetShaderiv(shaderId_, gl::INFO_LOG_LENGTH, &status);\n+        info_log.resize(status);\n+        gl::GetShaderInfoLog(shaderId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n+        CV_Error(Error::OpenGlApiCallError, info_log);\n+    }\n+\n+    CV_CheckGlError();\n+}\n+\n+cv::ogl::Shader::Impl::~Impl()\n+{\n+    if (autoRelease_ && shaderId_)\n+        gl::DeleteShader(shaderId_);\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::Shader::Shader() : type_(Type::VERTEX)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::Shader::Shader(const char* src, Type type, bool autoRelease) : type_(type)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(src);\n+    CV_UNUSED(type);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(src, type, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Shader::create(const char* src, Type type, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(src);\n+    CV_UNUSED(type);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(src, type, autoRelease));\n+    type_ = type;\n+#endif\n+}\n+\n+void cv::ogl::Shader::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::Shader::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+unsigned int cv::ogl::Shader::shaderId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->shaderId();\n+#endif\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Program\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::Program::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::Program::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint programId, bool autoRelease);\n+    Impl(Shader vert, Shader frag, bool autoRelease);\n+    ~Impl();\n+\n+    void bind();\n+\n+    int getAttributeLocation(const char* name) const;\n+    int getUniformLocation(const char* name) const;\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint programId() const { return programId_; }\n+\n+private:\n+    Impl();\n+\n+    Shader vert_;\n+    Shader frag_;\n+    GLuint programId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::Program::Impl>& cv::ogl::Program::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::Program::Impl::Impl() : programId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::Program::Impl::Impl(GLuint programId, bool autoRelease) : programId_(programId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsProgram(programId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::Program::Impl::Impl(Shader vert, Shader frag, bool autoRelease) : programId_(0), autoRelease_(autoRelease)\n+{\n+    programId_ = gl::CreateProgram();\n+    CV_CheckGlError();\n+\n+    CV_Assert( programId_ != 0 );\n+\n+    gl::AttachShader(programId_, vert.shaderId());\n+    CV_CheckGlError();\n+\n+    gl::AttachShader(programId_, frag.shaderId());\n+    CV_CheckGlError();\n+\n+    GLint status;\n+    gl::LinkProgram(programId_);\n+    gl::GetProgramiv(programId_, gl::LINK_STATUS, &status);\n+    if (!status) {\n+        String info_log;\n+        gl::GetProgramiv(programId_, gl::INFO_LOG_LENGTH, &status);\n+        info_log.resize(status);\n+        gl::GetProgramInfoLog(programId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n+        CV_Error(Error::OpenGlApiCallError, info_log);\n+    }\n+    \n+    CV_CheckGlError();\n+\n+    vert_ = vert;\n+    frag_ = frag;\n+}\n+\n+cv::ogl::Program::Impl::~Impl()\n+{\n+    if (autoRelease_ && programId_)\n+        gl::DeleteProgram(programId_);\n+}\n+\n+void cv::ogl::Program::Impl::bind()\n+{\n+    gl::UseProgram(programId_);\n+    CV_CheckGlError();\n+}\n+\n+int cv::ogl::Program::Impl::getAttributeLocation(const char* name) const\n+{\n+    int location = gl::GetAttribLocation(programId_, name);\n+    if (location < 0)\n+    {\n+        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n+    }\n+    CV_CheckGlError();\n+    return location;\n+}\n+\n+int cv::ogl::Program::Impl::getUniformLocation(const char* name) const\n+{\n+    int location = gl::GetUniformLocation(programId_, name);\n+    if (location < 0)\n+    {\n+        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n+    }\n+    CV_CheckGlError();\n+    return location;\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::Program::Program()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::Program::Program(Shader vert, Shader frag, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(vert);\n+    CV_UNUSED(frag);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(vert, frag, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Program::create(Shader vert, Shader frag, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(vert);\n+    CV_UNUSED(frag);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(vert, frag, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Program::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::Program::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+void cv::ogl::Program::bind() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_->bind();\n+#endif\n+}\n+\n+void cv::ogl::Program::unbind()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::UseProgram(0);\n+#endif\n+}\n+\n+int cv::ogl::Program::getAttributeLocation(const char* name) const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->getAttributeLocation(name);\n+#endif\n+}\n+\n+int cv::ogl::Program::getUniformLocation(const char* name) const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->getUniformLocation(name);\n+#endif\n+}\n+\n+void cv::ogl::Program::setUniformVec3(int loc, Vec3f vec)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::Uniform3f(loc, vec(0), vec(1), vec(2));\n+#endif\n+}\n+\n+void cv::ogl::Program::setUniformMat4x4(int loc, Matx44f mat)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::UniformMatrix4fv(loc, 1, true, mat.val);\n+#endif\n+}\n+\n+unsigned int cv::ogl::Program::programId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->programId();\n+#endif\n+}\n+",
        "comment_created_at": "2021-10-07T18:42:17+00:00",
        "comment_author": "JulieBar",
        "comment_body": "please reduce the amount of duplicated code if possible. you can implement methods: empty, create, release, setAutoRelease, bind, unbind, and then re-use it. ",
        "pr_file_module": null
      },
      {
        "comment_id": "729655562",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/core/src/opengl.cpp",
        "discussion_id": "724440487",
        "commented_code": "@@ -1405,6 +1412,574 @@ void cv::ogl::Arrays::bind() const\n #endif\n }\n \n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Attribute\n+\n+cv::ogl::Attribute::Attribute(Buffer buffer, size_t stride, size_t offset, int size, Type type, bool integer, bool normalized, unsigned int shader_loc)\n+{\n+    buffer_ = buffer;\n+    stride_ = stride;\n+    offset_ = offset;\n+    size_ = size;\n+    type_ = type;\n+    integer_ = integer;\n+    normalized_ = normalized;\n+    shader_loc_ = shader_loc;\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::VertexArray\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::VertexArray::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::VertexArray::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint vaId, bool autoRelease);\n+    Impl(std::initializer_list<Attribute> attributes, bool autoRelease);\n+    ~Impl();\n+\n+    void bind();\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint vaId() const { return vaId_; }\n+\n+private:\n+    Impl();\n+\n+    GLuint vaId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::VertexArray::Impl>& cv::ogl::VertexArray::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl() : vaId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl(GLuint vaId, bool autoRelease) : vaId_(vaId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsVertexArray(vaId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::VertexArray::Impl::Impl(std::initializer_list<Attribute> attributes, bool autoRelease) : vaId_(0), autoRelease_(autoRelease)\n+{\n+    gl::GenVertexArrays(1, &vaId_);\n+    CV_CheckGlError();\n+\n+    CV_Assert( vaId_ != 0 );\n+    gl::BindVertexArray(vaId_);\n+    CV_CheckGlError();\n+\n+    for (auto& attribute : attributes)\n+    {\n+        attribute.buffer_.bind(Buffer::ARRAY_BUFFER);\n+        if (attribute.integer_)\n+        {\n+            gl::VertexAttribIPointer(\n+                attribute.shader_loc_,\n+                attribute.size_,\n+                attribute.type_,\n+                attribute.stride_,\n+                (const void*)attribute.offset_\n+            );\n+            CV_CheckGlError();\n+        }\n+        else\n+        {\n+            gl::VertexAttribPointer(\n+                attribute.shader_loc_,\n+                attribute.size_,\n+                attribute.type_,\n+                attribute.normalized_,\n+                attribute.stride_,\n+                (const void*)attribute.offset_\n+            );\n+            CV_CheckGlError();\n+        }\n+\n+        gl::EnableVertexAttribArray(attribute.shader_loc_);\n+        CV_CheckGlError();\n+    }\n+}\n+\n+cv::ogl::VertexArray::Impl::~Impl()\n+{\n+    if (autoRelease_ && vaId_)\n+        gl::DeleteVertexArrays(1, &vaId_);\n+}\n+\n+void cv::ogl::VertexArray::Impl::bind()\n+{\n+    gl::BindVertexArray(vaId_);\n+    CV_CheckGlError();\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::VertexArray::VertexArray()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::VertexArray::VertexArray(std::initializer_list<Attribute> attributes, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(attributes);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(attributes, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::create(std::initializer_list<Attribute> attributes, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(attributes);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(attributes, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::bind() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_->bind();\n+#endif\n+}\n+\n+void cv::ogl::VertexArray::unbind()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::BindVertexArray(0);\n+#endif\n+}\n+\n+unsigned int cv::ogl::VertexArray::vaId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->vaId();\n+#endif\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Shader\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::Shader::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::Shader::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint shaderId, bool autoRelease);\n+    Impl(const char* src, GLenum type, bool autoRelease);\n+    ~Impl();\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint shaderId() const { return shaderId_; }\n+\n+private:\n+    Impl();\n+\n+    GLuint shaderId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::Shader::Impl>& cv::ogl::Shader::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::Shader::Impl::Impl() : shaderId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::Shader::Impl::Impl(GLuint shaderId, bool autoRelease) : shaderId_(shaderId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsShader(shaderId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::Shader::Impl::Impl(const char* src, GLenum type, bool autoRelease) : shaderId_(0), autoRelease_(autoRelease)\n+{\n+    shaderId_ = gl::CreateShader(type);\n+    CV_CheckGlError();\n+\n+    CV_Assert( shaderId_ != 0 );\n+\n+    GLint status;\n+    gl::ShaderSource(shaderId_, 1, &src, 0);\n+    gl::CompileShader(shaderId_);\n+    gl::GetShaderiv(shaderId_, gl::COMPILE_STATUS, &status);\n+    if (!status) {\n+        String info_log;\n+        gl::GetShaderiv(shaderId_, gl::INFO_LOG_LENGTH, &status);\n+        info_log.resize(status);\n+        gl::GetShaderInfoLog(shaderId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n+        CV_Error(Error::OpenGlApiCallError, info_log);\n+    }\n+\n+    CV_CheckGlError();\n+}\n+\n+cv::ogl::Shader::Impl::~Impl()\n+{\n+    if (autoRelease_ && shaderId_)\n+        gl::DeleteShader(shaderId_);\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::Shader::Shader() : type_(Type::VERTEX)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::Shader::Shader(const char* src, Type type, bool autoRelease) : type_(type)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(src);\n+    CV_UNUSED(type);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(src, type, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Shader::create(const char* src, Type type, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(src);\n+    CV_UNUSED(type);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(src, type, autoRelease));\n+    type_ = type;\n+#endif\n+}\n+\n+void cv::ogl::Shader::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::Shader::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+unsigned int cv::ogl::Shader::shaderId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->shaderId();\n+#endif\n+}\n+\n+////////////////////////////////////////////////////////////////////////\n+// ogl::Program\n+\n+#ifndef HAVE_OPENGL\n+\n+class cv::ogl::Program::Impl\n+{\n+};\n+\n+#else\n+\n+class cv::ogl::Program::Impl\n+{\n+public:\n+    static const Ptr<Impl>& empty();\n+\n+    Impl(GLuint programId, bool autoRelease);\n+    Impl(Shader vert, Shader frag, bool autoRelease);\n+    ~Impl();\n+\n+    void bind();\n+\n+    int getAttributeLocation(const char* name) const;\n+    int getUniformLocation(const char* name) const;\n+\n+    void setAutoRelease(bool flag) { autoRelease_ = flag; }\n+\n+    GLuint programId() const { return programId_; }\n+\n+private:\n+    Impl();\n+\n+    Shader vert_;\n+    Shader frag_;\n+    GLuint programId_;\n+    bool autoRelease_;\n+};\n+\n+const Ptr<cv::ogl::Program::Impl>& cv::ogl::Program::Impl::empty()\n+{\n+    static Ptr<Impl> p(new Impl);\n+    return p;\n+}\n+\n+cv::ogl::Program::Impl::Impl() : programId_(0), autoRelease_(false)\n+{\n+}\n+\n+cv::ogl::Program::Impl::Impl(GLuint programId, bool autoRelease) : programId_(programId), autoRelease_(autoRelease)\n+{\n+    CV_Assert( gl::IsProgram(programId) == gl::TRUE_ );\n+}\n+\n+cv::ogl::Program::Impl::Impl(Shader vert, Shader frag, bool autoRelease) : programId_(0), autoRelease_(autoRelease)\n+{\n+    programId_ = gl::CreateProgram();\n+    CV_CheckGlError();\n+\n+    CV_Assert( programId_ != 0 );\n+\n+    gl::AttachShader(programId_, vert.shaderId());\n+    CV_CheckGlError();\n+\n+    gl::AttachShader(programId_, frag.shaderId());\n+    CV_CheckGlError();\n+\n+    GLint status;\n+    gl::LinkProgram(programId_);\n+    gl::GetProgramiv(programId_, gl::LINK_STATUS, &status);\n+    if (!status) {\n+        String info_log;\n+        gl::GetProgramiv(programId_, gl::INFO_LOG_LENGTH, &status);\n+        info_log.resize(status);\n+        gl::GetProgramInfoLog(programId_, GLsizei(info_log.size()) + 1, nullptr, &info_log[0]);\n+        CV_Error(Error::OpenGlApiCallError, info_log);\n+    }\n+    \n+    CV_CheckGlError();\n+\n+    vert_ = vert;\n+    frag_ = frag;\n+}\n+\n+cv::ogl::Program::Impl::~Impl()\n+{\n+    if (autoRelease_ && programId_)\n+        gl::DeleteProgram(programId_);\n+}\n+\n+void cv::ogl::Program::Impl::bind()\n+{\n+    gl::UseProgram(programId_);\n+    CV_CheckGlError();\n+}\n+\n+int cv::ogl::Program::Impl::getAttributeLocation(const char* name) const\n+{\n+    int location = gl::GetAttribLocation(programId_, name);\n+    if (location < 0)\n+    {\n+        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n+    }\n+    CV_CheckGlError();\n+    return location;\n+}\n+\n+int cv::ogl::Program::Impl::getUniformLocation(const char* name) const\n+{\n+    int location = gl::GetUniformLocation(programId_, name);\n+    if (location < 0)\n+    {\n+        CV_Error(Error::OpenGlApiCallError, \"Attribute not found\");\n+    }\n+    CV_CheckGlError();\n+    return location;\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+cv::ogl::Program::Program()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+cv::ogl::Program::Program(Shader vert, Shader frag, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(vert);\n+    CV_UNUSED(frag);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(vert, frag, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Program::create(Shader vert, Shader frag, bool autoRelease)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(vert);\n+    CV_UNUSED(frag);\n+    CV_UNUSED(autoRelease);\n+    throw_no_ogl();\n+#else\n+    impl_.reset(new Impl(vert, frag, autoRelease));\n+#endif\n+}\n+\n+void cv::ogl::Program::release()\n+{\n+#ifdef HAVE_OPENGL\n+    if (impl_)\n+        impl_->setAutoRelease(true);\n+    impl_ = Impl::empty();\n+#endif\n+}\n+\n+void cv::ogl::Program::setAutoRelease(bool flag)\n+{\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(flag);\n+    throw_no_ogl();\n+#else\n+    impl_->setAutoRelease(flag);\n+#endif\n+}\n+\n+void cv::ogl::Program::bind() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    impl_->bind();\n+#endif\n+}\n+\n+void cv::ogl::Program::unbind()\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::UseProgram(0);\n+#endif\n+}\n+\n+int cv::ogl::Program::getAttributeLocation(const char* name) const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->getAttributeLocation(name);\n+#endif\n+}\n+\n+int cv::ogl::Program::getUniformLocation(const char* name) const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->getUniformLocation(name);\n+#endif\n+}\n+\n+void cv::ogl::Program::setUniformVec3(int loc, Vec3f vec)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::Uniform3f(loc, vec(0), vec(1), vec(2));\n+#endif\n+}\n+\n+void cv::ogl::Program::setUniformMat4x4(int loc, Matx44f mat)\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    gl::UniformMatrix4fv(loc, 1, true, mat.val);\n+#endif\n+}\n+\n+unsigned int cv::ogl::Program::programId() const\n+{\n+#ifndef HAVE_OPENGL\n+    throw_no_ogl();\n+#else\n+    return impl_->programId();\n+#endif\n+}\n+",
        "comment_created_at": "2021-10-15T09:12:14+00:00",
        "comment_author": "RiscadoA",
        "comment_body": "Can you clarify what you mean by duplicated code and those methods? I'm not seeing how it relates to the code section you commented. If the duplicated code you're referring to is those #ifndef #else #endif macros, I don't think it is possible to remove them.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "724474609",
    "pr_number": 20371,
    "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
    "created_at": "2021-10-07T19:34:06+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n\n#include \"../precomp.hpp\"\n#include \"viz3d_private.hpp\"\n#include \"opencv2/core/utils/logger.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace cv::viz3d;\n\n#ifdef HAVE_OPENGL\n\nstatic void openGlDrawCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->draw();\n}\n\nstatic void openGlFreeCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        delete win;\n}\n\nstatic void mouseCallback(int event, int x, int y, int flags, void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->onMouse(event, x, y, flags);\n}\n\nstatic Window* getWindow(const String& win_name)\n{\n    namedWindow(win_name, WINDOW_OPENGL);\n    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n    if (useGl <= 0)\n        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n\n    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n\n    if (!win)\n    {\n\t\tsetOpenGlContext(win_name);\n\t\twin = new Window(win_name);\n\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n        setMouseCallback(win_name, &mouseCallback, win);\n    }\n    else\n    {\n        auto callback = getOpenGlDrawCallback(win_name);\n        if (callback != nullptr && callback != openGlDrawCallback)\n            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n    }\n\n    return win;\n}\n\n#endif // HAVE_OPENGL\n\nvoid cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(fov);\n    CV_UNUSED(z_near);\n    CV_UNUSED(z_far);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->getView().setPerspective(fov, z_near, z_far);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setGridVisible(const String& win_name, bool visible)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(visible);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setGridVisible(visible);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(direction);\n    CV_UNUSED(ambient);\n    CV_UNUSED(diffuse);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSun(direction, ambient, diffuse);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(color);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSky(color);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(size);\n    CV_UNUSED(color);\n    CV_UNUSED(mode);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    if (mode == RENDER_WIREFRAME)\n    {\n        float points_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n        };\n\n        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "724474609",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
        "discussion_id": "724474609",
        "commented_code": "@@ -0,0 +1,1671 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+\n+#include \"../precomp.hpp\"\n+#include \"viz3d_private.hpp\"\n+#include \"opencv2/core/utils/logger.hpp\"\n+#include \"opencv2/imgproc.hpp\"\n+\n+using namespace cv;\n+using namespace cv::viz3d;\n+\n+#ifdef HAVE_OPENGL\n+\n+static void openGlDrawCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->draw();\n+}\n+\n+static void openGlFreeCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        delete win;\n+}\n+\n+static void mouseCallback(int event, int x, int y, int flags, void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->onMouse(event, x, y, flags);\n+}\n+\n+static Window* getWindow(const String& win_name)\n+{\n+    namedWindow(win_name, WINDOW_OPENGL);\n+    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n+    if (useGl <= 0)\n+        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n+\n+    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n+\n+    if (!win)\n+    {\n+\t\tsetOpenGlContext(win_name);\n+\t\twin = new Window(win_name);\n+\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n+        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n+        setMouseCallback(win_name, &mouseCallback, win);\n+    }\n+    else\n+    {\n+        auto callback = getOpenGlDrawCallback(win_name);\n+        if (callback != nullptr && callback != openGlDrawCallback)\n+            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n+    }\n+\n+    return win;\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+void cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(fov);\n+    CV_UNUSED(z_near);\n+    CV_UNUSED(z_far);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->getView().setPerspective(fov, z_near, z_far);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setGridVisible(const String& win_name, bool visible)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(visible);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setGridVisible(visible);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(direction);\n+    CV_UNUSED(ambient);\n+    CV_UNUSED(diffuse);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSun(direction, ambient, diffuse);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(color);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSky(color);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(size);\n+    CV_UNUSED(color);\n+    CV_UNUSED(mode);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    if (mode == RENDER_WIREFRAME)\n+    {\n+        float points_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+        };\n+\n+        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);",
        "comment_created_at": "2021-10-07T19:34:06+00:00",
        "comment_author": "JulieBar",
        "comment_body": "do not use magic numbers 6, 24; get it from the size of previous array",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "724475444",
    "pr_number": 20371,
    "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
    "created_at": "2021-10-07T19:35:28+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n\n#include \"../precomp.hpp\"\n#include \"viz3d_private.hpp\"\n#include \"opencv2/core/utils/logger.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace cv::viz3d;\n\n#ifdef HAVE_OPENGL\n\nstatic void openGlDrawCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->draw();\n}\n\nstatic void openGlFreeCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        delete win;\n}\n\nstatic void mouseCallback(int event, int x, int y, int flags, void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->onMouse(event, x, y, flags);\n}\n\nstatic Window* getWindow(const String& win_name)\n{\n    namedWindow(win_name, WINDOW_OPENGL);\n    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n    if (useGl <= 0)\n        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n\n    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n\n    if (!win)\n    {\n\t\tsetOpenGlContext(win_name);\n\t\twin = new Window(win_name);\n\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n        setMouseCallback(win_name, &mouseCallback, win);\n    }\n    else\n    {\n        auto callback = getOpenGlDrawCallback(win_name);\n        if (callback != nullptr && callback != openGlDrawCallback)\n            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n    }\n\n    return win;\n}\n\n#endif // HAVE_OPENGL\n\nvoid cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(fov);\n    CV_UNUSED(z_near);\n    CV_UNUSED(z_far);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->getView().setPerspective(fov, z_near, z_far);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setGridVisible(const String& win_name, bool visible)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(visible);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setGridVisible(visible);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(direction);\n    CV_UNUSED(ambient);\n    CV_UNUSED(diffuse);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSun(direction, ambient, diffuse);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(color);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSky(color);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(size);\n    CV_UNUSED(color);\n    CV_UNUSED(mode);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    if (mode == RENDER_WIREFRAME)\n    {\n        float points_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n        };\n\n        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);\n\n        showLines(win_name, obj_name, points_mat);\n    }\n    else if (mode == RENDER_SIMPLE)\n    {\n        float verts_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n        };\n\n        static unsigned char indices_data[] = {\n            0, 1, 2,\n            2, 3, 0,\n            4, 5, 6,\n            6, 7, 4,\n            0, 1, 5,\n            5, 4, 0,\n            3, 2, 6,\n            6, 7, 3,\n            0, 3, 7,\n            7, 4, 0,\n            1, 2, 6,\n            6, 5, 1,\n        };\n\n        const Mat verts_mat = Mat(Size(6, 8), CV_32F, &verts_data);\n        const Mat indices_mat = Mat(Size(3, 12), CV_8U, &indices_data);",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "724475444",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
        "discussion_id": "724475444",
        "commented_code": "@@ -0,0 +1,1671 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+\n+#include \"../precomp.hpp\"\n+#include \"viz3d_private.hpp\"\n+#include \"opencv2/core/utils/logger.hpp\"\n+#include \"opencv2/imgproc.hpp\"\n+\n+using namespace cv;\n+using namespace cv::viz3d;\n+\n+#ifdef HAVE_OPENGL\n+\n+static void openGlDrawCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->draw();\n+}\n+\n+static void openGlFreeCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        delete win;\n+}\n+\n+static void mouseCallback(int event, int x, int y, int flags, void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->onMouse(event, x, y, flags);\n+}\n+\n+static Window* getWindow(const String& win_name)\n+{\n+    namedWindow(win_name, WINDOW_OPENGL);\n+    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n+    if (useGl <= 0)\n+        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n+\n+    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n+\n+    if (!win)\n+    {\n+\t\tsetOpenGlContext(win_name);\n+\t\twin = new Window(win_name);\n+\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n+        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n+        setMouseCallback(win_name, &mouseCallback, win);\n+    }\n+    else\n+    {\n+        auto callback = getOpenGlDrawCallback(win_name);\n+        if (callback != nullptr && callback != openGlDrawCallback)\n+            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n+    }\n+\n+    return win;\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+void cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(fov);\n+    CV_UNUSED(z_near);\n+    CV_UNUSED(z_far);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->getView().setPerspective(fov, z_near, z_far);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setGridVisible(const String& win_name, bool visible)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(visible);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setGridVisible(visible);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(direction);\n+    CV_UNUSED(ambient);\n+    CV_UNUSED(diffuse);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSun(direction, ambient, diffuse);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(color);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSky(color);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(size);\n+    CV_UNUSED(color);\n+    CV_UNUSED(mode);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    if (mode == RENDER_WIREFRAME)\n+    {\n+        float points_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+        };\n+\n+        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);\n+\n+        showLines(win_name, obj_name, points_mat);\n+    }\n+    else if (mode == RENDER_SIMPLE)\n+    {\n+        float verts_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+        };\n+\n+        static unsigned char indices_data[] = {\n+            0, 1, 2,\n+            2, 3, 0,\n+            4, 5, 6,\n+            6, 7, 4,\n+            0, 1, 5,\n+            5, 4, 0,\n+            3, 2, 6,\n+            6, 7, 3,\n+            0, 3, 7,\n+            7, 4, 0,\n+            1, 2, 6,\n+            6, 5, 1,\n+        };\n+\n+        const Mat verts_mat = Mat(Size(6, 8), CV_32F, &verts_data);\n+        const Mat indices_mat = Mat(Size(3, 12), CV_8U, &indices_data);",
        "comment_created_at": "2021-10-07T19:35:28+00:00",
        "comment_author": "JulieBar",
        "comment_body": "no magic numbers; use std::array and get size",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "724533336",
    "pr_number": 20371,
    "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
    "created_at": "2021-10-07T21:05:49+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n\n#include \"../precomp.hpp\"\n#include \"viz3d_private.hpp\"\n#include \"opencv2/core/utils/logger.hpp\"\n#include \"opencv2/imgproc.hpp\"\n\nusing namespace cv;\nusing namespace cv::viz3d;\n\n#ifdef HAVE_OPENGL\n\nstatic void openGlDrawCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->draw();\n}\n\nstatic void openGlFreeCallback(void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        delete win;\n}\n\nstatic void mouseCallback(int event, int x, int y, int flags, void* data)\n{\n    Window* win = static_cast<Window*>(data);\n    if (win != nullptr)\n        win->onMouse(event, x, y, flags);\n}\n\nstatic Window* getWindow(const String& win_name)\n{\n    namedWindow(win_name, WINDOW_OPENGL);\n    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n    if (useGl <= 0)\n        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n\n    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n\n    if (!win)\n    {\n\t\tsetOpenGlContext(win_name);\n\t\twin = new Window(win_name);\n\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n        setMouseCallback(win_name, &mouseCallback, win);\n    }\n    else\n    {\n        auto callback = getOpenGlDrawCallback(win_name);\n        if (callback != nullptr && callback != openGlDrawCallback)\n            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n    }\n\n    return win;\n}\n\n#endif // HAVE_OPENGL\n\nvoid cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(fov);\n    CV_UNUSED(z_near);\n    CV_UNUSED(z_far);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->getView().setPerspective(fov, z_near, z_far);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setGridVisible(const String& win_name, bool visible)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(visible);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setGridVisible(visible);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(direction);\n    CV_UNUSED(ambient);\n    CV_UNUSED(diffuse);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSun(direction, ambient, diffuse);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(color);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->setSky(color);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(size);\n    CV_UNUSED(color);\n    CV_UNUSED(mode);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    if (mode == RENDER_WIREFRAME)\n    {\n        float points_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n        };\n\n        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);\n\n        showLines(win_name, obj_name, points_mat);\n    }\n    else if (mode == RENDER_SIMPLE)\n    {\n        float verts_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n        };\n\n        static unsigned char indices_data[] = {\n            0, 1, 2,\n            2, 3, 0,\n            4, 5, 6,\n            6, 7, 4,\n            0, 1, 5,\n            5, 4, 0,\n            3, 2, 6,\n            6, 7, 3,\n            0, 3, 7,\n            7, 4, 0,\n            1, 2, 6,\n            6, 5, 1,\n        };\n\n        const Mat verts_mat = Mat(Size(6, 8), CV_32F, &verts_data);\n        const Mat indices_mat = Mat(Size(3, 12), CV_8U, &indices_data);\n\n        showMesh(win_name, obj_name, verts_mat, indices_mat);\n    }\n    else if (mode == RENDER_SHADING)\n    {\n        float verts_data[] = {\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 0\n            +size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 1\n            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 2\n            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 2\n            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 3\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 0\n\n            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 4\n            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 5\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 6\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 6\n            -size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 7\n            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 4\n\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 0\n            +size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 1\n            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 5\n            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 5\n            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 4\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 0\n\n            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 3\n            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 2\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 6\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 6\n            -size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 7\n            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 3\n\n\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 0\n            -size(0), +size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 3\n            -size(0), +size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 7\n            -size(0), +size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 7\n            -size(0), -size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 4\n            -size(0), -size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 0\n\n            +size(0), -size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 1\n            +size(0), +size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 2\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 6\n            +size(0), +size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 6\n            +size(0), -size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 5\n            +size(0), -size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 1\n        };\n\n        const Mat verts_mat = Mat(Size(9, 36), CV_32F, &verts_data);\n\n        showMesh(win_name, obj_name, verts_mat);\n    }\n#endif\n}\n\nvoid cv::viz3d::showPlane(const String& win_name, const String& obj_name, const Vec2f& size, const Vec3f& color, RenderMode mode)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(size);\n    CV_UNUSED(color);\n    CV_UNUSED(mode);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    if (mode == RENDER_WIREFRAME)\n    {\n        float points_data[] = {\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n        };\n\n        const Mat points_mat = Mat(Size(6, 8), CV_32F, points_data);\n\n        showLines(win_name, obj_name, points_mat);\n    }\n    else if (mode == RENDER_SIMPLE)\n    {\n        float verts_data[] = {\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n        };\n\n        const Mat verts_mat = Mat(Size(6, 6), CV_32F, verts_data);\n\n        showMesh(win_name, obj_name, verts_mat);\n    }\n    else if (mode == RENDER_SHADING)\n    {\n        float verts_data[] = {\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n            +size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n            -size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n            -size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n            +size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n        };\n\n        const Mat verts_mat = Mat(Size(9, 6), CV_32F, verts_data);\n\n        showMesh(win_name, obj_name, verts_mat);\n    }\n#endif\n}\n\nvoid cv::viz3d::showSphere(const String& win_name, const String& obj_name, float radius, const Vec3f& color, RenderMode mode, int divs)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(radius);\n    CV_UNUSED(color);\n    CV_UNUSED(mode);\n    CV_UNUSED(divs);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    CV_Assert(divs >= 1);\n\n    if (mode == RENDER_WIREFRAME)\n    {\n        const float limit = 2.0f * 3.1415f;\n        std::vector<float> points_data;\n\n        for (int e = 0; e < 3; ++e)\n        {\n            auto ex = Vec3f::zeros();\n            auto ey = Vec3f::zeros();\n            ex((e + 0) % 3) = radius;\n            ey((e + 1) % 3) = radius;\n\n            for (float t = 0.0f, n; t < limit;)\n            {\n                n = t + limit / (divs * 4);\n                points_data.insert(points_data.end(), {\n                    ex(0) * cos(t) + ey(0) * sin(t), ex(1) * cos(t) + ey(1) * sin(t), ex(2) * cos(t) + ey(2) * sin(t), color(0), color(1), color(2),\n                    ex(0) * cos(n) + ey(0) * sin(n), ex(1) * cos(n) + ey(1) * sin(n), ex(2) * cos(n) + ey(2) * sin(n), color(0), color(1), color(2),\n                    });\n                t = n;\n            }\n        }\n\n        const Mat points_mat = Mat(Size(6, points_data.size() / 6), CV_32F, points_data.data());\n\n        showLines(win_name, obj_name, points_mat);\n    }\n    else\n    {\n        std::vector<float> verts_data;\n\n        for (int s = -1; s <= 1; s += 2)\n            for (int e = 0; e < 3; ++e)\n            {\n                auto ex = Vec3f::zeros();\n                auto ey = Vec3f::zeros();\n                auto pz = Vec3f::zeros();\n                ex((e + 1) % 3) = 1.0f / divs;\n                ey((e + 2) % 3) = 1.0f / divs;\n                pz(e) = s;\n\n                for (int x = -divs; x < divs; ++x)\n                    for (int y = -divs; y < divs; ++y)\n                        if (mode == RENDER_SIMPLE)\n                            verts_data.insert(verts_data.end(), {\n                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n                                ex(0) * (x + 1) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n                                ex(0) * (x + 0) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n                                });\n                        else\n                            verts_data.insert(verts_data.end(), {\n                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                ex(0) * (x + 1) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                ex(0) * (x + 0) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n                                });\n            }\n\n        if (mode == RENDER_SIMPLE)\n        {\n            for (int i = 0; i < verts_data.size() / 6; ++i)\n            {\n                float l = sqrtf(verts_data[6 * i + 0] * verts_data[6 * i + 0] + verts_data[6 * i + 1] * verts_data[6 * i + 1] + verts_data[6 * i + 2] * verts_data[6 * i + 2]);\n                verts_data[6 * i + 0] *= radius / l;\n                verts_data[6 * i + 1] *= radius / l;\n                verts_data[6 * i + 2] *= radius / l;\n            }\n\n            const Mat verts_mat = Mat(Size(6, verts_data.size() / 6), CV_32F, verts_data.data());\n            showMesh(win_name, obj_name, verts_mat);\n        }\n        else\n        {\n            for (int i = 0; i < verts_data.size() / 9; ++i)\n            {\n                float l = sqrtf(verts_data[9 * i + 0] * verts_data[9 * i + 0] + verts_data[9 * i + 1] * verts_data[9 * i + 1] + verts_data[9 * i + 2] * verts_data[9 * i + 2]);\n                verts_data[9 * i + 6] = verts_data[9 * i + 0] / l;\n                verts_data[9 * i + 7] = verts_data[9 * i + 1] / l;\n                verts_data[9 * i + 8] = verts_data[9 * i + 2] / l;\n                verts_data[9 * i + 0] *= radius / l;\n                verts_data[9 * i + 1] *= radius / l;\n                verts_data[9 * i + 2] *= radius / l;\n            }\n\n            const Mat verts_mat = Mat(Size(9, verts_data.size() / 9), CV_32F, verts_data.data());\n            showMesh(win_name, obj_name, verts_mat);\n        }\n    }\n#endif\n}\n\nvoid cv::viz3d::showCameraTrajectory(\n    const String& win_name, const String& obj_name, InputArray trajectory,\n    float aspect, float scale, Vec3f frustum_color, Vec3f line_color)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(trajectory);\n    CV_UNUSED(aspect);\n    CV_UNUSED(scale);\n    CV_UNUSED(frustum_color);\n    CV_UNUSED(line_color);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    CV_Assert(trajectory.dims() == 2 && trajectory.cols() == 6 && trajectory.depth() == CV_32F);\n\n    auto data = trajectory.getMat();\n    std::vector<float> points_data;\n\n    // Add frustums\n    for (int i = 0; i < data.rows; ++i)\n    {\n        Vec3f position = { data.at<float>(i, 0), data.at<float>(i, 1), data.at<float>(i, 2) };\n        Vec3f forward = normalize(Vec3f { data.at<float>(i, 3), data.at<float>(i, 4), data.at<float>(i, 5) });\n        Vec3f world_up = { 0.0f, 1.0f, 0.0f };\n        Vec3f right = forward.cross(world_up);\n        Vec3f up = forward.cross(right);\n\n        Vec3f back_f[4] = {\n            position + (-right * aspect - up) * scale,\n            position + ( right * aspect - up) * scale,\n            position + ( right * aspect + up) * scale,\n            position + (-right * aspect + up) * scale,\n        };\n\n        Vec3f front_f[4] = {\n            position + (-right * aspect - up) * scale * 1.5f + forward * scale * 2.0f,\n            position + (right * aspect - up) * scale * 1.5f + forward * scale * 2.0f,\n            position + (right * aspect + up) * scale * 1.5f + forward * scale * 2.0f,\n            position + (-right * aspect + up) * scale * 1.5f + forward * scale * 2.0f,\n        };\n\n        points_data.insert(points_data.end(), {\n            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n\n            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n\n            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n        });\n\n    }\n\n    // Add trajectory line\n    for (int i = 1; i < data.rows; ++i)\n    {\n        points_data.insert(points_data.end(), {\n            data.at<float>(i - 1, 0), data.at<float>(i - 1, 1), data.at<float>(i - 1, 2), line_color(0), line_color(1), line_color(2),\n            data.at<float>(i, 0), data.at<float>(i, 1), data.at<float>(i, 2), line_color(0), line_color(1), line_color(2),\n        });\n    }\n\n    const Mat points_mat = Mat(Size(6, points_data.size() / 6), CV_32F, points_data.data());\n    showLines(win_name, obj_name, points_mat);\n\n#endif\n}\n\nvoid cv::viz3d::showMesh(const String& win_name, const String& obj_name, InputArray verts, InputArray indices)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(verts);\n    CV_UNUSED(indices);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (obj)\n        delete obj;\n    setOpenGlContext(win_name);\n    obj = new Mesh(verts, indices);\n    win->set(obj_name, obj);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showMesh(const String& win_name, const String& obj_name, InputArray verts)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(verts);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (obj)\n        delete obj;\n    setOpenGlContext(win_name);\n    obj = new Mesh(verts);\n    win->set(obj_name, obj);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showPoints(const String& win_name, const String& obj_name, InputArray points)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(points);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (obj)\n        delete obj;\n    setOpenGlContext(win_name);\n    obj = new PointCloud(points);\n    win->set(obj_name, obj);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::showRGBD(const String& win_name, const String& obj_name, InputArray img, const Matx33f& intrinsics, float scale)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(img);\n    CV_UNUSED(intrinsics);\n    CV_UNUSED(scale);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    CV_Assert(img.dims() == 2 && img.channels() == 4 && img.type() == CV_32FC4);\n    \n    Mat mat = img.getMat();\n    Mat points;\n\n    // This section (RGBD to point cloud) should be changed to use the 3d module when\n    // #20013 is merged.\n\n    float fx = intrinsics(0, 0);\n    float fy = intrinsics(1, 1);\n    float cx = intrinsics(0, 2);\n    float cy = intrinsics(1, 2);\n\n    for (int u = 0; u < mat.cols; ++u)\n        for (int v = 0; v < mat.rows; ++v)\n        {\n            Vec4f c = mat.at<Vec4f>(v, u);\n            float d = c(3) * 0.001f; // mm to m\n\n            float x_over_z = (cx - (float)u) / fx;\n            float y_over_z = (cy - (float)v) / fy;\n            float z = d/* / sqrt(1.0f + x_over_z * x_over_z + y_over_z * y_over_z)*/;\n            float x = x_over_z * z;\n            float y = y_over_z * z;\n\n            float point[] = {\n                x * scale, y * scale, z * scale,\n                c(0) / 255.0f, c(1) / 255.0f, c(2) / 255.0f,\n            };\n            points.push_back(Mat(1, 6, CV_32F, point));\n        }\n\n    showPoints(win_name, obj_name, points);\n#endif\n}\n\nvoid cv::viz3d::showLines(const String& win_name, const String& obj_name, InputArray points)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(points);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (obj)\n        delete obj;\n    setOpenGlContext(win_name);\n    obj = new Lines(points);\n    win->set(obj_name, obj);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setObjectPosition(const String& win_name, const String& obj_name, const Vec3f& position)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(position);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (!obj)\n        CV_Error(cv::Error::StsObjectNotFound, \"Object not found\");\n    obj->setPosition(position);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::setObjectRotation(const String& win_name, const String& obj_name, const Vec3f& rotation)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_UNUSED(rotation);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    Object* obj = win->get(obj_name);\n    if (!obj)\n        CV_Error(cv::Error::StsObjectNotFound, \"Object not found\");\n    obj->setRotation(rotation);\n    updateWindow(win_name);\n#endif\n}\n\nvoid cv::viz3d::destroyObject(const String& win_name, const String& obj_name)\n{\n    CV_TRACE_FUNCTION();\n#ifndef HAVE_OPENGL\n    CV_UNUSED(win_name);\n    CV_UNUSED(obj_name);\n    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n#else\n    Window* win = getWindow(win_name);\n    win->set(obj_name, nullptr);\n    updateWindow(win_name);\n#endif\n}\n\n#ifdef HAVE_OPENGL\n\ncv::viz3d::View::View()\n{\n    this->origin = { 0.0f, 0.0f, 0.0f };\n    this->distance = 10.0f;\n    this->position = { 0.0f, 0.0f, this->distance };\n    this->up = { 0.0f, 1.0f, 0.0f };\n\n    this->aspect = 1.0f;\n    this->setPerspective(1.3f, 0.1f, 2000.0f);\n    this->lookAt(this->origin, { 0.0f, 1.0f, 0.0f });\n}\n\nvoid cv::viz3d::View::setAspect(float aspect)\n{\n    if (this->aspect != aspect)\n    {\n        this->aspect = aspect;\n        this->setPerspective(this->fov, this->z_near, this->z_far);\n    }  \n}\n\nvoid cv::viz3d::View::setPerspective(float fov, float z_near, float z_far)\n{\n    this->fov = fov;\n    this->z_near = z_near;\n    this->z_far = z_far;\n\n    float tan_half_fovy = ::tan(this->fov / 2.0f);\n    this->proj = Matx44f::zeros();\n    this->proj(0, 0) = 1.0f / (this->aspect * tan_half_fovy);\n    this->proj(1, 1) = 1.0f / tan_half_fovy;\n    this->proj(2, 2) = (this->z_far + this->z_near) / (this->z_far - this->z_near);\n    this->proj(2, 3) = 1.0f;\n    this->proj(3, 2) = -(2.0f * this->z_far * this->z_near) / (this->z_far - this->z_near);\n}\n\nvoid cv::viz3d::View::rotate(float dx, float dy)\n{\n    this->position = normalize(this->position - this->origin);\n    float theta = atan2(this->position(2), this->position(0));\n    float phi = ::asin(this->position(1));\n    theta -= dx * 0.05f;\n    phi += dy * 0.05f;\n    phi = max(-1.5f, min(1.5f, phi));\n\n    this->position(0) = ::cos(theta) * ::cos(phi) * this->distance;\n    this->position(1) = ::sin(phi) * this->distance;\n    this->position(2) = ::sin(theta) * ::cos(phi) * this->distance;\n    this->position += this->origin;\n\n    this->lookAt(this->origin, this->up);\n}\n\nvoid cv::viz3d::View::move(float dx, float dy)\n{\n    Vec3f forward = normalize(this->position - this->origin);\n    Vec3f right = normalize(this->up.cross(forward));\n    Vec3f up = right.cross(forward);\n    Vec3f delta = normalize(right * dx - up * dy) * this->distance * 0.01f;\n\n    this->origin += delta;\n    this->position += delta;\n    this->lookAt(this->origin, this->up);\n}\n\nvoid cv::viz3d::View::scaleDistance(float amount)\n{\n    this->distance *= amount;\n    this->distance = max(0.1f, this->distance);\n    this->position = normalize(this->position - this->origin) * this->distance + this->origin;\n\n    this->lookAt(this->origin, this->up);\n}\n\nvoid cv::viz3d::View::lookAt(const Vec3f& point, const Vec3f& up)\n{\n    Vec3f f = normalize(point - this->position);\n    Vec3f s = normalize(up.cross(f));\n    Vec3f u = f.cross(s);\n\n    this->view = Matx44f::zeros();\n    this->view(0, 0) = s[0];\n    this->view(1, 0) = s[1];\n    this->view(2, 0) = s[2];\n    this->view(0, 1) = u[0];\n    this->view(1, 1) = u[1];\n    this->view(2, 1) = u[2];\n    this->view(0, 2) = f[0];\n    this->view(1, 2) = f[1];\n    this->view(2, 2) = f[2];\n    this->view(3, 0) = -s.dot(this->position);\n    this->view(3, 1) = -u.dot(this->position);\n    this->view(3, 2) = -f.dot(this->position);\n    this->view(3, 3) = 1.0f;\n}\n\ncv::viz3d::Window::Window(const String& name)\n{\n    this->name = name;\n    this->sun.direction = normalize(Vec3f(0.3f, 1.0f, 0.5f));\n    this->sun.ambient = { 0.1f, 0.1f, 0.1f };\n    this->sun.diffuse = { 1.0f, 1.0f, 1.0f };\n    this->sky_color = { 0.0f, 0.0f, 0.0f };\n\n\tfloat points[] = {\n\t\t0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n\t\t0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n\t\t0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t\t0.0f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t\t0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,\n\t\t0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 1.0f,\n\t};\n\n\tMat points_mat = Mat(Size(6, 6), CV_32F, points);\n\n\tthis->crosshair = new Lines(points_mat);\n\tthis->shaders[this->crosshair->getShaderName()] = this->crosshair->buildShader();\n\tthis->crosshair->setShader(this->shaders[this->crosshair->getShaderName()]);\n\n    this->grid = nullptr;\n}\n\ncv::viz3d::Window::~Window()\n{\n\tdelete this->crosshair;\n    if (this->grid != nullptr)\n        delete this->grid;\n\n    for (auto obj : this->objects)\n\t\tdelete obj.second;\n}\n\ncv::viz3d::Object* cv::viz3d::Window::get(const String& obj_name)\n{\n\tauto it = this->objects.find(obj_name);\n\tif (it == this->objects.end())\n\t\treturn nullptr;\n\treturn it->second;\n}\n\nvoid cv::viz3d::Window::set(const String& obj_name, Object* obj)\n{\n\tauto it = this->objects.find(obj_name);\n\tif (it != this->objects.end() && it->second != obj)\n\t{\n\t\tdelete it->second;\n\n\t\tif (obj == nullptr)\n\t\t\tthis->objects.erase(it);\n\t\telse\n\t\t\tit->second = obj;\n\t}\n\telse if (obj != nullptr)\n\t\tthis->objects[obj_name] = obj;\n\n    if (obj != nullptr)\n    {\n        String name = obj->getShaderName();\n        auto it = this->shaders.find(name);\n        if (it == this->shaders.end())\n            this->shaders[name] = obj->buildShader();\n        obj->setShader(this->shaders[name]);\n    }\n}\n\nvoid cv::viz3d::Window::setSun(const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n{\n    this->sun.direction = normalize(direction);\n    this->sun.ambient = ambient;\n    this->sun.diffuse = diffuse;\n}\n\nvoid cv::viz3d::Window::setSky(const Vec3f& color)\n{\n    this->sky_color = color;\n}\n\nstatic Mat getGridVertices(const View& view)\n{\n    const Vec3f grid_color = { 0.5f, 0.5f, 0.5f };\n    const Vec3f axis_color = { 0.8f, 0.8f, 0.8f };\n    const Vec3f center = view.getOrigin();\n    const Vec3f camera_dir = view.getOrigin() - view.getPosition();\n    const float scale = 0.3f;\n\n    float tick_step = 1.0f;\n    while (view.getDistance() * scale / tick_step > 4.0f)\n        tick_step *= 2.0f;\n    while (view.getDistance() * scale / tick_step < 2.0f)\n        tick_step *= 0.5f;\n\n    Mat points;\n    float face_sign[3];\n\n    const Vec3f min_p = center - Vec3f(1.0f, 1.0f, 1.0f) * view.getDistance() * scale;\n    const Vec3f max_p = center + Vec3f(1.0f, 1.0f, 1.0f) * view.getDistance() * scale;\n\n    // For each axis add a grid\n    for (int ai = 0; ai < 3; ++ai)\n    {\n        Vec3f az = { 0.0f, 0.0f, 0.0f };\n        az((ai + 2) % 3) = 1.0f;\n\n        // Check if face is positive or negative along the az axis\n        face_sign[ai] = camera_dir.dot(az) > 0.0f ? 1.0f : -1.0f;\n\n        float x = (floor(min_p(ai) / tick_step) + 1.0f) * tick_step;\n        for (; x < max_p(ai); x += tick_step)\n        {\n            Vec3f a = min_p;\n            Vec3f b = max_p;\n            a((ai + 0) % 3) = x;\n            b((ai + 0) % 3) = x;\n            if (face_sign[ai] > 0.0f)\n                a((ai + 2) % 3) = b((ai + 2) % 3);\n            else\n                b((ai + 2) % 3) = a((ai + 2) % 3);\n\n            float data[] = {\n                a(0), a(1), a(2), grid_color(0), grid_color(1), grid_color(2),\n                b(0), b(1), b(2), grid_color(0), grid_color(1), grid_color(2),\n            };\n\n            points.push_back(Mat(2, 6, CV_32F, data));\n        }\n\n        float y = (floor(min_p((ai + 1) % 3) / tick_step) + 1.0f) * tick_step;\n        for (; y < max_p((ai + 1) % 3); y += tick_step)\n        {\n            Vec3f a = min_p;\n            Vec3f b = max_p;\n            a((ai + 1) % 3) = y;\n            b((ai + 1) % 3) = y;\n            if (face_sign[ai] > 0.0f)\n                a((ai + 2) % 3) = b((ai + 2) % 3);\n            else\n                b((ai + 2) % 3) = a((ai + 2) % 3);\n\n            float data[] = {\n                a(0), a(1), a(2), grid_color(0), grid_color(1), grid_color(2),\n                b(0), b(1), b(2), grid_color(0), grid_color(1), grid_color(2),\n            };\n\n            points.push_back(Mat(2, 6, CV_32F, data));\n        }\n    }\n\n    // Draw Ox, Oy and Oz axes and ticks\n    {\n        Vec3f a = { face_sign[1] > 0.0f ? min_p(0) : max_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? max_p(2) : min_p(2) };\n        Vec3f b = { face_sign[1] > 0.0f ? min_p(0) : max_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n        Vec3f c = { face_sign[1] > 0.0f ? max_p(0) : min_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n        Vec3f d = { face_sign[1] > 0.0f ? max_p(0) : min_p(0), face_sign[2] > 0.0f ? min_p(1) : max_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n\n        float data[] = {\n            a(0), a(1), a(2), 0.0f, 0.0f, 0.8f,\n            b(0), b(1), b(2), 0.0f, 0.0f, 0.8f,\n            b(0), b(1), b(2), 0.8f, 0.0f, 0.0f,\n            c(0), c(1), c(2), 0.8f, 0.0f, 0.0f,\n            c(0), c(1), c(2), 0.0f, 0.8f, 0.0f,\n            d(0), d(1), d(2), 0.0f, 0.8f, 0.0f,\n        };\n\n        points.push_back(Mat(6, 6, CV_32F, data));\n\n        float x = (floor(min_p(0) / tick_step) + 1.0f) * tick_step;\n        for (; x < max_p(0); x += tick_step)\n        {\n            Vec3f a, b, c;\n            a(0) = b(0) = x;\n            a(1) = b(1) = face_sign[2] > 0.0f ? max_p(1) : min_p(1);\n            a(2) = face_sign[0] > 0.0f ? min_p(2) : max_p(2);\n            b(2) = a(2) - face_sign[0] * 0.03f * scale * view.getDistance();\n\n            float line[] = {\n                a(0), a(1), a(2), 0.8f, 0.0f, 0.0f,\n                b(0), b(1), b(2), 0.8f, 0.0f, 0.0f,\n            };\n\n            points.push_back(Mat(2, 6, CV_32F, line));\n        }\n\n        float y = (floor(min_p(1) / tick_step) + 1.0f) * tick_step;\n        for (; y < max_p(1); y += tick_step)\n        {\n            Vec3f a, b;\n            a(0) = b(0) = face_sign[1] > 0.0f ? max_p(0) : min_p(0);\n            a(1) = b(1) = y;\n            a(2) = face_sign[0] > 0.0f ? min_p(2) : max_p(2);\n            b(2) = a(2) - face_sign[0] * 0.03f * scale * view.getDistance();\n\n            float line[] = {\n                a(0), a(1), a(2), 0.0f, 0.8f, 0.0f,\n                b(0), b(1), b(2), 0.0f, 0.8f, 0.0f,\n            };\n\n            points.push_back(Mat(2, 6, CV_32F, line));\n        }\n\n        float z = (floor(min_p(2) / tick_step) + 1.0f) * tick_step;\n        for (; z < max_p(2); z += tick_step)\n        {\n            Vec3f a, b;\n            a(0) = face_sign[1] > 0.0f ? min_p(0) : max_p(0);\n            b(0) = a(0) - face_sign[1] * 0.03f * scale * view.getDistance();\n            a(1) = b(1) = face_sign[2] > 0.0f ? max_p(1) : min_p(1);\n            a(2) = b(2) = z;\n\n            float line[] = {\n                a(0), a(1), a(2), 0.0f, 0.0f, 0.8f,\n                b(0), b(1), b(2), 0.0f, 0.0f, 0.8f,\n            };\n\n            points.push_back(Mat(2, 6, CV_32F, line));\n        }\n    }\n\n    return points;\n}\n\nvoid cv::viz3d::Window::setGridVisible(bool visible)\n{\n    if (visible)\n    {\n        this->grid = new Lines(Mat(4096, 6, CV_32F), 0);\n        this->grid->setShader(this->shaders[this->grid->getShaderName()]);\n    }\n    else if (this->grid != nullptr)\n    {\n        delete this->grid;\n        this->grid = nullptr;\n    }\n}\n\nvoid cv::viz3d::Window::draw()\n{\n    Rect rect = getWindowImageRect(this->name);\n    float aspect = (float)rect.width / (float)rect.height;\n    this->view.setAspect(aspect);\n\n    ogl::enable(ogl::DEPTH_TEST);\n    ogl::clearColor({ double(this->sky_color(0) * 255.0f), double(this->sky_color(1) * 255.0f), double(this->sky_color(2) * 255.0f), 255.0 });\n\n    if (this->grid)\n    {\n        Mat labels;\n        static_cast<Lines*>(this->grid)->update(getGridVertices(this->view));\n        this->grid->draw(this->view, this->sun);\n    }\n    else\n    {\n        this->crosshair->setPosition(this->view.getOrigin());\n        this->crosshair->draw(this->view, this->sun);\n    }\n\n    for (auto& obj : this->objects)\n        obj.second->draw(this->view, this->sun);\n}\n\nvoid cv::viz3d::Window::onMouse(int event, int x, int y, int flags)\n{\n    if (event == EVENT_LBUTTONDOWN || event == EVENT_RBUTTONDOWN)\n    {\n        this->l_mouse_x = x;\n        this->l_mouse_y = y;\n    }\n    else if (event == EVENT_MOUSEMOVE && (flags & EVENT_FLAG_LBUTTON))\n    {\n        this->view.rotate(x - this->l_mouse_x, y - this->l_mouse_y);\n        updateWindow(this->name);\n        this->l_mouse_x = x;\n        this->l_mouse_y = y;\n    }\n    else if (event == EVENT_MOUSEMOVE && (flags & EVENT_FLAG_RBUTTON))\n    {\n        this->view.move(x - this->l_mouse_x, y - this->l_mouse_y);\n        updateWindow(this->name);\n        this->l_mouse_x = x;\n        this->l_mouse_y = y;\n    }\n    else if (event == EVENT_MOUSEWHEEL)\n    {\n        this->view.scaleDistance(min(1.2f, max(0.8f, 1.0f - getMouseWheelDelta(flags) / 12.0f)));\n        updateWindow(this->name);\n    }\n}\n\ncv::viz3d::Object::Object()\n{\n\tthis->position = { 0.0f, 0.0f, 0.0f };\n\tthis->rotation = { 0.0f, 0.0f, 0.0f };\n\tthis->model = Matx44f::eye();\n}\n\nvoid cv::viz3d::Object::setPosition(const Vec3f& position)\n{\n    this->position = position;\n    this->updateModel();\n}\n\nvoid cv::viz3d::Object::setRotation(const Vec3f& rotation)\n{\n    this->rotation = rotation;\n    this->updateModel();\n}\n\nvoid cv::viz3d::Object::updateModel()\n{\n    // Calculate rotation matrices\n    Matx44f rot_a = Matx44f::eye();\n    rot_a(0, 0) = ::cos(this->rotation(0));\n    rot_a(1, 0) = ::sin(this->rotation(0));\n    rot_a(0, 1) = -::sin(this->rotation(0));\n    rot_a(1, 1) = ::cos(this->rotation(0));\n\n    Matx44f rot_b = Matx44f::eye();\n    rot_b(1, 1) = ::cos(this->rotation(1));\n    rot_b(2, 1) = ::sin(this->rotation(1));\n    rot_b(1, 2) = -::sin(this->rotation(1));\n    rot_b(2, 2) = ::cos(this->rotation(1));\n\n    Matx44f rot_c = Matx44f::eye();\n    rot_c(0, 0) = ::cos(this->rotation(2));\n    rot_c(2, 0) = ::sin(this->rotation(2));\n    rot_c(0, 2) = -::sin(this->rotation(2));\n    rot_c(2, 2) = ::cos(this->rotation(2));\n\n    // Calculate translation matrix\n    Matx44f trans = Matx44f::eye();\n    trans(3, 0) = this->position(0);\n    trans(3, 1) = this->position(1);\n    trans(3, 2) = this->position(2);\n\n    // Multiply matrices\n    this->model = rot_c * rot_b * rot_a * trans;\n}\n\ncv::viz3d::Mesh::Mesh(InputArray verts, InputArray indices)\n{\n    // Check parameter validity\n    CV_Assert(verts.channels() == 1 && verts.dims() == 2 && (verts.size().width == 3 || verts.size().width == 6 || verts.size().width == 9));\n    CV_Assert(verts.depth() == CV_32F);\n    CV_Assert(indices.channels() == 1 && indices.dims() == 2 && indices.size().width == 3);\n    CV_Assert(indices.depth() == CV_8U || indices.depth() == CV_16U || indices.depth() == CV_32S);\n\n    // Prepare buffers\n    if (verts.kind() == _InputArray::OPENGL_BUFFER)\n        this->verts = verts.getOGlBuffer();\n    else\n        this->verts.copyFrom(verts, ogl::Buffer::ARRAY_BUFFER);\n\n    if (indices.kind() == _InputArray::OPENGL_BUFFER)\n        this->indices = indices.getOGlBuffer();\n    else\n        this->indices.copyFrom(indices, ogl::Buffer::ELEMENT_ARRAY_BUFFER);\n\n    switch (indices.depth())\n    {\n    case CV_8U:\n        this->index_type = ogl::UNSIGNED_BYTE;\n        break;\n    case CV_16U:\n        this->index_type = ogl::UNSIGNED_SHORT;\n        break;\n    case CV_32S:\n        this->index_type = ogl::UNSIGNED_INT;\n        break;\n    }\n\n    // Prepare vertex array\n    if (verts.size().width == 3)\n    {\n        this->va.create({\n            ogl::Attribute(",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "724533336",
        "repo_full_name": "opencv/opencv",
        "pr_number": 20371,
        "pr_file": "modules/highgui/src/viz3d/viz3d.cpp",
        "discussion_id": "724533336",
        "commented_code": "@@ -0,0 +1,1671 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+\n+#include \"../precomp.hpp\"\n+#include \"viz3d_private.hpp\"\n+#include \"opencv2/core/utils/logger.hpp\"\n+#include \"opencv2/imgproc.hpp\"\n+\n+using namespace cv;\n+using namespace cv::viz3d;\n+\n+#ifdef HAVE_OPENGL\n+\n+static void openGlDrawCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->draw();\n+}\n+\n+static void openGlFreeCallback(void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        delete win;\n+}\n+\n+static void mouseCallback(int event, int x, int y, int flags, void* data)\n+{\n+    Window* win = static_cast<Window*>(data);\n+    if (win != nullptr)\n+        win->onMouse(event, x, y, flags);\n+}\n+\n+static Window* getWindow(const String& win_name)\n+{\n+    namedWindow(win_name, WINDOW_OPENGL);\n+    const double useGl = getWindowProperty(win_name, WND_PROP_OPENGL);\n+    if (useGl <= 0)\n+        CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the window was created without an OpenGL context\");\n+\n+    Window* win = static_cast<Window*>(getOpenGlUserData(win_name));\n+\n+    if (!win)\n+    {\n+\t\tsetOpenGlContext(win_name);\n+\t\twin = new Window(win_name);\n+\t\tsetOpenGlDrawCallback(win_name, &openGlDrawCallback, win);\n+        setOpenGlFreeCallback(win_name, &openGlFreeCallback);\n+        setMouseCallback(win_name, &mouseCallback, win);\n+    }\n+    else\n+    {\n+        auto callback = getOpenGlDrawCallback(win_name);\n+        if (callback != nullptr && callback != openGlDrawCallback)\n+            CV_Error(cv::Error::StsBadArg, \"OpenCV/UI: viz3d can't be used because the OpenGL callback is already being used on this window\");\n+    }\n+\n+    return win;\n+}\n+\n+#endif // HAVE_OPENGL\n+\n+void cv::viz3d::setPerspective(const String& win_name, float fov, float z_near, float z_far)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(fov);\n+    CV_UNUSED(z_near);\n+    CV_UNUSED(z_far);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->getView().setPerspective(fov, z_near, z_far);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setGridVisible(const String& win_name, bool visible)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(visible);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setGridVisible(visible);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSun(const String& win_name, const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(direction);\n+    CV_UNUSED(ambient);\n+    CV_UNUSED(diffuse);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSun(direction, ambient, diffuse);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setSky(const String& win_name, const Vec3f& color)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(color);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->setSky(color);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showBox(const String& win_name, const String& obj_name, const Vec3f& size, const Vec3f& color, RenderMode mode)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(size);\n+    CV_UNUSED(color);\n+    CV_UNUSED(mode);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    if (mode == RENDER_WIREFRAME)\n+    {\n+        float points_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+        };\n+\n+        const Mat points_mat = Mat(Size(6, 24), CV_32F, &points_data);\n+\n+        showLines(win_name, obj_name, points_mat);\n+    }\n+    else if (mode == RENDER_SIMPLE)\n+    {\n+        float verts_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2),\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2),\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2),\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2),\n+        };\n+\n+        static unsigned char indices_data[] = {\n+            0, 1, 2,\n+            2, 3, 0,\n+            4, 5, 6,\n+            6, 7, 4,\n+            0, 1, 5,\n+            5, 4, 0,\n+            3, 2, 6,\n+            6, 7, 3,\n+            0, 3, 7,\n+            7, 4, 0,\n+            1, 2, 6,\n+            6, 5, 1,\n+        };\n+\n+        const Mat verts_mat = Mat(Size(6, 8), CV_32F, &verts_data);\n+        const Mat indices_mat = Mat(Size(3, 12), CV_8U, &indices_data);\n+\n+        showMesh(win_name, obj_name, verts_mat, indices_mat);\n+    }\n+    else if (mode == RENDER_SHADING)\n+    {\n+        float verts_data[] = {\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 0\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 1\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 2\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 2\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 3\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, 0.0f, -1.0f, // 0\n+\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 4\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 5\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 6\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 6\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 7\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, 0.0f, +1.0f, // 4\n+\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 0\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 1\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 5\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 5\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 4\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), 0.0f, -1.0f, 0.0f, // 0\n+\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 3\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 2\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 6\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 6\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 7\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2), 0.0f, +1.0f, 0.0f, // 3\n+\n+\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 0\n+            -size(0), +size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 3\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 7\n+            -size(0), +size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 7\n+            -size(0), -size(1), +size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 4\n+            -size(0), -size(1), -size(2), color(0), color(1), color(2), -1.0f, 0.0f, 0.0f, // 0\n+\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 1\n+            +size(0), +size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 2\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 6\n+            +size(0), +size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 6\n+            +size(0), -size(1), +size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 5\n+            +size(0), -size(1), -size(2), color(0), color(1), color(2), +1.0f, 0.0f, 0.0f, // 1\n+        };\n+\n+        const Mat verts_mat = Mat(Size(9, 36), CV_32F, &verts_data);\n+\n+        showMesh(win_name, obj_name, verts_mat);\n+    }\n+#endif\n+}\n+\n+void cv::viz3d::showPlane(const String& win_name, const String& obj_name, const Vec2f& size, const Vec3f& color, RenderMode mode)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(size);\n+    CV_UNUSED(color);\n+    CV_UNUSED(mode);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    if (mode == RENDER_WIREFRAME)\n+    {\n+        float points_data[] = {\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+        };\n+\n+        const Mat points_mat = Mat(Size(6, 8), CV_32F, points_data);\n+\n+        showLines(win_name, obj_name, points_mat);\n+    }\n+    else if (mode == RENDER_SIMPLE)\n+    {\n+        float verts_data[] = {\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2),\n+            -size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2),\n+        };\n+\n+        const Mat verts_mat = Mat(Size(6, 6), CV_32F, verts_data);\n+\n+        showMesh(win_name, obj_name, verts_mat);\n+    }\n+    else if (mode == RENDER_SHADING)\n+    {\n+        float verts_data[] = {\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+            +size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+            -size(0), 0.0f, -size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+            -size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+            +size(0), 0.0f, +size(1), color(0), color(1), color(2), 0.0f, 1.0f, 0.0f,\n+        };\n+\n+        const Mat verts_mat = Mat(Size(9, 6), CV_32F, verts_data);\n+\n+        showMesh(win_name, obj_name, verts_mat);\n+    }\n+#endif\n+}\n+\n+void cv::viz3d::showSphere(const String& win_name, const String& obj_name, float radius, const Vec3f& color, RenderMode mode, int divs)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(radius);\n+    CV_UNUSED(color);\n+    CV_UNUSED(mode);\n+    CV_UNUSED(divs);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    CV_Assert(divs >= 1);\n+\n+    if (mode == RENDER_WIREFRAME)\n+    {\n+        const float limit = 2.0f * 3.1415f;\n+        std::vector<float> points_data;\n+\n+        for (int e = 0; e < 3; ++e)\n+        {\n+            auto ex = Vec3f::zeros();\n+            auto ey = Vec3f::zeros();\n+            ex((e + 0) % 3) = radius;\n+            ey((e + 1) % 3) = radius;\n+\n+            for (float t = 0.0f, n; t < limit;)\n+            {\n+                n = t + limit / (divs * 4);\n+                points_data.insert(points_data.end(), {\n+                    ex(0) * cos(t) + ey(0) * sin(t), ex(1) * cos(t) + ey(1) * sin(t), ex(2) * cos(t) + ey(2) * sin(t), color(0), color(1), color(2),\n+                    ex(0) * cos(n) + ey(0) * sin(n), ex(1) * cos(n) + ey(1) * sin(n), ex(2) * cos(n) + ey(2) * sin(n), color(0), color(1), color(2),\n+                    });\n+                t = n;\n+            }\n+        }\n+\n+        const Mat points_mat = Mat(Size(6, points_data.size() / 6), CV_32F, points_data.data());\n+\n+        showLines(win_name, obj_name, points_mat);\n+    }\n+    else\n+    {\n+        std::vector<float> verts_data;\n+\n+        for (int s = -1; s <= 1; s += 2)\n+            for (int e = 0; e < 3; ++e)\n+            {\n+                auto ex = Vec3f::zeros();\n+                auto ey = Vec3f::zeros();\n+                auto pz = Vec3f::zeros();\n+                ex((e + 1) % 3) = 1.0f / divs;\n+                ey((e + 2) % 3) = 1.0f / divs;\n+                pz(e) = s;\n+\n+                for (int x = -divs; x < divs; ++x)\n+                    for (int y = -divs; y < divs; ++y)\n+                        if (mode == RENDER_SIMPLE)\n+                            verts_data.insert(verts_data.end(), {\n+                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n+                                ex(0) * (x + 1) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n+                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n+                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n+                                ex(0) * (x + 0) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2),\n+                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2),\n+                                });\n+                        else\n+                            verts_data.insert(verts_data.end(), {\n+                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                ex(0) * (x + 1) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                ex(0) * (x + 1) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 1) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 1) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                ex(0) * (x + 0) + ey(0) * (y + 1) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 1) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 1) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                ex(0) * (x + 0) + ey(0) * (y + 0) + pz(0), ex(1) * (x + 0) + ey(1) * (y + 0) + pz(1), ex(2) * (x + 0) + ey(2) * (y + 0) + pz(2), color(0), color(1), color(2), 0.0f, 0.0f, 0.0f,\n+                                });\n+            }\n+\n+        if (mode == RENDER_SIMPLE)\n+        {\n+            for (int i = 0; i < verts_data.size() / 6; ++i)\n+            {\n+                float l = sqrtf(verts_data[6 * i + 0] * verts_data[6 * i + 0] + verts_data[6 * i + 1] * verts_data[6 * i + 1] + verts_data[6 * i + 2] * verts_data[6 * i + 2]);\n+                verts_data[6 * i + 0] *= radius / l;\n+                verts_data[6 * i + 1] *= radius / l;\n+                verts_data[6 * i + 2] *= radius / l;\n+            }\n+\n+            const Mat verts_mat = Mat(Size(6, verts_data.size() / 6), CV_32F, verts_data.data());\n+            showMesh(win_name, obj_name, verts_mat);\n+        }\n+        else\n+        {\n+            for (int i = 0; i < verts_data.size() / 9; ++i)\n+            {\n+                float l = sqrtf(verts_data[9 * i + 0] * verts_data[9 * i + 0] + verts_data[9 * i + 1] * verts_data[9 * i + 1] + verts_data[9 * i + 2] * verts_data[9 * i + 2]);\n+                verts_data[9 * i + 6] = verts_data[9 * i + 0] / l;\n+                verts_data[9 * i + 7] = verts_data[9 * i + 1] / l;\n+                verts_data[9 * i + 8] = verts_data[9 * i + 2] / l;\n+                verts_data[9 * i + 0] *= radius / l;\n+                verts_data[9 * i + 1] *= radius / l;\n+                verts_data[9 * i + 2] *= radius / l;\n+            }\n+\n+            const Mat verts_mat = Mat(Size(9, verts_data.size() / 9), CV_32F, verts_data.data());\n+            showMesh(win_name, obj_name, verts_mat);\n+        }\n+    }\n+#endif\n+}\n+\n+void cv::viz3d::showCameraTrajectory(\n+    const String& win_name, const String& obj_name, InputArray trajectory,\n+    float aspect, float scale, Vec3f frustum_color, Vec3f line_color)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(trajectory);\n+    CV_UNUSED(aspect);\n+    CV_UNUSED(scale);\n+    CV_UNUSED(frustum_color);\n+    CV_UNUSED(line_color);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    CV_Assert(trajectory.dims() == 2 && trajectory.cols() == 6 && trajectory.depth() == CV_32F);\n+\n+    auto data = trajectory.getMat();\n+    std::vector<float> points_data;\n+\n+    // Add frustums\n+    for (int i = 0; i < data.rows; ++i)\n+    {\n+        Vec3f position = { data.at<float>(i, 0), data.at<float>(i, 1), data.at<float>(i, 2) };\n+        Vec3f forward = normalize(Vec3f { data.at<float>(i, 3), data.at<float>(i, 4), data.at<float>(i, 5) });\n+        Vec3f world_up = { 0.0f, 1.0f, 0.0f };\n+        Vec3f right = forward.cross(world_up);\n+        Vec3f up = forward.cross(right);\n+\n+        Vec3f back_f[4] = {\n+            position + (-right * aspect - up) * scale,\n+            position + ( right * aspect - up) * scale,\n+            position + ( right * aspect + up) * scale,\n+            position + (-right * aspect + up) * scale,\n+        };\n+\n+        Vec3f front_f[4] = {\n+            position + (-right * aspect - up) * scale * 1.5f + forward * scale * 2.0f,\n+            position + (right * aspect - up) * scale * 1.5f + forward * scale * 2.0f,\n+            position + (right * aspect + up) * scale * 1.5f + forward * scale * 2.0f,\n+            position + (-right * aspect + up) * scale * 1.5f + forward * scale * 2.0f,\n+        };\n+\n+        points_data.insert(points_data.end(), {\n+            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+\n+            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+\n+            back_f[0](0), back_f[0](1), back_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[0](0), front_f[0](1), front_f[0](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[1](0), back_f[1](1), back_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[1](0), front_f[1](1), front_f[1](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[2](0), back_f[2](1), back_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[2](0), front_f[2](1), front_f[2](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            back_f[3](0), back_f[3](1), back_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+            front_f[3](0), front_f[3](1), front_f[3](2), frustum_color(0), frustum_color(1), frustum_color(2),\n+        });\n+\n+    }\n+\n+    // Add trajectory line\n+    for (int i = 1; i < data.rows; ++i)\n+    {\n+        points_data.insert(points_data.end(), {\n+            data.at<float>(i - 1, 0), data.at<float>(i - 1, 1), data.at<float>(i - 1, 2), line_color(0), line_color(1), line_color(2),\n+            data.at<float>(i, 0), data.at<float>(i, 1), data.at<float>(i, 2), line_color(0), line_color(1), line_color(2),\n+        });\n+    }\n+\n+    const Mat points_mat = Mat(Size(6, points_data.size() / 6), CV_32F, points_data.data());\n+    showLines(win_name, obj_name, points_mat);\n+\n+#endif\n+}\n+\n+void cv::viz3d::showMesh(const String& win_name, const String& obj_name, InputArray verts, InputArray indices)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(verts);\n+    CV_UNUSED(indices);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (obj)\n+        delete obj;\n+    setOpenGlContext(win_name);\n+    obj = new Mesh(verts, indices);\n+    win->set(obj_name, obj);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showMesh(const String& win_name, const String& obj_name, InputArray verts)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(verts);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (obj)\n+        delete obj;\n+    setOpenGlContext(win_name);\n+    obj = new Mesh(verts);\n+    win->set(obj_name, obj);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showPoints(const String& win_name, const String& obj_name, InputArray points)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(points);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (obj)\n+        delete obj;\n+    setOpenGlContext(win_name);\n+    obj = new PointCloud(points);\n+    win->set(obj_name, obj);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::showRGBD(const String& win_name, const String& obj_name, InputArray img, const Matx33f& intrinsics, float scale)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(img);\n+    CV_UNUSED(intrinsics);\n+    CV_UNUSED(scale);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    CV_Assert(img.dims() == 2 && img.channels() == 4 && img.type() == CV_32FC4);\n+    \n+    Mat mat = img.getMat();\n+    Mat points;\n+\n+    // This section (RGBD to point cloud) should be changed to use the 3d module when\n+    // #20013 is merged.\n+\n+    float fx = intrinsics(0, 0);\n+    float fy = intrinsics(1, 1);\n+    float cx = intrinsics(0, 2);\n+    float cy = intrinsics(1, 2);\n+\n+    for (int u = 0; u < mat.cols; ++u)\n+        for (int v = 0; v < mat.rows; ++v)\n+        {\n+            Vec4f c = mat.at<Vec4f>(v, u);\n+            float d = c(3) * 0.001f; // mm to m\n+\n+            float x_over_z = (cx - (float)u) / fx;\n+            float y_over_z = (cy - (float)v) / fy;\n+            float z = d/* / sqrt(1.0f + x_over_z * x_over_z + y_over_z * y_over_z)*/;\n+            float x = x_over_z * z;\n+            float y = y_over_z * z;\n+\n+            float point[] = {\n+                x * scale, y * scale, z * scale,\n+                c(0) / 255.0f, c(1) / 255.0f, c(2) / 255.0f,\n+            };\n+            points.push_back(Mat(1, 6, CV_32F, point));\n+        }\n+\n+    showPoints(win_name, obj_name, points);\n+#endif\n+}\n+\n+void cv::viz3d::showLines(const String& win_name, const String& obj_name, InputArray points)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(points);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (obj)\n+        delete obj;\n+    setOpenGlContext(win_name);\n+    obj = new Lines(points);\n+    win->set(obj_name, obj);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setObjectPosition(const String& win_name, const String& obj_name, const Vec3f& position)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(position);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (!obj)\n+        CV_Error(cv::Error::StsObjectNotFound, \"Object not found\");\n+    obj->setPosition(position);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::setObjectRotation(const String& win_name, const String& obj_name, const Vec3f& rotation)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_UNUSED(rotation);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    Object* obj = win->get(obj_name);\n+    if (!obj)\n+        CV_Error(cv::Error::StsObjectNotFound, \"Object not found\");\n+    obj->setRotation(rotation);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+void cv::viz3d::destroyObject(const String& win_name, const String& obj_name)\n+{\n+    CV_TRACE_FUNCTION();\n+#ifndef HAVE_OPENGL\n+    CV_UNUSED(win_name);\n+    CV_UNUSED(obj_name);\n+    CV_Error(cv::Error::OpenGlNotSupported, \"The library is compiled without OpenGL support\");\n+#else\n+    Window* win = getWindow(win_name);\n+    win->set(obj_name, nullptr);\n+    updateWindow(win_name);\n+#endif\n+}\n+\n+#ifdef HAVE_OPENGL\n+\n+cv::viz3d::View::View()\n+{\n+    this->origin = { 0.0f, 0.0f, 0.0f };\n+    this->distance = 10.0f;\n+    this->position = { 0.0f, 0.0f, this->distance };\n+    this->up = { 0.0f, 1.0f, 0.0f };\n+\n+    this->aspect = 1.0f;\n+    this->setPerspective(1.3f, 0.1f, 2000.0f);\n+    this->lookAt(this->origin, { 0.0f, 1.0f, 0.0f });\n+}\n+\n+void cv::viz3d::View::setAspect(float aspect)\n+{\n+    if (this->aspect != aspect)\n+    {\n+        this->aspect = aspect;\n+        this->setPerspective(this->fov, this->z_near, this->z_far);\n+    }  \n+}\n+\n+void cv::viz3d::View::setPerspective(float fov, float z_near, float z_far)\n+{\n+    this->fov = fov;\n+    this->z_near = z_near;\n+    this->z_far = z_far;\n+\n+    float tan_half_fovy = ::tan(this->fov / 2.0f);\n+    this->proj = Matx44f::zeros();\n+    this->proj(0, 0) = 1.0f / (this->aspect * tan_half_fovy);\n+    this->proj(1, 1) = 1.0f / tan_half_fovy;\n+    this->proj(2, 2) = (this->z_far + this->z_near) / (this->z_far - this->z_near);\n+    this->proj(2, 3) = 1.0f;\n+    this->proj(3, 2) = -(2.0f * this->z_far * this->z_near) / (this->z_far - this->z_near);\n+}\n+\n+void cv::viz3d::View::rotate(float dx, float dy)\n+{\n+    this->position = normalize(this->position - this->origin);\n+    float theta = atan2(this->position(2), this->position(0));\n+    float phi = ::asin(this->position(1));\n+    theta -= dx * 0.05f;\n+    phi += dy * 0.05f;\n+    phi = max(-1.5f, min(1.5f, phi));\n+\n+    this->position(0) = ::cos(theta) * ::cos(phi) * this->distance;\n+    this->position(1) = ::sin(phi) * this->distance;\n+    this->position(2) = ::sin(theta) * ::cos(phi) * this->distance;\n+    this->position += this->origin;\n+\n+    this->lookAt(this->origin, this->up);\n+}\n+\n+void cv::viz3d::View::move(float dx, float dy)\n+{\n+    Vec3f forward = normalize(this->position - this->origin);\n+    Vec3f right = normalize(this->up.cross(forward));\n+    Vec3f up = right.cross(forward);\n+    Vec3f delta = normalize(right * dx - up * dy) * this->distance * 0.01f;\n+\n+    this->origin += delta;\n+    this->position += delta;\n+    this->lookAt(this->origin, this->up);\n+}\n+\n+void cv::viz3d::View::scaleDistance(float amount)\n+{\n+    this->distance *= amount;\n+    this->distance = max(0.1f, this->distance);\n+    this->position = normalize(this->position - this->origin) * this->distance + this->origin;\n+\n+    this->lookAt(this->origin, this->up);\n+}\n+\n+void cv::viz3d::View::lookAt(const Vec3f& point, const Vec3f& up)\n+{\n+    Vec3f f = normalize(point - this->position);\n+    Vec3f s = normalize(up.cross(f));\n+    Vec3f u = f.cross(s);\n+\n+    this->view = Matx44f::zeros();\n+    this->view(0, 0) = s[0];\n+    this->view(1, 0) = s[1];\n+    this->view(2, 0) = s[2];\n+    this->view(0, 1) = u[0];\n+    this->view(1, 1) = u[1];\n+    this->view(2, 1) = u[2];\n+    this->view(0, 2) = f[0];\n+    this->view(1, 2) = f[1];\n+    this->view(2, 2) = f[2];\n+    this->view(3, 0) = -s.dot(this->position);\n+    this->view(3, 1) = -u.dot(this->position);\n+    this->view(3, 2) = -f.dot(this->position);\n+    this->view(3, 3) = 1.0f;\n+}\n+\n+cv::viz3d::Window::Window(const String& name)\n+{\n+    this->name = name;\n+    this->sun.direction = normalize(Vec3f(0.3f, 1.0f, 0.5f));\n+    this->sun.ambient = { 0.1f, 0.1f, 0.1f };\n+    this->sun.diffuse = { 1.0f, 1.0f, 1.0f };\n+    this->sky_color = { 0.0f, 0.0f, 0.0f };\n+\n+\tfloat points[] = {\n+\t\t0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n+\t\t0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,\n+\t\t0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f,\n+\t\t0.0f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n+\t\t0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,\n+\t\t0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 1.0f,\n+\t};\n+\n+\tMat points_mat = Mat(Size(6, 6), CV_32F, points);\n+\n+\tthis->crosshair = new Lines(points_mat);\n+\tthis->shaders[this->crosshair->getShaderName()] = this->crosshair->buildShader();\n+\tthis->crosshair->setShader(this->shaders[this->crosshair->getShaderName()]);\n+\n+    this->grid = nullptr;\n+}\n+\n+cv::viz3d::Window::~Window()\n+{\n+\tdelete this->crosshair;\n+    if (this->grid != nullptr)\n+        delete this->grid;\n+\n+    for (auto obj : this->objects)\n+\t\tdelete obj.second;\n+}\n+\n+cv::viz3d::Object* cv::viz3d::Window::get(const String& obj_name)\n+{\n+\tauto it = this->objects.find(obj_name);\n+\tif (it == this->objects.end())\n+\t\treturn nullptr;\n+\treturn it->second;\n+}\n+\n+void cv::viz3d::Window::set(const String& obj_name, Object* obj)\n+{\n+\tauto it = this->objects.find(obj_name);\n+\tif (it != this->objects.end() && it->second != obj)\n+\t{\n+\t\tdelete it->second;\n+\n+\t\tif (obj == nullptr)\n+\t\t\tthis->objects.erase(it);\n+\t\telse\n+\t\t\tit->second = obj;\n+\t}\n+\telse if (obj != nullptr)\n+\t\tthis->objects[obj_name] = obj;\n+\n+    if (obj != nullptr)\n+    {\n+        String name = obj->getShaderName();\n+        auto it = this->shaders.find(name);\n+        if (it == this->shaders.end())\n+            this->shaders[name] = obj->buildShader();\n+        obj->setShader(this->shaders[name]);\n+    }\n+}\n+\n+void cv::viz3d::Window::setSun(const Vec3f& direction, const Vec3f& ambient, const Vec3f& diffuse)\n+{\n+    this->sun.direction = normalize(direction);\n+    this->sun.ambient = ambient;\n+    this->sun.diffuse = diffuse;\n+}\n+\n+void cv::viz3d::Window::setSky(const Vec3f& color)\n+{\n+    this->sky_color = color;\n+}\n+\n+static Mat getGridVertices(const View& view)\n+{\n+    const Vec3f grid_color = { 0.5f, 0.5f, 0.5f };\n+    const Vec3f axis_color = { 0.8f, 0.8f, 0.8f };\n+    const Vec3f center = view.getOrigin();\n+    const Vec3f camera_dir = view.getOrigin() - view.getPosition();\n+    const float scale = 0.3f;\n+\n+    float tick_step = 1.0f;\n+    while (view.getDistance() * scale / tick_step > 4.0f)\n+        tick_step *= 2.0f;\n+    while (view.getDistance() * scale / tick_step < 2.0f)\n+        tick_step *= 0.5f;\n+\n+    Mat points;\n+    float face_sign[3];\n+\n+    const Vec3f min_p = center - Vec3f(1.0f, 1.0f, 1.0f) * view.getDistance() * scale;\n+    const Vec3f max_p = center + Vec3f(1.0f, 1.0f, 1.0f) * view.getDistance() * scale;\n+\n+    // For each axis add a grid\n+    for (int ai = 0; ai < 3; ++ai)\n+    {\n+        Vec3f az = { 0.0f, 0.0f, 0.0f };\n+        az((ai + 2) % 3) = 1.0f;\n+\n+        // Check if face is positive or negative along the az axis\n+        face_sign[ai] = camera_dir.dot(az) > 0.0f ? 1.0f : -1.0f;\n+\n+        float x = (floor(min_p(ai) / tick_step) + 1.0f) * tick_step;\n+        for (; x < max_p(ai); x += tick_step)\n+        {\n+            Vec3f a = min_p;\n+            Vec3f b = max_p;\n+            a((ai + 0) % 3) = x;\n+            b((ai + 0) % 3) = x;\n+            if (face_sign[ai] > 0.0f)\n+                a((ai + 2) % 3) = b((ai + 2) % 3);\n+            else\n+                b((ai + 2) % 3) = a((ai + 2) % 3);\n+\n+            float data[] = {\n+                a(0), a(1), a(2), grid_color(0), grid_color(1), grid_color(2),\n+                b(0), b(1), b(2), grid_color(0), grid_color(1), grid_color(2),\n+            };\n+\n+            points.push_back(Mat(2, 6, CV_32F, data));\n+        }\n+\n+        float y = (floor(min_p((ai + 1) % 3) / tick_step) + 1.0f) * tick_step;\n+        for (; y < max_p((ai + 1) % 3); y += tick_step)\n+        {\n+            Vec3f a = min_p;\n+            Vec3f b = max_p;\n+            a((ai + 1) % 3) = y;\n+            b((ai + 1) % 3) = y;\n+            if (face_sign[ai] > 0.0f)\n+                a((ai + 2) % 3) = b((ai + 2) % 3);\n+            else\n+                b((ai + 2) % 3) = a((ai + 2) % 3);\n+\n+            float data[] = {\n+                a(0), a(1), a(2), grid_color(0), grid_color(1), grid_color(2),\n+                b(0), b(1), b(2), grid_color(0), grid_color(1), grid_color(2),\n+            };\n+\n+            points.push_back(Mat(2, 6, CV_32F, data));\n+        }\n+    }\n+\n+    // Draw Ox, Oy and Oz axes and ticks\n+    {\n+        Vec3f a = { face_sign[1] > 0.0f ? min_p(0) : max_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? max_p(2) : min_p(2) };\n+        Vec3f b = { face_sign[1] > 0.0f ? min_p(0) : max_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n+        Vec3f c = { face_sign[1] > 0.0f ? max_p(0) : min_p(0), face_sign[2] > 0.0f ? max_p(1) : min_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n+        Vec3f d = { face_sign[1] > 0.0f ? max_p(0) : min_p(0), face_sign[2] > 0.0f ? min_p(1) : max_p(1), face_sign[0] > 0.0f ? min_p(2) : max_p(2) };\n+\n+        float data[] = {\n+            a(0), a(1), a(2), 0.0f, 0.0f, 0.8f,\n+            b(0), b(1), b(2), 0.0f, 0.0f, 0.8f,\n+            b(0), b(1), b(2), 0.8f, 0.0f, 0.0f,\n+            c(0), c(1), c(2), 0.8f, 0.0f, 0.0f,\n+            c(0), c(1), c(2), 0.0f, 0.8f, 0.0f,\n+            d(0), d(1), d(2), 0.0f, 0.8f, 0.0f,\n+        };\n+\n+        points.push_back(Mat(6, 6, CV_32F, data));\n+\n+        float x = (floor(min_p(0) / tick_step) + 1.0f) * tick_step;\n+        for (; x < max_p(0); x += tick_step)\n+        {\n+            Vec3f a, b, c;\n+            a(0) = b(0) = x;\n+            a(1) = b(1) = face_sign[2] > 0.0f ? max_p(1) : min_p(1);\n+            a(2) = face_sign[0] > 0.0f ? min_p(2) : max_p(2);\n+            b(2) = a(2) - face_sign[0] * 0.03f * scale * view.getDistance();\n+\n+            float line[] = {\n+                a(0), a(1), a(2), 0.8f, 0.0f, 0.0f,\n+                b(0), b(1), b(2), 0.8f, 0.0f, 0.0f,\n+            };\n+\n+            points.push_back(Mat(2, 6, CV_32F, line));\n+        }\n+\n+        float y = (floor(min_p(1) / tick_step) + 1.0f) * tick_step;\n+        for (; y < max_p(1); y += tick_step)\n+        {\n+            Vec3f a, b;\n+            a(0) = b(0) = face_sign[1] > 0.0f ? max_p(0) : min_p(0);\n+            a(1) = b(1) = y;\n+            a(2) = face_sign[0] > 0.0f ? min_p(2) : max_p(2);\n+            b(2) = a(2) - face_sign[0] * 0.03f * scale * view.getDistance();\n+\n+            float line[] = {\n+                a(0), a(1), a(2), 0.0f, 0.8f, 0.0f,\n+                b(0), b(1), b(2), 0.0f, 0.8f, 0.0f,\n+            };\n+\n+            points.push_back(Mat(2, 6, CV_32F, line));\n+        }\n+\n+        float z = (floor(min_p(2) / tick_step) + 1.0f) * tick_step;\n+        for (; z < max_p(2); z += tick_step)\n+        {\n+            Vec3f a, b;\n+            a(0) = face_sign[1] > 0.0f ? min_p(0) : max_p(0);\n+            b(0) = a(0) - face_sign[1] * 0.03f * scale * view.getDistance();\n+            a(1) = b(1) = face_sign[2] > 0.0f ? max_p(1) : min_p(1);\n+            a(2) = b(2) = z;\n+\n+            float line[] = {\n+                a(0), a(1), a(2), 0.0f, 0.0f, 0.8f,\n+                b(0), b(1), b(2), 0.0f, 0.0f, 0.8f,\n+            };\n+\n+            points.push_back(Mat(2, 6, CV_32F, line));\n+        }\n+    }\n+\n+    return points;\n+}\n+\n+void cv::viz3d::Window::setGridVisible(bool visible)\n+{\n+    if (visible)\n+    {\n+        this->grid = new Lines(Mat(4096, 6, CV_32F), 0);\n+        this->grid->setShader(this->shaders[this->grid->getShaderName()]);\n+    }\n+    else if (this->grid != nullptr)\n+    {\n+        delete this->grid;\n+        this->grid = nullptr;\n+    }\n+}\n+\n+void cv::viz3d::Window::draw()\n+{\n+    Rect rect = getWindowImageRect(this->name);\n+    float aspect = (float)rect.width / (float)rect.height;\n+    this->view.setAspect(aspect);\n+\n+    ogl::enable(ogl::DEPTH_TEST);\n+    ogl::clearColor({ double(this->sky_color(0) * 255.0f), double(this->sky_color(1) * 255.0f), double(this->sky_color(2) * 255.0f), 255.0 });\n+\n+    if (this->grid)\n+    {\n+        Mat labels;\n+        static_cast<Lines*>(this->grid)->update(getGridVertices(this->view));\n+        this->grid->draw(this->view, this->sun);\n+    }\n+    else\n+    {\n+        this->crosshair->setPosition(this->view.getOrigin());\n+        this->crosshair->draw(this->view, this->sun);\n+    }\n+\n+    for (auto& obj : this->objects)\n+        obj.second->draw(this->view, this->sun);\n+}\n+\n+void cv::viz3d::Window::onMouse(int event, int x, int y, int flags)\n+{\n+    if (event == EVENT_LBUTTONDOWN || event == EVENT_RBUTTONDOWN)\n+    {\n+        this->l_mouse_x = x;\n+        this->l_mouse_y = y;\n+    }\n+    else if (event == EVENT_MOUSEMOVE && (flags & EVENT_FLAG_LBUTTON))\n+    {\n+        this->view.rotate(x - this->l_mouse_x, y - this->l_mouse_y);\n+        updateWindow(this->name);\n+        this->l_mouse_x = x;\n+        this->l_mouse_y = y;\n+    }\n+    else if (event == EVENT_MOUSEMOVE && (flags & EVENT_FLAG_RBUTTON))\n+    {\n+        this->view.move(x - this->l_mouse_x, y - this->l_mouse_y);\n+        updateWindow(this->name);\n+        this->l_mouse_x = x;\n+        this->l_mouse_y = y;\n+    }\n+    else if (event == EVENT_MOUSEWHEEL)\n+    {\n+        this->view.scaleDistance(min(1.2f, max(0.8f, 1.0f - getMouseWheelDelta(flags) / 12.0f)));\n+        updateWindow(this->name);\n+    }\n+}\n+\n+cv::viz3d::Object::Object()\n+{\n+\tthis->position = { 0.0f, 0.0f, 0.0f };\n+\tthis->rotation = { 0.0f, 0.0f, 0.0f };\n+\tthis->model = Matx44f::eye();\n+}\n+\n+void cv::viz3d::Object::setPosition(const Vec3f& position)\n+{\n+    this->position = position;\n+    this->updateModel();\n+}\n+\n+void cv::viz3d::Object::setRotation(const Vec3f& rotation)\n+{\n+    this->rotation = rotation;\n+    this->updateModel();\n+}\n+\n+void cv::viz3d::Object::updateModel()\n+{\n+    // Calculate rotation matrices\n+    Matx44f rot_a = Matx44f::eye();\n+    rot_a(0, 0) = ::cos(this->rotation(0));\n+    rot_a(1, 0) = ::sin(this->rotation(0));\n+    rot_a(0, 1) = -::sin(this->rotation(0));\n+    rot_a(1, 1) = ::cos(this->rotation(0));\n+\n+    Matx44f rot_b = Matx44f::eye();\n+    rot_b(1, 1) = ::cos(this->rotation(1));\n+    rot_b(2, 1) = ::sin(this->rotation(1));\n+    rot_b(1, 2) = -::sin(this->rotation(1));\n+    rot_b(2, 2) = ::cos(this->rotation(1));\n+\n+    Matx44f rot_c = Matx44f::eye();\n+    rot_c(0, 0) = ::cos(this->rotation(2));\n+    rot_c(2, 0) = ::sin(this->rotation(2));\n+    rot_c(0, 2) = -::sin(this->rotation(2));\n+    rot_c(2, 2) = ::cos(this->rotation(2));\n+\n+    // Calculate translation matrix\n+    Matx44f trans = Matx44f::eye();\n+    trans(3, 0) = this->position(0);\n+    trans(3, 1) = this->position(1);\n+    trans(3, 2) = this->position(2);\n+\n+    // Multiply matrices\n+    this->model = rot_c * rot_b * rot_a * trans;\n+}\n+\n+cv::viz3d::Mesh::Mesh(InputArray verts, InputArray indices)\n+{\n+    // Check parameter validity\n+    CV_Assert(verts.channels() == 1 && verts.dims() == 2 && (verts.size().width == 3 || verts.size().width == 6 || verts.size().width == 9));\n+    CV_Assert(verts.depth() == CV_32F);\n+    CV_Assert(indices.channels() == 1 && indices.dims() == 2 && indices.size().width == 3);\n+    CV_Assert(indices.depth() == CV_8U || indices.depth() == CV_16U || indices.depth() == CV_32S);\n+\n+    // Prepare buffers\n+    if (verts.kind() == _InputArray::OPENGL_BUFFER)\n+        this->verts = verts.getOGlBuffer();\n+    else\n+        this->verts.copyFrom(verts, ogl::Buffer::ARRAY_BUFFER);\n+\n+    if (indices.kind() == _InputArray::OPENGL_BUFFER)\n+        this->indices = indices.getOGlBuffer();\n+    else\n+        this->indices.copyFrom(indices, ogl::Buffer::ELEMENT_ARRAY_BUFFER);\n+\n+    switch (indices.depth())\n+    {\n+    case CV_8U:\n+        this->index_type = ogl::UNSIGNED_BYTE;\n+        break;\n+    case CV_16U:\n+        this->index_type = ogl::UNSIGNED_SHORT;\n+        break;\n+    case CV_32S:\n+        this->index_type = ogl::UNSIGNED_INT;\n+        break;\n+    }\n+\n+    // Prepare vertex array\n+    if (verts.size().width == 3)\n+    {\n+        this->va.create({\n+            ogl::Attribute(",
        "comment_created_at": "2021-10-07T21:05:49+00:00",
        "comment_author": "JulieBar",
        "comment_body": "decrease duplication\r\n```\r\ngenerate_attr(shader_loc) {\r\nreturn ogl::Attribute(\r\n\t\t\t    this->verts,\r\n\t\t\t    verts.size().width * sizeof(float), 0,\r\n\t\t\t    3, ogl::Attribute::FLOAT,\r\n\t\t\t    false, false,\r\n\t\t\t    shader_loc\r\n\t\t    );\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1924918226",
    "pr_number": 26772,
    "pr_file": "modules/photo/src/denoising.cpp",
    "created_at": "2025-01-22T08:41:08+00:00",
    "commented_code": "int hn = (int)h.size();\n    double granularity = (double)std::max(1., (double)dst.total()/(1 << 16));\n\n    switch (srcImgs[0].type())\n    int depth = CV_MAT_DEPTH(srcImgs[0].type());",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1924918226",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26772,
        "pr_file": "modules/photo/src/denoising.cpp",
        "discussion_id": "1924918226",
        "commented_code": "@@ -249,60 +249,129 @@ static void fastNlMeansDenoisingMulti_( const std::vector<Mat>& srcImgs, Mat& ds\n     int hn = (int)h.size();\n     double granularity = (double)std::max(1., (double)dst.total()/(1 << 16));\n \n-    switch (srcImgs[0].type())\n+    int depth = CV_MAT_DEPTH(srcImgs[0].type());",
        "comment_created_at": "2025-01-22T08:41:08+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "what about\r\n```\r\n    int depth = srcImgs[0].depth();\r\n    int channels = srcImgs[0].channels();\r\nfor better readibility\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1800592693",
    "pr_number": 26281,
    "pr_file": "modules/core/src/opengl.cpp",
    "created_at": "2024-10-15T07:19:59+00:00",
    "commented_code": "#elif !defined(HAVE_OPENCL_OPENGL_SHARING)\n    NO_OPENCL_SHARING_ERROR;\n#else\n    cl_uint numPlatforms;\n    cl_int status = clGetPlatformIDs(0, NULL, &numPlatforms);\n    cl_uint platformsCnt = 0;\n    cl_uint devCnt = 0;\n    cl_device_id* devices = nullptr;\n    cl_uint devUsed = 0;\n    cl_context context = nullptr;\n\n    cl_int status = clGetPlatformIDs(0, NULL, &platformsCnt);\n    if (status != CL_SUCCESS)\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n    if (numPlatforms == 0)\n    if (platformsCnt == 0)\n        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: No available platforms\");\n\n    std::vector<cl_platform_id> platforms(numPlatforms);\n    status = clGetPlatformIDs(numPlatforms, &platforms[0], NULL);\n    std::vector<cl_platform_id> platforms(platformsCnt);\n    status = clGetPlatformIDs(platformsCnt, &platforms[0], NULL);\n    if (status != CL_SUCCESS)\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platforms: %d\", status));\n\n\n    // TODO Filter platforms by name from OPENCV_OPENCL_DEVICE\n    bool sharingSupported = false;\n\n    int found = -1;\n    cl_device_id device = NULL;\n    cl_context context = NULL;\n    for (unsigned int i = 0; (!sharingSupported && (i < platformsCnt)); ++i) {\n        status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 0, NULL, &devCnt);\n        if (status != CL_SUCCESS)\n            CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n\n    for (int i = 0; i < (int)numPlatforms; i++)\n    {\n        // query platform extension: presence of \"cl_khr_gl_sharing\" extension is required\n        {\n            AutoBuffer<char> extensionStr;\n        try {\n            devices = new cl_device_id[devCnt];\n\n            size_t extensionSize;\n            status = clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, 0, NULL, &extensionSize);\n            if (status == CL_SUCCESS)\n            {\n                extensionStr.allocate(extensionSize+1);\n                status = clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, extensionSize, (char*)extensionStr.data(), NULL);\n            }\n            status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, devCnt, devices, NULL);\n            if (status != CL_SUCCESS)\n                CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platform extension string: %d\", status));\n\n            if (!strstr((const char*)extensionStr.data(), \"cl_khr_gl_sharing\"))\n                continue;\n        }\n\n        clGetGLContextInfoKHR_fn clGetGLContextInfoKHR = (clGetGLContextInfoKHR_fn)\n                clGetExtensionFunctionAddressForPlatform(platforms[i], \"clGetGLContextInfoKHR\");\n        if (!clGetGLContextInfoKHR)\n                CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platform devices: %d\", status));\n\n            for (unsigned int j = 0; (!sharingSupported && (j < devCnt)); ++j) {\n                size_t extensionSize;\n                status = clGetDeviceInfo(devices[j], CL_DEVICE_EXTENSIONS, 0, NULL, &extensionSize );\n                if (status != CL_SUCCESS)\n                    CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n\n                if(extensionSize > 0)\n                {\n                    char* extensions = nullptr;\n\n                    try {\n                        extensions = new char[extensionSize];\n\n                        status = clGetDeviceInfo(devices[j], CL_DEVICE_EXTENSIONS, extensionSize, extensions, &extensionSize);\n                        if (status != CL_SUCCESS)\n                            continue;\n                    } catch(...) {\n                        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: Exception thrown during device extensions gathering\");\n                    }\n\n                    std::string devString;\n\n                    if(extensions != nullptr) {\n                        devString = extensions;\n                        delete[] extensions;\n                    }\n                    else {\n                        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: Unexpected error during device extensions gathering\");\n                    }\n\n                    size_t oldPos = 0;\n                    size_t spacePos = devString.find(' ', oldPos); // extensions string is space delimited\n                    while (spacePos != devString.npos) {\n                        if (strcmp(GL_SHARING_EXTENSION,\n                                devString.substr(oldPos, spacePos - oldPos).c_str())\n                                == 0) {\n                            // Device supports context sharing with OpenGL\n                            devUsed = i;\n                            sharingSupported = true;\n                            break;\n                        }\n                        do {\n                            oldPos = spacePos + 1;\n                            spacePos = devString.find(' ', oldPos);\n                        } while (spacePos == oldPos);\n                    }\n                }\n            }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1800592693",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26281,
        "pr_file": "modules/core/src/opengl.cpp",
        "discussion_id": "1800592693",
        "commented_code": "@@ -1635,94 +1641,148 @@ Context& initializeContextFromGL()\n #elif !defined(HAVE_OPENCL_OPENGL_SHARING)\n     NO_OPENCL_SHARING_ERROR;\n #else\n-    cl_uint numPlatforms;\n-    cl_int status = clGetPlatformIDs(0, NULL, &numPlatforms);\n+    cl_uint platformsCnt = 0;\n+    cl_uint devCnt = 0;\n+    cl_device_id* devices = nullptr;\n+    cl_uint devUsed = 0;\n+    cl_context context = nullptr;\n+\n+    cl_int status = clGetPlatformIDs(0, NULL, &platformsCnt);\n     if (status != CL_SUCCESS)\n         CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n-    if (numPlatforms == 0)\n+    if (platformsCnt == 0)\n         CV_Error(cv::Error::OpenCLInitError, \"OpenCL: No available platforms\");\n \n-    std::vector<cl_platform_id> platforms(numPlatforms);\n-    status = clGetPlatformIDs(numPlatforms, &platforms[0], NULL);\n+    std::vector<cl_platform_id> platforms(platformsCnt);\n+    status = clGetPlatformIDs(platformsCnt, &platforms[0], NULL);\n     if (status != CL_SUCCESS)\n-        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n+        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platforms: %d\", status));\n+\n \n     // TODO Filter platforms by name from OPENCV_OPENCL_DEVICE\n+    bool sharingSupported = false;\n \n-    int found = -1;\n-    cl_device_id device = NULL;\n-    cl_context context = NULL;\n+    for (unsigned int i = 0; (!sharingSupported && (i < platformsCnt)); ++i) {\n+        status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 0, NULL, &devCnt);\n+        if (status != CL_SUCCESS)\n+            CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n \n-    for (int i = 0; i < (int)numPlatforms; i++)\n-    {\n-        // query platform extension: presence of \"cl_khr_gl_sharing\" extension is required\n-        {\n-            AutoBuffer<char> extensionStr;\n+        try {\n+            devices = new cl_device_id[devCnt];\n \n-            size_t extensionSize;\n-            status = clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, 0, NULL, &extensionSize);\n-            if (status == CL_SUCCESS)\n-            {\n-                extensionStr.allocate(extensionSize+1);\n-                status = clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, extensionSize, (char*)extensionStr.data(), NULL);\n-            }\n+            status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, devCnt, devices, NULL);\n             if (status != CL_SUCCESS)\n-                CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platform extension string: %d\", status));\n-\n-            if (!strstr((const char*)extensionStr.data(), \"cl_khr_gl_sharing\"))\n-                continue;\n-        }\n-\n-        clGetGLContextInfoKHR_fn clGetGLContextInfoKHR = (clGetGLContextInfoKHR_fn)\n-                clGetExtensionFunctionAddressForPlatform(platforms[i], \"clGetGLContextInfoKHR\");\n-        if (!clGetGLContextInfoKHR)\n+                CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platform devices: %d\", status));\n+\n+            for (unsigned int j = 0; (!sharingSupported && (j < devCnt)); ++j) {\n+                size_t extensionSize;\n+                status = clGetDeviceInfo(devices[j], CL_DEVICE_EXTENSIONS, 0, NULL, &extensionSize );\n+                if (status != CL_SUCCESS)\n+                    CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n+\n+                if(extensionSize > 0)\n+                {\n+                    char* extensions = nullptr;\n+\n+                    try {\n+                        extensions = new char[extensionSize];\n+\n+                        status = clGetDeviceInfo(devices[j], CL_DEVICE_EXTENSIONS, extensionSize, extensions, &extensionSize);\n+                        if (status != CL_SUCCESS)\n+                            continue;\n+                    } catch(...) {\n+                        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: Exception thrown during device extensions gathering\");\n+                    }\n+\n+                    std::string devString;\n+\n+                    if(extensions != nullptr) {\n+                        devString = extensions;\n+                        delete[] extensions;\n+                    }\n+                    else {\n+                        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: Unexpected error during device extensions gathering\");\n+                    }\n+\n+                    size_t oldPos = 0;\n+                    size_t spacePos = devString.find(' ', oldPos); // extensions string is space delimited\n+                    while (spacePos != devString.npos) {\n+                        if (strcmp(GL_SHARING_EXTENSION,\n+                                devString.substr(oldPos, spacePos - oldPos).c_str())\n+                                == 0) {\n+                            // Device supports context sharing with OpenGL\n+                            devUsed = i;\n+                            sharingSupported = true;\n+                            break;\n+                        }\n+                        do {\n+                            oldPos = spacePos + 1;\n+                            spacePos = devString.find(' ', oldPos);\n+                        } while (spacePos == oldPos);\n+                    }\n+                }\n+            }",
        "comment_created_at": "2024-10-15T07:19:59+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Let's extract extension search as dedicated static function. It should make the code more readable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1677867568",
    "pr_number": 25608,
    "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
    "created_at": "2024-07-15T13:50:53+00:00",
    "commented_code": "WebPBitstreamFeatures features;\n    if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1677867568",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1677867568",
        "commented_code": "@@ -126,8 +84,39 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))",
        "comment_created_at": "2024-07-15T13:50:53+00:00",
        "comment_author": "vrabaud",
        "comment_body": "Just to reduce the imbricated `if` , write it as:\r\n```cpp\r\nif (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features)) return false;\r\n```\r\nAnd then you can remove the big `{}` below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1732463520",
    "pr_number": 25608,
    "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
    "created_at": "2024-08-27T09:21:47+00:00",
    "commented_code": "}\n\n    WebPBitstreamFeatures features;\n    if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n    if (VP8_STATUS_OK < WebPGetFeatures(header, sizeof(header), &features)) return false;\n\n    m_has_animation = features.has_animation == 1;\n\n    if (m_has_animation)\n    {\n        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n        fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n        data.create(1, validateToInt(fs_size), CV_8UC1);\n        fs.read((char*)data.ptr(), fs_size);\n        CV_Assert(fs && \"Can't read file data\");\n        fs.close();\n\n        m_width  = features.width;\n        m_height = features.height;\n        CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n\n        if (features.has_alpha)\n        {\n            m_type = CV_8UC4;\n            channels = 4;\n        }\n        WebPData webp_data;\n        webp_data.bytes = (const uint8_t*)data.ptr();\n        webp_data.size = data.total();\n\n        WebPAnimDecoderOptions dec_options;\n        WebPAnimDecoderOptionsInit(&dec_options);\n\n        if(m_use_rgb)",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1732463520",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1732463520",
        "commented_code": "@@ -124,28 +81,51 @@ bool WebPDecoder::readHeader()\n     }\n \n     WebPBitstreamFeatures features;\n-    if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n+    if (VP8_STATUS_OK < WebPGetFeatures(header, sizeof(header), &features)) return false;\n+\n+    m_has_animation = features.has_animation == 1;\n+\n+    if (m_has_animation)\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+        data.create(1, validateToInt(fs_size), CV_8UC1);\n+        fs.read((char*)data.ptr(), fs_size);\n+        CV_Assert(fs && \"Can't read file data\");\n+        fs.close();\n \n-        m_width  = features.width;\n-        m_height = features.height;\n+        CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n \n-        if (features.has_alpha)\n-        {\n-            m_type = CV_8UC4;\n-            channels = 4;\n-        }\n+        WebPData webp_data;\n+        webp_data.bytes = (const uint8_t*)data.ptr();\n+        webp_data.size = data.total();\n+\n+        WebPAnimDecoderOptions dec_options;\n+        WebPAnimDecoderOptionsInit(&dec_options);\n+\n+        if(m_use_rgb)",
        "comment_created_at": "2024-08-27T09:21:47+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "which line below better for readability?\r\n\r\n```\r\nif(m_use_rgb)\r\n    dec_options.color_mode = features.has_alpha ? MODE_RGBA : MODE_RGB;\r\nelse\r\n    dec_options.color_mode = features.has_alpha ? MODE_BGRA : MODE_BGR;\r\n```\r\n```\r\ndec_options.color_mode = m_use_rgb\r\n    ? (features.has_alpha ? MODE_RGBA : MODE_RGB)\r\n    : (features.has_alpha ? MODE_BGRA : MODE_BGR);\r\n```\r\n@vrabaud , @asmorkalov ",
        "pr_file_module": null
      },
      {
        "comment_id": "1732760920",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1732463520",
        "commented_code": "@@ -124,28 +81,51 @@ bool WebPDecoder::readHeader()\n     }\n \n     WebPBitstreamFeatures features;\n-    if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n+    if (VP8_STATUS_OK < WebPGetFeatures(header, sizeof(header), &features)) return false;\n+\n+    m_has_animation = features.has_animation == 1;\n+\n+    if (m_has_animation)\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+        data.create(1, validateToInt(fs_size), CV_8UC1);\n+        fs.read((char*)data.ptr(), fs_size);\n+        CV_Assert(fs && \"Can't read file data\");\n+        fs.close();\n \n-        m_width  = features.width;\n-        m_height = features.height;\n+        CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n \n-        if (features.has_alpha)\n-        {\n-            m_type = CV_8UC4;\n-            channels = 4;\n-        }\n+        WebPData webp_data;\n+        webp_data.bytes = (const uint8_t*)data.ptr();\n+        webp_data.size = data.total();\n+\n+        WebPAnimDecoderOptions dec_options;\n+        WebPAnimDecoderOptionsInit(&dec_options);\n+\n+        if(m_use_rgb)",
        "comment_created_at": "2024-08-27T12:31:30+00:00",
        "comment_author": "vrabaud",
        "comment_body": "I'd say the second one.",
        "pr_file_module": null
      }
    ]
  }
]