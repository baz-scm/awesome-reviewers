[
  {
    "discussion_id": "2024754221",
    "pr_number": 27051,
    "pr_file": "modules/photo/test/test_precomp.hpp",
    "created_at": "2025-04-02T12:46:24+00:00",
    "commented_code": "#include \"opencv2/ts/ocl_test.hpp\"\n#include \"opencv2/photo.hpp\"\n\nnamespace opencv_test\n{\nusing namespace cv::ccm;",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2024754221",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27051,
        "pr_file": "modules/photo/test/test_precomp.hpp",
        "discussion_id": "2024754221",
        "commented_code": "@@ -8,4 +8,9 @@\n #include \"opencv2/ts/ocl_test.hpp\"\n #include \"opencv2/photo.hpp\"\n \n+namespace opencv_test\n+{\n+using namespace cv::ccm;",
        "comment_created_at": "2025-04-02T12:46:24+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "using namespace is very bad practice. It affects everything, even, if the header is not included directly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1450246565",
    "pr_number": 24768,
    "pr_file": "modules/dnn/src/vkcom/shader/nary_eltwise_binary_forward.comp",
    "created_at": "2024-01-12T11:01:09+00:00",
    "commented_code": "#version 450\n// #extension GL_EXT_debug_printf : enable\n#define ALL_THREAD 1024\n// #define ALL_THREAD 128 // Experimental batched operation\n#define STEP_SIZE 65536\n\nlayout(binding = 0) readonly buffer Input1{\n    float matA[];\n};\n\nlayout(binding = 1) readonly buffer Input2{\n    float matB[];\n};\n\nlayout(binding = 2) writeonly buffer Output{\n    float matOut[];\n};\n\nlayout(binding = 3) uniform Params {\n    int opType;\n    int ndims;\n} params;\n\nlayout(binding = 4) readonly buffer Shape {\n    int shape[];\n};\n\nlayout(binding = 5) readonly buffer Step {\n    int matStep[];\n};\n\n/* local_size_x, local_size_y, local_size_z there defines the number of invocations\n   of this compute shader in the current work group. */\n// TODO: Check if this makes any sense\n// TODO: Check if it is required to fetch PhysicalDeviceLimit from Context\n// TODO: here we shall assume that maxGroupInvocation is 1024.\nlayout(local_size_x = ALL_THREAD, local_size_y = 1, local_size_z = 1) in; // TODO: Check if this makes any sense\n\nconst int AND = 0;\nconst int EQUAL = 1;\nconst int GREATER = 2;\nconst int GREATER_EQUAL = 3;\nconst int LESS = 4;\nconst int LESS_EQUAL = 5;\nconst int OR = 6;\nconst int POW = 7;\nconst int XOR = 8;\nconst int BITSHIFT = 9;\nconst int MAX = 10;\nconst int MEAN = 11;\nconst int MIN = 12;\nconst int MOD = 13;\nconst int PROD = 14;\nconst int SUB = 15;\nconst int SUM = 16;\nconst int ADD = 17;\nconst int DIV = 18;\nconst int WHERE = 19;\n\nvoid binary_forward()\n{\n    int ndims = params.ndims;\n    int dp1 = matStep[2 * ndims - 1];\n    int dp2 = matStep[3 * ndims - 1];\n    int dp = matStep[ndims - 1];\n    int n1 = shape[ndims - 1], n2 = shape[ndims - 2];\n\n    int plane_idx = int(gl_WorkGroupID.x);\n\n    int ptr1 = 0;\n    int ptr2 = 0;\n    int ptr = 0;\n    int idx = plane_idx;\n\n    for (int k = ndims - 3; k >= 0; --k) {\n        int next_idx = idx / shape[k];\n        int i_k = idx - next_idx * shape[k]; // i_k = idx % shape[k]\n        ptr1 += i_k * matStep[ndims + k];\n        ptr2 += i_k * matStep[2 * ndims + k];\n        ptr += i_k * matStep[k];\n        idx = next_idx;\n    }\n\n    int i2_offset = int(gl_WorkGroupID.y);\n    int i1_offset = int(gl_LocalInvocationID.x);\n\n    ptr1 += i2_offset * matStep[2 * ndims - 2];\n    ptr2 += i2_offset * matStep[3 * ndims - 2];\n    ptr += i2_offset * matStep[ndims - 2];\n\n/*\n    if (dp1 == 1 && dp2 == 1 && dp == 1) {\n        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n            perform_op(&matA + ptr1 + i1, &matB + ptr2 + i1, &matOut + ptr + i1);\n        }\n    } else if (dp1 == 1 && dp2 == 0 && dp == 1) {\n        float k = matB[ptr2];\n        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n            perform_op(&matA + ptr1 + i1, &matB + ptr2, &matOut + ptr + i1);\n        }\n    } else if (dp1 == 0 && dp2 == 1 && dp == 1) {\n        float k = matA[ptr1];\n        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n            perform_op(&matA + ptr1, &matB + ptr2 + i1, &matOut + ptr + i1);\n        }\n    } else {\n        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n            perform_op(&matA + ptr1 + i1 * dp1, &matB + ptr2 + i1 * dp2, &matOut + ptr + i1 * dp);\n        }\n    }\n*/\n    for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n        switch (params.opType) {\n            case int(ADD):\n                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] + matB[ptr2 + i1 * dp2];\n                break;\n            case int(SUB):\n                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] - matB[ptr2 + i1 * dp2];\n                break;\n            case int(PROD):\n                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] * matB[ptr2 + i1 * dp2];\n                break;\n            case int(DIV):\n                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] / matB[ptr2 + i1 * dp2];\n                break;\n        }\n    }\n\n    // Experimental Batched Operation\n\n    // int threadID = int(gl_LocalInvocationID.x);\n    // int i2_offset = (int(gl_WorkGroupID.y)) * STEP_SIZE + threadID;\n    // int i1_offset = (int(gl_WorkGroupID.z)) * STEP_SIZE;\n\n    // ptr1 += i2_offset * matStep[2 * ndims - 2] + i1_offset * dp1;\n    // ptr2 += i2_offset * matStep[3 * ndims - 2] + i1_offset * dp2;\n    // ptr += i2_offset * matStep[ndims - 2] + i1_offset * dp;\n\n\n    // int i2_loop_count = STEP_SIZE / ALL_THREAD;\n    // for (int i2_c = 0; i2_offset < n2 && i2_c < i2_loop_count; i2_offset += ALL_THREAD, ++i2_c)\n    // {\n    //     if (dp1 == 1 && dp2 == 1 && dp == 1) {\n    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n    //             if (ptr + i1 < n1) {\n    //                 matOut[ptr + i1] = matA[ptr1 + i1] + matB[ptr2 + i1];\n    //             }\n    //         }\n    //     } else if (dp1 == 1 && dp2 == 0 && dp == 1) {\n    //         float k = matB[ptr2];\n    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n    //             if (ptr + i1 < n1) {\n    //                 matOut[ptr + i1] = matA[ptr1 + i1] + k;\n    //             }\n    //         }\n    //     } else if (dp1 == 0 && dp2 == 1 && dp == 1) {\n    //         float k = matA[ptr1];\n    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n    //             if (ptr + i1 < n1) {\n    //                 matOut[ptr + i1] = k + matB[ptr2 + i1];\n    //             }\n    //         }\n    //     } else {\n    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n    //             if (ptr + i1 < n1) {\n    //                 matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] + matB[ptr2 + i1 * dp2];\n    //             }\n    //         }\n    //     }\n    //     ptr1 += ALL_THREAD * matStep[2 * ndims - 2];\n    //     ptr2 += ALL_THREAD * matStep[3 * ndims - 2];\n    //     ptr += ALL_THREAD * matStep[ndims - 2];\n    // }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1450246565",
        "repo_full_name": "opencv/opencv",
        "pr_number": 24768,
        "pr_file": "modules/dnn/src/vkcom/shader/nary_eltwise_binary_forward.comp",
        "discussion_id": "1450246565",
        "commented_code": "@@ -0,0 +1,182 @@\n+#version 450\n+// #extension GL_EXT_debug_printf : enable\n+#define ALL_THREAD 1024\n+// #define ALL_THREAD 128 // Experimental batched operation\n+#define STEP_SIZE 65536\n+\n+layout(binding = 0) readonly buffer Input1{\n+    float matA[];\n+};\n+\n+layout(binding = 1) readonly buffer Input2{\n+    float matB[];\n+};\n+\n+layout(binding = 2) writeonly buffer Output{\n+    float matOut[];\n+};\n+\n+layout(binding = 3) uniform Params {\n+    int opType;\n+    int ndims;\n+} params;\n+\n+layout(binding = 4) readonly buffer Shape {\n+    int shape[];\n+};\n+\n+layout(binding = 5) readonly buffer Step {\n+    int matStep[];\n+};\n+\n+/* local_size_x, local_size_y, local_size_z there defines the number of invocations\n+   of this compute shader in the current work group. */\n+// TODO: Check if this makes any sense\n+// TODO: Check if it is required to fetch PhysicalDeviceLimit from Context\n+// TODO: here we shall assume that maxGroupInvocation is 1024.\n+layout(local_size_x = ALL_THREAD, local_size_y = 1, local_size_z = 1) in; // TODO: Check if this makes any sense\n+\n+const int AND = 0;\n+const int EQUAL = 1;\n+const int GREATER = 2;\n+const int GREATER_EQUAL = 3;\n+const int LESS = 4;\n+const int LESS_EQUAL = 5;\n+const int OR = 6;\n+const int POW = 7;\n+const int XOR = 8;\n+const int BITSHIFT = 9;\n+const int MAX = 10;\n+const int MEAN = 11;\n+const int MIN = 12;\n+const int MOD = 13;\n+const int PROD = 14;\n+const int SUB = 15;\n+const int SUM = 16;\n+const int ADD = 17;\n+const int DIV = 18;\n+const int WHERE = 19;\n+\n+void binary_forward()\n+{\n+    int ndims = params.ndims;\n+    int dp1 = matStep[2 * ndims - 1];\n+    int dp2 = matStep[3 * ndims - 1];\n+    int dp = matStep[ndims - 1];\n+    int n1 = shape[ndims - 1], n2 = shape[ndims - 2];\n+\n+    int plane_idx = int(gl_WorkGroupID.x);\n+\n+    int ptr1 = 0;\n+    int ptr2 = 0;\n+    int ptr = 0;\n+    int idx = plane_idx;\n+\n+    for (int k = ndims - 3; k >= 0; --k) {\n+        int next_idx = idx / shape[k];\n+        int i_k = idx - next_idx * shape[k]; // i_k = idx % shape[k]\n+        ptr1 += i_k * matStep[ndims + k];\n+        ptr2 += i_k * matStep[2 * ndims + k];\n+        ptr += i_k * matStep[k];\n+        idx = next_idx;\n+    }\n+\n+    int i2_offset = int(gl_WorkGroupID.y);\n+    int i1_offset = int(gl_LocalInvocationID.x);\n+\n+    ptr1 += i2_offset * matStep[2 * ndims - 2];\n+    ptr2 += i2_offset * matStep[3 * ndims - 2];\n+    ptr += i2_offset * matStep[ndims - 2];\n+\n+/*\n+    if (dp1 == 1 && dp2 == 1 && dp == 1) {\n+        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n+            perform_op(&matA + ptr1 + i1, &matB + ptr2 + i1, &matOut + ptr + i1);\n+        }\n+    } else if (dp1 == 1 && dp2 == 0 && dp == 1) {\n+        float k = matB[ptr2];\n+        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n+            perform_op(&matA + ptr1 + i1, &matB + ptr2, &matOut + ptr + i1);\n+        }\n+    } else if (dp1 == 0 && dp2 == 1 && dp == 1) {\n+        float k = matA[ptr1];\n+        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n+            perform_op(&matA + ptr1, &matB + ptr2 + i1, &matOut + ptr + i1);\n+        }\n+    } else {\n+        for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n+            perform_op(&matA + ptr1 + i1 * dp1, &matB + ptr2 + i1 * dp2, &matOut + ptr + i1 * dp);\n+        }\n+    }\n+*/\n+    for (int i1 = i1_offset; i1 < n1; i1 += ALL_THREAD) {\n+        switch (params.opType) {\n+            case int(ADD):\n+                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] + matB[ptr2 + i1 * dp2];\n+                break;\n+            case int(SUB):\n+                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] - matB[ptr2 + i1 * dp2];\n+                break;\n+            case int(PROD):\n+                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] * matB[ptr2 + i1 * dp2];\n+                break;\n+            case int(DIV):\n+                matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] / matB[ptr2 + i1 * dp2];\n+                break;\n+        }\n+    }\n+\n+    // Experimental Batched Operation\n+\n+    // int threadID = int(gl_LocalInvocationID.x);\n+    // int i2_offset = (int(gl_WorkGroupID.y)) * STEP_SIZE + threadID;\n+    // int i1_offset = (int(gl_WorkGroupID.z)) * STEP_SIZE;\n+\n+    // ptr1 += i2_offset * matStep[2 * ndims - 2] + i1_offset * dp1;\n+    // ptr2 += i2_offset * matStep[3 * ndims - 2] + i1_offset * dp2;\n+    // ptr += i2_offset * matStep[ndims - 2] + i1_offset * dp;\n+\n+\n+    // int i2_loop_count = STEP_SIZE / ALL_THREAD;\n+    // for (int i2_c = 0; i2_offset < n2 && i2_c < i2_loop_count; i2_offset += ALL_THREAD, ++i2_c)\n+    // {\n+    //     if (dp1 == 1 && dp2 == 1 && dp == 1) {\n+    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n+    //             if (ptr + i1 < n1) {\n+    //                 matOut[ptr + i1] = matA[ptr1 + i1] + matB[ptr2 + i1];\n+    //             }\n+    //         }\n+    //     } else if (dp1 == 1 && dp2 == 0 && dp == 1) {\n+    //         float k = matB[ptr2];\n+    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n+    //             if (ptr + i1 < n1) {\n+    //                 matOut[ptr + i1] = matA[ptr1 + i1] + k;\n+    //             }\n+    //         }\n+    //     } else if (dp1 == 0 && dp2 == 1 && dp == 1) {\n+    //         float k = matA[ptr1];\n+    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n+    //             if (ptr + i1 < n1) {\n+    //                 matOut[ptr + i1] = k + matB[ptr2 + i1];\n+    //             }\n+    //         }\n+    //     } else {\n+    //         for (int i1 = 0; i1 < STEP_SIZE; ++i1) {\n+    //             if (ptr + i1 < n1) {\n+    //                 matOut[ptr + i1 * dp] = matA[ptr1 + i1 * dp1] + matB[ptr2 + i1 * dp2];\n+    //             }\n+    //         }\n+    //     }\n+    //     ptr1 += ALL_THREAD * matStep[2 * ndims - 2];\n+    //     ptr2 += ALL_THREAD * matStep[3 * ndims - 2];\n+    //     ptr += ALL_THREAD * matStep[ndims - 2];\n+    // }",
        "comment_created_at": "2024-01-12T11:01:09+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Please remove dead code, or guard it with macro, if you want to use it later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1989625280",
    "pr_number": 26834,
    "pr_file": "modules/imgproc/src/contours_common.hpp",
    "created_at": "2025-03-11T15:56:04+00:00",
    "commented_code": "}\n\nprivate:\n    std::stack<int> levels;\n    Tree<T>& tree;\n    std::stack<int> levels;\n};\n\n//==============================================================================\n\ntemplate <typename T, size_t BLOCK_SIZE_ELEM, size_t STATIC_CAPACITY_BYTES>\nclass ContourDataStorage\n{\npublic:\n    typedef T data_storage_t;\n    typedef BlockStorage<data_storage_t, BLOCK_SIZE_ELEM, STATIC_CAPACITY_BYTES> storage_t;\npublic:\n    ContourDataStorage(void) = delete;\n    ContourDataStorage(storage_t* _storage):storage(_storage) {}\n    ContourDataStorage(const ContourDataStorage&) = delete;\n    ContourDataStorage(ContourDataStorage&&) noexcept = default;\n    ~ContourDataStorage() = default;\n    ContourDataStorage& operator=(const ContourDataStorage&) = delete;\n    ContourDataStorage& operator=(ContourDataStorage&&) noexcept = default;\npublic:\n    typename storage_t::RangeIterator getRangeIterator(void) const {return storage->getRangeIterator(first, last);}\npublic:\n    bool empty(void) const {return first == last;}\n    size_t size(void) const {return last - first;}\npublic:\n    void clear(void) {first = last;}\n    bool resize(size_t newSize) {\n        bool ok = (newSize <= size());\n        if (ok)\n            last = first+newSize;\n        return ok;\n    }\n    void push_back(const data_storage_t& value) {",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1989625280",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26834,
        "pr_file": "modules/imgproc/src/contours_common.hpp",
        "discussion_id": "1989625280",
        "commented_code": "@@ -159,23 +171,78 @@ class TreeIterator\n     }\n \n private:\n-    std::stack<int> levels;\n     Tree<T>& tree;\n+    std::stack<int> levels;\n };\n \n //==============================================================================\n \n+template <typename T, size_t BLOCK_SIZE_ELEM, size_t STATIC_CAPACITY_BYTES>\n+class ContourDataStorage\n+{\n+public:\n+    typedef T data_storage_t;\n+    typedef BlockStorage<data_storage_t, BLOCK_SIZE_ELEM, STATIC_CAPACITY_BYTES> storage_t;\n+public:\n+    ContourDataStorage(void) = delete;\n+    ContourDataStorage(storage_t* _storage):storage(_storage) {}\n+    ContourDataStorage(const ContourDataStorage&) = delete;\n+    ContourDataStorage(ContourDataStorage&&) noexcept = default;\n+    ~ContourDataStorage() = default;\n+    ContourDataStorage& operator=(const ContourDataStorage&) = delete;\n+    ContourDataStorage& operator=(ContourDataStorage&&) noexcept = default;\n+public:\n+    typename storage_t::RangeIterator getRangeIterator(void) const {return storage->getRangeIterator(first, last);}\n+public:\n+    bool empty(void) const {return first == last;}\n+    size_t size(void) const {return last - first;}\n+public:\n+    void clear(void) {first = last;}\n+    bool resize(size_t newSize) {\n+        bool ok = (newSize <= size());\n+        if (ok)\n+            last = first+newSize;\n+        return ok;\n+    }\n+    void push_back(const data_storage_t& value) {",
        "comment_created_at": "2025-03-11T15:56:04+00:00",
        "comment_author": "mshabunin",
        "comment_body": "It would be better to keep formatting consistent in existing files. This file uses Allman brace/indent style:\r\n```\r\nvoid push_back(...)\r\n{\r\n    if (...)\r\n    {\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1928218708",
    "pr_number": 26789,
    "pr_file": "3rdparty/hal_rvv/hal_rvv_1p0/minmax.hpp",
    "created_at": "2025-01-24T07:27:05+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n#ifndef OPENCV_HAL_RVV_MINMAXIDX_HPP_INCLUDED\n#define OPENCV_HAL_RVV_MINMAXIDX_HPP_INCLUDED\n\n#include <riscv_vector.h>\n\nnamespace cv { namespace cv_hal_rvv {\n\n#undef cv_hal_minMaxIdx\n#define cv_hal_minMaxIdx cv::cv_hal_rvv::minMaxIdx\n#undef cv_hal_minMaxIdxMaskStep\n#define cv_hal_minMaxIdxMaskStep cv::cv_hal_rvv::minMaxIdx\n\n#define HAL_RVV_MINMAXIDX_READTWICE_GENERATOR(D_TYPE, V_TYPE, EEW, EMUL, IS_U, IS_F, F_OR_X, F_OR_S, M_EMUL) \\\ninline int minMaxIdx_##V_TYPE(const uchar* src_data, size_t src_step, int width, int height, double* minVal, double* maxVal, \\\n                              int* minIdx, int* maxIdx, uchar* mask, size_t mask_step) \\\n{ \\\n    int vlmax = __riscv_vsetvlmax_##EEW##EMUL(); \\\n    auto vec_min = __riscv_v##IS_F##mv_v_##F_OR_X##_##V_TYPE##EMUL(std::numeric_limits<D_TYPE>::max(), vlmax); \\",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1928218708",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26789,
        "pr_file": "3rdparty/hal_rvv/hal_rvv_1p0/minmax.hpp",
        "discussion_id": "1928218708",
        "commented_code": "@@ -0,0 +1,294 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+#ifndef OPENCV_HAL_RVV_MINMAXIDX_HPP_INCLUDED\n+#define OPENCV_HAL_RVV_MINMAXIDX_HPP_INCLUDED\n+\n+#include <riscv_vector.h>\n+\n+namespace cv { namespace cv_hal_rvv {\n+\n+#undef cv_hal_minMaxIdx\n+#define cv_hal_minMaxIdx cv::cv_hal_rvv::minMaxIdx\n+#undef cv_hal_minMaxIdxMaskStep\n+#define cv_hal_minMaxIdxMaskStep cv::cv_hal_rvv::minMaxIdx\n+\n+#define HAL_RVV_MINMAXIDX_READTWICE_GENERATOR(D_TYPE, V_TYPE, EEW, EMUL, IS_U, IS_F, F_OR_X, F_OR_S, M_EMUL) \\\n+inline int minMaxIdx_##V_TYPE(const uchar* src_data, size_t src_step, int width, int height, double* minVal, double* maxVal, \\\n+                              int* minIdx, int* maxIdx, uchar* mask, size_t mask_step) \\\n+{ \\\n+    int vlmax = __riscv_vsetvlmax_##EEW##EMUL(); \\\n+    auto vec_min = __riscv_v##IS_F##mv_v_##F_OR_X##_##V_TYPE##EMUL(std::numeric_limits<D_TYPE>::max(), vlmax); \\",
        "comment_created_at": "2025-01-24T07:27:05+00:00",
        "comment_author": "opencv-alalek",
        "comment_body": "In general it is hard to debug multi-line macros.\r\nC++ template-based approach is preferable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1732755224",
    "pr_number": 25715,
    "pr_file": "modules/imgcodecs/src/grfmt_png.hpp",
    "created_at": "2024-08-27T12:28:11+00:00",
    "commented_code": "bool  isFormatSupported( int depth ) const CV_OVERRIDE;\n    bool  write( const Mat& img, const std::vector<int>& params ) CV_OVERRIDE;\n    bool  writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params) CV_OVERRIDE;\n    bool  writeanimation(const Animation& animinfo, const std::vector<int>& params) CV_OVERRIDE;\n    size_t save_apng(std::string inputFileName, std::vector<APNGFrame>& frames, uint first, uint loops, uint coltype, int deflate_method, int iter);\n    void  optim_dirty(std::vector<APNGFrame>& frames);\n    void  optim_duplicates(std::vector<APNGFrame>& frames, uint first);\n\n    ImageEncoder newEncoder() const CV_OVERRIDE;\n\nprotected:\n    static void writeDataToBuf(void* png_ptr, uchar* src, size_t size);\n    static void flushBuf(void* png_ptr);\n\nprivate:\n    void write_chunk(FILE* f, const char* name, uchar* data, uint length);\n    void write_IDATs(FILE* f, int frame, uchar* data, uint length, uint idat_size);\n    void process_rect(uchar* row, int rowbytes, int bpp, int stride, int h, uchar* rows);\n    void deflate_rect_fin(int deflate_method, int iter, uchar* zbuf, uint* zsize, int bpp, int stride, uchar* rows, int zbuf_size, int n);\n    void deflate_rect_op(uchar* pdata, int x, int y, int w, int h, int bpp, int stride, int zbuf_size, int n);\n    void get_rect(uint w, uint h, uchar* pimage1, uchar* pimage2, uchar* ptemp, uint bpp, uint stride, int zbuf_size, uint has_tcolor, uint tcolor, int n);\n\n    uchar*         op_zbuf1;",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1732755224",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25715,
        "pr_file": "modules/imgcodecs/src/grfmt_png.hpp",
        "discussion_id": "1732755224",
        "commented_code": "@@ -86,12 +77,40 @@ class PngEncoder CV_FINAL : public BaseImageEncoder\n \n     bool  isFormatSupported( int depth ) const CV_OVERRIDE;\n     bool  write( const Mat& img, const std::vector<int>& params ) CV_OVERRIDE;\n+    bool  writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params) CV_OVERRIDE;\n+    bool  writeanimation(const Animation& animinfo, const std::vector<int>& params) CV_OVERRIDE;\n+    size_t save_apng(std::string inputFileName, std::vector<APNGFrame>& frames, uint first, uint loops, uint coltype, int deflate_method, int iter);\n+    void  optim_dirty(std::vector<APNGFrame>& frames);\n+    void  optim_duplicates(std::vector<APNGFrame>& frames, uint first);\n \n     ImageEncoder newEncoder() const CV_OVERRIDE;\n \n protected:\n     static void writeDataToBuf(void* png_ptr, uchar* src, size_t size);\n     static void flushBuf(void* png_ptr);\n+\n+private:\n+    void write_chunk(FILE* f, const char* name, uchar* data, uint length);\n+    void write_IDATs(FILE* f, int frame, uchar* data, uint length, uint idat_size);\n+    void process_rect(uchar* row, int rowbytes, int bpp, int stride, int h, uchar* rows);\n+    void deflate_rect_fin(int deflate_method, int iter, uchar* zbuf, uint* zsize, int bpp, int stride, uchar* rows, int zbuf_size, int n);\n+    void deflate_rect_op(uchar* pdata, int x, int y, int w, int h, int bpp, int stride, int zbuf_size, int n);\n+    void get_rect(uint w, uint h, uchar* pimage1, uchar* pimage2, uchar* ptemp, uint bpp, uint stride, int zbuf_size, uint has_tcolor, uint tcolor, int n);\n+\n+    uchar*         op_zbuf1;",
        "comment_created_at": "2024-08-27T12:28:11+00:00",
        "comment_author": "vrabaud",
        "comment_body": "please use `unsigned char`",
        "pr_file_module": null
      }
    ]
  }
]