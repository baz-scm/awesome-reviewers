[
  {
    "discussion_id": "1632891724",
    "pr_number": 25691,
    "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
    "created_at": "2024-06-10T09:10:33+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level\n// directory of this distribution and at http://opencv.org/license.html\n\n#include \"precomp.hpp\"\n#include \"grfmt_gif.hpp\"\n\nnamespace cv\n{\n//////////////////////////////////////////////////////////////////////\n////                        GIF Decoder                           ////\n//////////////////////////////////////////////////////////////////////\nGifDecoder::GifDecoder() {\n    m_signature = R\"(GIF)\";\n    m_type = CV_8UC3;\n    bgColor = -1;\n    m_buf_supported = true;\n    globalColorTableSize = 0;\n    localColorTableSize = 0;\n    lzwMinCodeSize = 0;\n    hasRead = false;\n    hasTransparentColor = false;\n    transparentColor = 0;\n    opMode = GRFMT_GIF_Nothing;\n    top = 0, left = 0, width = 0, height = 0;\n    depth = 8;\n}\n\nGifDecoder::~GifDecoder() {\n    close();\n}\n\nbool GifDecoder::readHeader() {\n    if (!m_buf.empty()) {\n        if (!m_strm.open(m_buf)) {\n            return false;\n        }\n    } else if (!m_strm.open(m_filename)) {\n        return false;\n    }\n\n    try {\n        m_strm.skip(6);// Skip the signature: GIF87a or GIF89a\n\n        // #1: read logical screen descriptor\n        m_width = m_strm.getWord();\n        m_height = m_strm.getWord();\n        CV_Assert(m_width > 0 && m_height > 0);\n\n        char flags = (char)m_strm.getByte();\n\n        // the background color -> index in the global color table, valid only if the global color table is present\n        bgColor = m_strm.getByte();\n        m_strm.skip(1); // Skip the aspect ratio\n\n        // #2: read global color table\n        depth = ((flags & 0x70) >> 4) + 1;\n        if (flags & 0x80) {\n            globalColorTableSize = 1 << ((flags & 0x07) + 1);\n            globalColorTable.allocate(3 * globalColorTableSize);\n            for (int i = 0; i < 3 * globalColorTableSize; i++) {\n                globalColorTable[i] = (uchar)m_strm.getByte();\n            }\n        }\n    } catch (...) {\n        throw;\n    }\n\n    hasRead = false;\n    return true;\n}\n\nbool GifDecoder::readData(Mat &img) {\n    if (hasRead) {\n        lastImage.copyTo(img);\n        return true;\n    }\n\n    readExtensions();\n    // Image separator\n    CV_Assert(!(m_strm.getByte()^0x2C));\n    left = m_strm.getWord();\n    top = m_strm.getWord();\n    width = m_strm.getWord();\n    height = m_strm.getWord();\n    CV_Assert(width > 0 && height > 0 && left + width <= m_width && top + height <= m_height);\n\n    currentImageCodeStream.allocate(width * height);\n    Mat img_;\n\n    switch (opMode) {\n        case GifOpMode::GRFMT_GIF_PreviousImage:\n            if (lastImage.empty()){\n                img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n            } else {\n                img_ = lastImage;\n            }\n            break;\n        case GifOpMode::GRFMT_GIF_Background:\n            // background color is valid iff global color table exists\n            CV_Assert(globalColorTableSize > 0);\n            img_ = Mat(m_height, m_width, CV_8UC3,\n                       Scalar(globalColorTable[bgColor * 3 + 2],\n                              globalColorTable[bgColor * 3 + 1],\n                              globalColorTable[bgColor * 3]));\n            break;\n        case GifOpMode::GRFMT_GIF_Nothing:\n        case GifOpMode::GRFMT_GIF_Cover:\n            // default value\n            img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n            break;\n        default:\n            CV_Assert(false);\n    }\n    lastImage.release();\n\n    auto flags = (uchar)m_strm.getByte();\n    localColorTableSize = 0;\n    if (flags & 0x80) {\n        // local color table\n        localColorTableSize = 1 << ((flags & 0x07) + 1);\n        localColorTable.allocate(3 * localColorTableSize);\n        for (int i = 0; i < 3 * localColorTableSize; i++) {\n            localColorTable[i] = (uchar)m_strm.getByte();\n        }\n    }\n\n    // the case that neither global nor local color table exists is not defined in the GIF standard (but allowed)\n    if (!(globalColorTableSize || localColorTableSize)) {\n        // go through the length of unused data.\n        m_strm.skip(1);\n        int len = m_strm.getByte();\n        while (len) {\n            m_strm.skip(len);\n            len = m_strm.getByte();\n        }\n\n        lastImage = img_;\n        if (!img.empty())\n            img_.copyTo(img);\n\n        // release the memory\n        img_.release();\n        return true;\n    }\n\n    // lzw decompression to get the code stream\n    hasRead = lzwDecode();\n\n    // convert code stream into pixels on the image\n    if (hasRead) {\n        if (!(flags & 0x40)) {\n            // no interlace, simply convert the code stream into pixels from top to down\n            code2pixel(img_, 0, 1);\n        } else {\n            // consider the interlace mode, the image will be rendered in four separate passes\n            code2pixel(img_, 0, 8);\n            code2pixel(img_, 4, 8);\n            code2pixel(img_, 2, 4);\n            code2pixel(img_, 1, 2);\n        }\n    }\n\n    lastImage = img_;\n    if (!img.empty())\n        img_.copyTo(img);\n\n    // release the memory\n    img_.release();\n\n    return hasRead;\n}\n\nbool GifDecoder::nextPage() {\n    if (hasRead) {\n        hasRead = false;\n        // end of a gif file\n        if(!(m_strm.getByte() ^ 0x3B)) return false;\n        m_strm.setPos(m_strm.getPos() - 1);\n        return true;\n    } else {\n        bool success;\n        try {\n            Mat emptyImg;\n            success = readData(emptyImg);\n            emptyImg.release();\n        } catch(...) {\n            return false;\n        }\n        return success;\n    }\n}\n\nvoid GifDecoder::readExtensions() {\n    uchar len;\n    while (!(m_strm.getByte() ^ 0x21)) {\n        uchar extensionType = (uchar)m_strm.getByte();\n\n        // read graphic control extension\n        // the scope of this extension is the next image or plain text extension\n        hasTransparentColor = false;\n        opMode = GifOpMode::GRFMT_GIF_Nothing;// default value\n        if (!(extensionType ^ 0xF9)) {\n            len = (uchar)m_strm.getByte();\n            CV_Assert(len == 4);\n            uchar flags = (uchar)m_strm.getByte();\n            m_strm.getWord(); // delay time, not used\n            opMode = (GifOpMode)((flags & 0x1C) >> 2);\n            hasTransparentColor = flags & 0x01;\n            transparentColor = (uchar)m_strm.getByte();\n        }\n\n        // skip other kinds of extensions\n        len = (uchar)m_strm.getByte();\n        while (len) {\n            m_strm.skip(len);\n            len = (uchar)m_strm.getByte();\n        }\n    }\n    // roll back to the block identifier\n    m_strm.setPos(m_strm.getPos() - 1);\n}\n\nvoid GifDecoder::code2pixel(Mat& img, int start, int k){\n    for (int i = start; i < height; i+=k) {\n        for (int j = 0; j < width; j++) {\n            int idx = i * width + j;\n            int colorIdx = currentImageCodeStream[idx];\n            if (hasTransparentColor && colorIdx == transparentColor) {\n                continue;\n            }\n            if (colorIdx < localColorTableSize) {\n                img.at<Vec3b>(top + i, left + j)[0] = localColorTable[colorIdx * 3 + 2]; //B\n                img.at<Vec3b>(top + i, left + j)[1] = localColorTable[colorIdx * 3 + 1]; //G\n                img.at<Vec3b>(top + i, left + j)[2] = localColorTable[colorIdx * 3];     //R\n            } else if (colorIdx < globalColorTableSize) {\n                img.at<Vec3b>(top + i, left + j)[0] = globalColorTable[colorIdx * 3 + 2]; //B\n                img.at<Vec3b>(top + i, left + j)[1] = globalColorTable[colorIdx * 3 + 1]; //G\n                img.at<Vec3b>(top + i, left + j)[2] = globalColorTable[colorIdx * 3];     //R\n            } else {\n                CV_Assert(false);\n            }\n        }\n    }\n}\n\nvoid GifDecoder::deleteLzwExtraTablePrefix(lzwNodeD* lzwExtraTable, int lzwTableSize) const{\n    for (int i = (1 << lzwMinCodeSize) + 2; i <= lzwTableSize; i++) {\n        if (lzwExtraTable[i].prefix) {\n            delete[] lzwExtraTable[i].prefix;\n            lzwExtraTable[i].prefix = nullptr;\n        }\n    }\n}\n\nbool GifDecoder::lzwDecode() {\n    // initialization\n    lzwMinCodeSize = m_strm.getByte();\n    int lzwCodeSize = lzwMinCodeSize + 1;\n    int clearCode = 1 << lzwMinCodeSize;\n    int exitCode = clearCode + 1;\n    CV_Assert(lzwCodeSize > 2 && lzwCodeSize <= 12);\n    auto* lzwExtraTable = new lzwNodeD[(1 << 12) + 1];",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1632891724",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25691,
        "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
        "discussion_id": "1632891724",
        "commented_code": "@@ -0,0 +1,372 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level\n+// directory of this distribution and at http://opencv.org/license.html\n+\n+#include \"precomp.hpp\"\n+#include \"grfmt_gif.hpp\"\n+\n+namespace cv\n+{\n+//////////////////////////////////////////////////////////////////////\n+////                        GIF Decoder                           ////\n+//////////////////////////////////////////////////////////////////////\n+GifDecoder::GifDecoder() {\n+    m_signature = R\"(GIF)\";\n+    m_type = CV_8UC3;\n+    bgColor = -1;\n+    m_buf_supported = true;\n+    globalColorTableSize = 0;\n+    localColorTableSize = 0;\n+    lzwMinCodeSize = 0;\n+    hasRead = false;\n+    hasTransparentColor = false;\n+    transparentColor = 0;\n+    opMode = GRFMT_GIF_Nothing;\n+    top = 0, left = 0, width = 0, height = 0;\n+    depth = 8;\n+}\n+\n+GifDecoder::~GifDecoder() {\n+    close();\n+}\n+\n+bool GifDecoder::readHeader() {\n+    if (!m_buf.empty()) {\n+        if (!m_strm.open(m_buf)) {\n+            return false;\n+        }\n+    } else if (!m_strm.open(m_filename)) {\n+        return false;\n+    }\n+\n+    try {\n+        m_strm.skip(6);// Skip the signature: GIF87a or GIF89a\n+\n+        // #1: read logical screen descriptor\n+        m_width = m_strm.getWord();\n+        m_height = m_strm.getWord();\n+        CV_Assert(m_width > 0 && m_height > 0);\n+\n+        char flags = (char)m_strm.getByte();\n+\n+        // the background color -> index in the global color table, valid only if the global color table is present\n+        bgColor = m_strm.getByte();\n+        m_strm.skip(1); // Skip the aspect ratio\n+\n+        // #2: read global color table\n+        depth = ((flags & 0x70) >> 4) + 1;\n+        if (flags & 0x80) {\n+            globalColorTableSize = 1 << ((flags & 0x07) + 1);\n+            globalColorTable.allocate(3 * globalColorTableSize);\n+            for (int i = 0; i < 3 * globalColorTableSize; i++) {\n+                globalColorTable[i] = (uchar)m_strm.getByte();\n+            }\n+        }\n+    } catch (...) {\n+        throw;\n+    }\n+\n+    hasRead = false;\n+    return true;\n+}\n+\n+bool GifDecoder::readData(Mat &img) {\n+    if (hasRead) {\n+        lastImage.copyTo(img);\n+        return true;\n+    }\n+\n+    readExtensions();\n+    // Image separator\n+    CV_Assert(!(m_strm.getByte()^0x2C));\n+    left = m_strm.getWord();\n+    top = m_strm.getWord();\n+    width = m_strm.getWord();\n+    height = m_strm.getWord();\n+    CV_Assert(width > 0 && height > 0 && left + width <= m_width && top + height <= m_height);\n+\n+    currentImageCodeStream.allocate(width * height);\n+    Mat img_;\n+\n+    switch (opMode) {\n+        case GifOpMode::GRFMT_GIF_PreviousImage:\n+            if (lastImage.empty()){\n+                img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n+            } else {\n+                img_ = lastImage;\n+            }\n+            break;\n+        case GifOpMode::GRFMT_GIF_Background:\n+            // background color is valid iff global color table exists\n+            CV_Assert(globalColorTableSize > 0);\n+            img_ = Mat(m_height, m_width, CV_8UC3,\n+                       Scalar(globalColorTable[bgColor * 3 + 2],\n+                              globalColorTable[bgColor * 3 + 1],\n+                              globalColorTable[bgColor * 3]));\n+            break;\n+        case GifOpMode::GRFMT_GIF_Nothing:\n+        case GifOpMode::GRFMT_GIF_Cover:\n+            // default value\n+            img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n+            break;\n+        default:\n+            CV_Assert(false);\n+    }\n+    lastImage.release();\n+\n+    auto flags = (uchar)m_strm.getByte();\n+    localColorTableSize = 0;\n+    if (flags & 0x80) {\n+        // local color table\n+        localColorTableSize = 1 << ((flags & 0x07) + 1);\n+        localColorTable.allocate(3 * localColorTableSize);\n+        for (int i = 0; i < 3 * localColorTableSize; i++) {\n+            localColorTable[i] = (uchar)m_strm.getByte();\n+        }\n+    }\n+\n+    // the case that neither global nor local color table exists is not defined in the GIF standard (but allowed)\n+    if (!(globalColorTableSize || localColorTableSize)) {\n+        // go through the length of unused data.\n+        m_strm.skip(1);\n+        int len = m_strm.getByte();\n+        while (len) {\n+            m_strm.skip(len);\n+            len = m_strm.getByte();\n+        }\n+\n+        lastImage = img_;\n+        if (!img.empty())\n+            img_.copyTo(img);\n+\n+        // release the memory\n+        img_.release();\n+        return true;\n+    }\n+\n+    // lzw decompression to get the code stream\n+    hasRead = lzwDecode();\n+\n+    // convert code stream into pixels on the image\n+    if (hasRead) {\n+        if (!(flags & 0x40)) {\n+            // no interlace, simply convert the code stream into pixels from top to down\n+            code2pixel(img_, 0, 1);\n+        } else {\n+            // consider the interlace mode, the image will be rendered in four separate passes\n+            code2pixel(img_, 0, 8);\n+            code2pixel(img_, 4, 8);\n+            code2pixel(img_, 2, 4);\n+            code2pixel(img_, 1, 2);\n+        }\n+    }\n+\n+    lastImage = img_;\n+    if (!img.empty())\n+        img_.copyTo(img);\n+\n+    // release the memory\n+    img_.release();\n+\n+    return hasRead;\n+}\n+\n+bool GifDecoder::nextPage() {\n+    if (hasRead) {\n+        hasRead = false;\n+        // end of a gif file\n+        if(!(m_strm.getByte() ^ 0x3B)) return false;\n+        m_strm.setPos(m_strm.getPos() - 1);\n+        return true;\n+    } else {\n+        bool success;\n+        try {\n+            Mat emptyImg;\n+            success = readData(emptyImg);\n+            emptyImg.release();\n+        } catch(...) {\n+            return false;\n+        }\n+        return success;\n+    }\n+}\n+\n+void GifDecoder::readExtensions() {\n+    uchar len;\n+    while (!(m_strm.getByte() ^ 0x21)) {\n+        uchar extensionType = (uchar)m_strm.getByte();\n+\n+        // read graphic control extension\n+        // the scope of this extension is the next image or plain text extension\n+        hasTransparentColor = false;\n+        opMode = GifOpMode::GRFMT_GIF_Nothing;// default value\n+        if (!(extensionType ^ 0xF9)) {\n+            len = (uchar)m_strm.getByte();\n+            CV_Assert(len == 4);\n+            uchar flags = (uchar)m_strm.getByte();\n+            m_strm.getWord(); // delay time, not used\n+            opMode = (GifOpMode)((flags & 0x1C) >> 2);\n+            hasTransparentColor = flags & 0x01;\n+            transparentColor = (uchar)m_strm.getByte();\n+        }\n+\n+        // skip other kinds of extensions\n+        len = (uchar)m_strm.getByte();\n+        while (len) {\n+            m_strm.skip(len);\n+            len = (uchar)m_strm.getByte();\n+        }\n+    }\n+    // roll back to the block identifier\n+    m_strm.setPos(m_strm.getPos() - 1);\n+}\n+\n+void GifDecoder::code2pixel(Mat& img, int start, int k){\n+    for (int i = start; i < height; i+=k) {\n+        for (int j = 0; j < width; j++) {\n+            int idx = i * width + j;\n+            int colorIdx = currentImageCodeStream[idx];\n+            if (hasTransparentColor && colorIdx == transparentColor) {\n+                continue;\n+            }\n+            if (colorIdx < localColorTableSize) {\n+                img.at<Vec3b>(top + i, left + j)[0] = localColorTable[colorIdx * 3 + 2]; //B\n+                img.at<Vec3b>(top + i, left + j)[1] = localColorTable[colorIdx * 3 + 1]; //G\n+                img.at<Vec3b>(top + i, left + j)[2] = localColorTable[colorIdx * 3];     //R\n+            } else if (colorIdx < globalColorTableSize) {\n+                img.at<Vec3b>(top + i, left + j)[0] = globalColorTable[colorIdx * 3 + 2]; //B\n+                img.at<Vec3b>(top + i, left + j)[1] = globalColorTable[colorIdx * 3 + 1]; //G\n+                img.at<Vec3b>(top + i, left + j)[2] = globalColorTable[colorIdx * 3];     //R\n+            } else {\n+                CV_Assert(false);\n+            }\n+        }\n+    }\n+}\n+\n+void GifDecoder::deleteLzwExtraTablePrefix(lzwNodeD* lzwExtraTable, int lzwTableSize) const{\n+    for (int i = (1 << lzwMinCodeSize) + 2; i <= lzwTableSize; i++) {\n+        if (lzwExtraTable[i].prefix) {\n+            delete[] lzwExtraTable[i].prefix;\n+            lzwExtraTable[i].prefix = nullptr;\n+        }\n+    }\n+}\n+\n+bool GifDecoder::lzwDecode() {\n+    // initialization\n+    lzwMinCodeSize = m_strm.getByte();\n+    int lzwCodeSize = lzwMinCodeSize + 1;\n+    int clearCode = 1 << lzwMinCodeSize;\n+    int exitCode = clearCode + 1;\n+    CV_Assert(lzwCodeSize > 2 && lzwCodeSize <= 12);\n+    auto* lzwExtraTable = new lzwNodeD[(1 << 12) + 1];",
        "comment_created_at": "2024-06-10T09:10:33+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "please use std::vector, std::array or cv::AutoBuffer to prevent memory leaks in cases of parser failrue.",
        "pr_file_module": null
      },
      {
        "comment_id": "1655702685",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25691,
        "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
        "discussion_id": "1632891724",
        "commented_code": "@@ -0,0 +1,372 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level\n+// directory of this distribution and at http://opencv.org/license.html\n+\n+#include \"precomp.hpp\"\n+#include \"grfmt_gif.hpp\"\n+\n+namespace cv\n+{\n+//////////////////////////////////////////////////////////////////////\n+////                        GIF Decoder                           ////\n+//////////////////////////////////////////////////////////////////////\n+GifDecoder::GifDecoder() {\n+    m_signature = R\"(GIF)\";\n+    m_type = CV_8UC3;\n+    bgColor = -1;\n+    m_buf_supported = true;\n+    globalColorTableSize = 0;\n+    localColorTableSize = 0;\n+    lzwMinCodeSize = 0;\n+    hasRead = false;\n+    hasTransparentColor = false;\n+    transparentColor = 0;\n+    opMode = GRFMT_GIF_Nothing;\n+    top = 0, left = 0, width = 0, height = 0;\n+    depth = 8;\n+}\n+\n+GifDecoder::~GifDecoder() {\n+    close();\n+}\n+\n+bool GifDecoder::readHeader() {\n+    if (!m_buf.empty()) {\n+        if (!m_strm.open(m_buf)) {\n+            return false;\n+        }\n+    } else if (!m_strm.open(m_filename)) {\n+        return false;\n+    }\n+\n+    try {\n+        m_strm.skip(6);// Skip the signature: GIF87a or GIF89a\n+\n+        // #1: read logical screen descriptor\n+        m_width = m_strm.getWord();\n+        m_height = m_strm.getWord();\n+        CV_Assert(m_width > 0 && m_height > 0);\n+\n+        char flags = (char)m_strm.getByte();\n+\n+        // the background color -> index in the global color table, valid only if the global color table is present\n+        bgColor = m_strm.getByte();\n+        m_strm.skip(1); // Skip the aspect ratio\n+\n+        // #2: read global color table\n+        depth = ((flags & 0x70) >> 4) + 1;\n+        if (flags & 0x80) {\n+            globalColorTableSize = 1 << ((flags & 0x07) + 1);\n+            globalColorTable.allocate(3 * globalColorTableSize);\n+            for (int i = 0; i < 3 * globalColorTableSize; i++) {\n+                globalColorTable[i] = (uchar)m_strm.getByte();\n+            }\n+        }\n+    } catch (...) {\n+        throw;\n+    }\n+\n+    hasRead = false;\n+    return true;\n+}\n+\n+bool GifDecoder::readData(Mat &img) {\n+    if (hasRead) {\n+        lastImage.copyTo(img);\n+        return true;\n+    }\n+\n+    readExtensions();\n+    // Image separator\n+    CV_Assert(!(m_strm.getByte()^0x2C));\n+    left = m_strm.getWord();\n+    top = m_strm.getWord();\n+    width = m_strm.getWord();\n+    height = m_strm.getWord();\n+    CV_Assert(width > 0 && height > 0 && left + width <= m_width && top + height <= m_height);\n+\n+    currentImageCodeStream.allocate(width * height);\n+    Mat img_;\n+\n+    switch (opMode) {\n+        case GifOpMode::GRFMT_GIF_PreviousImage:\n+            if (lastImage.empty()){\n+                img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n+            } else {\n+                img_ = lastImage;\n+            }\n+            break;\n+        case GifOpMode::GRFMT_GIF_Background:\n+            // background color is valid iff global color table exists\n+            CV_Assert(globalColorTableSize > 0);\n+            img_ = Mat(m_height, m_width, CV_8UC3,\n+                       Scalar(globalColorTable[bgColor * 3 + 2],\n+                              globalColorTable[bgColor * 3 + 1],\n+                              globalColorTable[bgColor * 3]));\n+            break;\n+        case GifOpMode::GRFMT_GIF_Nothing:\n+        case GifOpMode::GRFMT_GIF_Cover:\n+            // default value\n+            img_ = Mat(m_height, m_width, CV_8UC3, Scalar(0, 0, 0));\n+            break;\n+        default:\n+            CV_Assert(false);\n+    }\n+    lastImage.release();\n+\n+    auto flags = (uchar)m_strm.getByte();\n+    localColorTableSize = 0;\n+    if (flags & 0x80) {\n+        // local color table\n+        localColorTableSize = 1 << ((flags & 0x07) + 1);\n+        localColorTable.allocate(3 * localColorTableSize);\n+        for (int i = 0; i < 3 * localColorTableSize; i++) {\n+            localColorTable[i] = (uchar)m_strm.getByte();\n+        }\n+    }\n+\n+    // the case that neither global nor local color table exists is not defined in the GIF standard (but allowed)\n+    if (!(globalColorTableSize || localColorTableSize)) {\n+        // go through the length of unused data.\n+        m_strm.skip(1);\n+        int len = m_strm.getByte();\n+        while (len) {\n+            m_strm.skip(len);\n+            len = m_strm.getByte();\n+        }\n+\n+        lastImage = img_;\n+        if (!img.empty())\n+            img_.copyTo(img);\n+\n+        // release the memory\n+        img_.release();\n+        return true;\n+    }\n+\n+    // lzw decompression to get the code stream\n+    hasRead = lzwDecode();\n+\n+    // convert code stream into pixels on the image\n+    if (hasRead) {\n+        if (!(flags & 0x40)) {\n+            // no interlace, simply convert the code stream into pixels from top to down\n+            code2pixel(img_, 0, 1);\n+        } else {\n+            // consider the interlace mode, the image will be rendered in four separate passes\n+            code2pixel(img_, 0, 8);\n+            code2pixel(img_, 4, 8);\n+            code2pixel(img_, 2, 4);\n+            code2pixel(img_, 1, 2);\n+        }\n+    }\n+\n+    lastImage = img_;\n+    if (!img.empty())\n+        img_.copyTo(img);\n+\n+    // release the memory\n+    img_.release();\n+\n+    return hasRead;\n+}\n+\n+bool GifDecoder::nextPage() {\n+    if (hasRead) {\n+        hasRead = false;\n+        // end of a gif file\n+        if(!(m_strm.getByte() ^ 0x3B)) return false;\n+        m_strm.setPos(m_strm.getPos() - 1);\n+        return true;\n+    } else {\n+        bool success;\n+        try {\n+            Mat emptyImg;\n+            success = readData(emptyImg);\n+            emptyImg.release();\n+        } catch(...) {\n+            return false;\n+        }\n+        return success;\n+    }\n+}\n+\n+void GifDecoder::readExtensions() {\n+    uchar len;\n+    while (!(m_strm.getByte() ^ 0x21)) {\n+        uchar extensionType = (uchar)m_strm.getByte();\n+\n+        // read graphic control extension\n+        // the scope of this extension is the next image or plain text extension\n+        hasTransparentColor = false;\n+        opMode = GifOpMode::GRFMT_GIF_Nothing;// default value\n+        if (!(extensionType ^ 0xF9)) {\n+            len = (uchar)m_strm.getByte();\n+            CV_Assert(len == 4);\n+            uchar flags = (uchar)m_strm.getByte();\n+            m_strm.getWord(); // delay time, not used\n+            opMode = (GifOpMode)((flags & 0x1C) >> 2);\n+            hasTransparentColor = flags & 0x01;\n+            transparentColor = (uchar)m_strm.getByte();\n+        }\n+\n+        // skip other kinds of extensions\n+        len = (uchar)m_strm.getByte();\n+        while (len) {\n+            m_strm.skip(len);\n+            len = (uchar)m_strm.getByte();\n+        }\n+    }\n+    // roll back to the block identifier\n+    m_strm.setPos(m_strm.getPos() - 1);\n+}\n+\n+void GifDecoder::code2pixel(Mat& img, int start, int k){\n+    for (int i = start; i < height; i+=k) {\n+        for (int j = 0; j < width; j++) {\n+            int idx = i * width + j;\n+            int colorIdx = currentImageCodeStream[idx];\n+            if (hasTransparentColor && colorIdx == transparentColor) {\n+                continue;\n+            }\n+            if (colorIdx < localColorTableSize) {\n+                img.at<Vec3b>(top + i, left + j)[0] = localColorTable[colorIdx * 3 + 2]; //B\n+                img.at<Vec3b>(top + i, left + j)[1] = localColorTable[colorIdx * 3 + 1]; //G\n+                img.at<Vec3b>(top + i, left + j)[2] = localColorTable[colorIdx * 3];     //R\n+            } else if (colorIdx < globalColorTableSize) {\n+                img.at<Vec3b>(top + i, left + j)[0] = globalColorTable[colorIdx * 3 + 2]; //B\n+                img.at<Vec3b>(top + i, left + j)[1] = globalColorTable[colorIdx * 3 + 1]; //G\n+                img.at<Vec3b>(top + i, left + j)[2] = globalColorTable[colorIdx * 3];     //R\n+            } else {\n+                CV_Assert(false);\n+            }\n+        }\n+    }\n+}\n+\n+void GifDecoder::deleteLzwExtraTablePrefix(lzwNodeD* lzwExtraTable, int lzwTableSize) const{\n+    for (int i = (1 << lzwMinCodeSize) + 2; i <= lzwTableSize; i++) {\n+        if (lzwExtraTable[i].prefix) {\n+            delete[] lzwExtraTable[i].prefix;\n+            lzwExtraTable[i].prefix = nullptr;\n+        }\n+    }\n+}\n+\n+bool GifDecoder::lzwDecode() {\n+    // initialization\n+    lzwMinCodeSize = m_strm.getByte();\n+    int lzwCodeSize = lzwMinCodeSize + 1;\n+    int clearCode = 1 << lzwMinCodeSize;\n+    int exitCode = clearCode + 1;\n+    CV_Assert(lzwCodeSize > 2 && lzwCodeSize <= 12);\n+    auto* lzwExtraTable = new lzwNodeD[(1 << 12) + 1];",
        "comment_created_at": "2024-06-27T01:26:45+00:00",
        "comment_author": "redhecker",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1798939112",
    "pr_number": 26281,
    "pr_file": "modules/core/src/opengl.cpp",
    "created_at": "2024-10-14T07:57:17+00:00",
    "commented_code": "#elif !defined(HAVE_OPENCL_OPENGL_SHARING)\n    NO_OPENCL_SHARING_ERROR;\n#else\n    cl_uint numPlatforms;\n    cl_int status = clGetPlatformIDs(0, NULL, &numPlatforms);\n    cl_uint platformsCnt = 0;\n    cl_uint devCnt = 0;\n    cl_device_id* devices = nullptr;\n    cl_uint devUsed = 0;\n    cl_context context = nullptr;\n\n    cl_int status = clGetPlatformIDs(0, NULL, &platformsCnt);\n    if (status != CL_SUCCESS)\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n    if (numPlatforms == 0)\n    if (platformsCnt == 0)\n        CV_Error(cv::Error::OpenCLInitError, \"OpenCL: No available platforms\");\n\n    std::vector<cl_platform_id> platforms(numPlatforms);\n    status = clGetPlatformIDs(numPlatforms, &platforms[0], NULL);\n    std::vector<cl_platform_id> platforms(platformsCnt);\n    status = clGetPlatformIDs(platformsCnt, &platforms[0], NULL);\n    if (status != CL_SUCCESS)\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platforms: %d\", status));\n\n\n    // TODO Filter platforms by name from OPENCV_OPENCL_DEVICE\n    bool sharingSupported = false;\n\n    int found = -1;\n    cl_device_id device = NULL;\n    cl_context context = NULL;\n    for (unsigned int i = 0; (!sharingSupported && (i < platformsCnt)); ++i) {\n        status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 0, NULL, &devCnt);\n        if (status != CL_SUCCESS)\n            CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n\n    for (int i = 0; i < (int)numPlatforms; i++)\n    {\n        // query platform extension: presence of \"cl_khr_gl_sharing\" extension is required\n        {\n            AutoBuffer<char> extensionStr;\n        try {\n            devices = new cl_device_id[devCnt];",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1798939112",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26281,
        "pr_file": "modules/core/src/opengl.cpp",
        "discussion_id": "1798939112",
        "commented_code": "@@ -1635,94 +1641,148 @@ Context& initializeContextFromGL()\n #elif !defined(HAVE_OPENCL_OPENGL_SHARING)\n     NO_OPENCL_SHARING_ERROR;\n #else\n-    cl_uint numPlatforms;\n-    cl_int status = clGetPlatformIDs(0, NULL, &numPlatforms);\n+    cl_uint platformsCnt = 0;\n+    cl_uint devCnt = 0;\n+    cl_device_id* devices = nullptr;\n+    cl_uint devUsed = 0;\n+    cl_context context = nullptr;\n+\n+    cl_int status = clGetPlatformIDs(0, NULL, &platformsCnt);\n     if (status != CL_SUCCESS)\n         CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n-    if (numPlatforms == 0)\n+    if (platformsCnt == 0)\n         CV_Error(cv::Error::OpenCLInitError, \"OpenCL: No available platforms\");\n \n-    std::vector<cl_platform_id> platforms(numPlatforms);\n-    status = clGetPlatformIDs(numPlatforms, &platforms[0], NULL);\n+    std::vector<cl_platform_id> platforms(platformsCnt);\n+    status = clGetPlatformIDs(platformsCnt, &platforms[0], NULL);\n     if (status != CL_SUCCESS)\n-        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get number of platforms: %d\", status));\n+        CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: Can't get platforms: %d\", status));\n+\n \n     // TODO Filter platforms by name from OPENCV_OPENCL_DEVICE\n+    bool sharingSupported = false;\n \n-    int found = -1;\n-    cl_device_id device = NULL;\n-    cl_context context = NULL;\n+    for (unsigned int i = 0; (!sharingSupported && (i < platformsCnt)); ++i) {\n+        status = clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, 0, NULL, &devCnt);\n+        if (status != CL_SUCCESS)\n+            CV_Error_(cv::Error::OpenCLInitError, (\"OpenCL: No devices available: %d\", status));\n \n-    for (int i = 0; i < (int)numPlatforms; i++)\n-    {\n-        // query platform extension: presence of \"cl_khr_gl_sharing\" extension is required\n-        {\n-            AutoBuffer<char> extensionStr;\n+        try {\n+            devices = new cl_device_id[devCnt];",
        "comment_created_at": "2024-10-14T07:57:17+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Let's use `std::vector<>` or `cv::AutoBuffer` for locals to prevent leaks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1658732501",
    "pr_number": 25715,
    "pr_file": "modules/imgcodecs/src/grfmt_png.cpp",
    "created_at": "2024-06-28T13:18:04+00:00",
    "commented_code": "return result;\n}\n\nbool PngDecoder::nextPage() {\n    if (m_f)\n    {\n        uint id;\n        CHUNK chunkfcTL;\n\n        id = read_chunk(m_f, &chunkfcTL);\n        if (id == id_fcTL && chunkfcTL.size == 38)\n        {\n            // At this point the old frame is done. Let's start a new one.\n            uint w0 = png_get_uint_32(chunkfcTL.p + 12);\n            uint h0 = png_get_uint_32(chunkfcTL.p + 16);\n            uint x0 = png_get_uint_32(chunkfcTL.p + 20);\n            uint y0 = png_get_uint_32(chunkfcTL.p + 24);\n            int delay_num = png_get_uint_16(chunkfcTL.p + 28);\n            int delay_den = png_get_uint_16(chunkfcTL.p + 30);\n            char dop = chunkfcTL.p[32];\n            char bop = chunkfcTL.p[33];\n            printf(\"**frame props\\n-------------------\\n\");\n            printf(\"w0 : %d\\n\", w0);\n            printf(\"h0 : %d\\n\", h0);\n            printf(\"x0 : %d\\n\", x0);\n            printf(\"y0 : %d\\n\", y0);\n            printf(\"delay_num : %d\\n\", delay_num);\n            printf(\"delay_den : %d\\n\", delay_den);\n            printf(\"dop : %d\\n\", dop);\n            printf(\"bop : %d\\n-------------------\\n\", bop);\n\n            uchar sig[8];\n            if (fread(sig, 1, 8, m_f))\n                return true;\n        }\n    }\n    return false;\n}\n\nvoid PngDecoder::compose_frame(uchar** rows_dst, uchar** rows_src, uchar bop, uint x, uint y, uint w, uint h)\n{\n    uint  i, j;\n    int u, v, al;\n\n    for (j = 0; j < h; j++)\n    {\n        uchar* sp = rows_src[j];\n        uchar* dp = rows_dst[j + y] + x * 4;\n\n        if (bop == 0)\n            memcpy(dp, sp, w * 4);\n        else\n            for (i = 0; i < w; i++, sp += 4, dp += 4)\n            {\n                if (sp[3] == 255)\n                    memcpy(dp, sp, 4);\n                else\n                    if (sp[3] != 0)\n                    {\n                        if (dp[3] != 0)\n                        {\n                            u = sp[3] * 255;\n                            v = (255 - sp[3]) * dp[3];\n                            al = u + v;\n                            dp[0] = (sp[0] * u + dp[0] * v) / al;\n                            dp[1] = (sp[1] * u + dp[1] * v) / al;\n                            dp[2] = (sp[2] * u + dp[2] * v) / al;\n                            dp[3] = al / 255;\n                        }\n                        else\n                            memcpy(dp, sp, 4);\n                    }\n            }\n    }\n}\n\nuint PngDecoder::read_chunk(FILE* f, CHUNK* pChunk)\n{\n    uchar len[4];\n    pChunk->size = 0;\n    pChunk->p = 0;\n    if (fread(&len, 4, 1, f) == 1)\n    {\n        pChunk->size = png_get_uint_32(len);\n        if (pChunk->size > PNG_USER_CHUNK_MALLOC_MAX)\n            return 0;\n        pChunk->size += 12;\n        pChunk->p = new uchar[pChunk->size];",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1658732501",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25715,
        "pr_file": "modules/imgcodecs/src/grfmt_png.cpp",
        "discussion_id": "1658732501",
        "commented_code": "@@ -300,6 +403,379 @@ bool  PngDecoder::readData( Mat& img )\n     return result;\n }\n \n+bool PngDecoder::nextPage() {\n+    if (m_f)\n+    {\n+        uint id;\n+        CHUNK chunkfcTL;\n+\n+        id = read_chunk(m_f, &chunkfcTL);\n+        if (id == id_fcTL && chunkfcTL.size == 38)\n+        {\n+            // At this point the old frame is done. Let's start a new one.\n+            uint w0 = png_get_uint_32(chunkfcTL.p + 12);\n+            uint h0 = png_get_uint_32(chunkfcTL.p + 16);\n+            uint x0 = png_get_uint_32(chunkfcTL.p + 20);\n+            uint y0 = png_get_uint_32(chunkfcTL.p + 24);\n+            int delay_num = png_get_uint_16(chunkfcTL.p + 28);\n+            int delay_den = png_get_uint_16(chunkfcTL.p + 30);\n+            char dop = chunkfcTL.p[32];\n+            char bop = chunkfcTL.p[33];\n+            printf(\"**frame props\\n-------------------\\n\");\n+            printf(\"w0 : %d\\n\", w0);\n+            printf(\"h0 : %d\\n\", h0);\n+            printf(\"x0 : %d\\n\", x0);\n+            printf(\"y0 : %d\\n\", y0);\n+            printf(\"delay_num : %d\\n\", delay_num);\n+            printf(\"delay_den : %d\\n\", delay_den);\n+            printf(\"dop : %d\\n\", dop);\n+            printf(\"bop : %d\\n-------------------\\n\", bop);\n+\n+            uchar sig[8];\n+            if (fread(sig, 1, 8, m_f))\n+                return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+void PngDecoder::compose_frame(uchar** rows_dst, uchar** rows_src, uchar bop, uint x, uint y, uint w, uint h)\n+{\n+    uint  i, j;\n+    int u, v, al;\n+\n+    for (j = 0; j < h; j++)\n+    {\n+        uchar* sp = rows_src[j];\n+        uchar* dp = rows_dst[j + y] + x * 4;\n+\n+        if (bop == 0)\n+            memcpy(dp, sp, w * 4);\n+        else\n+            for (i = 0; i < w; i++, sp += 4, dp += 4)\n+            {\n+                if (sp[3] == 255)\n+                    memcpy(dp, sp, 4);\n+                else\n+                    if (sp[3] != 0)\n+                    {\n+                        if (dp[3] != 0)\n+                        {\n+                            u = sp[3] * 255;\n+                            v = (255 - sp[3]) * dp[3];\n+                            al = u + v;\n+                            dp[0] = (sp[0] * u + dp[0] * v) / al;\n+                            dp[1] = (sp[1] * u + dp[1] * v) / al;\n+                            dp[2] = (sp[2] * u + dp[2] * v) / al;\n+                            dp[3] = al / 255;\n+                        }\n+                        else\n+                            memcpy(dp, sp, 4);\n+                    }\n+            }\n+    }\n+}\n+\n+uint PngDecoder::read_chunk(FILE* f, CHUNK* pChunk)\n+{\n+    uchar len[4];\n+    pChunk->size = 0;\n+    pChunk->p = 0;\n+    if (fread(&len, 4, 1, f) == 1)\n+    {\n+        pChunk->size = png_get_uint_32(len);\n+        if (pChunk->size > PNG_USER_CHUNK_MALLOC_MAX)\n+            return 0;\n+        pChunk->size += 12;\n+        pChunk->p = new uchar[pChunk->size];",
        "comment_created_at": "2024-06-28T13:18:04+00:00",
        "comment_author": "vrabaud",
        "comment_body": "Please do not use new as it makes its hard to track memory. Use std::vector<char> if you can.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1894579735",
    "pr_number": 25715,
    "pr_file": "modules/imgcodecs/src/grfmt_png.cpp",
    "created_at": "2024-12-21T07:44:06+00:00",
    "commented_code": "return result;\n}\n\nvoid PngEncoder::optim_dirty(std::vector<APNGFrame>& frames)\n{\n    uint32_t i, j;\n    unsigned char* sp;\n    uint32_t size = frames[0].getWidth() * frames[0].getHeight();\n\n    for (i = 0; i < frames.size(); i++)\n    {\n        sp = frames[i].getPixels();\n        for (j = 0; j < size; j++, sp += 4)\n            if (sp[3] == 0)\n                sp[0] = sp[1] = sp[2] = 0;\n    }\n}\n\nvoid PngEncoder::optim_duplicates(std::vector<APNGFrame>& frames, uint32_t first)\n{\n    uint32_t imagesize = frames[0].getWidth() * frames[0].getHeight() * 4;\n    uint32_t i = first;\n\n    while (++i < frames.size())\n    {\n        if (memcmp(frames[i - 1].getPixels(), frames[i].getPixels(), imagesize) != 0)\n            continue;\n\n        i--;\n        delete[] frames[i].getPixels();\n        delete[] frames[i].getRows();\n        uint32_t num = frames[i].getDelayNum();\n        uint32_t den = frames[i].getDelayDen();\n        frames.erase(frames.begin() + i);\n\n        if (frames[i].getDelayDen() == den)\n            frames[i].setDelayNum(frames[i].getDelayNum()+num);\n        else\n        {\n            frames[i].setDelayNum(num * frames[i].getDelayDen() + den * frames[i].getDelayNum());\n            frames[i].setDelayDen(den * frames[i].getDelayDen());\n            while (num && den)\n            {\n                if (num > den)\n                    num = num % den;\n                else\n                    den = den % num;\n            }\n            num += den;\n            frames[i].setDelayNum(frames[i].getDelayNum() / num);\n            frames[i].setDelayDen(frames[i].getDelayDen() / num);\n        }\n    }\n}\n\nsize_t PngEncoder::write_to_io(void const* _Buffer, size_t  _ElementSize, size_t _ElementCount, FILE * _Stream)\n{\n    if (_Stream)\n        return fwrite(_Buffer, _ElementSize, _ElementCount, _Stream);\n\n    size_t cursz = m_buf->size();\n    m_buf->resize(cursz + _ElementCount);\n    memcpy( &(*m_buf)[cursz], _Buffer, _ElementCount );\n    return _ElementCount;\n}\n\nvoid PngEncoder::write_chunk(FILE* f, const char* name, unsigned char* data, uint32_t length)\n{\n    unsigned char buf[4];\n    uint32_t crc = crc32(0, Z_NULL, 0);\n\n    png_save_uint_32(buf, length);\n    write_to_io(buf, 1, 4, f);\n    write_to_io(name, 1, 4, f);\n    crc = crc32(crc, (const Bytef*)name, 4);\n\n    if (memcmp(name, \"fdAT\", 4) == 0)\n    {\n        png_save_uint_32(buf, next_seq_num++);\n        write_to_io(buf, 1, 4, f);\n        crc = crc32(crc, buf, 4);\n        length -= 4;\n    }\n\n    if (data != NULL && length > 0)\n    {\n        write_to_io(data, 1, length, f);\n        crc = crc32(crc, data, length);\n    }\n\n    png_save_uint_32(buf, crc);\n    write_to_io(buf, 1, 4, f);\n}\n\nvoid PngEncoder::write_IDATs(FILE* f, int frame, unsigned char* data, uint32_t length, uint32_t idat_size)\n{\n    uint32_t z_cmf = data[0];\n    if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)\n    {\n        if (length >= 2)\n        {\n            uint32_t z_cinfo = z_cmf >> 4;\n            uint32_t half_z_window_size = 1 << (z_cinfo + 7);\n            while (idat_size <= half_z_window_size && half_z_window_size >= 256)\n            {\n                z_cinfo--;\n                half_z_window_size >>= 1;\n            }\n            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);\n            if (data[0] != (unsigned char)z_cmf)\n            {\n                data[0] = (unsigned char)z_cmf;\n                data[1] &= 0xe0;\n                data[1] += (unsigned char)(0x1f - ((z_cmf << 8) + data[1]) % 0x1f);\n            }\n        }\n    }\n\n    while (length > 0)\n    {\n        uint32_t ds = length;\n        if (ds > 32768)\n            ds = 32768;\n\n        if (frame == 0)\n            write_chunk(f, \"IDAT\", data, ds);\n        else\n            write_chunk(f, \"fdAT\", data, ds + 4);\n\n        data += ds;\n        length -= ds;\n    }\n}\n\nvoid PngEncoder::process_rect(unsigned char* row, int rowbytes, int bpp, int stride, int h, unsigned char* rows)\n{\n    int i, j, v;\n    int a, b, c, pa, pb, pc, p;\n    unsigned char* prev = NULL;\n    unsigned char* dp = rows;\n    unsigned char* out;\n\n    for (j = 0; j < h; j++)\n    {\n        uint32_t sum = 0;\n        unsigned char* best_row = row_buf;\n        uint32_t mins = ((uint32_t)(-1)) >> 1;\n\n        out = row_buf + 1;\n        for (i = 0; i < rowbytes; i++)\n        {\n            v = out[i] = row[i];\n            sum += (v < 128) ? v : 256 - v;\n        }\n        mins = sum;\n\n        sum = 0;\n        out = sub_row + 1;\n        for (i = 0; i < bpp; i++)\n        {\n            v = out[i] = row[i];\n            sum += (v < 128) ? v : 256 - v;\n        }\n        for (i = bpp; i < rowbytes; i++)\n        {\n            v = out[i] = row[i] - row[i - bpp];\n            sum += (v < 128) ? v : 256 - v;\n            if (sum > mins)\n                break;\n        }\n        if (sum < mins)\n        {\n            mins = sum;\n            best_row = sub_row;\n        }\n\n        if (prev)\n        {\n            sum = 0;\n            out = up_row + 1;\n            for (i = 0; i < rowbytes; i++)\n            {\n                v = out[i] = row[i] - prev[i];\n                sum += (v < 128) ? v : 256 - v;\n                if (sum > mins)\n                    break;\n            }\n            if (sum < mins)\n            {\n                mins = sum;\n                best_row = up_row;\n            }\n\n            sum = 0;\n            out = avg_row + 1;\n            for (i = 0; i < bpp; i++)\n            {\n                v = out[i] = row[i] - prev[i] / 2;\n                sum += (v < 128) ? v : 256 - v;\n            }\n            for (i = bpp; i < rowbytes; i++)\n            {\n                v = out[i] = row[i] - (prev[i] + row[i - bpp]) / 2;\n                sum += (v < 128) ? v : 256 - v;\n                if (sum > mins)\n                    break;\n            }\n            if (sum < mins)\n            {\n                mins = sum;\n                best_row = avg_row;\n            }\n\n            sum = 0;\n            out = paeth_row + 1;\n            for (i = 0; i < bpp; i++)\n            {\n                v = out[i] = row[i] - prev[i];\n                sum += (v < 128) ? v : 256 - v;\n            }\n            for (i = bpp; i < rowbytes; i++)\n            {\n                a = row[i - bpp];\n                b = prev[i];\n                c = prev[i - bpp];\n                p = b - c;\n                pc = a - c;\n                pa = abs(p);\n                pb = abs(pc);\n                pc = abs(p + pc);\n                p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b\n                    : c;\n                v = out[i] = row[i] - p;\n                sum += (v < 128) ? v : 256 - v;\n                if (sum > mins)\n                    break;\n            }\n            if (sum < mins)\n            {\n                best_row = paeth_row;\n            }\n        }\n\n        if (rows == NULL)\n        {\n            // deflate_rect_op()\n            op_zstream1.next_in = row_buf;\n            op_zstream1.avail_in = rowbytes + 1;\n            deflate(&op_zstream1, Z_NO_FLUSH);\n\n            op_zstream2.next_in = best_row;\n            op_zstream2.avail_in = rowbytes + 1;\n            deflate(&op_zstream2, Z_NO_FLUSH);\n        }\n        else\n        {\n            // deflate_rect_fin()\n            memcpy(dp, best_row, rowbytes + 1);\n            dp += rowbytes + 1;\n        }\n\n        prev = row;\n        row += stride;\n    }\n}\n\nvoid PngEncoder::deflate_rect_op(unsigned char* pdata, int x, int y, int w, int h, int bpp, int stride, int zbuf_size, int n)\n{\n    unsigned char* row = pdata + y * stride + x * bpp;\n    int rowbytes = w * bpp;\n\n    op_zstream1.data_type = Z_BINARY;\n    op_zstream1.next_out = op_zbuf1;\n    op_zstream1.avail_out = zbuf_size;\n\n    op_zstream2.data_type = Z_BINARY;\n    op_zstream2.next_out = op_zbuf2;\n    op_zstream2.avail_out = zbuf_size;\n\n    process_rect(row, rowbytes, bpp, stride, h, NULL);\n\n    deflate(&op_zstream1, Z_FINISH);\n    deflate(&op_zstream2, Z_FINISH);\n    op[n].p = pdata;\n\n    if (op_zstream1.total_out < op_zstream2.total_out)\n    {\n        op[n].size = op_zstream1.total_out;\n        op[n].filters = 0;\n    }\n    else\n    {\n        op[n].size = op_zstream2.total_out;\n        op[n].filters = 1;\n    }\n    op[n].x = x;\n    op[n].y = y;\n    op[n].w = w;\n    op[n].h = h;\n    op[n].valid = 1;\n    deflateReset(&op_zstream1);\n    deflateReset(&op_zstream2);\n}\n\nvoid PngEncoder::get_rect(uint32_t w, uint32_t h, unsigned char* pimage1, unsigned char* pimage2, unsigned char* ptemp, uint32_t bpp, uint32_t stride, int zbuf_size, uint32_t has_tcolor, uint32_t tcolor, int n)\n{\n    uint32_t i, j, x0, y0, w0, h0;\n    uint32_t x_min = w - 1;\n    uint32_t y_min = h - 1;\n    uint32_t x_max = 0;\n    uint32_t y_max = 0;\n    uint32_t diffnum = 0;\n    uint32_t over_is_possible = 1;\n\n    if (!has_tcolor)\n        over_is_possible = 0;\n\n    if (bpp == 1)\n    {\n        unsigned char* pa = pimage1;\n        unsigned char* pb = pimage2;\n        unsigned char* pc = ptemp;\n\n        for (j = 0; j < h; j++)\n            for (i = 0; i < w; i++)\n            {\n                unsigned char c = *pb++;\n                if (*pa++ != c)\n                {\n                    diffnum++;\n                    if (has_tcolor && c == tcolor)\n                        over_is_possible = 0;\n                    if (i < x_min)\n                        x_min = i;\n                    if (i > x_max)\n                        x_max = i;\n                    if (j < y_min)\n                        y_min = j;\n                    if (j > y_max)\n                        y_max = j;\n                }\n                else\n                    c = tcolor;\n\n                *pc++ = c;\n            }\n    }\n    else if (bpp == 2)\n    {\n        unsigned short* pa = (unsigned short*)pimage1;\n        unsigned short* pb = (unsigned short*)pimage2;\n        unsigned short* pc = (unsigned short*)ptemp;\n\n        for (j = 0; j < h; j++)\n            for (i = 0; i < w; i++)\n            {\n                uint32_t c1 = *pa++;\n                uint32_t c2 = *pb++;\n                if ((c1 != c2) && ((c1 >> 8) || (c2 >> 8)))\n                {\n                    diffnum++;\n                    if ((c2 >> 8) != 0xFF)\n                        over_is_possible = 0;\n                    if (i < x_min)\n                        x_min = i;\n                    if (i > x_max)\n                        x_max = i;\n                    if (j < y_min)\n                        y_min = j;\n                    if (j > y_max)\n                        y_max = j;\n                }\n                else\n                    c2 = 0;\n\n                *pc++ = c2;\n            }\n    }\n    else if (bpp == 3)\n    {\n        unsigned char* pa = pimage1;\n        unsigned char* pb = pimage2;\n        unsigned char* pc = ptemp;\n\n        for (j = 0; j < h; j++)\n            for (i = 0; i < w; i++)\n            {\n                uint32_t c1 = (pa[2] << 16) + (pa[1] << 8) + pa[0];\n                uint32_t c2 = (pb[2] << 16) + (pb[1] << 8) + pb[0];\n                if (c1 != c2)\n                {\n                    diffnum++;\n                    if (has_tcolor && c2 == tcolor)\n                        over_is_possible = 0;\n                    if (i < x_min)\n                        x_min = i;\n                    if (i > x_max)\n                        x_max = i;\n                    if (j < y_min)\n                        y_min = j;\n                    if (j > y_max)\n                        y_max = j;\n                }\n                else\n                    c2 = tcolor;\n\n                memcpy(pc, &c2, 3);\n                pa += 3;\n                pb += 3;\n                pc += 3;\n            }\n    }\n    else if (bpp == 4)\n    {\n        uint32_t* pa = (uint32_t*)pimage1;\n        uint32_t* pb = (uint32_t*)pimage2;\n        uint32_t* pc = (uint32_t*)ptemp;\n\n        for (j = 0; j < h; j++)\n            for (i = 0; i < w; i++)\n            {\n                uint32_t c1 = *pa++;\n                uint32_t c2 = *pb++;\n                if ((c1 != c2) && ((c1 >> 24) || (c2 >> 24)))\n                {\n                    diffnum++;\n                    if ((c2 >> 24) != 0xFF)\n                        over_is_possible = 0;\n                    if (i < x_min)\n                        x_min = i;\n                    if (i > x_max)\n                        x_max = i;\n                    if (j < y_min)\n                        y_min = j;\n                    if (j > y_max)\n                        y_max = j;\n                }\n                else\n                    c2 = 0;\n\n                *pc++ = c2;\n            }\n    }\n\n    if (diffnum == 0)\n    {\n        x0 = y0 = 0;\n        w0 = h0 = 1;\n    }\n    else\n    {\n        x0 = x_min;\n        y0 = y_min;\n        w0 = x_max - x_min + 1;\n        h0 = y_max - y_min + 1;\n    }\n\n    deflate_rect_op(pimage2, x0, y0, w0, h0, bpp, stride, zbuf_size, n * 2);\n\n    if (over_is_possible)\n        deflate_rect_op(ptemp, x0, y0, w0, h0, bpp, stride, zbuf_size, n * 2 + 1);\n}\n\nvoid PngEncoder::deflate_rect_fin(int deflate_method, int iter, unsigned char* zbuf, uint32_t* zsize, int bpp, int stride, unsigned char* rows, int zbuf_size, int n)\n{\n    unsigned char* row = op[n].p + op[n].y * stride + op[n].x * bpp;\n    int rowbytes = op[n].w * bpp;\n\n    if (op[n].filters == 0)\n    {\n        unsigned char* dp = rows;\n        for (int j = 0; j < op[n].h; j++)\n        {\n            *dp++ = 0;\n            memcpy(dp, row, rowbytes);\n            dp += rowbytes;\n            row += stride;\n        }\n    }\n    else\n        process_rect(row, rowbytes, bpp, stride, op[n].h, rows);\n\n    if (deflate_method == 2)\n    {\n        CV_UNUSED(iter);\n#if 0  // needs include \"zopfli.h\"\n        ZopfliOptions opt_zopfli;\n        unsigned char* data = 0;\n        size_t size = 0;\n        ZopfliInitOptions(&opt_zopfli);\n        opt_zopfli.numiterations = iter;\n        ZopfliCompress(&opt_zopfli, ZOPFLI_FORMAT_ZLIB, rows, op[n].h * (rowbytes + 1), &data, &size);\n        if (size < (size_t)zbuf_size)\n        {\n            memcpy(zbuf, data, size);\n            *zsize = size;\n        }\n        free(data);\n#endif\n    }\n    else if (deflate_method == 1)\n    {\n#if 0  // needs include \"7z.h\"\n        unsigned size = zbuf_size;\n        compress_rfc1950_7z(rows, op[n].h * (rowbytes + 1), zbuf, size, iter < 100 ? iter : 100, 255);\n        *zsize = size;\n#endif\n    }\n    else\n    {\n        z_stream fin_zstream;\n\n        fin_zstream.data_type = Z_BINARY;\n        fin_zstream.zalloc = Z_NULL;\n        fin_zstream.zfree = Z_NULL;\n        fin_zstream.opaque = Z_NULL;\n        deflateInit2(&fin_zstream, Z_BEST_COMPRESSION, 8, 15, 8, op[n].filters ? Z_FILTERED : Z_DEFAULT_STRATEGY);\n\n        fin_zstream.next_out = zbuf;\n        fin_zstream.avail_out = zbuf_size;\n        fin_zstream.next_in = rows;\n        fin_zstream.avail_in = op[n].h * (rowbytes + 1);\n        deflate(&fin_zstream, Z_FINISH);\n        *zsize = fin_zstream.total_out;\n        deflateEnd(&fin_zstream);\n    }\n}\n\nbool PngEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    CV_Assert(img_vec[0].depth() == CV_8U);\n    Animation animation;\n    animation.frames = img_vec;\n\n    for (size_t i = 0; i < animation.frames.size(); i++)\n    {\n        animation.durations.push_back(1000);\n    }\n    return writeanimation(animation, params);\n}\n\nbool PngEncoder::writeanimation(const Animation& animation, const std::vector<int>& params)\n{\n    int compression_level = 6;\n    int compression_strategy = IMWRITE_PNG_STRATEGY_RLE; // Default strategy\n    bool isBilevel = false;\n\n    for (size_t i = 0; i < params.size(); i += 2)\n    {\n        if (params[i] == IMWRITE_PNG_COMPRESSION)\n        {\n            compression_strategy = IMWRITE_PNG_STRATEGY_DEFAULT; // Default strategy\n            compression_level = params[i + 1];\n            compression_level = MIN(MAX(compression_level, 0), Z_BEST_COMPRESSION);\n        }\n        if (params[i] == IMWRITE_PNG_STRATEGY)\n        {\n            compression_strategy = params[i + 1];\n            compression_strategy = MIN(MAX(compression_strategy, 0), Z_FIXED);\n        }\n        if (params[i] == IMWRITE_PNG_BILEVEL)\n        {\n            isBilevel = params[i + 1] != 0;\n        }\n    }\n\n    std::vector<APNGFrame> frames;\n    std::vector<Mat> tmpframes;\n\n    for (size_t i = 0; i < animation.frames.size(); i++)\n    {\n        APNGFrame apngFrame;\n        tmpframes.push_back(animation.frames[i].clone());\n        if (animation.frames[i].channels() == 4)\n            cvtColor(animation.frames[i], tmpframes[i], COLOR_BGRA2RGBA);\n        if (animation.frames[i].channels() == 3)\n            cvtColor(animation.frames[i], tmpframes[i], COLOR_BGR2RGB);\n        apngFrame.setMat(tmpframes[i]);\n        apngFrame.setDelayDen(animation.durations[i]);\n        frames.push_back(apngFrame);\n    }\n\n    CV_UNUSED(isBilevel);\n    uint32_t first =0;\n    uint32_t loops= animation.loop_count;\n    uint32_t coltype= animation.frames[0].channels() == 1 ? PNG_COLOR_TYPE_GRAY : animation.frames[0].channels() == 3 ? PNG_COLOR_TYPE_RGB : PNG_COLOR_TYPE_RGB_ALPHA;\n    int deflate_method=0;\n    int iter=0;\n\n    FILE* m_f = NULL;\n    uint32_t i, j, k;\n    uint32_t x0, y0, w0, h0, dop, bop;\n    uint32_t idat_size, zbuf_size, zsize;\n    unsigned char* zbuf;\n    unsigned char header[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n    uint32_t num_frames = (int)frames.size();\n    uint32_t width = frames[0].getWidth();\n    uint32_t height = frames[0].getHeight();\n    uint32_t bpp = (coltype == 6) ? 4 : (coltype == 2) ? 3\n        : (coltype == 4) ? 2\n        : 1;\n    uint32_t has_tcolor = (coltype >= 4 || (coltype <= 2 && trnssize)) ? 1 : 0;\n    uint32_t tcolor = 0;\n    uint32_t rowbytes = width * bpp;\n    uint32_t imagesize = rowbytes * height;\n\n    unsigned char* temp = new unsigned char[imagesize];\n    unsigned char* over1 = new unsigned char[imagesize];\n    unsigned char* over2 = new unsigned char[imagesize];\n    unsigned char* over3 = new unsigned char[imagesize];\n    unsigned char* rest = new unsigned char[imagesize];\n    unsigned char* rows = new unsigned char[(rowbytes + 1) * height];",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1894579735",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25715,
        "pr_file": "modules/imgcodecs/src/grfmt_png.cpp",
        "discussion_id": "1894579735",
        "commented_code": "@@ -449,6 +852,843 @@ bool  PngEncoder::write( const Mat& img, const std::vector<int>& params )\n     return result;\n }\n \n+void PngEncoder::optim_dirty(std::vector<APNGFrame>& frames)\n+{\n+    uint32_t i, j;\n+    unsigned char* sp;\n+    uint32_t size = frames[0].getWidth() * frames[0].getHeight();\n+\n+    for (i = 0; i < frames.size(); i++)\n+    {\n+        sp = frames[i].getPixels();\n+        for (j = 0; j < size; j++, sp += 4)\n+            if (sp[3] == 0)\n+                sp[0] = sp[1] = sp[2] = 0;\n+    }\n+}\n+\n+void PngEncoder::optim_duplicates(std::vector<APNGFrame>& frames, uint32_t first)\n+{\n+    uint32_t imagesize = frames[0].getWidth() * frames[0].getHeight() * 4;\n+    uint32_t i = first;\n+\n+    while (++i < frames.size())\n+    {\n+        if (memcmp(frames[i - 1].getPixels(), frames[i].getPixels(), imagesize) != 0)\n+            continue;\n+\n+        i--;\n+        delete[] frames[i].getPixels();\n+        delete[] frames[i].getRows();\n+        uint32_t num = frames[i].getDelayNum();\n+        uint32_t den = frames[i].getDelayDen();\n+        frames.erase(frames.begin() + i);\n+\n+        if (frames[i].getDelayDen() == den)\n+            frames[i].setDelayNum(frames[i].getDelayNum()+num);\n+        else\n+        {\n+            frames[i].setDelayNum(num * frames[i].getDelayDen() + den * frames[i].getDelayNum());\n+            frames[i].setDelayDen(den * frames[i].getDelayDen());\n+            while (num && den)\n+            {\n+                if (num > den)\n+                    num = num % den;\n+                else\n+                    den = den % num;\n+            }\n+            num += den;\n+            frames[i].setDelayNum(frames[i].getDelayNum() / num);\n+            frames[i].setDelayDen(frames[i].getDelayDen() / num);\n+        }\n+    }\n+}\n+\n+size_t PngEncoder::write_to_io(void const* _Buffer, size_t  _ElementSize, size_t _ElementCount, FILE * _Stream)\n+{\n+    if (_Stream)\n+        return fwrite(_Buffer, _ElementSize, _ElementCount, _Stream);\n+\n+    size_t cursz = m_buf->size();\n+    m_buf->resize(cursz + _ElementCount);\n+    memcpy( &(*m_buf)[cursz], _Buffer, _ElementCount );\n+    return _ElementCount;\n+}\n+\n+void PngEncoder::write_chunk(FILE* f, const char* name, unsigned char* data, uint32_t length)\n+{\n+    unsigned char buf[4];\n+    uint32_t crc = crc32(0, Z_NULL, 0);\n+\n+    png_save_uint_32(buf, length);\n+    write_to_io(buf, 1, 4, f);\n+    write_to_io(name, 1, 4, f);\n+    crc = crc32(crc, (const Bytef*)name, 4);\n+\n+    if (memcmp(name, \"fdAT\", 4) == 0)\n+    {\n+        png_save_uint_32(buf, next_seq_num++);\n+        write_to_io(buf, 1, 4, f);\n+        crc = crc32(crc, buf, 4);\n+        length -= 4;\n+    }\n+\n+    if (data != NULL && length > 0)\n+    {\n+        write_to_io(data, 1, length, f);\n+        crc = crc32(crc, data, length);\n+    }\n+\n+    png_save_uint_32(buf, crc);\n+    write_to_io(buf, 1, 4, f);\n+}\n+\n+void PngEncoder::write_IDATs(FILE* f, int frame, unsigned char* data, uint32_t length, uint32_t idat_size)\n+{\n+    uint32_t z_cmf = data[0];\n+    if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)\n+    {\n+        if (length >= 2)\n+        {\n+            uint32_t z_cinfo = z_cmf >> 4;\n+            uint32_t half_z_window_size = 1 << (z_cinfo + 7);\n+            while (idat_size <= half_z_window_size && half_z_window_size >= 256)\n+            {\n+                z_cinfo--;\n+                half_z_window_size >>= 1;\n+            }\n+            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);\n+            if (data[0] != (unsigned char)z_cmf)\n+            {\n+                data[0] = (unsigned char)z_cmf;\n+                data[1] &= 0xe0;\n+                data[1] += (unsigned char)(0x1f - ((z_cmf << 8) + data[1]) % 0x1f);\n+            }\n+        }\n+    }\n+\n+    while (length > 0)\n+    {\n+        uint32_t ds = length;\n+        if (ds > 32768)\n+            ds = 32768;\n+\n+        if (frame == 0)\n+            write_chunk(f, \"IDAT\", data, ds);\n+        else\n+            write_chunk(f, \"fdAT\", data, ds + 4);\n+\n+        data += ds;\n+        length -= ds;\n+    }\n+}\n+\n+void PngEncoder::process_rect(unsigned char* row, int rowbytes, int bpp, int stride, int h, unsigned char* rows)\n+{\n+    int i, j, v;\n+    int a, b, c, pa, pb, pc, p;\n+    unsigned char* prev = NULL;\n+    unsigned char* dp = rows;\n+    unsigned char* out;\n+\n+    for (j = 0; j < h; j++)\n+    {\n+        uint32_t sum = 0;\n+        unsigned char* best_row = row_buf;\n+        uint32_t mins = ((uint32_t)(-1)) >> 1;\n+\n+        out = row_buf + 1;\n+        for (i = 0; i < rowbytes; i++)\n+        {\n+            v = out[i] = row[i];\n+            sum += (v < 128) ? v : 256 - v;\n+        }\n+        mins = sum;\n+\n+        sum = 0;\n+        out = sub_row + 1;\n+        for (i = 0; i < bpp; i++)\n+        {\n+            v = out[i] = row[i];\n+            sum += (v < 128) ? v : 256 - v;\n+        }\n+        for (i = bpp; i < rowbytes; i++)\n+        {\n+            v = out[i] = row[i] - row[i - bpp];\n+            sum += (v < 128) ? v : 256 - v;\n+            if (sum > mins)\n+                break;\n+        }\n+        if (sum < mins)\n+        {\n+            mins = sum;\n+            best_row = sub_row;\n+        }\n+\n+        if (prev)\n+        {\n+            sum = 0;\n+            out = up_row + 1;\n+            for (i = 0; i < rowbytes; i++)\n+            {\n+                v = out[i] = row[i] - prev[i];\n+                sum += (v < 128) ? v : 256 - v;\n+                if (sum > mins)\n+                    break;\n+            }\n+            if (sum < mins)\n+            {\n+                mins = sum;\n+                best_row = up_row;\n+            }\n+\n+            sum = 0;\n+            out = avg_row + 1;\n+            for (i = 0; i < bpp; i++)\n+            {\n+                v = out[i] = row[i] - prev[i] / 2;\n+                sum += (v < 128) ? v : 256 - v;\n+            }\n+            for (i = bpp; i < rowbytes; i++)\n+            {\n+                v = out[i] = row[i] - (prev[i] + row[i - bpp]) / 2;\n+                sum += (v < 128) ? v : 256 - v;\n+                if (sum > mins)\n+                    break;\n+            }\n+            if (sum < mins)\n+            {\n+                mins = sum;\n+                best_row = avg_row;\n+            }\n+\n+            sum = 0;\n+            out = paeth_row + 1;\n+            for (i = 0; i < bpp; i++)\n+            {\n+                v = out[i] = row[i] - prev[i];\n+                sum += (v < 128) ? v : 256 - v;\n+            }\n+            for (i = bpp; i < rowbytes; i++)\n+            {\n+                a = row[i - bpp];\n+                b = prev[i];\n+                c = prev[i - bpp];\n+                p = b - c;\n+                pc = a - c;\n+                pa = abs(p);\n+                pb = abs(pc);\n+                pc = abs(p + pc);\n+                p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b\n+                    : c;\n+                v = out[i] = row[i] - p;\n+                sum += (v < 128) ? v : 256 - v;\n+                if (sum > mins)\n+                    break;\n+            }\n+            if (sum < mins)\n+            {\n+                best_row = paeth_row;\n+            }\n+        }\n+\n+        if (rows == NULL)\n+        {\n+            // deflate_rect_op()\n+            op_zstream1.next_in = row_buf;\n+            op_zstream1.avail_in = rowbytes + 1;\n+            deflate(&op_zstream1, Z_NO_FLUSH);\n+\n+            op_zstream2.next_in = best_row;\n+            op_zstream2.avail_in = rowbytes + 1;\n+            deflate(&op_zstream2, Z_NO_FLUSH);\n+        }\n+        else\n+        {\n+            // deflate_rect_fin()\n+            memcpy(dp, best_row, rowbytes + 1);\n+            dp += rowbytes + 1;\n+        }\n+\n+        prev = row;\n+        row += stride;\n+    }\n+}\n+\n+void PngEncoder::deflate_rect_op(unsigned char* pdata, int x, int y, int w, int h, int bpp, int stride, int zbuf_size, int n)\n+{\n+    unsigned char* row = pdata + y * stride + x * bpp;\n+    int rowbytes = w * bpp;\n+\n+    op_zstream1.data_type = Z_BINARY;\n+    op_zstream1.next_out = op_zbuf1;\n+    op_zstream1.avail_out = zbuf_size;\n+\n+    op_zstream2.data_type = Z_BINARY;\n+    op_zstream2.next_out = op_zbuf2;\n+    op_zstream2.avail_out = zbuf_size;\n+\n+    process_rect(row, rowbytes, bpp, stride, h, NULL);\n+\n+    deflate(&op_zstream1, Z_FINISH);\n+    deflate(&op_zstream2, Z_FINISH);\n+    op[n].p = pdata;\n+\n+    if (op_zstream1.total_out < op_zstream2.total_out)\n+    {\n+        op[n].size = op_zstream1.total_out;\n+        op[n].filters = 0;\n+    }\n+    else\n+    {\n+        op[n].size = op_zstream2.total_out;\n+        op[n].filters = 1;\n+    }\n+    op[n].x = x;\n+    op[n].y = y;\n+    op[n].w = w;\n+    op[n].h = h;\n+    op[n].valid = 1;\n+    deflateReset(&op_zstream1);\n+    deflateReset(&op_zstream2);\n+}\n+\n+void PngEncoder::get_rect(uint32_t w, uint32_t h, unsigned char* pimage1, unsigned char* pimage2, unsigned char* ptemp, uint32_t bpp, uint32_t stride, int zbuf_size, uint32_t has_tcolor, uint32_t tcolor, int n)\n+{\n+    uint32_t i, j, x0, y0, w0, h0;\n+    uint32_t x_min = w - 1;\n+    uint32_t y_min = h - 1;\n+    uint32_t x_max = 0;\n+    uint32_t y_max = 0;\n+    uint32_t diffnum = 0;\n+    uint32_t over_is_possible = 1;\n+\n+    if (!has_tcolor)\n+        over_is_possible = 0;\n+\n+    if (bpp == 1)\n+    {\n+        unsigned char* pa = pimage1;\n+        unsigned char* pb = pimage2;\n+        unsigned char* pc = ptemp;\n+\n+        for (j = 0; j < h; j++)\n+            for (i = 0; i < w; i++)\n+            {\n+                unsigned char c = *pb++;\n+                if (*pa++ != c)\n+                {\n+                    diffnum++;\n+                    if (has_tcolor && c == tcolor)\n+                        over_is_possible = 0;\n+                    if (i < x_min)\n+                        x_min = i;\n+                    if (i > x_max)\n+                        x_max = i;\n+                    if (j < y_min)\n+                        y_min = j;\n+                    if (j > y_max)\n+                        y_max = j;\n+                }\n+                else\n+                    c = tcolor;\n+\n+                *pc++ = c;\n+            }\n+    }\n+    else if (bpp == 2)\n+    {\n+        unsigned short* pa = (unsigned short*)pimage1;\n+        unsigned short* pb = (unsigned short*)pimage2;\n+        unsigned short* pc = (unsigned short*)ptemp;\n+\n+        for (j = 0; j < h; j++)\n+            for (i = 0; i < w; i++)\n+            {\n+                uint32_t c1 = *pa++;\n+                uint32_t c2 = *pb++;\n+                if ((c1 != c2) && ((c1 >> 8) || (c2 >> 8)))\n+                {\n+                    diffnum++;\n+                    if ((c2 >> 8) != 0xFF)\n+                        over_is_possible = 0;\n+                    if (i < x_min)\n+                        x_min = i;\n+                    if (i > x_max)\n+                        x_max = i;\n+                    if (j < y_min)\n+                        y_min = j;\n+                    if (j > y_max)\n+                        y_max = j;\n+                }\n+                else\n+                    c2 = 0;\n+\n+                *pc++ = c2;\n+            }\n+    }\n+    else if (bpp == 3)\n+    {\n+        unsigned char* pa = pimage1;\n+        unsigned char* pb = pimage2;\n+        unsigned char* pc = ptemp;\n+\n+        for (j = 0; j < h; j++)\n+            for (i = 0; i < w; i++)\n+            {\n+                uint32_t c1 = (pa[2] << 16) + (pa[1] << 8) + pa[0];\n+                uint32_t c2 = (pb[2] << 16) + (pb[1] << 8) + pb[0];\n+                if (c1 != c2)\n+                {\n+                    diffnum++;\n+                    if (has_tcolor && c2 == tcolor)\n+                        over_is_possible = 0;\n+                    if (i < x_min)\n+                        x_min = i;\n+                    if (i > x_max)\n+                        x_max = i;\n+                    if (j < y_min)\n+                        y_min = j;\n+                    if (j > y_max)\n+                        y_max = j;\n+                }\n+                else\n+                    c2 = tcolor;\n+\n+                memcpy(pc, &c2, 3);\n+                pa += 3;\n+                pb += 3;\n+                pc += 3;\n+            }\n+    }\n+    else if (bpp == 4)\n+    {\n+        uint32_t* pa = (uint32_t*)pimage1;\n+        uint32_t* pb = (uint32_t*)pimage2;\n+        uint32_t* pc = (uint32_t*)ptemp;\n+\n+        for (j = 0; j < h; j++)\n+            for (i = 0; i < w; i++)\n+            {\n+                uint32_t c1 = *pa++;\n+                uint32_t c2 = *pb++;\n+                if ((c1 != c2) && ((c1 >> 24) || (c2 >> 24)))\n+                {\n+                    diffnum++;\n+                    if ((c2 >> 24) != 0xFF)\n+                        over_is_possible = 0;\n+                    if (i < x_min)\n+                        x_min = i;\n+                    if (i > x_max)\n+                        x_max = i;\n+                    if (j < y_min)\n+                        y_min = j;\n+                    if (j > y_max)\n+                        y_max = j;\n+                }\n+                else\n+                    c2 = 0;\n+\n+                *pc++ = c2;\n+            }\n+    }\n+\n+    if (diffnum == 0)\n+    {\n+        x0 = y0 = 0;\n+        w0 = h0 = 1;\n+    }\n+    else\n+    {\n+        x0 = x_min;\n+        y0 = y_min;\n+        w0 = x_max - x_min + 1;\n+        h0 = y_max - y_min + 1;\n+    }\n+\n+    deflate_rect_op(pimage2, x0, y0, w0, h0, bpp, stride, zbuf_size, n * 2);\n+\n+    if (over_is_possible)\n+        deflate_rect_op(ptemp, x0, y0, w0, h0, bpp, stride, zbuf_size, n * 2 + 1);\n+}\n+\n+void PngEncoder::deflate_rect_fin(int deflate_method, int iter, unsigned char* zbuf, uint32_t* zsize, int bpp, int stride, unsigned char* rows, int zbuf_size, int n)\n+{\n+    unsigned char* row = op[n].p + op[n].y * stride + op[n].x * bpp;\n+    int rowbytes = op[n].w * bpp;\n+\n+    if (op[n].filters == 0)\n+    {\n+        unsigned char* dp = rows;\n+        for (int j = 0; j < op[n].h; j++)\n+        {\n+            *dp++ = 0;\n+            memcpy(dp, row, rowbytes);\n+            dp += rowbytes;\n+            row += stride;\n+        }\n+    }\n+    else\n+        process_rect(row, rowbytes, bpp, stride, op[n].h, rows);\n+\n+    if (deflate_method == 2)\n+    {\n+        CV_UNUSED(iter);\n+#if 0  // needs include \"zopfli.h\"\n+        ZopfliOptions opt_zopfli;\n+        unsigned char* data = 0;\n+        size_t size = 0;\n+        ZopfliInitOptions(&opt_zopfli);\n+        opt_zopfli.numiterations = iter;\n+        ZopfliCompress(&opt_zopfli, ZOPFLI_FORMAT_ZLIB, rows, op[n].h * (rowbytes + 1), &data, &size);\n+        if (size < (size_t)zbuf_size)\n+        {\n+            memcpy(zbuf, data, size);\n+            *zsize = size;\n+        }\n+        free(data);\n+#endif\n+    }\n+    else if (deflate_method == 1)\n+    {\n+#if 0  // needs include \"7z.h\"\n+        unsigned size = zbuf_size;\n+        compress_rfc1950_7z(rows, op[n].h * (rowbytes + 1), zbuf, size, iter < 100 ? iter : 100, 255);\n+        *zsize = size;\n+#endif\n+    }\n+    else\n+    {\n+        z_stream fin_zstream;\n+\n+        fin_zstream.data_type = Z_BINARY;\n+        fin_zstream.zalloc = Z_NULL;\n+        fin_zstream.zfree = Z_NULL;\n+        fin_zstream.opaque = Z_NULL;\n+        deflateInit2(&fin_zstream, Z_BEST_COMPRESSION, 8, 15, 8, op[n].filters ? Z_FILTERED : Z_DEFAULT_STRATEGY);\n+\n+        fin_zstream.next_out = zbuf;\n+        fin_zstream.avail_out = zbuf_size;\n+        fin_zstream.next_in = rows;\n+        fin_zstream.avail_in = op[n].h * (rowbytes + 1);\n+        deflate(&fin_zstream, Z_FINISH);\n+        *zsize = fin_zstream.total_out;\n+        deflateEnd(&fin_zstream);\n+    }\n+}\n+\n+bool PngEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n+{\n+    CV_Assert(img_vec[0].depth() == CV_8U);\n+    Animation animation;\n+    animation.frames = img_vec;\n+\n+    for (size_t i = 0; i < animation.frames.size(); i++)\n+    {\n+        animation.durations.push_back(1000);\n+    }\n+    return writeanimation(animation, params);\n+}\n+\n+bool PngEncoder::writeanimation(const Animation& animation, const std::vector<int>& params)\n+{\n+    int compression_level = 6;\n+    int compression_strategy = IMWRITE_PNG_STRATEGY_RLE; // Default strategy\n+    bool isBilevel = false;\n+\n+    for (size_t i = 0; i < params.size(); i += 2)\n+    {\n+        if (params[i] == IMWRITE_PNG_COMPRESSION)\n+        {\n+            compression_strategy = IMWRITE_PNG_STRATEGY_DEFAULT; // Default strategy\n+            compression_level = params[i + 1];\n+            compression_level = MIN(MAX(compression_level, 0), Z_BEST_COMPRESSION);\n+        }\n+        if (params[i] == IMWRITE_PNG_STRATEGY)\n+        {\n+            compression_strategy = params[i + 1];\n+            compression_strategy = MIN(MAX(compression_strategy, 0), Z_FIXED);\n+        }\n+        if (params[i] == IMWRITE_PNG_BILEVEL)\n+        {\n+            isBilevel = params[i + 1] != 0;\n+        }\n+    }\n+\n+    std::vector<APNGFrame> frames;\n+    std::vector<Mat> tmpframes;\n+\n+    for (size_t i = 0; i < animation.frames.size(); i++)\n+    {\n+        APNGFrame apngFrame;\n+        tmpframes.push_back(animation.frames[i].clone());\n+        if (animation.frames[i].channels() == 4)\n+            cvtColor(animation.frames[i], tmpframes[i], COLOR_BGRA2RGBA);\n+        if (animation.frames[i].channels() == 3)\n+            cvtColor(animation.frames[i], tmpframes[i], COLOR_BGR2RGB);\n+        apngFrame.setMat(tmpframes[i]);\n+        apngFrame.setDelayDen(animation.durations[i]);\n+        frames.push_back(apngFrame);\n+    }\n+\n+    CV_UNUSED(isBilevel);\n+    uint32_t first =0;\n+    uint32_t loops= animation.loop_count;\n+    uint32_t coltype= animation.frames[0].channels() == 1 ? PNG_COLOR_TYPE_GRAY : animation.frames[0].channels() == 3 ? PNG_COLOR_TYPE_RGB : PNG_COLOR_TYPE_RGB_ALPHA;\n+    int deflate_method=0;\n+    int iter=0;\n+\n+    FILE* m_f = NULL;\n+    uint32_t i, j, k;\n+    uint32_t x0, y0, w0, h0, dop, bop;\n+    uint32_t idat_size, zbuf_size, zsize;\n+    unsigned char* zbuf;\n+    unsigned char header[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };\n+    uint32_t num_frames = (int)frames.size();\n+    uint32_t width = frames[0].getWidth();\n+    uint32_t height = frames[0].getHeight();\n+    uint32_t bpp = (coltype == 6) ? 4 : (coltype == 2) ? 3\n+        : (coltype == 4) ? 2\n+        : 1;\n+    uint32_t has_tcolor = (coltype >= 4 || (coltype <= 2 && trnssize)) ? 1 : 0;\n+    uint32_t tcolor = 0;\n+    uint32_t rowbytes = width * bpp;\n+    uint32_t imagesize = rowbytes * height;\n+\n+    unsigned char* temp = new unsigned char[imagesize];\n+    unsigned char* over1 = new unsigned char[imagesize];\n+    unsigned char* over2 = new unsigned char[imagesize];\n+    unsigned char* over3 = new unsigned char[imagesize];\n+    unsigned char* rest = new unsigned char[imagesize];\n+    unsigned char* rows = new unsigned char[(rowbytes + 1) * height];",
        "comment_created_at": "2024-12-21T07:44:06+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "I propose to use `std::vector` or `cv::AutoBuffer` to prevent memory leaks. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1668761773",
    "pr_number": 25608,
    "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
    "created_at": "2024-07-08T14:33:40+00:00",
    "commented_code": "WebPBitstreamFeatures features;\n    if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n    {\n        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n        m_has_animation = features.has_animation > 0;\n        if (m_has_animation)\n        {\n            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n            data.create(1, validateToInt(fs_size), CV_8UC1);\n            fs.read((char*)data.ptr(), fs_size);\n            CV_Assert(fs && \"Can't read file data\");\n            fs.close();\n\n            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n\n            WebPData webp_data;\n            webp_data.bytes = (const uint8_t*)data.ptr();\n            webp_data.size = data.total();\n\n            WebPAnimDecoderOptions dec_options;\n            WebPAnimDecoderOptionsInit(&dec_options);\n            dec_options.color_mode = MODE_BGRA;\n            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1668761773",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-08T14:33:40+00:00",
        "comment_author": "vrabaud",
        "comment_body": "You are missing a WebPAnimDecoderDelete. Either you create a destructor for WebPDecoder, either you wrap the pointer in a unique_ptr. E.g., create in the header, a private struct:\r\n```cpp\r\nstruct UniquePtrDeleter\r\n{\r\n    void operator()(WebPAnimDecoder * decoder) const { WebPAnimDecoderDelete(decoder); }\r\n    void operator()(WebpData * dara) const { WebPDataClear(decoder); }\r\n};\r\n\r\n// Use these unique_ptr to ensure the structs are automatically destroyed.\r\nstd::unique_ptr<WebPAnimDecoder, UniquePtrDeleter> anim_decoder;\r\n// or create a type:\r\nusing DataPtr = std::unique_ptr<WebPData, UniquePtrDeleter>;\r\n```\r\nI'd go with this, so that you do not have to remember to call a destructor.",
        "pr_file_module": null
      },
      {
        "comment_id": "1673724498",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-11T09:38:39+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "@vrabaud could you check the last commit. frankly i tried your suggestion using std::unique_ptr but no success.. can last commit resolve this conversation.",
        "pr_file_module": null
      },
      {
        "comment_id": "1676777267",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-13T07:24:12+00:00",
        "comment_author": "vrabaud",
        "comment_body": "When calling the WebP API you need to get a pointer so if you have a `std::unique_ptr<WebPAnimDecoder, UniquePtrDeleter> anim_decoder;`, just call `anim_decoder.get()`",
        "pr_file_module": null
      },
      {
        "comment_id": "1676807079",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-13T11:02:33+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "@vrabaud could you check https://github.com/opencv/opencv/pull/25608/commits/a105d94aff541d2b4593150dc834bab279ad6cd6",
        "pr_file_module": null
      },
      {
        "comment_id": "1677917053",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-15T14:23:58+00:00",
        "comment_author": "sturkmen72",
        "comment_body": "should i mark this as resolved?",
        "pr_file_module": null
      },
      {
        "comment_id": "1681234937",
        "repo_full_name": "opencv/opencv",
        "pr_number": 25608,
        "pr_file": "modules/imgcodecs/src/grfmt_webp.cpp",
        "discussion_id": "1668761773",
        "commented_code": "@@ -126,8 +86,38 @@ bool WebPDecoder::readHeader()\n     WebPBitstreamFeatures features;\n     if (VP8_STATUS_OK == WebPGetFeatures(header, sizeof(header), &features))\n     {\n-        CV_CheckEQ(features.has_animation, 0, \"WebP backend does not support animated webp images\");\n+        m_has_animation = features.has_animation > 0;\n+        if (m_has_animation)\n+        {\n+            fs.seekg(0, std::ios::beg); CV_Assert(fs && \"File stream error\");\n+            data.create(1, validateToInt(fs_size), CV_8UC1);\n+            fs.read((char*)data.ptr(), fs_size);\n+            CV_Assert(fs && \"Can't read file data\");\n+            fs.close();\n+\n+            CV_Assert(data.type() == CV_8UC1); CV_Assert(data.rows == 1);\n+\n+            WebPData webp_data;\n+            webp_data.bytes = (const uint8_t*)data.ptr();\n+            webp_data.size = data.total();\n \n+            WebPAnimDecoderOptions dec_options;\n+            WebPAnimDecoderOptionsInit(&dec_options);\n+            dec_options.color_mode = MODE_BGRA;\n+            anim_decoder = WebPAnimDecoderNew(&webp_data, &dec_options);",
        "comment_created_at": "2024-07-17T15:11:36+00:00",
        "comment_author": "vrabaud",
        "comment_body": "Just do the same thing for data and encoder (or maybe simply do what you did for the encoder, by using a full  unique_ptr definition if you only use those once in the code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1259283684",
    "pr_number": 23960,
    "pr_file": "modules/video/src/tracking/bytetracker.cpp",
    "created_at": "2023-07-11T07:07:13+00:00",
    "commented_code": "// This file is part of OpenCV project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://opencv.org/license.html.\n\n\n\n#include \"../precomp.hpp\"\n\n//#include \"opencv2/video/detail/bytetracker.hpp\"\n// /#include \"opencv2/video/detail/bytetracker_strack.hpp\"\n#include \"opencv2/video/detail/lapjv.hpp\"\n#include \"opencv2/video/detail/tracking.detail.hpp\"\n#include <unordered_map>\n\n// #include \"detail/bytetracker.hpp\"\n// #include \"detail/bytetracker_strack.hpp\"\n// #include \"detail/lapjv.hpp\"\n\n#ifdef HAVE_OPENCV_DNN\n#include \"opencv2/dnn.hpp\"\n#endif\n\nusing namespace std;\nusing namespace cv;\n\nnamespace cv {\n\n\n//using cv::detail::tracking::Strack;\n//using cv::detail::tracking::Detection;\n//using cv::detail::tracking::TrackState;\n\n\n\nByteTracker::ByteTracker()\n{\n    //nothing\n}\n\nByteTracker::~ByteTracker()\n{\n    //nothing\n}\n\nByteTracker::Params::Params()\n{\n    frameRate = 30;\n    frameBuffer = 30;\n}\n        \n    \n\n\n\nclass ByteTrackerImpl : public ByteTracker\n{ \npublic:\n    //ByteTracker(int, int);\n    ByteTrackerImpl(const ByteTracker::Params& parameters) : params_(parameters)\n    {\n        trackThreshold_ = 0.5f;\n        matchThreshold_ = 0.7f;\n        lastId_ = 0;\n        frame_ = 0;\n        maxTimeLost_ = static_cast<int>(params_.frameRate / 30.0f * params_.frameBuffer);\n    }\n\n    void init(InputArray image, const Rect& boundingBox);\n    //std::vector<std::vector<float>> update(std::vector<std::vector<float>>)\n    vector<Strack> update(vector<Detection>& objects);\n    //Scalar get_color(int idx);\n    int getFrame();\n    map<int, int> lapjv(vector<vector<float>> &cost);\n\nprotected:\n    ByteTracker::Params params_;\n    float trackThreshold_;\n    float matchThreshold_;\n    unordered_map<int, Strack> trackedStracks_;\n    unordered_map<int, Strack> lostStracks_;\n    int lastId_;\n    int frame_;\n    int maxTimeLost_;\n    KalmanFilter kalmanFilter_;\n\n    void getDetections(vector<Detection>& Objects, vector<Strack>& detections, \n        vector<Strack>& detectionsLow);\n\n\n    void addNewDetectedTracks(unordered_map<int, Strack> trackedMap,\n        vector<Strack>& inactiveStracks, vector<Strack>& trackedStracks);\n\n\n    Mat getCostMatrix(vector<Strack>& tracks, vector<Strack>& btracks);\n    Mat getCostMatrix(unordered_map<int, Strack>& atracks, vector<Strack> &btracks);\n\n        \n    Mat calculateIous(vector<Rect>& atlwhs, vector<Rect> &btlwhs);\n\n\n    unordered_map<int, Strack> joinStracks(const vector<Strack>& trackA, vector<Strack>& trackB);\n    unordered_map<int, Strack> joinStracks(const vector<Strack>& trackVector,\n        unordered_map<int, Strack>& trackMap, bool inplace);\n\n};\n\n\nvector<Strack> ByteTrackerImpl::update(vector<Detection> &objects)\n{\n\n    // Detetions, Dk = Detections(fk)\n    vector<Strack> detections; // consider changing to cv::Mat_<Strack>\n    vector<Strack> detectionsLow;\n    vector<Strack> remainDets;\n    vector<Strack> activatedStracks;\n    vector<Strack> reRemainTracks;\n\n    getDetections(objects, detections, detectionsLow); // objects -> D and Dlow\n\n    vector<Strack> inactiveStracks;\n    vector<Strack> trackedStracks;\n\n    addNewDetectedTracks(trackedStracks_, inactiveStracks, trackedStracks); // trackedStracks_ -> inactive and active\n\n    unordered_map<int, Strack> strackPool;\n    strackPool = joinStracks(trackedStracks, lostStracks_, false);\n    // remember that in the first association we consider the lost tracks too\n    // we need to predict the tracks to do association\n    // it updates strackPool with prediction, maybe pass strackPool by reference\n    for (auto &track : strackPool)\n    {\n        cv::Mat prediction = track.second.predict(); // cx cy w h\n        prediction.at<float>(0, 0) -= prediction.at<float>(2, 0);\n        prediction.at<float>(1, 0) -= prediction.at<float>(3, 0);\n        track.second.setTlwh(prediction);\n    }\n\n    // getting map keys from the indexes\n    unordered_map<int, int> indexToKey;\n    int index = 0;\n    for (const auto &pair : strackPool)\n    {\n        int key = pair.first;\n        indexToKey[index] = key;\n        ++index;\n    }\n\n    // First association with IoU\n    vector<vector<float>> dists; // IoU distances, maybe change it to mat type?\n    dists = getCostMatrix(strackPool, detections);\n\n    vector<Strack> remainTracks;\n    vector<int> strackIndex;\n    vector<int> detectionsIndex;\n    map<int, int> matches;\n\n    matches = lapjv(dists); // returns a map (track_i,matched_det_index)\n    // cout << \"\\n Num of matches: \" << matches.size();\n\n    // Find unmatched track indexes\n    for (int trackIndex = 0; trackIndex < static_cast<int>(strackPool.size()); ++trackIndex)\n    {\n        if (matches.find(trackIndex) == matches.end())\n        {\n            strackIndex.push_back(trackIndex);\n        }\n    }\n\n    // Find unmatched detection indexes\n    for (int detectionIndex = 0; detectionIndex < static_cast<int>(detections.size());\n        ++detectionIndex)\n    {\n        bool matched = false;\n        for (const auto &match : matches)\n        {\n            int matchedDetectionIndex = match.second;\n            if (detectionIndex == matchedDetectionIndex)\n            {\n                matched = true;\n                break;\n            }\n        }\n        if (!matched)\n        {\n            detectionsIndex.push_back(detectionIndex);\n        }\n    }\n\n    // remain tracks and dets\n    for (int i = 0; i < static_cast<int>(strackIndex.size()); i++)\n    {\n        int key = indexToKey[strackIndex[i]];\n        Strack track = strackPool[key];\n        remainTracks.push_back(track);\n    }\n    for (int j = 0; j < static_cast<int>(detectionsIndex.size()); j++)\n    {\n        remainDets.push_back(detections[detectionsIndex[j]]);\n    }\n\n    for (auto &pair : matches) // row\n    {\n        int key = indexToKey[pair.first];\n        Strack &track = strackPool[key];\n        Strack &detection = detections[pair.second];\n\n        // if it's tracked, update it, else reactivate it\n        if (track.getState() == TrackState::Tracked)\n        {\n            track.update(detection);\n            activatedStracks.push_back(track);\n        }\n        else\n        {\n            track.reactivate(detection, frame_);\n            activatedStracks.push_back(track);\n            lostStracks_.erase(track.getId());\n        }\n    }\n\n    dists = getCostMatrix(remainTracks, detectionsLow);\n    strackIndex.clear();\n    detectionsIndex.clear();\n    matches = lapjv(dists);\n\n    // cout << \"\\n Num of low matches: \" << matches.size();\n\n    // Find unmatched track indexes\n    for (int trackIndex = 0; trackIndex < static_cast<int>(remainTracks.size()); ++trackIndex)\n    {\n        if (matches.find(trackIndex) == matches.end())\n        {\n            strackIndex.push_back(trackIndex);\n        }\n    }\n\n    // Find unmatched detection indexes\n    for (int detectionIndex = 0; detectionIndex < static_cast<int>(detectionsLow.size());\n         ++detectionIndex)\n    {\n        bool matched = false;\n        for (const auto &match : matches)\n        {\n            int matchedDetectionIndex = match.second;\n            if (detectionIndex == matchedDetectionIndex)\n            {\n                matched = true;\n                break;\n            }\n        }\n        if (!matched)\n        {\n            detectionsIndex.push_back(detectionIndex);\n        }\n    }\n\n    for (int i = 0; i < static_cast<int>(strackIndex.size()); i++)\n    {\n        reRemainTracks.push_back(remainTracks[strackIndex[i]]);\n    }\n\n    for (auto pair : matches) // row\n    {\n        Strack &track = remainTracks[pair.first];\n        Strack &detection = detectionsLow[pair.second];\n\n        // if it's tracked, update it, else re_activate it\n        if (track.getState() == TrackState::Tracked)\n        {\n            track.update(detection);\n            activatedStracks.push_back(track);\n        }\n        else\n        {\n            track.reactivate(detection, frame_);\n            activatedStracks.push_back(track);\n            lostStracks_.erase(track.getId());\n        }\n    }\n\n    // initialize new tracks\n    for (int i = 0; i < static_cast<int>(remainDets.size()); i++)\n    {\n        Strack newTrack = remainDets[i];\n        newTrack.activate(getFrame(), lastId_++);\n        activatedStracks.push_back(newTrack);\n    }\n    joinStracks(activatedStracks, trackedStracks_, true); //\"true\" is replacing in place\n    joinStracks(reRemainTracks, lostStracks_, true);\n\n    // deal with lost tracks and save them in an attribute\n    vector<int> keysToRemove;\n    for (auto &track : lostStracks_)\n    {\n        track.second.incrementTrackletLen();\n        if ((track.second.getTrackletLen()) >maxTimeLost_)\n            keysToRemove.push_back(track.first);\n        else\n            track.second.setState(TrackState::Lost);\n    }\n\n    for (int key : keysToRemove)\n    {\n        lostStracks_.erase(key);\n    }\n\n    vector<Strack> ret;\n    for (const auto &pair : trackedStracks_)\n    {\n        const Strack &strack = pair.second;\n        ret.push_back(strack);\n    }\n\n    return ret;\n}\n\nvoid ByteTrackerImpl::getDetections(vector<Detection> &objects, vector<Strack> &detections, \n    vector<Strack> &detectionsLow)\n{\n    frame_++; // update frame\n    for (const auto &obj : objects)\n    {\n        Strack strack(obj.box, obj.confidence);\n        if (obj.confidence >= trackThreshold_) // Dhigh or Dlow\n        {\n            detections.push_back(strack);\n        }\n        else\n        {\n            detectionsLow.push_back(strack);\n        }\n    }\n}\n\nvoid ByteTrackerImpl::addNewDetectedTracks(unordered_map<int, Strack> trackedMap, \n    vector<Strack> &inactiveStracks, vector<Strack> &trackedStracks)\n{\n    // checks if the trackedStracks are activated to keep them in the vector(same name)\n    for (auto pair : trackedMap)\n    {\n        Strack track = pair.second;\n        if (track.getState() == TrackState::Tracked)\n            trackedStracks.push_back(track);\n        else\n            inactiveStracks.push_back(track);\n    }\n}\n\nMat ByteTrackerImpl::getCostMatrix(vector<Strack> &atracks, vector<Strack> &btracks)\n{\n    Mat costMatrix;\n    if (atracks.size() == 0 || btracks.size() == 0)\n    {\n        return costMatrix; // returns empty matrix\n    }\n\n    vector<Rect> atlwhs, btlwhs;\n    for (auto& track : atracks)\n    {\n        atlwhs.push_back(track.getTlwh());\n    }\n    for (auto& track : btracks)\n    {\n        btlwhs.push_back(track.getTlwh());\n    }\n\n    costMatrix = calculateIous(atlwhs, btlwhs);\n    subtract(1, costMatrix, costMatrix); //costMatrix = 1 - costMatrix\n\n    return costMatrix;\n}\n\nMat ByteTrackerImpl::getCostMatrix(unordered_map<int, Strack> &atracks, vector<Strack> &btracks)\n{\n    Mat costMatrix;\n    if (atracks.size() == 0 && btracks.size() == 0)\n    {\n        return costMatrix; // returns empty matrix\n    }\n\n    vector<Rect> atlwhs, btlwhs;\n    for (auto &pair : atracks)\n    {\n        Rect tlwh = pair.second.getTlwh();\n        atlwhs.push_back(tlwh);\n    }\n\n    for (auto &track : btracks)\n    {\n        Rect tlwh = track.getTlwh();\n        btlwhs.push_back(tlwh);\n    }\n\n    costMatrix = calculateIous(atlwhs, btlwhs);\n    subtract(1, costMatrix, costMatrix); //costMatrix = 1 - costMatrix\n\n    return costMatrix;\n}\n\n\nMat ByteTrackerImpl::calculateIous(vector<Rect> &atlwhs, vector<Rect> &btlwhs)\n{\n    Mat calculateIous;\n    if (atlwhs.empty() || btlwhs.empty())\n    {\n        return calculateIous;\n    }\n\n    calculateIous.create(static_cast<int>(atlwhs.size()), static_cast<int>(btlwhs.size()), CV_32F);\n    \n    // bbox_ious\n    for (int i = 0; i < static_cast<int>(atlwhs.size()); ++i)\n    {\n        for (int j = 0; j < static_cast<int>(btlwhs.size()); ++j)\n        {\n            cv::Rect intersection = atlwhs[i] & btlwhs[j];\n            cv::Rect unionRect = atlwhs[i] | btlwhs[j];\n            float intersectionArea = intersection.area();\n            float unionArea = unionRect.area();\n            calculateIous.at<float>(i, j) = intersectionArea / unionArea;\n        }\n    }\n\n    return calculateIous;\n}\n\nunordered_map<int, Strack> ByteTrackerImpl::joinStracks(\n    const vector<Strack>& trackA, vector<Strack>& trackB)\n{\n    unordered_map<int, Strack> joinedTracks;\n\n    for (const auto &track : trackA)\n    {\n        joinedTracks.emplace(track.getId(), track);\n    }\n\n    for (const auto &track : trackB)\n    {\n        joinedTracks.emplace(track.getId(), track);\n    }\n\n    return joinedTracks;\n}\n\n// overload to receive a hashmap\nunordered_map<int, Strack> ByteTrackerImpl::joinStracks(const vector<Strack>& trackVector,\n    unordered_map<int, Strack>& trackMap, bool inplace)\n{\n    if (inplace)\n    {\n        for (const auto& track : trackVector)\n        {\n            trackMap.emplace(track.getId(), track);\n        }\n        return trackMap;\n    }\n\n    unordered_map<int, Strack> joinedTracks = trackMap;\n    for (const auto &track : trackVector)\n    {\n        joinedTracks.emplace(track.getId(), track);\n    }\n\n    return joinedTracks;\n\n}\n\n\n\nmap<int, int> ByteTrackerImpl::lapjv(vector<vector<float>> &cost)\n{\n    map<int, int> ret;\n    if (cost.size() == 0 || cost[0].size() == 0)\n        return ret;\n    int maxI = cost.size();\n    int maxJ = cost[0].size();\n    int n = max(maxJ, maxI);\n    double **cost_ptr;\n    double *u = new double[sizeof(double) * n];\n    double *v = new double[sizeof(double) * n];\n    int *x_c = new int[n];\n    int *y_c = new int[n];\n    cost_ptr = new double *[sizeof(double *) * n];",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1259283684",
        "repo_full_name": "opencv/opencv",
        "pr_number": 23960,
        "pr_file": "modules/video/src/tracking/bytetracker.cpp",
        "discussion_id": "1259283684",
        "commented_code": "@@ -0,0 +1,533 @@\n+// This file is part of OpenCV project.\n+// It is subject to the license terms in the LICENSE file found in the top-level directory\n+// of this distribution and at http://opencv.org/license.html.\n+\n+\n+\n+#include \"../precomp.hpp\"\n+\n+//#include \"opencv2/video/detail/bytetracker.hpp\"\n+// /#include \"opencv2/video/detail/bytetracker_strack.hpp\"\n+#include \"opencv2/video/detail/lapjv.hpp\"\n+#include \"opencv2/video/detail/tracking.detail.hpp\"\n+#include <unordered_map>\n+\n+// #include \"detail/bytetracker.hpp\"\n+// #include \"detail/bytetracker_strack.hpp\"\n+// #include \"detail/lapjv.hpp\"\n+\n+#ifdef HAVE_OPENCV_DNN\n+#include \"opencv2/dnn.hpp\"\n+#endif\n+\n+using namespace std;\n+using namespace cv;\n+\n+namespace cv {\n+\n+\n+//using cv::detail::tracking::Strack;\n+//using cv::detail::tracking::Detection;\n+//using cv::detail::tracking::TrackState;\n+\n+\n+\n+ByteTracker::ByteTracker()\n+{\n+    //nothing\n+}\n+\n+ByteTracker::~ByteTracker()\n+{\n+    //nothing\n+}\n+\n+ByteTracker::Params::Params()\n+{\n+    frameRate = 30;\n+    frameBuffer = 30;\n+}\n+        \n+    \n+\n+\n+\n+class ByteTrackerImpl : public ByteTracker\n+{ \n+public:\n+    //ByteTracker(int, int);\n+    ByteTrackerImpl(const ByteTracker::Params& parameters) : params_(parameters)\n+    {\n+        trackThreshold_ = 0.5f;\n+        matchThreshold_ = 0.7f;\n+        lastId_ = 0;\n+        frame_ = 0;\n+        maxTimeLost_ = static_cast<int>(params_.frameRate / 30.0f * params_.frameBuffer);\n+    }\n+\n+    void init(InputArray image, const Rect& boundingBox);\n+    //std::vector<std::vector<float>> update(std::vector<std::vector<float>>)\n+    vector<Strack> update(vector<Detection>& objects);\n+    //Scalar get_color(int idx);\n+    int getFrame();\n+    map<int, int> lapjv(vector<vector<float>> &cost);\n+\n+protected:\n+    ByteTracker::Params params_;\n+    float trackThreshold_;\n+    float matchThreshold_;\n+    unordered_map<int, Strack> trackedStracks_;\n+    unordered_map<int, Strack> lostStracks_;\n+    int lastId_;\n+    int frame_;\n+    int maxTimeLost_;\n+    KalmanFilter kalmanFilter_;\n+\n+    void getDetections(vector<Detection>& Objects, vector<Strack>& detections, \n+        vector<Strack>& detectionsLow);\n+\n+\n+    void addNewDetectedTracks(unordered_map<int, Strack> trackedMap,\n+        vector<Strack>& inactiveStracks, vector<Strack>& trackedStracks);\n+\n+\n+    Mat getCostMatrix(vector<Strack>& tracks, vector<Strack>& btracks);\n+    Mat getCostMatrix(unordered_map<int, Strack>& atracks, vector<Strack> &btracks);\n+\n+        \n+    Mat calculateIous(vector<Rect>& atlwhs, vector<Rect> &btlwhs);\n+\n+\n+    unordered_map<int, Strack> joinStracks(const vector<Strack>& trackA, vector<Strack>& trackB);\n+    unordered_map<int, Strack> joinStracks(const vector<Strack>& trackVector,\n+        unordered_map<int, Strack>& trackMap, bool inplace);\n+\n+};\n+\n+\n+vector<Strack> ByteTrackerImpl::update(vector<Detection> &objects)\n+{\n+\n+    // Detetions, Dk = Detections(fk)\n+    vector<Strack> detections; // consider changing to cv::Mat_<Strack>\n+    vector<Strack> detectionsLow;\n+    vector<Strack> remainDets;\n+    vector<Strack> activatedStracks;\n+    vector<Strack> reRemainTracks;\n+\n+    getDetections(objects, detections, detectionsLow); // objects -> D and Dlow\n+\n+    vector<Strack> inactiveStracks;\n+    vector<Strack> trackedStracks;\n+\n+    addNewDetectedTracks(trackedStracks_, inactiveStracks, trackedStracks); // trackedStracks_ -> inactive and active\n+\n+    unordered_map<int, Strack> strackPool;\n+    strackPool = joinStracks(trackedStracks, lostStracks_, false);\n+    // remember that in the first association we consider the lost tracks too\n+    // we need to predict the tracks to do association\n+    // it updates strackPool with prediction, maybe pass strackPool by reference\n+    for (auto &track : strackPool)\n+    {\n+        cv::Mat prediction = track.second.predict(); // cx cy w h\n+        prediction.at<float>(0, 0) -= prediction.at<float>(2, 0);\n+        prediction.at<float>(1, 0) -= prediction.at<float>(3, 0);\n+        track.second.setTlwh(prediction);\n+    }\n+\n+    // getting map keys from the indexes\n+    unordered_map<int, int> indexToKey;\n+    int index = 0;\n+    for (const auto &pair : strackPool)\n+    {\n+        int key = pair.first;\n+        indexToKey[index] = key;\n+        ++index;\n+    }\n+\n+    // First association with IoU\n+    vector<vector<float>> dists; // IoU distances, maybe change it to mat type?\n+    dists = getCostMatrix(strackPool, detections);\n+\n+    vector<Strack> remainTracks;\n+    vector<int> strackIndex;\n+    vector<int> detectionsIndex;\n+    map<int, int> matches;\n+\n+    matches = lapjv(dists); // returns a map (track_i,matched_det_index)\n+    // cout << \"\\n Num of matches: \" << matches.size();\n+\n+    // Find unmatched track indexes\n+    for (int trackIndex = 0; trackIndex < static_cast<int>(strackPool.size()); ++trackIndex)\n+    {\n+        if (matches.find(trackIndex) == matches.end())\n+        {\n+            strackIndex.push_back(trackIndex);\n+        }\n+    }\n+\n+    // Find unmatched detection indexes\n+    for (int detectionIndex = 0; detectionIndex < static_cast<int>(detections.size());\n+        ++detectionIndex)\n+    {\n+        bool matched = false;\n+        for (const auto &match : matches)\n+        {\n+            int matchedDetectionIndex = match.second;\n+            if (detectionIndex == matchedDetectionIndex)\n+            {\n+                matched = true;\n+                break;\n+            }\n+        }\n+        if (!matched)\n+        {\n+            detectionsIndex.push_back(detectionIndex);\n+        }\n+    }\n+\n+    // remain tracks and dets\n+    for (int i = 0; i < static_cast<int>(strackIndex.size()); i++)\n+    {\n+        int key = indexToKey[strackIndex[i]];\n+        Strack track = strackPool[key];\n+        remainTracks.push_back(track);\n+    }\n+    for (int j = 0; j < static_cast<int>(detectionsIndex.size()); j++)\n+    {\n+        remainDets.push_back(detections[detectionsIndex[j]]);\n+    }\n+\n+    for (auto &pair : matches) // row\n+    {\n+        int key = indexToKey[pair.first];\n+        Strack &track = strackPool[key];\n+        Strack &detection = detections[pair.second];\n+\n+        // if it's tracked, update it, else reactivate it\n+        if (track.getState() == TrackState::Tracked)\n+        {\n+            track.update(detection);\n+            activatedStracks.push_back(track);\n+        }\n+        else\n+        {\n+            track.reactivate(detection, frame_);\n+            activatedStracks.push_back(track);\n+            lostStracks_.erase(track.getId());\n+        }\n+    }\n+\n+    dists = getCostMatrix(remainTracks, detectionsLow);\n+    strackIndex.clear();\n+    detectionsIndex.clear();\n+    matches = lapjv(dists);\n+\n+    // cout << \"\\n Num of low matches: \" << matches.size();\n+\n+    // Find unmatched track indexes\n+    for (int trackIndex = 0; trackIndex < static_cast<int>(remainTracks.size()); ++trackIndex)\n+    {\n+        if (matches.find(trackIndex) == matches.end())\n+        {\n+            strackIndex.push_back(trackIndex);\n+        }\n+    }\n+\n+    // Find unmatched detection indexes\n+    for (int detectionIndex = 0; detectionIndex < static_cast<int>(detectionsLow.size());\n+         ++detectionIndex)\n+    {\n+        bool matched = false;\n+        for (const auto &match : matches)\n+        {\n+            int matchedDetectionIndex = match.second;\n+            if (detectionIndex == matchedDetectionIndex)\n+            {\n+                matched = true;\n+                break;\n+            }\n+        }\n+        if (!matched)\n+        {\n+            detectionsIndex.push_back(detectionIndex);\n+        }\n+    }\n+\n+    for (int i = 0; i < static_cast<int>(strackIndex.size()); i++)\n+    {\n+        reRemainTracks.push_back(remainTracks[strackIndex[i]]);\n+    }\n+\n+    for (auto pair : matches) // row\n+    {\n+        Strack &track = remainTracks[pair.first];\n+        Strack &detection = detectionsLow[pair.second];\n+\n+        // if it's tracked, update it, else re_activate it\n+        if (track.getState() == TrackState::Tracked)\n+        {\n+            track.update(detection);\n+            activatedStracks.push_back(track);\n+        }\n+        else\n+        {\n+            track.reactivate(detection, frame_);\n+            activatedStracks.push_back(track);\n+            lostStracks_.erase(track.getId());\n+        }\n+    }\n+\n+    // initialize new tracks\n+    for (int i = 0; i < static_cast<int>(remainDets.size()); i++)\n+    {\n+        Strack newTrack = remainDets[i];\n+        newTrack.activate(getFrame(), lastId_++);\n+        activatedStracks.push_back(newTrack);\n+    }\n+    joinStracks(activatedStracks, trackedStracks_, true); //\"true\" is replacing in place\n+    joinStracks(reRemainTracks, lostStracks_, true);\n+\n+    // deal with lost tracks and save them in an attribute\n+    vector<int> keysToRemove;\n+    for (auto &track : lostStracks_)\n+    {\n+        track.second.incrementTrackletLen();\n+        if ((track.second.getTrackletLen()) >maxTimeLost_)\n+            keysToRemove.push_back(track.first);\n+        else\n+            track.second.setState(TrackState::Lost);\n+    }\n+\n+    for (int key : keysToRemove)\n+    {\n+        lostStracks_.erase(key);\n+    }\n+\n+    vector<Strack> ret;\n+    for (const auto &pair : trackedStracks_)\n+    {\n+        const Strack &strack = pair.second;\n+        ret.push_back(strack);\n+    }\n+\n+    return ret;\n+}\n+\n+void ByteTrackerImpl::getDetections(vector<Detection> &objects, vector<Strack> &detections, \n+    vector<Strack> &detectionsLow)\n+{\n+    frame_++; // update frame\n+    for (const auto &obj : objects)\n+    {\n+        Strack strack(obj.box, obj.confidence);\n+        if (obj.confidence >= trackThreshold_) // Dhigh or Dlow\n+        {\n+            detections.push_back(strack);\n+        }\n+        else\n+        {\n+            detectionsLow.push_back(strack);\n+        }\n+    }\n+}\n+\n+void ByteTrackerImpl::addNewDetectedTracks(unordered_map<int, Strack> trackedMap, \n+    vector<Strack> &inactiveStracks, vector<Strack> &trackedStracks)\n+{\n+    // checks if the trackedStracks are activated to keep them in the vector(same name)\n+    for (auto pair : trackedMap)\n+    {\n+        Strack track = pair.second;\n+        if (track.getState() == TrackState::Tracked)\n+            trackedStracks.push_back(track);\n+        else\n+            inactiveStracks.push_back(track);\n+    }\n+}\n+\n+Mat ByteTrackerImpl::getCostMatrix(vector<Strack> &atracks, vector<Strack> &btracks)\n+{\n+    Mat costMatrix;\n+    if (atracks.size() == 0 || btracks.size() == 0)\n+    {\n+        return costMatrix; // returns empty matrix\n+    }\n+\n+    vector<Rect> atlwhs, btlwhs;\n+    for (auto& track : atracks)\n+    {\n+        atlwhs.push_back(track.getTlwh());\n+    }\n+    for (auto& track : btracks)\n+    {\n+        btlwhs.push_back(track.getTlwh());\n+    }\n+\n+    costMatrix = calculateIous(atlwhs, btlwhs);\n+    subtract(1, costMatrix, costMatrix); //costMatrix = 1 - costMatrix\n+\n+    return costMatrix;\n+}\n+\n+Mat ByteTrackerImpl::getCostMatrix(unordered_map<int, Strack> &atracks, vector<Strack> &btracks)\n+{\n+    Mat costMatrix;\n+    if (atracks.size() == 0 && btracks.size() == 0)\n+    {\n+        return costMatrix; // returns empty matrix\n+    }\n+\n+    vector<Rect> atlwhs, btlwhs;\n+    for (auto &pair : atracks)\n+    {\n+        Rect tlwh = pair.second.getTlwh();\n+        atlwhs.push_back(tlwh);\n+    }\n+\n+    for (auto &track : btracks)\n+    {\n+        Rect tlwh = track.getTlwh();\n+        btlwhs.push_back(tlwh);\n+    }\n+\n+    costMatrix = calculateIous(atlwhs, btlwhs);\n+    subtract(1, costMatrix, costMatrix); //costMatrix = 1 - costMatrix\n+\n+    return costMatrix;\n+}\n+\n+\n+Mat ByteTrackerImpl::calculateIous(vector<Rect> &atlwhs, vector<Rect> &btlwhs)\n+{\n+    Mat calculateIous;\n+    if (atlwhs.empty() || btlwhs.empty())\n+    {\n+        return calculateIous;\n+    }\n+\n+    calculateIous.create(static_cast<int>(atlwhs.size()), static_cast<int>(btlwhs.size()), CV_32F);\n+    \n+    // bbox_ious\n+    for (int i = 0; i < static_cast<int>(atlwhs.size()); ++i)\n+    {\n+        for (int j = 0; j < static_cast<int>(btlwhs.size()); ++j)\n+        {\n+            cv::Rect intersection = atlwhs[i] & btlwhs[j];\n+            cv::Rect unionRect = atlwhs[i] | btlwhs[j];\n+            float intersectionArea = intersection.area();\n+            float unionArea = unionRect.area();\n+            calculateIous.at<float>(i, j) = intersectionArea / unionArea;\n+        }\n+    }\n+\n+    return calculateIous;\n+}\n+\n+unordered_map<int, Strack> ByteTrackerImpl::joinStracks(\n+    const vector<Strack>& trackA, vector<Strack>& trackB)\n+{\n+    unordered_map<int, Strack> joinedTracks;\n+\n+    for (const auto &track : trackA)\n+    {\n+        joinedTracks.emplace(track.getId(), track);\n+    }\n+\n+    for (const auto &track : trackB)\n+    {\n+        joinedTracks.emplace(track.getId(), track);\n+    }\n+\n+    return joinedTracks;\n+}\n+\n+// overload to receive a hashmap\n+unordered_map<int, Strack> ByteTrackerImpl::joinStracks(const vector<Strack>& trackVector,\n+    unordered_map<int, Strack>& trackMap, bool inplace)\n+{\n+    if (inplace)\n+    {\n+        for (const auto& track : trackVector)\n+        {\n+            trackMap.emplace(track.getId(), track);\n+        }\n+        return trackMap;\n+    }\n+\n+    unordered_map<int, Strack> joinedTracks = trackMap;\n+    for (const auto &track : trackVector)\n+    {\n+        joinedTracks.emplace(track.getId(), track);\n+    }\n+\n+    return joinedTracks;\n+\n+}\n+\n+\n+\n+map<int, int> ByteTrackerImpl::lapjv(vector<vector<float>> &cost)\n+{\n+    map<int, int> ret;\n+    if (cost.size() == 0 || cost[0].size() == 0)\n+        return ret;\n+    int maxI = cost.size();\n+    int maxJ = cost[0].size();\n+    int n = max(maxJ, maxI);\n+    double **cost_ptr;\n+    double *u = new double[sizeof(double) * n];\n+    double *v = new double[sizeof(double) * n];\n+    int *x_c = new int[n];\n+    int *y_c = new int[n];\n+    cost_ptr = new double *[sizeof(double *) * n];",
        "comment_created_at": "2023-07-11T07:07:13+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Pleas use `cv::AutoBuffer` or `std::vector` for temporary buffers instead new/delete to prevent memory leaks. `cv::AutoBuffer` is preferable, it may use stack space, if buffer is small enough.",
        "pr_file_module": null
      }
    ]
  }
]