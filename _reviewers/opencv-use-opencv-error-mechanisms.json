[
  {
    "discussion_id": "2153806951",
    "pr_number": 27369,
    "pr_file": "modules/imgproc/src/min_enclosing_convex_polygon.cpp",
    "created_at": "2025-06-18T07:03:02+00:00",
    "commented_code": "/*M///////////////////////////////////////////////////////////////////////////////////////\n //\n //  This file is part of OpenCV project.\n //  It is subject to the license terms in the LICENSE file found in the top-level directory of this\n //  distribution and at http://opencv.org/license.html.\n //\n //\n //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n //\n //  By downloading, copying, installing or using the software you agree to this license.\n //  If you do not agree to this license, do not download, install,\n //  copy or use the software.\n //\n //  INFORMATION REGARDING THE CONTRIBUTION:\n //\n //  Author: Sara Kuhnert\n //  Created: 20.05.2025\n //  E-mail: <sara.kuhnert[AT]gmx.de>\n //\n //  THE IMPLEMENTATION OF THE MODULES IS BASED ON THE FOLLOWING PAPER:\n //\n //  [1] A. Aggarwal, J. S. Chang, Chee K. Yap: \"Minimum area circumscribing Polygons\", The Visual\n //  Computer, 1:112-117, 1985\n //\n //  The overall complexity of the algorithm is theta(n^2log(n)log(k)) where \"n\" represents the number\n //  of vertices in the input convex polygon and \"k\" the number of vertices in the output polygon.\n //\n //\n //\n //                           License Agreement\n //                For Open Source Computer Vision Library\n //\n // Copyright (C) 2000, Intel Corporation, all rights reserved.\n // Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n // Copyright (C) 2020, Sara Kuhnert, all rights reserved.\n // Third party copyrights are property of their respective owners.\n //\n // Redistribution and use in source and binary forms, with or without modification,\n // are permitted provided that the following conditions are met:\n //\n //   * Redistribution's of source code must retain the above copyright notice,\n //     this list of conditions and the following disclaimer.\n //\n //   * Redistribution's in binary form must reproduce the above copyright notice,\n //     this list of conditions and the following disclaimer in the documentation\n //     and/or other materials provided with the distribution.\n //\n //   * The name of the copyright holders may not be used to endorse or promote products\n //     derived from this software without specific prior written permission.\n //\n // This software is provided by the copyright holders and contributors \"as is\" and\n // any express or implied warranties, including, but not limited to, the implied\n // warranties of merchantability and fitness for a particular purpose are disclaimed.\n // In no event shall the Intel Corporation or contributors be liable for any direct,\n // indirect, incidental, special, exemplary, or consequential damages\n // (including, but not limited to, procurement of substitute goods or services;\n // loss of use, data, or profits; or business interruption) however caused\n // and on any theory of liability, whether in contract, strict liability,\n // or tort (including negligence or otherwise) arising in any way out of\n // the use of this software, even if advised of the possibility of such damage.\n //\n //M*/\n\n#include \"precomp.hpp\"\n#include <opencv2/imgproc.hpp>\n\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <numeric>\n#include <set>\n#include <iostream>\n#include <cstdlib>\n\n\n\n//////////////////////////// Constants definitions ////////////////////////////\n\n#define EPSILON 1e-6\n\n\n///////////////////////// Helper function declarations /////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\nstatic void findMinEnclosingPolygon(cv::InputArray points,\n                                    const int &k,\n                                    CV_OUT cv::OutputArray &kgon,\n                                    CV_OUT double &area);\n\nstatic void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n                                    const int &k,\n                                    cv::OutputArray &kgon,\n                                    double &area);\n\nstatic void findMinAreaPolygon(const std::vector<cv::Point2f> &ngon,\n                                std::vector<cv::Point2f> &minPolygon,\n                                double &area,\n                                int k);\n\n} //namespace\n\n\n//////////////////////// Class and struct declarations ////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Intersection point of two sides with its position relative to the polygon\n/*!\n * @param point         Intersection point of the two sides\n * @param position      Is the intersection point a valid solution?\n */\nstruct IntersectionPoint\n{\n    cv::Point2f point = {-1.0, -1.0};\n    bool position = false;\n\n    IntersectionPoint() = default;\n    IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n                      const cv::Point2f& c, const cv::Point2f& d);\n    IntersectionPoint(int i, int j, const std::vector<cv::Point2f>& ngon);\n};\n\n//! Container for the information about the intersection point of two flush sides\n/*!\n * @param intersection  Instance of IntersectionPoint\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct FlushIntersect\n{\n    IntersectionPoint intersection = {};\n    double extra_area = std::numeric_limits<double>::max();\n    bool done = false;\n};\n\n//! Container for the information about a balanced side between two points\n/*!\n * @param pi            First intersection point\n * @param pj            Second intersection point\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param flush         Flush is a special case of balanced. If the balanced side is also flush, this indicates which of the sides of the ngon it is flush with. The default for not flush sides is -1.\n * @param position      Is the balanced side a valid solution?\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct BalancedIntersect\n{\n    cv::Point2f pi = {-1, -1};\n    cv::Point2f pj = {-1, -1};\n    double extra_area = std::numeric_limits<double>::max();\n    int flush = -1;\n    bool position = false;\n    bool done = false;\n};\n\n//! Container for the best segment between two points\n/*!\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param side          Side of the ngon to which it is flush (if flush is true) or edge of the ngon which it is touching (if flush is false)\n * @param flush         True if it is flush. If false, it is balanced but not flush\n * @param exists        Does a valid solution exist?\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct Segment\n{\n    double extra_area = std::numeric_limits<double>::max();\n    int side = -1;\n    bool flush = false;\n    bool exists = false;\n    bool done = false;\n};\n\n//! Combination of selected sides and their corresponding chains, which generates the kgon with the minimum area\n/*!\n * @param area          Extra area that the minimal kgon is bigger than the input ngon\n * @param i             First side\n * @param j             Second side\n */\nstruct Minimum\n{\n    double area = std::numeric_limits<double>::max();\n    int i = -1;\n    int j = -1;\n};\n\n//! Container for a side of the minimal kgon\n/*!\n * @param side          Index of the side of the ngon which it is flush with or the vertex which it is touching\n * @param flush         Is this side flush?\n */\nstruct Side\n{\n    int side = -1;\n    bool flush = false;\n\n    Side() = default;\n    Side(int i, bool b);\n};\n\n//! Container for the minimal kgon\n/*!\n * @param sides         Indices of the corresponding sindes of the ngon\n * @param vertices      Vertices of the kgon\n * @param extra_area    Extra area that the minimal kgon is bigger than the input ngon\n * @param i, @param j   The chains which build the minimal kgon are formed between those two sides\n */\nstruct Kgon\n{\n    std::vector<Side> sides;\n    std::vector<cv::Point2f> vertices;\n    double extra_area = std::numeric_limits<double>::max();\n    int i = -1;\n    int j = -1;\n};\n\n//! Class for all the possible combinations of flush intersections of two sides of the input polygon\n/*!\n * @param ngon              Input polygon\n * @param intersections     Matrix of all possible flush intersections of two sides of the ngon\n * @param area_edges        Collection of the points that define the extra area of the kgon\n */\nclass FlushIntersections\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<FlushIntersect>> intersections;\n    std::vector<cv::Point2f> area_edges;\n\npublic:\n    FlushIntersections(const std::vector<cv::Point2f>& _ngon);\n    const FlushIntersect& lineIntersect(int i, int j);\n};\n\n//! Class for all the possible combinations of balanced intersections with two sides of the input polygon\n/*!\n * @param ngon                      Input polygon\n * @param balanced_intersections    atrix of all possible balanced intersections of two sides of the ngon\n * @param area_edges                Collection of the points that define the extra area of the kgon\n */\nclass BalancedIntersections\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<BalancedIntersect>> balanced_intersections;\n    std::vector<cv::Point2f> area_edges;\n\n    double extraArea ( int first, int last, const cv::Point2f& extra1, const cv::Point2f& extra2 );\n\n    BalancedIntersect flush(int i, int j, int e);\n\npublic:\n    BalancedIntersections(const std::vector<cv::Point2f>& _ngon);\n    BalancedIntersect balancedIntersect(int i, int j, int e);\n    void markAsDone(int i, int j);\n    const std::vector<BalancedIntersect>& operator[](size_t i) const;\n};\n\n//! Class for building the one-sided and h-sided chains and calculation the minimum enclosing polygon based on those chains\n/*!\n * @param ngon              Input polygon\n * @param single_sides      Matrix of the best one-sided chain for each combination of two sides of the ngon\n * @param middle_sides      Matrix of the middle side of each h-sided chain for all relevant h and each combination of two sides of the ngon\n * @param intersections     An instance of FlushIntersections to store already calculated flush intersections\n * @param balanced_inters   An instance of BalancedIntersections to store already calculated balanced intersections\n */\nclass Chains\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<Segment>> single_sides;\n    std::vector<std::vector<std::vector<Segment>>> middle_sides;\n    FlushIntersections intersections;\n    BalancedIntersections balanced_inters;\n\n    void findSingleE(int i, int j, int l, int r);\n    void singleSideImpl(int i, int j1, int j2);\n    void findMiddleE1(int i, int j, int l, int r);\n    void middleSideImpl1(int i, int j1, int j2);\n    void findMiddleE(int h, int i, int j, int l, int r);\n    void middleSideImpl(int h, int i, int j1, int j2);\n\npublic:\n    Chains(const std::vector<cv::Point2f>& _ngon, int k);\n\n    std::set<int> relevantChainLengths(int h);\n    void calcOneSidedChains();\n    void calcMiddleChains(int h);\n\n    Minimum minimumArea(int n, int k);\n    std::vector<Side> reconstructHSidedChain(int h, int i, int j);\n    std::vector<Side> findKSides(int k, int i, int j);\n    std::vector<cv::Point2f> findKVertices(std::vector<Side>& sides);\n\n};\n\n} //namespace\n\n\n//////////////////////// Class and struct constructors ////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Constructor for IntersectionPoint. Find the intersection point of two lines given by four points and decide whether it is on the correct side of the polygon\n/*!\n * @param a             First point of the first line\n * @param b             Second point of the first line\n * @param c             First point of the second line\n * @param d             Second point of the second line\n */\nIntersectionPoint::IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n                                     const cv::Point2f& c, const cv::Point2f& d)\n{\n    const cv::Point2f ab = b - a, cd = d - c, ac = c - a;\n    const double det = ab.cross(-cd);\n    if(std::abs (det) < EPSILON )\n        return;\n\n    const double loc = ac.cross(-cd) / det;\n    if(loc <= 0)\n        return;\n\n    point = a + loc * ab;\n    position = true;\n}\n\n//! Constructor for IntersectionPoint. Find the intersection point of two sides of the polygon based on the given side indices.\n/*!\n * @param i             Index of the first side\n * @param j             Index of the second side\n * @param ngon          Input polygon with n sides\n */\nIntersectionPoint::IntersectionPoint(int i, int j,\n                                     const std::vector<cv::Point2f>& ngon) :\n    IntersectionPoint(ngon[i],\n                      ngon[(i + 1) % ngon.size()],\n                      ngon[j],\n                      ngon[(j + 1) % ngon.size()])\n{}\n\n//! Constructor for FlushIntersections\n/*!\n * @param _ngon         Input polygon with n sides\n */\nFlushIntersections::FlushIntersections(const std::vector<cv::Point2f>& _ngon) :\n    ngon(_ngon),\n    intersections(ngon.size(),\n                  std::vector<FlushIntersect>(ngon.size()))\n{\n    area_edges.reserve(ngon.size());\n}\n\n//! Constructor for BalancedIntersections\n/*!\n * @param _ngon         Input polygon with n sides\n */\nBalancedIntersections::BalancedIntersections(const std::vector<cv::Point2f>& _ngon) :\nngon(_ngon),\nbalanced_intersections(ngon.size(),\n                        std::vector<BalancedIntersect>(ngon.size()))\n{\n    area_edges.reserve(ngon.size());\n}\n\n//! Constructor for Side. Assign a side index and weather it is flush or not.\n/*!\n * @param i             Side index\n * @param b             Is side i flush?\n */\nSide::Side(int i, bool b)\n{\n    side = i;\n    flush = b;\n}\n\n//! Constructor for Chains\n/*!\n * @param\n */\nChains::Chains(const std::vector<cv::Point2f>& _ngon, int k) :\n    ngon(_ngon),\n    single_sides(std::vector<std::vector<Segment>>(ngon.size(),\n                                                   std::vector<Segment>(ngon.size()))),\n    middle_sides(std::vector<std::vector<std::vector<Segment>>>(\n        k, std::vector<std::vector<Segment>>(ngon.size(),\n                                             std::vector<Segment>(ngon.size())))),\n    intersections(ngon),\n    balanced_inters(ngon)\n{}\n\n} //namespace\n\n\n////////////////////////// Class and struct functions //////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Find the intersection point of two sides, decide weather it is a valid point and if so calculate the extra area caused by that intersection.\n/*!\n * @param i             Index of the first side\n * @param j             Index of the second side\n */\nconst FlushIntersect& FlushIntersections::lineIntersect(int i, int j)\n{\n    FlushIntersect& itr = intersections[i][j];\n    if(itr.done)\n        return itr;\n\n    const size_t n = ngon.size();\n    if((i + 1) % n == j)\n    {\n        itr.intersection.point = ngon[j];\n        itr.intersection.position = true;\n        itr.extra_area = 0.0;\n        itr.done = true;\n        return itr;\n    }\n    itr.intersection = IntersectionPoint(i, j, ngon);\n    if(itr.intersection.position)\n    {\n        area_edges.resize(0);\n        for(int t = (i + 1) % n; t != (j + 1) % n; t = (t + 1) % n)\n        {\n            area_edges.push_back(ngon[t]);\n        }\n        area_edges.push_back(itr.intersection.point);\n        itr.extra_area = cv::contourArea(area_edges);\n        itr.done = true;\n    }\n    else\n    {\n        itr.extra_area = std::numeric_limits<double>::max();\n        itr.intersection.position = false;\n        itr.done = true;\n    }\n    return itr;\n}\n\n//! Calculate the added area that is enclosed by a sequence of consecutive vertices of the polygon and the intersection point of two sides.\n/*!\n * @param first         Index of the first point of the sequence\n * @param last          Index of the last point of the sequence\n * @param extra1        Last point of the sequence\n * @param extra2        Intersection point\n */\ndouble BalancedIntersections::extraArea(int first, int last,\n                                       const cv::Point2f& extra1,\n                                       const cv::Point2f& extra2)\n{\n    const size_t n = ngon.size();\n    area_edges.resize(0);\n    for(int t = first; t != last; t = (t + 1) % n)\n        area_edges.push_back(ngon[t]);\n\n    area_edges.push_back(extra1);\n    area_edges.push_back(extra2);\n\n    return cv::contourArea(area_edges);\n}\n\n//! Determine the intersection points of a flush side e that lies between sides i and j with these two sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n * @param e             Index of a side between i and j\n */\nBalancedIntersect BalancedIntersections::flush(int i, int j, int e)\n{\n    if(i == e)\n        std::logic_error(\"\");\n    if(j == e)\n        std::logic_error(\"\");\n\n    const size_t n = ngon.size();\n    const int before = (e - 1 + n) % n;\n    BalancedIntersect bi = balanced_intersections[i][j];\n\n    const IntersectionPoint left_e(i, e, ngon);\n    const IntersectionPoint right_e(e, j, ngon);\n\n    if(left_e.position == true && right_e.position == true)\n    {\n        double extra_area = extraArea((i + 1) % n, e, ngon[e], left_e.point);\n        if(extra_area < bi.extra_area)\n        {\n            extra_area += extraArea((e + 1) % n, j, ngon[j], right_e.point);\n            if(extra_area < bi.extra_area)\n            {\n                bi.extra_area = extra_area;\n                bi.pi = left_e.point;\n                bi.pj = right_e.point;\n                bi.position = true;\n                bi.flush = e;\n            }\n        }\n    }\n\n    if(before != i)\n    {\n        const IntersectionPoint left_before(i, before, ngon);\n        const IntersectionPoint right_before(before, j, ngon);\n        if(left_before.position == true && right_before.position == true)\n        {\n            double extra_area =\n            extraArea((i + 1) % n, before, ngon[before], left_before.point);\n\n            if(extra_area < bi.extra_area)\n            {\n                extra_area += extraArea(e, j, ngon[j], right_before.point);\n                if(extra_area < bi.extra_area)\n                {\n                    bi.extra_area = extra_area;\n                    bi.pi = left_before.point;\n                    bi.pj = right_before.point;\n                    bi.position = true;\n                    bi.flush = before;\n                }\n            }\n        }\n    }\n    return bi;\n}\n\n//! Determine the intersection points of a balanced side e that lies between sides i and j with these two sides. If no valid balanced edge is found, ccheck for flush sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n * @param e             Index of a side between i and j\n */\nBalancedIntersect BalancedIntersections::balancedIntersect(int i, int j, int e)\n{\n    if(balanced_intersections[i][j].done)\n        return balanced_intersections[i][j];\n\n    const size_t n = ngon.size();\n    if((i + 2) % n == j)\n    {\n        BalancedIntersect& bi = balanced_intersections[i][j];\n        bi.pi = ngon[(i + 1) % n];\n        bi.pj = ngon[j];\n        bi.flush = (i + 1) % n;\n        bi.position = true;\n        bi.extra_area = 0.0;\n        bi.done = true;\n        return bi;\n    }\n\n    const cv::Point2f p1 = ngon[i], p2 = ngon[(i + 1) % n], p3 = ngon[e],\n    p4 = ngon[j], p5 = ngon[(j + 1) % n];\n    const cv::Point2f dir12 = p2 - p1, dir45 = p5 - p4;\n    const double det = dir12.cross(dir45);\n    if(std::abs (det) < EPSILON )\n    {\n        flush(i, j, e);\n        return balanced_intersections[i][j];\n    }\n\n    BalancedIntersect bi;\n    cv::Point2f temp = 2 * p3 - p2 - p4;\n    const double s = temp.cross(dir45) / det;\n    const double t = temp.cross(dir12) / det;\n    if(s >= 0 && t >= 0)\n    {\n        bi.pi = p2 + dir12 * s;\n        bi.pj = p4 - dir45 * t;\n        bi.position = true;\n\n        const cv::Point2f dir_balanced = bi.pj - bi.pi,\n        dir_left = p3 - ngon[(e - 1 + n) % n],\n        dir_right = ngon[(e + 1) % n] - p3;\n\n        const double cross_left = dir_balanced.cross(dir_left),\n        cross_right = dir_balanced.cross(dir_right);\n        if((cross_left < 0 && cross_right < 0) || (cross_left > 0 && cross_right > 0))\n        {\n            BalancedIntersect reset;\n            bi = reset;\n            bi = flush(i, j, e);\n        }\n        else if(std::abs (cross_left) < EPSILON )\n        {\n            bi.flush = (e - 1 + n) % n;\n            bi.extra_area =\n            extraArea((i + 1) % n, (e - 1 + n) % n, ngon[(e - 1 + n) % n], bi.pi)\n            + extraArea(e, j, ngon[j], bi.pj);\n        }\n        else if(std::abs (cross_right) < EPSILON )\n        {\n            bi.flush = e;\n            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n            + extraArea((e + 1) % n, j, ngon[j], bi.pj);\n        }\n        else\n        {\n            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n            + extraArea(e, j, ngon[j], bi.pj);\n        }\n    }\n    else\n    {\n        flush(i, j, e);\n    }\n\n    if(bi.extra_area < balanced_intersections[i][j].extra_area)\n    {\n        balanced_intersections[i][j] = bi;\n    }\n    return bi;\n}\n\n//! Set function for the done attribute of BalancedIntersections\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n */\nvoid BalancedIntersections::markAsDone(int i, int j)\n{\n    balanced_intersections[i][j].done = true;\n}\n\n//! Operator to get a vector of elements from BalancedIntersections\n/*!\n * @param i             index of a side\n */\nconst std::vector<BalancedIntersect>& BalancedIntersections::operator[](\n    size_t i) const\n{\n    return balanced_intersections[i];\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the one sided chain with minimal extra area\n/*!\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findSingleE(int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = single_sides[i][j];\n    if (one.done)\n        return;\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        BalancedIntersect candidate = balanced_inters.balancedIntersect(i, j, e);\n        if(candidate.extra_area < min_area)\n        {\n            min_area = candidate.extra_area;\n            one.side = e;\n            one.extra_area = candidate.extra_area;\n            one.flush = false;\n            one.exists = true;\n        }\n    }\n    one.done = true;\n    balanced_inters.markAsDone(i, j);\n}\n\n//! Recursively repeat the search for the one sided chain with minimal extra area to shrink the boundaries of bigger distances\n/*!\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::singleSideImpl(int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = single_sides[i][j1].side < 0 ? (j1 + 1) %n : single_sides[i][j1].side;\n    int r = single_sides[i][j2].side < 0 ? (j2 - 1 + n) %n : single_sides[i][j2].side;\n\n    findSingleE(i, mid, l, r);\n    singleSideImpl(i, j1, mid);\n    singleSideImpl(i, mid, j2);\n\n    return;\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h = 1.\n/*!\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findMiddleE1(int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = middle_sides[1][i][j];\n    if (one.done)\n        return;\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        const FlushIntersect& before = intersections.lineIntersect(i, e);\n        if(!before.intersection.position)\n            continue;\n        const FlushIntersect& after = intersections.lineIntersect(e, j);\n        if(!after.intersection.position)\n            continue;\n\n        double tmp_area = before.extra_area + after.extra_area;\n        if(tmp_area < min_area)\n        {\n            min_area = tmp_area;\n            one.side = e;\n            one.extra_area = tmp_area;\n            one.exists = true;\n            one.flush = true;\n        }\n    }\n    one.done = true;\n}\n\n//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h = 1.\n/*!\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::middleSideImpl1(int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = middle_sides[1][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[1][i][j1].side;\n    int r = middle_sides[1][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[1][i][j2].side;\n\n    findMiddleE1(i, mid, l, r);\n    middleSideImpl1(i, j1, mid);\n    middleSideImpl1(i, mid, j2);\n\n    return;\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h > 1.\n/*!\n * @param h     Length of the h-sided chain\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findMiddleE(int h, int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = middle_sides[h][i][j];\n    if (one.done)\n        return;\n\n    const int dist = (i <= j ? (j - i) : (j + n - i));\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n\n    if(dist == 0)\n        throw std::logic_error(\"\");\n    if(dist - 1 < h)\n    {\n        one.done = true;\n        return;\n    }\n    if(dist - 1 == h)\n    {\n        one.side = (i + h_floor + 1) % n;\n        one.extra_area = 0.0;\n        one.exists = true;\n        one.flush = true;\n        one.done = true;\n        return;\n    }\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        const Segment& before = middle_sides[h_floor][i][e];\n        if (before.extra_area == std::numeric_limits<double>::max())\n            continue;\n        const Segment& after = middle_sides[h_ceil][e][j];\n        if(after.extra_area == std::numeric_limits<double>::max())\n            continue;\n\n        double tmp_area = before.extra_area + after.extra_area;\n        if(tmp_area < min_area)\n        {\n            min_area = tmp_area;\n            one.side = e;\n            one.extra_area = tmp_area;\n            one.exists = true;\n            one.flush = true;\n        }\n    }\n    one.done = true;\n}\n\n//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h > 1.\n/*!\n * @param h     Length of the h-sided chain\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::middleSideImpl(int h, int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = middle_sides[h][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[h][i][j1].side;\n    int r = middle_sides[h][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[h][i][j2].side;\n\n    findMiddleE(h, i, mid, l, r);\n    middleSideImpl(h, i, j1, mid);\n    middleSideImpl(h, i, mid, j2);\n\n    return;\n}\n\n//! Calculate the relevant chain lengths. Starting with a maximum chain length of h, down to a chain length of 1, only chains with half the length of the chain before are needed.\n/*!\n * @param h     Length of the longest chain (h = k - 3)\n */\nstd::set<int> Chains::relevantChainLengths(int h)\n{\n    if(h <= 1)\n        return {h};\n\n    std::set<int> hs = {h};\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n    std::set<int> h1 = relevantChainLengths(h_floor);\n    for(const int& hNew : h1)\n        hs.insert(hNew);\n    if (h_ceil != h_floor)\n    {\n        std::set<int> h2 = relevantChainLengths(h_ceil);\n        for(const int& hNew : h2)\n            hs.insert(hNew);\n    }\n    return hs;\n}\n\n//! Recursively calculate all the onesided chains for each combination of polygon sides.\n/*!\n */\nvoid Chains::calcOneSidedChains()\n{\n    const size_t n = ngon.size();\n    for(size_t i = 0; i < n; i++)\n    {\n        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n        findSingleE(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n        findSingleE(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n        singleSideImpl(i, j1, j2);\n    }\n}\n\n//! Recursively calculate the middle sides of the h-sided chains for all combinations of polygon sides.\n/*!\n * @param h     Length of the chains\n */\nvoid Chains::calcMiddleChains(int h)\n{\n    const size_t n = ngon.size();\n    if (h == 0)\n    {\n        for (size_t i = 0; i < n; i++)\n        {\n            for (size_t j = 0; j < n; j++)\n            {\n                Segment& one = middle_sides[h][i][j];\n                const FlushIntersect itrs = intersections.lineIntersect(i, j);\n\n                one.side = -1;\n                one.extra_area = itrs.extra_area;\n                one.exists = false;\n                one.flush = false;\n                one.done = true;\n            }\n        }\n        return;\n    }\n    if (h == 1)\n    {\n        for (size_t i = 0; i < n; i++)\n        {\n            int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n            findMiddleE1(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n            findMiddleE1(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n            middleSideImpl1(i, j1, j2);\n        }\n        return;\n    }\n\n    for (size_t i = 0; i < n; i++)\n    {\n        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n        findMiddleE(h, i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n        findMiddleE(h, i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n        middleSideImpl(h, i, j1, j2);\n    }\n}\n\n//! Find the i and j with the smallest extra area.\n/*!\n * @param n             Number of sides of the input polygon\n * @param k             Number of sides of the output polygon\n */\nMinimum Chains::minimumArea(int n, int k)\n{\n    Minimum min{};\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(!single_sides[i][j].exists || !middle_sides[k - 3][j][i].exists)\n                continue;\n\n            double tmp_area =\n            single_sides[i][j].extra_area + middle_sides[k - 3][j][i].extra_area;\n            if(tmp_area < min.area)\n            {\n                min.area = tmp_area;\n                min.i = i;\n                min.j = j;\n            }\n        }\n    }\n    return min;\n}\n\n//! Reconstruct the h-sided chain based on the two sides that give the smalles extra area.\n/*!\n * @param h             Length of the k - 3 sided chain.\n * @param i             First index from minimumArea\n * @param j             Second index from minimumArea\n */\nstd::vector<Side> Chains::reconstructHSidedChain(int h, int i, int j)\n{\n    if(h == 0)\n    {\n        throw std::logic_error(\"\");\n    }\n    if(h == 1)\n    {\n        return std::vector<Side>{{middle_sides[h][i][j].side, true}};\n    }\n\n    std::vector<Side> before, after;\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n    if(h_floor > 0)\n        before = reconstructHSidedChain(h_floor, i, middle_sides[h][i][j].side);\n    if(h_ceil > 0)\n        after = reconstructHSidedChain(h_ceil, middle_sides[h][i][j].side, j);\n\n    std::vector<Side> sides{{middle_sides[h][i][j].side, true}};\n    sides.insert(sides.end(), before.begin(), before.end());\n    sides.insert(sides.end(), after.begin(), after.end());\n    return sides;\n}\n\n//! Get the k sides that build the kgon based on the two sides that give the smalles extra area.\n/*!\n * @param k             Number of sides of the output polygon\n * @param i             First index from minimumArea\n * @param j             Second index from minimumArea\n */\nstd::vector<Side> Chains::findKSides(int k, int i, int j)\n{\n    std::vector<Side> sides;\n    sides.push_back({i, true});\n    sides.push_back({j, true});\n\n    if(single_sides[i][j].flush)\n        sides.push_back({single_sides[i][j].side, true});\n    else\n        sides.push_back({single_sides[i][j].side, false});\n\n    std::vector<Side> flush_chain = reconstructHSidedChain(k - 3, j, i);\n    sides.insert(sides.end(), flush_chain.begin(), flush_chain.end());\n    std::sort(sides.begin(), sides.end(),\n              [](const Side& lhs, const Side& rhs) { return lhs.side < rhs.side; });\n\n    return sides;\n}\n\n//! Calculate the k vertices of the kgon from its k sides.\n/*!\n * @param sides         Sides of the output polygon\n */\nstd::vector<cv::Point2f> Chains::findKVertices(std::vector<Side>& sides)\n{\n    const int k = sides.size();\n    std::vector<cv::Point2f> vertices(k);\n\n    for(int u = 0; u < k; u++)\n    {\n        const int next = (u + 1) % k;\n        if(sides[u].flush && sides[next].flush)\n        {\n            vertices[u] = intersections.lineIntersect(sides[u].side,\n                                                      sides[next].side).intersection.point;\n        }\n        else if(sides[u].flush && !sides[next].flush)\n        {\n            vertices[u] = balanced_inters[sides[u].side][sides[(u + 2) % k].side].pi;\n        }\n        else if(!sides[u].flush && sides[next].flush)\n        {\n            vertices[u] = balanced_inters[sides[(u - 1 + k) %k].side][sides[next].side].pj;\n        }\n        else\n        {\n            throw std::logic_error(\"\");\n        }\n    }\n    return vertices;\n}\n\n} //namespace\n\n\n///////////////////////// Helper function definitions /////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Find the minimum enclosing convex kgon and its area. Converting inputs to used vector shape and data format.\n/*!\n * @param points         Set of points\n * @param k              Number of vertices of the output polygon\n * @param minPolygon     Minimum area convex k-gon enclosing the given set of points\n * @param area           Area of minPolygon\n */\nstatic void findMinEnclosingPolygon(cv::InputArray points,\n                                    const int &k,\n                                    CV_OUT cv::OutputArray &minPolygon,\n                                    CV_OUT double &area) {\n    CV_Assert(!points.empty());\n    std::vector<cv::Point2f> ngon, kgon;\n    cv::convexHull(points, ngon, true);\n    findMinEnclosingPolygon(ngon, k, kgon, area);\n    cv::Mat(kgon).copyTo(minPolygon);\n}\n\n//! Find the minimum enclosing convex polygon and its area for a given set of points. Handling of input errors.\n/*!\n * @param ngon           The polygon representing the convex hull of the points\n * @param k              Number of vertices of the output polygon\n * @param minPolygon     Minimum area convex k-gon enclosing the given polygon\n * @param area           Area of minPolygon\n */\nstatic void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n                                    const int &k,\n                                    cv::OutputArray &minPolygon,\n                                    double &area) {\n    try\n    {\n        if (ngon.size() < 3)\n        {\n            throw std::invalid_argument(\n            \"ngon must have 3 or more different points enclosing an area\" );\n        }\n        if (cv::contourArea(ngon) < EPSILON )\n        {\n            throw std::invalid_argument( \"invalid ngon: all points on line\" );\n        }\n        if (k <= 3)\n        {\n            throw std::invalid_argument( \"k must be 3 or higher\" );\n        }\n        const size_t n = ngon.size();\n        if ((const int)n == k)\n        {\n            throw std::runtime_error (\"(n = k)\");\n        }\n        if ((const int)n < k)\n        {\n            throw std::runtime_error (\"(n < k)\");\n        }\n    }\n    catch (std::invalid_argument &message)\n    {\n        std::cout << \"invalid argument: \" << message.what() << std::endl;\n        return;\n    }\n    catch (std::runtime_error &message)\n    {\n        std::cout << \"Warning: no minimum area polygon calculated \" << message.what() << std::endl;\n        cv::Mat(ngon).copyTo(minPolygon);\n        area = cv::contourArea(minPolygon);\n        return;\n    }\n    catch (...)\n    {\n        std::cout << \"input error\" << std::endl;\n        return;\n    }\n\n    try\n    {\n        std::vector<cv::Point2f> kgon;\n        findMinAreaPolygon(ngon, kgon, area, k);\n        cv::Mat(kgon).copyTo(minPolygon);\n    }\n    catch (...)\n    {\n        std::cout << \"correct input but execution failed\" << std::endl;\n        return;\n    }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2153806951",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27369,
        "pr_file": "modules/imgproc/src/min_enclosing_convex_polygon.cpp",
        "discussion_id": "2153806951",
        "commented_code": "@@ -0,0 +1,1185 @@\n+/*M///////////////////////////////////////////////////////////////////////////////////////\n+ //\n+ //  This file is part of OpenCV project.\n+ //  It is subject to the license terms in the LICENSE file found in the top-level directory of this\n+ //  distribution and at http://opencv.org/license.html.\n+ //\n+ //\n+ //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n+ //\n+ //  By downloading, copying, installing or using the software you agree to this license.\n+ //  If you do not agree to this license, do not download, install,\n+ //  copy or use the software.\n+ //\n+ //  INFORMATION REGARDING THE CONTRIBUTION:\n+ //\n+ //  Author: Sara Kuhnert\n+ //  Created: 20.05.2025\n+ //  E-mail: <sara.kuhnert[AT]gmx.de>\n+ //\n+ //  THE IMPLEMENTATION OF THE MODULES IS BASED ON THE FOLLOWING PAPER:\n+ //\n+ //  [1] A. Aggarwal, J. S. Chang, Chee K. Yap: \"Minimum area circumscribing Polygons\", The Visual\n+ //  Computer, 1:112-117, 1985\n+ //\n+ //  The overall complexity of the algorithm is theta(n^2log(n)log(k)) where \"n\" represents the number\n+ //  of vertices in the input convex polygon and \"k\" the number of vertices in the output polygon.\n+ //\n+ //\n+ //\n+ //                           License Agreement\n+ //                For Open Source Computer Vision Library\n+ //\n+ // Copyright (C) 2000, Intel Corporation, all rights reserved.\n+ // Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n+ // Copyright (C) 2020, Sara Kuhnert, all rights reserved.\n+ // Third party copyrights are property of their respective owners.\n+ //\n+ // Redistribution and use in source and binary forms, with or without modification,\n+ // are permitted provided that the following conditions are met:\n+ //\n+ //   * Redistribution's of source code must retain the above copyright notice,\n+ //     this list of conditions and the following disclaimer.\n+ //\n+ //   * Redistribution's in binary form must reproduce the above copyright notice,\n+ //     this list of conditions and the following disclaimer in the documentation\n+ //     and/or other materials provided with the distribution.\n+ //\n+ //   * The name of the copyright holders may not be used to endorse or promote products\n+ //     derived from this software without specific prior written permission.\n+ //\n+ // This software is provided by the copyright holders and contributors \"as is\" and\n+ // any express or implied warranties, including, but not limited to, the implied\n+ // warranties of merchantability and fitness for a particular purpose are disclaimed.\n+ // In no event shall the Intel Corporation or contributors be liable for any direct,\n+ // indirect, incidental, special, exemplary, or consequential damages\n+ // (including, but not limited to, procurement of substitute goods or services;\n+ // loss of use, data, or profits; or business interruption) however caused\n+ // and on any theory of liability, whether in contract, strict liability,\n+ // or tort (including negligence or otherwise) arising in any way out of\n+ // the use of this software, even if advised of the possibility of such damage.\n+ //\n+ //M*/\n+\n+#include \"precomp.hpp\"\n+#include <opencv2/imgproc.hpp>\n+\n+#include <vector>\n+#include <algorithm>\n+#include <limits>\n+#include <numeric>\n+#include <set>\n+#include <iostream>\n+#include <cstdlib>\n+\n+\n+\n+//////////////////////////// Constants definitions ////////////////////////////\n+\n+#define EPSILON 1e-6\n+\n+\n+///////////////////////// Helper function declarations /////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+static void findMinEnclosingPolygon(cv::InputArray points,\n+                                    const int &k,\n+                                    CV_OUT cv::OutputArray &kgon,\n+                                    CV_OUT double &area);\n+\n+static void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n+                                    const int &k,\n+                                    cv::OutputArray &kgon,\n+                                    double &area);\n+\n+static void findMinAreaPolygon(const std::vector<cv::Point2f> &ngon,\n+                                std::vector<cv::Point2f> &minPolygon,\n+                                double &area,\n+                                int k);\n+\n+} //namespace\n+\n+\n+//////////////////////// Class and struct declarations ////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Intersection point of two sides with its position relative to the polygon\n+/*!\n+ * @param point         Intersection point of the two sides\n+ * @param position      Is the intersection point a valid solution?\n+ */\n+struct IntersectionPoint\n+{\n+    cv::Point2f point = {-1.0, -1.0};\n+    bool position = false;\n+\n+    IntersectionPoint() = default;\n+    IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n+                      const cv::Point2f& c, const cv::Point2f& d);\n+    IntersectionPoint(int i, int j, const std::vector<cv::Point2f>& ngon);\n+};\n+\n+//! Container for the information about the intersection point of two flush sides\n+/*!\n+ * @param intersection  Instance of IntersectionPoint\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct FlushIntersect\n+{\n+    IntersectionPoint intersection = {};\n+    double extra_area = std::numeric_limits<double>::max();\n+    bool done = false;\n+};\n+\n+//! Container for the information about a balanced side between two points\n+/*!\n+ * @param pi            First intersection point\n+ * @param pj            Second intersection point\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param flush         Flush is a special case of balanced. If the balanced side is also flush, this indicates which of the sides of the ngon it is flush with. The default for not flush sides is -1.\n+ * @param position      Is the balanced side a valid solution?\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct BalancedIntersect\n+{\n+    cv::Point2f pi = {-1, -1};\n+    cv::Point2f pj = {-1, -1};\n+    double extra_area = std::numeric_limits<double>::max();\n+    int flush = -1;\n+    bool position = false;\n+    bool done = false;\n+};\n+\n+//! Container for the best segment between two points\n+/*!\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param side          Side of the ngon to which it is flush (if flush is true) or edge of the ngon which it is touching (if flush is false)\n+ * @param flush         True if it is flush. If false, it is balanced but not flush\n+ * @param exists        Does a valid solution exist?\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct Segment\n+{\n+    double extra_area = std::numeric_limits<double>::max();\n+    int side = -1;\n+    bool flush = false;\n+    bool exists = false;\n+    bool done = false;\n+};\n+\n+//! Combination of selected sides and their corresponding chains, which generates the kgon with the minimum area\n+/*!\n+ * @param area          Extra area that the minimal kgon is bigger than the input ngon\n+ * @param i             First side\n+ * @param j             Second side\n+ */\n+struct Minimum\n+{\n+    double area = std::numeric_limits<double>::max();\n+    int i = -1;\n+    int j = -1;\n+};\n+\n+//! Container for a side of the minimal kgon\n+/*!\n+ * @param side          Index of the side of the ngon which it is flush with or the vertex which it is touching\n+ * @param flush         Is this side flush?\n+ */\n+struct Side\n+{\n+    int side = -1;\n+    bool flush = false;\n+\n+    Side() = default;\n+    Side(int i, bool b);\n+};\n+\n+//! Container for the minimal kgon\n+/*!\n+ * @param sides         Indices of the corresponding sindes of the ngon\n+ * @param vertices      Vertices of the kgon\n+ * @param extra_area    Extra area that the minimal kgon is bigger than the input ngon\n+ * @param i, @param j   The chains which build the minimal kgon are formed between those two sides\n+ */\n+struct Kgon\n+{\n+    std::vector<Side> sides;\n+    std::vector<cv::Point2f> vertices;\n+    double extra_area = std::numeric_limits<double>::max();\n+    int i = -1;\n+    int j = -1;\n+};\n+\n+//! Class for all the possible combinations of flush intersections of two sides of the input polygon\n+/*!\n+ * @param ngon              Input polygon\n+ * @param intersections     Matrix of all possible flush intersections of two sides of the ngon\n+ * @param area_edges        Collection of the points that define the extra area of the kgon\n+ */\n+class FlushIntersections\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<FlushIntersect>> intersections;\n+    std::vector<cv::Point2f> area_edges;\n+\n+public:\n+    FlushIntersections(const std::vector<cv::Point2f>& _ngon);\n+    const FlushIntersect& lineIntersect(int i, int j);\n+};\n+\n+//! Class for all the possible combinations of balanced intersections with two sides of the input polygon\n+/*!\n+ * @param ngon                      Input polygon\n+ * @param balanced_intersections    atrix of all possible balanced intersections of two sides of the ngon\n+ * @param area_edges                Collection of the points that define the extra area of the kgon\n+ */\n+class BalancedIntersections\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<BalancedIntersect>> balanced_intersections;\n+    std::vector<cv::Point2f> area_edges;\n+\n+    double extraArea ( int first, int last, const cv::Point2f& extra1, const cv::Point2f& extra2 );\n+\n+    BalancedIntersect flush(int i, int j, int e);\n+\n+public:\n+    BalancedIntersections(const std::vector<cv::Point2f>& _ngon);\n+    BalancedIntersect balancedIntersect(int i, int j, int e);\n+    void markAsDone(int i, int j);\n+    const std::vector<BalancedIntersect>& operator[](size_t i) const;\n+};\n+\n+//! Class for building the one-sided and h-sided chains and calculation the minimum enclosing polygon based on those chains\n+/*!\n+ * @param ngon              Input polygon\n+ * @param single_sides      Matrix of the best one-sided chain for each combination of two sides of the ngon\n+ * @param middle_sides      Matrix of the middle side of each h-sided chain for all relevant h and each combination of two sides of the ngon\n+ * @param intersections     An instance of FlushIntersections to store already calculated flush intersections\n+ * @param balanced_inters   An instance of BalancedIntersections to store already calculated balanced intersections\n+ */\n+class Chains\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<Segment>> single_sides;\n+    std::vector<std::vector<std::vector<Segment>>> middle_sides;\n+    FlushIntersections intersections;\n+    BalancedIntersections balanced_inters;\n+\n+    void findSingleE(int i, int j, int l, int r);\n+    void singleSideImpl(int i, int j1, int j2);\n+    void findMiddleE1(int i, int j, int l, int r);\n+    void middleSideImpl1(int i, int j1, int j2);\n+    void findMiddleE(int h, int i, int j, int l, int r);\n+    void middleSideImpl(int h, int i, int j1, int j2);\n+\n+public:\n+    Chains(const std::vector<cv::Point2f>& _ngon, int k);\n+\n+    std::set<int> relevantChainLengths(int h);\n+    void calcOneSidedChains();\n+    void calcMiddleChains(int h);\n+\n+    Minimum minimumArea(int n, int k);\n+    std::vector<Side> reconstructHSidedChain(int h, int i, int j);\n+    std::vector<Side> findKSides(int k, int i, int j);\n+    std::vector<cv::Point2f> findKVertices(std::vector<Side>& sides);\n+\n+};\n+\n+} //namespace\n+\n+\n+//////////////////////// Class and struct constructors ////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Constructor for IntersectionPoint. Find the intersection point of two lines given by four points and decide whether it is on the correct side of the polygon\n+/*!\n+ * @param a             First point of the first line\n+ * @param b             Second point of the first line\n+ * @param c             First point of the second line\n+ * @param d             Second point of the second line\n+ */\n+IntersectionPoint::IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n+                                     const cv::Point2f& c, const cv::Point2f& d)\n+{\n+    const cv::Point2f ab = b - a, cd = d - c, ac = c - a;\n+    const double det = ab.cross(-cd);\n+    if(std::abs (det) < EPSILON )\n+        return;\n+\n+    const double loc = ac.cross(-cd) / det;\n+    if(loc <= 0)\n+        return;\n+\n+    point = a + loc * ab;\n+    position = true;\n+}\n+\n+//! Constructor for IntersectionPoint. Find the intersection point of two sides of the polygon based on the given side indices.\n+/*!\n+ * @param i             Index of the first side\n+ * @param j             Index of the second side\n+ * @param ngon          Input polygon with n sides\n+ */\n+IntersectionPoint::IntersectionPoint(int i, int j,\n+                                     const std::vector<cv::Point2f>& ngon) :\n+    IntersectionPoint(ngon[i],\n+                      ngon[(i + 1) % ngon.size()],\n+                      ngon[j],\n+                      ngon[(j + 1) % ngon.size()])\n+{}\n+\n+//! Constructor for FlushIntersections\n+/*!\n+ * @param _ngon         Input polygon with n sides\n+ */\n+FlushIntersections::FlushIntersections(const std::vector<cv::Point2f>& _ngon) :\n+    ngon(_ngon),\n+    intersections(ngon.size(),\n+                  std::vector<FlushIntersect>(ngon.size()))\n+{\n+    area_edges.reserve(ngon.size());\n+}\n+\n+//! Constructor for BalancedIntersections\n+/*!\n+ * @param _ngon         Input polygon with n sides\n+ */\n+BalancedIntersections::BalancedIntersections(const std::vector<cv::Point2f>& _ngon) :\n+ngon(_ngon),\n+balanced_intersections(ngon.size(),\n+                        std::vector<BalancedIntersect>(ngon.size()))\n+{\n+    area_edges.reserve(ngon.size());\n+}\n+\n+//! Constructor for Side. Assign a side index and weather it is flush or not.\n+/*!\n+ * @param i             Side index\n+ * @param b             Is side i flush?\n+ */\n+Side::Side(int i, bool b)\n+{\n+    side = i;\n+    flush = b;\n+}\n+\n+//! Constructor for Chains\n+/*!\n+ * @param\n+ */\n+Chains::Chains(const std::vector<cv::Point2f>& _ngon, int k) :\n+    ngon(_ngon),\n+    single_sides(std::vector<std::vector<Segment>>(ngon.size(),\n+                                                   std::vector<Segment>(ngon.size()))),\n+    middle_sides(std::vector<std::vector<std::vector<Segment>>>(\n+        k, std::vector<std::vector<Segment>>(ngon.size(),\n+                                             std::vector<Segment>(ngon.size())))),\n+    intersections(ngon),\n+    balanced_inters(ngon)\n+{}\n+\n+} //namespace\n+\n+\n+////////////////////////// Class and struct functions //////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Find the intersection point of two sides, decide weather it is a valid point and if so calculate the extra area caused by that intersection.\n+/*!\n+ * @param i             Index of the first side\n+ * @param j             Index of the second side\n+ */\n+const FlushIntersect& FlushIntersections::lineIntersect(int i, int j)\n+{\n+    FlushIntersect& itr = intersections[i][j];\n+    if(itr.done)\n+        return itr;\n+\n+    const size_t n = ngon.size();\n+    if((i + 1) % n == j)\n+    {\n+        itr.intersection.point = ngon[j];\n+        itr.intersection.position = true;\n+        itr.extra_area = 0.0;\n+        itr.done = true;\n+        return itr;\n+    }\n+    itr.intersection = IntersectionPoint(i, j, ngon);\n+    if(itr.intersection.position)\n+    {\n+        area_edges.resize(0);\n+        for(int t = (i + 1) % n; t != (j + 1) % n; t = (t + 1) % n)\n+        {\n+            area_edges.push_back(ngon[t]);\n+        }\n+        area_edges.push_back(itr.intersection.point);\n+        itr.extra_area = cv::contourArea(area_edges);\n+        itr.done = true;\n+    }\n+    else\n+    {\n+        itr.extra_area = std::numeric_limits<double>::max();\n+        itr.intersection.position = false;\n+        itr.done = true;\n+    }\n+    return itr;\n+}\n+\n+//! Calculate the added area that is enclosed by a sequence of consecutive vertices of the polygon and the intersection point of two sides.\n+/*!\n+ * @param first         Index of the first point of the sequence\n+ * @param last          Index of the last point of the sequence\n+ * @param extra1        Last point of the sequence\n+ * @param extra2        Intersection point\n+ */\n+double BalancedIntersections::extraArea(int first, int last,\n+                                       const cv::Point2f& extra1,\n+                                       const cv::Point2f& extra2)\n+{\n+    const size_t n = ngon.size();\n+    area_edges.resize(0);\n+    for(int t = first; t != last; t = (t + 1) % n)\n+        area_edges.push_back(ngon[t]);\n+\n+    area_edges.push_back(extra1);\n+    area_edges.push_back(extra2);\n+\n+    return cv::contourArea(area_edges);\n+}\n+\n+//! Determine the intersection points of a flush side e that lies between sides i and j with these two sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ * @param e             Index of a side between i and j\n+ */\n+BalancedIntersect BalancedIntersections::flush(int i, int j, int e)\n+{\n+    if(i == e)\n+        std::logic_error(\"\");\n+    if(j == e)\n+        std::logic_error(\"\");\n+\n+    const size_t n = ngon.size();\n+    const int before = (e - 1 + n) % n;\n+    BalancedIntersect bi = balanced_intersections[i][j];\n+\n+    const IntersectionPoint left_e(i, e, ngon);\n+    const IntersectionPoint right_e(e, j, ngon);\n+\n+    if(left_e.position == true && right_e.position == true)\n+    {\n+        double extra_area = extraArea((i + 1) % n, e, ngon[e], left_e.point);\n+        if(extra_area < bi.extra_area)\n+        {\n+            extra_area += extraArea((e + 1) % n, j, ngon[j], right_e.point);\n+            if(extra_area < bi.extra_area)\n+            {\n+                bi.extra_area = extra_area;\n+                bi.pi = left_e.point;\n+                bi.pj = right_e.point;\n+                bi.position = true;\n+                bi.flush = e;\n+            }\n+        }\n+    }\n+\n+    if(before != i)\n+    {\n+        const IntersectionPoint left_before(i, before, ngon);\n+        const IntersectionPoint right_before(before, j, ngon);\n+        if(left_before.position == true && right_before.position == true)\n+        {\n+            double extra_area =\n+            extraArea((i + 1) % n, before, ngon[before], left_before.point);\n+\n+            if(extra_area < bi.extra_area)\n+            {\n+                extra_area += extraArea(e, j, ngon[j], right_before.point);\n+                if(extra_area < bi.extra_area)\n+                {\n+                    bi.extra_area = extra_area;\n+                    bi.pi = left_before.point;\n+                    bi.pj = right_before.point;\n+                    bi.position = true;\n+                    bi.flush = before;\n+                }\n+            }\n+        }\n+    }\n+    return bi;\n+}\n+\n+//! Determine the intersection points of a balanced side e that lies between sides i and j with these two sides. If no valid balanced edge is found, ccheck for flush sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ * @param e             Index of a side between i and j\n+ */\n+BalancedIntersect BalancedIntersections::balancedIntersect(int i, int j, int e)\n+{\n+    if(balanced_intersections[i][j].done)\n+        return balanced_intersections[i][j];\n+\n+    const size_t n = ngon.size();\n+    if((i + 2) % n == j)\n+    {\n+        BalancedIntersect& bi = balanced_intersections[i][j];\n+        bi.pi = ngon[(i + 1) % n];\n+        bi.pj = ngon[j];\n+        bi.flush = (i + 1) % n;\n+        bi.position = true;\n+        bi.extra_area = 0.0;\n+        bi.done = true;\n+        return bi;\n+    }\n+\n+    const cv::Point2f p1 = ngon[i], p2 = ngon[(i + 1) % n], p3 = ngon[e],\n+    p4 = ngon[j], p5 = ngon[(j + 1) % n];\n+    const cv::Point2f dir12 = p2 - p1, dir45 = p5 - p4;\n+    const double det = dir12.cross(dir45);\n+    if(std::abs (det) < EPSILON )\n+    {\n+        flush(i, j, e);\n+        return balanced_intersections[i][j];\n+    }\n+\n+    BalancedIntersect bi;\n+    cv::Point2f temp = 2 * p3 - p2 - p4;\n+    const double s = temp.cross(dir45) / det;\n+    const double t = temp.cross(dir12) / det;\n+    if(s >= 0 && t >= 0)\n+    {\n+        bi.pi = p2 + dir12 * s;\n+        bi.pj = p4 - dir45 * t;\n+        bi.position = true;\n+\n+        const cv::Point2f dir_balanced = bi.pj - bi.pi,\n+        dir_left = p3 - ngon[(e - 1 + n) % n],\n+        dir_right = ngon[(e + 1) % n] - p3;\n+\n+        const double cross_left = dir_balanced.cross(dir_left),\n+        cross_right = dir_balanced.cross(dir_right);\n+        if((cross_left < 0 && cross_right < 0) || (cross_left > 0 && cross_right > 0))\n+        {\n+            BalancedIntersect reset;\n+            bi = reset;\n+            bi = flush(i, j, e);\n+        }\n+        else if(std::abs (cross_left) < EPSILON )\n+        {\n+            bi.flush = (e - 1 + n) % n;\n+            bi.extra_area =\n+            extraArea((i + 1) % n, (e - 1 + n) % n, ngon[(e - 1 + n) % n], bi.pi)\n+            + extraArea(e, j, ngon[j], bi.pj);\n+        }\n+        else if(std::abs (cross_right) < EPSILON )\n+        {\n+            bi.flush = e;\n+            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n+            + extraArea((e + 1) % n, j, ngon[j], bi.pj);\n+        }\n+        else\n+        {\n+            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n+            + extraArea(e, j, ngon[j], bi.pj);\n+        }\n+    }\n+    else\n+    {\n+        flush(i, j, e);\n+    }\n+\n+    if(bi.extra_area < balanced_intersections[i][j].extra_area)\n+    {\n+        balanced_intersections[i][j] = bi;\n+    }\n+    return bi;\n+}\n+\n+//! Set function for the done attribute of BalancedIntersections\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ */\n+void BalancedIntersections::markAsDone(int i, int j)\n+{\n+    balanced_intersections[i][j].done = true;\n+}\n+\n+//! Operator to get a vector of elements from BalancedIntersections\n+/*!\n+ * @param i             index of a side\n+ */\n+const std::vector<BalancedIntersect>& BalancedIntersections::operator[](\n+    size_t i) const\n+{\n+    return balanced_intersections[i];\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the one sided chain with minimal extra area\n+/*!\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findSingleE(int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = single_sides[i][j];\n+    if (one.done)\n+        return;\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        BalancedIntersect candidate = balanced_inters.balancedIntersect(i, j, e);\n+        if(candidate.extra_area < min_area)\n+        {\n+            min_area = candidate.extra_area;\n+            one.side = e;\n+            one.extra_area = candidate.extra_area;\n+            one.flush = false;\n+            one.exists = true;\n+        }\n+    }\n+    one.done = true;\n+    balanced_inters.markAsDone(i, j);\n+}\n+\n+//! Recursively repeat the search for the one sided chain with minimal extra area to shrink the boundaries of bigger distances\n+/*!\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::singleSideImpl(int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = single_sides[i][j1].side < 0 ? (j1 + 1) %n : single_sides[i][j1].side;\n+    int r = single_sides[i][j2].side < 0 ? (j2 - 1 + n) %n : single_sides[i][j2].side;\n+\n+    findSingleE(i, mid, l, r);\n+    singleSideImpl(i, j1, mid);\n+    singleSideImpl(i, mid, j2);\n+\n+    return;\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h = 1.\n+/*!\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findMiddleE1(int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = middle_sides[1][i][j];\n+    if (one.done)\n+        return;\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        const FlushIntersect& before = intersections.lineIntersect(i, e);\n+        if(!before.intersection.position)\n+            continue;\n+        const FlushIntersect& after = intersections.lineIntersect(e, j);\n+        if(!after.intersection.position)\n+            continue;\n+\n+        double tmp_area = before.extra_area + after.extra_area;\n+        if(tmp_area < min_area)\n+        {\n+            min_area = tmp_area;\n+            one.side = e;\n+            one.extra_area = tmp_area;\n+            one.exists = true;\n+            one.flush = true;\n+        }\n+    }\n+    one.done = true;\n+}\n+\n+//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h = 1.\n+/*!\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::middleSideImpl1(int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = middle_sides[1][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[1][i][j1].side;\n+    int r = middle_sides[1][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[1][i][j2].side;\n+\n+    findMiddleE1(i, mid, l, r);\n+    middleSideImpl1(i, j1, mid);\n+    middleSideImpl1(i, mid, j2);\n+\n+    return;\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h > 1.\n+/*!\n+ * @param h     Length of the h-sided chain\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findMiddleE(int h, int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = middle_sides[h][i][j];\n+    if (one.done)\n+        return;\n+\n+    const int dist = (i <= j ? (j - i) : (j + n - i));\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+\n+    if(dist == 0)\n+        throw std::logic_error(\"\");\n+    if(dist - 1 < h)\n+    {\n+        one.done = true;\n+        return;\n+    }\n+    if(dist - 1 == h)\n+    {\n+        one.side = (i + h_floor + 1) % n;\n+        one.extra_area = 0.0;\n+        one.exists = true;\n+        one.flush = true;\n+        one.done = true;\n+        return;\n+    }\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        const Segment& before = middle_sides[h_floor][i][e];\n+        if (before.extra_area == std::numeric_limits<double>::max())\n+            continue;\n+        const Segment& after = middle_sides[h_ceil][e][j];\n+        if(after.extra_area == std::numeric_limits<double>::max())\n+            continue;\n+\n+        double tmp_area = before.extra_area + after.extra_area;\n+        if(tmp_area < min_area)\n+        {\n+            min_area = tmp_area;\n+            one.side = e;\n+            one.extra_area = tmp_area;\n+            one.exists = true;\n+            one.flush = true;\n+        }\n+    }\n+    one.done = true;\n+}\n+\n+//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h > 1.\n+/*!\n+ * @param h     Length of the h-sided chain\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::middleSideImpl(int h, int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = middle_sides[h][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[h][i][j1].side;\n+    int r = middle_sides[h][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[h][i][j2].side;\n+\n+    findMiddleE(h, i, mid, l, r);\n+    middleSideImpl(h, i, j1, mid);\n+    middleSideImpl(h, i, mid, j2);\n+\n+    return;\n+}\n+\n+//! Calculate the relevant chain lengths. Starting with a maximum chain length of h, down to a chain length of 1, only chains with half the length of the chain before are needed.\n+/*!\n+ * @param h     Length of the longest chain (h = k - 3)\n+ */\n+std::set<int> Chains::relevantChainLengths(int h)\n+{\n+    if(h <= 1)\n+        return {h};\n+\n+    std::set<int> hs = {h};\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+    std::set<int> h1 = relevantChainLengths(h_floor);\n+    for(const int& hNew : h1)\n+        hs.insert(hNew);\n+    if (h_ceil != h_floor)\n+    {\n+        std::set<int> h2 = relevantChainLengths(h_ceil);\n+        for(const int& hNew : h2)\n+            hs.insert(hNew);\n+    }\n+    return hs;\n+}\n+\n+//! Recursively calculate all the onesided chains for each combination of polygon sides.\n+/*!\n+ */\n+void Chains::calcOneSidedChains()\n+{\n+    const size_t n = ngon.size();\n+    for(size_t i = 0; i < n; i++)\n+    {\n+        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+        findSingleE(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+        findSingleE(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+        singleSideImpl(i, j1, j2);\n+    }\n+}\n+\n+//! Recursively calculate the middle sides of the h-sided chains for all combinations of polygon sides.\n+/*!\n+ * @param h     Length of the chains\n+ */\n+void Chains::calcMiddleChains(int h)\n+{\n+    const size_t n = ngon.size();\n+    if (h == 0)\n+    {\n+        for (size_t i = 0; i < n; i++)\n+        {\n+            for (size_t j = 0; j < n; j++)\n+            {\n+                Segment& one = middle_sides[h][i][j];\n+                const FlushIntersect itrs = intersections.lineIntersect(i, j);\n+\n+                one.side = -1;\n+                one.extra_area = itrs.extra_area;\n+                one.exists = false;\n+                one.flush = false;\n+                one.done = true;\n+            }\n+        }\n+        return;\n+    }\n+    if (h == 1)\n+    {\n+        for (size_t i = 0; i < n; i++)\n+        {\n+            int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+            findMiddleE1(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+            findMiddleE1(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+            middleSideImpl1(i, j1, j2);\n+        }\n+        return;\n+    }\n+\n+    for (size_t i = 0; i < n; i++)\n+    {\n+        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+        findMiddleE(h, i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+        findMiddleE(h, i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+        middleSideImpl(h, i, j1, j2);\n+    }\n+}\n+\n+//! Find the i and j with the smallest extra area.\n+/*!\n+ * @param n             Number of sides of the input polygon\n+ * @param k             Number of sides of the output polygon\n+ */\n+Minimum Chains::minimumArea(int n, int k)\n+{\n+    Minimum min{};\n+    for(int i = 0; i < n; i++)\n+    {\n+        for(int j = 0; j < n; j++)\n+        {\n+            if(!single_sides[i][j].exists || !middle_sides[k - 3][j][i].exists)\n+                continue;\n+\n+            double tmp_area =\n+            single_sides[i][j].extra_area + middle_sides[k - 3][j][i].extra_area;\n+            if(tmp_area < min.area)\n+            {\n+                min.area = tmp_area;\n+                min.i = i;\n+                min.j = j;\n+            }\n+        }\n+    }\n+    return min;\n+}\n+\n+//! Reconstruct the h-sided chain based on the two sides that give the smalles extra area.\n+/*!\n+ * @param h             Length of the k - 3 sided chain.\n+ * @param i             First index from minimumArea\n+ * @param j             Second index from minimumArea\n+ */\n+std::vector<Side> Chains::reconstructHSidedChain(int h, int i, int j)\n+{\n+    if(h == 0)\n+    {\n+        throw std::logic_error(\"\");\n+    }\n+    if(h == 1)\n+    {\n+        return std::vector<Side>{{middle_sides[h][i][j].side, true}};\n+    }\n+\n+    std::vector<Side> before, after;\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+    if(h_floor > 0)\n+        before = reconstructHSidedChain(h_floor, i, middle_sides[h][i][j].side);\n+    if(h_ceil > 0)\n+        after = reconstructHSidedChain(h_ceil, middle_sides[h][i][j].side, j);\n+\n+    std::vector<Side> sides{{middle_sides[h][i][j].side, true}};\n+    sides.insert(sides.end(), before.begin(), before.end());\n+    sides.insert(sides.end(), after.begin(), after.end());\n+    return sides;\n+}\n+\n+//! Get the k sides that build the kgon based on the two sides that give the smalles extra area.\n+/*!\n+ * @param k             Number of sides of the output polygon\n+ * @param i             First index from minimumArea\n+ * @param j             Second index from minimumArea\n+ */\n+std::vector<Side> Chains::findKSides(int k, int i, int j)\n+{\n+    std::vector<Side> sides;\n+    sides.push_back({i, true});\n+    sides.push_back({j, true});\n+\n+    if(single_sides[i][j].flush)\n+        sides.push_back({single_sides[i][j].side, true});\n+    else\n+        sides.push_back({single_sides[i][j].side, false});\n+\n+    std::vector<Side> flush_chain = reconstructHSidedChain(k - 3, j, i);\n+    sides.insert(sides.end(), flush_chain.begin(), flush_chain.end());\n+    std::sort(sides.begin(), sides.end(),\n+              [](const Side& lhs, const Side& rhs) { return lhs.side < rhs.side; });\n+\n+    return sides;\n+}\n+\n+//! Calculate the k vertices of the kgon from its k sides.\n+/*!\n+ * @param sides         Sides of the output polygon\n+ */\n+std::vector<cv::Point2f> Chains::findKVertices(std::vector<Side>& sides)\n+{\n+    const int k = sides.size();\n+    std::vector<cv::Point2f> vertices(k);\n+\n+    for(int u = 0; u < k; u++)\n+    {\n+        const int next = (u + 1) % k;\n+        if(sides[u].flush && sides[next].flush)\n+        {\n+            vertices[u] = intersections.lineIntersect(sides[u].side,\n+                                                      sides[next].side).intersection.point;\n+        }\n+        else if(sides[u].flush && !sides[next].flush)\n+        {\n+            vertices[u] = balanced_inters[sides[u].side][sides[(u + 2) % k].side].pi;\n+        }\n+        else if(!sides[u].flush && sides[next].flush)\n+        {\n+            vertices[u] = balanced_inters[sides[(u - 1 + k) %k].side][sides[next].side].pj;\n+        }\n+        else\n+        {\n+            throw std::logic_error(\"\");\n+        }\n+    }\n+    return vertices;\n+}\n+\n+} //namespace\n+\n+\n+///////////////////////// Helper function definitions /////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Find the minimum enclosing convex kgon and its area. Converting inputs to used vector shape and data format.\n+/*!\n+ * @param points         Set of points\n+ * @param k              Number of vertices of the output polygon\n+ * @param minPolygon     Minimum area convex k-gon enclosing the given set of points\n+ * @param area           Area of minPolygon\n+ */\n+static void findMinEnclosingPolygon(cv::InputArray points,\n+                                    const int &k,\n+                                    CV_OUT cv::OutputArray &minPolygon,\n+                                    CV_OUT double &area) {\n+    CV_Assert(!points.empty());\n+    std::vector<cv::Point2f> ngon, kgon;\n+    cv::convexHull(points, ngon, true);\n+    findMinEnclosingPolygon(ngon, k, kgon, area);\n+    cv::Mat(kgon).copyTo(minPolygon);\n+}\n+\n+//! Find the minimum enclosing convex polygon and its area for a given set of points. Handling of input errors.\n+/*!\n+ * @param ngon           The polygon representing the convex hull of the points\n+ * @param k              Number of vertices of the output polygon\n+ * @param minPolygon     Minimum area convex k-gon enclosing the given polygon\n+ * @param area           Area of minPolygon\n+ */\n+static void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n+                                    const int &k,\n+                                    cv::OutputArray &minPolygon,\n+                                    double &area) {\n+    try\n+    {\n+        if (ngon.size() < 3)\n+        {\n+            throw std::invalid_argument(\n+            \"ngon must have 3 or more different points enclosing an area\" );\n+        }\n+        if (cv::contourArea(ngon) < EPSILON )\n+        {\n+            throw std::invalid_argument( \"invalid ngon: all points on line\" );\n+        }\n+        if (k <= 3)\n+        {\n+            throw std::invalid_argument( \"k must be 3 or higher\" );\n+        }\n+        const size_t n = ngon.size();\n+        if ((const int)n == k)\n+        {\n+            throw std::runtime_error (\"(n = k)\");\n+        }\n+        if ((const int)n < k)\n+        {\n+            throw std::runtime_error (\"(n < k)\");\n+        }\n+    }\n+    catch (std::invalid_argument &message)\n+    {\n+        std::cout << \"invalid argument: \" << message.what() << std::endl;\n+        return;\n+    }\n+    catch (std::runtime_error &message)\n+    {\n+        std::cout << \"Warning: no minimum area polygon calculated \" << message.what() << std::endl;\n+        cv::Mat(ngon).copyTo(minPolygon);\n+        area = cv::contourArea(minPolygon);\n+        return;\n+    }\n+    catch (...)\n+    {\n+        std::cout << \"input error\" << std::endl;\n+        return;\n+    }\n+\n+    try\n+    {\n+        std::vector<cv::Point2f> kgon;\n+        findMinAreaPolygon(ngon, kgon, area, k);\n+        cv::Mat(kgon).copyTo(minPolygon);\n+    }\n+    catch (...)\n+    {\n+        std::cout << \"correct input but execution failed\" << std::endl;\n+        return;\n+    }",
        "comment_created_at": "2025-06-18T07:03:02+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Please do not use try-catch. OpenCV uses CV_Assert, CV_Check for the function input validation and and CV_LOG_DEBUG/CV_LOG_INFO for notifications. Function should not silently ignore obvious invalid inputs like not enough points or wrong data types and ranges.  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2153834792",
    "pr_number": 27369,
    "pr_file": "modules/imgproc/src/min_enclosing_convex_polygon.cpp",
    "created_at": "2025-06-18T07:17:46+00:00",
    "commented_code": "/*M///////////////////////////////////////////////////////////////////////////////////////\n //\n //  This file is part of OpenCV project.\n //  It is subject to the license terms in the LICENSE file found in the top-level directory of this\n //  distribution and at http://opencv.org/license.html.\n //\n //\n //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n //\n //  By downloading, copying, installing or using the software you agree to this license.\n //  If you do not agree to this license, do not download, install,\n //  copy or use the software.\n //\n //  INFORMATION REGARDING THE CONTRIBUTION:\n //\n //  Author: Sara Kuhnert\n //  Created: 20.05.2025\n //  E-mail: <sara.kuhnert[AT]gmx.de>\n //\n //  THE IMPLEMENTATION OF THE MODULES IS BASED ON THE FOLLOWING PAPER:\n //\n //  [1] A. Aggarwal, J. S. Chang, Chee K. Yap: \"Minimum area circumscribing Polygons\", The Visual\n //  Computer, 1:112-117, 1985\n //\n //  The overall complexity of the algorithm is theta(n^2log(n)log(k)) where \"n\" represents the number\n //  of vertices in the input convex polygon and \"k\" the number of vertices in the output polygon.\n //\n //\n //\n //                           License Agreement\n //                For Open Source Computer Vision Library\n //\n // Copyright (C) 2000, Intel Corporation, all rights reserved.\n // Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n // Copyright (C) 2020, Sara Kuhnert, all rights reserved.\n // Third party copyrights are property of their respective owners.\n //\n // Redistribution and use in source and binary forms, with or without modification,\n // are permitted provided that the following conditions are met:\n //\n //   * Redistribution's of source code must retain the above copyright notice,\n //     this list of conditions and the following disclaimer.\n //\n //   * Redistribution's in binary form must reproduce the above copyright notice,\n //     this list of conditions and the following disclaimer in the documentation\n //     and/or other materials provided with the distribution.\n //\n //   * The name of the copyright holders may not be used to endorse or promote products\n //     derived from this software without specific prior written permission.\n //\n // This software is provided by the copyright holders and contributors \"as is\" and\n // any express or implied warranties, including, but not limited to, the implied\n // warranties of merchantability and fitness for a particular purpose are disclaimed.\n // In no event shall the Intel Corporation or contributors be liable for any direct,\n // indirect, incidental, special, exemplary, or consequential damages\n // (including, but not limited to, procurement of substitute goods or services;\n // loss of use, data, or profits; or business interruption) however caused\n // and on any theory of liability, whether in contract, strict liability,\n // or tort (including negligence or otherwise) arising in any way out of\n // the use of this software, even if advised of the possibility of such damage.\n //\n //M*/\n\n#include \"precomp.hpp\"\n#include <opencv2/imgproc.hpp>\n\n#include <vector>\n#include <algorithm>\n#include <limits>\n#include <numeric>\n#include <set>\n#include <iostream>\n#include <cstdlib>\n\n\n\n//////////////////////////// Constants definitions ////////////////////////////\n\n#define EPSILON 1e-6\n\n\n///////////////////////// Helper function declarations /////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\nstatic void findMinEnclosingPolygon(cv::InputArray points,\n                                    const int &k,\n                                    CV_OUT cv::OutputArray &kgon,\n                                    CV_OUT double &area);\n\nstatic void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n                                    const int &k,\n                                    cv::OutputArray &kgon,\n                                    double &area);\n\nstatic void findMinAreaPolygon(const std::vector<cv::Point2f> &ngon,\n                                std::vector<cv::Point2f> &minPolygon,\n                                double &area,\n                                int k);\n\n} //namespace\n\n\n//////////////////////// Class and struct declarations ////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Intersection point of two sides with its position relative to the polygon\n/*!\n * @param point         Intersection point of the two sides\n * @param position      Is the intersection point a valid solution?\n */\nstruct IntersectionPoint\n{\n    cv::Point2f point = {-1.0, -1.0};\n    bool position = false;\n\n    IntersectionPoint() = default;\n    IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n                      const cv::Point2f& c, const cv::Point2f& d);\n    IntersectionPoint(int i, int j, const std::vector<cv::Point2f>& ngon);\n};\n\n//! Container for the information about the intersection point of two flush sides\n/*!\n * @param intersection  Instance of IntersectionPoint\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct FlushIntersect\n{\n    IntersectionPoint intersection = {};\n    double extra_area = std::numeric_limits<double>::max();\n    bool done = false;\n};\n\n//! Container for the information about a balanced side between two points\n/*!\n * @param pi            First intersection point\n * @param pj            Second intersection point\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param flush         Flush is a special case of balanced. If the balanced side is also flush, this indicates which of the sides of the ngon it is flush with. The default for not flush sides is -1.\n * @param position      Is the balanced side a valid solution?\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct BalancedIntersect\n{\n    cv::Point2f pi = {-1, -1};\n    cv::Point2f pj = {-1, -1};\n    double extra_area = std::numeric_limits<double>::max();\n    int flush = -1;\n    bool position = false;\n    bool done = false;\n};\n\n//! Container for the best segment between two points\n/*!\n * @param extra_area    The area that would be added to the kgon compared to the ngon\n * @param side          Side of the ngon to which it is flush (if flush is true) or edge of the ngon which it is touching (if flush is false)\n * @param flush         True if it is flush. If false, it is balanced but not flush\n * @param exists        Does a valid solution exist?\n * @param done          Set to true once calculated to avoid redundant calculations\n */\nstruct Segment\n{\n    double extra_area = std::numeric_limits<double>::max();\n    int side = -1;\n    bool flush = false;\n    bool exists = false;\n    bool done = false;\n};\n\n//! Combination of selected sides and their corresponding chains, which generates the kgon with the minimum area\n/*!\n * @param area          Extra area that the minimal kgon is bigger than the input ngon\n * @param i             First side\n * @param j             Second side\n */\nstruct Minimum\n{\n    double area = std::numeric_limits<double>::max();\n    int i = -1;\n    int j = -1;\n};\n\n//! Container for a side of the minimal kgon\n/*!\n * @param side          Index of the side of the ngon which it is flush with or the vertex which it is touching\n * @param flush         Is this side flush?\n */\nstruct Side\n{\n    int side = -1;\n    bool flush = false;\n\n    Side() = default;\n    Side(int i, bool b);\n};\n\n//! Container for the minimal kgon\n/*!\n * @param sides         Indices of the corresponding sindes of the ngon\n * @param vertices      Vertices of the kgon\n * @param extra_area    Extra area that the minimal kgon is bigger than the input ngon\n * @param i, @param j   The chains which build the minimal kgon are formed between those two sides\n */\nstruct Kgon\n{\n    std::vector<Side> sides;\n    std::vector<cv::Point2f> vertices;\n    double extra_area = std::numeric_limits<double>::max();\n    int i = -1;\n    int j = -1;\n};\n\n//! Class for all the possible combinations of flush intersections of two sides of the input polygon\n/*!\n * @param ngon              Input polygon\n * @param intersections     Matrix of all possible flush intersections of two sides of the ngon\n * @param area_edges        Collection of the points that define the extra area of the kgon\n */\nclass FlushIntersections\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<FlushIntersect>> intersections;\n    std::vector<cv::Point2f> area_edges;\n\npublic:\n    FlushIntersections(const std::vector<cv::Point2f>& _ngon);\n    const FlushIntersect& lineIntersect(int i, int j);\n};\n\n//! Class for all the possible combinations of balanced intersections with two sides of the input polygon\n/*!\n * @param ngon                      Input polygon\n * @param balanced_intersections    atrix of all possible balanced intersections of two sides of the ngon\n * @param area_edges                Collection of the points that define the extra area of the kgon\n */\nclass BalancedIntersections\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<BalancedIntersect>> balanced_intersections;\n    std::vector<cv::Point2f> area_edges;\n\n    double extraArea ( int first, int last, const cv::Point2f& extra1, const cv::Point2f& extra2 );\n\n    BalancedIntersect flush(int i, int j, int e);\n\npublic:\n    BalancedIntersections(const std::vector<cv::Point2f>& _ngon);\n    BalancedIntersect balancedIntersect(int i, int j, int e);\n    void markAsDone(int i, int j);\n    const std::vector<BalancedIntersect>& operator[](size_t i) const;\n};\n\n//! Class for building the one-sided and h-sided chains and calculation the minimum enclosing polygon based on those chains\n/*!\n * @param ngon              Input polygon\n * @param single_sides      Matrix of the best one-sided chain for each combination of two sides of the ngon\n * @param middle_sides      Matrix of the middle side of each h-sided chain for all relevant h and each combination of two sides of the ngon\n * @param intersections     An instance of FlushIntersections to store already calculated flush intersections\n * @param balanced_inters   An instance of BalancedIntersections to store already calculated balanced intersections\n */\nclass Chains\n{\nprivate:\n    const std::vector<cv::Point2f>& ngon;\n    std::vector<std::vector<Segment>> single_sides;\n    std::vector<std::vector<std::vector<Segment>>> middle_sides;\n    FlushIntersections intersections;\n    BalancedIntersections balanced_inters;\n\n    void findSingleE(int i, int j, int l, int r);\n    void singleSideImpl(int i, int j1, int j2);\n    void findMiddleE1(int i, int j, int l, int r);\n    void middleSideImpl1(int i, int j1, int j2);\n    void findMiddleE(int h, int i, int j, int l, int r);\n    void middleSideImpl(int h, int i, int j1, int j2);\n\npublic:\n    Chains(const std::vector<cv::Point2f>& _ngon, int k);\n\n    std::set<int> relevantChainLengths(int h);\n    void calcOneSidedChains();\n    void calcMiddleChains(int h);\n\n    Minimum minimumArea(int n, int k);\n    std::vector<Side> reconstructHSidedChain(int h, int i, int j);\n    std::vector<Side> findKSides(int k, int i, int j);\n    std::vector<cv::Point2f> findKVertices(std::vector<Side>& sides);\n\n};\n\n} //namespace\n\n\n//////////////////////// Class and struct constructors ////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Constructor for IntersectionPoint. Find the intersection point of two lines given by four points and decide whether it is on the correct side of the polygon\n/*!\n * @param a             First point of the first line\n * @param b             Second point of the first line\n * @param c             First point of the second line\n * @param d             Second point of the second line\n */\nIntersectionPoint::IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n                                     const cv::Point2f& c, const cv::Point2f& d)\n{\n    const cv::Point2f ab = b - a, cd = d - c, ac = c - a;\n    const double det = ab.cross(-cd);\n    if(std::abs (det) < EPSILON )\n        return;\n\n    const double loc = ac.cross(-cd) / det;\n    if(loc <= 0)\n        return;\n\n    point = a + loc * ab;\n    position = true;\n}\n\n//! Constructor for IntersectionPoint. Find the intersection point of two sides of the polygon based on the given side indices.\n/*!\n * @param i             Index of the first side\n * @param j             Index of the second side\n * @param ngon          Input polygon with n sides\n */\nIntersectionPoint::IntersectionPoint(int i, int j,\n                                     const std::vector<cv::Point2f>& ngon) :\n    IntersectionPoint(ngon[i],\n                      ngon[(i + 1) % ngon.size()],\n                      ngon[j],\n                      ngon[(j + 1) % ngon.size()])\n{}\n\n//! Constructor for FlushIntersections\n/*!\n * @param _ngon         Input polygon with n sides\n */\nFlushIntersections::FlushIntersections(const std::vector<cv::Point2f>& _ngon) :\n    ngon(_ngon),\n    intersections(ngon.size(),\n                  std::vector<FlushIntersect>(ngon.size()))\n{\n    area_edges.reserve(ngon.size());\n}\n\n//! Constructor for BalancedIntersections\n/*!\n * @param _ngon         Input polygon with n sides\n */\nBalancedIntersections::BalancedIntersections(const std::vector<cv::Point2f>& _ngon) :\nngon(_ngon),\nbalanced_intersections(ngon.size(),\n                        std::vector<BalancedIntersect>(ngon.size()))\n{\n    area_edges.reserve(ngon.size());\n}\n\n//! Constructor for Side. Assign a side index and weather it is flush or not.\n/*!\n * @param i             Side index\n * @param b             Is side i flush?\n */\nSide::Side(int i, bool b)\n{\n    side = i;\n    flush = b;\n}\n\n//! Constructor for Chains\n/*!\n * @param\n */\nChains::Chains(const std::vector<cv::Point2f>& _ngon, int k) :\n    ngon(_ngon),\n    single_sides(std::vector<std::vector<Segment>>(ngon.size(),\n                                                   std::vector<Segment>(ngon.size()))),\n    middle_sides(std::vector<std::vector<std::vector<Segment>>>(\n        k, std::vector<std::vector<Segment>>(ngon.size(),\n                                             std::vector<Segment>(ngon.size())))),\n    intersections(ngon),\n    balanced_inters(ngon)\n{}\n\n} //namespace\n\n\n////////////////////////// Class and struct functions //////////////////////////\n\nnamespace minEnclosingConvexPolygon {\n\n//! Find the intersection point of two sides, decide weather it is a valid point and if so calculate the extra area caused by that intersection.\n/*!\n * @param i             Index of the first side\n * @param j             Index of the second side\n */\nconst FlushIntersect& FlushIntersections::lineIntersect(int i, int j)\n{\n    FlushIntersect& itr = intersections[i][j];\n    if(itr.done)\n        return itr;\n\n    const size_t n = ngon.size();\n    if((i + 1) % n == j)\n    {\n        itr.intersection.point = ngon[j];\n        itr.intersection.position = true;\n        itr.extra_area = 0.0;\n        itr.done = true;\n        return itr;\n    }\n    itr.intersection = IntersectionPoint(i, j, ngon);\n    if(itr.intersection.position)\n    {\n        area_edges.resize(0);\n        for(int t = (i + 1) % n; t != (j + 1) % n; t = (t + 1) % n)\n        {\n            area_edges.push_back(ngon[t]);\n        }\n        area_edges.push_back(itr.intersection.point);\n        itr.extra_area = cv::contourArea(area_edges);\n        itr.done = true;\n    }\n    else\n    {\n        itr.extra_area = std::numeric_limits<double>::max();\n        itr.intersection.position = false;\n        itr.done = true;\n    }\n    return itr;\n}\n\n//! Calculate the added area that is enclosed by a sequence of consecutive vertices of the polygon and the intersection point of two sides.\n/*!\n * @param first         Index of the first point of the sequence\n * @param last          Index of the last point of the sequence\n * @param extra1        Last point of the sequence\n * @param extra2        Intersection point\n */\ndouble BalancedIntersections::extraArea(int first, int last,\n                                       const cv::Point2f& extra1,\n                                       const cv::Point2f& extra2)\n{\n    const size_t n = ngon.size();\n    area_edges.resize(0);\n    for(int t = first; t != last; t = (t + 1) % n)\n        area_edges.push_back(ngon[t]);\n\n    area_edges.push_back(extra1);\n    area_edges.push_back(extra2);\n\n    return cv::contourArea(area_edges);\n}\n\n//! Determine the intersection points of a flush side e that lies between sides i and j with these two sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n * @param e             Index of a side between i and j\n */\nBalancedIntersect BalancedIntersections::flush(int i, int j, int e)\n{\n    if(i == e)\n        std::logic_error(\"\");\n    if(j == e)\n        std::logic_error(\"\");\n\n    const size_t n = ngon.size();\n    const int before = (e - 1 + n) % n;\n    BalancedIntersect bi = balanced_intersections[i][j];\n\n    const IntersectionPoint left_e(i, e, ngon);\n    const IntersectionPoint right_e(e, j, ngon);\n\n    if(left_e.position == true && right_e.position == true)\n    {\n        double extra_area = extraArea((i + 1) % n, e, ngon[e], left_e.point);\n        if(extra_area < bi.extra_area)\n        {\n            extra_area += extraArea((e + 1) % n, j, ngon[j], right_e.point);\n            if(extra_area < bi.extra_area)\n            {\n                bi.extra_area = extra_area;\n                bi.pi = left_e.point;\n                bi.pj = right_e.point;\n                bi.position = true;\n                bi.flush = e;\n            }\n        }\n    }\n\n    if(before != i)\n    {\n        const IntersectionPoint left_before(i, before, ngon);\n        const IntersectionPoint right_before(before, j, ngon);\n        if(left_before.position == true && right_before.position == true)\n        {\n            double extra_area =\n            extraArea((i + 1) % n, before, ngon[before], left_before.point);\n\n            if(extra_area < bi.extra_area)\n            {\n                extra_area += extraArea(e, j, ngon[j], right_before.point);\n                if(extra_area < bi.extra_area)\n                {\n                    bi.extra_area = extra_area;\n                    bi.pi = left_before.point;\n                    bi.pj = right_before.point;\n                    bi.position = true;\n                    bi.flush = before;\n                }\n            }\n        }\n    }\n    return bi;\n}\n\n//! Determine the intersection points of a balanced side e that lies between sides i and j with these two sides. If no valid balanced edge is found, ccheck for flush sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n * @param e             Index of a side between i and j\n */\nBalancedIntersect BalancedIntersections::balancedIntersect(int i, int j, int e)\n{\n    if(balanced_intersections[i][j].done)\n        return balanced_intersections[i][j];\n\n    const size_t n = ngon.size();\n    if((i + 2) % n == j)\n    {\n        BalancedIntersect& bi = balanced_intersections[i][j];\n        bi.pi = ngon[(i + 1) % n];\n        bi.pj = ngon[j];\n        bi.flush = (i + 1) % n;\n        bi.position = true;\n        bi.extra_area = 0.0;\n        bi.done = true;\n        return bi;\n    }\n\n    const cv::Point2f p1 = ngon[i], p2 = ngon[(i + 1) % n], p3 = ngon[e],\n    p4 = ngon[j], p5 = ngon[(j + 1) % n];\n    const cv::Point2f dir12 = p2 - p1, dir45 = p5 - p4;\n    const double det = dir12.cross(dir45);\n    if(std::abs (det) < EPSILON )\n    {\n        flush(i, j, e);\n        return balanced_intersections[i][j];\n    }\n\n    BalancedIntersect bi;\n    cv::Point2f temp = 2 * p3 - p2 - p4;\n    const double s = temp.cross(dir45) / det;\n    const double t = temp.cross(dir12) / det;\n    if(s >= 0 && t >= 0)\n    {\n        bi.pi = p2 + dir12 * s;\n        bi.pj = p4 - dir45 * t;\n        bi.position = true;\n\n        const cv::Point2f dir_balanced = bi.pj - bi.pi,\n        dir_left = p3 - ngon[(e - 1 + n) % n],\n        dir_right = ngon[(e + 1) % n] - p3;\n\n        const double cross_left = dir_balanced.cross(dir_left),\n        cross_right = dir_balanced.cross(dir_right);\n        if((cross_left < 0 && cross_right < 0) || (cross_left > 0 && cross_right > 0))\n        {\n            BalancedIntersect reset;\n            bi = reset;\n            bi = flush(i, j, e);\n        }\n        else if(std::abs (cross_left) < EPSILON )\n        {\n            bi.flush = (e - 1 + n) % n;\n            bi.extra_area =\n            extraArea((i + 1) % n, (e - 1 + n) % n, ngon[(e - 1 + n) % n], bi.pi)\n            + extraArea(e, j, ngon[j], bi.pj);\n        }\n        else if(std::abs (cross_right) < EPSILON )\n        {\n            bi.flush = e;\n            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n            + extraArea((e + 1) % n, j, ngon[j], bi.pj);\n        }\n        else\n        {\n            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n            + extraArea(e, j, ngon[j], bi.pj);\n        }\n    }\n    else\n    {\n        flush(i, j, e);\n    }\n\n    if(bi.extra_area < balanced_intersections[i][j].extra_area)\n    {\n        balanced_intersections[i][j] = bi;\n    }\n    return bi;\n}\n\n//! Set function for the done attribute of BalancedIntersections\n/*!\n * @param i             Index of first side\n * @param j             Index of second side\n */\nvoid BalancedIntersections::markAsDone(int i, int j)\n{\n    balanced_intersections[i][j].done = true;\n}\n\n//! Operator to get a vector of elements from BalancedIntersections\n/*!\n * @param i             index of a side\n */\nconst std::vector<BalancedIntersect>& BalancedIntersections::operator[](\n    size_t i) const\n{\n    return balanced_intersections[i];\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the one sided chain with minimal extra area\n/*!\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findSingleE(int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = single_sides[i][j];\n    if (one.done)\n        return;\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        BalancedIntersect candidate = balanced_inters.balancedIntersect(i, j, e);\n        if(candidate.extra_area < min_area)\n        {\n            min_area = candidate.extra_area;\n            one.side = e;\n            one.extra_area = candidate.extra_area;\n            one.flush = false;\n            one.exists = true;\n        }\n    }\n    one.done = true;\n    balanced_inters.markAsDone(i, j);\n}\n\n//! Recursively repeat the search for the one sided chain with minimal extra area to shrink the boundaries of bigger distances\n/*!\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::singleSideImpl(int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = single_sides[i][j1].side < 0 ? (j1 + 1) %n : single_sides[i][j1].side;\n    int r = single_sides[i][j2].side < 0 ? (j2 - 1 + n) %n : single_sides[i][j2].side;\n\n    findSingleE(i, mid, l, r);\n    singleSideImpl(i, j1, mid);\n    singleSideImpl(i, mid, j2);\n\n    return;\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h = 1.\n/*!\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findMiddleE1(int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = middle_sides[1][i][j];\n    if (one.done)\n        return;\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        const FlushIntersect& before = intersections.lineIntersect(i, e);\n        if(!before.intersection.position)\n            continue;\n        const FlushIntersect& after = intersections.lineIntersect(e, j);\n        if(!after.intersection.position)\n            continue;\n\n        double tmp_area = before.extra_area + after.extra_area;\n        if(tmp_area < min_area)\n        {\n            min_area = tmp_area;\n            one.side = e;\n            one.extra_area = tmp_area;\n            one.exists = true;\n            one.flush = true;\n        }\n    }\n    one.done = true;\n}\n\n//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h = 1.\n/*!\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::middleSideImpl1(int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = middle_sides[1][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[1][i][j1].side;\n    int r = middle_sides[1][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[1][i][j2].side;\n\n    findMiddleE1(i, mid, l, r);\n    middleSideImpl1(i, j1, mid);\n    middleSideImpl1(i, mid, j2);\n\n    return;\n}\n\n//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h > 1.\n/*!\n * @param h     Length of the h-sided chain\n * @param i     Index of first fixed side\n * @param j     Index of second fixed side\n * @param l     Index of left boundary\n * @param r     Index of right boundary\n */\nvoid Chains::findMiddleE(int h, int i, int j, int l, int r)\n{\n    const size_t n = ngon.size();\n    Segment& one = middle_sides[h][i][j];\n    if (one.done)\n        return;\n\n    const int dist = (i <= j ? (j - i) : (j + n - i));\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n\n    if(dist == 0)\n        throw std::logic_error(\"\");\n    if(dist - 1 < h)\n    {\n        one.done = true;\n        return;\n    }\n    if(dist - 1 == h)\n    {\n        one.side = (i + h_floor + 1) % n;\n        one.extra_area = 0.0;\n        one.exists = true;\n        one.flush = true;\n        one.done = true;\n        return;\n    }\n\n    double min_area = std::numeric_limits<double>::max();\n    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n    {\n        const Segment& before = middle_sides[h_floor][i][e];\n        if (before.extra_area == std::numeric_limits<double>::max())\n            continue;\n        const Segment& after = middle_sides[h_ceil][e][j];\n        if(after.extra_area == std::numeric_limits<double>::max())\n            continue;\n\n        double tmp_area = before.extra_area + after.extra_area;\n        if(tmp_area < min_area)\n        {\n            min_area = tmp_area;\n            one.side = e;\n            one.extra_area = tmp_area;\n            one.exists = true;\n            one.flush = true;\n        }\n    }\n    one.done = true;\n}\n\n//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h > 1.\n/*!\n * @param h     Length of the h-sided chain\n * @param i     Fixed side of the ngon\n * @param j1    Lower boundary of search intervall\n * @param j2    Upper boundary of search intervall\n */\nvoid Chains::middleSideImpl(int h, int i, int j1, int j2)\n{\n    const size_t n = ngon.size();\n    if((j1 + 1) %n == j2)\n    {\n        return;\n    }\n\n    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n    int l = middle_sides[h][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[h][i][j1].side;\n    int r = middle_sides[h][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[h][i][j2].side;\n\n    findMiddleE(h, i, mid, l, r);\n    middleSideImpl(h, i, j1, mid);\n    middleSideImpl(h, i, mid, j2);\n\n    return;\n}\n\n//! Calculate the relevant chain lengths. Starting with a maximum chain length of h, down to a chain length of 1, only chains with half the length of the chain before are needed.\n/*!\n * @param h     Length of the longest chain (h = k - 3)\n */\nstd::set<int> Chains::relevantChainLengths(int h)\n{\n    if(h <= 1)\n        return {h};\n\n    std::set<int> hs = {h};\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n    std::set<int> h1 = relevantChainLengths(h_floor);\n    for(const int& hNew : h1)\n        hs.insert(hNew);\n    if (h_ceil != h_floor)\n    {\n        std::set<int> h2 = relevantChainLengths(h_ceil);\n        for(const int& hNew : h2)\n            hs.insert(hNew);\n    }\n    return hs;\n}\n\n//! Recursively calculate all the onesided chains for each combination of polygon sides.\n/*!\n */\nvoid Chains::calcOneSidedChains()\n{\n    const size_t n = ngon.size();\n    for(size_t i = 0; i < n; i++)\n    {\n        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n        findSingleE(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n        findSingleE(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n        singleSideImpl(i, j1, j2);\n    }\n}\n\n//! Recursively calculate the middle sides of the h-sided chains for all combinations of polygon sides.\n/*!\n * @param h     Length of the chains\n */\nvoid Chains::calcMiddleChains(int h)\n{\n    const size_t n = ngon.size();\n    if (h == 0)\n    {\n        for (size_t i = 0; i < n; i++)\n        {\n            for (size_t j = 0; j < n; j++)\n            {\n                Segment& one = middle_sides[h][i][j];\n                const FlushIntersect itrs = intersections.lineIntersect(i, j);\n\n                one.side = -1;\n                one.extra_area = itrs.extra_area;\n                one.exists = false;\n                one.flush = false;\n                one.done = true;\n            }\n        }\n        return;\n    }\n    if (h == 1)\n    {\n        for (size_t i = 0; i < n; i++)\n        {\n            int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n            findMiddleE1(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n            findMiddleE1(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n            middleSideImpl1(i, j1, j2);\n        }\n        return;\n    }\n\n    for (size_t i = 0; i < n; i++)\n    {\n        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n\n        findMiddleE(h, i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n        findMiddleE(h, i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n        middleSideImpl(h, i, j1, j2);\n    }\n}\n\n//! Find the i and j with the smallest extra area.\n/*!\n * @param n             Number of sides of the input polygon\n * @param k             Number of sides of the output polygon\n */\nMinimum Chains::minimumArea(int n, int k)\n{\n    Minimum min{};\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            if(!single_sides[i][j].exists || !middle_sides[k - 3][j][i].exists)\n                continue;\n\n            double tmp_area =\n            single_sides[i][j].extra_area + middle_sides[k - 3][j][i].extra_area;\n            if(tmp_area < min.area)\n            {\n                min.area = tmp_area;\n                min.i = i;\n                min.j = j;\n            }\n        }\n    }\n    return min;\n}\n\n//! Reconstruct the h-sided chain based on the two sides that give the smalles extra area.\n/*!\n * @param h             Length of the k - 3 sided chain.\n * @param i             First index from minimumArea\n * @param j             Second index from minimumArea\n */\nstd::vector<Side> Chains::reconstructHSidedChain(int h, int i, int j)\n{\n    if(h == 0)\n    {\n        throw std::logic_error(\"\");\n    }\n    if(h == 1)\n    {\n        return std::vector<Side>{{middle_sides[h][i][j].side, true}};\n    }\n\n    std::vector<Side> before, after;\n    const int h_floor = (h - 1) / 2;\n    const int h_ceil = h - 1 - h_floor;\n    if(h_floor > 0)\n        before = reconstructHSidedChain(h_floor, i, middle_sides[h][i][j].side);\n    if(h_ceil > 0)\n        after = reconstructHSidedChain(h_ceil, middle_sides[h][i][j].side, j);\n\n    std::vector<Side> sides{{middle_sides[h][i][j].side, true}};\n    sides.insert(sides.end(), before.begin(), before.end());\n    sides.insert(sides.end(), after.begin(), after.end());\n    return sides;\n}\n\n//! Get the k sides that build the kgon based on the two sides that give the smalles extra area.\n/*!\n * @param k             Number of sides of the output polygon\n * @param i             First index from minimumArea\n * @param j             Second index from minimumArea\n */\nstd::vector<Side> Chains::findKSides(int k, int i, int j)\n{\n    std::vector<Side> sides;\n    sides.push_back({i, true});\n    sides.push_back({j, true});\n\n    if(single_sides[i][j].flush)\n        sides.push_back({single_sides[i][j].side, true});\n    else\n        sides.push_back({single_sides[i][j].side, false});\n\n    std::vector<Side> flush_chain = reconstructHSidedChain(k - 3, j, i);\n    sides.insert(sides.end(), flush_chain.begin(), flush_chain.end());\n    std::sort(sides.begin(), sides.end(),\n              [](const Side& lhs, const Side& rhs) { return lhs.side < rhs.side; });\n\n    return sides;\n}\n\n//! Calculate the k vertices of the kgon from its k sides.\n/*!\n * @param sides         Sides of the output polygon\n */\nstd::vector<cv::Point2f> Chains::findKVertices(std::vector<Side>& sides)\n{\n    const int k = sides.size();\n    std::vector<cv::Point2f> vertices(k);\n\n    for(int u = 0; u < k; u++)\n    {\n        const int next = (u + 1) % k;\n        if(sides[u].flush && sides[next].flush)\n        {\n            vertices[u] = intersections.lineIntersect(sides[u].side,\n                                                      sides[next].side).intersection.point;\n        }\n        else if(sides[u].flush && !sides[next].flush)\n        {\n            vertices[u] = balanced_inters[sides[u].side][sides[(u + 2) % k].side].pi;\n        }\n        else if(!sides[u].flush && sides[next].flush)\n        {\n            vertices[u] = balanced_inters[sides[(u - 1 + k) %k].side][sides[next].side].pj;\n        }\n        else\n        {\n            throw std::logic_error(\"\");",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2153834792",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27369,
        "pr_file": "modules/imgproc/src/min_enclosing_convex_polygon.cpp",
        "discussion_id": "2153834792",
        "commented_code": "@@ -0,0 +1,1185 @@\n+/*M///////////////////////////////////////////////////////////////////////////////////////\n+ //\n+ //  This file is part of OpenCV project.\n+ //  It is subject to the license terms in the LICENSE file found in the top-level directory of this\n+ //  distribution and at http://opencv.org/license.html.\n+ //\n+ //\n+ //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n+ //\n+ //  By downloading, copying, installing or using the software you agree to this license.\n+ //  If you do not agree to this license, do not download, install,\n+ //  copy or use the software.\n+ //\n+ //  INFORMATION REGARDING THE CONTRIBUTION:\n+ //\n+ //  Author: Sara Kuhnert\n+ //  Created: 20.05.2025\n+ //  E-mail: <sara.kuhnert[AT]gmx.de>\n+ //\n+ //  THE IMPLEMENTATION OF THE MODULES IS BASED ON THE FOLLOWING PAPER:\n+ //\n+ //  [1] A. Aggarwal, J. S. Chang, Chee K. Yap: \"Minimum area circumscribing Polygons\", The Visual\n+ //  Computer, 1:112-117, 1985\n+ //\n+ //  The overall complexity of the algorithm is theta(n^2log(n)log(k)) where \"n\" represents the number\n+ //  of vertices in the input convex polygon and \"k\" the number of vertices in the output polygon.\n+ //\n+ //\n+ //\n+ //                           License Agreement\n+ //                For Open Source Computer Vision Library\n+ //\n+ // Copyright (C) 2000, Intel Corporation, all rights reserved.\n+ // Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n+ // Copyright (C) 2020, Sara Kuhnert, all rights reserved.\n+ // Third party copyrights are property of their respective owners.\n+ //\n+ // Redistribution and use in source and binary forms, with or without modification,\n+ // are permitted provided that the following conditions are met:\n+ //\n+ //   * Redistribution's of source code must retain the above copyright notice,\n+ //     this list of conditions and the following disclaimer.\n+ //\n+ //   * Redistribution's in binary form must reproduce the above copyright notice,\n+ //     this list of conditions and the following disclaimer in the documentation\n+ //     and/or other materials provided with the distribution.\n+ //\n+ //   * The name of the copyright holders may not be used to endorse or promote products\n+ //     derived from this software without specific prior written permission.\n+ //\n+ // This software is provided by the copyright holders and contributors \"as is\" and\n+ // any express or implied warranties, including, but not limited to, the implied\n+ // warranties of merchantability and fitness for a particular purpose are disclaimed.\n+ // In no event shall the Intel Corporation or contributors be liable for any direct,\n+ // indirect, incidental, special, exemplary, or consequential damages\n+ // (including, but not limited to, procurement of substitute goods or services;\n+ // loss of use, data, or profits; or business interruption) however caused\n+ // and on any theory of liability, whether in contract, strict liability,\n+ // or tort (including negligence or otherwise) arising in any way out of\n+ // the use of this software, even if advised of the possibility of such damage.\n+ //\n+ //M*/\n+\n+#include \"precomp.hpp\"\n+#include <opencv2/imgproc.hpp>\n+\n+#include <vector>\n+#include <algorithm>\n+#include <limits>\n+#include <numeric>\n+#include <set>\n+#include <iostream>\n+#include <cstdlib>\n+\n+\n+\n+//////////////////////////// Constants definitions ////////////////////////////\n+\n+#define EPSILON 1e-6\n+\n+\n+///////////////////////// Helper function declarations /////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+static void findMinEnclosingPolygon(cv::InputArray points,\n+                                    const int &k,\n+                                    CV_OUT cv::OutputArray &kgon,\n+                                    CV_OUT double &area);\n+\n+static void findMinEnclosingPolygon(const std::vector<cv::Point2f> &ngon,\n+                                    const int &k,\n+                                    cv::OutputArray &kgon,\n+                                    double &area);\n+\n+static void findMinAreaPolygon(const std::vector<cv::Point2f> &ngon,\n+                                std::vector<cv::Point2f> &minPolygon,\n+                                double &area,\n+                                int k);\n+\n+} //namespace\n+\n+\n+//////////////////////// Class and struct declarations ////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Intersection point of two sides with its position relative to the polygon\n+/*!\n+ * @param point         Intersection point of the two sides\n+ * @param position      Is the intersection point a valid solution?\n+ */\n+struct IntersectionPoint\n+{\n+    cv::Point2f point = {-1.0, -1.0};\n+    bool position = false;\n+\n+    IntersectionPoint() = default;\n+    IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n+                      const cv::Point2f& c, const cv::Point2f& d);\n+    IntersectionPoint(int i, int j, const std::vector<cv::Point2f>& ngon);\n+};\n+\n+//! Container for the information about the intersection point of two flush sides\n+/*!\n+ * @param intersection  Instance of IntersectionPoint\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct FlushIntersect\n+{\n+    IntersectionPoint intersection = {};\n+    double extra_area = std::numeric_limits<double>::max();\n+    bool done = false;\n+};\n+\n+//! Container for the information about a balanced side between two points\n+/*!\n+ * @param pi            First intersection point\n+ * @param pj            Second intersection point\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param flush         Flush is a special case of balanced. If the balanced side is also flush, this indicates which of the sides of the ngon it is flush with. The default for not flush sides is -1.\n+ * @param position      Is the balanced side a valid solution?\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct BalancedIntersect\n+{\n+    cv::Point2f pi = {-1, -1};\n+    cv::Point2f pj = {-1, -1};\n+    double extra_area = std::numeric_limits<double>::max();\n+    int flush = -1;\n+    bool position = false;\n+    bool done = false;\n+};\n+\n+//! Container for the best segment between two points\n+/*!\n+ * @param extra_area    The area that would be added to the kgon compared to the ngon\n+ * @param side          Side of the ngon to which it is flush (if flush is true) or edge of the ngon which it is touching (if flush is false)\n+ * @param flush         True if it is flush. If false, it is balanced but not flush\n+ * @param exists        Does a valid solution exist?\n+ * @param done          Set to true once calculated to avoid redundant calculations\n+ */\n+struct Segment\n+{\n+    double extra_area = std::numeric_limits<double>::max();\n+    int side = -1;\n+    bool flush = false;\n+    bool exists = false;\n+    bool done = false;\n+};\n+\n+//! Combination of selected sides and their corresponding chains, which generates the kgon with the minimum area\n+/*!\n+ * @param area          Extra area that the minimal kgon is bigger than the input ngon\n+ * @param i             First side\n+ * @param j             Second side\n+ */\n+struct Minimum\n+{\n+    double area = std::numeric_limits<double>::max();\n+    int i = -1;\n+    int j = -1;\n+};\n+\n+//! Container for a side of the minimal kgon\n+/*!\n+ * @param side          Index of the side of the ngon which it is flush with or the vertex which it is touching\n+ * @param flush         Is this side flush?\n+ */\n+struct Side\n+{\n+    int side = -1;\n+    bool flush = false;\n+\n+    Side() = default;\n+    Side(int i, bool b);\n+};\n+\n+//! Container for the minimal kgon\n+/*!\n+ * @param sides         Indices of the corresponding sindes of the ngon\n+ * @param vertices      Vertices of the kgon\n+ * @param extra_area    Extra area that the minimal kgon is bigger than the input ngon\n+ * @param i, @param j   The chains which build the minimal kgon are formed between those two sides\n+ */\n+struct Kgon\n+{\n+    std::vector<Side> sides;\n+    std::vector<cv::Point2f> vertices;\n+    double extra_area = std::numeric_limits<double>::max();\n+    int i = -1;\n+    int j = -1;\n+};\n+\n+//! Class for all the possible combinations of flush intersections of two sides of the input polygon\n+/*!\n+ * @param ngon              Input polygon\n+ * @param intersections     Matrix of all possible flush intersections of two sides of the ngon\n+ * @param area_edges        Collection of the points that define the extra area of the kgon\n+ */\n+class FlushIntersections\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<FlushIntersect>> intersections;\n+    std::vector<cv::Point2f> area_edges;\n+\n+public:\n+    FlushIntersections(const std::vector<cv::Point2f>& _ngon);\n+    const FlushIntersect& lineIntersect(int i, int j);\n+};\n+\n+//! Class for all the possible combinations of balanced intersections with two sides of the input polygon\n+/*!\n+ * @param ngon                      Input polygon\n+ * @param balanced_intersections    atrix of all possible balanced intersections of two sides of the ngon\n+ * @param area_edges                Collection of the points that define the extra area of the kgon\n+ */\n+class BalancedIntersections\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<BalancedIntersect>> balanced_intersections;\n+    std::vector<cv::Point2f> area_edges;\n+\n+    double extraArea ( int first, int last, const cv::Point2f& extra1, const cv::Point2f& extra2 );\n+\n+    BalancedIntersect flush(int i, int j, int e);\n+\n+public:\n+    BalancedIntersections(const std::vector<cv::Point2f>& _ngon);\n+    BalancedIntersect balancedIntersect(int i, int j, int e);\n+    void markAsDone(int i, int j);\n+    const std::vector<BalancedIntersect>& operator[](size_t i) const;\n+};\n+\n+//! Class for building the one-sided and h-sided chains and calculation the minimum enclosing polygon based on those chains\n+/*!\n+ * @param ngon              Input polygon\n+ * @param single_sides      Matrix of the best one-sided chain for each combination of two sides of the ngon\n+ * @param middle_sides      Matrix of the middle side of each h-sided chain for all relevant h and each combination of two sides of the ngon\n+ * @param intersections     An instance of FlushIntersections to store already calculated flush intersections\n+ * @param balanced_inters   An instance of BalancedIntersections to store already calculated balanced intersections\n+ */\n+class Chains\n+{\n+private:\n+    const std::vector<cv::Point2f>& ngon;\n+    std::vector<std::vector<Segment>> single_sides;\n+    std::vector<std::vector<std::vector<Segment>>> middle_sides;\n+    FlushIntersections intersections;\n+    BalancedIntersections balanced_inters;\n+\n+    void findSingleE(int i, int j, int l, int r);\n+    void singleSideImpl(int i, int j1, int j2);\n+    void findMiddleE1(int i, int j, int l, int r);\n+    void middleSideImpl1(int i, int j1, int j2);\n+    void findMiddleE(int h, int i, int j, int l, int r);\n+    void middleSideImpl(int h, int i, int j1, int j2);\n+\n+public:\n+    Chains(const std::vector<cv::Point2f>& _ngon, int k);\n+\n+    std::set<int> relevantChainLengths(int h);\n+    void calcOneSidedChains();\n+    void calcMiddleChains(int h);\n+\n+    Minimum minimumArea(int n, int k);\n+    std::vector<Side> reconstructHSidedChain(int h, int i, int j);\n+    std::vector<Side> findKSides(int k, int i, int j);\n+    std::vector<cv::Point2f> findKVertices(std::vector<Side>& sides);\n+\n+};\n+\n+} //namespace\n+\n+\n+//////////////////////// Class and struct constructors ////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Constructor for IntersectionPoint. Find the intersection point of two lines given by four points and decide whether it is on the correct side of the polygon\n+/*!\n+ * @param a             First point of the first line\n+ * @param b             Second point of the first line\n+ * @param c             First point of the second line\n+ * @param d             Second point of the second line\n+ */\n+IntersectionPoint::IntersectionPoint(const cv::Point2f& a, const cv::Point2f& b,\n+                                     const cv::Point2f& c, const cv::Point2f& d)\n+{\n+    const cv::Point2f ab = b - a, cd = d - c, ac = c - a;\n+    const double det = ab.cross(-cd);\n+    if(std::abs (det) < EPSILON )\n+        return;\n+\n+    const double loc = ac.cross(-cd) / det;\n+    if(loc <= 0)\n+        return;\n+\n+    point = a + loc * ab;\n+    position = true;\n+}\n+\n+//! Constructor for IntersectionPoint. Find the intersection point of two sides of the polygon based on the given side indices.\n+/*!\n+ * @param i             Index of the first side\n+ * @param j             Index of the second side\n+ * @param ngon          Input polygon with n sides\n+ */\n+IntersectionPoint::IntersectionPoint(int i, int j,\n+                                     const std::vector<cv::Point2f>& ngon) :\n+    IntersectionPoint(ngon[i],\n+                      ngon[(i + 1) % ngon.size()],\n+                      ngon[j],\n+                      ngon[(j + 1) % ngon.size()])\n+{}\n+\n+//! Constructor for FlushIntersections\n+/*!\n+ * @param _ngon         Input polygon with n sides\n+ */\n+FlushIntersections::FlushIntersections(const std::vector<cv::Point2f>& _ngon) :\n+    ngon(_ngon),\n+    intersections(ngon.size(),\n+                  std::vector<FlushIntersect>(ngon.size()))\n+{\n+    area_edges.reserve(ngon.size());\n+}\n+\n+//! Constructor for BalancedIntersections\n+/*!\n+ * @param _ngon         Input polygon with n sides\n+ */\n+BalancedIntersections::BalancedIntersections(const std::vector<cv::Point2f>& _ngon) :\n+ngon(_ngon),\n+balanced_intersections(ngon.size(),\n+                        std::vector<BalancedIntersect>(ngon.size()))\n+{\n+    area_edges.reserve(ngon.size());\n+}\n+\n+//! Constructor for Side. Assign a side index and weather it is flush or not.\n+/*!\n+ * @param i             Side index\n+ * @param b             Is side i flush?\n+ */\n+Side::Side(int i, bool b)\n+{\n+    side = i;\n+    flush = b;\n+}\n+\n+//! Constructor for Chains\n+/*!\n+ * @param\n+ */\n+Chains::Chains(const std::vector<cv::Point2f>& _ngon, int k) :\n+    ngon(_ngon),\n+    single_sides(std::vector<std::vector<Segment>>(ngon.size(),\n+                                                   std::vector<Segment>(ngon.size()))),\n+    middle_sides(std::vector<std::vector<std::vector<Segment>>>(\n+        k, std::vector<std::vector<Segment>>(ngon.size(),\n+                                             std::vector<Segment>(ngon.size())))),\n+    intersections(ngon),\n+    balanced_inters(ngon)\n+{}\n+\n+} //namespace\n+\n+\n+////////////////////////// Class and struct functions //////////////////////////\n+\n+namespace minEnclosingConvexPolygon {\n+\n+//! Find the intersection point of two sides, decide weather it is a valid point and if so calculate the extra area caused by that intersection.\n+/*!\n+ * @param i             Index of the first side\n+ * @param j             Index of the second side\n+ */\n+const FlushIntersect& FlushIntersections::lineIntersect(int i, int j)\n+{\n+    FlushIntersect& itr = intersections[i][j];\n+    if(itr.done)\n+        return itr;\n+\n+    const size_t n = ngon.size();\n+    if((i + 1) % n == j)\n+    {\n+        itr.intersection.point = ngon[j];\n+        itr.intersection.position = true;\n+        itr.extra_area = 0.0;\n+        itr.done = true;\n+        return itr;\n+    }\n+    itr.intersection = IntersectionPoint(i, j, ngon);\n+    if(itr.intersection.position)\n+    {\n+        area_edges.resize(0);\n+        for(int t = (i + 1) % n; t != (j + 1) % n; t = (t + 1) % n)\n+        {\n+            area_edges.push_back(ngon[t]);\n+        }\n+        area_edges.push_back(itr.intersection.point);\n+        itr.extra_area = cv::contourArea(area_edges);\n+        itr.done = true;\n+    }\n+    else\n+    {\n+        itr.extra_area = std::numeric_limits<double>::max();\n+        itr.intersection.position = false;\n+        itr.done = true;\n+    }\n+    return itr;\n+}\n+\n+//! Calculate the added area that is enclosed by a sequence of consecutive vertices of the polygon and the intersection point of two sides.\n+/*!\n+ * @param first         Index of the first point of the sequence\n+ * @param last          Index of the last point of the sequence\n+ * @param extra1        Last point of the sequence\n+ * @param extra2        Intersection point\n+ */\n+double BalancedIntersections::extraArea(int first, int last,\n+                                       const cv::Point2f& extra1,\n+                                       const cv::Point2f& extra2)\n+{\n+    const size_t n = ngon.size();\n+    area_edges.resize(0);\n+    for(int t = first; t != last; t = (t + 1) % n)\n+        area_edges.push_back(ngon[t]);\n+\n+    area_edges.push_back(extra1);\n+    area_edges.push_back(extra2);\n+\n+    return cv::contourArea(area_edges);\n+}\n+\n+//! Determine the intersection points of a flush side e that lies between sides i and j with these two sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ * @param e             Index of a side between i and j\n+ */\n+BalancedIntersect BalancedIntersections::flush(int i, int j, int e)\n+{\n+    if(i == e)\n+        std::logic_error(\"\");\n+    if(j == e)\n+        std::logic_error(\"\");\n+\n+    const size_t n = ngon.size();\n+    const int before = (e - 1 + n) % n;\n+    BalancedIntersect bi = balanced_intersections[i][j];\n+\n+    const IntersectionPoint left_e(i, e, ngon);\n+    const IntersectionPoint right_e(e, j, ngon);\n+\n+    if(left_e.position == true && right_e.position == true)\n+    {\n+        double extra_area = extraArea((i + 1) % n, e, ngon[e], left_e.point);\n+        if(extra_area < bi.extra_area)\n+        {\n+            extra_area += extraArea((e + 1) % n, j, ngon[j], right_e.point);\n+            if(extra_area < bi.extra_area)\n+            {\n+                bi.extra_area = extra_area;\n+                bi.pi = left_e.point;\n+                bi.pj = right_e.point;\n+                bi.position = true;\n+                bi.flush = e;\n+            }\n+        }\n+    }\n+\n+    if(before != i)\n+    {\n+        const IntersectionPoint left_before(i, before, ngon);\n+        const IntersectionPoint right_before(before, j, ngon);\n+        if(left_before.position == true && right_before.position == true)\n+        {\n+            double extra_area =\n+            extraArea((i + 1) % n, before, ngon[before], left_before.point);\n+\n+            if(extra_area < bi.extra_area)\n+            {\n+                extra_area += extraArea(e, j, ngon[j], right_before.point);\n+                if(extra_area < bi.extra_area)\n+                {\n+                    bi.extra_area = extra_area;\n+                    bi.pi = left_before.point;\n+                    bi.pj = right_before.point;\n+                    bi.position = true;\n+                    bi.flush = before;\n+                }\n+            }\n+        }\n+    }\n+    return bi;\n+}\n+\n+//! Determine the intersection points of a balanced side e that lies between sides i and j with these two sides. If no valid balanced edge is found, ccheck for flush sides. Calculate the extra area and the position of the intersection points relative to the polygon. Update balanced_intersections if the new area is smaller than extraArea.\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ * @param e             Index of a side between i and j\n+ */\n+BalancedIntersect BalancedIntersections::balancedIntersect(int i, int j, int e)\n+{\n+    if(balanced_intersections[i][j].done)\n+        return balanced_intersections[i][j];\n+\n+    const size_t n = ngon.size();\n+    if((i + 2) % n == j)\n+    {\n+        BalancedIntersect& bi = balanced_intersections[i][j];\n+        bi.pi = ngon[(i + 1) % n];\n+        bi.pj = ngon[j];\n+        bi.flush = (i + 1) % n;\n+        bi.position = true;\n+        bi.extra_area = 0.0;\n+        bi.done = true;\n+        return bi;\n+    }\n+\n+    const cv::Point2f p1 = ngon[i], p2 = ngon[(i + 1) % n], p3 = ngon[e],\n+    p4 = ngon[j], p5 = ngon[(j + 1) % n];\n+    const cv::Point2f dir12 = p2 - p1, dir45 = p5 - p4;\n+    const double det = dir12.cross(dir45);\n+    if(std::abs (det) < EPSILON )\n+    {\n+        flush(i, j, e);\n+        return balanced_intersections[i][j];\n+    }\n+\n+    BalancedIntersect bi;\n+    cv::Point2f temp = 2 * p3 - p2 - p4;\n+    const double s = temp.cross(dir45) / det;\n+    const double t = temp.cross(dir12) / det;\n+    if(s >= 0 && t >= 0)\n+    {\n+        bi.pi = p2 + dir12 * s;\n+        bi.pj = p4 - dir45 * t;\n+        bi.position = true;\n+\n+        const cv::Point2f dir_balanced = bi.pj - bi.pi,\n+        dir_left = p3 - ngon[(e - 1 + n) % n],\n+        dir_right = ngon[(e + 1) % n] - p3;\n+\n+        const double cross_left = dir_balanced.cross(dir_left),\n+        cross_right = dir_balanced.cross(dir_right);\n+        if((cross_left < 0 && cross_right < 0) || (cross_left > 0 && cross_right > 0))\n+        {\n+            BalancedIntersect reset;\n+            bi = reset;\n+            bi = flush(i, j, e);\n+        }\n+        else if(std::abs (cross_left) < EPSILON )\n+        {\n+            bi.flush = (e - 1 + n) % n;\n+            bi.extra_area =\n+            extraArea((i + 1) % n, (e - 1 + n) % n, ngon[(e - 1 + n) % n], bi.pi)\n+            + extraArea(e, j, ngon[j], bi.pj);\n+        }\n+        else if(std::abs (cross_right) < EPSILON )\n+        {\n+            bi.flush = e;\n+            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n+            + extraArea((e + 1) % n, j, ngon[j], bi.pj);\n+        }\n+        else\n+        {\n+            bi.extra_area = extraArea((i + 1) % n, e, ngon[e], bi.pi)\n+            + extraArea(e, j, ngon[j], bi.pj);\n+        }\n+    }\n+    else\n+    {\n+        flush(i, j, e);\n+    }\n+\n+    if(bi.extra_area < balanced_intersections[i][j].extra_area)\n+    {\n+        balanced_intersections[i][j] = bi;\n+    }\n+    return bi;\n+}\n+\n+//! Set function for the done attribute of BalancedIntersections\n+/*!\n+ * @param i             Index of first side\n+ * @param j             Index of second side\n+ */\n+void BalancedIntersections::markAsDone(int i, int j)\n+{\n+    balanced_intersections[i][j].done = true;\n+}\n+\n+//! Operator to get a vector of elements from BalancedIntersections\n+/*!\n+ * @param i             index of a side\n+ */\n+const std::vector<BalancedIntersect>& BalancedIntersections::operator[](\n+    size_t i) const\n+{\n+    return balanced_intersections[i];\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the one sided chain with minimal extra area\n+/*!\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findSingleE(int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = single_sides[i][j];\n+    if (one.done)\n+        return;\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        BalancedIntersect candidate = balanced_inters.balancedIntersect(i, j, e);\n+        if(candidate.extra_area < min_area)\n+        {\n+            min_area = candidate.extra_area;\n+            one.side = e;\n+            one.extra_area = candidate.extra_area;\n+            one.flush = false;\n+            one.exists = true;\n+        }\n+    }\n+    one.done = true;\n+    balanced_inters.markAsDone(i, j);\n+}\n+\n+//! Recursively repeat the search for the one sided chain with minimal extra area to shrink the boundaries of bigger distances\n+/*!\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::singleSideImpl(int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = single_sides[i][j1].side < 0 ? (j1 + 1) %n : single_sides[i][j1].side;\n+    int r = single_sides[i][j2].side < 0 ? (j2 - 1 + n) %n : single_sides[i][j2].side;\n+\n+    findSingleE(i, mid, l, r);\n+    singleSideImpl(i, j1, mid);\n+    singleSideImpl(i, mid, j2);\n+\n+    return;\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h = 1.\n+/*!\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findMiddleE1(int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = middle_sides[1][i][j];\n+    if (one.done)\n+        return;\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        const FlushIntersect& before = intersections.lineIntersect(i, e);\n+        if(!before.intersection.position)\n+            continue;\n+        const FlushIntersect& after = intersections.lineIntersect(e, j);\n+        if(!after.intersection.position)\n+            continue;\n+\n+        double tmp_area = before.extra_area + after.extra_area;\n+        if(tmp_area < min_area)\n+        {\n+            min_area = tmp_area;\n+            one.side = e;\n+            one.extra_area = tmp_area;\n+            one.exists = true;\n+            one.flush = true;\n+        }\n+    }\n+    one.done = true;\n+}\n+\n+//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h = 1.\n+/*!\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::middleSideImpl1(int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = middle_sides[1][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[1][i][j1].side;\n+    int r = middle_sides[1][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[1][i][j2].side;\n+\n+    findMiddleE1(i, mid, l, r);\n+    middleSideImpl1(i, j1, mid);\n+    middleSideImpl1(i, mid, j2);\n+\n+    return;\n+}\n+\n+//! For a combination of two fixed sides of the ngon test all sides between left and right boundary to find the middle side of the h-sided chain with minimal extra area. This is the version for h > 1.\n+/*!\n+ * @param h     Length of the h-sided chain\n+ * @param i     Index of first fixed side\n+ * @param j     Index of second fixed side\n+ * @param l     Index of left boundary\n+ * @param r     Index of right boundary\n+ */\n+void Chains::findMiddleE(int h, int i, int j, int l, int r)\n+{\n+    const size_t n = ngon.size();\n+    Segment& one = middle_sides[h][i][j];\n+    if (one.done)\n+        return;\n+\n+    const int dist = (i <= j ? (j - i) : (j + n - i));\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+\n+    if(dist == 0)\n+        throw std::logic_error(\"\");\n+    if(dist - 1 < h)\n+    {\n+        one.done = true;\n+        return;\n+    }\n+    if(dist - 1 == h)\n+    {\n+        one.side = (i + h_floor + 1) % n;\n+        one.extra_area = 0.0;\n+        one.exists = true;\n+        one.flush = true;\n+        one.done = true;\n+        return;\n+    }\n+\n+    double min_area = std::numeric_limits<double>::max();\n+    for (int e = l; e != r + 1 && e != j; e = (e + 1) %n)\n+    {\n+        const Segment& before = middle_sides[h_floor][i][e];\n+        if (before.extra_area == std::numeric_limits<double>::max())\n+            continue;\n+        const Segment& after = middle_sides[h_ceil][e][j];\n+        if(after.extra_area == std::numeric_limits<double>::max())\n+            continue;\n+\n+        double tmp_area = before.extra_area + after.extra_area;\n+        if(tmp_area < min_area)\n+        {\n+            min_area = tmp_area;\n+            one.side = e;\n+            one.extra_area = tmp_area;\n+            one.exists = true;\n+            one.flush = true;\n+        }\n+    }\n+    one.done = true;\n+}\n+\n+//! Recursively repeat the search for the middle side of the h-sided chain with minimal extra area to shrink the boundaries of bigger distances. This is the version for h > 1.\n+/*!\n+ * @param h     Length of the h-sided chain\n+ * @param i     Fixed side of the ngon\n+ * @param j1    Lower boundary of search intervall\n+ * @param j2    Upper boundary of search intervall\n+ */\n+void Chains::middleSideImpl(int h, int i, int j1, int j2)\n+{\n+    const size_t n = ngon.size();\n+    if((j1 + 1) %n == j2)\n+    {\n+        return;\n+    }\n+\n+    int mid = (j1 < j2 ? ((j1 + j2) / 2) : ((j1 + n + j2) / 2)) % n;\n+    int l = middle_sides[h][i][j1].side < 0 ? (j1 + 1) %n : middle_sides[h][i][j1].side;\n+    int r = middle_sides[h][i][j2].side < 0 ? (j2 - 1 + n) %n : middle_sides[h][i][j2].side;\n+\n+    findMiddleE(h, i, mid, l, r);\n+    middleSideImpl(h, i, j1, mid);\n+    middleSideImpl(h, i, mid, j2);\n+\n+    return;\n+}\n+\n+//! Calculate the relevant chain lengths. Starting with a maximum chain length of h, down to a chain length of 1, only chains with half the length of the chain before are needed.\n+/*!\n+ * @param h     Length of the longest chain (h = k - 3)\n+ */\n+std::set<int> Chains::relevantChainLengths(int h)\n+{\n+    if(h <= 1)\n+        return {h};\n+\n+    std::set<int> hs = {h};\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+    std::set<int> h1 = relevantChainLengths(h_floor);\n+    for(const int& hNew : h1)\n+        hs.insert(hNew);\n+    if (h_ceil != h_floor)\n+    {\n+        std::set<int> h2 = relevantChainLengths(h_ceil);\n+        for(const int& hNew : h2)\n+            hs.insert(hNew);\n+    }\n+    return hs;\n+}\n+\n+//! Recursively calculate all the onesided chains for each combination of polygon sides.\n+/*!\n+ */\n+void Chains::calcOneSidedChains()\n+{\n+    const size_t n = ngon.size();\n+    for(size_t i = 0; i < n; i++)\n+    {\n+        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+        findSingleE(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+        findSingleE(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+        singleSideImpl(i, j1, j2);\n+    }\n+}\n+\n+//! Recursively calculate the middle sides of the h-sided chains for all combinations of polygon sides.\n+/*!\n+ * @param h     Length of the chains\n+ */\n+void Chains::calcMiddleChains(int h)\n+{\n+    const size_t n = ngon.size();\n+    if (h == 0)\n+    {\n+        for (size_t i = 0; i < n; i++)\n+        {\n+            for (size_t j = 0; j < n; j++)\n+            {\n+                Segment& one = middle_sides[h][i][j];\n+                const FlushIntersect itrs = intersections.lineIntersect(i, j);\n+\n+                one.side = -1;\n+                one.extra_area = itrs.extra_area;\n+                one.exists = false;\n+                one.flush = false;\n+                one.done = true;\n+            }\n+        }\n+        return;\n+    }\n+    if (h == 1)\n+    {\n+        for (size_t i = 0; i < n; i++)\n+        {\n+            int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+            findMiddleE1(i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+            findMiddleE1(i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+            middleSideImpl1(i, j1, j2);\n+        }\n+        return;\n+    }\n+\n+    for (size_t i = 0; i < n; i++)\n+    {\n+        int j1 = (i + 2) %n, j2 = (i - 2 + n) %n;\n+\n+        findMiddleE(h, i, j1, (i + 1) %n, (j1 - 1 + n) %n);\n+        findMiddleE(h, i, j2, (i + 1) %n, (j2 - 1 + n) %n);\n+        middleSideImpl(h, i, j1, j2);\n+    }\n+}\n+\n+//! Find the i and j with the smallest extra area.\n+/*!\n+ * @param n             Number of sides of the input polygon\n+ * @param k             Number of sides of the output polygon\n+ */\n+Minimum Chains::minimumArea(int n, int k)\n+{\n+    Minimum min{};\n+    for(int i = 0; i < n; i++)\n+    {\n+        for(int j = 0; j < n; j++)\n+        {\n+            if(!single_sides[i][j].exists || !middle_sides[k - 3][j][i].exists)\n+                continue;\n+\n+            double tmp_area =\n+            single_sides[i][j].extra_area + middle_sides[k - 3][j][i].extra_area;\n+            if(tmp_area < min.area)\n+            {\n+                min.area = tmp_area;\n+                min.i = i;\n+                min.j = j;\n+            }\n+        }\n+    }\n+    return min;\n+}\n+\n+//! Reconstruct the h-sided chain based on the two sides that give the smalles extra area.\n+/*!\n+ * @param h             Length of the k - 3 sided chain.\n+ * @param i             First index from minimumArea\n+ * @param j             Second index from minimumArea\n+ */\n+std::vector<Side> Chains::reconstructHSidedChain(int h, int i, int j)\n+{\n+    if(h == 0)\n+    {\n+        throw std::logic_error(\"\");\n+    }\n+    if(h == 1)\n+    {\n+        return std::vector<Side>{{middle_sides[h][i][j].side, true}};\n+    }\n+\n+    std::vector<Side> before, after;\n+    const int h_floor = (h - 1) / 2;\n+    const int h_ceil = h - 1 - h_floor;\n+    if(h_floor > 0)\n+        before = reconstructHSidedChain(h_floor, i, middle_sides[h][i][j].side);\n+    if(h_ceil > 0)\n+        after = reconstructHSidedChain(h_ceil, middle_sides[h][i][j].side, j);\n+\n+    std::vector<Side> sides{{middle_sides[h][i][j].side, true}};\n+    sides.insert(sides.end(), before.begin(), before.end());\n+    sides.insert(sides.end(), after.begin(), after.end());\n+    return sides;\n+}\n+\n+//! Get the k sides that build the kgon based on the two sides that give the smalles extra area.\n+/*!\n+ * @param k             Number of sides of the output polygon\n+ * @param i             First index from minimumArea\n+ * @param j             Second index from minimumArea\n+ */\n+std::vector<Side> Chains::findKSides(int k, int i, int j)\n+{\n+    std::vector<Side> sides;\n+    sides.push_back({i, true});\n+    sides.push_back({j, true});\n+\n+    if(single_sides[i][j].flush)\n+        sides.push_back({single_sides[i][j].side, true});\n+    else\n+        sides.push_back({single_sides[i][j].side, false});\n+\n+    std::vector<Side> flush_chain = reconstructHSidedChain(k - 3, j, i);\n+    sides.insert(sides.end(), flush_chain.begin(), flush_chain.end());\n+    std::sort(sides.begin(), sides.end(),\n+              [](const Side& lhs, const Side& rhs) { return lhs.side < rhs.side; });\n+\n+    return sides;\n+}\n+\n+//! Calculate the k vertices of the kgon from its k sides.\n+/*!\n+ * @param sides         Sides of the output polygon\n+ */\n+std::vector<cv::Point2f> Chains::findKVertices(std::vector<Side>& sides)\n+{\n+    const int k = sides.size();\n+    std::vector<cv::Point2f> vertices(k);\n+\n+    for(int u = 0; u < k; u++)\n+    {\n+        const int next = (u + 1) % k;\n+        if(sides[u].flush && sides[next].flush)\n+        {\n+            vertices[u] = intersections.lineIntersect(sides[u].side,\n+                                                      sides[next].side).intersection.point;\n+        }\n+        else if(sides[u].flush && !sides[next].flush)\n+        {\n+            vertices[u] = balanced_inters[sides[u].side][sides[(u + 2) % k].side].pi;\n+        }\n+        else if(!sides[u].flush && sides[next].flush)\n+        {\n+            vertices[u] = balanced_inters[sides[(u - 1 + k) %k].side][sides[next].side].pj;\n+        }\n+        else\n+        {\n+            throw std::logic_error(\"\");",
        "comment_created_at": "2025-06-18T07:17:46+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "OpenCV uses CV_Assert for such purposes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2073337340",
    "pr_number": 27051,
    "pr_file": "modules/photo/src/ccm/utils.cpp",
    "created_at": "2025-05-05T12:20:27+00:00",
    "commented_code": "namespace cv {\nnamespace ccm {\n\ninline double gammaCorrection_(double element, double gamma)\ninline double gammaOp(double element, double gamma)\n{\n    return (element >= 0 ? pow(element, gamma) : -pow((-element), gamma));\n    return (element >= 0.0) ? pow(element, gamma) : -pow(-element, gamma);\n}\n\nMat gammaCorrection(const Mat& src, double gamma, Mat dst)\nvoid gammaCorrection(InputArray _src, OutputArray _dst, double gamma)\n{\n    return elementWise(src, [gamma](double element) -> double { return gammaCorrection_(element, gamma); }, dst);\n    Mat src = _src.getMat();",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2073337340",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27051,
        "pr_file": "modules/photo/src/ccm/utils.cpp",
        "discussion_id": "2073337340",
        "commented_code": "@@ -11,14 +11,23 @@\n namespace cv {\n namespace ccm {\n \n-inline double gammaCorrection_(double element, double gamma)\n+inline double gammaOp(double element, double gamma)\n {\n-    return (element >= 0 ? pow(element, gamma) : -pow((-element), gamma));\n+    return (element >= 0.0) ? pow(element, gamma) : -pow(-element, gamma);\n }\n \n-Mat gammaCorrection(const Mat& src, double gamma, Mat dst)\n+void gammaCorrection(InputArray _src, OutputArray _dst, double gamma)\n {\n-    return elementWise(src, [gamma](double element) -> double { return gammaCorrection_(element, gamma); }, dst);\n+    Mat src = _src.getMat();",
        "comment_created_at": "2025-05-05T12:20:27+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "please add CV_Assert with input type checks at least. The function is public API now and should handle invalid input correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2139828248",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27051,
        "pr_file": "modules/photo/src/ccm/utils.cpp",
        "discussion_id": "2073337340",
        "commented_code": "@@ -11,14 +11,23 @@\n namespace cv {\n namespace ccm {\n \n-inline double gammaCorrection_(double element, double gamma)\n+inline double gammaOp(double element, double gamma)\n {\n-    return (element >= 0 ? pow(element, gamma) : -pow((-element), gamma));\n+    return (element >= 0.0) ? pow(element, gamma) : -pow(-element, gamma);\n }\n \n-Mat gammaCorrection(const Mat& src, double gamma, Mat dst)\n+void gammaCorrection(InputArray _src, OutputArray _dst, double gamma)\n {\n-    return elementWise(src, [gamma](double element) -> double { return gammaCorrection_(element, gamma); }, dst);\n+    Mat src = _src.getMat();",
        "comment_created_at": "2025-06-11T10:54:35+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "It's still relevant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2140012048",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27051,
        "pr_file": "modules/photo/src/ccm/utils.cpp",
        "discussion_id": "2073337340",
        "commented_code": "@@ -11,14 +11,23 @@\n namespace cv {\n namespace ccm {\n \n-inline double gammaCorrection_(double element, double gamma)\n+inline double gammaOp(double element, double gamma)\n {\n-    return (element >= 0 ? pow(element, gamma) : -pow((-element), gamma));\n+    return (element >= 0.0) ? pow(element, gamma) : -pow(-element, gamma);\n }\n \n-Mat gammaCorrection(const Mat& src, double gamma, Mat dst)\n+void gammaCorrection(InputArray _src, OutputArray _dst, double gamma)\n {\n-    return elementWise(src, [gamma](double element) -> double { return gammaCorrection_(element, gamma); }, dst);\n+    Mat src = _src.getMat();",
        "comment_created_at": "2025-06-11T12:31:48+00:00",
        "comment_author": "abhishek-gola",
        "comment_body": "@asmorkalov CV_ASSERT for gamma and type checks using switch have already been added. Please check the updated file.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2053519772",
    "pr_number": 27177,
    "pr_file": "modules/dnn/src/llm/gguf_buffer.cpp",
    "created_at": "2025-04-22T07:37:55+00:00",
    "commented_code": "#include \"../precomp.hpp\"\n#include \"gguf_buffer.hpp\"\n\n\nnamespace cv { namespace dnn {\nCV__DNN_INLINE_NS_BEGIN\n\nGGUFBuffer::GGUFBuffer(const std::string & fileName){\n    std::ifstream file(fileName, std::ios::binary | std::ios::ate);\n    if (!file.is_open()) {\n        throw std::runtime_error(\"Could not open file: \");",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "2053519772",
        "repo_full_name": "opencv/opencv",
        "pr_number": 27177,
        "pr_file": "modules/dnn/src/llm/gguf_buffer.cpp",
        "discussion_id": "2053519772",
        "commented_code": "@@ -0,0 +1,161 @@\n+#include \"../precomp.hpp\"\n+#include \"gguf_buffer.hpp\"\n+\n+\n+namespace cv { namespace dnn {\n+CV__DNN_INLINE_NS_BEGIN\n+\n+GGUFBuffer::GGUFBuffer(const std::string & fileName){\n+    std::ifstream file(fileName, std::ios::binary | std::ios::ate);\n+    if (!file.is_open()) {\n+        throw std::runtime_error(\"Could not open file: \");",
        "comment_created_at": "2025-04-22T07:37:55+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "Please use CV_Error, CV_Assert, etc. See https://docs.opencv.org/5.x/db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1936883220",
    "pr_number": 26859,
    "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
    "created_at": "2025-01-31T08:49:23+00:00",
    "commented_code": "} else {\n                cvtColor(img_, img, COLOR_BGRA2BGR);\n            }\n        } else {\n        } else if (img.channels() == 4){\n            if (m_use_rgb) {\n                cvtColor(img_, img, COLOR_BGRA2RGBA);\n            } else {\n                img_.copyTo(img);\n            }\n        } else if (img.channels() == 1){\n            cvtColor(img_, img, COLOR_BGRA2GRAY);\n        } else {\n            CV_LOG_WARNING(NULL, \"Unsupported channels\");",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1936883220",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26859,
        "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
        "discussion_id": "1936883220",
        "commented_code": "@@ -172,12 +172,17 @@ bool GifDecoder::readData(Mat &img) {\n             } else {\n                 cvtColor(img_, img, COLOR_BGRA2BGR);\n             }\n-        } else {\n+        } else if (img.channels() == 4){\n             if (m_use_rgb) {\n                 cvtColor(img_, img, COLOR_BGRA2RGBA);\n             } else {\n                 img_.copyTo(img);\n             }\n+        } else if (img.channels() == 1){\n+            cvtColor(img_, img, COLOR_BGRA2GRAY);\n+        } else {\n+            CV_LOG_WARNING(NULL, \"Unsupported channels\");",
        "comment_created_at": "2025-01-31T08:49:23+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "It's error. I propose to include amount of channels to error message in printf style like https://github.com/opencv/opencv/blob/c21d0ad9d08d364542bb4a6eb971ee3051ccba63/modules/imgcodecs/src/grfmt_jpeg.cpp#L771",
        "pr_file_module": null
      },
      {
        "comment_id": "1937124526",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26859,
        "pr_file": "modules/imgcodecs/src/grfmt_gif.cpp",
        "discussion_id": "1936883220",
        "commented_code": "@@ -172,12 +172,17 @@ bool GifDecoder::readData(Mat &img) {\n             } else {\n                 cvtColor(img_, img, COLOR_BGRA2BGR);\n             }\n-        } else {\n+        } else if (img.channels() == 4){\n             if (m_use_rgb) {\n                 cvtColor(img_, img, COLOR_BGRA2RGBA);\n             } else {\n                 img_.copyTo(img);\n             }\n+        } else if (img.channels() == 1){\n+            cvtColor(img_, img, COLOR_BGRA2GRAY);\n+        } else {\n+            CV_LOG_WARNING(NULL, \"Unsupported channels\");",
        "comment_created_at": "2025-01-31T12:03:48+00:00",
        "comment_author": "Kumataro",
        "comment_body": "Thank you for your comment, I fixed it to show `img.channels()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1820140600",
    "pr_number": 26379,
    "pr_file": "modules/imgcodecs/src/grfmt_jpegxl.cpp",
    "created_at": "2024-10-29T06:05:36+00:00",
    "commented_code": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#include \"precomp.hpp\"\n#include \"grfmt_jpegxl.hpp\"\n\n#ifdef HAVE_JPEGXL\n\n#include <opencv2/core/utils/logger.hpp>\n\nnamespace cv\n{\n\n/////////////////////// JpegXLDecoder ///////////////////\n\nJpegXLDecoder::JpegXLDecoder() : m_f(nullptr, fclose)\n{\n    m_signature = \"\\xFF\\x0A\";\n    m_decoder = nullptr;\n    m_buf_supported = true;\n    m_type = -1;\n}\n\nJpegXLDecoder::~JpegXLDecoder()\n{\n    close();\n}\n\nvoid JpegXLDecoder::close()\n{\n    if (m_decoder)\n        m_decoder.release();\n    if (m_f)\n        m_f.release();\n    m_read_buffer = {};\n    m_width = m_height = 0;\n    m_type = -1;\n}\n\nImageDecoder JpegXLDecoder::newDecoder() const\n{\n    return makePtr<JpegXLDecoder>();\n}\n\nbool JpegXLDecoder::read(Mat* pimg)\n{\n    // Open file\n    if (!m_f) {\n        m_f.reset(fopen(m_filename.c_str(), \"rb\"));\n        if (!m_f)\n            return false;\n    }\n\n    // Initialize decoder\n    if (!m_decoder) {\n        m_decoder = JxlDecoderMake(nullptr);\n        if (!m_decoder)\n            return false;\n        // Subscribe to the basic info event\n        JxlDecoderStatus status = JxlDecoderSubscribeEvents(m_decoder.get(), JXL_DEC_BASIC_INFO | JXL_DEC_FULL_IMAGE);\n        if (status != JXL_DEC_SUCCESS)\n            return false;\n    }\n\n    // Set up parallel m_parallel_runner\n    if (!m_parallel_runner) {\n        m_parallel_runner = JxlThreadParallelRunnerMake(nullptr, JxlThreadParallelRunnerDefaultNumWorkerThreads());\n        if (JXL_DEC_SUCCESS != JxlDecoderSetParallelRunner(m_decoder.get(),\n                                                            JxlThreadParallelRunner,\n                                                            m_parallel_runner.get())) {\n            return false;\n        }\n    }\n\n    // Create buffer for reading\n    const size_t read_buffer_size = 16384;  // 16KB chunks\n    if (m_read_buffer.capacity() < read_buffer_size)\n        m_read_buffer.resize(read_buffer_size);\n\n    // Create image if needed\n    if (m_type != -1 && pimg) {\n        pimg->create(m_height, m_width, m_type);\n        if (!pimg->isContinuous())\n            return false;\n        if (JXL_DEC_SUCCESS != JxlDecoderSetImageOutBuffer(m_decoder.get(), \n                                                        &m_format,\n                                                        pimg->ptr<uint8_t>(),\n                                                        pimg->total() * pimg->elemSize())) {\n            return false;\n        }\n    }\n\n    // Start decoding loop\n    JxlDecoderStatus status = JXL_DEC_NEED_MORE_INPUT;\n    do {\n        // Check if we need more input\n        if (status == JXL_DEC_NEED_MORE_INPUT) {\n            size_t remaining = JxlDecoderReleaseInput(m_decoder.get());\n            // Move any remaining bytes to the beginning\n            if (remaining > 0) {\n                memmove(m_read_buffer.data(), m_read_buffer.data() + m_read_buffer.size() - remaining, remaining);\n            }\n            \n            // Read more data from file\n            size_t bytes_read = fread(m_read_buffer.data() + remaining, \n                                    1, m_read_buffer.size() - remaining, m_f.get());\n            if (bytes_read == 0) {\n                if (ferror(m_f.get())) {\n                    throw std::runtime_error(\"Error reading input file\");\n                }\n                // If we reached EOF but decoder needs more input, file is truncated\n                if (status == JXL_DEC_NEED_MORE_INPUT) {\n                    throw std::runtime_error(\"Truncated JXL file\");\n                }",
    "repo_full_name": "opencv/opencv",
    "discussion_comments": [
      {
        "comment_id": "1820140600",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26379,
        "pr_file": "modules/imgcodecs/src/grfmt_jpegxl.cpp",
        "discussion_id": "1820140600",
        "commented_code": "@@ -0,0 +1,376 @@\n+/*M///////////////////////////////////////////////////////////////////////////////////////\n+//\n+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n+//\n+//  By downloading, copying, installing or using the software you agree to this license.\n+//  If you do not agree to this license, do not download, install,\n+//  copy or use the software.\n+//\n+//\n+//                        Intel License Agreement\n+//                For Open Source Computer Vision Library\n+//\n+// Copyright (C) 2000, Intel Corporation, all rights reserved.\n+// Third party copyrights are property of their respective owners.\n+//\n+// Redistribution and use in source and binary forms, with or without modification,\n+// are permitted provided that the following conditions are met:\n+//\n+//   * Redistribution's of source code must retain the above copyright notice,\n+//     this list of conditions and the following disclaimer.\n+//\n+//   * Redistribution's in binary form must reproduce the above copyright notice,\n+//     this list of conditions and the following disclaimer in the documentation\n+//     and/or other materials provided with the distribution.\n+//\n+//   * The name of Intel Corporation may not be used to endorse or promote products\n+//     derived from this software without specific prior written permission.\n+//\n+// This software is provided by the copyright holders and contributors \"as is\" and\n+// any express or implied warranties, including, but not limited to, the implied\n+// warranties of merchantability and fitness for a particular purpose are disclaimed.\n+// In no event shall the Intel Corporation or contributors be liable for any direct,\n+// indirect, incidental, special, exemplary, or consequential damages\n+// (including, but not limited to, procurement of substitute goods or services;\n+// loss of use, data, or profits; or business interruption) however caused\n+// and on any theory of liability, whether in contract, strict liability,\n+// or tort (including negligence or otherwise) arising in any way out of\n+// the use of this software, even if advised of the possibility of such damage.\n+//\n+//M*/\n+\n+#include \"precomp.hpp\"\n+#include \"grfmt_jpegxl.hpp\"\n+\n+#ifdef HAVE_JPEGXL\n+\n+#include <opencv2/core/utils/logger.hpp>\n+\n+namespace cv\n+{\n+\n+/////////////////////// JpegXLDecoder ///////////////////\n+\n+JpegXLDecoder::JpegXLDecoder() : m_f(nullptr, fclose)\n+{\n+    m_signature = \"\\xFF\\x0A\";\n+    m_decoder = nullptr;\n+    m_buf_supported = true;\n+    m_type = -1;\n+}\n+\n+JpegXLDecoder::~JpegXLDecoder()\n+{\n+    close();\n+}\n+\n+void JpegXLDecoder::close()\n+{\n+    if (m_decoder)\n+        m_decoder.release();\n+    if (m_f)\n+        m_f.release();\n+    m_read_buffer = {};\n+    m_width = m_height = 0;\n+    m_type = -1;\n+}\n+\n+ImageDecoder JpegXLDecoder::newDecoder() const\n+{\n+    return makePtr<JpegXLDecoder>();\n+}\n+\n+bool JpegXLDecoder::read(Mat* pimg)\n+{\n+    // Open file\n+    if (!m_f) {\n+        m_f.reset(fopen(m_filename.c_str(), \"rb\"));\n+        if (!m_f)\n+            return false;\n+    }\n+\n+    // Initialize decoder\n+    if (!m_decoder) {\n+        m_decoder = JxlDecoderMake(nullptr);\n+        if (!m_decoder)\n+            return false;\n+        // Subscribe to the basic info event\n+        JxlDecoderStatus status = JxlDecoderSubscribeEvents(m_decoder.get(), JXL_DEC_BASIC_INFO | JXL_DEC_FULL_IMAGE);\n+        if (status != JXL_DEC_SUCCESS)\n+            return false;\n+    }\n+\n+    // Set up parallel m_parallel_runner\n+    if (!m_parallel_runner) {\n+        m_parallel_runner = JxlThreadParallelRunnerMake(nullptr, JxlThreadParallelRunnerDefaultNumWorkerThreads());\n+        if (JXL_DEC_SUCCESS != JxlDecoderSetParallelRunner(m_decoder.get(),\n+                                                            JxlThreadParallelRunner,\n+                                                            m_parallel_runner.get())) {\n+            return false;\n+        }\n+    }\n+\n+    // Create buffer for reading\n+    const size_t read_buffer_size = 16384;  // 16KB chunks\n+    if (m_read_buffer.capacity() < read_buffer_size)\n+        m_read_buffer.resize(read_buffer_size);\n+\n+    // Create image if needed\n+    if (m_type != -1 && pimg) {\n+        pimg->create(m_height, m_width, m_type);\n+        if (!pimg->isContinuous())\n+            return false;\n+        if (JXL_DEC_SUCCESS != JxlDecoderSetImageOutBuffer(m_decoder.get(), \n+                                                        &m_format,\n+                                                        pimg->ptr<uint8_t>(),\n+                                                        pimg->total() * pimg->elemSize())) {\n+            return false;\n+        }\n+    }\n+\n+    // Start decoding loop\n+    JxlDecoderStatus status = JXL_DEC_NEED_MORE_INPUT;\n+    do {\n+        // Check if we need more input\n+        if (status == JXL_DEC_NEED_MORE_INPUT) {\n+            size_t remaining = JxlDecoderReleaseInput(m_decoder.get());\n+            // Move any remaining bytes to the beginning\n+            if (remaining > 0) {\n+                memmove(m_read_buffer.data(), m_read_buffer.data() + m_read_buffer.size() - remaining, remaining);\n+            }\n+            \n+            // Read more data from file\n+            size_t bytes_read = fread(m_read_buffer.data() + remaining, \n+                                    1, m_read_buffer.size() - remaining, m_f.get());\n+            if (bytes_read == 0) {\n+                if (ferror(m_f.get())) {\n+                    throw std::runtime_error(\"Error reading input file\");\n+                }\n+                // If we reached EOF but decoder needs more input, file is truncated\n+                if (status == JXL_DEC_NEED_MORE_INPUT) {\n+                    throw std::runtime_error(\"Truncated JXL file\");\n+                }",
        "comment_created_at": "2024-10-29T06:05:36+00:00",
        "comment_author": "asmorkalov",
        "comment_body": "OpenCV's `imread` is exception safe. Please use CV_LOG_WARNING and analogs and return satus instead of exception.",
        "pr_file_module": null
      },
      {
        "comment_id": "1820592738",
        "repo_full_name": "opencv/opencv",
        "pr_number": 26379,
        "pr_file": "modules/imgcodecs/src/grfmt_jpegxl.cpp",
        "discussion_id": "1820140600",
        "commented_code": "@@ -0,0 +1,376 @@\n+/*M///////////////////////////////////////////////////////////////////////////////////////\n+//\n+//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n+//\n+//  By downloading, copying, installing or using the software you agree to this license.\n+//  If you do not agree to this license, do not download, install,\n+//  copy or use the software.\n+//\n+//\n+//                        Intel License Agreement\n+//                For Open Source Computer Vision Library\n+//\n+// Copyright (C) 2000, Intel Corporation, all rights reserved.\n+// Third party copyrights are property of their respective owners.\n+//\n+// Redistribution and use in source and binary forms, with or without modification,\n+// are permitted provided that the following conditions are met:\n+//\n+//   * Redistribution's of source code must retain the above copyright notice,\n+//     this list of conditions and the following disclaimer.\n+//\n+//   * Redistribution's in binary form must reproduce the above copyright notice,\n+//     this list of conditions and the following disclaimer in the documentation\n+//     and/or other materials provided with the distribution.\n+//\n+//   * The name of Intel Corporation may not be used to endorse or promote products\n+//     derived from this software without specific prior written permission.\n+//\n+// This software is provided by the copyright holders and contributors \"as is\" and\n+// any express or implied warranties, including, but not limited to, the implied\n+// warranties of merchantability and fitness for a particular purpose are disclaimed.\n+// In no event shall the Intel Corporation or contributors be liable for any direct,\n+// indirect, incidental, special, exemplary, or consequential damages\n+// (including, but not limited to, procurement of substitute goods or services;\n+// loss of use, data, or profits; or business interruption) however caused\n+// and on any theory of liability, whether in contract, strict liability,\n+// or tort (including negligence or otherwise) arising in any way out of\n+// the use of this software, even if advised of the possibility of such damage.\n+//\n+//M*/\n+\n+#include \"precomp.hpp\"\n+#include \"grfmt_jpegxl.hpp\"\n+\n+#ifdef HAVE_JPEGXL\n+\n+#include <opencv2/core/utils/logger.hpp>\n+\n+namespace cv\n+{\n+\n+/////////////////////// JpegXLDecoder ///////////////////\n+\n+JpegXLDecoder::JpegXLDecoder() : m_f(nullptr, fclose)\n+{\n+    m_signature = \"\\xFF\\x0A\";\n+    m_decoder = nullptr;\n+    m_buf_supported = true;\n+    m_type = -1;\n+}\n+\n+JpegXLDecoder::~JpegXLDecoder()\n+{\n+    close();\n+}\n+\n+void JpegXLDecoder::close()\n+{\n+    if (m_decoder)\n+        m_decoder.release();\n+    if (m_f)\n+        m_f.release();\n+    m_read_buffer = {};\n+    m_width = m_height = 0;\n+    m_type = -1;\n+}\n+\n+ImageDecoder JpegXLDecoder::newDecoder() const\n+{\n+    return makePtr<JpegXLDecoder>();\n+}\n+\n+bool JpegXLDecoder::read(Mat* pimg)\n+{\n+    // Open file\n+    if (!m_f) {\n+        m_f.reset(fopen(m_filename.c_str(), \"rb\"));\n+        if (!m_f)\n+            return false;\n+    }\n+\n+    // Initialize decoder\n+    if (!m_decoder) {\n+        m_decoder = JxlDecoderMake(nullptr);\n+        if (!m_decoder)\n+            return false;\n+        // Subscribe to the basic info event\n+        JxlDecoderStatus status = JxlDecoderSubscribeEvents(m_decoder.get(), JXL_DEC_BASIC_INFO | JXL_DEC_FULL_IMAGE);\n+        if (status != JXL_DEC_SUCCESS)\n+            return false;\n+    }\n+\n+    // Set up parallel m_parallel_runner\n+    if (!m_parallel_runner) {\n+        m_parallel_runner = JxlThreadParallelRunnerMake(nullptr, JxlThreadParallelRunnerDefaultNumWorkerThreads());\n+        if (JXL_DEC_SUCCESS != JxlDecoderSetParallelRunner(m_decoder.get(),\n+                                                            JxlThreadParallelRunner,\n+                                                            m_parallel_runner.get())) {\n+            return false;\n+        }\n+    }\n+\n+    // Create buffer for reading\n+    const size_t read_buffer_size = 16384;  // 16KB chunks\n+    if (m_read_buffer.capacity() < read_buffer_size)\n+        m_read_buffer.resize(read_buffer_size);\n+\n+    // Create image if needed\n+    if (m_type != -1 && pimg) {\n+        pimg->create(m_height, m_width, m_type);\n+        if (!pimg->isContinuous())\n+            return false;\n+        if (JXL_DEC_SUCCESS != JxlDecoderSetImageOutBuffer(m_decoder.get(), \n+                                                        &m_format,\n+                                                        pimg->ptr<uint8_t>(),\n+                                                        pimg->total() * pimg->elemSize())) {\n+            return false;\n+        }\n+    }\n+\n+    // Start decoding loop\n+    JxlDecoderStatus status = JXL_DEC_NEED_MORE_INPUT;\n+    do {\n+        // Check if we need more input\n+        if (status == JXL_DEC_NEED_MORE_INPUT) {\n+            size_t remaining = JxlDecoderReleaseInput(m_decoder.get());\n+            // Move any remaining bytes to the beginning\n+            if (remaining > 0) {\n+                memmove(m_read_buffer.data(), m_read_buffer.data() + m_read_buffer.size() - remaining, remaining);\n+            }\n+            \n+            // Read more data from file\n+            size_t bytes_read = fread(m_read_buffer.data() + remaining, \n+                                    1, m_read_buffer.size() - remaining, m_f.get());\n+            if (bytes_read == 0) {\n+                if (ferror(m_f.get())) {\n+                    throw std::runtime_error(\"Error reading input file\");\n+                }\n+                // If we reached EOF but decoder needs more input, file is truncated\n+                if (status == JXL_DEC_NEED_MORE_INPUT) {\n+                    throw std::runtime_error(\"Truncated JXL file\");\n+                }",
        "comment_created_at": "2024-10-29T11:08:45+00:00",
        "comment_author": "cdcseacave",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  }
]