[
  {
    "discussion_id": "2279413911",
    "pr_number": 391,
    "pr_file": "languages/cpp/tree-sitter/Dummy_preprocessors.ml",
    "created_at": "2025-08-15T16:18:05+00:00",
    "commented_code": "+module S = String\n+\n+type single_line = string\n+\n+let is_start (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#if\" s ||\n+  S.starts_with ~prefix:\"#ifdef\" s ||\n+  S.starts_with ~prefix:\"#ifndef\" s\n+\n+let is_middle (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#else\" s ||\n+  S.starts_with ~prefix:\"#elif\" s\n+\n+let is_end (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#endif\" s\n+\n+let lines (s : string) : single_line list =\n+  S.split_on_char '\n' s\n+\n+let unlines (ls : single_line list) : string =\n+  S.concat \"\n\" ls\n+\n+type ctx = If | Else\n+\n+let keep_all (s : string) : string =\n+  let go (l : single_line) : single_line =\n+    if is_start l || is_middle l || is_end l\n+      then \"\"\n+      else l\n+  in\n+  s\n+  |> lines\n+  |> List.map go\n+  |> unlines\n+\n+let positive (s : string) : string =\n+  let go (ctx : ctx list) (l : single_line) : ctx list * single_line =\n+    (* invariant: never put If on Else *)\n+    match ctx with\n+    | If :: _ | [] when is_start l -> (If :: ctx), \"\"\n+    (* If we're under #else, we put Else even for #if, becase we don't print *)\n+    | Else :: _ when is_start l -> (Else :: ctx), \"\"\n+    | If :: ctx' when is_middle l -> (Else :: ctx'), \"\"\n+    | _ when is_middle l -> ctx, \"\"\n+    | _ :: ctx' when is_end l -> ctx', \"\"\n+    | If :: _ | [] -> ctx, l\n+    | _ -> ctx, l",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2279413911",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 391,
        "pr_file": "languages/cpp/tree-sitter/Dummy_preprocessors.ml",
        "discussion_id": "2279413911",
        "commented_code": "@@ -0,0 +1,56 @@\n+module S = String\n+\n+type single_line = string\n+\n+let is_start (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#if\" s ||\n+  S.starts_with ~prefix:\"#ifdef\" s ||\n+  S.starts_with ~prefix:\"#ifndef\" s\n+\n+let is_middle (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#else\" s ||\n+  S.starts_with ~prefix:\"#elif\" s\n+\n+let is_end (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#endif\" s\n+\n+let lines (s : string) : single_line list =\n+  S.split_on_char '\\n' s\n+\n+let unlines (ls : single_line list) : string =\n+  S.concat \"\\n\" ls\n+\n+type ctx = If | Else\n+\n+let keep_all (s : string) : string =\n+  let go (l : single_line) : single_line =\n+    if is_start l || is_middle l || is_end l\n+      then \"\"\n+      else l\n+  in\n+  s\n+  |> lines\n+  |> List.map go\n+  |> unlines\n+\n+let positive (s : string) : string =\n+  let go (ctx : ctx list) (l : single_line) : ctx list * single_line =\n+    (* invariant: never put If on Else *)\n+    match ctx with\n+    | If :: _ | [] when is_start l -> (If :: ctx), \"\"\n+    (* If we're under #else, we put Else even for #if, becase we don't print *)\n+    | Else :: _ when is_start l -> (Else :: ctx), \"\"\n+    | If :: ctx' when is_middle l -> (Else :: ctx'), \"\"\n+    | _ when is_middle l -> ctx, \"\"\n+    | _ :: ctx' when is_end l -> ctx', \"\"\n+    | If :: _ | [] -> ctx, l\n+    | _ -> ctx, l",
        "comment_created_at": "2025-08-15T16:18:05+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Why do we need 2 cases here instead of 1 (the last)?",
        "pr_file_module": null
      },
      {
        "comment_id": "2279584477",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 391,
        "pr_file": "languages/cpp/tree-sitter/Dummy_preprocessors.ml",
        "discussion_id": "2279413911",
        "commented_code": "@@ -0,0 +1,56 @@\n+module S = String\n+\n+type single_line = string\n+\n+let is_start (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#if\" s ||\n+  S.starts_with ~prefix:\"#ifdef\" s ||\n+  S.starts_with ~prefix:\"#ifndef\" s\n+\n+let is_middle (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#else\" s ||\n+  S.starts_with ~prefix:\"#elif\" s\n+\n+let is_end (l : single_line) : bool =\n+  let s = S.trim l in\n+  S.starts_with ~prefix:\"#endif\" s\n+\n+let lines (s : string) : single_line list =\n+  S.split_on_char '\\n' s\n+\n+let unlines (ls : single_line list) : string =\n+  S.concat \"\\n\" ls\n+\n+type ctx = If | Else\n+\n+let keep_all (s : string) : string =\n+  let go (l : single_line) : single_line =\n+    if is_start l || is_middle l || is_end l\n+      then \"\"\n+      else l\n+  in\n+  s\n+  |> lines\n+  |> List.map go\n+  |> unlines\n+\n+let positive (s : string) : string =\n+  let go (ctx : ctx list) (l : single_line) : ctx list * single_line =\n+    (* invariant: never put If on Else *)\n+    match ctx with\n+    | If :: _ | [] when is_start l -> (If :: ctx), \"\"\n+    (* If we're under #else, we put Else even for #if, becase we don't print *)\n+    | Else :: _ when is_start l -> (Else :: ctx), \"\"\n+    | If :: ctx' when is_middle l -> (Else :: ctx'), \"\"\n+    | _ when is_middle l -> ctx, \"\"\n+    | _ :: ctx' when is_end l -> ctx', \"\"\n+    | If :: _ | [] -> ctx, l\n+    | _ -> ctx, l",
        "comment_created_at": "2025-08-15T17:51:20+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "The last case should be `-> ctx, \"\"`. fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2243560319",
    "pr_number": 376,
    "pr_file": "src/optimizing/Analyze_rule.ml",
    "created_at": "2025-07-30T18:31:35+00:00",
    "commented_code": "| R.CondEval _ -> None\n   | R.CondNestedFormula _ -> None\n   | R.CondRegexp (mvar, re, const_prop) ->\n-      if is_id_mvar mvar then Some (MvarRegexp (mvar, re, const_prop)) else None\n+      if is_id_mvar mvar then Some (MvarRegexp (mvar, re.pattern, const_prop)) else None",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2243560319",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 376,
        "pr_file": "src/optimizing/Analyze_rule.ml",
        "discussion_id": "2243560319",
        "commented_code": "@@ -354,7 +354,7 @@ and metavarcond_step1 ~is_id_mvar x =\n   | R.CondEval _ -> None\n   | R.CondNestedFormula _ -> None\n   | R.CondRegexp (mvar, re, const_prop) ->\n-      if is_id_mvar mvar then Some (MvarRegexp (mvar, re, const_prop)) else None\n+      if is_id_mvar mvar then Some (MvarRegexp (mvar, re.pattern, const_prop)) else None",
        "comment_created_at": "2025-07-30T18:31:35+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "I think `MvarRegexp` should also take the full pcre object, for example we have code like this were compilation happens: \r\n\r\n```ocaml\r\nlet or_step2 (Or xs) =\r\n  let step1_to_step2 =\r\n    List_.map (function\r\n      | StringsAndMvars ([], _) -> raise GeneralPattern\r\n      | StringsAndMvars (xs, _) -> Idents xs\r\n      | Regexp re_str -> Regexp2_search (Pcre2_.pcre_compile re_str)\r\n      | MvarRegexp (_mvar, re_str, _const_prop) ->\r\n          (* The original regexp is meant to apply on a substring.\r\n              We rewrite them to remove end-of-string anchors if possible. *)\r\n          let re =\r\n            match\r\n              Pcre2_.remove_end_of_string_assertions\r\n                (Pcre2_.pcre_compile re_str)\r\n            with\r\n            | None -> raise GeneralPattern\r\n            | Some re -> re\r\n          in\r\n          Regexp2_search re)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2243567514",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 376,
        "pr_file": "src/optimizing/Analyze_rule.ml",
        "discussion_id": "2243560319",
        "commented_code": "@@ -354,7 +354,7 @@ and metavarcond_step1 ~is_id_mvar x =\n   | R.CondEval _ -> None\n   | R.CondNestedFormula _ -> None\n   | R.CondRegexp (mvar, re, const_prop) ->\n-      if is_id_mvar mvar then Some (MvarRegexp (mvar, re, const_prop)) else None\n+      if is_id_mvar mvar then Some (MvarRegexp (mvar, re.pattern, const_prop)) else None",
        "comment_created_at": "2025-07-30T18:35:06+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "same as above: no `ANCHOR` flag + `remove_end_of_string_assertions`, which we cannot do after we compile",
        "pr_file_module": null
      },
      {
        "comment_id": "2243589308",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 376,
        "pr_file": "src/optimizing/Analyze_rule.ml",
        "discussion_id": "2243560319",
        "commented_code": "@@ -354,7 +354,7 @@ and metavarcond_step1 ~is_id_mvar x =\n   | R.CondEval _ -> None\n   | R.CondNestedFormula _ -> None\n   | R.CondRegexp (mvar, re, const_prop) ->\n-      if is_id_mvar mvar then Some (MvarRegexp (mvar, re, const_prop)) else None\n+      if is_id_mvar mvar then Some (MvarRegexp (mvar, re.pattern, const_prop)) else None",
        "comment_created_at": "2025-07-30T18:46:28+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Ok -- and same comment as above, we can ignore I think.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2221939101",
    "pr_number": 358,
    "pr_file": "src/engine/Match_taint_spec.ml",
    "created_at": "2025-07-22T09:48:52+00:00",
    "commented_code": "(* =~ List.concat_map with automatic management of matching-explanations *)\n let concat_map_with_expls f xs =\n-  let all_expls = ref [] in\n-  let res =\n-    xs\n-    |> List.concat_map (fun x ->\n-           let ys, expls = f x in\n-           Stack_.push expls all_expls;\n-           ys)\n+  let lhs, rhs =\n+    List.fold_left_map\n+      (fun acc x ->\n+        let l, r = f x in\n+        (l :: acc, r))\n+      [] xs\n   in\n-  (res, List_.flatten (List.rev !all_expls))\n+  (List.flatten (List.rev lhs), List.flatten rhs)",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2221939101",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 358,
        "pr_file": "src/engine/Match_taint_spec.ml",
        "discussion_id": "2221939101",
        "commented_code": "@@ -99,15 +99,14 @@ let range_w_metas_of_formula (xconf : Match_env.xconfig) (xtarget : Xtarget.t)\n \n (* =~ List.concat_map with automatic management of matching-explanations *)\n let concat_map_with_expls f xs =\n-  let all_expls = ref [] in\n-  let res =\n-    xs\n-    |> List.concat_map (fun x ->\n-           let ys, expls = f x in\n-           Stack_.push expls all_expls;\n-           ys)\n+  let lhs, rhs =\n+    List.fold_left_map\n+      (fun acc x ->\n+        let l, r = f x in\n+        (l :: acc, r))\n+      [] xs\n   in\n-  (res, List_.flatten (List.rev !all_expls))\n+  (List.flatten (List.rev lhs), List.flatten rhs)",
        "comment_created_at": "2025-07-22T09:48:52+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "`lhs` is the accumulator right? \r\nI did not test but I would expect something like this (with some renaming, but essentially reversing the order of lhs, rhs in the result tuple): \r\n\r\n```ocaml\r\nlet concat_map_with_expls f xs =\r\n  let all_expls, res = (List.fold_left_map \r\n    (fun acc x -> let ys, expls  = f x in (ys::acc , expls)) [] xs) \r\n  in\r\n  (List_.flatten res, List.flatten (List.rev all_expls))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193382256",
    "pr_number": 337,
    "pr_file": "languages/apex/generic/Parse_apex_tree_sitter.ml",
    "created_at": "2025-07-08T20:25:23+00:00",
    "commented_code": "+(**\n+   Boilerplate to be used as a template when mapping the apex CST\n+   to another type of tree.\n+*)\n+\n+(*  open Common *)\n+(*  open Either_ *)\n+open Fpath_.Operators\n+module H = Parse_tree_sitter_helpers\n+open AST_generic\n+module G = AST_generic\n+module H2 = AST_generic_helpers\n+module CST = Tree_sitter_apex.CST\n+\n+module R = Tree_sitter_run.Raw_tree\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27-32\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+type raw = G.raw_tree\n+\n+let token_ = H.token\n+let str = H.str\n+let fb = Tok.unsafe_fake_bracket\n+\n+let token (env : env) (tok : Tree_sitter_run.Token.t) =\n+  R.Token tok\n+\n+let blank (env : env) () =\n+  R.Tuple []\n+\n+let map_pat_snip (env : env) (tok : CST.pat_snip) =\n+  (* pattern [sS][nN][iI][pP][pP][eE][tT] *) token env tok\n+\n+let map_pat_data (env : env) (tok : CST.pat_data) =\n+  (* pattern [dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_first (env : env) (tok : CST.pat_first) =\n+  (* pattern [fF][iI][rR][sS][tT] *) token env tok\n+\n+let map_pat_suppos (env : env) (tok : CST.pat_suppos) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][oO][mM][aA][iI][nN][sS] *) token env tok\n+\n+let map_pat_view (env : env) (tok : CST.pat_view) =\n+  (* pattern [vV][iI][eE][wW] *) token env tok\n+\n+let map_pat_find (env : env) (tok : CST.pat_find) =\n+  (* pattern [fF][iI][nN][dD] *) token env tok\n+\n+let map_pat_suppos_ (env : env) (tok : CST.pat_suppos_) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][eE][lL][eE][gG][aA][tT][eE][sS] *) token env tok\n+\n+let map_pat_final (env : env) (tok : CST.pat_final) =\n+  (* pattern [fF][iI][nN][aA][lL] *) token env tok\n+\n+let map_pat_my_team_terr (env : env) (tok : CST.pat_my_team_terr) =\n+  (* pattern [mM][yY][__][tT][eE][aA][mM][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_currency_literal (env : env) (tok : CST.currency_literal) =\n+  (* pattern \\w{3}\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_virt (env : env) (tok : CST.pat_virt) =\n+  (* pattern [vV][iI][rR][tT][uU][aA][lL] *) token env tok\n+\n+let map_pat_shar (env : env) (tok : CST.pat_shar) =\n+  (* pattern [sS][hH][aA][rR][iI][nN][gG] *) token env tok\n+\n+let map_pat_in (env : env) (tok : CST.pat_in) =\n+  (* pattern [iI][nN] *) token env tok\n+\n+let map_pat_meta (env : env) (tok : CST.pat_meta) =\n+  (* pattern [mM][eE][tT][aA][dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_user_mode (env : env) (tok : CST.pat_user_mode) =\n+  (* pattern [uU][sS][eE][rR][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_prot (env : env) (tok : CST.pat_prot) =\n+  (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *) token env tok\n+\n+let map_pat_next_fiscal_year (env : env) (tok : CST.pat_next_fiscal_year) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_tola (env : env) (tok : CST.pat_tola) =\n+  (* pattern [tT][oO][lL][aA][bB][eE][lL] *) token env tok\n+\n+let map_block_comment_explicit (env : env) (() : CST.block_comment_explicit) =\n+  R.Tuple []\n+\n+let map_pat_offset (env : env) (tok : CST.pat_offset) =\n+  (* pattern [oO][fF][fF][sS][eE][tT] *) token env tok\n+\n+let map_pat_today (env : env) (tok : CST.pat_today) =\n+  (* pattern [tT][oO][dD][aA][yY] *) token env tok\n+\n+let map_semgrep_metavar_ellipsis (env : env) (tok : CST.semgrep_metavar_ellipsis) =\n+  (* pattern \\$\\.\\.\\.[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_then (env : env) (tok : CST.pat_then) =\n+  (* pattern [tT][hH][eE][nN] *) token env tok\n+\n+let map_pat_above (env : env) (tok : CST.pat_above) =\n+  (* pattern [aA][bB][oO][vV][eE] *) token env tok\n+\n+let map_pat_insert (env : env) (tok : CST.pat_insert) =\n+  (* pattern [iI][nN][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_merge (env : env) (tok : CST.pat_merge) =\n+  (* pattern [mM][eE][rR][gG][eE] *) token env tok\n+\n+let map_pat_count_dist (env : env) (tok : CST.pat_count_dist) =\n+  (* pattern [cC][oO][uU][nN][tT][__][dD][iI][sS][tT][iI][nN][cC][tT] *) token env tok\n+\n+let map_pat_nulls (env : env) (tok : CST.pat_nulls) =\n+  (* pattern [nN][uU][lL][lL][sS] *) token env tok\n+\n+let map_date (env : env) (tok : CST.date) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1]) *) token env tok\n+\n+let map_decimal_floating_point_literal (env : env) (tok : CST.decimal_floating_point_literal) =\n+  (* decimal_floating_point_literal *) token env tok\n+\n+let map_pat_last_month (env : env) (tok : CST.pat_last_month) =\n+  (* pattern [lL][aA][sS][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+(* OLD *)\n+let map_property_navigation (env : env) ((v1, v2) : CST.property_navigation) =\n+  let v1 =\n+    (match v1 with\n+    | Some tok -> R.Option (Some (\n+        (* \"?\" *) token env tok\n+      ))\n+    | None -> R.Option None)\n+  in\n+  let v2 = (* \".\" *) token env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* NEW *)\n+let property_navigation (env : env) ((v1, v2) : CST.property_navigation)\n+    : G.tok option * G.tok =\n+  let v1 = Option.map ((* \"?\" *) token_ env) v1 in\n+  let v2 = (* \".\" *) token_ env v2 in\n+  (v1, v2)\n+\n+let map_pat_cale_month (env : env) (tok : CST.pat_cale_month) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_unde (env : env) (tok : CST.pat_unde) =\n+  (* pattern [uU][nN][dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+let map_pat_inclus (env : env) (tok : CST.pat_inclus) =\n+  (* pattern [iI][nN][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_side (env : env) (tok : CST.pat_side) =\n+  (* pattern [sS][iI][dD][eE][bB][aA][rR] *) token env tok\n+\n+let map_pat_dele (env : env) (tok : CST.pat_dele) =\n+  (* pattern [dD][eE][lL][eE][gG][aA][tT][eE][dD] *) token env tok\n+\n+let map_pat_fields (env : env) (tok : CST.pat_fields) =\n+  (* pattern [fF][iI][eE][lL][dD][sS] *) token env tok\n+\n+let map_pat_fiscal_month (env : env) (tok : CST.pat_fiscal_month) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_when (env : env) (tok : CST.pat_when) =\n+  (* pattern [wW][hH][eE][nN] *) token env tok\n+\n+let map_pat_like (env : env) (tok : CST.pat_like) =\n+  (* pattern [lL][iI][kK][eE] *) token env tok\n+\n+let map_pat_avg (env : env) (tok : CST.pat_avg) =\n+  (* pattern [aA][vV][gG] *) token env tok\n+\n+let map_pat_scope (env : env) (tok : CST.pat_scope) =\n+  (* pattern [sS][cC][oO][pP][eE] *) token env tok\n+\n+let map_pat_sum (env : env) (tok : CST.pat_sum) =\n+  (* pattern [sS][uU][mM] *) token env tok\n+\n+let map_pat_target_len (env : env) (tok : CST.pat_target_len) =\n+  (* pattern [tT][aA][rR][gG][eE][tT][__][lL][eE][nN][gG][tT][hH] *) token env tok\n+\n+let map_pat_try (env : env) (tok : CST.pat_try) =\n+  (* pattern [tT][rR][yY] *) token env tok\n+\n+let map_pat_inst (env : env) (tok : CST.pat_inst) =\n+  (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *) token env tok\n+\n+let map_pat_mine (env : env) (tok : CST.pat_mine) =\n+  (* pattern [mM][iI][nN][eE] *) token env tok\n+\n+let map_date_time (env : env) (tok : CST.date_time) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d\\d?\\d?)?(?:Z|[+-][0-1]\\d:[0-5]\\d) *) token env tok\n+\n+let map_pat_while (env : env) (tok : CST.pat_while) =\n+  (* pattern [wW][hH][iI][lL][eE] *) token env tok\n+\n+let map_pat_ret (env : env) (tok : CST.pat_ret) =\n+  (* pattern [rR][eE][tT][uU][rR][nN] *) token env tok\n+\n+let map_pat_with (env : env) (tok : CST.pat_with) =\n+  (* pattern [wW][iI][tT][hH] *) token env tok\n+\n+let map_pat_where (env : env) (tok : CST.pat_where) =\n+  (* pattern [wW][hH][eE][rR][eE] *) token env tok\n+\n+let map_pat_this_month (env : env) (tok : CST.pat_this_month) =\n+  (* pattern [tT][hH][iI][sS][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_high (env : env) (tok : CST.pat_high) =\n+  (* pattern [hH][iI][gG][hH][lL][iI][gG][hH][tT] *) token env tok\n+\n+let map_pat_tran (env : env) (tok : CST.pat_tran) =\n+  (* pattern [tT][rR][aA][nN][sS][iI][eE][nN][tT] *) token env tok\n+\n+let map_pat_as (env : env) (tok : CST.pat_as) =\n+  (* pattern [aA][sS] *) token env tok\n+\n+let map_pat_next_90_days (env : env) (tok : CST.pat_next_90_days) =\n+  (* pattern [nN][eE][xX][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+let map_pat_super (env : env) (tok : CST.pat_super) =\n+  (* pattern [sS][uU][pP][eE][rR] *) token env tok\n+\n+let map_pat_on (env : env) (tok : CST.pat_on) =\n+  (* pattern [oO][nN] *) token env tok\n+\n+let map_pat_min (env : env) (tok : CST.pat_min) =\n+  (* pattern [mM][iI][nN] *) token env tok\n+\n+let map_pat_mine_and_my_groups (env : env) (tok : CST.pat_mine_and_my_groups) =\n+  (* pattern [mM][iI][nN][eE][__][aA][nN][dD][__][mM][yY][__][gG][rR][oO][uU][pP][sS] *) token env tok\n+\n+let map_pat_list (env : env) (tok : CST.pat_list) =\n+  (* pattern [lL][iI][sS][tT][vV][iI][eE][wW] *) token env tok\n+\n+let map_string_literal (env : env) (tok : CST.string_literal) =\n+  (* pattern \"'(\\\\\\\\[nNrRtTbBfFuU\\\"'_%\\\\\\\\]|[^\\\\\\\\'])*'\" *) token env tok\n+\n+let map_pat_not (env : env) (tok : CST.pat_not) =\n+  (* pattern [nN][oO][tT] *) token env tok\n+\n+let map_pat_test (env : env) (tok : CST.pat_test) =\n+  (* pattern [tT][eE][sS][tT][mM][eE][tT][hH][oO][dD] *) token env tok\n+\n+let map_pat_typeof (env : env) (tok : CST.pat_typeof) =\n+  (* pattern [tT][yY][pP][eE][oO][fF] *) token env tok\n+\n+let map_pat_desc (env : env) (tok : CST.pat_desc) =\n+  (* pattern [dD][eE][sS][cC] *) token env tok\n+\n+let map_pat_day_only (env : env) (tok : CST.pat_day_only) =\n+  (* pattern [dD][aA][yY][__][oO][nN][lL][yY] *) token env tok\n+\n+let map_pat_spell_corr (env : env) (tok : CST.pat_spell_corr) =\n+  (* pattern [sS][pP][eE][lL][lL][__][cC][oO][rR][rR][eE][cC][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_ref (env : env) (tok : CST.pat_ref) =\n+  (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE] *) token env tok\n+\n+let map_pat_public (env : env) (tok : CST.pat_public) =\n+  (* pattern [pP][uU][bB][lL][iI][cC] *) token env tok\n+\n+let map_pat_last (env : env) (tok : CST.pat_last) =\n+  (* pattern [lL][aA][sS][tT] *) token env tok\n+\n+let map_pat_upsert (env : env) (tok : CST.pat_upsert) =\n+  (* pattern [uU][pP][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_void (env : env) (tok : CST.pat_void) =\n+  (* pattern [vV][oO][iI][dD] *) token env tok\n+\n+let map_pat_netw (env : env) (tok : CST.pat_netw) =\n+  (* pattern [nN][eE][tT][wW][oO][rR][kK] *) token env tok\n+\n+let map_pat_below (env : env) (tok : CST.pat_below) =\n+  (* pattern [bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_line_comment_explicit (env : env) (() : CST.line_comment_explicit) =\n+  R.Tuple []\n+\n+let map_apex_identifier_ (env : env) (tok : CST.apex_identifier_) =\n+  (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+\n+let map_pat_imples (env : env) (tok : CST.pat_imples) =\n+  (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *) token env tok\n+\n+let map_pat_stan (env : env) (tok : CST.pat_stan) =\n+  (* pattern [sS][tT][aA][nN][dD][aA][rR][dD] *) token env tok\n+\n+let map_pat_or (env : env) (tok : CST.pat_or) =\n+  (* pattern [oO][rR] *) token env tok\n+\n+let map_pat_cate (env : env) (tok : CST.pat_cate) =\n+  (* pattern [cC][aA][tT][eE][gG][oO][rR][yY] *) token env tok\n+\n+let map_pat_before (env : env) (tok : CST.pat_before) =\n+  (* pattern [bB][eE][fF][oO][rR][eE] *) token env tok\n+\n+let map_pat_email (env : env) (tok : CST.pat_email) =\n+  (* pattern [eE][mM][aA][iI][lL] *) token env tok\n+\n+let map_pat_if (env : env) (tok : CST.pat_if) =\n+  (* pattern [iI][fF] *) token env tok\n+\n+let map_pat_rows (env : env) (tok : CST.pat_rows) =\n+  (* pattern [rR][oO][wW][sS] *) token env tok\n+\n+let map_pat_else (env : env) (tok : CST.pat_else) =\n+  (* pattern [eE][lL][sS][eE] *) token env tok\n+\n+let map_pat_week_in_year (env : env) (tok : CST.pat_week_in_year) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_limit (env : env) (tok : CST.pat_limit) =\n+  (* pattern [lL][iI][mM][iI][tT] *) token env tok\n+\n+let map_pat_next_month (env : env) (tok : CST.pat_next_month) =\n+  (* pattern [nN][eE][xX][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_trac (env : env) (tok : CST.pat_trac) =\n+  (* pattern [tT][rR][aA][cC][kK][iI][nN][gG] *) token env tok\n+\n+let map_block_comment (env : env) (tok : CST.block_comment) =\n+  (* block_comment *) token env tok\n+\n+let map_pat_dist (env : env) (tok : CST.pat_dist) =\n+  (* pattern [dD][iI][sS][tT][aA][nN][cC][eE] *) token env tok\n+\n+let map_pat_rollup (env : env) (tok : CST.pat_rollup) =\n+  (* pattern [rR][oO][lL][lL][uU][pP] *) token env tok\n+\n+let map_pat_inte (env : env) (tok : CST.pat_inte) =\n+  (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *) token env tok\n+\n+let map_pat_set (env : env) (tok : CST.pat_set) =\n+  (* pattern [sS][eE][tT] *) token env tok\n+\n+let map_decimal (env : env) (tok : CST.decimal) =\n+  (* pattern -?\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_last_fiscal_quar (env : env) (tok : CST.pat_last_fiscal_quar) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_for (env : env) (tok : CST.pat_for) =\n+  (* pattern [fF][oO][rR] *) token env tok\n+\n+let map_pat_pric (env : env) (tok : CST.pat_pric) =\n+  (* pattern [pP][rR][iI][cC][eE][bB][oO][oO][kK][iI][dD] *) token env tok\n+\n+let map_pat_last_fiscal_year (env : env) (tok : CST.pat_last_fiscal_year) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_this_quar (env : env) (tok : CST.pat_this_quar) =\n+  (* pattern [tT][hH][iI][sS][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_at (env : env) (tok : CST.pat_at) =\n+  (* pattern [aA][tT] *) token env tok\n+\n+let map_pat_static (env : env) (tok : CST.pat_static) =\n+  (* pattern [sS][tT][aA][tT][iI][cC] *) token env tok\n+\n+let map_pat_fiscal_quar (env : env) (tok : CST.pat_fiscal_quar) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_tomo (env : env) (tok : CST.pat_tomo) =\n+  (* pattern [tT][oO][mM][oO][rR][rR][oO][wW] *) token env tok\n+\n+let map_pat_geol (env : env) (tok : CST.pat_geol) =\n+  (* pattern [gG][eE][oO][lL][oO][cC][aA][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_day_in_week (env : env) (tok : CST.pat_day_in_week) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_last_week (env : env) (tok : CST.pat_last_week) =\n+  (* pattern [lL][aA][sS][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_divi (env : env) (tok : CST.pat_divi) =\n+  (* pattern [dD][iI][vV][iI][sS][iI][oO][nN] *) token env tok\n+\n+let map_pat_abst (env : env) (tok : CST.pat_abst) =\n+  (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *) token env tok\n+\n+let map_pat_custom (env : env) (tok : CST.pat_custom) =\n+  (* pattern [cC][uU][sS][tT][oO][mM] *) token env tok\n+\n+let map_pat_userid (env : env) (tok : CST.pat_userid) =\n+  (* pattern [uU][sS][eE][rR][iI][dD] *) token env tok\n+\n+let map_pat_over (env : env) (tok : CST.pat_over) =\n+  (* pattern [oO][vV][eE][rR][rR][iI][dD][eE] *) token env tok\n+\n+let map_pat_fina (env : env) (tok : CST.pat_fina) =\n+  (* pattern [fF][iI][nN][aA][lL][lL][yY] *) token env tok\n+\n+let map_pat_trig (env : env) (tok : CST.pat_trig) =\n+  (* pattern [tT][rR][iI][gG][gG][eE][rR] *) token env tok\n+\n+let map_pat_cale_quar (env : env) (tok : CST.pat_cale_quar) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_this_week (env : env) (tok : CST.pat_this_week) =\n+  (* pattern [tT][hH][iI][sS][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_throw (env : env) (tok : CST.pat_throw) =\n+  (* pattern [tT][hH][rR][oO][wW] *) token env tok\n+\n+let map_pat_ever (env : env) (tok : CST.pat_ever) =\n+  (* pattern [eE][vV][eE][rR][yY][tT][hH][iI][nN][gG] *) token env tok\n+\n+let map_pat_cube (env : env) (tok : CST.pat_cube) =\n+  (* pattern [cC][uU][bB][eE] *) token env tok\n+\n+let map_pat_hour_in_day (env : env) (tok : CST.pat_hour_in_day) =\n+  (* pattern [hH][oO][uU][rR][__][iI][nN][__][dD][aA][yY] *) token env tok\n+\n+let map_pat_day_in_month (env : env) (tok : CST.pat_day_in_month) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_last_90_days (env : env) (tok : CST.pat_last_90_days) =\n+  (* pattern [lL][aA][sS][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+(* OLD *)\n+let map_dimensions (env : env) (xs : CST.dimensions) =\n+  R.List (List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token env v1 in\n+    let v2 = (* \"]\" *) token env v2 in\n+    R.Tuple [v1; v2]\n+  ) xs)\n+\n+(* NEW *)\n+let dimensions (env : env) (xs : CST.dimensions) : (G.tok * G.tok) list =\n+  List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token_ env v1 in\n+    let v2 = (* \"]\" *) token_ env v2 in\n+    v1, v2)\n+    xs\n+\n+let map_pat_cale_year (env : env) (tok : CST.pat_cale_year) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_last_year (env : env) (tok : CST.pat_last_year) =\n+  (* pattern [lL][aA][sS][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_end (env : env) (tok : CST.pat_end) =\n+  (* pattern [eE][nN][dD] *) token env tok\n+\n+let map_pat_format (env : env) (tok : CST.pat_format) =\n+  (* pattern [fF][oO][rR][mM][aA][tT] *) token env tok\n+\n+let map_pat_switch (env : env) (tok : CST.pat_switch) =\n+  (* pattern [sS][wW][iI][tT][cC][hH] *) token env tok\n+\n+let map_pat_priv (env : env) (tok : CST.pat_priv) =\n+  (* pattern [pP][rR][iI][vV][aA][tT][eE] *) token env tok\n+\n+let map_pat_count (env : env) (tok : CST.pat_count) =\n+  (* pattern [cC][oO][uU][nN][tT] *) token env tok\n+\n+let map_pat_this_fiscal_quar (env : env) (tok : CST.pat_this_fiscal_quar) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_term (env : env) (tok : CST.term) =\n+  (* pattern \"(\\\\\\\\\\\\'|[^'])+\" *) token env tok\n+\n+let map_pat_after (env : env) (tok : CST.pat_after) =\n+  (* pattern [aA][fF][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_year (env : env) (tok : CST.pat_next_year) =\n+  (* pattern [nN][eE][xX][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_extends (env : env) (tok : CST.pat_extends) =\n+  (* pattern [eE][xX][tT][eE][nN][dD][sS] *) token env tok\n+\n+let map_pat_update (env : env) (tok : CST.pat_update) =\n+  (* pattern [uU][pP][dD][aA][tT][eE] *) token env tok\n+\n+let map_pat_this_year (env : env) (tok : CST.pat_this_year) =\n+  (* pattern [tT][hH][iI][sS][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_view_ (env : env) (tok : CST.pat_view_) =\n+  (* pattern [vV][iI][eE][wW][sS][tT][aA][tT] *) token env tok\n+\n+let map_pat_fiscal_year (env : env) (tok : CST.pat_fiscal_year) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_my_terr (env : env) (tok : CST.pat_my_terr) =\n+  (* pattern [mM][yY][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_tok_choice_pat_last_n_days (env : env) (tok : CST.tok_choice_pat_last_n_days) =\n+  (* tok_choice_pat_last_n_days *) token env tok\n+\n+let map_pat_do (env : env) (tok : CST.pat_do) =\n+  (* pattern [dD][oO] *) token env tok\n+\n+let map_pat_true (env : env) (tok : CST.pat_true) =\n+  (* pattern [tT][rR][uU][eE] *) token env tok\n+\n+let map_pat_by (env : env) (tok : CST.pat_by) =\n+  (* pattern [bB][yY] *) token env tok\n+\n+let map_pat_above_or_below (env : env) (tok : CST.pat_above_or_below) =\n+  (* pattern [aA][bB][oO][vV][eE][__][oO][rR][__][bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_pat_last_quar (env : env) (tok : CST.pat_last_quar) =\n+  (* pattern [lL][aA][sS][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_from (env : env) (tok : CST.pat_from) =\n+  (* pattern [fF][rR][oO][mM] *) token env tok\n+\n+let map_pat_team (env : env) (tok : CST.pat_team) =\n+  (* pattern [tT][eE][aA][mM] *) token env tok\n+\n+let map_pat_and (env : env) (tok : CST.pat_and) =\n+  (* pattern [aA][nN][dD] *) token env tok\n+\n+let map_pat_phone (env : env) (tok : CST.pat_phone) =\n+  (* pattern [pP][hH][oO][nN][eE] *) token env tok\n+\n+let map_pat_this (env : env) (tok : CST.pat_this) =\n+  (* pattern [tT][hH][iI][sS] *) token env tok\n+\n+let map_pat_week_in_month (env : env) (tok : CST.pat_week_in_month) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_next_week (env : env) (tok : CST.pat_next_week) =\n+  (* pattern [nN][eE][xX][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_having (env : env) (tok : CST.pat_having) =\n+  (* pattern [hH][aA][vV][iI][nN][gG] *) token env tok\n+\n+let map_pat_next_quar (env : env) (tok : CST.pat_next_quar) =\n+  (* pattern [nN][eE][xX][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_fiscal_quar (env : env) (tok : CST.pat_next_fiscal_quar) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_asc (env : env) (tok : CST.pat_asc) =\n+  (* pattern [aA][sS][cC] *) token env tok\n+\n+let map_pat_null (env : env) (tok : CST.pat_null) =\n+  (* pattern [nN][uU][lL][lL] *) token env tok\n+\n+let map_pat_global (env : env) (tok : CST.pat_global) =\n+  (* pattern [gG][lL][oO][bB][aA][lL] *) token env tok\n+\n+let map_pat_max (env : env) (tok : CST.pat_max) =\n+  (* pattern [mM][aA][xX] *) token env tok\n+\n+let map_pat_all (env : env) (tok : CST.pat_all) =\n+  (* pattern [aA][lL][lL] *) token env tok\n+\n+let map_pat_reco (env : env) (tok : CST.pat_reco) =\n+  (* pattern [rR][eE][cC][oO][rR][dD][vV][iI][sS][iI][bB][iI][lL][iI][tT][yY][cC][oO][nN][tT][eE][xX][tT] *) token env tok\n+\n+let map_pat_cont (env : env) (tok : CST.pat_cont) =\n+  (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *) token env tok\n+\n+let map_pat_get (env : env) (tok : CST.pat_get) =\n+  (* pattern [gG][eE][tT] *) token env tok\n+\n+let map_pat_select (env : env) (tok : CST.pat_select) =\n+  (* pattern [sS][eE][lL][eE][cC][tT] *) token env tok\n+\n+let map_pat_conv (env : env) (tok : CST.pat_conv) =\n+  (* pattern [cC][oO][nN][vV][eE][rR][tT][cC][uU][rR][rR][eE][nN][cC][yY] *) token env tok\n+\n+let map_pat_inhe (env : env) (tok : CST.pat_inhe) =\n+  (* pattern [iI][nN][hH][eE][rR][iI][tT][eE][dD] *) token env tok\n+\n+let map_pat_maxd (env : env) (tok : CST.pat_maxd) =\n+  (* pattern [mM][aA][xX][dD][eE][sS][cC][rR][iI][pP][tT][oO][rR][pP][eE][rR][rR][eE][cC][oO][rR][dD] *) token env tok\n+\n+let map_pat_name (env : env) (tok : CST.pat_name) =\n+  (* pattern [nN][aA][mM][eE] *) token env tok\n+\n+let map_pat_catch (env : env) (tok : CST.pat_catch) =\n+  (* pattern [cC][aA][tT][cC][hH] *) token env tok\n+\n+let map_semgrep_metavar (env : env) (tok : CST.semgrep_metavar) =\n+  (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_retu (env : env) (tok : CST.pat_retu) =\n+  (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *) token env tok\n+\n+let map_pat_system_mode (env : env) (tok : CST.pat_system_mode) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_using (env : env) (tok : CST.pat_using) =\n+  (* pattern [uU][sS][iI][nN][gG] *) token env tok\n+\n+let map_pat_class (env : env) (tok : CST.pat_class) =\n+  (* pattern [cC][lL][aA][sS][sS] *) token env tok\n+\n+let map_pat_e8c36c5 (env : env) (tok : CST.pat_e8c36c5) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][..][rR][uU][nN][aA][sS] *) token env tok\n+\n+let map_pat_exclus (env : env) (tok : CST.pat_exclus) =\n+  (* pattern [eE][xX][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_order (env : env) (tok : CST.pat_order) =\n+  (* pattern [oO][rR][dD][eE][rR] *) token env tok\n+\n+let map_pat_yest (env : env) (tok : CST.pat_yest) =\n+  (* pattern [yY][eE][sS][tT][eE][rR][dD][aA][yY] *) token env tok\n+\n+let map_pat_false (env : env) (tok : CST.pat_false) =\n+  (* pattern [fF][aA][lL][sS][eE] *) token env tok\n+\n+let map_pat_grou (env : env) (tok : CST.pat_grou) =\n+  (* pattern [gG][rR][oO][uU][pP][iI][nN][gG] *) token env tok\n+\n+let map_pat_enum (env : env) (tok : CST.pat_enum) =\n+  (* pattern [eE][nN][uU][mM] *) token env tok\n+\n+let map_pat_new (env : env) (tok : CST.pat_new) =\n+  (* pattern [nN][eE][wW] *) token env tok\n+\n+let map_pat_this_fiscal_year (env : env) (tok : CST.pat_this_fiscal_year) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_group (env : env) (tok : CST.pat_group) =\n+  (* pattern [gG][rR][oO][uU][pP] *) token env tok\n+\n+let map_int_ (env : env) (tok : CST.int_) =\n+  (* int *) token env tok\n+\n+let map_pat_with_ (env : env) (tok : CST.pat_with_) =\n+  (* pattern [wW][iI][tT][hH][oO][uU][tT] *) token env tok\n+\n+let map_pat_secu_enfo (env : env) (tok : CST.pat_secu_enfo) =\n+  (* pattern [sS][eE][cC][uU][rR][iI][tT][yY][__][eE][nN][fF][oO][rR][cC][eE][dD] *) token env tok\n+\n+let map_pat_brk (env : env) (tok : CST.pat_brk) =\n+  (* pattern [bB][rR][eE][aA][kK] *) token env tok\n+\n+let map_pat_day_in_year (env : env) (tok : CST.pat_day_in_year) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_line_comment (env : env) (tok : CST.line_comment) =\n+  (* line_comment *) token env tok\n+\n+let map_pat_delete (env : env) (tok : CST.pat_delete) =\n+  (* pattern [dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+(* OLD QUERY *)\n+let map_value_comparison_operator (env : env) (x : CST.value_comparison_operator) =\n+  (match x with\n+  | `EQ tok -> R.Case (\"EQ\",\n+      (* \"=\" *) token env tok\n+    )\n+  | `BANGEQ tok -> R.Case (\"BANGEQ\",\n+      (* \"!=\" *) token env tok\n+    )\n+  | `LTGT tok -> R.Case (\"LTGT\",\n+      (* \"<>\" *) token env tok\n+    )\n+  | `LT tok -> R.Case (\"LT\",\n+      (* \"<\" *) token env tok\n+    )\n+  | `LTEQ tok -> R.Case (\"LTEQ\",\n+      (* \"<=\" *) token env tok\n+    )\n+  | `GT tok -> R.Case (\"GT\",\n+      (* \">\" *) token env tok\n+    )\n+  | `GTEQ tok -> R.Case (\"GTEQ\",\n+      (* \">=\" *) token env tok\n+    )\n+  | `Pat_like x -> R.Case (\"Pat_like\",\n+      map_pat_like env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let value_comparison_operator (env : env) (x : CST.value_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `EQ tok ->\n+      let t = (* \"=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Eq, t) |> G.e\n+  | `BANGEQ tok ->\n+      let t = (* \"!=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LTGT tok ->\n+      let t = (* \"<>\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LT tok ->\n+      let t = (* \"<\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Lt, t) |> G.e\n+  | `LTEQ tok ->\n+      let t = (* \"<=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.LtE, t) |> G.e\n+  | `GT tok ->\n+      let t = (* \">\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Gt, t) |> G.e\n+  | `GTEQ tok ->\n+      let t = (* \">=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.GtE, t) |> G.e\n+  | `Pat_like x ->\n+      let v = (* \"like\" *) str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_highlight (env : env) (x : CST.with_highlight) =\n+  map_pat_high env x\n+\n+let with_highlight (env : env) (x : CST.with_highlight) : G.ident =\n+  (* \"hightlight\" *) str env x\n+\n+(* OLD *)\n+let map_super (env : env) (x : CST.super) =\n+  map_pat_super env x\n+\n+(* NEW *)\n+let super (env : env) (x : CST.super) : G.expr =\n+  let t = (* \"super\" *) token_ env x in\n+  G.IdSpecial (G.Super, t) |> G.e\n+\n+(* AUX*)\n+let super_to_field_name (env : env) (x : CST.super) : G.field_name =\n+  let i = (* \"super\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* AUX *)\n+let this_to_field_name (env : env) (x : CST.this) : G.field_name =\n+  let i = (* \"this\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* OLD QUERY *)\n+let map_order_null_direciton (env : env) (x : CST.order_null_direciton) =\n+  (match x with\n+  | `Pat_nulls_pat_first (v1, v2) -> R.Case (\"Pat_nulls_pat_first\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_first env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_nulls_pat_last (v1, v2) -> R.Case (\"Pat_nulls_pat_last\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_last env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_null_direciton (env : env) (x : CST.order_null_direciton) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_nulls_pat_first (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"first\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+  | `Pat_nulls_pat_last (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"last\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+\n+let map_void_type (env : env) (x : CST.void_type) =\n+  map_pat_void env x\n+\n+(* OLD QUERY *)\n+let map_count_expression (env : env) ((v1, v2, v3) : CST.count_expression) =\n+  let v1 = map_pat_count env v1 in\n+  let v2 = (* \"(\" *) token env v2 in\n+  let v3 = (* \")\" *) token env v3 in\n+  R.Tuple [v1; v2; v3]\n+\n+(* RAW QUERY *)\n+let count_expression (env : env) ((v1, v2, v3) : CST.count_expression)\n+    : G.expr =\n+  let v1 = str env v1 in\n+  let v2 = (* \"(\" *) token_ env v2 in\n+  let v3 = (* \")\" *) token_ env v3 in\n+  G.Call (G.N (G.Id (v1, G.empty_id_info ())) |> G.e, (v2, [], v3)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_for_type (env : env) (x : CST.for_type) =\n+  (match x with\n+  | `Pat_update x -> R.Case (\"Pat_update\",\n+      map_pat_update env x\n+    )\n+  | `Pat_ref x -> R.Case (\"Pat_ref\",\n+      map_pat_ref env x\n+    )\n+  | `Pat_view x -> R.Case (\"Pat_view\",\n+      map_pat_view env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let for_type (env : env) (x : CST.for_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_update x\n+  | `Pat_ref x\n+  | `Pat_view x ->\n+      let v = str env x in\n+      R.Token v\n+\n+(* OLD QUERY *)\n+let map_update_type (env : env) (x : CST.update_type) =\n+  (match x with\n+  | `Pat_trac x -> R.Case (\"Pat_trac\",\n+      map_pat_trac env x\n+    )\n+  | `Pat_view_ x -> R.Case (\"Pat_view_\",\n+      map_pat_view_ env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let update_type (env : env) (x : CST.update_type) : G.expr =\n+  let v1 =\n+    match x with\n+    | `Pat_trac x\n+    | `Pat_view_ x ->\n+        str env x\n+  in\n+    G.L (G.String (fb v1)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) =\n+  (match x with\n+  | `Pat_at x -> R.Case (\"Pat_at\",\n+      map_pat_at env x\n+    )\n+  | `Pat_above x -> R.Case (\"Pat_above\",\n+      map_pat_above env x\n+    )\n+  | `Pat_below x -> R.Case (\"Pat_below\",\n+      map_pat_below env x\n+    )\n+  | `Pat_above_or_below x -> R.Case (\"Pat_above_or_below\",\n+      map_pat_above_or_below env x\n+    )\n+  )\n+\n+(* NEW QUERY *)\n+let with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_at x\n+  | `Pat_above x\n+  | `Pat_below x\n+  | `Pat_above_or_below x ->\n+      R.Token (str env x)\n+\n+(* OLD QUERY *)\n+let map_using_scope_type (env : env) (x : CST.using_scope_type) =\n+  (match x with\n+  | `Pat_dele x -> R.Case (\"Pat_dele\",\n+      map_pat_dele env x\n+    )\n+  | `Pat_ever x -> R.Case (\"Pat_ever\",\n+      map_pat_ever env x\n+    )\n+  | `Pat_mine x -> R.Case (\"Pat_mine\",\n+      map_pat_mine env x\n+    )\n+  | `Pat_mine_and_my_groups x -> R.Case (\"Pat_mine_and_my_groups\",\n+      map_pat_mine_and_my_groups env x\n+    )\n+  | `Pat_my_terr x -> R.Case (\"Pat_my_terr\",\n+      map_pat_my_terr env x\n+    )\n+  | `Pat_my_team_terr x -> R.Case (\"Pat_my_team_terr\",\n+      map_pat_my_team_terr env x\n+    )\n+  | `Pat_team x -> R.Case (\"Pat_team\",\n+      map_pat_team env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let using_scope_type (env : env) (x : CST.using_scope_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_dele x\n+  | `Pat_ever x\n+  | `Pat_mine x\n+  | `Pat_mine_and_my_groups x\n+  | `Pat_my_terr x\n+  | `Pat_my_team_terr x\n+  | `Pat_team x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_this (env : env) (x : CST.this) =\n+  map_pat_this env x\n+\n+(* NEW *)\n+let this (env : env) (x : CST.this) : G.expr =\n+  let t = token_ env x (* \"this\" *) in\n+  IdSpecial (This, t) |> G.e\n+\n+(* OLD QUERY *)\n+let map_order_direction (env : env) (x : CST.order_direction) =\n+  (match x with\n+  | `Pat_asc x -> R.Case (\"Pat_asc\",\n+      map_pat_asc env x\n+    )\n+  | `Pat_desc x -> R.Case (\"Pat_desc\",\n+      map_pat_desc env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_direction (env : env) (x : CST.order_direction) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_asc x\n+  | `Pat_desc x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_null_literal (env : env) (x : CST.null_literal) =\n+  map_pat_null env x\n+\n+(* NEW *)\n+let null_literal (env : env) (x : CST.null_literal) : literal =\n+  G.Null (token_ env x)\n+\n+(* OLD QUERY *)\n+let map_all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) =\n+  let v1 = map_pat_all env v1 in\n+  let v2 = map_pat_rows env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* RAW QUERY *)\n+let all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) : raw =\n+  let module R = Raw_tree in\n+  let v1 = (* \"all\" *) str env v1 in\n+  let v2 = (* \"rows\" *) str env v2 in\n+  R.Tuple [R.Token v1; R.Token v2]\n+\n+(* OLD QUERY *)\n+let map_fields_type (env : env) (x : CST.fields_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_custom x -> R.Case (\"Pat_custom\",\n+      map_pat_custom env x\n+    )\n+  | `Pat_stan x -> R.Case (\"Pat_stan\",\n+      map_pat_stan env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let fields_type (env : env) (x : CST.fields_type) : G.ident =\n+  match x with\n+  | `Pat_all x\n+  | `Pat_custom x\n+  | `Pat_stan x ->\n+      str env x\n+\n+(* OLD QUERY *)\n+let map_in_type (env : env) (x : CST.in_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_email x -> R.Case (\"Pat_email\",\n+      map_pat_email env x\n+    )\n+  | `Pat_name x -> R.Case (\"Pat_name\",\n+      map_pat_name env x\n+    )\n+  | `Pat_phone x -> R.Case (\"Pat_phone\",\n+      map_pat_phone env x\n+    )\n+  | `Pat_side x -> R.Case (\"Pat_side\",\n+      map_pat_side env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let in_type (env : env) (x : CST.in_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_all x\n+  | `Pat_email x\n+  | `Pat_name x\n+  | `Pat_phone x\n+  | `Pat_side x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_identifier (env : env) (x : CST.identifier) =\n+  (match x with\n+  | `Semg_meta tok -> R.Case (\"Semg_meta\",\n+      (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+    )\n+  | `Apex_id_ tok -> R.Case (\"Apex_id_\",\n+      (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+    )\n+  )\n+\n+(* NEW *)\n+let identifier (env : env) (x : CST.identifier) : G.ident =\n+  match x with\n+  | `Semg_meta tok (* pattern \\$[A-Z_][A-Z_0-9]* *) ->\n+      str env tok\n+  | `Apex_id_ tok (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) ->\n+      str env tok\n+\n+(* AUX *)\n+let identifier_to_expression (env : env) (x : CST.identifier) : G.expr =\n+  G.N (H2.name_of_id (identifier env x)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_set_comparison_operator (env : env) (x : CST.set_comparison_operator) =\n+  (match x with\n+  | `Pat_in x -> R.Case (\"Pat_in\",\n+      map_pat_in env x\n+    )\n+  | `Pat_not_pat_in (v1, v2) -> R.Case (\"Pat_not_pat_in\",\n+      let v1 = map_pat_not env v1 in\n+      let v2 = map_pat_in env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_inclus x -> R.Case (\"Pat_inclus\",\n+      map_pat_inclus env x\n+    )\n+  | `Pat_exclus x -> R.Case (\"Pat_exclus\",\n+      map_pat_exclus env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let set_comparison_operator (env : env) (x : CST.set_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_in x\n+  | `Pat_inclus x\n+  | `Pat_exclus x ->\n+      let v = str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+  | `Pat_not_pat_in (v1, v2) ->\n+      let v1 = str env v1 in\n+      let v2 = str env v2 in\n+      G.RawExpr (R.Tuple [R.Token v1; R.Token v2]) |> G.e\n+\n+(* OLD *)\n+let map_boolean (env : env) (x : CST.boolean) =\n+  (match x with\n+  | `Pat_true x -> R.Case (\"Pat_true\",\n+      map_pat_true env x\n+    )\n+  | `Pat_false x -> R.Case (\"Pat_false\",\n+      map_pat_false env x\n+    )\n+  )\n+\n+(* NEW *)\n+let boolean (env : env) (x : CST.boolean) : literal =\n+  match x with\n+  | `Pat_true tok -> G.Bool (true, token_ env tok)\n+  | `Pat_false tok -> G.Bool (false, token_ env tok)\n+\n+(* OLD QUERY *)\n+let map_date_literal (env : env) (x : CST.date_literal) =\n+  (match x with\n+  | `Pat_yest x -> R.Case (\"Pat_yest\",\n+      map_pat_yest env x\n+    )\n+  | `Pat_today x -> R.Case (\"Pat_today\",\n+      map_pat_today env x\n+    )\n+  | `Pat_tomo x -> R.Case (\"Pat_tomo\",\n+      map_pat_tomo env x\n+    )\n+  | `Pat_last_week x -> R.Case (\"Pat_last_week\",\n+      map_pat_last_week env x\n+    )\n+  | `Pat_this_week x -> R.Case (\"Pat_this_week\",\n+      map_pat_this_week env x\n+    )\n+  | `Pat_next_week x -> R.Case (\"Pat_next_week\",\n+      map_pat_next_week env x\n+    )\n+  | `Pat_last_month x -> R.Case (\"Pat_last_month\",\n+      map_pat_last_month env x\n+    )\n+  | `Pat_this_month x -> R.Case (\"Pat_this_month\",\n+      map_pat_this_month env x\n+    )\n+  | `Pat_next_month x -> R.Case (\"Pat_next_month\",\n+      map_pat_next_month env x\n+    )\n+  | `Pat_last_90_days x -> R.Case (\"Pat_last_90_days\",\n+      map_pat_last_90_days env x\n+    )\n+  | `Pat_next_90_days x -> R.Case (\"Pat_next_90_days\",\n+      map_pat_next_90_days env x\n+    )\n+  | `Pat_this_quar x -> R.Case (\"Pat_this_quar\",\n+      map_pat_this_quar env x\n+    )\n+  | `Pat_last_quar x -> R.Case (\"Pat_last_quar\",\n+      map_pat_last_quar env x\n+    )\n+  | `Pat_next_quar x -> R.Case (\"Pat_next_quar\",\n+      map_pat_next_quar env x\n+    )\n+  | `Pat_this_year x -> R.Case (\"Pat_this_year\",\n+      map_pat_this_year env x\n+    )\n+  | `Pat_last_year x -> R.Case (\"Pat_last_year\",\n+      map_pat_last_year env x\n+    )\n+  | `Pat_next_year x -> R.Case (\"Pat_next_year\",\n+      map_pat_next_year env x\n+    )\n+  | `Pat_this_fiscal_quar x -> R.Case (\"Pat_this_fiscal_quar\",\n+      map_pat_this_fiscal_quar env x\n+    )\n+  | `Pat_last_fiscal_quar x -> R.Case (\"Pat_last_fiscal_quar\",\n+      map_pat_last_fiscal_quar env x\n+    )\n+  | `Pat_next_fiscal_quar x -> R.Case (\"Pat_next_fiscal_quar\",\n+      map_pat_next_fiscal_quar env x\n+    )\n+  | `Pat_this_fiscal_year x -> R.Case (\"Pat_this_fiscal_year\",\n+      map_pat_this_fiscal_year env x\n+    )\n+  | `Pat_last_fiscal_year x -> R.Case (\"Pat_last_fiscal_year\",\n+      map_pat_last_fiscal_year env x\n+    )\n+  | `Pat_next_fiscal_year x -> R.Case (\"Pat_next_fiscal_year\",\n+      map_pat_next_fiscal_year env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let date_literal (env : env) (x : CST.date_literal) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_yest x\n+  | `Pat_today x\n+  | `Pat_tomo x\n+  | `Pat_last_week x\n+  | `Pat_this_week x\n+  | `Pat_next_week x\n+  | `Pat_last_month x\n+  | `Pat_this_month x\n+  | `Pat_next_month x\n+  | `Pat_last_90_days x\n+  | `Pat_next_90_days x\n+  | `Pat_this_quar x\n+  | `Pat_last_quar x\n+  | `Pat_next_quar x\n+  | `Pat_this_year x\n+  | `Pat_last_year x\n+  | `Pat_next_year x\n+  | `Pat_this_fiscal_quar x\n+  | `Pat_last_fiscal_quar x\n+  | `Pat_next_fiscal_quar x\n+  | `Pat_this_fiscal_year x\n+  | `Pat_last_fiscal_year x\n+  | `Pat_next_fiscal_year x ->\n+      let v = str env x in\n+      R.Token v",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2193382256",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 337,
        "pr_file": "languages/apex/generic/Parse_apex_tree_sitter.ml",
        "discussion_id": "2193382256",
        "commented_code": "@@ -0,0 +1,7343 @@\n+(**\n+   Boilerplate to be used as a template when mapping the apex CST\n+   to another type of tree.\n+*)\n+\n+(*  open Common *)\n+(*  open Either_ *)\n+open Fpath_.Operators\n+module H = Parse_tree_sitter_helpers\n+open AST_generic\n+module G = AST_generic\n+module H2 = AST_generic_helpers\n+module CST = Tree_sitter_apex.CST\n+\n+module R = Tree_sitter_run.Raw_tree\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27-32\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+type raw = G.raw_tree\n+\n+let token_ = H.token\n+let str = H.str\n+let fb = Tok.unsafe_fake_bracket\n+\n+let token (env : env) (tok : Tree_sitter_run.Token.t) =\n+  R.Token tok\n+\n+let blank (env : env) () =\n+  R.Tuple []\n+\n+let map_pat_snip (env : env) (tok : CST.pat_snip) =\n+  (* pattern [sS][nN][iI][pP][pP][eE][tT] *) token env tok\n+\n+let map_pat_data (env : env) (tok : CST.pat_data) =\n+  (* pattern [dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_first (env : env) (tok : CST.pat_first) =\n+  (* pattern [fF][iI][rR][sS][tT] *) token env tok\n+\n+let map_pat_suppos (env : env) (tok : CST.pat_suppos) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][oO][mM][aA][iI][nN][sS] *) token env tok\n+\n+let map_pat_view (env : env) (tok : CST.pat_view) =\n+  (* pattern [vV][iI][eE][wW] *) token env tok\n+\n+let map_pat_find (env : env) (tok : CST.pat_find) =\n+  (* pattern [fF][iI][nN][dD] *) token env tok\n+\n+let map_pat_suppos_ (env : env) (tok : CST.pat_suppos_) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][eE][lL][eE][gG][aA][tT][eE][sS] *) token env tok\n+\n+let map_pat_final (env : env) (tok : CST.pat_final) =\n+  (* pattern [fF][iI][nN][aA][lL] *) token env tok\n+\n+let map_pat_my_team_terr (env : env) (tok : CST.pat_my_team_terr) =\n+  (* pattern [mM][yY][__][tT][eE][aA][mM][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_currency_literal (env : env) (tok : CST.currency_literal) =\n+  (* pattern \\w{3}\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_virt (env : env) (tok : CST.pat_virt) =\n+  (* pattern [vV][iI][rR][tT][uU][aA][lL] *) token env tok\n+\n+let map_pat_shar (env : env) (tok : CST.pat_shar) =\n+  (* pattern [sS][hH][aA][rR][iI][nN][gG] *) token env tok\n+\n+let map_pat_in (env : env) (tok : CST.pat_in) =\n+  (* pattern [iI][nN] *) token env tok\n+\n+let map_pat_meta (env : env) (tok : CST.pat_meta) =\n+  (* pattern [mM][eE][tT][aA][dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_user_mode (env : env) (tok : CST.pat_user_mode) =\n+  (* pattern [uU][sS][eE][rR][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_prot (env : env) (tok : CST.pat_prot) =\n+  (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *) token env tok\n+\n+let map_pat_next_fiscal_year (env : env) (tok : CST.pat_next_fiscal_year) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_tola (env : env) (tok : CST.pat_tola) =\n+  (* pattern [tT][oO][lL][aA][bB][eE][lL] *) token env tok\n+\n+let map_block_comment_explicit (env : env) (() : CST.block_comment_explicit) =\n+  R.Tuple []\n+\n+let map_pat_offset (env : env) (tok : CST.pat_offset) =\n+  (* pattern [oO][fF][fF][sS][eE][tT] *) token env tok\n+\n+let map_pat_today (env : env) (tok : CST.pat_today) =\n+  (* pattern [tT][oO][dD][aA][yY] *) token env tok\n+\n+let map_semgrep_metavar_ellipsis (env : env) (tok : CST.semgrep_metavar_ellipsis) =\n+  (* pattern \\$\\.\\.\\.[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_then (env : env) (tok : CST.pat_then) =\n+  (* pattern [tT][hH][eE][nN] *) token env tok\n+\n+let map_pat_above (env : env) (tok : CST.pat_above) =\n+  (* pattern [aA][bB][oO][vV][eE] *) token env tok\n+\n+let map_pat_insert (env : env) (tok : CST.pat_insert) =\n+  (* pattern [iI][nN][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_merge (env : env) (tok : CST.pat_merge) =\n+  (* pattern [mM][eE][rR][gG][eE] *) token env tok\n+\n+let map_pat_count_dist (env : env) (tok : CST.pat_count_dist) =\n+  (* pattern [cC][oO][uU][nN][tT][__][dD][iI][sS][tT][iI][nN][cC][tT] *) token env tok\n+\n+let map_pat_nulls (env : env) (tok : CST.pat_nulls) =\n+  (* pattern [nN][uU][lL][lL][sS] *) token env tok\n+\n+let map_date (env : env) (tok : CST.date) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1]) *) token env tok\n+\n+let map_decimal_floating_point_literal (env : env) (tok : CST.decimal_floating_point_literal) =\n+  (* decimal_floating_point_literal *) token env tok\n+\n+let map_pat_last_month (env : env) (tok : CST.pat_last_month) =\n+  (* pattern [lL][aA][sS][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+(* OLD *)\n+let map_property_navigation (env : env) ((v1, v2) : CST.property_navigation) =\n+  let v1 =\n+    (match v1 with\n+    | Some tok -> R.Option (Some (\n+        (* \"?\" *) token env tok\n+      ))\n+    | None -> R.Option None)\n+  in\n+  let v2 = (* \".\" *) token env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* NEW *)\n+let property_navigation (env : env) ((v1, v2) : CST.property_navigation)\n+    : G.tok option * G.tok =\n+  let v1 = Option.map ((* \"?\" *) token_ env) v1 in\n+  let v2 = (* \".\" *) token_ env v2 in\n+  (v1, v2)\n+\n+let map_pat_cale_month (env : env) (tok : CST.pat_cale_month) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_unde (env : env) (tok : CST.pat_unde) =\n+  (* pattern [uU][nN][dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+let map_pat_inclus (env : env) (tok : CST.pat_inclus) =\n+  (* pattern [iI][nN][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_side (env : env) (tok : CST.pat_side) =\n+  (* pattern [sS][iI][dD][eE][bB][aA][rR] *) token env tok\n+\n+let map_pat_dele (env : env) (tok : CST.pat_dele) =\n+  (* pattern [dD][eE][lL][eE][gG][aA][tT][eE][dD] *) token env tok\n+\n+let map_pat_fields (env : env) (tok : CST.pat_fields) =\n+  (* pattern [fF][iI][eE][lL][dD][sS] *) token env tok\n+\n+let map_pat_fiscal_month (env : env) (tok : CST.pat_fiscal_month) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_when (env : env) (tok : CST.pat_when) =\n+  (* pattern [wW][hH][eE][nN] *) token env tok\n+\n+let map_pat_like (env : env) (tok : CST.pat_like) =\n+  (* pattern [lL][iI][kK][eE] *) token env tok\n+\n+let map_pat_avg (env : env) (tok : CST.pat_avg) =\n+  (* pattern [aA][vV][gG] *) token env tok\n+\n+let map_pat_scope (env : env) (tok : CST.pat_scope) =\n+  (* pattern [sS][cC][oO][pP][eE] *) token env tok\n+\n+let map_pat_sum (env : env) (tok : CST.pat_sum) =\n+  (* pattern [sS][uU][mM] *) token env tok\n+\n+let map_pat_target_len (env : env) (tok : CST.pat_target_len) =\n+  (* pattern [tT][aA][rR][gG][eE][tT][__][lL][eE][nN][gG][tT][hH] *) token env tok\n+\n+let map_pat_try (env : env) (tok : CST.pat_try) =\n+  (* pattern [tT][rR][yY] *) token env tok\n+\n+let map_pat_inst (env : env) (tok : CST.pat_inst) =\n+  (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *) token env tok\n+\n+let map_pat_mine (env : env) (tok : CST.pat_mine) =\n+  (* pattern [mM][iI][nN][eE] *) token env tok\n+\n+let map_date_time (env : env) (tok : CST.date_time) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d\\d?\\d?)?(?:Z|[+-][0-1]\\d:[0-5]\\d) *) token env tok\n+\n+let map_pat_while (env : env) (tok : CST.pat_while) =\n+  (* pattern [wW][hH][iI][lL][eE] *) token env tok\n+\n+let map_pat_ret (env : env) (tok : CST.pat_ret) =\n+  (* pattern [rR][eE][tT][uU][rR][nN] *) token env tok\n+\n+let map_pat_with (env : env) (tok : CST.pat_with) =\n+  (* pattern [wW][iI][tT][hH] *) token env tok\n+\n+let map_pat_where (env : env) (tok : CST.pat_where) =\n+  (* pattern [wW][hH][eE][rR][eE] *) token env tok\n+\n+let map_pat_this_month (env : env) (tok : CST.pat_this_month) =\n+  (* pattern [tT][hH][iI][sS][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_high (env : env) (tok : CST.pat_high) =\n+  (* pattern [hH][iI][gG][hH][lL][iI][gG][hH][tT] *) token env tok\n+\n+let map_pat_tran (env : env) (tok : CST.pat_tran) =\n+  (* pattern [tT][rR][aA][nN][sS][iI][eE][nN][tT] *) token env tok\n+\n+let map_pat_as (env : env) (tok : CST.pat_as) =\n+  (* pattern [aA][sS] *) token env tok\n+\n+let map_pat_next_90_days (env : env) (tok : CST.pat_next_90_days) =\n+  (* pattern [nN][eE][xX][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+let map_pat_super (env : env) (tok : CST.pat_super) =\n+  (* pattern [sS][uU][pP][eE][rR] *) token env tok\n+\n+let map_pat_on (env : env) (tok : CST.pat_on) =\n+  (* pattern [oO][nN] *) token env tok\n+\n+let map_pat_min (env : env) (tok : CST.pat_min) =\n+  (* pattern [mM][iI][nN] *) token env tok\n+\n+let map_pat_mine_and_my_groups (env : env) (tok : CST.pat_mine_and_my_groups) =\n+  (* pattern [mM][iI][nN][eE][__][aA][nN][dD][__][mM][yY][__][gG][rR][oO][uU][pP][sS] *) token env tok\n+\n+let map_pat_list (env : env) (tok : CST.pat_list) =\n+  (* pattern [lL][iI][sS][tT][vV][iI][eE][wW] *) token env tok\n+\n+let map_string_literal (env : env) (tok : CST.string_literal) =\n+  (* pattern \"'(\\\\\\\\[nNrRtTbBfFuU\\\"'_%\\\\\\\\]|[^\\\\\\\\'])*'\" *) token env tok\n+\n+let map_pat_not (env : env) (tok : CST.pat_not) =\n+  (* pattern [nN][oO][tT] *) token env tok\n+\n+let map_pat_test (env : env) (tok : CST.pat_test) =\n+  (* pattern [tT][eE][sS][tT][mM][eE][tT][hH][oO][dD] *) token env tok\n+\n+let map_pat_typeof (env : env) (tok : CST.pat_typeof) =\n+  (* pattern [tT][yY][pP][eE][oO][fF] *) token env tok\n+\n+let map_pat_desc (env : env) (tok : CST.pat_desc) =\n+  (* pattern [dD][eE][sS][cC] *) token env tok\n+\n+let map_pat_day_only (env : env) (tok : CST.pat_day_only) =\n+  (* pattern [dD][aA][yY][__][oO][nN][lL][yY] *) token env tok\n+\n+let map_pat_spell_corr (env : env) (tok : CST.pat_spell_corr) =\n+  (* pattern [sS][pP][eE][lL][lL][__][cC][oO][rR][rR][eE][cC][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_ref (env : env) (tok : CST.pat_ref) =\n+  (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE] *) token env tok\n+\n+let map_pat_public (env : env) (tok : CST.pat_public) =\n+  (* pattern [pP][uU][bB][lL][iI][cC] *) token env tok\n+\n+let map_pat_last (env : env) (tok : CST.pat_last) =\n+  (* pattern [lL][aA][sS][tT] *) token env tok\n+\n+let map_pat_upsert (env : env) (tok : CST.pat_upsert) =\n+  (* pattern [uU][pP][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_void (env : env) (tok : CST.pat_void) =\n+  (* pattern [vV][oO][iI][dD] *) token env tok\n+\n+let map_pat_netw (env : env) (tok : CST.pat_netw) =\n+  (* pattern [nN][eE][tT][wW][oO][rR][kK] *) token env tok\n+\n+let map_pat_below (env : env) (tok : CST.pat_below) =\n+  (* pattern [bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_line_comment_explicit (env : env) (() : CST.line_comment_explicit) =\n+  R.Tuple []\n+\n+let map_apex_identifier_ (env : env) (tok : CST.apex_identifier_) =\n+  (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+\n+let map_pat_imples (env : env) (tok : CST.pat_imples) =\n+  (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *) token env tok\n+\n+let map_pat_stan (env : env) (tok : CST.pat_stan) =\n+  (* pattern [sS][tT][aA][nN][dD][aA][rR][dD] *) token env tok\n+\n+let map_pat_or (env : env) (tok : CST.pat_or) =\n+  (* pattern [oO][rR] *) token env tok\n+\n+let map_pat_cate (env : env) (tok : CST.pat_cate) =\n+  (* pattern [cC][aA][tT][eE][gG][oO][rR][yY] *) token env tok\n+\n+let map_pat_before (env : env) (tok : CST.pat_before) =\n+  (* pattern [bB][eE][fF][oO][rR][eE] *) token env tok\n+\n+let map_pat_email (env : env) (tok : CST.pat_email) =\n+  (* pattern [eE][mM][aA][iI][lL] *) token env tok\n+\n+let map_pat_if (env : env) (tok : CST.pat_if) =\n+  (* pattern [iI][fF] *) token env tok\n+\n+let map_pat_rows (env : env) (tok : CST.pat_rows) =\n+  (* pattern [rR][oO][wW][sS] *) token env tok\n+\n+let map_pat_else (env : env) (tok : CST.pat_else) =\n+  (* pattern [eE][lL][sS][eE] *) token env tok\n+\n+let map_pat_week_in_year (env : env) (tok : CST.pat_week_in_year) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_limit (env : env) (tok : CST.pat_limit) =\n+  (* pattern [lL][iI][mM][iI][tT] *) token env tok\n+\n+let map_pat_next_month (env : env) (tok : CST.pat_next_month) =\n+  (* pattern [nN][eE][xX][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_trac (env : env) (tok : CST.pat_trac) =\n+  (* pattern [tT][rR][aA][cC][kK][iI][nN][gG] *) token env tok\n+\n+let map_block_comment (env : env) (tok : CST.block_comment) =\n+  (* block_comment *) token env tok\n+\n+let map_pat_dist (env : env) (tok : CST.pat_dist) =\n+  (* pattern [dD][iI][sS][tT][aA][nN][cC][eE] *) token env tok\n+\n+let map_pat_rollup (env : env) (tok : CST.pat_rollup) =\n+  (* pattern [rR][oO][lL][lL][uU][pP] *) token env tok\n+\n+let map_pat_inte (env : env) (tok : CST.pat_inte) =\n+  (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *) token env tok\n+\n+let map_pat_set (env : env) (tok : CST.pat_set) =\n+  (* pattern [sS][eE][tT] *) token env tok\n+\n+let map_decimal (env : env) (tok : CST.decimal) =\n+  (* pattern -?\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_last_fiscal_quar (env : env) (tok : CST.pat_last_fiscal_quar) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_for (env : env) (tok : CST.pat_for) =\n+  (* pattern [fF][oO][rR] *) token env tok\n+\n+let map_pat_pric (env : env) (tok : CST.pat_pric) =\n+  (* pattern [pP][rR][iI][cC][eE][bB][oO][oO][kK][iI][dD] *) token env tok\n+\n+let map_pat_last_fiscal_year (env : env) (tok : CST.pat_last_fiscal_year) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_this_quar (env : env) (tok : CST.pat_this_quar) =\n+  (* pattern [tT][hH][iI][sS][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_at (env : env) (tok : CST.pat_at) =\n+  (* pattern [aA][tT] *) token env tok\n+\n+let map_pat_static (env : env) (tok : CST.pat_static) =\n+  (* pattern [sS][tT][aA][tT][iI][cC] *) token env tok\n+\n+let map_pat_fiscal_quar (env : env) (tok : CST.pat_fiscal_quar) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_tomo (env : env) (tok : CST.pat_tomo) =\n+  (* pattern [tT][oO][mM][oO][rR][rR][oO][wW] *) token env tok\n+\n+let map_pat_geol (env : env) (tok : CST.pat_geol) =\n+  (* pattern [gG][eE][oO][lL][oO][cC][aA][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_day_in_week (env : env) (tok : CST.pat_day_in_week) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_last_week (env : env) (tok : CST.pat_last_week) =\n+  (* pattern [lL][aA][sS][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_divi (env : env) (tok : CST.pat_divi) =\n+  (* pattern [dD][iI][vV][iI][sS][iI][oO][nN] *) token env tok\n+\n+let map_pat_abst (env : env) (tok : CST.pat_abst) =\n+  (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *) token env tok\n+\n+let map_pat_custom (env : env) (tok : CST.pat_custom) =\n+  (* pattern [cC][uU][sS][tT][oO][mM] *) token env tok\n+\n+let map_pat_userid (env : env) (tok : CST.pat_userid) =\n+  (* pattern [uU][sS][eE][rR][iI][dD] *) token env tok\n+\n+let map_pat_over (env : env) (tok : CST.pat_over) =\n+  (* pattern [oO][vV][eE][rR][rR][iI][dD][eE] *) token env tok\n+\n+let map_pat_fina (env : env) (tok : CST.pat_fina) =\n+  (* pattern [fF][iI][nN][aA][lL][lL][yY] *) token env tok\n+\n+let map_pat_trig (env : env) (tok : CST.pat_trig) =\n+  (* pattern [tT][rR][iI][gG][gG][eE][rR] *) token env tok\n+\n+let map_pat_cale_quar (env : env) (tok : CST.pat_cale_quar) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_this_week (env : env) (tok : CST.pat_this_week) =\n+  (* pattern [tT][hH][iI][sS][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_throw (env : env) (tok : CST.pat_throw) =\n+  (* pattern [tT][hH][rR][oO][wW] *) token env tok\n+\n+let map_pat_ever (env : env) (tok : CST.pat_ever) =\n+  (* pattern [eE][vV][eE][rR][yY][tT][hH][iI][nN][gG] *) token env tok\n+\n+let map_pat_cube (env : env) (tok : CST.pat_cube) =\n+  (* pattern [cC][uU][bB][eE] *) token env tok\n+\n+let map_pat_hour_in_day (env : env) (tok : CST.pat_hour_in_day) =\n+  (* pattern [hH][oO][uU][rR][__][iI][nN][__][dD][aA][yY] *) token env tok\n+\n+let map_pat_day_in_month (env : env) (tok : CST.pat_day_in_month) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_last_90_days (env : env) (tok : CST.pat_last_90_days) =\n+  (* pattern [lL][aA][sS][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+(* OLD *)\n+let map_dimensions (env : env) (xs : CST.dimensions) =\n+  R.List (List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token env v1 in\n+    let v2 = (* \"]\" *) token env v2 in\n+    R.Tuple [v1; v2]\n+  ) xs)\n+\n+(* NEW *)\n+let dimensions (env : env) (xs : CST.dimensions) : (G.tok * G.tok) list =\n+  List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token_ env v1 in\n+    let v2 = (* \"]\" *) token_ env v2 in\n+    v1, v2)\n+    xs\n+\n+let map_pat_cale_year (env : env) (tok : CST.pat_cale_year) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_last_year (env : env) (tok : CST.pat_last_year) =\n+  (* pattern [lL][aA][sS][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_end (env : env) (tok : CST.pat_end) =\n+  (* pattern [eE][nN][dD] *) token env tok\n+\n+let map_pat_format (env : env) (tok : CST.pat_format) =\n+  (* pattern [fF][oO][rR][mM][aA][tT] *) token env tok\n+\n+let map_pat_switch (env : env) (tok : CST.pat_switch) =\n+  (* pattern [sS][wW][iI][tT][cC][hH] *) token env tok\n+\n+let map_pat_priv (env : env) (tok : CST.pat_priv) =\n+  (* pattern [pP][rR][iI][vV][aA][tT][eE] *) token env tok\n+\n+let map_pat_count (env : env) (tok : CST.pat_count) =\n+  (* pattern [cC][oO][uU][nN][tT] *) token env tok\n+\n+let map_pat_this_fiscal_quar (env : env) (tok : CST.pat_this_fiscal_quar) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_term (env : env) (tok : CST.term) =\n+  (* pattern \"(\\\\\\\\\\\\'|[^'])+\" *) token env tok\n+\n+let map_pat_after (env : env) (tok : CST.pat_after) =\n+  (* pattern [aA][fF][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_year (env : env) (tok : CST.pat_next_year) =\n+  (* pattern [nN][eE][xX][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_extends (env : env) (tok : CST.pat_extends) =\n+  (* pattern [eE][xX][tT][eE][nN][dD][sS] *) token env tok\n+\n+let map_pat_update (env : env) (tok : CST.pat_update) =\n+  (* pattern [uU][pP][dD][aA][tT][eE] *) token env tok\n+\n+let map_pat_this_year (env : env) (tok : CST.pat_this_year) =\n+  (* pattern [tT][hH][iI][sS][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_view_ (env : env) (tok : CST.pat_view_) =\n+  (* pattern [vV][iI][eE][wW][sS][tT][aA][tT] *) token env tok\n+\n+let map_pat_fiscal_year (env : env) (tok : CST.pat_fiscal_year) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_my_terr (env : env) (tok : CST.pat_my_terr) =\n+  (* pattern [mM][yY][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_tok_choice_pat_last_n_days (env : env) (tok : CST.tok_choice_pat_last_n_days) =\n+  (* tok_choice_pat_last_n_days *) token env tok\n+\n+let map_pat_do (env : env) (tok : CST.pat_do) =\n+  (* pattern [dD][oO] *) token env tok\n+\n+let map_pat_true (env : env) (tok : CST.pat_true) =\n+  (* pattern [tT][rR][uU][eE] *) token env tok\n+\n+let map_pat_by (env : env) (tok : CST.pat_by) =\n+  (* pattern [bB][yY] *) token env tok\n+\n+let map_pat_above_or_below (env : env) (tok : CST.pat_above_or_below) =\n+  (* pattern [aA][bB][oO][vV][eE][__][oO][rR][__][bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_pat_last_quar (env : env) (tok : CST.pat_last_quar) =\n+  (* pattern [lL][aA][sS][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_from (env : env) (tok : CST.pat_from) =\n+  (* pattern [fF][rR][oO][mM] *) token env tok\n+\n+let map_pat_team (env : env) (tok : CST.pat_team) =\n+  (* pattern [tT][eE][aA][mM] *) token env tok\n+\n+let map_pat_and (env : env) (tok : CST.pat_and) =\n+  (* pattern [aA][nN][dD] *) token env tok\n+\n+let map_pat_phone (env : env) (tok : CST.pat_phone) =\n+  (* pattern [pP][hH][oO][nN][eE] *) token env tok\n+\n+let map_pat_this (env : env) (tok : CST.pat_this) =\n+  (* pattern [tT][hH][iI][sS] *) token env tok\n+\n+let map_pat_week_in_month (env : env) (tok : CST.pat_week_in_month) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_next_week (env : env) (tok : CST.pat_next_week) =\n+  (* pattern [nN][eE][xX][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_having (env : env) (tok : CST.pat_having) =\n+  (* pattern [hH][aA][vV][iI][nN][gG] *) token env tok\n+\n+let map_pat_next_quar (env : env) (tok : CST.pat_next_quar) =\n+  (* pattern [nN][eE][xX][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_fiscal_quar (env : env) (tok : CST.pat_next_fiscal_quar) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_asc (env : env) (tok : CST.pat_asc) =\n+  (* pattern [aA][sS][cC] *) token env tok\n+\n+let map_pat_null (env : env) (tok : CST.pat_null) =\n+  (* pattern [nN][uU][lL][lL] *) token env tok\n+\n+let map_pat_global (env : env) (tok : CST.pat_global) =\n+  (* pattern [gG][lL][oO][bB][aA][lL] *) token env tok\n+\n+let map_pat_max (env : env) (tok : CST.pat_max) =\n+  (* pattern [mM][aA][xX] *) token env tok\n+\n+let map_pat_all (env : env) (tok : CST.pat_all) =\n+  (* pattern [aA][lL][lL] *) token env tok\n+\n+let map_pat_reco (env : env) (tok : CST.pat_reco) =\n+  (* pattern [rR][eE][cC][oO][rR][dD][vV][iI][sS][iI][bB][iI][lL][iI][tT][yY][cC][oO][nN][tT][eE][xX][tT] *) token env tok\n+\n+let map_pat_cont (env : env) (tok : CST.pat_cont) =\n+  (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *) token env tok\n+\n+let map_pat_get (env : env) (tok : CST.pat_get) =\n+  (* pattern [gG][eE][tT] *) token env tok\n+\n+let map_pat_select (env : env) (tok : CST.pat_select) =\n+  (* pattern [sS][eE][lL][eE][cC][tT] *) token env tok\n+\n+let map_pat_conv (env : env) (tok : CST.pat_conv) =\n+  (* pattern [cC][oO][nN][vV][eE][rR][tT][cC][uU][rR][rR][eE][nN][cC][yY] *) token env tok\n+\n+let map_pat_inhe (env : env) (tok : CST.pat_inhe) =\n+  (* pattern [iI][nN][hH][eE][rR][iI][tT][eE][dD] *) token env tok\n+\n+let map_pat_maxd (env : env) (tok : CST.pat_maxd) =\n+  (* pattern [mM][aA][xX][dD][eE][sS][cC][rR][iI][pP][tT][oO][rR][pP][eE][rR][rR][eE][cC][oO][rR][dD] *) token env tok\n+\n+let map_pat_name (env : env) (tok : CST.pat_name) =\n+  (* pattern [nN][aA][mM][eE] *) token env tok\n+\n+let map_pat_catch (env : env) (tok : CST.pat_catch) =\n+  (* pattern [cC][aA][tT][cC][hH] *) token env tok\n+\n+let map_semgrep_metavar (env : env) (tok : CST.semgrep_metavar) =\n+  (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_retu (env : env) (tok : CST.pat_retu) =\n+  (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *) token env tok\n+\n+let map_pat_system_mode (env : env) (tok : CST.pat_system_mode) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_using (env : env) (tok : CST.pat_using) =\n+  (* pattern [uU][sS][iI][nN][gG] *) token env tok\n+\n+let map_pat_class (env : env) (tok : CST.pat_class) =\n+  (* pattern [cC][lL][aA][sS][sS] *) token env tok\n+\n+let map_pat_e8c36c5 (env : env) (tok : CST.pat_e8c36c5) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][..][rR][uU][nN][aA][sS] *) token env tok\n+\n+let map_pat_exclus (env : env) (tok : CST.pat_exclus) =\n+  (* pattern [eE][xX][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_order (env : env) (tok : CST.pat_order) =\n+  (* pattern [oO][rR][dD][eE][rR] *) token env tok\n+\n+let map_pat_yest (env : env) (tok : CST.pat_yest) =\n+  (* pattern [yY][eE][sS][tT][eE][rR][dD][aA][yY] *) token env tok\n+\n+let map_pat_false (env : env) (tok : CST.pat_false) =\n+  (* pattern [fF][aA][lL][sS][eE] *) token env tok\n+\n+let map_pat_grou (env : env) (tok : CST.pat_grou) =\n+  (* pattern [gG][rR][oO][uU][pP][iI][nN][gG] *) token env tok\n+\n+let map_pat_enum (env : env) (tok : CST.pat_enum) =\n+  (* pattern [eE][nN][uU][mM] *) token env tok\n+\n+let map_pat_new (env : env) (tok : CST.pat_new) =\n+  (* pattern [nN][eE][wW] *) token env tok\n+\n+let map_pat_this_fiscal_year (env : env) (tok : CST.pat_this_fiscal_year) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_group (env : env) (tok : CST.pat_group) =\n+  (* pattern [gG][rR][oO][uU][pP] *) token env tok\n+\n+let map_int_ (env : env) (tok : CST.int_) =\n+  (* int *) token env tok\n+\n+let map_pat_with_ (env : env) (tok : CST.pat_with_) =\n+  (* pattern [wW][iI][tT][hH][oO][uU][tT] *) token env tok\n+\n+let map_pat_secu_enfo (env : env) (tok : CST.pat_secu_enfo) =\n+  (* pattern [sS][eE][cC][uU][rR][iI][tT][yY][__][eE][nN][fF][oO][rR][cC][eE][dD] *) token env tok\n+\n+let map_pat_brk (env : env) (tok : CST.pat_brk) =\n+  (* pattern [bB][rR][eE][aA][kK] *) token env tok\n+\n+let map_pat_day_in_year (env : env) (tok : CST.pat_day_in_year) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_line_comment (env : env) (tok : CST.line_comment) =\n+  (* line_comment *) token env tok\n+\n+let map_pat_delete (env : env) (tok : CST.pat_delete) =\n+  (* pattern [dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+(* OLD QUERY *)\n+let map_value_comparison_operator (env : env) (x : CST.value_comparison_operator) =\n+  (match x with\n+  | `EQ tok -> R.Case (\"EQ\",\n+      (* \"=\" *) token env tok\n+    )\n+  | `BANGEQ tok -> R.Case (\"BANGEQ\",\n+      (* \"!=\" *) token env tok\n+    )\n+  | `LTGT tok -> R.Case (\"LTGT\",\n+      (* \"<>\" *) token env tok\n+    )\n+  | `LT tok -> R.Case (\"LT\",\n+      (* \"<\" *) token env tok\n+    )\n+  | `LTEQ tok -> R.Case (\"LTEQ\",\n+      (* \"<=\" *) token env tok\n+    )\n+  | `GT tok -> R.Case (\"GT\",\n+      (* \">\" *) token env tok\n+    )\n+  | `GTEQ tok -> R.Case (\"GTEQ\",\n+      (* \">=\" *) token env tok\n+    )\n+  | `Pat_like x -> R.Case (\"Pat_like\",\n+      map_pat_like env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let value_comparison_operator (env : env) (x : CST.value_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `EQ tok ->\n+      let t = (* \"=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Eq, t) |> G.e\n+  | `BANGEQ tok ->\n+      let t = (* \"!=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LTGT tok ->\n+      let t = (* \"<>\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LT tok ->\n+      let t = (* \"<\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Lt, t) |> G.e\n+  | `LTEQ tok ->\n+      let t = (* \"<=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.LtE, t) |> G.e\n+  | `GT tok ->\n+      let t = (* \">\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Gt, t) |> G.e\n+  | `GTEQ tok ->\n+      let t = (* \">=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.GtE, t) |> G.e\n+  | `Pat_like x ->\n+      let v = (* \"like\" *) str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_highlight (env : env) (x : CST.with_highlight) =\n+  map_pat_high env x\n+\n+let with_highlight (env : env) (x : CST.with_highlight) : G.ident =\n+  (* \"hightlight\" *) str env x\n+\n+(* OLD *)\n+let map_super (env : env) (x : CST.super) =\n+  map_pat_super env x\n+\n+(* NEW *)\n+let super (env : env) (x : CST.super) : G.expr =\n+  let t = (* \"super\" *) token_ env x in\n+  G.IdSpecial (G.Super, t) |> G.e\n+\n+(* AUX*)\n+let super_to_field_name (env : env) (x : CST.super) : G.field_name =\n+  let i = (* \"super\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* AUX *)\n+let this_to_field_name (env : env) (x : CST.this) : G.field_name =\n+  let i = (* \"this\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* OLD QUERY *)\n+let map_order_null_direciton (env : env) (x : CST.order_null_direciton) =\n+  (match x with\n+  | `Pat_nulls_pat_first (v1, v2) -> R.Case (\"Pat_nulls_pat_first\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_first env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_nulls_pat_last (v1, v2) -> R.Case (\"Pat_nulls_pat_last\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_last env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_null_direciton (env : env) (x : CST.order_null_direciton) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_nulls_pat_first (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"first\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+  | `Pat_nulls_pat_last (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"last\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+\n+let map_void_type (env : env) (x : CST.void_type) =\n+  map_pat_void env x\n+\n+(* OLD QUERY *)\n+let map_count_expression (env : env) ((v1, v2, v3) : CST.count_expression) =\n+  let v1 = map_pat_count env v1 in\n+  let v2 = (* \"(\" *) token env v2 in\n+  let v3 = (* \")\" *) token env v3 in\n+  R.Tuple [v1; v2; v3]\n+\n+(* RAW QUERY *)\n+let count_expression (env : env) ((v1, v2, v3) : CST.count_expression)\n+    : G.expr =\n+  let v1 = str env v1 in\n+  let v2 = (* \"(\" *) token_ env v2 in\n+  let v3 = (* \")\" *) token_ env v3 in\n+  G.Call (G.N (G.Id (v1, G.empty_id_info ())) |> G.e, (v2, [], v3)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_for_type (env : env) (x : CST.for_type) =\n+  (match x with\n+  | `Pat_update x -> R.Case (\"Pat_update\",\n+      map_pat_update env x\n+    )\n+  | `Pat_ref x -> R.Case (\"Pat_ref\",\n+      map_pat_ref env x\n+    )\n+  | `Pat_view x -> R.Case (\"Pat_view\",\n+      map_pat_view env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let for_type (env : env) (x : CST.for_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_update x\n+  | `Pat_ref x\n+  | `Pat_view x ->\n+      let v = str env x in\n+      R.Token v\n+\n+(* OLD QUERY *)\n+let map_update_type (env : env) (x : CST.update_type) =\n+  (match x with\n+  | `Pat_trac x -> R.Case (\"Pat_trac\",\n+      map_pat_trac env x\n+    )\n+  | `Pat_view_ x -> R.Case (\"Pat_view_\",\n+      map_pat_view_ env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let update_type (env : env) (x : CST.update_type) : G.expr =\n+  let v1 =\n+    match x with\n+    | `Pat_trac x\n+    | `Pat_view_ x ->\n+        str env x\n+  in\n+    G.L (G.String (fb v1)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) =\n+  (match x with\n+  | `Pat_at x -> R.Case (\"Pat_at\",\n+      map_pat_at env x\n+    )\n+  | `Pat_above x -> R.Case (\"Pat_above\",\n+      map_pat_above env x\n+    )\n+  | `Pat_below x -> R.Case (\"Pat_below\",\n+      map_pat_below env x\n+    )\n+  | `Pat_above_or_below x -> R.Case (\"Pat_above_or_below\",\n+      map_pat_above_or_below env x\n+    )\n+  )\n+\n+(* NEW QUERY *)\n+let with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_at x\n+  | `Pat_above x\n+  | `Pat_below x\n+  | `Pat_above_or_below x ->\n+      R.Token (str env x)\n+\n+(* OLD QUERY *)\n+let map_using_scope_type (env : env) (x : CST.using_scope_type) =\n+  (match x with\n+  | `Pat_dele x -> R.Case (\"Pat_dele\",\n+      map_pat_dele env x\n+    )\n+  | `Pat_ever x -> R.Case (\"Pat_ever\",\n+      map_pat_ever env x\n+    )\n+  | `Pat_mine x -> R.Case (\"Pat_mine\",\n+      map_pat_mine env x\n+    )\n+  | `Pat_mine_and_my_groups x -> R.Case (\"Pat_mine_and_my_groups\",\n+      map_pat_mine_and_my_groups env x\n+    )\n+  | `Pat_my_terr x -> R.Case (\"Pat_my_terr\",\n+      map_pat_my_terr env x\n+    )\n+  | `Pat_my_team_terr x -> R.Case (\"Pat_my_team_terr\",\n+      map_pat_my_team_terr env x\n+    )\n+  | `Pat_team x -> R.Case (\"Pat_team\",\n+      map_pat_team env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let using_scope_type (env : env) (x : CST.using_scope_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_dele x\n+  | `Pat_ever x\n+  | `Pat_mine x\n+  | `Pat_mine_and_my_groups x\n+  | `Pat_my_terr x\n+  | `Pat_my_team_terr x\n+  | `Pat_team x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_this (env : env) (x : CST.this) =\n+  map_pat_this env x\n+\n+(* NEW *)\n+let this (env : env) (x : CST.this) : G.expr =\n+  let t = token_ env x (* \"this\" *) in\n+  IdSpecial (This, t) |> G.e\n+\n+(* OLD QUERY *)\n+let map_order_direction (env : env) (x : CST.order_direction) =\n+  (match x with\n+  | `Pat_asc x -> R.Case (\"Pat_asc\",\n+      map_pat_asc env x\n+    )\n+  | `Pat_desc x -> R.Case (\"Pat_desc\",\n+      map_pat_desc env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_direction (env : env) (x : CST.order_direction) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_asc x\n+  | `Pat_desc x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_null_literal (env : env) (x : CST.null_literal) =\n+  map_pat_null env x\n+\n+(* NEW *)\n+let null_literal (env : env) (x : CST.null_literal) : literal =\n+  G.Null (token_ env x)\n+\n+(* OLD QUERY *)\n+let map_all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) =\n+  let v1 = map_pat_all env v1 in\n+  let v2 = map_pat_rows env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* RAW QUERY *)\n+let all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) : raw =\n+  let module R = Raw_tree in\n+  let v1 = (* \"all\" *) str env v1 in\n+  let v2 = (* \"rows\" *) str env v2 in\n+  R.Tuple [R.Token v1; R.Token v2]\n+\n+(* OLD QUERY *)\n+let map_fields_type (env : env) (x : CST.fields_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_custom x -> R.Case (\"Pat_custom\",\n+      map_pat_custom env x\n+    )\n+  | `Pat_stan x -> R.Case (\"Pat_stan\",\n+      map_pat_stan env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let fields_type (env : env) (x : CST.fields_type) : G.ident =\n+  match x with\n+  | `Pat_all x\n+  | `Pat_custom x\n+  | `Pat_stan x ->\n+      str env x\n+\n+(* OLD QUERY *)\n+let map_in_type (env : env) (x : CST.in_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_email x -> R.Case (\"Pat_email\",\n+      map_pat_email env x\n+    )\n+  | `Pat_name x -> R.Case (\"Pat_name\",\n+      map_pat_name env x\n+    )\n+  | `Pat_phone x -> R.Case (\"Pat_phone\",\n+      map_pat_phone env x\n+    )\n+  | `Pat_side x -> R.Case (\"Pat_side\",\n+      map_pat_side env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let in_type (env : env) (x : CST.in_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_all x\n+  | `Pat_email x\n+  | `Pat_name x\n+  | `Pat_phone x\n+  | `Pat_side x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_identifier (env : env) (x : CST.identifier) =\n+  (match x with\n+  | `Semg_meta tok -> R.Case (\"Semg_meta\",\n+      (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+    )\n+  | `Apex_id_ tok -> R.Case (\"Apex_id_\",\n+      (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+    )\n+  )\n+\n+(* NEW *)\n+let identifier (env : env) (x : CST.identifier) : G.ident =\n+  match x with\n+  | `Semg_meta tok (* pattern \\$[A-Z_][A-Z_0-9]* *) ->\n+      str env tok\n+  | `Apex_id_ tok (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) ->\n+      str env tok\n+\n+(* AUX *)\n+let identifier_to_expression (env : env) (x : CST.identifier) : G.expr =\n+  G.N (H2.name_of_id (identifier env x)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_set_comparison_operator (env : env) (x : CST.set_comparison_operator) =\n+  (match x with\n+  | `Pat_in x -> R.Case (\"Pat_in\",\n+      map_pat_in env x\n+    )\n+  | `Pat_not_pat_in (v1, v2) -> R.Case (\"Pat_not_pat_in\",\n+      let v1 = map_pat_not env v1 in\n+      let v2 = map_pat_in env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_inclus x -> R.Case (\"Pat_inclus\",\n+      map_pat_inclus env x\n+    )\n+  | `Pat_exclus x -> R.Case (\"Pat_exclus\",\n+      map_pat_exclus env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let set_comparison_operator (env : env) (x : CST.set_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_in x\n+  | `Pat_inclus x\n+  | `Pat_exclus x ->\n+      let v = str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+  | `Pat_not_pat_in (v1, v2) ->\n+      let v1 = str env v1 in\n+      let v2 = str env v2 in\n+      G.RawExpr (R.Tuple [R.Token v1; R.Token v2]) |> G.e\n+\n+(* OLD *)\n+let map_boolean (env : env) (x : CST.boolean) =\n+  (match x with\n+  | `Pat_true x -> R.Case (\"Pat_true\",\n+      map_pat_true env x\n+    )\n+  | `Pat_false x -> R.Case (\"Pat_false\",\n+      map_pat_false env x\n+    )\n+  )\n+\n+(* NEW *)\n+let boolean (env : env) (x : CST.boolean) : literal =\n+  match x with\n+  | `Pat_true tok -> G.Bool (true, token_ env tok)\n+  | `Pat_false tok -> G.Bool (false, token_ env tok)\n+\n+(* OLD QUERY *)\n+let map_date_literal (env : env) (x : CST.date_literal) =\n+  (match x with\n+  | `Pat_yest x -> R.Case (\"Pat_yest\",\n+      map_pat_yest env x\n+    )\n+  | `Pat_today x -> R.Case (\"Pat_today\",\n+      map_pat_today env x\n+    )\n+  | `Pat_tomo x -> R.Case (\"Pat_tomo\",\n+      map_pat_tomo env x\n+    )\n+  | `Pat_last_week x -> R.Case (\"Pat_last_week\",\n+      map_pat_last_week env x\n+    )\n+  | `Pat_this_week x -> R.Case (\"Pat_this_week\",\n+      map_pat_this_week env x\n+    )\n+  | `Pat_next_week x -> R.Case (\"Pat_next_week\",\n+      map_pat_next_week env x\n+    )\n+  | `Pat_last_month x -> R.Case (\"Pat_last_month\",\n+      map_pat_last_month env x\n+    )\n+  | `Pat_this_month x -> R.Case (\"Pat_this_month\",\n+      map_pat_this_month env x\n+    )\n+  | `Pat_next_month x -> R.Case (\"Pat_next_month\",\n+      map_pat_next_month env x\n+    )\n+  | `Pat_last_90_days x -> R.Case (\"Pat_last_90_days\",\n+      map_pat_last_90_days env x\n+    )\n+  | `Pat_next_90_days x -> R.Case (\"Pat_next_90_days\",\n+      map_pat_next_90_days env x\n+    )\n+  | `Pat_this_quar x -> R.Case (\"Pat_this_quar\",\n+      map_pat_this_quar env x\n+    )\n+  | `Pat_last_quar x -> R.Case (\"Pat_last_quar\",\n+      map_pat_last_quar env x\n+    )\n+  | `Pat_next_quar x -> R.Case (\"Pat_next_quar\",\n+      map_pat_next_quar env x\n+    )\n+  | `Pat_this_year x -> R.Case (\"Pat_this_year\",\n+      map_pat_this_year env x\n+    )\n+  | `Pat_last_year x -> R.Case (\"Pat_last_year\",\n+      map_pat_last_year env x\n+    )\n+  | `Pat_next_year x -> R.Case (\"Pat_next_year\",\n+      map_pat_next_year env x\n+    )\n+  | `Pat_this_fiscal_quar x -> R.Case (\"Pat_this_fiscal_quar\",\n+      map_pat_this_fiscal_quar env x\n+    )\n+  | `Pat_last_fiscal_quar x -> R.Case (\"Pat_last_fiscal_quar\",\n+      map_pat_last_fiscal_quar env x\n+    )\n+  | `Pat_next_fiscal_quar x -> R.Case (\"Pat_next_fiscal_quar\",\n+      map_pat_next_fiscal_quar env x\n+    )\n+  | `Pat_this_fiscal_year x -> R.Case (\"Pat_this_fiscal_year\",\n+      map_pat_this_fiscal_year env x\n+    )\n+  | `Pat_last_fiscal_year x -> R.Case (\"Pat_last_fiscal_year\",\n+      map_pat_last_fiscal_year env x\n+    )\n+  | `Pat_next_fiscal_year x -> R.Case (\"Pat_next_fiscal_year\",\n+      map_pat_next_fiscal_year env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let date_literal (env : env) (x : CST.date_literal) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_yest x\n+  | `Pat_today x\n+  | `Pat_tomo x\n+  | `Pat_last_week x\n+  | `Pat_this_week x\n+  | `Pat_next_week x\n+  | `Pat_last_month x\n+  | `Pat_this_month x\n+  | `Pat_next_month x\n+  | `Pat_last_90_days x\n+  | `Pat_next_90_days x\n+  | `Pat_this_quar x\n+  | `Pat_last_quar x\n+  | `Pat_next_quar x\n+  | `Pat_this_year x\n+  | `Pat_last_year x\n+  | `Pat_next_year x\n+  | `Pat_this_fiscal_quar x\n+  | `Pat_last_fiscal_quar x\n+  | `Pat_next_fiscal_quar x\n+  | `Pat_this_fiscal_year x\n+  | `Pat_last_fiscal_year x\n+  | `Pat_next_fiscal_year x ->\n+      let v = str env x in\n+      R.Token v",
        "comment_created_at": "2025-07-08T20:25:23+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "I wonder why we use `R.token` instead of proper token: `let token = H.token` as in csharp.",
        "pr_file_module": null
      },
      {
        "comment_id": "2193404699",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 337,
        "pr_file": "languages/apex/generic/Parse_apex_tree_sitter.ml",
        "discussion_id": "2193382256",
        "commented_code": "@@ -0,0 +1,7343 @@\n+(**\n+   Boilerplate to be used as a template when mapping the apex CST\n+   to another type of tree.\n+*)\n+\n+(*  open Common *)\n+(*  open Either_ *)\n+open Fpath_.Operators\n+module H = Parse_tree_sitter_helpers\n+open AST_generic\n+module G = AST_generic\n+module H2 = AST_generic_helpers\n+module CST = Tree_sitter_apex.CST\n+\n+module R = Tree_sitter_run.Raw_tree\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27-32\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+type raw = G.raw_tree\n+\n+let token_ = H.token\n+let str = H.str\n+let fb = Tok.unsafe_fake_bracket\n+\n+let token (env : env) (tok : Tree_sitter_run.Token.t) =\n+  R.Token tok\n+\n+let blank (env : env) () =\n+  R.Tuple []\n+\n+let map_pat_snip (env : env) (tok : CST.pat_snip) =\n+  (* pattern [sS][nN][iI][pP][pP][eE][tT] *) token env tok\n+\n+let map_pat_data (env : env) (tok : CST.pat_data) =\n+  (* pattern [dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_first (env : env) (tok : CST.pat_first) =\n+  (* pattern [fF][iI][rR][sS][tT] *) token env tok\n+\n+let map_pat_suppos (env : env) (tok : CST.pat_suppos) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][oO][mM][aA][iI][nN][sS] *) token env tok\n+\n+let map_pat_view (env : env) (tok : CST.pat_view) =\n+  (* pattern [vV][iI][eE][wW] *) token env tok\n+\n+let map_pat_find (env : env) (tok : CST.pat_find) =\n+  (* pattern [fF][iI][nN][dD] *) token env tok\n+\n+let map_pat_suppos_ (env : env) (tok : CST.pat_suppos_) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][eE][lL][eE][gG][aA][tT][eE][sS] *) token env tok\n+\n+let map_pat_final (env : env) (tok : CST.pat_final) =\n+  (* pattern [fF][iI][nN][aA][lL] *) token env tok\n+\n+let map_pat_my_team_terr (env : env) (tok : CST.pat_my_team_terr) =\n+  (* pattern [mM][yY][__][tT][eE][aA][mM][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_currency_literal (env : env) (tok : CST.currency_literal) =\n+  (* pattern \\w{3}\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_virt (env : env) (tok : CST.pat_virt) =\n+  (* pattern [vV][iI][rR][tT][uU][aA][lL] *) token env tok\n+\n+let map_pat_shar (env : env) (tok : CST.pat_shar) =\n+  (* pattern [sS][hH][aA][rR][iI][nN][gG] *) token env tok\n+\n+let map_pat_in (env : env) (tok : CST.pat_in) =\n+  (* pattern [iI][nN] *) token env tok\n+\n+let map_pat_meta (env : env) (tok : CST.pat_meta) =\n+  (* pattern [mM][eE][tT][aA][dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_user_mode (env : env) (tok : CST.pat_user_mode) =\n+  (* pattern [uU][sS][eE][rR][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_prot (env : env) (tok : CST.pat_prot) =\n+  (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *) token env tok\n+\n+let map_pat_next_fiscal_year (env : env) (tok : CST.pat_next_fiscal_year) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_tola (env : env) (tok : CST.pat_tola) =\n+  (* pattern [tT][oO][lL][aA][bB][eE][lL] *) token env tok\n+\n+let map_block_comment_explicit (env : env) (() : CST.block_comment_explicit) =\n+  R.Tuple []\n+\n+let map_pat_offset (env : env) (tok : CST.pat_offset) =\n+  (* pattern [oO][fF][fF][sS][eE][tT] *) token env tok\n+\n+let map_pat_today (env : env) (tok : CST.pat_today) =\n+  (* pattern [tT][oO][dD][aA][yY] *) token env tok\n+\n+let map_semgrep_metavar_ellipsis (env : env) (tok : CST.semgrep_metavar_ellipsis) =\n+  (* pattern \\$\\.\\.\\.[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_then (env : env) (tok : CST.pat_then) =\n+  (* pattern [tT][hH][eE][nN] *) token env tok\n+\n+let map_pat_above (env : env) (tok : CST.pat_above) =\n+  (* pattern [aA][bB][oO][vV][eE] *) token env tok\n+\n+let map_pat_insert (env : env) (tok : CST.pat_insert) =\n+  (* pattern [iI][nN][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_merge (env : env) (tok : CST.pat_merge) =\n+  (* pattern [mM][eE][rR][gG][eE] *) token env tok\n+\n+let map_pat_count_dist (env : env) (tok : CST.pat_count_dist) =\n+  (* pattern [cC][oO][uU][nN][tT][__][dD][iI][sS][tT][iI][nN][cC][tT] *) token env tok\n+\n+let map_pat_nulls (env : env) (tok : CST.pat_nulls) =\n+  (* pattern [nN][uU][lL][lL][sS] *) token env tok\n+\n+let map_date (env : env) (tok : CST.date) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1]) *) token env tok\n+\n+let map_decimal_floating_point_literal (env : env) (tok : CST.decimal_floating_point_literal) =\n+  (* decimal_floating_point_literal *) token env tok\n+\n+let map_pat_last_month (env : env) (tok : CST.pat_last_month) =\n+  (* pattern [lL][aA][sS][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+(* OLD *)\n+let map_property_navigation (env : env) ((v1, v2) : CST.property_navigation) =\n+  let v1 =\n+    (match v1 with\n+    | Some tok -> R.Option (Some (\n+        (* \"?\" *) token env tok\n+      ))\n+    | None -> R.Option None)\n+  in\n+  let v2 = (* \".\" *) token env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* NEW *)\n+let property_navigation (env : env) ((v1, v2) : CST.property_navigation)\n+    : G.tok option * G.tok =\n+  let v1 = Option.map ((* \"?\" *) token_ env) v1 in\n+  let v2 = (* \".\" *) token_ env v2 in\n+  (v1, v2)\n+\n+let map_pat_cale_month (env : env) (tok : CST.pat_cale_month) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_unde (env : env) (tok : CST.pat_unde) =\n+  (* pattern [uU][nN][dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+let map_pat_inclus (env : env) (tok : CST.pat_inclus) =\n+  (* pattern [iI][nN][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_side (env : env) (tok : CST.pat_side) =\n+  (* pattern [sS][iI][dD][eE][bB][aA][rR] *) token env tok\n+\n+let map_pat_dele (env : env) (tok : CST.pat_dele) =\n+  (* pattern [dD][eE][lL][eE][gG][aA][tT][eE][dD] *) token env tok\n+\n+let map_pat_fields (env : env) (tok : CST.pat_fields) =\n+  (* pattern [fF][iI][eE][lL][dD][sS] *) token env tok\n+\n+let map_pat_fiscal_month (env : env) (tok : CST.pat_fiscal_month) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_when (env : env) (tok : CST.pat_when) =\n+  (* pattern [wW][hH][eE][nN] *) token env tok\n+\n+let map_pat_like (env : env) (tok : CST.pat_like) =\n+  (* pattern [lL][iI][kK][eE] *) token env tok\n+\n+let map_pat_avg (env : env) (tok : CST.pat_avg) =\n+  (* pattern [aA][vV][gG] *) token env tok\n+\n+let map_pat_scope (env : env) (tok : CST.pat_scope) =\n+  (* pattern [sS][cC][oO][pP][eE] *) token env tok\n+\n+let map_pat_sum (env : env) (tok : CST.pat_sum) =\n+  (* pattern [sS][uU][mM] *) token env tok\n+\n+let map_pat_target_len (env : env) (tok : CST.pat_target_len) =\n+  (* pattern [tT][aA][rR][gG][eE][tT][__][lL][eE][nN][gG][tT][hH] *) token env tok\n+\n+let map_pat_try (env : env) (tok : CST.pat_try) =\n+  (* pattern [tT][rR][yY] *) token env tok\n+\n+let map_pat_inst (env : env) (tok : CST.pat_inst) =\n+  (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *) token env tok\n+\n+let map_pat_mine (env : env) (tok : CST.pat_mine) =\n+  (* pattern [mM][iI][nN][eE] *) token env tok\n+\n+let map_date_time (env : env) (tok : CST.date_time) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d\\d?\\d?)?(?:Z|[+-][0-1]\\d:[0-5]\\d) *) token env tok\n+\n+let map_pat_while (env : env) (tok : CST.pat_while) =\n+  (* pattern [wW][hH][iI][lL][eE] *) token env tok\n+\n+let map_pat_ret (env : env) (tok : CST.pat_ret) =\n+  (* pattern [rR][eE][tT][uU][rR][nN] *) token env tok\n+\n+let map_pat_with (env : env) (tok : CST.pat_with) =\n+  (* pattern [wW][iI][tT][hH] *) token env tok\n+\n+let map_pat_where (env : env) (tok : CST.pat_where) =\n+  (* pattern [wW][hH][eE][rR][eE] *) token env tok\n+\n+let map_pat_this_month (env : env) (tok : CST.pat_this_month) =\n+  (* pattern [tT][hH][iI][sS][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_high (env : env) (tok : CST.pat_high) =\n+  (* pattern [hH][iI][gG][hH][lL][iI][gG][hH][tT] *) token env tok\n+\n+let map_pat_tran (env : env) (tok : CST.pat_tran) =\n+  (* pattern [tT][rR][aA][nN][sS][iI][eE][nN][tT] *) token env tok\n+\n+let map_pat_as (env : env) (tok : CST.pat_as) =\n+  (* pattern [aA][sS] *) token env tok\n+\n+let map_pat_next_90_days (env : env) (tok : CST.pat_next_90_days) =\n+  (* pattern [nN][eE][xX][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+let map_pat_super (env : env) (tok : CST.pat_super) =\n+  (* pattern [sS][uU][pP][eE][rR] *) token env tok\n+\n+let map_pat_on (env : env) (tok : CST.pat_on) =\n+  (* pattern [oO][nN] *) token env tok\n+\n+let map_pat_min (env : env) (tok : CST.pat_min) =\n+  (* pattern [mM][iI][nN] *) token env tok\n+\n+let map_pat_mine_and_my_groups (env : env) (tok : CST.pat_mine_and_my_groups) =\n+  (* pattern [mM][iI][nN][eE][__][aA][nN][dD][__][mM][yY][__][gG][rR][oO][uU][pP][sS] *) token env tok\n+\n+let map_pat_list (env : env) (tok : CST.pat_list) =\n+  (* pattern [lL][iI][sS][tT][vV][iI][eE][wW] *) token env tok\n+\n+let map_string_literal (env : env) (tok : CST.string_literal) =\n+  (* pattern \"'(\\\\\\\\[nNrRtTbBfFuU\\\"'_%\\\\\\\\]|[^\\\\\\\\'])*'\" *) token env tok\n+\n+let map_pat_not (env : env) (tok : CST.pat_not) =\n+  (* pattern [nN][oO][tT] *) token env tok\n+\n+let map_pat_test (env : env) (tok : CST.pat_test) =\n+  (* pattern [tT][eE][sS][tT][mM][eE][tT][hH][oO][dD] *) token env tok\n+\n+let map_pat_typeof (env : env) (tok : CST.pat_typeof) =\n+  (* pattern [tT][yY][pP][eE][oO][fF] *) token env tok\n+\n+let map_pat_desc (env : env) (tok : CST.pat_desc) =\n+  (* pattern [dD][eE][sS][cC] *) token env tok\n+\n+let map_pat_day_only (env : env) (tok : CST.pat_day_only) =\n+  (* pattern [dD][aA][yY][__][oO][nN][lL][yY] *) token env tok\n+\n+let map_pat_spell_corr (env : env) (tok : CST.pat_spell_corr) =\n+  (* pattern [sS][pP][eE][lL][lL][__][cC][oO][rR][rR][eE][cC][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_ref (env : env) (tok : CST.pat_ref) =\n+  (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE] *) token env tok\n+\n+let map_pat_public (env : env) (tok : CST.pat_public) =\n+  (* pattern [pP][uU][bB][lL][iI][cC] *) token env tok\n+\n+let map_pat_last (env : env) (tok : CST.pat_last) =\n+  (* pattern [lL][aA][sS][tT] *) token env tok\n+\n+let map_pat_upsert (env : env) (tok : CST.pat_upsert) =\n+  (* pattern [uU][pP][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_void (env : env) (tok : CST.pat_void) =\n+  (* pattern [vV][oO][iI][dD] *) token env tok\n+\n+let map_pat_netw (env : env) (tok : CST.pat_netw) =\n+  (* pattern [nN][eE][tT][wW][oO][rR][kK] *) token env tok\n+\n+let map_pat_below (env : env) (tok : CST.pat_below) =\n+  (* pattern [bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_line_comment_explicit (env : env) (() : CST.line_comment_explicit) =\n+  R.Tuple []\n+\n+let map_apex_identifier_ (env : env) (tok : CST.apex_identifier_) =\n+  (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+\n+let map_pat_imples (env : env) (tok : CST.pat_imples) =\n+  (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *) token env tok\n+\n+let map_pat_stan (env : env) (tok : CST.pat_stan) =\n+  (* pattern [sS][tT][aA][nN][dD][aA][rR][dD] *) token env tok\n+\n+let map_pat_or (env : env) (tok : CST.pat_or) =\n+  (* pattern [oO][rR] *) token env tok\n+\n+let map_pat_cate (env : env) (tok : CST.pat_cate) =\n+  (* pattern [cC][aA][tT][eE][gG][oO][rR][yY] *) token env tok\n+\n+let map_pat_before (env : env) (tok : CST.pat_before) =\n+  (* pattern [bB][eE][fF][oO][rR][eE] *) token env tok\n+\n+let map_pat_email (env : env) (tok : CST.pat_email) =\n+  (* pattern [eE][mM][aA][iI][lL] *) token env tok\n+\n+let map_pat_if (env : env) (tok : CST.pat_if) =\n+  (* pattern [iI][fF] *) token env tok\n+\n+let map_pat_rows (env : env) (tok : CST.pat_rows) =\n+  (* pattern [rR][oO][wW][sS] *) token env tok\n+\n+let map_pat_else (env : env) (tok : CST.pat_else) =\n+  (* pattern [eE][lL][sS][eE] *) token env tok\n+\n+let map_pat_week_in_year (env : env) (tok : CST.pat_week_in_year) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_limit (env : env) (tok : CST.pat_limit) =\n+  (* pattern [lL][iI][mM][iI][tT] *) token env tok\n+\n+let map_pat_next_month (env : env) (tok : CST.pat_next_month) =\n+  (* pattern [nN][eE][xX][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_trac (env : env) (tok : CST.pat_trac) =\n+  (* pattern [tT][rR][aA][cC][kK][iI][nN][gG] *) token env tok\n+\n+let map_block_comment (env : env) (tok : CST.block_comment) =\n+  (* block_comment *) token env tok\n+\n+let map_pat_dist (env : env) (tok : CST.pat_dist) =\n+  (* pattern [dD][iI][sS][tT][aA][nN][cC][eE] *) token env tok\n+\n+let map_pat_rollup (env : env) (tok : CST.pat_rollup) =\n+  (* pattern [rR][oO][lL][lL][uU][pP] *) token env tok\n+\n+let map_pat_inte (env : env) (tok : CST.pat_inte) =\n+  (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *) token env tok\n+\n+let map_pat_set (env : env) (tok : CST.pat_set) =\n+  (* pattern [sS][eE][tT] *) token env tok\n+\n+let map_decimal (env : env) (tok : CST.decimal) =\n+  (* pattern -?\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_last_fiscal_quar (env : env) (tok : CST.pat_last_fiscal_quar) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_for (env : env) (tok : CST.pat_for) =\n+  (* pattern [fF][oO][rR] *) token env tok\n+\n+let map_pat_pric (env : env) (tok : CST.pat_pric) =\n+  (* pattern [pP][rR][iI][cC][eE][bB][oO][oO][kK][iI][dD] *) token env tok\n+\n+let map_pat_last_fiscal_year (env : env) (tok : CST.pat_last_fiscal_year) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_this_quar (env : env) (tok : CST.pat_this_quar) =\n+  (* pattern [tT][hH][iI][sS][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_at (env : env) (tok : CST.pat_at) =\n+  (* pattern [aA][tT] *) token env tok\n+\n+let map_pat_static (env : env) (tok : CST.pat_static) =\n+  (* pattern [sS][tT][aA][tT][iI][cC] *) token env tok\n+\n+let map_pat_fiscal_quar (env : env) (tok : CST.pat_fiscal_quar) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_tomo (env : env) (tok : CST.pat_tomo) =\n+  (* pattern [tT][oO][mM][oO][rR][rR][oO][wW] *) token env tok\n+\n+let map_pat_geol (env : env) (tok : CST.pat_geol) =\n+  (* pattern [gG][eE][oO][lL][oO][cC][aA][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_day_in_week (env : env) (tok : CST.pat_day_in_week) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_last_week (env : env) (tok : CST.pat_last_week) =\n+  (* pattern [lL][aA][sS][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_divi (env : env) (tok : CST.pat_divi) =\n+  (* pattern [dD][iI][vV][iI][sS][iI][oO][nN] *) token env tok\n+\n+let map_pat_abst (env : env) (tok : CST.pat_abst) =\n+  (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *) token env tok\n+\n+let map_pat_custom (env : env) (tok : CST.pat_custom) =\n+  (* pattern [cC][uU][sS][tT][oO][mM] *) token env tok\n+\n+let map_pat_userid (env : env) (tok : CST.pat_userid) =\n+  (* pattern [uU][sS][eE][rR][iI][dD] *) token env tok\n+\n+let map_pat_over (env : env) (tok : CST.pat_over) =\n+  (* pattern [oO][vV][eE][rR][rR][iI][dD][eE] *) token env tok\n+\n+let map_pat_fina (env : env) (tok : CST.pat_fina) =\n+  (* pattern [fF][iI][nN][aA][lL][lL][yY] *) token env tok\n+\n+let map_pat_trig (env : env) (tok : CST.pat_trig) =\n+  (* pattern [tT][rR][iI][gG][gG][eE][rR] *) token env tok\n+\n+let map_pat_cale_quar (env : env) (tok : CST.pat_cale_quar) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_this_week (env : env) (tok : CST.pat_this_week) =\n+  (* pattern [tT][hH][iI][sS][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_throw (env : env) (tok : CST.pat_throw) =\n+  (* pattern [tT][hH][rR][oO][wW] *) token env tok\n+\n+let map_pat_ever (env : env) (tok : CST.pat_ever) =\n+  (* pattern [eE][vV][eE][rR][yY][tT][hH][iI][nN][gG] *) token env tok\n+\n+let map_pat_cube (env : env) (tok : CST.pat_cube) =\n+  (* pattern [cC][uU][bB][eE] *) token env tok\n+\n+let map_pat_hour_in_day (env : env) (tok : CST.pat_hour_in_day) =\n+  (* pattern [hH][oO][uU][rR][__][iI][nN][__][dD][aA][yY] *) token env tok\n+\n+let map_pat_day_in_month (env : env) (tok : CST.pat_day_in_month) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_last_90_days (env : env) (tok : CST.pat_last_90_days) =\n+  (* pattern [lL][aA][sS][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+(* OLD *)\n+let map_dimensions (env : env) (xs : CST.dimensions) =\n+  R.List (List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token env v1 in\n+    let v2 = (* \"]\" *) token env v2 in\n+    R.Tuple [v1; v2]\n+  ) xs)\n+\n+(* NEW *)\n+let dimensions (env : env) (xs : CST.dimensions) : (G.tok * G.tok) list =\n+  List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token_ env v1 in\n+    let v2 = (* \"]\" *) token_ env v2 in\n+    v1, v2)\n+    xs\n+\n+let map_pat_cale_year (env : env) (tok : CST.pat_cale_year) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_last_year (env : env) (tok : CST.pat_last_year) =\n+  (* pattern [lL][aA][sS][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_end (env : env) (tok : CST.pat_end) =\n+  (* pattern [eE][nN][dD] *) token env tok\n+\n+let map_pat_format (env : env) (tok : CST.pat_format) =\n+  (* pattern [fF][oO][rR][mM][aA][tT] *) token env tok\n+\n+let map_pat_switch (env : env) (tok : CST.pat_switch) =\n+  (* pattern [sS][wW][iI][tT][cC][hH] *) token env tok\n+\n+let map_pat_priv (env : env) (tok : CST.pat_priv) =\n+  (* pattern [pP][rR][iI][vV][aA][tT][eE] *) token env tok\n+\n+let map_pat_count (env : env) (tok : CST.pat_count) =\n+  (* pattern [cC][oO][uU][nN][tT] *) token env tok\n+\n+let map_pat_this_fiscal_quar (env : env) (tok : CST.pat_this_fiscal_quar) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_term (env : env) (tok : CST.term) =\n+  (* pattern \"(\\\\\\\\\\\\'|[^'])+\" *) token env tok\n+\n+let map_pat_after (env : env) (tok : CST.pat_after) =\n+  (* pattern [aA][fF][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_year (env : env) (tok : CST.pat_next_year) =\n+  (* pattern [nN][eE][xX][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_extends (env : env) (tok : CST.pat_extends) =\n+  (* pattern [eE][xX][tT][eE][nN][dD][sS] *) token env tok\n+\n+let map_pat_update (env : env) (tok : CST.pat_update) =\n+  (* pattern [uU][pP][dD][aA][tT][eE] *) token env tok\n+\n+let map_pat_this_year (env : env) (tok : CST.pat_this_year) =\n+  (* pattern [tT][hH][iI][sS][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_view_ (env : env) (tok : CST.pat_view_) =\n+  (* pattern [vV][iI][eE][wW][sS][tT][aA][tT] *) token env tok\n+\n+let map_pat_fiscal_year (env : env) (tok : CST.pat_fiscal_year) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_my_terr (env : env) (tok : CST.pat_my_terr) =\n+  (* pattern [mM][yY][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_tok_choice_pat_last_n_days (env : env) (tok : CST.tok_choice_pat_last_n_days) =\n+  (* tok_choice_pat_last_n_days *) token env tok\n+\n+let map_pat_do (env : env) (tok : CST.pat_do) =\n+  (* pattern [dD][oO] *) token env tok\n+\n+let map_pat_true (env : env) (tok : CST.pat_true) =\n+  (* pattern [tT][rR][uU][eE] *) token env tok\n+\n+let map_pat_by (env : env) (tok : CST.pat_by) =\n+  (* pattern [bB][yY] *) token env tok\n+\n+let map_pat_above_or_below (env : env) (tok : CST.pat_above_or_below) =\n+  (* pattern [aA][bB][oO][vV][eE][__][oO][rR][__][bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_pat_last_quar (env : env) (tok : CST.pat_last_quar) =\n+  (* pattern [lL][aA][sS][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_from (env : env) (tok : CST.pat_from) =\n+  (* pattern [fF][rR][oO][mM] *) token env tok\n+\n+let map_pat_team (env : env) (tok : CST.pat_team) =\n+  (* pattern [tT][eE][aA][mM] *) token env tok\n+\n+let map_pat_and (env : env) (tok : CST.pat_and) =\n+  (* pattern [aA][nN][dD] *) token env tok\n+\n+let map_pat_phone (env : env) (tok : CST.pat_phone) =\n+  (* pattern [pP][hH][oO][nN][eE] *) token env tok\n+\n+let map_pat_this (env : env) (tok : CST.pat_this) =\n+  (* pattern [tT][hH][iI][sS] *) token env tok\n+\n+let map_pat_week_in_month (env : env) (tok : CST.pat_week_in_month) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_next_week (env : env) (tok : CST.pat_next_week) =\n+  (* pattern [nN][eE][xX][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_having (env : env) (tok : CST.pat_having) =\n+  (* pattern [hH][aA][vV][iI][nN][gG] *) token env tok\n+\n+let map_pat_next_quar (env : env) (tok : CST.pat_next_quar) =\n+  (* pattern [nN][eE][xX][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_fiscal_quar (env : env) (tok : CST.pat_next_fiscal_quar) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_asc (env : env) (tok : CST.pat_asc) =\n+  (* pattern [aA][sS][cC] *) token env tok\n+\n+let map_pat_null (env : env) (tok : CST.pat_null) =\n+  (* pattern [nN][uU][lL][lL] *) token env tok\n+\n+let map_pat_global (env : env) (tok : CST.pat_global) =\n+  (* pattern [gG][lL][oO][bB][aA][lL] *) token env tok\n+\n+let map_pat_max (env : env) (tok : CST.pat_max) =\n+  (* pattern [mM][aA][xX] *) token env tok\n+\n+let map_pat_all (env : env) (tok : CST.pat_all) =\n+  (* pattern [aA][lL][lL] *) token env tok\n+\n+let map_pat_reco (env : env) (tok : CST.pat_reco) =\n+  (* pattern [rR][eE][cC][oO][rR][dD][vV][iI][sS][iI][bB][iI][lL][iI][tT][yY][cC][oO][nN][tT][eE][xX][tT] *) token env tok\n+\n+let map_pat_cont (env : env) (tok : CST.pat_cont) =\n+  (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *) token env tok\n+\n+let map_pat_get (env : env) (tok : CST.pat_get) =\n+  (* pattern [gG][eE][tT] *) token env tok\n+\n+let map_pat_select (env : env) (tok : CST.pat_select) =\n+  (* pattern [sS][eE][lL][eE][cC][tT] *) token env tok\n+\n+let map_pat_conv (env : env) (tok : CST.pat_conv) =\n+  (* pattern [cC][oO][nN][vV][eE][rR][tT][cC][uU][rR][rR][eE][nN][cC][yY] *) token env tok\n+\n+let map_pat_inhe (env : env) (tok : CST.pat_inhe) =\n+  (* pattern [iI][nN][hH][eE][rR][iI][tT][eE][dD] *) token env tok\n+\n+let map_pat_maxd (env : env) (tok : CST.pat_maxd) =\n+  (* pattern [mM][aA][xX][dD][eE][sS][cC][rR][iI][pP][tT][oO][rR][pP][eE][rR][rR][eE][cC][oO][rR][dD] *) token env tok\n+\n+let map_pat_name (env : env) (tok : CST.pat_name) =\n+  (* pattern [nN][aA][mM][eE] *) token env tok\n+\n+let map_pat_catch (env : env) (tok : CST.pat_catch) =\n+  (* pattern [cC][aA][tT][cC][hH] *) token env tok\n+\n+let map_semgrep_metavar (env : env) (tok : CST.semgrep_metavar) =\n+  (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_retu (env : env) (tok : CST.pat_retu) =\n+  (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *) token env tok\n+\n+let map_pat_system_mode (env : env) (tok : CST.pat_system_mode) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_using (env : env) (tok : CST.pat_using) =\n+  (* pattern [uU][sS][iI][nN][gG] *) token env tok\n+\n+let map_pat_class (env : env) (tok : CST.pat_class) =\n+  (* pattern [cC][lL][aA][sS][sS] *) token env tok\n+\n+let map_pat_e8c36c5 (env : env) (tok : CST.pat_e8c36c5) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][..][rR][uU][nN][aA][sS] *) token env tok\n+\n+let map_pat_exclus (env : env) (tok : CST.pat_exclus) =\n+  (* pattern [eE][xX][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_order (env : env) (tok : CST.pat_order) =\n+  (* pattern [oO][rR][dD][eE][rR] *) token env tok\n+\n+let map_pat_yest (env : env) (tok : CST.pat_yest) =\n+  (* pattern [yY][eE][sS][tT][eE][rR][dD][aA][yY] *) token env tok\n+\n+let map_pat_false (env : env) (tok : CST.pat_false) =\n+  (* pattern [fF][aA][lL][sS][eE] *) token env tok\n+\n+let map_pat_grou (env : env) (tok : CST.pat_grou) =\n+  (* pattern [gG][rR][oO][uU][pP][iI][nN][gG] *) token env tok\n+\n+let map_pat_enum (env : env) (tok : CST.pat_enum) =\n+  (* pattern [eE][nN][uU][mM] *) token env tok\n+\n+let map_pat_new (env : env) (tok : CST.pat_new) =\n+  (* pattern [nN][eE][wW] *) token env tok\n+\n+let map_pat_this_fiscal_year (env : env) (tok : CST.pat_this_fiscal_year) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_group (env : env) (tok : CST.pat_group) =\n+  (* pattern [gG][rR][oO][uU][pP] *) token env tok\n+\n+let map_int_ (env : env) (tok : CST.int_) =\n+  (* int *) token env tok\n+\n+let map_pat_with_ (env : env) (tok : CST.pat_with_) =\n+  (* pattern [wW][iI][tT][hH][oO][uU][tT] *) token env tok\n+\n+let map_pat_secu_enfo (env : env) (tok : CST.pat_secu_enfo) =\n+  (* pattern [sS][eE][cC][uU][rR][iI][tT][yY][__][eE][nN][fF][oO][rR][cC][eE][dD] *) token env tok\n+\n+let map_pat_brk (env : env) (tok : CST.pat_brk) =\n+  (* pattern [bB][rR][eE][aA][kK] *) token env tok\n+\n+let map_pat_day_in_year (env : env) (tok : CST.pat_day_in_year) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_line_comment (env : env) (tok : CST.line_comment) =\n+  (* line_comment *) token env tok\n+\n+let map_pat_delete (env : env) (tok : CST.pat_delete) =\n+  (* pattern [dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+(* OLD QUERY *)\n+let map_value_comparison_operator (env : env) (x : CST.value_comparison_operator) =\n+  (match x with\n+  | `EQ tok -> R.Case (\"EQ\",\n+      (* \"=\" *) token env tok\n+    )\n+  | `BANGEQ tok -> R.Case (\"BANGEQ\",\n+      (* \"!=\" *) token env tok\n+    )\n+  | `LTGT tok -> R.Case (\"LTGT\",\n+      (* \"<>\" *) token env tok\n+    )\n+  | `LT tok -> R.Case (\"LT\",\n+      (* \"<\" *) token env tok\n+    )\n+  | `LTEQ tok -> R.Case (\"LTEQ\",\n+      (* \"<=\" *) token env tok\n+    )\n+  | `GT tok -> R.Case (\"GT\",\n+      (* \">\" *) token env tok\n+    )\n+  | `GTEQ tok -> R.Case (\"GTEQ\",\n+      (* \">=\" *) token env tok\n+    )\n+  | `Pat_like x -> R.Case (\"Pat_like\",\n+      map_pat_like env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let value_comparison_operator (env : env) (x : CST.value_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `EQ tok ->\n+      let t = (* \"=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Eq, t) |> G.e\n+  | `BANGEQ tok ->\n+      let t = (* \"!=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LTGT tok ->\n+      let t = (* \"<>\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LT tok ->\n+      let t = (* \"<\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Lt, t) |> G.e\n+  | `LTEQ tok ->\n+      let t = (* \"<=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.LtE, t) |> G.e\n+  | `GT tok ->\n+      let t = (* \">\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Gt, t) |> G.e\n+  | `GTEQ tok ->\n+      let t = (* \">=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.GtE, t) |> G.e\n+  | `Pat_like x ->\n+      let v = (* \"like\" *) str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_highlight (env : env) (x : CST.with_highlight) =\n+  map_pat_high env x\n+\n+let with_highlight (env : env) (x : CST.with_highlight) : G.ident =\n+  (* \"hightlight\" *) str env x\n+\n+(* OLD *)\n+let map_super (env : env) (x : CST.super) =\n+  map_pat_super env x\n+\n+(* NEW *)\n+let super (env : env) (x : CST.super) : G.expr =\n+  let t = (* \"super\" *) token_ env x in\n+  G.IdSpecial (G.Super, t) |> G.e\n+\n+(* AUX*)\n+let super_to_field_name (env : env) (x : CST.super) : G.field_name =\n+  let i = (* \"super\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* AUX *)\n+let this_to_field_name (env : env) (x : CST.this) : G.field_name =\n+  let i = (* \"this\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* OLD QUERY *)\n+let map_order_null_direciton (env : env) (x : CST.order_null_direciton) =\n+  (match x with\n+  | `Pat_nulls_pat_first (v1, v2) -> R.Case (\"Pat_nulls_pat_first\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_first env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_nulls_pat_last (v1, v2) -> R.Case (\"Pat_nulls_pat_last\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_last env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_null_direciton (env : env) (x : CST.order_null_direciton) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_nulls_pat_first (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"first\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+  | `Pat_nulls_pat_last (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"last\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+\n+let map_void_type (env : env) (x : CST.void_type) =\n+  map_pat_void env x\n+\n+(* OLD QUERY *)\n+let map_count_expression (env : env) ((v1, v2, v3) : CST.count_expression) =\n+  let v1 = map_pat_count env v1 in\n+  let v2 = (* \"(\" *) token env v2 in\n+  let v3 = (* \")\" *) token env v3 in\n+  R.Tuple [v1; v2; v3]\n+\n+(* RAW QUERY *)\n+let count_expression (env : env) ((v1, v2, v3) : CST.count_expression)\n+    : G.expr =\n+  let v1 = str env v1 in\n+  let v2 = (* \"(\" *) token_ env v2 in\n+  let v3 = (* \")\" *) token_ env v3 in\n+  G.Call (G.N (G.Id (v1, G.empty_id_info ())) |> G.e, (v2, [], v3)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_for_type (env : env) (x : CST.for_type) =\n+  (match x with\n+  | `Pat_update x -> R.Case (\"Pat_update\",\n+      map_pat_update env x\n+    )\n+  | `Pat_ref x -> R.Case (\"Pat_ref\",\n+      map_pat_ref env x\n+    )\n+  | `Pat_view x -> R.Case (\"Pat_view\",\n+      map_pat_view env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let for_type (env : env) (x : CST.for_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_update x\n+  | `Pat_ref x\n+  | `Pat_view x ->\n+      let v = str env x in\n+      R.Token v\n+\n+(* OLD QUERY *)\n+let map_update_type (env : env) (x : CST.update_type) =\n+  (match x with\n+  | `Pat_trac x -> R.Case (\"Pat_trac\",\n+      map_pat_trac env x\n+    )\n+  | `Pat_view_ x -> R.Case (\"Pat_view_\",\n+      map_pat_view_ env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let update_type (env : env) (x : CST.update_type) : G.expr =\n+  let v1 =\n+    match x with\n+    | `Pat_trac x\n+    | `Pat_view_ x ->\n+        str env x\n+  in\n+    G.L (G.String (fb v1)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) =\n+  (match x with\n+  | `Pat_at x -> R.Case (\"Pat_at\",\n+      map_pat_at env x\n+    )\n+  | `Pat_above x -> R.Case (\"Pat_above\",\n+      map_pat_above env x\n+    )\n+  | `Pat_below x -> R.Case (\"Pat_below\",\n+      map_pat_below env x\n+    )\n+  | `Pat_above_or_below x -> R.Case (\"Pat_above_or_below\",\n+      map_pat_above_or_below env x\n+    )\n+  )\n+\n+(* NEW QUERY *)\n+let with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_at x\n+  | `Pat_above x\n+  | `Pat_below x\n+  | `Pat_above_or_below x ->\n+      R.Token (str env x)\n+\n+(* OLD QUERY *)\n+let map_using_scope_type (env : env) (x : CST.using_scope_type) =\n+  (match x with\n+  | `Pat_dele x -> R.Case (\"Pat_dele\",\n+      map_pat_dele env x\n+    )\n+  | `Pat_ever x -> R.Case (\"Pat_ever\",\n+      map_pat_ever env x\n+    )\n+  | `Pat_mine x -> R.Case (\"Pat_mine\",\n+      map_pat_mine env x\n+    )\n+  | `Pat_mine_and_my_groups x -> R.Case (\"Pat_mine_and_my_groups\",\n+      map_pat_mine_and_my_groups env x\n+    )\n+  | `Pat_my_terr x -> R.Case (\"Pat_my_terr\",\n+      map_pat_my_terr env x\n+    )\n+  | `Pat_my_team_terr x -> R.Case (\"Pat_my_team_terr\",\n+      map_pat_my_team_terr env x\n+    )\n+  | `Pat_team x -> R.Case (\"Pat_team\",\n+      map_pat_team env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let using_scope_type (env : env) (x : CST.using_scope_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_dele x\n+  | `Pat_ever x\n+  | `Pat_mine x\n+  | `Pat_mine_and_my_groups x\n+  | `Pat_my_terr x\n+  | `Pat_my_team_terr x\n+  | `Pat_team x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_this (env : env) (x : CST.this) =\n+  map_pat_this env x\n+\n+(* NEW *)\n+let this (env : env) (x : CST.this) : G.expr =\n+  let t = token_ env x (* \"this\" *) in\n+  IdSpecial (This, t) |> G.e\n+\n+(* OLD QUERY *)\n+let map_order_direction (env : env) (x : CST.order_direction) =\n+  (match x with\n+  | `Pat_asc x -> R.Case (\"Pat_asc\",\n+      map_pat_asc env x\n+    )\n+  | `Pat_desc x -> R.Case (\"Pat_desc\",\n+      map_pat_desc env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_direction (env : env) (x : CST.order_direction) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_asc x\n+  | `Pat_desc x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_null_literal (env : env) (x : CST.null_literal) =\n+  map_pat_null env x\n+\n+(* NEW *)\n+let null_literal (env : env) (x : CST.null_literal) : literal =\n+  G.Null (token_ env x)\n+\n+(* OLD QUERY *)\n+let map_all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) =\n+  let v1 = map_pat_all env v1 in\n+  let v2 = map_pat_rows env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* RAW QUERY *)\n+let all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) : raw =\n+  let module R = Raw_tree in\n+  let v1 = (* \"all\" *) str env v1 in\n+  let v2 = (* \"rows\" *) str env v2 in\n+  R.Tuple [R.Token v1; R.Token v2]\n+\n+(* OLD QUERY *)\n+let map_fields_type (env : env) (x : CST.fields_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_custom x -> R.Case (\"Pat_custom\",\n+      map_pat_custom env x\n+    )\n+  | `Pat_stan x -> R.Case (\"Pat_stan\",\n+      map_pat_stan env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let fields_type (env : env) (x : CST.fields_type) : G.ident =\n+  match x with\n+  | `Pat_all x\n+  | `Pat_custom x\n+  | `Pat_stan x ->\n+      str env x\n+\n+(* OLD QUERY *)\n+let map_in_type (env : env) (x : CST.in_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_email x -> R.Case (\"Pat_email\",\n+      map_pat_email env x\n+    )\n+  | `Pat_name x -> R.Case (\"Pat_name\",\n+      map_pat_name env x\n+    )\n+  | `Pat_phone x -> R.Case (\"Pat_phone\",\n+      map_pat_phone env x\n+    )\n+  | `Pat_side x -> R.Case (\"Pat_side\",\n+      map_pat_side env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let in_type (env : env) (x : CST.in_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_all x\n+  | `Pat_email x\n+  | `Pat_name x\n+  | `Pat_phone x\n+  | `Pat_side x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_identifier (env : env) (x : CST.identifier) =\n+  (match x with\n+  | `Semg_meta tok -> R.Case (\"Semg_meta\",\n+      (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+    )\n+  | `Apex_id_ tok -> R.Case (\"Apex_id_\",\n+      (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+    )\n+  )\n+\n+(* NEW *)\n+let identifier (env : env) (x : CST.identifier) : G.ident =\n+  match x with\n+  | `Semg_meta tok (* pattern \\$[A-Z_][A-Z_0-9]* *) ->\n+      str env tok\n+  | `Apex_id_ tok (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) ->\n+      str env tok\n+\n+(* AUX *)\n+let identifier_to_expression (env : env) (x : CST.identifier) : G.expr =\n+  G.N (H2.name_of_id (identifier env x)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_set_comparison_operator (env : env) (x : CST.set_comparison_operator) =\n+  (match x with\n+  | `Pat_in x -> R.Case (\"Pat_in\",\n+      map_pat_in env x\n+    )\n+  | `Pat_not_pat_in (v1, v2) -> R.Case (\"Pat_not_pat_in\",\n+      let v1 = map_pat_not env v1 in\n+      let v2 = map_pat_in env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_inclus x -> R.Case (\"Pat_inclus\",\n+      map_pat_inclus env x\n+    )\n+  | `Pat_exclus x -> R.Case (\"Pat_exclus\",\n+      map_pat_exclus env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let set_comparison_operator (env : env) (x : CST.set_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_in x\n+  | `Pat_inclus x\n+  | `Pat_exclus x ->\n+      let v = str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+  | `Pat_not_pat_in (v1, v2) ->\n+      let v1 = str env v1 in\n+      let v2 = str env v2 in\n+      G.RawExpr (R.Tuple [R.Token v1; R.Token v2]) |> G.e\n+\n+(* OLD *)\n+let map_boolean (env : env) (x : CST.boolean) =\n+  (match x with\n+  | `Pat_true x -> R.Case (\"Pat_true\",\n+      map_pat_true env x\n+    )\n+  | `Pat_false x -> R.Case (\"Pat_false\",\n+      map_pat_false env x\n+    )\n+  )\n+\n+(* NEW *)\n+let boolean (env : env) (x : CST.boolean) : literal =\n+  match x with\n+  | `Pat_true tok -> G.Bool (true, token_ env tok)\n+  | `Pat_false tok -> G.Bool (false, token_ env tok)\n+\n+(* OLD QUERY *)\n+let map_date_literal (env : env) (x : CST.date_literal) =\n+  (match x with\n+  | `Pat_yest x -> R.Case (\"Pat_yest\",\n+      map_pat_yest env x\n+    )\n+  | `Pat_today x -> R.Case (\"Pat_today\",\n+      map_pat_today env x\n+    )\n+  | `Pat_tomo x -> R.Case (\"Pat_tomo\",\n+      map_pat_tomo env x\n+    )\n+  | `Pat_last_week x -> R.Case (\"Pat_last_week\",\n+      map_pat_last_week env x\n+    )\n+  | `Pat_this_week x -> R.Case (\"Pat_this_week\",\n+      map_pat_this_week env x\n+    )\n+  | `Pat_next_week x -> R.Case (\"Pat_next_week\",\n+      map_pat_next_week env x\n+    )\n+  | `Pat_last_month x -> R.Case (\"Pat_last_month\",\n+      map_pat_last_month env x\n+    )\n+  | `Pat_this_month x -> R.Case (\"Pat_this_month\",\n+      map_pat_this_month env x\n+    )\n+  | `Pat_next_month x -> R.Case (\"Pat_next_month\",\n+      map_pat_next_month env x\n+    )\n+  | `Pat_last_90_days x -> R.Case (\"Pat_last_90_days\",\n+      map_pat_last_90_days env x\n+    )\n+  | `Pat_next_90_days x -> R.Case (\"Pat_next_90_days\",\n+      map_pat_next_90_days env x\n+    )\n+  | `Pat_this_quar x -> R.Case (\"Pat_this_quar\",\n+      map_pat_this_quar env x\n+    )\n+  | `Pat_last_quar x -> R.Case (\"Pat_last_quar\",\n+      map_pat_last_quar env x\n+    )\n+  | `Pat_next_quar x -> R.Case (\"Pat_next_quar\",\n+      map_pat_next_quar env x\n+    )\n+  | `Pat_this_year x -> R.Case (\"Pat_this_year\",\n+      map_pat_this_year env x\n+    )\n+  | `Pat_last_year x -> R.Case (\"Pat_last_year\",\n+      map_pat_last_year env x\n+    )\n+  | `Pat_next_year x -> R.Case (\"Pat_next_year\",\n+      map_pat_next_year env x\n+    )\n+  | `Pat_this_fiscal_quar x -> R.Case (\"Pat_this_fiscal_quar\",\n+      map_pat_this_fiscal_quar env x\n+    )\n+  | `Pat_last_fiscal_quar x -> R.Case (\"Pat_last_fiscal_quar\",\n+      map_pat_last_fiscal_quar env x\n+    )\n+  | `Pat_next_fiscal_quar x -> R.Case (\"Pat_next_fiscal_quar\",\n+      map_pat_next_fiscal_quar env x\n+    )\n+  | `Pat_this_fiscal_year x -> R.Case (\"Pat_this_fiscal_year\",\n+      map_pat_this_fiscal_year env x\n+    )\n+  | `Pat_last_fiscal_year x -> R.Case (\"Pat_last_fiscal_year\",\n+      map_pat_last_fiscal_year env x\n+    )\n+  | `Pat_next_fiscal_year x -> R.Case (\"Pat_next_fiscal_year\",\n+      map_pat_next_fiscal_year env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let date_literal (env : env) (x : CST.date_literal) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_yest x\n+  | `Pat_today x\n+  | `Pat_tomo x\n+  | `Pat_last_week x\n+  | `Pat_this_week x\n+  | `Pat_next_week x\n+  | `Pat_last_month x\n+  | `Pat_this_month x\n+  | `Pat_next_month x\n+  | `Pat_last_90_days x\n+  | `Pat_next_90_days x\n+  | `Pat_this_quar x\n+  | `Pat_last_quar x\n+  | `Pat_next_quar x\n+  | `Pat_this_year x\n+  | `Pat_last_year x\n+  | `Pat_next_year x\n+  | `Pat_this_fiscal_quar x\n+  | `Pat_last_fiscal_quar x\n+  | `Pat_next_fiscal_quar x\n+  | `Pat_this_fiscal_year x\n+  | `Pat_last_fiscal_year x\n+  | `Pat_next_fiscal_year x ->\n+      let v = str env x in\n+      R.Token v",
        "comment_created_at": "2025-07-08T20:39:46+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "I understand now there is probably a good reason.",
        "pr_file_module": null
      },
      {
        "comment_id": "2193408071",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 337,
        "pr_file": "languages/apex/generic/Parse_apex_tree_sitter.ml",
        "discussion_id": "2193382256",
        "commented_code": "@@ -0,0 +1,7343 @@\n+(**\n+   Boilerplate to be used as a template when mapping the apex CST\n+   to another type of tree.\n+*)\n+\n+(*  open Common *)\n+(*  open Either_ *)\n+open Fpath_.Operators\n+module H = Parse_tree_sitter_helpers\n+open AST_generic\n+module G = AST_generic\n+module H2 = AST_generic_helpers\n+module CST = Tree_sitter_apex.CST\n+\n+module R = Tree_sitter_run.Raw_tree\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27-32\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type env = unit H.env\n+type raw = G.raw_tree\n+\n+let token_ = H.token\n+let str = H.str\n+let fb = Tok.unsafe_fake_bracket\n+\n+let token (env : env) (tok : Tree_sitter_run.Token.t) =\n+  R.Token tok\n+\n+let blank (env : env) () =\n+  R.Tuple []\n+\n+let map_pat_snip (env : env) (tok : CST.pat_snip) =\n+  (* pattern [sS][nN][iI][pP][pP][eE][tT] *) token env tok\n+\n+let map_pat_data (env : env) (tok : CST.pat_data) =\n+  (* pattern [dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_first (env : env) (tok : CST.pat_first) =\n+  (* pattern [fF][iI][rR][sS][tT] *) token env tok\n+\n+let map_pat_suppos (env : env) (tok : CST.pat_suppos) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][oO][mM][aA][iI][nN][sS] *) token env tok\n+\n+let map_pat_view (env : env) (tok : CST.pat_view) =\n+  (* pattern [vV][iI][eE][wW] *) token env tok\n+\n+let map_pat_find (env : env) (tok : CST.pat_find) =\n+  (* pattern [fF][iI][nN][dD] *) token env tok\n+\n+let map_pat_suppos_ (env : env) (tok : CST.pat_suppos_) =\n+  (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][eE][lL][eE][gG][aA][tT][eE][sS] *) token env tok\n+\n+let map_pat_final (env : env) (tok : CST.pat_final) =\n+  (* pattern [fF][iI][nN][aA][lL] *) token env tok\n+\n+let map_pat_my_team_terr (env : env) (tok : CST.pat_my_team_terr) =\n+  (* pattern [mM][yY][__][tT][eE][aA][mM][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_currency_literal (env : env) (tok : CST.currency_literal) =\n+  (* pattern \\w{3}\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_virt (env : env) (tok : CST.pat_virt) =\n+  (* pattern [vV][iI][rR][tT][uU][aA][lL] *) token env tok\n+\n+let map_pat_shar (env : env) (tok : CST.pat_shar) =\n+  (* pattern [sS][hH][aA][rR][iI][nN][gG] *) token env tok\n+\n+let map_pat_in (env : env) (tok : CST.pat_in) =\n+  (* pattern [iI][nN] *) token env tok\n+\n+let map_pat_meta (env : env) (tok : CST.pat_meta) =\n+  (* pattern [mM][eE][tT][aA][dD][aA][tT][aA] *) token env tok\n+\n+let map_pat_user_mode (env : env) (tok : CST.pat_user_mode) =\n+  (* pattern [uU][sS][eE][rR][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_prot (env : env) (tok : CST.pat_prot) =\n+  (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *) token env tok\n+\n+let map_pat_next_fiscal_year (env : env) (tok : CST.pat_next_fiscal_year) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_tola (env : env) (tok : CST.pat_tola) =\n+  (* pattern [tT][oO][lL][aA][bB][eE][lL] *) token env tok\n+\n+let map_block_comment_explicit (env : env) (() : CST.block_comment_explicit) =\n+  R.Tuple []\n+\n+let map_pat_offset (env : env) (tok : CST.pat_offset) =\n+  (* pattern [oO][fF][fF][sS][eE][tT] *) token env tok\n+\n+let map_pat_today (env : env) (tok : CST.pat_today) =\n+  (* pattern [tT][oO][dD][aA][yY] *) token env tok\n+\n+let map_semgrep_metavar_ellipsis (env : env) (tok : CST.semgrep_metavar_ellipsis) =\n+  (* pattern \\$\\.\\.\\.[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_then (env : env) (tok : CST.pat_then) =\n+  (* pattern [tT][hH][eE][nN] *) token env tok\n+\n+let map_pat_above (env : env) (tok : CST.pat_above) =\n+  (* pattern [aA][bB][oO][vV][eE] *) token env tok\n+\n+let map_pat_insert (env : env) (tok : CST.pat_insert) =\n+  (* pattern [iI][nN][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_merge (env : env) (tok : CST.pat_merge) =\n+  (* pattern [mM][eE][rR][gG][eE] *) token env tok\n+\n+let map_pat_count_dist (env : env) (tok : CST.pat_count_dist) =\n+  (* pattern [cC][oO][uU][nN][tT][__][dD][iI][sS][tT][iI][nN][cC][tT] *) token env tok\n+\n+let map_pat_nulls (env : env) (tok : CST.pat_nulls) =\n+  (* pattern [nN][uU][lL][lL][sS] *) token env tok\n+\n+let map_date (env : env) (tok : CST.date) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1]) *) token env tok\n+\n+let map_decimal_floating_point_literal (env : env) (tok : CST.decimal_floating_point_literal) =\n+  (* decimal_floating_point_literal *) token env tok\n+\n+let map_pat_last_month (env : env) (tok : CST.pat_last_month) =\n+  (* pattern [lL][aA][sS][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+(* OLD *)\n+let map_property_navigation (env : env) ((v1, v2) : CST.property_navigation) =\n+  let v1 =\n+    (match v1 with\n+    | Some tok -> R.Option (Some (\n+        (* \"?\" *) token env tok\n+      ))\n+    | None -> R.Option None)\n+  in\n+  let v2 = (* \".\" *) token env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* NEW *)\n+let property_navigation (env : env) ((v1, v2) : CST.property_navigation)\n+    : G.tok option * G.tok =\n+  let v1 = Option.map ((* \"?\" *) token_ env) v1 in\n+  let v2 = (* \".\" *) token_ env v2 in\n+  (v1, v2)\n+\n+let map_pat_cale_month (env : env) (tok : CST.pat_cale_month) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_unde (env : env) (tok : CST.pat_unde) =\n+  (* pattern [uU][nN][dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+let map_pat_inclus (env : env) (tok : CST.pat_inclus) =\n+  (* pattern [iI][nN][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_side (env : env) (tok : CST.pat_side) =\n+  (* pattern [sS][iI][dD][eE][bB][aA][rR] *) token env tok\n+\n+let map_pat_dele (env : env) (tok : CST.pat_dele) =\n+  (* pattern [dD][eE][lL][eE][gG][aA][tT][eE][dD] *) token env tok\n+\n+let map_pat_fields (env : env) (tok : CST.pat_fields) =\n+  (* pattern [fF][iI][eE][lL][dD][sS] *) token env tok\n+\n+let map_pat_fiscal_month (env : env) (tok : CST.pat_fiscal_month) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_when (env : env) (tok : CST.pat_when) =\n+  (* pattern [wW][hH][eE][nN] *) token env tok\n+\n+let map_pat_like (env : env) (tok : CST.pat_like) =\n+  (* pattern [lL][iI][kK][eE] *) token env tok\n+\n+let map_pat_avg (env : env) (tok : CST.pat_avg) =\n+  (* pattern [aA][vV][gG] *) token env tok\n+\n+let map_pat_scope (env : env) (tok : CST.pat_scope) =\n+  (* pattern [sS][cC][oO][pP][eE] *) token env tok\n+\n+let map_pat_sum (env : env) (tok : CST.pat_sum) =\n+  (* pattern [sS][uU][mM] *) token env tok\n+\n+let map_pat_target_len (env : env) (tok : CST.pat_target_len) =\n+  (* pattern [tT][aA][rR][gG][eE][tT][__][lL][eE][nN][gG][tT][hH] *) token env tok\n+\n+let map_pat_try (env : env) (tok : CST.pat_try) =\n+  (* pattern [tT][rR][yY] *) token env tok\n+\n+let map_pat_inst (env : env) (tok : CST.pat_inst) =\n+  (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *) token env tok\n+\n+let map_pat_mine (env : env) (tok : CST.pat_mine) =\n+  (* pattern [mM][iI][nN][eE] *) token env tok\n+\n+let map_date_time (env : env) (tok : CST.date_time) =\n+  (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:\\.\\d\\d?\\d?)?(?:Z|[+-][0-1]\\d:[0-5]\\d) *) token env tok\n+\n+let map_pat_while (env : env) (tok : CST.pat_while) =\n+  (* pattern [wW][hH][iI][lL][eE] *) token env tok\n+\n+let map_pat_ret (env : env) (tok : CST.pat_ret) =\n+  (* pattern [rR][eE][tT][uU][rR][nN] *) token env tok\n+\n+let map_pat_with (env : env) (tok : CST.pat_with) =\n+  (* pattern [wW][iI][tT][hH] *) token env tok\n+\n+let map_pat_where (env : env) (tok : CST.pat_where) =\n+  (* pattern [wW][hH][eE][rR][eE] *) token env tok\n+\n+let map_pat_this_month (env : env) (tok : CST.pat_this_month) =\n+  (* pattern [tT][hH][iI][sS][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_high (env : env) (tok : CST.pat_high) =\n+  (* pattern [hH][iI][gG][hH][lL][iI][gG][hH][tT] *) token env tok\n+\n+let map_pat_tran (env : env) (tok : CST.pat_tran) =\n+  (* pattern [tT][rR][aA][nN][sS][iI][eE][nN][tT] *) token env tok\n+\n+let map_pat_as (env : env) (tok : CST.pat_as) =\n+  (* pattern [aA][sS] *) token env tok\n+\n+let map_pat_next_90_days (env : env) (tok : CST.pat_next_90_days) =\n+  (* pattern [nN][eE][xX][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+let map_pat_super (env : env) (tok : CST.pat_super) =\n+  (* pattern [sS][uU][pP][eE][rR] *) token env tok\n+\n+let map_pat_on (env : env) (tok : CST.pat_on) =\n+  (* pattern [oO][nN] *) token env tok\n+\n+let map_pat_min (env : env) (tok : CST.pat_min) =\n+  (* pattern [mM][iI][nN] *) token env tok\n+\n+let map_pat_mine_and_my_groups (env : env) (tok : CST.pat_mine_and_my_groups) =\n+  (* pattern [mM][iI][nN][eE][__][aA][nN][dD][__][mM][yY][__][gG][rR][oO][uU][pP][sS] *) token env tok\n+\n+let map_pat_list (env : env) (tok : CST.pat_list) =\n+  (* pattern [lL][iI][sS][tT][vV][iI][eE][wW] *) token env tok\n+\n+let map_string_literal (env : env) (tok : CST.string_literal) =\n+  (* pattern \"'(\\\\\\\\[nNrRtTbBfFuU\\\"'_%\\\\\\\\]|[^\\\\\\\\'])*'\" *) token env tok\n+\n+let map_pat_not (env : env) (tok : CST.pat_not) =\n+  (* pattern [nN][oO][tT] *) token env tok\n+\n+let map_pat_test (env : env) (tok : CST.pat_test) =\n+  (* pattern [tT][eE][sS][tT][mM][eE][tT][hH][oO][dD] *) token env tok\n+\n+let map_pat_typeof (env : env) (tok : CST.pat_typeof) =\n+  (* pattern [tT][yY][pP][eE][oO][fF] *) token env tok\n+\n+let map_pat_desc (env : env) (tok : CST.pat_desc) =\n+  (* pattern [dD][eE][sS][cC] *) token env tok\n+\n+let map_pat_day_only (env : env) (tok : CST.pat_day_only) =\n+  (* pattern [dD][aA][yY][__][oO][nN][lL][yY] *) token env tok\n+\n+let map_pat_spell_corr (env : env) (tok : CST.pat_spell_corr) =\n+  (* pattern [sS][pP][eE][lL][lL][__][cC][oO][rR][rR][eE][cC][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_ref (env : env) (tok : CST.pat_ref) =\n+  (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE] *) token env tok\n+\n+let map_pat_public (env : env) (tok : CST.pat_public) =\n+  (* pattern [pP][uU][bB][lL][iI][cC] *) token env tok\n+\n+let map_pat_last (env : env) (tok : CST.pat_last) =\n+  (* pattern [lL][aA][sS][tT] *) token env tok\n+\n+let map_pat_upsert (env : env) (tok : CST.pat_upsert) =\n+  (* pattern [uU][pP][sS][eE][rR][tT] *) token env tok\n+\n+let map_pat_void (env : env) (tok : CST.pat_void) =\n+  (* pattern [vV][oO][iI][dD] *) token env tok\n+\n+let map_pat_netw (env : env) (tok : CST.pat_netw) =\n+  (* pattern [nN][eE][tT][wW][oO][rR][kK] *) token env tok\n+\n+let map_pat_below (env : env) (tok : CST.pat_below) =\n+  (* pattern [bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_line_comment_explicit (env : env) (() : CST.line_comment_explicit) =\n+  R.Tuple []\n+\n+let map_apex_identifier_ (env : env) (tok : CST.apex_identifier_) =\n+  (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+\n+let map_pat_imples (env : env) (tok : CST.pat_imples) =\n+  (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *) token env tok\n+\n+let map_pat_stan (env : env) (tok : CST.pat_stan) =\n+  (* pattern [sS][tT][aA][nN][dD][aA][rR][dD] *) token env tok\n+\n+let map_pat_or (env : env) (tok : CST.pat_or) =\n+  (* pattern [oO][rR] *) token env tok\n+\n+let map_pat_cate (env : env) (tok : CST.pat_cate) =\n+  (* pattern [cC][aA][tT][eE][gG][oO][rR][yY] *) token env tok\n+\n+let map_pat_before (env : env) (tok : CST.pat_before) =\n+  (* pattern [bB][eE][fF][oO][rR][eE] *) token env tok\n+\n+let map_pat_email (env : env) (tok : CST.pat_email) =\n+  (* pattern [eE][mM][aA][iI][lL] *) token env tok\n+\n+let map_pat_if (env : env) (tok : CST.pat_if) =\n+  (* pattern [iI][fF] *) token env tok\n+\n+let map_pat_rows (env : env) (tok : CST.pat_rows) =\n+  (* pattern [rR][oO][wW][sS] *) token env tok\n+\n+let map_pat_else (env : env) (tok : CST.pat_else) =\n+  (* pattern [eE][lL][sS][eE] *) token env tok\n+\n+let map_pat_week_in_year (env : env) (tok : CST.pat_week_in_year) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_limit (env : env) (tok : CST.pat_limit) =\n+  (* pattern [lL][iI][mM][iI][tT] *) token env tok\n+\n+let map_pat_next_month (env : env) (tok : CST.pat_next_month) =\n+  (* pattern [nN][eE][xX][tT][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_trac (env : env) (tok : CST.pat_trac) =\n+  (* pattern [tT][rR][aA][cC][kK][iI][nN][gG] *) token env tok\n+\n+let map_block_comment (env : env) (tok : CST.block_comment) =\n+  (* block_comment *) token env tok\n+\n+let map_pat_dist (env : env) (tok : CST.pat_dist) =\n+  (* pattern [dD][iI][sS][tT][aA][nN][cC][eE] *) token env tok\n+\n+let map_pat_rollup (env : env) (tok : CST.pat_rollup) =\n+  (* pattern [rR][oO][lL][lL][uU][pP] *) token env tok\n+\n+let map_pat_inte (env : env) (tok : CST.pat_inte) =\n+  (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *) token env tok\n+\n+let map_pat_set (env : env) (tok : CST.pat_set) =\n+  (* pattern [sS][eE][tT] *) token env tok\n+\n+let map_decimal (env : env) (tok : CST.decimal) =\n+  (* pattern -?\\d+(\\.\\d+)? *) token env tok\n+\n+let map_pat_last_fiscal_quar (env : env) (tok : CST.pat_last_fiscal_quar) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_for (env : env) (tok : CST.pat_for) =\n+  (* pattern [fF][oO][rR] *) token env tok\n+\n+let map_pat_pric (env : env) (tok : CST.pat_pric) =\n+  (* pattern [pP][rR][iI][cC][eE][bB][oO][oO][kK][iI][dD] *) token env tok\n+\n+let map_pat_last_fiscal_year (env : env) (tok : CST.pat_last_fiscal_year) =\n+  (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_this_quar (env : env) (tok : CST.pat_this_quar) =\n+  (* pattern [tT][hH][iI][sS][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_at (env : env) (tok : CST.pat_at) =\n+  (* pattern [aA][tT] *) token env tok\n+\n+let map_pat_static (env : env) (tok : CST.pat_static) =\n+  (* pattern [sS][tT][aA][tT][iI][cC] *) token env tok\n+\n+let map_pat_fiscal_quar (env : env) (tok : CST.pat_fiscal_quar) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_tomo (env : env) (tok : CST.pat_tomo) =\n+  (* pattern [tT][oO][mM][oO][rR][rR][oO][wW] *) token env tok\n+\n+let map_pat_geol (env : env) (tok : CST.pat_geol) =\n+  (* pattern [gG][eE][oO][lL][oO][cC][aA][tT][iI][oO][nN] *) token env tok\n+\n+let map_pat_day_in_week (env : env) (tok : CST.pat_day_in_week) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_last_week (env : env) (tok : CST.pat_last_week) =\n+  (* pattern [lL][aA][sS][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_divi (env : env) (tok : CST.pat_divi) =\n+  (* pattern [dD][iI][vV][iI][sS][iI][oO][nN] *) token env tok\n+\n+let map_pat_abst (env : env) (tok : CST.pat_abst) =\n+  (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *) token env tok\n+\n+let map_pat_custom (env : env) (tok : CST.pat_custom) =\n+  (* pattern [cC][uU][sS][tT][oO][mM] *) token env tok\n+\n+let map_pat_userid (env : env) (tok : CST.pat_userid) =\n+  (* pattern [uU][sS][eE][rR][iI][dD] *) token env tok\n+\n+let map_pat_over (env : env) (tok : CST.pat_over) =\n+  (* pattern [oO][vV][eE][rR][rR][iI][dD][eE] *) token env tok\n+\n+let map_pat_fina (env : env) (tok : CST.pat_fina) =\n+  (* pattern [fF][iI][nN][aA][lL][lL][yY] *) token env tok\n+\n+let map_pat_trig (env : env) (tok : CST.pat_trig) =\n+  (* pattern [tT][rR][iI][gG][gG][eE][rR] *) token env tok\n+\n+let map_pat_cale_quar (env : env) (tok : CST.pat_cale_quar) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_this_week (env : env) (tok : CST.pat_this_week) =\n+  (* pattern [tT][hH][iI][sS][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_throw (env : env) (tok : CST.pat_throw) =\n+  (* pattern [tT][hH][rR][oO][wW] *) token env tok\n+\n+let map_pat_ever (env : env) (tok : CST.pat_ever) =\n+  (* pattern [eE][vV][eE][rR][yY][tT][hH][iI][nN][gG] *) token env tok\n+\n+let map_pat_cube (env : env) (tok : CST.pat_cube) =\n+  (* pattern [cC][uU][bB][eE] *) token env tok\n+\n+let map_pat_hour_in_day (env : env) (tok : CST.pat_hour_in_day) =\n+  (* pattern [hH][oO][uU][rR][__][iI][nN][__][dD][aA][yY] *) token env tok\n+\n+let map_pat_day_in_month (env : env) (tok : CST.pat_day_in_month) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_last_90_days (env : env) (tok : CST.pat_last_90_days) =\n+  (* pattern [lL][aA][sS][tT][__][99][00][__][dD][aA][yY][sS] *) token env tok\n+\n+(* OLD *)\n+let map_dimensions (env : env) (xs : CST.dimensions) =\n+  R.List (List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token env v1 in\n+    let v2 = (* \"]\" *) token env v2 in\n+    R.Tuple [v1; v2]\n+  ) xs)\n+\n+(* NEW *)\n+let dimensions (env : env) (xs : CST.dimensions) : (G.tok * G.tok) list =\n+  List.map (fun (v1, v2) ->\n+    let v1 = (* \"[\" *) token_ env v1 in\n+    let v2 = (* \"]\" *) token_ env v2 in\n+    v1, v2)\n+    xs\n+\n+let map_pat_cale_year (env : env) (tok : CST.pat_cale_year) =\n+  (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_last_year (env : env) (tok : CST.pat_last_year) =\n+  (* pattern [lL][aA][sS][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_end (env : env) (tok : CST.pat_end) =\n+  (* pattern [eE][nN][dD] *) token env tok\n+\n+let map_pat_format (env : env) (tok : CST.pat_format) =\n+  (* pattern [fF][oO][rR][mM][aA][tT] *) token env tok\n+\n+let map_pat_switch (env : env) (tok : CST.pat_switch) =\n+  (* pattern [sS][wW][iI][tT][cC][hH] *) token env tok\n+\n+let map_pat_priv (env : env) (tok : CST.pat_priv) =\n+  (* pattern [pP][rR][iI][vV][aA][tT][eE] *) token env tok\n+\n+let map_pat_count (env : env) (tok : CST.pat_count) =\n+  (* pattern [cC][oO][uU][nN][tT] *) token env tok\n+\n+let map_pat_this_fiscal_quar (env : env) (tok : CST.pat_this_fiscal_quar) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_term (env : env) (tok : CST.term) =\n+  (* pattern \"(\\\\\\\\\\\\'|[^'])+\" *) token env tok\n+\n+let map_pat_after (env : env) (tok : CST.pat_after) =\n+  (* pattern [aA][fF][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_year (env : env) (tok : CST.pat_next_year) =\n+  (* pattern [nN][eE][xX][tT][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_extends (env : env) (tok : CST.pat_extends) =\n+  (* pattern [eE][xX][tT][eE][nN][dD][sS] *) token env tok\n+\n+let map_pat_update (env : env) (tok : CST.pat_update) =\n+  (* pattern [uU][pP][dD][aA][tT][eE] *) token env tok\n+\n+let map_pat_this_year (env : env) (tok : CST.pat_this_year) =\n+  (* pattern [tT][hH][iI][sS][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_view_ (env : env) (tok : CST.pat_view_) =\n+  (* pattern [vV][iI][eE][wW][sS][tT][aA][tT] *) token env tok\n+\n+let map_pat_fiscal_year (env : env) (tok : CST.pat_fiscal_year) =\n+  (* pattern [fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_my_terr (env : env) (tok : CST.pat_my_terr) =\n+  (* pattern [mM][yY][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *) token env tok\n+\n+let map_tok_choice_pat_last_n_days (env : env) (tok : CST.tok_choice_pat_last_n_days) =\n+  (* tok_choice_pat_last_n_days *) token env tok\n+\n+let map_pat_do (env : env) (tok : CST.pat_do) =\n+  (* pattern [dD][oO] *) token env tok\n+\n+let map_pat_true (env : env) (tok : CST.pat_true) =\n+  (* pattern [tT][rR][uU][eE] *) token env tok\n+\n+let map_pat_by (env : env) (tok : CST.pat_by) =\n+  (* pattern [bB][yY] *) token env tok\n+\n+let map_pat_above_or_below (env : env) (tok : CST.pat_above_or_below) =\n+  (* pattern [aA][bB][oO][vV][eE][__][oO][rR][__][bB][eE][lL][oO][wW] *) token env tok\n+\n+let map_pat_last_quar (env : env) (tok : CST.pat_last_quar) =\n+  (* pattern [lL][aA][sS][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_from (env : env) (tok : CST.pat_from) =\n+  (* pattern [fF][rR][oO][mM] *) token env tok\n+\n+let map_pat_team (env : env) (tok : CST.pat_team) =\n+  (* pattern [tT][eE][aA][mM] *) token env tok\n+\n+let map_pat_and (env : env) (tok : CST.pat_and) =\n+  (* pattern [aA][nN][dD] *) token env tok\n+\n+let map_pat_phone (env : env) (tok : CST.pat_phone) =\n+  (* pattern [pP][hH][oO][nN][eE] *) token env tok\n+\n+let map_pat_this (env : env) (tok : CST.pat_this) =\n+  (* pattern [tT][hH][iI][sS] *) token env tok\n+\n+let map_pat_week_in_month (env : env) (tok : CST.pat_week_in_month) =\n+  (* pattern [wW][eE][eE][kK][__][iI][nN][__][mM][oO][nN][tT][hH] *) token env tok\n+\n+let map_pat_next_week (env : env) (tok : CST.pat_next_week) =\n+  (* pattern [nN][eE][xX][tT][__][wW][eE][eE][kK] *) token env tok\n+\n+let map_pat_having (env : env) (tok : CST.pat_having) =\n+  (* pattern [hH][aA][vV][iI][nN][gG] *) token env tok\n+\n+let map_pat_next_quar (env : env) (tok : CST.pat_next_quar) =\n+  (* pattern [nN][eE][xX][tT][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_next_fiscal_quar (env : env) (tok : CST.pat_next_fiscal_quar) =\n+  (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *) token env tok\n+\n+let map_pat_asc (env : env) (tok : CST.pat_asc) =\n+  (* pattern [aA][sS][cC] *) token env tok\n+\n+let map_pat_null (env : env) (tok : CST.pat_null) =\n+  (* pattern [nN][uU][lL][lL] *) token env tok\n+\n+let map_pat_global (env : env) (tok : CST.pat_global) =\n+  (* pattern [gG][lL][oO][bB][aA][lL] *) token env tok\n+\n+let map_pat_max (env : env) (tok : CST.pat_max) =\n+  (* pattern [mM][aA][xX] *) token env tok\n+\n+let map_pat_all (env : env) (tok : CST.pat_all) =\n+  (* pattern [aA][lL][lL] *) token env tok\n+\n+let map_pat_reco (env : env) (tok : CST.pat_reco) =\n+  (* pattern [rR][eE][cC][oO][rR][dD][vV][iI][sS][iI][bB][iI][lL][iI][tT][yY][cC][oO][nN][tT][eE][xX][tT] *) token env tok\n+\n+let map_pat_cont (env : env) (tok : CST.pat_cont) =\n+  (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *) token env tok\n+\n+let map_pat_get (env : env) (tok : CST.pat_get) =\n+  (* pattern [gG][eE][tT] *) token env tok\n+\n+let map_pat_select (env : env) (tok : CST.pat_select) =\n+  (* pattern [sS][eE][lL][eE][cC][tT] *) token env tok\n+\n+let map_pat_conv (env : env) (tok : CST.pat_conv) =\n+  (* pattern [cC][oO][nN][vV][eE][rR][tT][cC][uU][rR][rR][eE][nN][cC][yY] *) token env tok\n+\n+let map_pat_inhe (env : env) (tok : CST.pat_inhe) =\n+  (* pattern [iI][nN][hH][eE][rR][iI][tT][eE][dD] *) token env tok\n+\n+let map_pat_maxd (env : env) (tok : CST.pat_maxd) =\n+  (* pattern [mM][aA][xX][dD][eE][sS][cC][rR][iI][pP][tT][oO][rR][pP][eE][rR][rR][eE][cC][oO][rR][dD] *) token env tok\n+\n+let map_pat_name (env : env) (tok : CST.pat_name) =\n+  (* pattern [nN][aA][mM][eE] *) token env tok\n+\n+let map_pat_catch (env : env) (tok : CST.pat_catch) =\n+  (* pattern [cC][aA][tT][cC][hH] *) token env tok\n+\n+let map_semgrep_metavar (env : env) (tok : CST.semgrep_metavar) =\n+  (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+\n+let map_pat_retu (env : env) (tok : CST.pat_retu) =\n+  (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *) token env tok\n+\n+let map_pat_system_mode (env : env) (tok : CST.pat_system_mode) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][__][mM][oO][dD][eE] *) token env tok\n+\n+let map_pat_using (env : env) (tok : CST.pat_using) =\n+  (* pattern [uU][sS][iI][nN][gG] *) token env tok\n+\n+let map_pat_class (env : env) (tok : CST.pat_class) =\n+  (* pattern [cC][lL][aA][sS][sS] *) token env tok\n+\n+let map_pat_e8c36c5 (env : env) (tok : CST.pat_e8c36c5) =\n+  (* pattern [sS][yY][sS][tT][eE][mM][..][rR][uU][nN][aA][sS] *) token env tok\n+\n+let map_pat_exclus (env : env) (tok : CST.pat_exclus) =\n+  (* pattern [eE][xX][cC][lL][uU][dD][eE][sS] *) token env tok\n+\n+let map_pat_order (env : env) (tok : CST.pat_order) =\n+  (* pattern [oO][rR][dD][eE][rR] *) token env tok\n+\n+let map_pat_yest (env : env) (tok : CST.pat_yest) =\n+  (* pattern [yY][eE][sS][tT][eE][rR][dD][aA][yY] *) token env tok\n+\n+let map_pat_false (env : env) (tok : CST.pat_false) =\n+  (* pattern [fF][aA][lL][sS][eE] *) token env tok\n+\n+let map_pat_grou (env : env) (tok : CST.pat_grou) =\n+  (* pattern [gG][rR][oO][uU][pP][iI][nN][gG] *) token env tok\n+\n+let map_pat_enum (env : env) (tok : CST.pat_enum) =\n+  (* pattern [eE][nN][uU][mM] *) token env tok\n+\n+let map_pat_new (env : env) (tok : CST.pat_new) =\n+  (* pattern [nN][eE][wW] *) token env tok\n+\n+let map_pat_this_fiscal_year (env : env) (tok : CST.pat_this_fiscal_year) =\n+  (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_pat_group (env : env) (tok : CST.pat_group) =\n+  (* pattern [gG][rR][oO][uU][pP] *) token env tok\n+\n+let map_int_ (env : env) (tok : CST.int_) =\n+  (* int *) token env tok\n+\n+let map_pat_with_ (env : env) (tok : CST.pat_with_) =\n+  (* pattern [wW][iI][tT][hH][oO][uU][tT] *) token env tok\n+\n+let map_pat_secu_enfo (env : env) (tok : CST.pat_secu_enfo) =\n+  (* pattern [sS][eE][cC][uU][rR][iI][tT][yY][__][eE][nN][fF][oO][rR][cC][eE][dD] *) token env tok\n+\n+let map_pat_brk (env : env) (tok : CST.pat_brk) =\n+  (* pattern [bB][rR][eE][aA][kK] *) token env tok\n+\n+let map_pat_day_in_year (env : env) (tok : CST.pat_day_in_year) =\n+  (* pattern [dD][aA][yY][__][iI][nN][__][yY][eE][aA][rR] *) token env tok\n+\n+let map_line_comment (env : env) (tok : CST.line_comment) =\n+  (* line_comment *) token env tok\n+\n+let map_pat_delete (env : env) (tok : CST.pat_delete) =\n+  (* pattern [dD][eE][lL][eE][tT][eE] *) token env tok\n+\n+(* OLD QUERY *)\n+let map_value_comparison_operator (env : env) (x : CST.value_comparison_operator) =\n+  (match x with\n+  | `EQ tok -> R.Case (\"EQ\",\n+      (* \"=\" *) token env tok\n+    )\n+  | `BANGEQ tok -> R.Case (\"BANGEQ\",\n+      (* \"!=\" *) token env tok\n+    )\n+  | `LTGT tok -> R.Case (\"LTGT\",\n+      (* \"<>\" *) token env tok\n+    )\n+  | `LT tok -> R.Case (\"LT\",\n+      (* \"<\" *) token env tok\n+    )\n+  | `LTEQ tok -> R.Case (\"LTEQ\",\n+      (* \"<=\" *) token env tok\n+    )\n+  | `GT tok -> R.Case (\"GT\",\n+      (* \">\" *) token env tok\n+    )\n+  | `GTEQ tok -> R.Case (\"GTEQ\",\n+      (* \">=\" *) token env tok\n+    )\n+  | `Pat_like x -> R.Case (\"Pat_like\",\n+      map_pat_like env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let value_comparison_operator (env : env) (x : CST.value_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `EQ tok ->\n+      let t = (* \"=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Eq, t) |> G.e\n+  | `BANGEQ tok ->\n+      let t = (* \"!=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LTGT tok ->\n+      let t = (* \"<>\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.NotEq, t) |> G.e\n+  | `LT tok ->\n+      let t = (* \"<\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Lt, t) |> G.e\n+  | `LTEQ tok ->\n+      let t = (* \"<=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.LtE, t) |> G.e\n+  | `GT tok ->\n+      let t = (* \">\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.Gt, t) |> G.e\n+  | `GTEQ tok ->\n+      let t = (* \">=\" *) token_ env tok in\n+      G.IdSpecial (G.Op G.GtE, t) |> G.e\n+  | `Pat_like x ->\n+      let v = (* \"like\" *) str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_highlight (env : env) (x : CST.with_highlight) =\n+  map_pat_high env x\n+\n+let with_highlight (env : env) (x : CST.with_highlight) : G.ident =\n+  (* \"hightlight\" *) str env x\n+\n+(* OLD *)\n+let map_super (env : env) (x : CST.super) =\n+  map_pat_super env x\n+\n+(* NEW *)\n+let super (env : env) (x : CST.super) : G.expr =\n+  let t = (* \"super\" *) token_ env x in\n+  G.IdSpecial (G.Super, t) |> G.e\n+\n+(* AUX*)\n+let super_to_field_name (env : env) (x : CST.super) : G.field_name =\n+  let i = (* \"super\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* AUX *)\n+let this_to_field_name (env : env) (x : CST.this) : G.field_name =\n+  let i = (* \"this\" *) str env x in\n+  G.FN (H2.name_of_id i)\n+\n+(* OLD QUERY *)\n+let map_order_null_direciton (env : env) (x : CST.order_null_direciton) =\n+  (match x with\n+  | `Pat_nulls_pat_first (v1, v2) -> R.Case (\"Pat_nulls_pat_first\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_first env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_nulls_pat_last (v1, v2) -> R.Case (\"Pat_nulls_pat_last\",\n+      let v1 = map_pat_nulls env v1 in\n+      let v2 = map_pat_last env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_null_direciton (env : env) (x : CST.order_null_direciton) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_nulls_pat_first (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"first\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+  | `Pat_nulls_pat_last (v1, v2) ->\n+      let v1 = (* \"nulls\" *) str env v1 in\n+      let v2 = (* \"last\" *) str env v2 in\n+      R.Tuple [R.Token v1; R.Token v2]\n+\n+let map_void_type (env : env) (x : CST.void_type) =\n+  map_pat_void env x\n+\n+(* OLD QUERY *)\n+let map_count_expression (env : env) ((v1, v2, v3) : CST.count_expression) =\n+  let v1 = map_pat_count env v1 in\n+  let v2 = (* \"(\" *) token env v2 in\n+  let v3 = (* \")\" *) token env v3 in\n+  R.Tuple [v1; v2; v3]\n+\n+(* RAW QUERY *)\n+let count_expression (env : env) ((v1, v2, v3) : CST.count_expression)\n+    : G.expr =\n+  let v1 = str env v1 in\n+  let v2 = (* \"(\" *) token_ env v2 in\n+  let v3 = (* \")\" *) token_ env v3 in\n+  G.Call (G.N (G.Id (v1, G.empty_id_info ())) |> G.e, (v2, [], v3)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_for_type (env : env) (x : CST.for_type) =\n+  (match x with\n+  | `Pat_update x -> R.Case (\"Pat_update\",\n+      map_pat_update env x\n+    )\n+  | `Pat_ref x -> R.Case (\"Pat_ref\",\n+      map_pat_ref env x\n+    )\n+  | `Pat_view x -> R.Case (\"Pat_view\",\n+      map_pat_view env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let for_type (env : env) (x : CST.for_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_update x\n+  | `Pat_ref x\n+  | `Pat_view x ->\n+      let v = str env x in\n+      R.Token v\n+\n+(* OLD QUERY *)\n+let map_update_type (env : env) (x : CST.update_type) =\n+  (match x with\n+  | `Pat_trac x -> R.Case (\"Pat_trac\",\n+      map_pat_trac env x\n+    )\n+  | `Pat_view_ x -> R.Case (\"Pat_view_\",\n+      map_pat_view_ env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let update_type (env : env) (x : CST.update_type) : G.expr =\n+  let v1 =\n+    match x with\n+    | `Pat_trac x\n+    | `Pat_view_ x ->\n+        str env x\n+  in\n+    G.L (G.String (fb v1)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) =\n+  (match x with\n+  | `Pat_at x -> R.Case (\"Pat_at\",\n+      map_pat_at env x\n+    )\n+  | `Pat_above x -> R.Case (\"Pat_above\",\n+      map_pat_above env x\n+    )\n+  | `Pat_below x -> R.Case (\"Pat_below\",\n+      map_pat_below env x\n+    )\n+  | `Pat_above_or_below x -> R.Case (\"Pat_above_or_below\",\n+      map_pat_above_or_below env x\n+    )\n+  )\n+\n+(* NEW QUERY *)\n+let with_data_cat_filter_type (env : env) (x : CST.with_data_cat_filter_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_at x\n+  | `Pat_above x\n+  | `Pat_below x\n+  | `Pat_above_or_below x ->\n+      R.Token (str env x)\n+\n+(* OLD QUERY *)\n+let map_using_scope_type (env : env) (x : CST.using_scope_type) =\n+  (match x with\n+  | `Pat_dele x -> R.Case (\"Pat_dele\",\n+      map_pat_dele env x\n+    )\n+  | `Pat_ever x -> R.Case (\"Pat_ever\",\n+      map_pat_ever env x\n+    )\n+  | `Pat_mine x -> R.Case (\"Pat_mine\",\n+      map_pat_mine env x\n+    )\n+  | `Pat_mine_and_my_groups x -> R.Case (\"Pat_mine_and_my_groups\",\n+      map_pat_mine_and_my_groups env x\n+    )\n+  | `Pat_my_terr x -> R.Case (\"Pat_my_terr\",\n+      map_pat_my_terr env x\n+    )\n+  | `Pat_my_team_terr x -> R.Case (\"Pat_my_team_terr\",\n+      map_pat_my_team_terr env x\n+    )\n+  | `Pat_team x -> R.Case (\"Pat_team\",\n+      map_pat_team env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let using_scope_type (env : env) (x : CST.using_scope_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_dele x\n+  | `Pat_ever x\n+  | `Pat_mine x\n+  | `Pat_mine_and_my_groups x\n+  | `Pat_my_terr x\n+  | `Pat_my_team_terr x\n+  | `Pat_team x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_this (env : env) (x : CST.this) =\n+  map_pat_this env x\n+\n+(* NEW *)\n+let this (env : env) (x : CST.this) : G.expr =\n+  let t = token_ env x (* \"this\" *) in\n+  IdSpecial (This, t) |> G.e\n+\n+(* OLD QUERY *)\n+let map_order_direction (env : env) (x : CST.order_direction) =\n+  (match x with\n+  | `Pat_asc x -> R.Case (\"Pat_asc\",\n+      map_pat_asc env x\n+    )\n+  | `Pat_desc x -> R.Case (\"Pat_desc\",\n+      map_pat_desc env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let order_direction (env : env) (x : CST.order_direction) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_asc x\n+  | `Pat_desc x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_null_literal (env : env) (x : CST.null_literal) =\n+  map_pat_null env x\n+\n+(* NEW *)\n+let null_literal (env : env) (x : CST.null_literal) : literal =\n+  G.Null (token_ env x)\n+\n+(* OLD QUERY *)\n+let map_all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) =\n+  let v1 = map_pat_all env v1 in\n+  let v2 = map_pat_rows env v2 in\n+  R.Tuple [v1; v2]\n+\n+(* RAW QUERY *)\n+let all_rows_clause (env : env) ((v1, v2) : CST.all_rows_clause) : raw =\n+  let module R = Raw_tree in\n+  let v1 = (* \"all\" *) str env v1 in\n+  let v2 = (* \"rows\" *) str env v2 in\n+  R.Tuple [R.Token v1; R.Token v2]\n+\n+(* OLD QUERY *)\n+let map_fields_type (env : env) (x : CST.fields_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_custom x -> R.Case (\"Pat_custom\",\n+      map_pat_custom env x\n+    )\n+  | `Pat_stan x -> R.Case (\"Pat_stan\",\n+      map_pat_stan env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let fields_type (env : env) (x : CST.fields_type) : G.ident =\n+  match x with\n+  | `Pat_all x\n+  | `Pat_custom x\n+  | `Pat_stan x ->\n+      str env x\n+\n+(* OLD QUERY *)\n+let map_in_type (env : env) (x : CST.in_type) =\n+  (match x with\n+  | `Pat_all x -> R.Case (\"Pat_all\",\n+      map_pat_all env x\n+    )\n+  | `Pat_email x -> R.Case (\"Pat_email\",\n+      map_pat_email env x\n+    )\n+  | `Pat_name x -> R.Case (\"Pat_name\",\n+      map_pat_name env x\n+    )\n+  | `Pat_phone x -> R.Case (\"Pat_phone\",\n+      map_pat_phone env x\n+    )\n+  | `Pat_side x -> R.Case (\"Pat_side\",\n+      map_pat_side env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let in_type (env : env) (x : CST.in_type) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_all x\n+  | `Pat_email x\n+  | `Pat_name x\n+  | `Pat_phone x\n+  | `Pat_side x ->\n+      R.Token (str env x)\n+\n+(* OLD *)\n+let map_identifier (env : env) (x : CST.identifier) =\n+  (match x with\n+  | `Semg_meta tok -> R.Case (\"Semg_meta\",\n+      (* pattern \\$[A-Z_][A-Z_0-9]* *) token env tok\n+    )\n+  | `Apex_id_ tok -> R.Case (\"Apex_id_\",\n+      (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) token env tok\n+    )\n+  )\n+\n+(* NEW *)\n+let identifier (env : env) (x : CST.identifier) : G.ident =\n+  match x with\n+  | `Semg_meta tok (* pattern \\$[A-Z_][A-Z_0-9]* *) ->\n+      str env tok\n+  | `Apex_id_ tok (* pattern [\\p{L}_$][\\p{L}\\p{Nd}_$]* *) ->\n+      str env tok\n+\n+(* AUX *)\n+let identifier_to_expression (env : env) (x : CST.identifier) : G.expr =\n+  G.N (H2.name_of_id (identifier env x)) |> G.e\n+\n+(* OLD QUERY *)\n+let map_set_comparison_operator (env : env) (x : CST.set_comparison_operator) =\n+  (match x with\n+  | `Pat_in x -> R.Case (\"Pat_in\",\n+      map_pat_in env x\n+    )\n+  | `Pat_not_pat_in (v1, v2) -> R.Case (\"Pat_not_pat_in\",\n+      let v1 = map_pat_not env v1 in\n+      let v2 = map_pat_in env v2 in\n+      R.Tuple [v1; v2]\n+    )\n+  | `Pat_inclus x -> R.Case (\"Pat_inclus\",\n+      map_pat_inclus env x\n+    )\n+  | `Pat_exclus x -> R.Case (\"Pat_exclus\",\n+      map_pat_exclus env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let set_comparison_operator (env : env) (x : CST.set_comparison_operator) : G.expr =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_in x\n+  | `Pat_inclus x\n+  | `Pat_exclus x ->\n+      let v = str env x in\n+      G.RawExpr (R.Token v) |> G.e\n+  | `Pat_not_pat_in (v1, v2) ->\n+      let v1 = str env v1 in\n+      let v2 = str env v2 in\n+      G.RawExpr (R.Tuple [R.Token v1; R.Token v2]) |> G.e\n+\n+(* OLD *)\n+let map_boolean (env : env) (x : CST.boolean) =\n+  (match x with\n+  | `Pat_true x -> R.Case (\"Pat_true\",\n+      map_pat_true env x\n+    )\n+  | `Pat_false x -> R.Case (\"Pat_false\",\n+      map_pat_false env x\n+    )\n+  )\n+\n+(* NEW *)\n+let boolean (env : env) (x : CST.boolean) : literal =\n+  match x with\n+  | `Pat_true tok -> G.Bool (true, token_ env tok)\n+  | `Pat_false tok -> G.Bool (false, token_ env tok)\n+\n+(* OLD QUERY *)\n+let map_date_literal (env : env) (x : CST.date_literal) =\n+  (match x with\n+  | `Pat_yest x -> R.Case (\"Pat_yest\",\n+      map_pat_yest env x\n+    )\n+  | `Pat_today x -> R.Case (\"Pat_today\",\n+      map_pat_today env x\n+    )\n+  | `Pat_tomo x -> R.Case (\"Pat_tomo\",\n+      map_pat_tomo env x\n+    )\n+  | `Pat_last_week x -> R.Case (\"Pat_last_week\",\n+      map_pat_last_week env x\n+    )\n+  | `Pat_this_week x -> R.Case (\"Pat_this_week\",\n+      map_pat_this_week env x\n+    )\n+  | `Pat_next_week x -> R.Case (\"Pat_next_week\",\n+      map_pat_next_week env x\n+    )\n+  | `Pat_last_month x -> R.Case (\"Pat_last_month\",\n+      map_pat_last_month env x\n+    )\n+  | `Pat_this_month x -> R.Case (\"Pat_this_month\",\n+      map_pat_this_month env x\n+    )\n+  | `Pat_next_month x -> R.Case (\"Pat_next_month\",\n+      map_pat_next_month env x\n+    )\n+  | `Pat_last_90_days x -> R.Case (\"Pat_last_90_days\",\n+      map_pat_last_90_days env x\n+    )\n+  | `Pat_next_90_days x -> R.Case (\"Pat_next_90_days\",\n+      map_pat_next_90_days env x\n+    )\n+  | `Pat_this_quar x -> R.Case (\"Pat_this_quar\",\n+      map_pat_this_quar env x\n+    )\n+  | `Pat_last_quar x -> R.Case (\"Pat_last_quar\",\n+      map_pat_last_quar env x\n+    )\n+  | `Pat_next_quar x -> R.Case (\"Pat_next_quar\",\n+      map_pat_next_quar env x\n+    )\n+  | `Pat_this_year x -> R.Case (\"Pat_this_year\",\n+      map_pat_this_year env x\n+    )\n+  | `Pat_last_year x -> R.Case (\"Pat_last_year\",\n+      map_pat_last_year env x\n+    )\n+  | `Pat_next_year x -> R.Case (\"Pat_next_year\",\n+      map_pat_next_year env x\n+    )\n+  | `Pat_this_fiscal_quar x -> R.Case (\"Pat_this_fiscal_quar\",\n+      map_pat_this_fiscal_quar env x\n+    )\n+  | `Pat_last_fiscal_quar x -> R.Case (\"Pat_last_fiscal_quar\",\n+      map_pat_last_fiscal_quar env x\n+    )\n+  | `Pat_next_fiscal_quar x -> R.Case (\"Pat_next_fiscal_quar\",\n+      map_pat_next_fiscal_quar env x\n+    )\n+  | `Pat_this_fiscal_year x -> R.Case (\"Pat_this_fiscal_year\",\n+      map_pat_this_fiscal_year env x\n+    )\n+  | `Pat_last_fiscal_year x -> R.Case (\"Pat_last_fiscal_year\",\n+      map_pat_last_fiscal_year env x\n+    )\n+  | `Pat_next_fiscal_year x -> R.Case (\"Pat_next_fiscal_year\",\n+      map_pat_next_fiscal_year env x\n+    )\n+  )\n+\n+(* RAW QUERY *)\n+let date_literal (env : env) (x : CST.date_literal) : raw =\n+  let module R = Raw_tree in\n+  match x with\n+  | `Pat_yest x\n+  | `Pat_today x\n+  | `Pat_tomo x\n+  | `Pat_last_week x\n+  | `Pat_this_week x\n+  | `Pat_next_week x\n+  | `Pat_last_month x\n+  | `Pat_this_month x\n+  | `Pat_next_month x\n+  | `Pat_last_90_days x\n+  | `Pat_next_90_days x\n+  | `Pat_this_quar x\n+  | `Pat_last_quar x\n+  | `Pat_next_quar x\n+  | `Pat_this_year x\n+  | `Pat_last_year x\n+  | `Pat_next_year x\n+  | `Pat_this_fiscal_quar x\n+  | `Pat_last_fiscal_quar x\n+  | `Pat_next_fiscal_quar x\n+  | `Pat_this_fiscal_year x\n+  | `Pat_last_fiscal_year x\n+  | `Pat_next_fiscal_year x ->\n+      let v = str env x in\n+      R.Token v",
        "comment_created_at": "2025-07-08T20:41:52+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "Because they serve different purposes. `H.token` takes a CST token to `AST_generic.tok`, while `R.Token` is a constructor of raw tree. In particular `AST_generic.tok` by itself is not a proper expression or statement (some constructors in the generic syntax want tokens, usually as brackets, but some don't), but `R.Token` is a proper constructor of syntax (via `AST_generic.RawTree (R.Token ...) : expr_kind`).\r\n\r\n`H.token` is used to translate tokens from CST to AST generic's tokens. Not to get confused with the \"OLD\" functions, it is called `token_` (with underscore).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2029632531",
    "pr_number": 191,
    "pr_file": "languages/kotlin/generic/Parse_kotlin_tree_sitter.ml",
    "created_at": "2025-04-05T01:23:51+00:00",
    "commented_code": "and string_literal (env : env) (v1, v2, v3) : expr =\n   let l = token env v1 in\n   let r = token env v3 in\n-  match v2 with\n-  | [ `Interp (`DOLLAR_simple_id (v1, v2)) ] when in_pattern env ->\n-      (* This is something of the form \"$X\". This is interpreted as an interpolated\n-         string of a single identifier, but if this is the pattern,\n-         it's probably not what the person writing the rule meant.\n-         Instead, we interpret it as a string literal containing a metavariable,\n-         which allows the existing literal metavariable machinery to run.\n-\n-         This does not affect Semgrep's expressive power, because a string containing\n-         an interpolated identifier `X` can also be expressed in a Semgrep pattern via\n-         `\"{X}\"`.\n-      *)\n-      let s1, t1 = str env v1 (* \"$\" *) in\n-      let s2, t2 = simple_identifier env v2 in\n-      G.L (G.String (l, (s1 ^ s2, Tok.combine_toks l [ t1; t2; r ]), r)) |> G.e\n-  | _ ->\n-      let v2 =\n-        List_.map\n-          (fun x ->\n-            match x with\n-            | `Str_content tok ->\n-                (* string_content *)\n-                Either_.Left3 (str env tok)\n-            | `Interp x -> interpolation env x)\n-          v2\n-      in\n-      G.interpolated (l, v2, r)\n+  let v2 =\n+    List_.map\n+      (function\n+        | `Str_content tok ->\n+            Either_.Left3 (str env tok)\n+        | `Interp (`DOLLAR_simple_id (v1, v2)) when in_pattern env ->",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2029632531",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 191,
        "pr_file": "languages/kotlin/generic/Parse_kotlin_tree_sitter.ml",
        "discussion_id": "2029632531",
        "commented_code": "@@ -1932,33 +1932,19 @@ and statements (env : env) ((v1, v2, v3) : CST.statements) =\n and string_literal (env : env) (v1, v2, v3) : expr =\n   let l = token env v1 in\n   let r = token env v3 in\n-  match v2 with\n-  | [ `Interp (`DOLLAR_simple_id (v1, v2)) ] when in_pattern env ->\n-      (* This is something of the form \"$X\". This is interpreted as an interpolated\n-         string of a single identifier, but if this is the pattern,\n-         it's probably not what the person writing the rule meant.\n-         Instead, we interpret it as a string literal containing a metavariable,\n-         which allows the existing literal metavariable machinery to run.\n-\n-         This does not affect Semgrep's expressive power, because a string containing\n-         an interpolated identifier `X` can also be expressed in a Semgrep pattern via\n-         `\"{X}\"`.\n-      *)\n-      let s1, t1 = str env v1 (* \"$\" *) in\n-      let s2, t2 = simple_identifier env v2 in\n-      G.L (G.String (l, (s1 ^ s2, Tok.combine_toks l [ t1; t2; r ]), r)) |> G.e\n-  | _ ->\n-      let v2 =\n-        List_.map\n-          (fun x ->\n-            match x with\n-            | `Str_content tok ->\n-                (* string_content *)\n-                Either_.Left3 (str env tok)\n-            | `Interp x -> interpolation env x)\n-          v2\n-      in\n-      G.interpolated (l, v2, r)\n+  let v2 =\n+    List_.map\n+      (function\n+        | `Str_content tok ->\n+            Either_.Left3 (str env tok)\n+        | `Interp (`DOLLAR_simple_id (v1, v2)) when in_pattern env ->",
        "comment_created_at": "2025-04-05T01:23:51+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Why keep `when in_pattern env` here?\r\nIs this not how programs should be parsed?",
        "pr_file_module": null
      },
      {
        "comment_id": "2029898008",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 191,
        "pr_file": "languages/kotlin/generic/Parse_kotlin_tree_sitter.ml",
        "discussion_id": "2029632531",
        "commented_code": "@@ -1932,33 +1932,19 @@ and statements (env : env) ((v1, v2, v3) : CST.statements) =\n and string_literal (env : env) (v1, v2, v3) : expr =\n   let l = token env v1 in\n   let r = token env v3 in\n-  match v2 with\n-  | [ `Interp (`DOLLAR_simple_id (v1, v2)) ] when in_pattern env ->\n-      (* This is something of the form \"$X\". This is interpreted as an interpolated\n-         string of a single identifier, but if this is the pattern,\n-         it's probably not what the person writing the rule meant.\n-         Instead, we interpret it as a string literal containing a metavariable,\n-         which allows the existing literal metavariable machinery to run.\n-\n-         This does not affect Semgrep's expressive power, because a string containing\n-         an interpolated identifier `X` can also be expressed in a Semgrep pattern via\n-         `\"{X}\"`.\n-      *)\n-      let s1, t1 = str env v1 (* \"$\" *) in\n-      let s2, t2 = simple_identifier env v2 in\n-      G.L (G.String (l, (s1 ^ s2, Tok.combine_toks l [ t1; t2; r ]), r)) |> G.e\n-  | _ ->\n-      let v2 =\n-        List_.map\n-          (fun x ->\n-            match x with\n-            | `Str_content tok ->\n-                (* string_content *)\n-                Either_.Left3 (str env tok)\n-            | `Interp x -> interpolation env x)\n-          v2\n-      in\n-      G.interpolated (l, v2, r)\n+  let v2 =\n+    List_.map\n+      (function\n+        | `Str_content tok ->\n+            Either_.Left3 (str env tok)\n+        | `Interp (`DOLLAR_simple_id (v1, v2)) when in_pattern env ->",
        "comment_created_at": "2025-04-05T15:29:17+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "Indeed, inside interpolated strings we parse `$FOO` in patterns and in programs differently. In programs, they are the inner expressions in an interpolated string. In patterns, they are patterns that match string segments.\r\nThe context is that in every other language, `$FOO` in pattern matching an interpolated string means a string segment. For example, the pattern\r\n```\r\n$\"{...}$FOO{...}\"\r\n```\r\nin C# matches the following value\r\n```\r\n$\"{someVal}xyz{someVal}\"\r\n```\r\nwith `$FOO` matching `xyz`.\r\nIn Kotlin, we want the pattern\r\n```\r\n\"${...}$FOO${...}\"\r\n```\r\nto match the following value\r\n```\r\n\"${someVal}xyz${someVal}\"\r\n```\r\nwith $FOO matching, again, `xyz`.\r\nThis is the clash of syntax that is problematic here: `$FOO` in a pattern can be interpreted as a metavar matching a string segment (the convention used in every other language in opengrep) or a single-variable inner expression (as is the syntax of Kotlin). The choice proposed in this PR is that we arbitrarily say it is a string pattern, while if you want to match an inner expression, you need to add braces in the pattern (`${$FOO}`), which is semantically equivalent to `$FOO` in Kotlin and is not ambiguous.",
        "pr_file_module": null
      },
      {
        "comment_id": "2029990985",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 191,
        "pr_file": "languages/kotlin/generic/Parse_kotlin_tree_sitter.ml",
        "discussion_id": "2029632531",
        "commented_code": "@@ -1932,33 +1932,19 @@ and statements (env : env) ((v1, v2, v3) : CST.statements) =\n and string_literal (env : env) (v1, v2, v3) : expr =\n   let l = token env v1 in\n   let r = token env v3 in\n-  match v2 with\n-  | [ `Interp (`DOLLAR_simple_id (v1, v2)) ] when in_pattern env ->\n-      (* This is something of the form \"$X\". This is interpreted as an interpolated\n-         string of a single identifier, but if this is the pattern,\n-         it's probably not what the person writing the rule meant.\n-         Instead, we interpret it as a string literal containing a metavariable,\n-         which allows the existing literal metavariable machinery to run.\n-\n-         This does not affect Semgrep's expressive power, because a string containing\n-         an interpolated identifier `X` can also be expressed in a Semgrep pattern via\n-         `\"{X}\"`.\n-      *)\n-      let s1, t1 = str env v1 (* \"$\" *) in\n-      let s2, t2 = simple_identifier env v2 in\n-      G.L (G.String (l, (s1 ^ s2, Tok.combine_toks l [ t1; t2; r ]), r)) |> G.e\n-  | _ ->\n-      let v2 =\n-        List_.map\n-          (fun x ->\n-            match x with\n-            | `Str_content tok ->\n-                (* string_content *)\n-                Either_.Left3 (str env tok)\n-            | `Interp x -> interpolation env x)\n-          v2\n-      in\n-      G.interpolated (l, v2, r)\n+  let v2 =\n+    List_.map\n+      (function\n+        | `Str_content tok ->\n+            Either_.Left3 (str env tok)\n+        | `Interp (`DOLLAR_simple_id (v1, v2)) when in_pattern env ->",
        "comment_created_at": "2025-04-05T23:15:53+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Ok, got it!",
        "pr_file_module": null
      }
    ]
  }
]