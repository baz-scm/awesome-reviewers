[
  {
    "discussion_id": "2102217948",
    "pr_number": 267,
    "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
    "created_at": "2025-05-22T10:27:30+00:00",
    "commented_code": "* get something that Matches_report.pp_text_outputs can operate on\n      *)\n     let pms : Core_match.t list = match_results.matches in\n-    let core_matches : Out.core_match list =\n+    (* Process matches to set is_ignored flag based on nosem comments *)\n+    let processed_matches, _errors =\n       pms\n-      (* OK, because we don't need the postprocessing to report the matches. *)\n       |> List_.map Core_result.mk_processed_match\n+      |> Nosemgrep.produce_ignored ~config:conf.core_runner_conf.engine_config\n+    in\n+    (* Convert to core matches *)\n+    let core_matches : Out.core_match list =\n+      processed_matches\n       |> Result_.partition Core_json_output.match_to_match\n       |> fst |> Core_json_output.dedup_and_sort\n     in\n     let hrules = Rule.hrules_of_rules rules in\n     let fixed_env = Fixed_lines.mk_env () in\n-    core_matches\n+    let matches = core_matches\n     |> List_.map\n          (Cli_json_output.cli_match_of_core_match\n             ~fixed_lines:conf.output_conf.fixed_lines fixed_env hrules)\n-    |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    in\n+    (* Only filter out ignored matches if --enable-ignore is set *)\n+    if conf.enable_ignore then\n+      matches |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    else\n+      matches",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2102217948",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 267,
        "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
        "discussion_id": "2102217948",
        "commented_code": "@@ -229,20 +229,30 @@ let mk_file_match_hook (conf : Scan_CLI.conf) (rules : Rule.rules)\n      * get something that Matches_report.pp_text_outputs can operate on\n      *)\n     let pms : Core_match.t list = match_results.matches in\n-    let core_matches : Out.core_match list =\n+    (* Process matches to set is_ignored flag based on nosem comments *)\n+    let processed_matches, _errors =\n       pms\n-      (* OK, because we don't need the postprocessing to report the matches. *)\n       |> List_.map Core_result.mk_processed_match\n+      |> Nosemgrep.produce_ignored ~config:conf.core_runner_conf.engine_config\n+    in\n+    (* Convert to core matches *)\n+    let core_matches : Out.core_match list =\n+      processed_matches\n       |> Result_.partition Core_json_output.match_to_match\n       |> fst |> Core_json_output.dedup_and_sort\n     in\n     let hrules = Rule.hrules_of_rules rules in\n     let fixed_env = Fixed_lines.mk_env () in\n-    core_matches\n+    let matches = core_matches\n     |> List_.map\n          (Cli_json_output.cli_match_of_core_match\n             ~fixed_lines:conf.output_conf.fixed_lines fixed_env hrules)\n-    |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    in\n+    (* Only filter out ignored matches if --enable-ignore is set *)\n+    if conf.enable_ignore then\n+      matches |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    else\n+      matches",
        "comment_created_at": "2025-05-22T10:27:30+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "But from what I understood, what you require is to filter out matches also (in addition to normal operation) when printing incrementally. \r\n\r\nHere something completely different happens, no? \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2102390484",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 267,
        "pr_file": "src/osemgrep/cli_scan/Scan_subcommand.ml",
        "discussion_id": "2102217948",
        "commented_code": "@@ -229,20 +229,30 @@ let mk_file_match_hook (conf : Scan_CLI.conf) (rules : Rule.rules)\n      * get something that Matches_report.pp_text_outputs can operate on\n      *)\n     let pms : Core_match.t list = match_results.matches in\n-    let core_matches : Out.core_match list =\n+    (* Process matches to set is_ignored flag based on nosem comments *)\n+    let processed_matches, _errors =\n       pms\n-      (* OK, because we don't need the postprocessing to report the matches. *)\n       |> List_.map Core_result.mk_processed_match\n+      |> Nosemgrep.produce_ignored ~config:conf.core_runner_conf.engine_config\n+    in\n+    (* Convert to core matches *)\n+    let core_matches : Out.core_match list =\n+      processed_matches\n       |> Result_.partition Core_json_output.match_to_match\n       |> fst |> Core_json_output.dedup_and_sort\n     in\n     let hrules = Rule.hrules_of_rules rules in\n     let fixed_env = Fixed_lines.mk_env () in\n-    core_matches\n+    let matches = core_matches\n     |> List_.map\n          (Cli_json_output.cli_match_of_core_match\n             ~fixed_lines:conf.output_conf.fixed_lines fixed_env hrules)\n-    |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    in\n+    (* Only filter out ignored matches if --enable-ignore is set *)\n+    if conf.enable_ignore then\n+      matches |> List_.exclude (fun (m : Out.cli_match) -> m.extra.is_ignored ||| false)\n+    else\n+      matches",
        "comment_created_at": "2025-05-22T12:03:14+00:00",
        "comment_author": "tom-paz",
        "comment_body": "the ignore filtering logic in both regular and incremental output modes, depending on the flag. The filtering is handled in the file match hook, and the logic is shared and consistent for both output types.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2067133568",
    "pr_number": 238,
    "pr_file": "src/osemgrep/cli_test/Test_CLI.ml",
    "created_at": "2025-04-29T18:40:28+00:00",
    "commented_code": "| [ file ], [ config ] ->\n       if Sys.file_exists !!file && Sys.is_directory !!file then\n         Dir (file, Some config)\n-      else File (file, config)\n+      else Files ([file], config)\n   | [ file ], [] ->\n       if Sys.is_directory !!file then Dir (file, None)\n       else\n         (* was raise Exception but cleaner abort I think *)\n         Error.abort \"--config is required when running a test on single file\"\n-  | _ :: _ :: _, _ ->\n-      (* stricter: better error message '(directory or file)' *)\n-      Error.abort \"only one target (directory or file) allowed for tests\"\n+  | [], _ -> Error.abort \"bug: no valid target roots\"",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2067133568",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 238,
        "pr_file": "src/osemgrep/cli_test/Test_CLI.ml",
        "discussion_id": "2067133568",
        "commented_code": "@@ -128,19 +128,20 @@ let target_kind_of_roots_and_config target_roots config =\n   | [ file ], [ config ] ->\n       if Sys.file_exists !!file && Sys.is_directory !!file then\n         Dir (file, Some config)\n-      else File (file, config)\n+      else Files ([file], config)\n   | [ file ], [] ->\n       if Sys.is_directory !!file then Dir (file, None)\n       else\n         (* was raise Exception but cleaner abort I think *)\n         Error.abort \"--config is required when running a test on single file\"\n-  | _ :: _ :: _, _ ->\n-      (* stricter: better error message '(directory or file)' *)\n-      Error.abort \"only one target (directory or file) allowed for tests\"\n+  | [], _ -> Error.abort \"bug: no valid target roots\"",
        "comment_created_at": "2025-04-29T18:40:28+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "I would not say \"bug\" here as it's invalid input.",
        "pr_file_module": null
      },
      {
        "comment_id": "2067151851",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 238,
        "pr_file": "src/osemgrep/cli_test/Test_CLI.ml",
        "discussion_id": "2067133568",
        "commented_code": "@@ -128,19 +128,20 @@ let target_kind_of_roots_and_config target_roots config =\n   | [ file ], [ config ] ->\n       if Sys.file_exists !!file && Sys.is_directory !!file then\n         Dir (file, Some config)\n-      else File (file, config)\n+      else Files ([file], config)\n   | [ file ], [] ->\n       if Sys.is_directory !!file then Dir (file, None)\n       else\n         (* was raise Exception but cleaner abort I think *)\n         Error.abort \"--config is required when running a test on single file\"\n-  | _ :: _ :: _, _ ->\n-      (* stricter: better error message '(directory or file)' *)\n-      Error.abort \"only one target (directory or file) allowed for tests\"\n+  | [], _ -> Error.abort \"bug: no valid target roots\"",
        "comment_created_at": "2025-04-29T18:53:00+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "maybe \"at least one target required for tests\"",
        "pr_file_module": null
      },
      {
        "comment_id": "2068828538",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 238,
        "pr_file": "src/osemgrep/cli_test/Test_CLI.ml",
        "discussion_id": "2067133568",
        "commented_code": "@@ -128,19 +128,20 @@ let target_kind_of_roots_and_config target_roots config =\n   | [ file ], [ config ] ->\n       if Sys.file_exists !!file && Sys.is_directory !!file then\n         Dir (file, Some config)\n-      else File (file, config)\n+      else Files ([file], config)\n   | [ file ], [] ->\n       if Sys.is_directory !!file then Dir (file, None)\n       else\n         (* was raise Exception but cleaner abort I think *)\n         Error.abort \"--config is required when running a test on single file\"\n-  | _ :: _ :: _, _ ->\n-      (* stricter: better error message '(directory or file)' *)\n-      Error.abort \"only one target (directory or file) allowed for tests\"\n+  | [], _ -> Error.abort \"bug: no valid target roots\"",
        "comment_created_at": "2025-04-30T14:46:07+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "fixed according to your suggestion",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006058133",
    "pr_number": 169,
    "pr_file": "libs/ast_generic/Enclosure.ml",
    "created_at": "2025-03-20T16:45:16+00:00",
    "commented_code": "+module AST = AST_generic\n+\n+type delimiter_kind = Module | Class | Func\n+[@@deriving show, eq]\n+\n+(* delimiter_info values are included in Core_match.t, which is why we\n+ * don't include the relevant AST nodes here, not to block the GC from\n+ * cleaning up the AST of targets that have been already processed.\n+ *)\n+type delimiter_info = {\n+  kind : delimiter_kind;\n+  name : string;\n+  range : (Tok.location * Tok.location) option\n+}\n+[@@deriving show, eq]\n+\n+type t = delimiter_info list\n+[@@deriving show, eq]\n+\n+let human_readable_entity_name (name : AST.entity_name) : string =\n+  match name with\n+  | AST.EN (Id ((i, _tok), _)) -> i\n+  | AST.EN (IdQualified {name_last = ((i, _tok), _type_args); _}) -> i\n+  | _ -> failwith \"impossible\"",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "2006058133",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 169,
        "pr_file": "libs/ast_generic/Enclosure.ml",
        "discussion_id": "2006058133",
        "commented_code": "@@ -0,0 +1,51 @@\n+module AST = AST_generic\n+\n+type delimiter_kind = Module | Class | Func\n+[@@deriving show, eq]\n+\n+(* delimiter_info values are included in Core_match.t, which is why we\n+ * don't include the relevant AST nodes here, not to block the GC from\n+ * cleaning up the AST of targets that have been already processed.\n+ *)\n+type delimiter_info = {\n+  kind : delimiter_kind;\n+  name : string;\n+  range : (Tok.location * Tok.location) option\n+}\n+[@@deriving show, eq]\n+\n+type t = delimiter_info list\n+[@@deriving show, eq]\n+\n+let human_readable_entity_name (name : AST.entity_name) : string =\n+  match name with\n+  | AST.EN (Id ((i, _tok), _)) -> i\n+  | AST.EN (IdQualified {name_last = ((i, _tok), _type_args); _}) -> i\n+  | _ -> failwith \"impossible\"",
        "comment_created_at": "2025-03-20T16:45:16+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "maybe `assert false` if this really should not happen?",
        "pr_file_module": null
      },
      {
        "comment_id": "2006087170",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 169,
        "pr_file": "libs/ast_generic/Enclosure.ml",
        "discussion_id": "2006058133",
        "commented_code": "@@ -0,0 +1,51 @@\n+module AST = AST_generic\n+\n+type delimiter_kind = Module | Class | Func\n+[@@deriving show, eq]\n+\n+(* delimiter_info values are included in Core_match.t, which is why we\n+ * don't include the relevant AST nodes here, not to block the GC from\n+ * cleaning up the AST of targets that have been already processed.\n+ *)\n+type delimiter_info = {\n+  kind : delimiter_kind;\n+  name : string;\n+  range : (Tok.location * Tok.location) option\n+}\n+[@@deriving show, eq]\n+\n+type t = delimiter_info list\n+[@@deriving show, eq]\n+\n+let human_readable_entity_name (name : AST.entity_name) : string =\n+  match name with\n+  | AST.EN (Id ((i, _tok), _)) -> i\n+  | AST.EN (IdQualified {name_last = ((i, _tok), _type_args); _}) -> i\n+  | _ -> failwith \"impossible\"",
        "comment_created_at": "2025-03-20T17:00:21+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "Thanks, I wasn't sure what kind of \"impossible\" to use",
        "pr_file_module": null
      },
      {
        "comment_id": "2006522384",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 169,
        "pr_file": "libs/ast_generic/Enclosure.ml",
        "discussion_id": "2006058133",
        "commented_code": "@@ -0,0 +1,51 @@\n+module AST = AST_generic\n+\n+type delimiter_kind = Module | Class | Func\n+[@@deriving show, eq]\n+\n+(* delimiter_info values are included in Core_match.t, which is why we\n+ * don't include the relevant AST nodes here, not to block the GC from\n+ * cleaning up the AST of targets that have been already processed.\n+ *)\n+type delimiter_info = {\n+  kind : delimiter_kind;\n+  name : string;\n+  range : (Tok.location * Tok.location) option\n+}\n+[@@deriving show, eq]\n+\n+type t = delimiter_info list\n+[@@deriving show, eq]\n+\n+let human_readable_entity_name (name : AST.entity_name) : string =\n+  match name with\n+  | AST.EN (Id ((i, _tok), _)) -> i\n+  | AST.EN (IdQualified {name_last = ((i, _tok), _type_args); _}) -> i\n+  | _ -> failwith \"impossible\"",
        "comment_created_at": "2025-03-20T22:02:37+00:00",
        "comment_author": "maciejpirog",
        "comment_body": "Refactored to avoid this altogether",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1931401998",
    "pr_number": 48,
    "pr_file": "libs/commons/Uri_.ml",
    "created_at": "2025-01-28T01:27:14+00:00",
    "commented_code": "let of_string_opt (str : string) : Uri.t option =\n   let uri = Uri.of_string str in\n   if Uri.equal uri Uri.empty then None else Some uri\n+\n+\n+let url_regex = Pcre2_.regexp \"^https?://\"\n+let is_url config_path =\n+  match Pcre2_.pmatch ~rex:url_regex config_path with\n+  | Ok true -> true\n+  | Ok false -> false \n+  | Error err ->\n+      Log.warn (fun m -> m \"Error Validation URL: %a\" pp_error err);\n+      false",
    "repo_full_name": "opengrep/opengrep",
    "discussion_comments": [
      {
        "comment_id": "1931401998",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 48,
        "pr_file": "libs/commons/Uri_.ml",
        "discussion_id": "1931401998",
        "commented_code": "@@ -26,3 +26,13 @@\n let of_string_opt (str : string) : Uri.t option =\n   let uri = Uri.of_string str in\n   if Uri.equal uri Uri.empty then None else Some uri\n+\n+\n+let url_regex = Pcre2_.regexp \"^https?://\"\n+let is_url config_path =\n+  match Pcre2_.pmatch ~rex:url_regex config_path with\n+  | Ok true -> true\n+  | Ok false -> false \n+  | Error err ->\n+      Log.warn (fun m -> m \"Error Validation URL: %a\" pp_error err);\n+      false",
        "comment_created_at": "2025-01-28T01:27:14+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Here you can just have : \r\n\r\n```ocaml \r\n| Ok res -> res \r\n| Error err  -> (* your code *)\r\n```\r\n\r\nOr even better, just use:\r\n\r\n```ocaml\r\nPcre2_.pmatch_noerr\r\n```\r\n\r\nthat will do the logging for you, ie: \r\n\r\n```ocaml\r\nlet is_url config_path = Pcre2_.pmatch_noerr ~rex:url_regex config_pat\r\n```\r\n\r\n(no need for `match` in that case).",
        "pr_file_module": null
      },
      {
        "comment_id": "1931419631",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 48,
        "pr_file": "libs/commons/Uri_.ml",
        "discussion_id": "1931401998",
        "commented_code": "@@ -26,3 +26,13 @@\n let of_string_opt (str : string) : Uri.t option =\n   let uri = Uri.of_string str in\n   if Uri.equal uri Uri.empty then None else Some uri\n+\n+\n+let url_regex = Pcre2_.regexp \"^https?://\"\n+let is_url config_path =\n+  match Pcre2_.pmatch ~rex:url_regex config_path with\n+  | Ok true -> true\n+  | Ok false -> false \n+  | Error err ->\n+      Log.warn (fun m -> m \"Error Validation URL: %a\" pp_error err);\n+      false",
        "comment_created_at": "2025-01-28T01:55:52+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "In fact your version will probably not compile, but my proposed solution with `pmatch_noerr` will.",
        "pr_file_module": null
      },
      {
        "comment_id": "1931423108",
        "repo_full_name": "opengrep/opengrep",
        "pr_number": 48,
        "pr_file": "libs/commons/Uri_.ml",
        "discussion_id": "1931401998",
        "commented_code": "@@ -26,3 +26,13 @@\n let of_string_opt (str : string) : Uri.t option =\n   let uri = Uri.of_string str in\n   if Uri.equal uri Uri.empty then None else Some uri\n+\n+\n+let url_regex = Pcre2_.regexp \"^https?://\"\n+let is_url config_path =\n+  match Pcre2_.pmatch ~rex:url_regex config_path with\n+  | Ok true -> true\n+  | Ok false -> false \n+  | Error err ->\n+      Log.warn (fun m -> m \"Error Validation URL: %a\" pp_error err);\n+      false",
        "comment_created_at": "2025-01-28T02:02:29+00:00",
        "comment_author": "dimitris-m",
        "comment_body": "Notice that in `Pcre2_.ml`, line 27, we define: `module Log = (val Logs.src_log src : Logs.LOG)`.\r\n\r\nThis is used in the body of `pmatch_noerr` within `Pcre2_.ml`, but it's not visible in `Uri_.ml` which is why compilation failed.",
        "pr_file_module": null
      }
    ]
  }
]