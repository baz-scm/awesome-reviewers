[
  {
    "discussion_id": "2294794636",
    "pr_number": 36005,
    "pr_file": "selfdrive/controls/tests/test_torqued_straight_road_roll_bias.py",
    "created_at": "2025-08-22T21:37:27+00:00",
    "commented_code": "+import numpy as np\n+from cereal import car, messaging\n+from opendbc.car import ACCELERATION_DUE_TO_GRAVITY\n+from opendbc.car import structs\n+from opendbc.car.lateral import get_friction, FRICTION_THRESHOLD\n+from openpilot.selfdrive.locationd.torqued import TorqueEstimator, MIN_BUCKET_POINTS, STEER_BUCKET_BOUNDS, POINTS_PER_BUCKET\n+from openpilot.common.realtime import DT_MDL\n+np.random.seed(0)\n+\n+ROLL_BIAS_DEG = 1.0\n+V_EGO = 30.0\n+\n+# how much larger roll compensation is than it should be\n+roll_compensation_bias = ACCELERATION_DUE_TO_GRAVITY*float(np.sin(np.deg2rad(ROLL_BIAS_DEG)))\n+gt_torque_tune = structs.CarParams.LateralTorqueTuning(latAccelFactor=2.0, latAccelOffset=0.0, friction=0.2)\n+\n+def test_straight_road_roll_bias():\n+  steer_torques = np.concat([np.random.uniform(bound[0], bound[1], int(points))\n+                             for bound, points in zip(STEER_BUCKET_BOUNDS, 1.5*MIN_BUCKET_POINTS, strict=True)])\n+  la_errs = np.random.randn(steer_torques.size)\n+  frictions = np.array([get_friction(la_err, 0.0, FRICTION_THRESHOLD, gt_torque_tune) for la_err in la_errs])\n+  lat_accels = gt_torque_tune.latAccelFactor*steer_torques + frictions\n+  est = TorqueEstimator(car.CarParams())\n+  for steer_torque, lat_accel in zip(steer_torques, lat_accels, strict=True):\n+    est.filtered_points.add_point(steer_torque, lat_accel)\n+  for i in range(2*POINTS_PER_BUCKET):\n+    t = i*DT_MDL\n+    sgn = (-1)**(i < POINTS_PER_BUCKET)\n+    steer_torque = sgn * np.random.uniform(0.02, 0.03)\n+    lat_accel = gt_torque_tune.latAccelFactor * steer_torque\n+    livePose = messaging.new_message('livePose').livePose\n+    livePose.orientationNED.x = float(np.deg2rad(ROLL_BIAS_DEG))\n+    livePose.angularVelocityDevice.z = lat_accel / V_EGO\n+    est.raw_points[\"lat_active\"].append(True)",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2294794636",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 36005,
        "pr_file": "selfdrive/controls/tests/test_torqued_straight_road_roll_bias.py",
        "discussion_id": "2294794636",
        "commented_code": "@@ -0,0 +1,43 @@\n+import numpy as np\n+from cereal import car, messaging\n+from opendbc.car import ACCELERATION_DUE_TO_GRAVITY\n+from opendbc.car import structs\n+from opendbc.car.lateral import get_friction, FRICTION_THRESHOLD\n+from openpilot.selfdrive.locationd.torqued import TorqueEstimator, MIN_BUCKET_POINTS, STEER_BUCKET_BOUNDS, POINTS_PER_BUCKET\n+from openpilot.common.realtime import DT_MDL\n+np.random.seed(0)\n+\n+ROLL_BIAS_DEG = 1.0\n+V_EGO = 30.0\n+\n+# how much larger roll compensation is than it should be\n+roll_compensation_bias = ACCELERATION_DUE_TO_GRAVITY*float(np.sin(np.deg2rad(ROLL_BIAS_DEG)))\n+gt_torque_tune = structs.CarParams.LateralTorqueTuning(latAccelFactor=2.0, latAccelOffset=0.0, friction=0.2)\n+\n+def test_straight_road_roll_bias():\n+  steer_torques = np.concat([np.random.uniform(bound[0], bound[1], int(points))\n+                             for bound, points in zip(STEER_BUCKET_BOUNDS, 1.5*MIN_BUCKET_POINTS, strict=True)])\n+  la_errs = np.random.randn(steer_torques.size)\n+  frictions = np.array([get_friction(la_err, 0.0, FRICTION_THRESHOLD, gt_torque_tune) for la_err in la_errs])\n+  lat_accels = gt_torque_tune.latAccelFactor*steer_torques + frictions\n+  est = TorqueEstimator(car.CarParams())\n+  for steer_torque, lat_accel in zip(steer_torques, lat_accels, strict=True):\n+    est.filtered_points.add_point(steer_torque, lat_accel)\n+  for i in range(2*POINTS_PER_BUCKET):\n+    t = i*DT_MDL\n+    sgn = (-1)**(i < POINTS_PER_BUCKET)\n+    steer_torque = sgn * np.random.uniform(0.02, 0.03)\n+    lat_accel = gt_torque_tune.latAccelFactor * steer_torque\n+    livePose = messaging.new_message('livePose').livePose\n+    livePose.orientationNED.x = float(np.deg2rad(ROLL_BIAS_DEG))\n+    livePose.angularVelocityDevice.z = lat_accel / V_EGO\n+    est.raw_points[\"lat_active\"].append(True)",
        "comment_created_at": "2025-08-22T21:37:27+00:00",
        "comment_author": "adeebshihadeh",
        "comment_body": "why are some inputs done like this and others with `handle_log`? you generally don't want to rely on internal state, like `raw_points`, in a test case",
        "pr_file_module": null
      },
      {
        "comment_id": "2294858099",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 36005,
        "pr_file": "selfdrive/controls/tests/test_torqued_straight_road_roll_bias.py",
        "discussion_id": "2294794636",
        "commented_code": "@@ -0,0 +1,43 @@\n+import numpy as np\n+from cereal import car, messaging\n+from opendbc.car import ACCELERATION_DUE_TO_GRAVITY\n+from opendbc.car import structs\n+from opendbc.car.lateral import get_friction, FRICTION_THRESHOLD\n+from openpilot.selfdrive.locationd.torqued import TorqueEstimator, MIN_BUCKET_POINTS, STEER_BUCKET_BOUNDS, POINTS_PER_BUCKET\n+from openpilot.common.realtime import DT_MDL\n+np.random.seed(0)\n+\n+ROLL_BIAS_DEG = 1.0\n+V_EGO = 30.0\n+\n+# how much larger roll compensation is than it should be\n+roll_compensation_bias = ACCELERATION_DUE_TO_GRAVITY*float(np.sin(np.deg2rad(ROLL_BIAS_DEG)))\n+gt_torque_tune = structs.CarParams.LateralTorqueTuning(latAccelFactor=2.0, latAccelOffset=0.0, friction=0.2)\n+\n+def test_straight_road_roll_bias():\n+  steer_torques = np.concat([np.random.uniform(bound[0], bound[1], int(points))\n+                             for bound, points in zip(STEER_BUCKET_BOUNDS, 1.5*MIN_BUCKET_POINTS, strict=True)])\n+  la_errs = np.random.randn(steer_torques.size)\n+  frictions = np.array([get_friction(la_err, 0.0, FRICTION_THRESHOLD, gt_torque_tune) for la_err in la_errs])\n+  lat_accels = gt_torque_tune.latAccelFactor*steer_torques + frictions\n+  est = TorqueEstimator(car.CarParams())\n+  for steer_torque, lat_accel in zip(steer_torques, lat_accels, strict=True):\n+    est.filtered_points.add_point(steer_torque, lat_accel)\n+  for i in range(2*POINTS_PER_BUCKET):\n+    t = i*DT_MDL\n+    sgn = (-1)**(i < POINTS_PER_BUCKET)\n+    steer_torque = sgn * np.random.uniform(0.02, 0.03)\n+    lat_accel = gt_torque_tune.latAccelFactor * steer_torque\n+    livePose = messaging.new_message('livePose').livePose\n+    livePose.orientationNED.x = float(np.deg2rad(ROLL_BIAS_DEG))\n+    livePose.angularVelocityDevice.z = lat_accel / V_EGO\n+    est.raw_points[\"lat_active\"].append(True)",
        "comment_created_at": "2025-08-22T22:22:29+00:00",
        "comment_author": "felsager",
        "comment_body": "All inputs are now handled by `handle_log` ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2004003500",
    "pr_number": 34856,
    "pr_file": "system/athena/tests/test_athenad.py",
    "created_at": "2025-03-19T18:32:30+00:00",
    "commented_code": "assert len(items) == 1\n     assert items[0]['current']\n \n+  def test_list_upload_queue_priority(self, host: str):",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2004003500",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34856,
        "pr_file": "system/athena/tests/test_athenad.py",
        "discussion_id": "2004003500",
        "commented_code": "@@ -321,6 +321,26 @@ def test_list_upload_queue_current(self, host: str):\n     assert len(items) == 1\n     assert items[0]['current']\n \n+  def test_list_upload_queue_priority(self, host: str):",
        "comment_created_at": "2025-03-19T18:32:30+00:00",
        "comment_author": "incognitojam",
        "comment_body": "```suggestion\r\n  def test_list_upload_queue_priority(self):\r\n```\r\nYou can use a made up host for this test, not using `@with_upload_handler`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1621548539",
    "pr_number": 32577,
    "pr_file": "selfdrive/car/tests/test_models.py",
    "created_at": "2024-05-31T00:39:08+00:00",
    "commented_code": "if self.CP.carName == \"honda\":\n         if self.safety.get_acc_main_on() != prev_panda_acc_main_on:\n           self.assertEqual(CS.cruiseState.available, self.safety.get_acc_main_on())\n+  '''\n+\n+  # Skip stdout/stderr capture with pytest, causes elevated memory usage\n+  @pytest.mark.nocapture\n+  @settings(max_examples=MAX_EXAMPLES, deadline=None,\n+            phases=(Phase.reuse, Phase.generate, Phase.shrink))\n+  @given(CC=car_control_strategy())\n+  def test_panda_safety_tx_fuzzy(self, CC):\n+\n+    now_nanos = DT_CTRL * 1e9\n+    CI = self.CarInterface(self.CP, self.CarController, self.CarState)\n+\n+    if self.CP.carName == \"honda\":",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "1621548539",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 32577,
        "pr_file": "selfdrive/car/tests/test_models.py",
        "discussion_id": "1621548539",
        "commented_code": "@@ -386,7 +440,89 @@ def test_panda_safety_carstate_fuzzy(self, data):\n       if self.CP.carName == \"honda\":\n         if self.safety.get_acc_main_on() != prev_panda_acc_main_on:\n           self.assertEqual(CS.cruiseState.available, self.safety.get_acc_main_on())\n+  '''\n+\n+  # Skip stdout/stderr capture with pytest, causes elevated memory usage\n+  @pytest.mark.nocapture\n+  @settings(max_examples=MAX_EXAMPLES, deadline=None,\n+            phases=(Phase.reuse, Phase.generate, Phase.shrink))\n+  @given(CC=car_control_strategy())\n+  def test_panda_safety_tx_fuzzy(self, CC):\n+\n+    now_nanos = DT_CTRL * 1e9\n+    CI = self.CarInterface(self.CP, self.CarController, self.CarState)\n+\n+    if self.CP.carName == \"honda\":",
        "comment_created_at": "2024-05-31T00:39:08+00:00",
        "comment_author": "sshane",
        "comment_body": "this test should know as little about the cars/brands as possible",
        "pr_file_module": null
      }
    ]
  }
]