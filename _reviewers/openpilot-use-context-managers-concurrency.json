[
  {
    "discussion_id": "2272000597",
    "pr_number": 35984,
    "pr_file": "tools/clip/run.py",
    "created_at": "2025-08-13T03:50:54+00:00",
    "commented_code": "env = os.environ.copy()\n     env['DISPLAY'] = display\n \n-    xvfb_proc = start_proc(xvfb_cmd, env)\n-    atexit.register(lambda: xvfb_proc.terminate())\n-    ui_proc = start_proc(ui_cmd, env)\n-    atexit.register(lambda: ui_proc.terminate())\n-    replay_proc = start_proc(replay_cmd, env)\n-    atexit.register(lambda: replay_proc.terminate())\n-    procs = [replay_proc, ui_proc, xvfb_proc]\n-\n-    logger.info('waiting for replay to begin (loading segments, may take a while)...')\n-    wait_for_frames(procs)\n-\n-    logger.debug(f'letting UI warm up ({SECONDS_TO_WARM}s)...')\n-    time.sleep(SECONDS_TO_WARM)\n-    for proc in procs:\n-      check_for_failure(proc)\n-\n-    ffmpeg_proc = start_proc(ffmpeg_cmd, env)\n-    procs.append(ffmpeg_proc)\n-    atexit.register(lambda: ffmpeg_proc.terminate())\n-\n-    logger.info(f'recording in progress ({duration}s)...')\n-    ffmpeg_proc.wait(duration + PROC_WAIT_SECONDS)\n-    for proc in procs:\n-      check_for_failure(proc)\n-    logger.info(f'recording complete: {Path(out).resolve()}')\n+    procs = []\n+    try:\n+      xvfb_proc = start_proc(xvfb_cmd, env)\n+      procs.append(xvfb_proc)\n+      ui_proc = start_proc(ui_cmd, env)\n+      procs.append(ui_proc)\n+      replay_proc = start_proc(replay_cmd, env)\n+      procs.append(replay_proc)\n+\n+      logger.info('waiting for replay to begin (loading segments, may take a while)...')\n+      wait_for_frames(procs)\n+\n+      logger.debug(f'letting UI warm up ({SECONDS_TO_WARM}s)...')\n+      time.sleep(SECONDS_TO_WARM)\n+      for proc in procs:\n+        check_for_failure(proc)\n+\n+      ffmpeg_proc = start_proc(ffmpeg_cmd, env)\n+      procs.append(ffmpeg_proc)\n+\n+      logger.info(f'recording in progress ({duration}s)...')\n+      ffmpeg_proc.wait(duration + PROC_WAIT_SECONDS)\n+      for proc in procs:\n+        check_for_failure(proc)\n+      logger.info(f'recording complete: {Path(out).resolve()}')\n+    finally:",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2272000597",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 35984,
        "pr_file": "tools/clip/run.py",
        "discussion_id": "2272000597",
        "commented_code": "@@ -257,31 +256,41 @@ def clip(\n     env = os.environ.copy()\n     env['DISPLAY'] = display\n \n-    xvfb_proc = start_proc(xvfb_cmd, env)\n-    atexit.register(lambda: xvfb_proc.terminate())\n-    ui_proc = start_proc(ui_cmd, env)\n-    atexit.register(lambda: ui_proc.terminate())\n-    replay_proc = start_proc(replay_cmd, env)\n-    atexit.register(lambda: replay_proc.terminate())\n-    procs = [replay_proc, ui_proc, xvfb_proc]\n-\n-    logger.info('waiting for replay to begin (loading segments, may take a while)...')\n-    wait_for_frames(procs)\n-\n-    logger.debug(f'letting UI warm up ({SECONDS_TO_WARM}s)...')\n-    time.sleep(SECONDS_TO_WARM)\n-    for proc in procs:\n-      check_for_failure(proc)\n-\n-    ffmpeg_proc = start_proc(ffmpeg_cmd, env)\n-    procs.append(ffmpeg_proc)\n-    atexit.register(lambda: ffmpeg_proc.terminate())\n-\n-    logger.info(f'recording in progress ({duration}s)...')\n-    ffmpeg_proc.wait(duration + PROC_WAIT_SECONDS)\n-    for proc in procs:\n-      check_for_failure(proc)\n-    logger.info(f'recording complete: {Path(out).resolve()}')\n+    procs = []\n+    try:\n+      xvfb_proc = start_proc(xvfb_cmd, env)\n+      procs.append(xvfb_proc)\n+      ui_proc = start_proc(ui_cmd, env)\n+      procs.append(ui_proc)\n+      replay_proc = start_proc(replay_cmd, env)\n+      procs.append(replay_proc)\n+\n+      logger.info('waiting for replay to begin (loading segments, may take a while)...')\n+      wait_for_frames(procs)\n+\n+      logger.debug(f'letting UI warm up ({SECONDS_TO_WARM}s)...')\n+      time.sleep(SECONDS_TO_WARM)\n+      for proc in procs:\n+        check_for_failure(proc)\n+\n+      ffmpeg_proc = start_proc(ffmpeg_cmd, env)\n+      procs.append(ffmpeg_proc)\n+\n+      logger.info(f'recording in progress ({duration}s)...')\n+      ffmpeg_proc.wait(duration + PROC_WAIT_SECONDS)\n+      for proc in procs:\n+        check_for_failure(proc)\n+      logger.info(f'recording complete: {Path(out).resolve()}')\n+    finally:",
        "comment_created_at": "2025-08-13T03:50:54+00:00",
        "comment_author": "adeebshihadeh",
        "comment_body": "let's make a little helper (and put it in `common/`) to do this in a context manager:\n```python\nwith Proc('./replay'), proc('./ui')...:\n\t<code>\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2015689011",
    "pr_number": 34531,
    "pr_file": "selfdrive/locationd/lagd.py",
    "created_at": "2025-03-27T05:47:41+00:00",
    "commented_code": "+#!/usr/bin/env python3\n+import numpy as np\n+from collections import deque\n+from functools import partial\n+\n+import cereal.messaging as messaging\n+from cereal import car, log\n+from cereal.services import SERVICE_LIST\n+from openpilot.common.params import Params\n+from openpilot.common.realtime import config_realtime_process\n+from openpilot.selfdrive.locationd.helpers import PoseCalibrator, Pose\n+\n+BLOCK_SIZE = 100\n+BLOCK_NUM = 50\n+MOVING_WINDOW_SEC = 300.0\n+MIN_OKAY_WINDOW_SEC = 30.0\n+MIN_VEGO = 15.0\n+MIN_ABS_YAW_RATE = np.radians(1.0)\n+MIN_NCC = 0.95\n+\n+\n+def parabolic_peak_interp(R, max_index):\n+  if max_index == 0 or max_index == len(R) - 1:\n+    return max_index\n+\n+  y_m1, y_0, y_p1 = R[max_index - 1], R[max_index], R[max_index + 1]\n+  offset = 0.5 * (y_p1 - y_m1) / (2 * y_0 - y_p1 - y_m1)\n+\n+  return max_index + offset\n+\n+\n+def masked_normalized_cross_correlation(expected_sig, actual_sig, mask):\n+  \"\"\"\n+  References:\n+    D. Padfield. \"Masked FFT registration\". In Proc. Computer Vision and\n+    Pattern Recognition, pp. 2918-2925 (2010).\n+    :DOI:`10.1109/CVPR.2010.5540032`\n+  \"\"\"\n+\n+  eps = np.finfo(np.float64).eps\n+  expected_sig = np.asarray(expected_sig, dtype=np.float64)\n+  actual_sig = np.asarray(actual_sig, dtype=np.float64)\n+\n+  expected_sig[~mask] = 0.0\n+  actual_sig[~mask] = 0.0\n+\n+  rotated_expected_sig = expected_sig[::-1]\n+  rotated_mask = mask[::-1]\n+\n+  n = len(expected_sig) + len(actual_sig) - 1\n+  fft = partial(np.fft.fft, n=n)\n+\n+  actual_sig_fft = fft(actual_sig)\n+  rotated_expected_sig_fft = fft(rotated_expected_sig)\n+  actual_mask_fft = fft(mask.astype(np.float64))\n+  rotated_mask_fft = fft(rotated_mask.astype(np.float64))\n+\n+  number_overlap_masked_samples = np.fft.ifft(rotated_mask_fft * actual_mask_fft).real\n+  number_overlap_masked_samples[:] = np.round(number_overlap_masked_samples)\n+  number_overlap_masked_samples[:] = np.fmax(number_overlap_masked_samples, eps)\n+  masked_correlated_actual_fft = np.fft.ifft(rotated_mask_fft * actual_sig_fft).real\n+  masked_correlated_expected_fft = np.fft.ifft(actual_mask_fft * rotated_expected_sig_fft).real\n+\n+  numerator = np.fft.ifft(rotated_expected_sig_fft * actual_sig_fft).real\n+  numerator -= masked_correlated_actual_fft * masked_correlated_expected_fft / number_overlap_masked_samples\n+\n+  actual_squared_fft = fft(actual_sig ** 2)\n+  actual_sig_denom = np.fft.ifft(rotated_mask_fft * actual_squared_fft).real\n+  actual_sig_denom -= masked_correlated_actual_fft ** 2 / number_overlap_masked_samples\n+  actual_sig_denom[:] = np.fmax(actual_sig_denom, 0.0)\n+\n+  rotated_expected_squared_fft = fft(rotated_expected_sig ** 2)\n+  expected_sig_denom = np.fft.ifft(actual_mask_fft * rotated_expected_squared_fft).real\n+  expected_sig_denom -= masked_correlated_expected_fft ** 2 / number_overlap_masked_samples\n+  expected_sig_denom[:] = np.fmax(expected_sig_denom, 0.0)\n+\n+  denom = np.sqrt(actual_sig_denom * expected_sig_denom)\n+\n+  # zero-out samples with very small denominators\n+  tol = 1e3 * eps * np.max(np.abs(denom), keepdims=True)\n+  nonzero_indices = denom > tol\n+\n+  ncc = np.zeros_like(denom, dtype=np.float64)\n+  ncc[nonzero_indices] = numerator[nonzero_indices] / denom[nonzero_indices]\n+  np.clip(ncc, -1, 1, out=ncc)\n+\n+  return ncc\n+\n+\n+class Points:\n+  def __init__(self, num_points):\n+    self.times = deque(maxlen=num_points)\n+    self.okay = deque(maxlen=num_points)\n+    self.desired = deque(maxlen=num_points)\n+    self.actual = deque(maxlen=num_points)\n+\n+  @property\n+  def num_points(self):\n+    return len(self.desired)\n+\n+  @property\n+  def num_okay(self):\n+    return np.count_nonzero(self.okay)\n+\n+  def update(self, t, desired, actual, okay):\n+    self.times.append(t)\n+    self.okay.append(okay)\n+    self.desired.append(desired)\n+    self.actual.append(actual)\n+\n+  def get(self):\n+    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)\n+\n+\n+class BlockAverage:\n+  def __init__(self, num_blocks, block_size, valid_blocks, initial_value):\n+    self.num_blocks = num_blocks\n+    self.block_size = block_size\n+    self.block_idx = 0\n+    self.idx = 0\n+\n+    self.values = np.tile(initial_value, (num_blocks, 1))\n+    self.valid_blocks = valid_blocks\n+\n+  def update(self, value):\n+    self.values[self.block_idx] = (self.idx * self.values[self.block_idx] + (self.block_size - self.idx) * value) / self.block_size\n+    self.idx = (self.idx + 1) % self.block_size\n+    if self.idx == 0:\n+      self.block_idx = (self.block_idx + 1) % self.num_blocks\n+      self.valid_blocks = min(self.valid_blocks + 1, self.num_blocks)\n+\n+  def get(self):\n+    valid_block_idx = [i for i in range(self.valid_blocks) if i != self.block_idx]\n+    if not valid_block_idx:\n+      return None\n+    return np.mean(self.values[valid_block_idx], axis=0)\n+\n+\n+class LagEstimator:\n+  def __init__(self, CP, dt,\n+               block_count=BLOCK_NUM, block_size=BLOCK_SIZE,\n+               window_sec=MOVING_WINDOW_SEC, okay_window_sec=MIN_OKAY_WINDOW_SEC,\n+               min_vego=MIN_VEGO, min_yr=MIN_ABS_YAW_RATE, min_ncc=MIN_NCC):\n+    self.dt = dt\n+    self.window_sec = window_sec\n+    self.okay_window_sec = okay_window_sec\n+    self.initial_lag = CP.steerActuatorDelay + 0.2\n+    self.block_size = block_size\n+    self.block_count = block_count\n+    self.min_vego = min_vego\n+    self.min_yr = min_yr\n+    self.min_ncc = min_ncc\n+\n+    self.t = 0\n+    self.lat_active = False\n+    self.steering_pressed = False\n+    self.steering_saturated = False\n+    self.desired_curvature = 0\n+    self.v_ego = 0\n+    self.yaw_rate = 0\n+\n+    self.calibrator = PoseCalibrator()\n+\n+    self.reset(self.initial_lag, 0)\n+\n+  def reset(self, initial_lag, valid_blocks):\n+    window_len = int(self.window_sec / self.dt)\n+    self.points = Points(window_len)\n+    self.block_avg = BlockAverage(self.block_count, self.block_size, valid_blocks, initial_lag)\n+    self.lag = initial_lag\n+\n+  def get_msg(self, valid):\n+    msg = messaging.new_message('liveActuatorDelay')\n+\n+    msg.valid = valid\n+\n+    liveDelay = msg.liveActuatorDelay\n+    liveDelay.steerActuatorDelay = self.lag\n+    liveDelay.isEstimated = self.block_avg.valid_blocks > 0\n+    liveDelay.validBlocks = self.block_avg.valid_blocks\n+    liveDelay.points = self.block_avg.values.tolist()\n+\n+    return msg\n+\n+  def handle_log(self, t, which, msg):\n+    if which == \"carControl\":\n+      self.lat_active = msg.latActive\n+    elif which == \"carState\":\n+      self.steering_pressed = msg.steeringPressed\n+      self.v_ego = msg.vEgo\n+    elif which == \"controlsState\":\n+      self.desired_curvature = msg.desiredCurvature\n+      self.steering_saturated = getattr(msg.lateralControlState, msg.lateralControlState.which()).saturated\n+    elif which == \"liveCalibration\":\n+      self.calibrator.feed_live_calib(msg)\n+    elif which == \"livePose\":\n+      device_pose = Pose.from_live_pose(msg)\n+      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n+      self.yaw_rate = calibrated_pose.angular_velocity.z\n+    self.t = t\n+\n+  def points_valid(self):\n+    return self.points.num_okay >= int(self.okay_window_sec / self.dt)\n+\n+  def update_points(self):\n+    la_desired = self.desired_curvature * self.v_ego * self.v_ego\n+    la_actual_pose = self.yaw_rate * self.v_ego\n+\n+    fast = self.v_ego > self.min_vego\n+    turning = np.abs(self.yaw_rate) >= self.min_yr\n+    okay = self.lat_active and not self.steering_pressed and not self.steering_saturated and fast and turning",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2015689011",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34531,
        "pr_file": "selfdrive/locationd/lagd.py",
        "discussion_id": "2015689011",
        "commented_code": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+import numpy as np\n+from collections import deque\n+from functools import partial\n+\n+import cereal.messaging as messaging\n+from cereal import car, log\n+from cereal.services import SERVICE_LIST\n+from openpilot.common.params import Params\n+from openpilot.common.realtime import config_realtime_process\n+from openpilot.selfdrive.locationd.helpers import PoseCalibrator, Pose\n+\n+BLOCK_SIZE = 100\n+BLOCK_NUM = 50\n+MOVING_WINDOW_SEC = 300.0\n+MIN_OKAY_WINDOW_SEC = 30.0\n+MIN_VEGO = 15.0\n+MIN_ABS_YAW_RATE = np.radians(1.0)\n+MIN_NCC = 0.95\n+\n+\n+def parabolic_peak_interp(R, max_index):\n+  if max_index == 0 or max_index == len(R) - 1:\n+    return max_index\n+\n+  y_m1, y_0, y_p1 = R[max_index - 1], R[max_index], R[max_index + 1]\n+  offset = 0.5 * (y_p1 - y_m1) / (2 * y_0 - y_p1 - y_m1)\n+\n+  return max_index + offset\n+\n+\n+def masked_normalized_cross_correlation(expected_sig, actual_sig, mask):\n+  \"\"\"\n+  References:\n+    D. Padfield. \"Masked FFT registration\". In Proc. Computer Vision and\n+    Pattern Recognition, pp. 2918-2925 (2010).\n+    :DOI:`10.1109/CVPR.2010.5540032`\n+  \"\"\"\n+\n+  eps = np.finfo(np.float64).eps\n+  expected_sig = np.asarray(expected_sig, dtype=np.float64)\n+  actual_sig = np.asarray(actual_sig, dtype=np.float64)\n+\n+  expected_sig[~mask] = 0.0\n+  actual_sig[~mask] = 0.0\n+\n+  rotated_expected_sig = expected_sig[::-1]\n+  rotated_mask = mask[::-1]\n+\n+  n = len(expected_sig) + len(actual_sig) - 1\n+  fft = partial(np.fft.fft, n=n)\n+\n+  actual_sig_fft = fft(actual_sig)\n+  rotated_expected_sig_fft = fft(rotated_expected_sig)\n+  actual_mask_fft = fft(mask.astype(np.float64))\n+  rotated_mask_fft = fft(rotated_mask.astype(np.float64))\n+\n+  number_overlap_masked_samples = np.fft.ifft(rotated_mask_fft * actual_mask_fft).real\n+  number_overlap_masked_samples[:] = np.round(number_overlap_masked_samples)\n+  number_overlap_masked_samples[:] = np.fmax(number_overlap_masked_samples, eps)\n+  masked_correlated_actual_fft = np.fft.ifft(rotated_mask_fft * actual_sig_fft).real\n+  masked_correlated_expected_fft = np.fft.ifft(actual_mask_fft * rotated_expected_sig_fft).real\n+\n+  numerator = np.fft.ifft(rotated_expected_sig_fft * actual_sig_fft).real\n+  numerator -= masked_correlated_actual_fft * masked_correlated_expected_fft / number_overlap_masked_samples\n+\n+  actual_squared_fft = fft(actual_sig ** 2)\n+  actual_sig_denom = np.fft.ifft(rotated_mask_fft * actual_squared_fft).real\n+  actual_sig_denom -= masked_correlated_actual_fft ** 2 / number_overlap_masked_samples\n+  actual_sig_denom[:] = np.fmax(actual_sig_denom, 0.0)\n+\n+  rotated_expected_squared_fft = fft(rotated_expected_sig ** 2)\n+  expected_sig_denom = np.fft.ifft(actual_mask_fft * rotated_expected_squared_fft).real\n+  expected_sig_denom -= masked_correlated_expected_fft ** 2 / number_overlap_masked_samples\n+  expected_sig_denom[:] = np.fmax(expected_sig_denom, 0.0)\n+\n+  denom = np.sqrt(actual_sig_denom * expected_sig_denom)\n+\n+  # zero-out samples with very small denominators\n+  tol = 1e3 * eps * np.max(np.abs(denom), keepdims=True)\n+  nonzero_indices = denom > tol\n+\n+  ncc = np.zeros_like(denom, dtype=np.float64)\n+  ncc[nonzero_indices] = numerator[nonzero_indices] / denom[nonzero_indices]\n+  np.clip(ncc, -1, 1, out=ncc)\n+\n+  return ncc\n+\n+\n+class Points:\n+  def __init__(self, num_points):\n+    self.times = deque(maxlen=num_points)\n+    self.okay = deque(maxlen=num_points)\n+    self.desired = deque(maxlen=num_points)\n+    self.actual = deque(maxlen=num_points)\n+\n+  @property\n+  def num_points(self):\n+    return len(self.desired)\n+\n+  @property\n+  def num_okay(self):\n+    return np.count_nonzero(self.okay)\n+\n+  def update(self, t, desired, actual, okay):\n+    self.times.append(t)\n+    self.okay.append(okay)\n+    self.desired.append(desired)\n+    self.actual.append(actual)\n+\n+  def get(self):\n+    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)\n+\n+\n+class BlockAverage:\n+  def __init__(self, num_blocks, block_size, valid_blocks, initial_value):\n+    self.num_blocks = num_blocks\n+    self.block_size = block_size\n+    self.block_idx = 0\n+    self.idx = 0\n+\n+    self.values = np.tile(initial_value, (num_blocks, 1))\n+    self.valid_blocks = valid_blocks\n+\n+  def update(self, value):\n+    self.values[self.block_idx] = (self.idx * self.values[self.block_idx] + (self.block_size - self.idx) * value) / self.block_size\n+    self.idx = (self.idx + 1) % self.block_size\n+    if self.idx == 0:\n+      self.block_idx = (self.block_idx + 1) % self.num_blocks\n+      self.valid_blocks = min(self.valid_blocks + 1, self.num_blocks)\n+\n+  def get(self):\n+    valid_block_idx = [i for i in range(self.valid_blocks) if i != self.block_idx]\n+    if not valid_block_idx:\n+      return None\n+    return np.mean(self.values[valid_block_idx], axis=0)\n+\n+\n+class LagEstimator:\n+  def __init__(self, CP, dt,\n+               block_count=BLOCK_NUM, block_size=BLOCK_SIZE,\n+               window_sec=MOVING_WINDOW_SEC, okay_window_sec=MIN_OKAY_WINDOW_SEC,\n+               min_vego=MIN_VEGO, min_yr=MIN_ABS_YAW_RATE, min_ncc=MIN_NCC):\n+    self.dt = dt\n+    self.window_sec = window_sec\n+    self.okay_window_sec = okay_window_sec\n+    self.initial_lag = CP.steerActuatorDelay + 0.2\n+    self.block_size = block_size\n+    self.block_count = block_count\n+    self.min_vego = min_vego\n+    self.min_yr = min_yr\n+    self.min_ncc = min_ncc\n+\n+    self.t = 0\n+    self.lat_active = False\n+    self.steering_pressed = False\n+    self.steering_saturated = False\n+    self.desired_curvature = 0\n+    self.v_ego = 0\n+    self.yaw_rate = 0\n+\n+    self.calibrator = PoseCalibrator()\n+\n+    self.reset(self.initial_lag, 0)\n+\n+  def reset(self, initial_lag, valid_blocks):\n+    window_len = int(self.window_sec / self.dt)\n+    self.points = Points(window_len)\n+    self.block_avg = BlockAverage(self.block_count, self.block_size, valid_blocks, initial_lag)\n+    self.lag = initial_lag\n+\n+  def get_msg(self, valid):\n+    msg = messaging.new_message('liveActuatorDelay')\n+\n+    msg.valid = valid\n+\n+    liveDelay = msg.liveActuatorDelay\n+    liveDelay.steerActuatorDelay = self.lag\n+    liveDelay.isEstimated = self.block_avg.valid_blocks > 0\n+    liveDelay.validBlocks = self.block_avg.valid_blocks\n+    liveDelay.points = self.block_avg.values.tolist()\n+\n+    return msg\n+\n+  def handle_log(self, t, which, msg):\n+    if which == \"carControl\":\n+      self.lat_active = msg.latActive\n+    elif which == \"carState\":\n+      self.steering_pressed = msg.steeringPressed\n+      self.v_ego = msg.vEgo\n+    elif which == \"controlsState\":\n+      self.desired_curvature = msg.desiredCurvature\n+      self.steering_saturated = getattr(msg.lateralControlState, msg.lateralControlState.which()).saturated\n+    elif which == \"liveCalibration\":\n+      self.calibrator.feed_live_calib(msg)\n+    elif which == \"livePose\":\n+      device_pose = Pose.from_live_pose(msg)\n+      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n+      self.yaw_rate = calibrated_pose.angular_velocity.z\n+    self.t = t\n+\n+  def points_valid(self):\n+    return self.points.num_okay >= int(self.okay_window_sec / self.dt)\n+\n+  def update_points(self):\n+    la_desired = self.desired_curvature * self.v_ego * self.v_ego\n+    la_actual_pose = self.yaw_rate * self.v_ego\n+\n+    fast = self.v_ego > self.min_vego\n+    turning = np.abs(self.yaw_rate) >= self.min_yr\n+    okay = self.lat_active and not self.steering_pressed and not self.steering_saturated and fast and turning",
        "comment_created_at": "2025-03-27T05:47:41+00:00",
        "comment_author": "sshane",
        "comment_body": "You should check that the user hasn't been steering and we've been engaged for longer than x time since there is some ramp time back to a steady control state.\r\n\r\nhttps://github.com/commaai/openpilot/blob/a2859090d835041a0c662809f7549bdc2040af16/selfdrive/locationd/torqued.py#L196-L198",
        "pr_file_module": null
      },
      {
        "comment_id": "2015704437",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34531,
        "pr_file": "selfdrive/locationd/lagd.py",
        "discussion_id": "2015689011",
        "commented_code": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+import numpy as np\n+from collections import deque\n+from functools import partial\n+\n+import cereal.messaging as messaging\n+from cereal import car, log\n+from cereal.services import SERVICE_LIST\n+from openpilot.common.params import Params\n+from openpilot.common.realtime import config_realtime_process\n+from openpilot.selfdrive.locationd.helpers import PoseCalibrator, Pose\n+\n+BLOCK_SIZE = 100\n+BLOCK_NUM = 50\n+MOVING_WINDOW_SEC = 300.0\n+MIN_OKAY_WINDOW_SEC = 30.0\n+MIN_VEGO = 15.0\n+MIN_ABS_YAW_RATE = np.radians(1.0)\n+MIN_NCC = 0.95\n+\n+\n+def parabolic_peak_interp(R, max_index):\n+  if max_index == 0 or max_index == len(R) - 1:\n+    return max_index\n+\n+  y_m1, y_0, y_p1 = R[max_index - 1], R[max_index], R[max_index + 1]\n+  offset = 0.5 * (y_p1 - y_m1) / (2 * y_0 - y_p1 - y_m1)\n+\n+  return max_index + offset\n+\n+\n+def masked_normalized_cross_correlation(expected_sig, actual_sig, mask):\n+  \"\"\"\n+  References:\n+    D. Padfield. \"Masked FFT registration\". In Proc. Computer Vision and\n+    Pattern Recognition, pp. 2918-2925 (2010).\n+    :DOI:`10.1109/CVPR.2010.5540032`\n+  \"\"\"\n+\n+  eps = np.finfo(np.float64).eps\n+  expected_sig = np.asarray(expected_sig, dtype=np.float64)\n+  actual_sig = np.asarray(actual_sig, dtype=np.float64)\n+\n+  expected_sig[~mask] = 0.0\n+  actual_sig[~mask] = 0.0\n+\n+  rotated_expected_sig = expected_sig[::-1]\n+  rotated_mask = mask[::-1]\n+\n+  n = len(expected_sig) + len(actual_sig) - 1\n+  fft = partial(np.fft.fft, n=n)\n+\n+  actual_sig_fft = fft(actual_sig)\n+  rotated_expected_sig_fft = fft(rotated_expected_sig)\n+  actual_mask_fft = fft(mask.astype(np.float64))\n+  rotated_mask_fft = fft(rotated_mask.astype(np.float64))\n+\n+  number_overlap_masked_samples = np.fft.ifft(rotated_mask_fft * actual_mask_fft).real\n+  number_overlap_masked_samples[:] = np.round(number_overlap_masked_samples)\n+  number_overlap_masked_samples[:] = np.fmax(number_overlap_masked_samples, eps)\n+  masked_correlated_actual_fft = np.fft.ifft(rotated_mask_fft * actual_sig_fft).real\n+  masked_correlated_expected_fft = np.fft.ifft(actual_mask_fft * rotated_expected_sig_fft).real\n+\n+  numerator = np.fft.ifft(rotated_expected_sig_fft * actual_sig_fft).real\n+  numerator -= masked_correlated_actual_fft * masked_correlated_expected_fft / number_overlap_masked_samples\n+\n+  actual_squared_fft = fft(actual_sig ** 2)\n+  actual_sig_denom = np.fft.ifft(rotated_mask_fft * actual_squared_fft).real\n+  actual_sig_denom -= masked_correlated_actual_fft ** 2 / number_overlap_masked_samples\n+  actual_sig_denom[:] = np.fmax(actual_sig_denom, 0.0)\n+\n+  rotated_expected_squared_fft = fft(rotated_expected_sig ** 2)\n+  expected_sig_denom = np.fft.ifft(actual_mask_fft * rotated_expected_squared_fft).real\n+  expected_sig_denom -= masked_correlated_expected_fft ** 2 / number_overlap_masked_samples\n+  expected_sig_denom[:] = np.fmax(expected_sig_denom, 0.0)\n+\n+  denom = np.sqrt(actual_sig_denom * expected_sig_denom)\n+\n+  # zero-out samples with very small denominators\n+  tol = 1e3 * eps * np.max(np.abs(denom), keepdims=True)\n+  nonzero_indices = denom > tol\n+\n+  ncc = np.zeros_like(denom, dtype=np.float64)\n+  ncc[nonzero_indices] = numerator[nonzero_indices] / denom[nonzero_indices]\n+  np.clip(ncc, -1, 1, out=ncc)\n+\n+  return ncc\n+\n+\n+class Points:\n+  def __init__(self, num_points):\n+    self.times = deque(maxlen=num_points)\n+    self.okay = deque(maxlen=num_points)\n+    self.desired = deque(maxlen=num_points)\n+    self.actual = deque(maxlen=num_points)\n+\n+  @property\n+  def num_points(self):\n+    return len(self.desired)\n+\n+  @property\n+  def num_okay(self):\n+    return np.count_nonzero(self.okay)\n+\n+  def update(self, t, desired, actual, okay):\n+    self.times.append(t)\n+    self.okay.append(okay)\n+    self.desired.append(desired)\n+    self.actual.append(actual)\n+\n+  def get(self):\n+    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)\n+\n+\n+class BlockAverage:\n+  def __init__(self, num_blocks, block_size, valid_blocks, initial_value):\n+    self.num_blocks = num_blocks\n+    self.block_size = block_size\n+    self.block_idx = 0\n+    self.idx = 0\n+\n+    self.values = np.tile(initial_value, (num_blocks, 1))\n+    self.valid_blocks = valid_blocks\n+\n+  def update(self, value):\n+    self.values[self.block_idx] = (self.idx * self.values[self.block_idx] + (self.block_size - self.idx) * value) / self.block_size\n+    self.idx = (self.idx + 1) % self.block_size\n+    if self.idx == 0:\n+      self.block_idx = (self.block_idx + 1) % self.num_blocks\n+      self.valid_blocks = min(self.valid_blocks + 1, self.num_blocks)\n+\n+  def get(self):\n+    valid_block_idx = [i for i in range(self.valid_blocks) if i != self.block_idx]\n+    if not valid_block_idx:\n+      return None\n+    return np.mean(self.values[valid_block_idx], axis=0)\n+\n+\n+class LagEstimator:\n+  def __init__(self, CP, dt,\n+               block_count=BLOCK_NUM, block_size=BLOCK_SIZE,\n+               window_sec=MOVING_WINDOW_SEC, okay_window_sec=MIN_OKAY_WINDOW_SEC,\n+               min_vego=MIN_VEGO, min_yr=MIN_ABS_YAW_RATE, min_ncc=MIN_NCC):\n+    self.dt = dt\n+    self.window_sec = window_sec\n+    self.okay_window_sec = okay_window_sec\n+    self.initial_lag = CP.steerActuatorDelay + 0.2\n+    self.block_size = block_size\n+    self.block_count = block_count\n+    self.min_vego = min_vego\n+    self.min_yr = min_yr\n+    self.min_ncc = min_ncc\n+\n+    self.t = 0\n+    self.lat_active = False\n+    self.steering_pressed = False\n+    self.steering_saturated = False\n+    self.desired_curvature = 0\n+    self.v_ego = 0\n+    self.yaw_rate = 0\n+\n+    self.calibrator = PoseCalibrator()\n+\n+    self.reset(self.initial_lag, 0)\n+\n+  def reset(self, initial_lag, valid_blocks):\n+    window_len = int(self.window_sec / self.dt)\n+    self.points = Points(window_len)\n+    self.block_avg = BlockAverage(self.block_count, self.block_size, valid_blocks, initial_lag)\n+    self.lag = initial_lag\n+\n+  def get_msg(self, valid):\n+    msg = messaging.new_message('liveActuatorDelay')\n+\n+    msg.valid = valid\n+\n+    liveDelay = msg.liveActuatorDelay\n+    liveDelay.steerActuatorDelay = self.lag\n+    liveDelay.isEstimated = self.block_avg.valid_blocks > 0\n+    liveDelay.validBlocks = self.block_avg.valid_blocks\n+    liveDelay.points = self.block_avg.values.tolist()\n+\n+    return msg\n+\n+  def handle_log(self, t, which, msg):\n+    if which == \"carControl\":\n+      self.lat_active = msg.latActive\n+    elif which == \"carState\":\n+      self.steering_pressed = msg.steeringPressed\n+      self.v_ego = msg.vEgo\n+    elif which == \"controlsState\":\n+      self.desired_curvature = msg.desiredCurvature\n+      self.steering_saturated = getattr(msg.lateralControlState, msg.lateralControlState.which()).saturated\n+    elif which == \"liveCalibration\":\n+      self.calibrator.feed_live_calib(msg)\n+    elif which == \"livePose\":\n+      device_pose = Pose.from_live_pose(msg)\n+      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n+      self.yaw_rate = calibrated_pose.angular_velocity.z\n+    self.t = t\n+\n+  def points_valid(self):\n+    return self.points.num_okay >= int(self.okay_window_sec / self.dt)\n+\n+  def update_points(self):\n+    la_desired = self.desired_curvature * self.v_ego * self.v_ego\n+    la_actual_pose = self.yaw_rate * self.v_ego\n+\n+    fast = self.v_ego > self.min_vego\n+    turning = np.abs(self.yaw_rate) >= self.min_yr\n+    okay = self.lat_active and not self.steering_pressed and not self.steering_saturated and fast and turning",
        "comment_created_at": "2025-03-27T05:55:47+00:00",
        "comment_author": "fredyshox",
        "comment_body": "yeah, thats planned (the 4th point of the todo list)",
        "pr_file_module": null
      },
      {
        "comment_id": "2017572105",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34531,
        "pr_file": "selfdrive/locationd/lagd.py",
        "discussion_id": "2015689011",
        "commented_code": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+import numpy as np\n+from collections import deque\n+from functools import partial\n+\n+import cereal.messaging as messaging\n+from cereal import car, log\n+from cereal.services import SERVICE_LIST\n+from openpilot.common.params import Params\n+from openpilot.common.realtime import config_realtime_process\n+from openpilot.selfdrive.locationd.helpers import PoseCalibrator, Pose\n+\n+BLOCK_SIZE = 100\n+BLOCK_NUM = 50\n+MOVING_WINDOW_SEC = 300.0\n+MIN_OKAY_WINDOW_SEC = 30.0\n+MIN_VEGO = 15.0\n+MIN_ABS_YAW_RATE = np.radians(1.0)\n+MIN_NCC = 0.95\n+\n+\n+def parabolic_peak_interp(R, max_index):\n+  if max_index == 0 or max_index == len(R) - 1:\n+    return max_index\n+\n+  y_m1, y_0, y_p1 = R[max_index - 1], R[max_index], R[max_index + 1]\n+  offset = 0.5 * (y_p1 - y_m1) / (2 * y_0 - y_p1 - y_m1)\n+\n+  return max_index + offset\n+\n+\n+def masked_normalized_cross_correlation(expected_sig, actual_sig, mask):\n+  \"\"\"\n+  References:\n+    D. Padfield. \"Masked FFT registration\". In Proc. Computer Vision and\n+    Pattern Recognition, pp. 2918-2925 (2010).\n+    :DOI:`10.1109/CVPR.2010.5540032`\n+  \"\"\"\n+\n+  eps = np.finfo(np.float64).eps\n+  expected_sig = np.asarray(expected_sig, dtype=np.float64)\n+  actual_sig = np.asarray(actual_sig, dtype=np.float64)\n+\n+  expected_sig[~mask] = 0.0\n+  actual_sig[~mask] = 0.0\n+\n+  rotated_expected_sig = expected_sig[::-1]\n+  rotated_mask = mask[::-1]\n+\n+  n = len(expected_sig) + len(actual_sig) - 1\n+  fft = partial(np.fft.fft, n=n)\n+\n+  actual_sig_fft = fft(actual_sig)\n+  rotated_expected_sig_fft = fft(rotated_expected_sig)\n+  actual_mask_fft = fft(mask.astype(np.float64))\n+  rotated_mask_fft = fft(rotated_mask.astype(np.float64))\n+\n+  number_overlap_masked_samples = np.fft.ifft(rotated_mask_fft * actual_mask_fft).real\n+  number_overlap_masked_samples[:] = np.round(number_overlap_masked_samples)\n+  number_overlap_masked_samples[:] = np.fmax(number_overlap_masked_samples, eps)\n+  masked_correlated_actual_fft = np.fft.ifft(rotated_mask_fft * actual_sig_fft).real\n+  masked_correlated_expected_fft = np.fft.ifft(actual_mask_fft * rotated_expected_sig_fft).real\n+\n+  numerator = np.fft.ifft(rotated_expected_sig_fft * actual_sig_fft).real\n+  numerator -= masked_correlated_actual_fft * masked_correlated_expected_fft / number_overlap_masked_samples\n+\n+  actual_squared_fft = fft(actual_sig ** 2)\n+  actual_sig_denom = np.fft.ifft(rotated_mask_fft * actual_squared_fft).real\n+  actual_sig_denom -= masked_correlated_actual_fft ** 2 / number_overlap_masked_samples\n+  actual_sig_denom[:] = np.fmax(actual_sig_denom, 0.0)\n+\n+  rotated_expected_squared_fft = fft(rotated_expected_sig ** 2)\n+  expected_sig_denom = np.fft.ifft(actual_mask_fft * rotated_expected_squared_fft).real\n+  expected_sig_denom -= masked_correlated_expected_fft ** 2 / number_overlap_masked_samples\n+  expected_sig_denom[:] = np.fmax(expected_sig_denom, 0.0)\n+\n+  denom = np.sqrt(actual_sig_denom * expected_sig_denom)\n+\n+  # zero-out samples with very small denominators\n+  tol = 1e3 * eps * np.max(np.abs(denom), keepdims=True)\n+  nonzero_indices = denom > tol\n+\n+  ncc = np.zeros_like(denom, dtype=np.float64)\n+  ncc[nonzero_indices] = numerator[nonzero_indices] / denom[nonzero_indices]\n+  np.clip(ncc, -1, 1, out=ncc)\n+\n+  return ncc\n+\n+\n+class Points:\n+  def __init__(self, num_points):\n+    self.times = deque(maxlen=num_points)\n+    self.okay = deque(maxlen=num_points)\n+    self.desired = deque(maxlen=num_points)\n+    self.actual = deque(maxlen=num_points)\n+\n+  @property\n+  def num_points(self):\n+    return len(self.desired)\n+\n+  @property\n+  def num_okay(self):\n+    return np.count_nonzero(self.okay)\n+\n+  def update(self, t, desired, actual, okay):\n+    self.times.append(t)\n+    self.okay.append(okay)\n+    self.desired.append(desired)\n+    self.actual.append(actual)\n+\n+  def get(self):\n+    return np.array(self.times), np.array(self.desired), np.array(self.actual), np.array(self.okay)\n+\n+\n+class BlockAverage:\n+  def __init__(self, num_blocks, block_size, valid_blocks, initial_value):\n+    self.num_blocks = num_blocks\n+    self.block_size = block_size\n+    self.block_idx = 0\n+    self.idx = 0\n+\n+    self.values = np.tile(initial_value, (num_blocks, 1))\n+    self.valid_blocks = valid_blocks\n+\n+  def update(self, value):\n+    self.values[self.block_idx] = (self.idx * self.values[self.block_idx] + (self.block_size - self.idx) * value) / self.block_size\n+    self.idx = (self.idx + 1) % self.block_size\n+    if self.idx == 0:\n+      self.block_idx = (self.block_idx + 1) % self.num_blocks\n+      self.valid_blocks = min(self.valid_blocks + 1, self.num_blocks)\n+\n+  def get(self):\n+    valid_block_idx = [i for i in range(self.valid_blocks) if i != self.block_idx]\n+    if not valid_block_idx:\n+      return None\n+    return np.mean(self.values[valid_block_idx], axis=0)\n+\n+\n+class LagEstimator:\n+  def __init__(self, CP, dt,\n+               block_count=BLOCK_NUM, block_size=BLOCK_SIZE,\n+               window_sec=MOVING_WINDOW_SEC, okay_window_sec=MIN_OKAY_WINDOW_SEC,\n+               min_vego=MIN_VEGO, min_yr=MIN_ABS_YAW_RATE, min_ncc=MIN_NCC):\n+    self.dt = dt\n+    self.window_sec = window_sec\n+    self.okay_window_sec = okay_window_sec\n+    self.initial_lag = CP.steerActuatorDelay + 0.2\n+    self.block_size = block_size\n+    self.block_count = block_count\n+    self.min_vego = min_vego\n+    self.min_yr = min_yr\n+    self.min_ncc = min_ncc\n+\n+    self.t = 0\n+    self.lat_active = False\n+    self.steering_pressed = False\n+    self.steering_saturated = False\n+    self.desired_curvature = 0\n+    self.v_ego = 0\n+    self.yaw_rate = 0\n+\n+    self.calibrator = PoseCalibrator()\n+\n+    self.reset(self.initial_lag, 0)\n+\n+  def reset(self, initial_lag, valid_blocks):\n+    window_len = int(self.window_sec / self.dt)\n+    self.points = Points(window_len)\n+    self.block_avg = BlockAverage(self.block_count, self.block_size, valid_blocks, initial_lag)\n+    self.lag = initial_lag\n+\n+  def get_msg(self, valid):\n+    msg = messaging.new_message('liveActuatorDelay')\n+\n+    msg.valid = valid\n+\n+    liveDelay = msg.liveActuatorDelay\n+    liveDelay.steerActuatorDelay = self.lag\n+    liveDelay.isEstimated = self.block_avg.valid_blocks > 0\n+    liveDelay.validBlocks = self.block_avg.valid_blocks\n+    liveDelay.points = self.block_avg.values.tolist()\n+\n+    return msg\n+\n+  def handle_log(self, t, which, msg):\n+    if which == \"carControl\":\n+      self.lat_active = msg.latActive\n+    elif which == \"carState\":\n+      self.steering_pressed = msg.steeringPressed\n+      self.v_ego = msg.vEgo\n+    elif which == \"controlsState\":\n+      self.desired_curvature = msg.desiredCurvature\n+      self.steering_saturated = getattr(msg.lateralControlState, msg.lateralControlState.which()).saturated\n+    elif which == \"liveCalibration\":\n+      self.calibrator.feed_live_calib(msg)\n+    elif which == \"livePose\":\n+      device_pose = Pose.from_live_pose(msg)\n+      calibrated_pose = self.calibrator.build_calibrated_pose(device_pose)\n+      self.yaw_rate = calibrated_pose.angular_velocity.z\n+    self.t = t\n+\n+  def points_valid(self):\n+    return self.points.num_okay >= int(self.okay_window_sec / self.dt)\n+\n+  def update_points(self):\n+    la_desired = self.desired_curvature * self.v_ego * self.v_ego\n+    la_actual_pose = self.yaw_rate * self.v_ego\n+\n+    fast = self.v_ego > self.min_vego\n+    turning = np.abs(self.yaw_rate) >= self.min_yr\n+    okay = self.lat_active and not self.steering_pressed and not self.steering_saturated and fast and turning",
        "comment_created_at": "2025-03-27T20:39:47+00:00",
        "comment_author": "fredyshox",
        "comment_body": "implemented in [d00f784](https://github.com/commaai/openpilot/pull/34531/commits/d00f7841d5668efb54afd0af7b8e37615c988505)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2079847490",
    "pr_number": 35148,
    "pr_file": "system/micd.py",
    "created_at": "2025-05-08T14:34:37+00:00",
    "commented_code": "self.sound_pressure_weighted = 0\n     self.sound_pressure_level_weighted = 0\n \n+    self.lock = threading.Lock()  # Add a lock for thread safety",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2079847490",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 35148,
        "pr_file": "system/micd.py",
        "discussion_id": "2079847490",
        "commented_code": "@@ -52,12 +53,18 @@ def __init__(self):\n     self.sound_pressure_weighted = 0\n     self.sound_pressure_level_weighted = 0\n \n+    self.lock = threading.Lock()  # Add a lock for thread safety",
        "comment_created_at": "2025-05-08T14:34:37+00:00",
        "comment_author": "incognitojam",
        "comment_body": "```suggestion\r\n    self.lock = threading.Lock()\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2005992356",
    "pr_number": 34887,
    "pr_file": "system/athena/registration.py",
    "created_at": "2025-03-20T16:09:51+00:00",
    "commented_code": "backoff = min(backoff + 1, 15)\n         time.sleep(backoff)\n \n-      if time.monotonic() - start_time > 60 and show_spinner:\n-        spinner.update(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n+      if time.monotonic() - start_time > 60 and spinner:\n+        spinner.set_text(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n \n+    return dongle_id\n+\n+def register(show_spinner=False) -> str | None:\n+  dongle_id = _get_dongle_id()\n+  if not dongle_id:\n     if show_spinner:\n-      spinner.close()\n+      with ThreadPoolExecutor(max_workers=1) as executor:",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "2005992356",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34887,
        "pr_file": "system/athena/registration.py",
        "discussion_id": "2005992356",
        "commented_code": "@@ -89,14 +89,32 @@ def register(show_spinner=False) -> str | None:\n         backoff = min(backoff + 1, 15)\n         time.sleep(backoff)\n \n-      if time.monotonic() - start_time > 60 and show_spinner:\n-        spinner.update(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n+      if time.monotonic() - start_time > 60 and spinner:\n+        spinner.set_text(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n \n+    return dongle_id\n+\n+def register(show_spinner=False) -> str | None:\n+  dongle_id = _get_dongle_id()\n+  if not dongle_id:\n     if show_spinner:\n-      spinner.close()\n+      with ThreadPoolExecutor(max_workers=1) as executor:",
        "comment_created_at": "2025-03-20T16:09:51+00:00",
        "comment_author": "adeebshihadeh",
        "comment_body": "we shouldn't have to change the consumers of spinner/text. if we have to use the wrapper for that, that's fine",
        "pr_file_module": null
      },
      {
        "comment_id": "2006194653",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 34887,
        "pr_file": "system/athena/registration.py",
        "discussion_id": "2005992356",
        "commented_code": "@@ -89,14 +89,32 @@ def register(show_spinner=False) -> str | None:\n         backoff = min(backoff + 1, 15)\n         time.sleep(backoff)\n \n-      if time.monotonic() - start_time > 60 and show_spinner:\n-        spinner.update(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n+      if time.monotonic() - start_time > 60 and spinner:\n+        spinner.set_text(f\"registering device - serial: {serial}, IMEI: ({imei1}, {imei2})\")\n \n+    return dongle_id\n+\n+def register(show_spinner=False) -> str | None:\n+  dongle_id = _get_dongle_id()\n+  if not dongle_id:\n     if show_spinner:\n-      spinner.close()\n+      with ThreadPoolExecutor(max_workers=1) as executor:",
        "comment_created_at": "2025-03-20T18:08:50+00:00",
        "comment_author": "deanlee",
        "comment_body": "y, Moving the spinner into a separate thread is a better approach than moving the register process to a thread. This requires fewer changes to the original code while ensuring the spinner doesn't freeze or get blocked during the registration process.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1629288986",
    "pr_number": 32103,
    "pr_file": "selfdrive/pandad/pandad.py",
    "created_at": "2024-06-06T10:56:45+00:00",
    "commented_code": "def main() -> NoReturn:\n+  # override manager's immediate SystemExit to allow pandad to exit gracefully\n+  def signal_handler(signum, frame):\n+    nonlocal do_exit\n+    do_exit = True\n+    cloudlog.warning(f\"caught signal {signum}, exiting\")\n+\n+  do_exit = False\n+  signal.signal(signal.SIGTERM, signal_handler)\n+",
    "repo_full_name": "commaai/openpilot",
    "discussion_comments": [
      {
        "comment_id": "1629288986",
        "repo_full_name": "commaai/openpilot",
        "pr_number": 32103,
        "pr_file": "selfdrive/pandad/pandad.py",
        "discussion_id": "1629288986",
        "commented_code": "@@ -62,12 +63,21 @@ def flash_panda(panda_serial: str) -> Panda:\n \n \n def main() -> NoReturn:\n+  # override manager's immediate SystemExit to allow pandad to exit gracefully\n+  def signal_handler(signum, frame):\n+    nonlocal do_exit\n+    do_exit = True\n+    cloudlog.warning(f\"caught signal {signum}, exiting\")\n+\n+  do_exit = False\n+  signal.signal(signal.SIGTERM, signal_handler)\n+",
        "comment_created_at": "2024-06-06T10:56:45+00:00",
        "comment_author": "sshane",
        "comment_body": "When creating a [new Python process with `multiprocessing.Process`](https://github.com/commaai/openpilot/blob/e8857a6713db6b8b3b8cd67aca1b8c046a4dccd9/system/manager/process.py#L224), it inherits the parent's signal handler. For manager, that is to cause a `SystemExit` immediately, which SIGKILLs pandad.cc before it has a chance to react to the SIGTERM and close the relay.\r\n\r\nhttps://github.com/commaai/openpilot/blob/e8857a6713db6b8b3b8cd67aca1b8c046a4dccd9/system/manager/manager.py#L183-L184",
        "pr_file_module": null
      }
    ]
  }
]