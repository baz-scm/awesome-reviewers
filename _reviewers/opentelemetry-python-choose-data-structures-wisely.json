[
  {
    "discussion_id": "378232150",
    "pr_number": 378,
    "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
    "created_at": "2020-02-12T12:54:39+00:00",
    "commented_code": "+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "378232150",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378232150",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
        "comment_created_at": "2020-02-12T12:54:39+00:00",
        "comment_author": "mauriciovasquezbernal",
        "comment_body": "I feel we should use a more specialized type for it. I think [deque](https://docs.python.org/3.8/library/collections.html#collections.deque) is the right choice for this, it's thread safe optimized list. `add_metrics_data` could use `appendleft` while `collect` could `pop` elements.",
        "pr_file_module": null
      },
      {
        "comment_id": "378394545",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378232150",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
        "comment_created_at": "2020-02-12T17:16:02+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Don't you mean `add_metrics_data` could use `append` while collect could use `popleft`?",
        "pr_file_module": null
      },
      {
        "comment_id": "378424225",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378232150",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
        "comment_created_at": "2020-02-12T18:11:15+00:00",
        "comment_author": "mauriciovasquezbernal",
        "comment_body": "What's the difference between using `appendleft` & `pop` vs `append` & `popleft`?",
        "pr_file_module": null
      },
      {
        "comment_id": "378426684",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378232150",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
        "comment_created_at": "2020-02-12T18:16:03+00:00",
        "comment_author": "ocelotl",
        "comment_body": "I mean, is just a matter of keeping what the current implementation is doing right now. `add_metrics_data` appends to the right of `self._metrics_to_export` and collect is \"popping\" (actually, it is calling `remove`) from left to right.",
        "pr_file_module": null
      },
      {
        "comment_id": "378544182",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378232150",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []",
        "comment_created_at": "2020-02-12T22:14:41+00:00",
        "comment_author": "hectorhdzg",
        "comment_body": "Added append and popleft let me know if there are strong opinions about this",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "378391516",
    "pr_number": 378,
    "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
    "created_at": "2020-02-12T17:10:41+00:00",
    "commented_code": "+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []\n+\n+    def add_metrics_data(self, metric_records: Sequence[MetricRecord]):\n+        self._metrics_to_export.append(metric_records)\n+\n+    def collect(self):\n+        \"\"\"Collect fetches the metrics from OpenTelemetry\n+        and delivers them as Prometheus Metrics.\n+        Collect is invoked every time a prometheus.Gatherer is run\n+        for example when the HTTP endpoint is invoked by Prometheus.\n+        \"\"\"\n+\n+        for metric_batch in self._metrics_to_export:\n+            for metric_record in metric_batch:\n+                prometheus_metric = self._translate_to_prometheus(\n+                    metric_record\n+                )\n+                if prometheus_metric:\n+                    yield prometheus_metric\n+            self._metrics_to_export.remove(metric_batch)",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "378391516",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378391516",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []\n+\n+    def add_metrics_data(self, metric_records: Sequence[MetricRecord]):\n+        self._metrics_to_export.append(metric_records)\n+\n+    def collect(self):\n+        \"\"\"Collect fetches the metrics from OpenTelemetry\n+        and delivers them as Prometheus Metrics.\n+        Collect is invoked every time a prometheus.Gatherer is run\n+        for example when the HTTP endpoint is invoked by Prometheus.\n+        \"\"\"\n+\n+        for metric_batch in self._metrics_to_export:\n+            for metric_record in metric_batch:\n+                prometheus_metric = self._translate_to_prometheus(\n+                    metric_record\n+                )\n+                if prometheus_metric:\n+                    yield prometheus_metric\n+            self._metrics_to_export.remove(metric_batch)",
        "comment_created_at": "2020-02-12T17:10:41+00:00",
        "comment_author": "ocelotl",
        "comment_body": "This specific piece of code probably works fine, but modifying a sequence while iterating over it can lead to very weird bugs.",
        "pr_file_module": null
      },
      {
        "comment_id": "378398297",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378391516",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []\n+\n+    def add_metrics_data(self, metric_records: Sequence[MetricRecord]):\n+        self._metrics_to_export.append(metric_records)\n+\n+    def collect(self):\n+        \"\"\"Collect fetches the metrics from OpenTelemetry\n+        and delivers them as Prometheus Metrics.\n+        Collect is invoked every time a prometheus.Gatherer is run\n+        for example when the HTTP endpoint is invoked by Prometheus.\n+        \"\"\"\n+\n+        for metric_batch in self._metrics_to_export:\n+            for metric_record in metric_batch:\n+                prometheus_metric = self._translate_to_prometheus(\n+                    metric_record\n+                )\n+                if prometheus_metric:\n+                    yield prometheus_metric\n+            self._metrics_to_export.remove(metric_batch)",
        "comment_created_at": "2020-02-12T17:22:24+00:00",
        "comment_author": "ocelotl",
        "comment_body": "I suggest using a `while` here:\r\n```python\r\nwhile self._metrics_to_export:\r\n    for metric_record in self._metrics_to_export.popleft():\r\n        ...\r\n    ...\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1733381381",
    "pr_number": 4094,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
    "created_at": "2024-08-27T19:00:47+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (\n+            {\n+                k: v\n+                for k, v in self.__attributes.items()\n+                if k not in point_attributes\n+            }\n+            if self.__attributes\n+            else None\n+        )\n+\n+        exemplar = Exemplar(\n+            current_attributes,\n+            self.__value,\n+            self.__time_unix_nano,\n+            self.__span_id,\n+            self.__trace_id,\n+        )\n+        self.__reset()\n+        return exemplar\n+\n+    def __reset(self) -> None:\n+        self.__value = 0\n+        self.__attributes = {}\n+        self.__time_unix_nano = 0\n+        self.__span_id = None\n+        self.__trace_id = None\n+        self.__offered = False\n+\n+\n+class FixedSizeExemplarReservoirABC(ExemplarReservoir):\n+    \"\"\"Abstract class for a reservoir with fixed size.\"\"\"\n+\n+    def __init__(self, size: int, **kwargs) -> None:\n+        super().__init__(**kwargs)\n+        self._size: int = size\n+        self._reservoir_storage: list[ExemplarBucket] = [\n+            ExemplarBucket() for _ in range(self._size)\n+        ]\n+\n+    def maxSize(self) -> int:\n+        \"\"\"Reservoir maximal size\"\"\"\n+        return self._size\n+\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        exemplars = filter(\n+            lambda e: e is not None,\n+            map(\n+                lambda bucket: bucket.collect(point_attributes),\n+                self._reservoir_storage,\n+            ),\n+        )\n+        self._reset()\n+        return [*exemplars]\n+\n+    def _reset(self) -> None:\n+        \"\"\"Reset the reservoir.\"\"\"\n+        pass\n+\n+\n+class SimpleFixedSizeExemplarReservoir(FixedSizeExemplarReservoirABC):\n+    \"\"\"This reservoir uses an uniformly-weighted sampling algorithm based on the number\n+    of samples the reservoir has seen so far to determine if the offered measurements\n+    should be sampled.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#simplefixedsizeexemplarreservoir\n+    \"\"\"\n+\n+    def __init__(self, size: int = 1, **kwargs) -> None:\n+        super().__init__(size, **kwargs)\n+        self._measurements_seen: int = 0\n+\n+    def _reset(self) -> None:\n+        super()._reset()\n+        self._measurements_seen = 0\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        index = self._find_bucket_index(value, time_unix_nano, attributes, ctx)\n+        if index != -1:\n+            self._reservoir_storage[index].offer(\n+                value, time_unix_nano, attributes, ctx\n+            )\n+\n+    def _find_bucket_index(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> int:\n+        self._measurements_seen += 1",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1733381381",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4094,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
        "discussion_id": "1733381381",
        "commented_code": "@@ -0,0 +1,263 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (\n+            {\n+                k: v\n+                for k, v in self.__attributes.items()\n+                if k not in point_attributes\n+            }\n+            if self.__attributes\n+            else None\n+        )\n+\n+        exemplar = Exemplar(\n+            current_attributes,\n+            self.__value,\n+            self.__time_unix_nano,\n+            self.__span_id,\n+            self.__trace_id,\n+        )\n+        self.__reset()\n+        return exemplar\n+\n+    def __reset(self) -> None:\n+        self.__value = 0\n+        self.__attributes = {}\n+        self.__time_unix_nano = 0\n+        self.__span_id = None\n+        self.__trace_id = None\n+        self.__offered = False\n+\n+\n+class FixedSizeExemplarReservoirABC(ExemplarReservoir):\n+    \"\"\"Abstract class for a reservoir with fixed size.\"\"\"\n+\n+    def __init__(self, size: int, **kwargs) -> None:\n+        super().__init__(**kwargs)\n+        self._size: int = size\n+        self._reservoir_storage: list[ExemplarBucket] = [\n+            ExemplarBucket() for _ in range(self._size)\n+        ]\n+\n+    def maxSize(self) -> int:\n+        \"\"\"Reservoir maximal size\"\"\"\n+        return self._size\n+\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        exemplars = filter(\n+            lambda e: e is not None,\n+            map(\n+                lambda bucket: bucket.collect(point_attributes),\n+                self._reservoir_storage,\n+            ),\n+        )\n+        self._reset()\n+        return [*exemplars]\n+\n+    def _reset(self) -> None:\n+        \"\"\"Reset the reservoir.\"\"\"\n+        pass\n+\n+\n+class SimpleFixedSizeExemplarReservoir(FixedSizeExemplarReservoirABC):\n+    \"\"\"This reservoir uses an uniformly-weighted sampling algorithm based on the number\n+    of samples the reservoir has seen so far to determine if the offered measurements\n+    should be sampled.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#simplefixedsizeexemplarreservoir\n+    \"\"\"\n+\n+    def __init__(self, size: int = 1, **kwargs) -> None:\n+        super().__init__(size, **kwargs)\n+        self._measurements_seen: int = 0\n+\n+    def _reset(self) -> None:\n+        super()._reset()\n+        self._measurements_seen = 0\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        index = self._find_bucket_index(value, time_unix_nano, attributes, ctx)\n+        if index != -1:\n+            self._reservoir_storage[index].offer(\n+                value, time_unix_nano, attributes, ctx\n+            )\n+\n+    def _find_bucket_index(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> int:\n+        self._measurements_seen += 1",
        "comment_created_at": "2024-08-27T19:00:47+00:00",
        "comment_author": "lzchen",
        "comment_body": "Should the increment to `measurements_seen` occur AFTER finding the index? Otherwise we tend to skip the first bucket?",
        "pr_file_module": null
      },
      {
        "comment_id": "1740601888",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4094,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
        "discussion_id": "1733381381",
        "commented_code": "@@ -0,0 +1,263 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (\n+            {\n+                k: v\n+                for k, v in self.__attributes.items()\n+                if k not in point_attributes\n+            }\n+            if self.__attributes\n+            else None\n+        )\n+\n+        exemplar = Exemplar(\n+            current_attributes,\n+            self.__value,\n+            self.__time_unix_nano,\n+            self.__span_id,\n+            self.__trace_id,\n+        )\n+        self.__reset()\n+        return exemplar\n+\n+    def __reset(self) -> None:\n+        self.__value = 0\n+        self.__attributes = {}\n+        self.__time_unix_nano = 0\n+        self.__span_id = None\n+        self.__trace_id = None\n+        self.__offered = False\n+\n+\n+class FixedSizeExemplarReservoirABC(ExemplarReservoir):\n+    \"\"\"Abstract class for a reservoir with fixed size.\"\"\"\n+\n+    def __init__(self, size: int, **kwargs) -> None:\n+        super().__init__(**kwargs)\n+        self._size: int = size\n+        self._reservoir_storage: list[ExemplarBucket] = [\n+            ExemplarBucket() for _ in range(self._size)\n+        ]\n+\n+    def maxSize(self) -> int:\n+        \"\"\"Reservoir maximal size\"\"\"\n+        return self._size\n+\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        exemplars = filter(\n+            lambda e: e is not None,\n+            map(\n+                lambda bucket: bucket.collect(point_attributes),\n+                self._reservoir_storage,\n+            ),\n+        )\n+        self._reset()\n+        return [*exemplars]\n+\n+    def _reset(self) -> None:\n+        \"\"\"Reset the reservoir.\"\"\"\n+        pass\n+\n+\n+class SimpleFixedSizeExemplarReservoir(FixedSizeExemplarReservoirABC):\n+    \"\"\"This reservoir uses an uniformly-weighted sampling algorithm based on the number\n+    of samples the reservoir has seen so far to determine if the offered measurements\n+    should be sampled.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#simplefixedsizeexemplarreservoir\n+    \"\"\"\n+\n+    def __init__(self, size: int = 1, **kwargs) -> None:\n+        super().__init__(size, **kwargs)\n+        self._measurements_seen: int = 0\n+\n+    def _reset(self) -> None:\n+        super()._reset()\n+        self._measurements_seen = 0\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        index = self._find_bucket_index(value, time_unix_nano, attributes, ctx)\n+        if index != -1:\n+            self._reservoir_storage[index].offer(\n+                value, time_unix_nano, attributes, ctx\n+            )\n+\n+    def _find_bucket_index(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> int:\n+        self._measurements_seen += 1",
        "comment_created_at": "2024-09-02T09:25:00+00:00",
        "comment_author": "fcollonval",
        "comment_body": "Actually not because [`randrange`](https://docs.python.org/3/library/random.html#random.randrange) exclude the stop value. Therefore if we don't increment first, we try to execute `randrange(0, 0)` resulting in an exception:\r\n\r\n```sh\r\nValueError: empty range for randrange() (0, 0, 0)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1532866111",
    "pr_number": 3798,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exponential_histogram/buckets.py",
    "created_at": "2024-03-20T21:02:19+00:00",
    "commented_code": "def counts(self):\n         return self._counts\n \n+    def get_offset_counts(self):\n+        bias = self.__index_base - self.__index_start\n+        return self._counts[-bias:] + self._counts[:-bias]",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1532866111",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3798,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exponential_histogram/buckets.py",
        "discussion_id": "1532866111",
        "commented_code": "@@ -73,6 +73,10 @@ def index_base(self, value: int) -> None:\n     def counts(self):\n         return self._counts\n \n+    def get_offset_counts(self):\n+        bias = self.__index_base - self.__index_start\n+        return self._counts[-bias:] + self._counts[:-bias]",
        "comment_created_at": "2024-03-20T21:02:19+00:00",
        "comment_author": "euroelessar",
        "comment_body": "collected result should be a regular list, not a circular buffer, so introduce a new method for it",
        "pr_file_module": null
      }
    ]
  }
]