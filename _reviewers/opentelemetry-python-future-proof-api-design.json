[
  {
    "discussion_id": "347932725",
    "pr_number": 297,
    "pr_file": "opentelemetry-api/src/opentelemetry/trace/status.py",
    "created_at": "2019-11-19T13:50:55+00:00",
    "commented_code": "# See the License for the specific language governing permissions and\n # limitations under the License.\n \n-import enum\n-import typing\n-\n-\n-class StatusCanonicalCode(enum.Enum):\n-    \"\"\"Represents the canonical set of status codes of a finished Span.\"\"\"\n-\n-    OK = 0\n-    \"\"\"Not an error, returned on success.\"\"\"\n-\n-    CANCELLED = 1\n-    \"\"\"The operation was cancelled, typically by the caller.\"\"\"\n-\n-    UNKNOWN = 2\n-    \"\"\"Unknown error.\n-\n-    For example, this error may be returned when a Status value received from\n-    another address space belongs to an error space that is not known in this\n-    address space. Also errors raised by APIs that do not return enough error\n-    information may be converted to this error.\n-    \"\"\"\n-\n-    INVALID_ARGUMENT = 3\n-    \"\"\"The client specified an invalid argument.\n-\n-    Note that this differs from FAILED_PRECONDITION. INVALID_ARGUMENT indicates\n-    arguments that are problematic regardless of the state of the system (e.g.,\n-    a malformed file name).\n-    \"\"\"\n-\n-    DEADLINE_EXCEEDED = 4\n-    \"\"\"The deadline expired before the operation could complete.\n-\n-    For operations that change the state of the system, this error may be\n-    returned even if the operation has completed successfully. For example, a\n-    successful response from a server could have been delayed long\n-    \"\"\"\n-\n-    NOT_FOUND = 5\n-    \"\"\"Some requested entity (e.g., file or directory) was not found.\n-\n-    Note to server developers: if a request is denied for an entire class of\n-    users, such as gradual feature rollout or undocumented whitelist, NOT_FOUND\n-    may be used. If a request is denied for some users within a class of users,\n-    such as user-based access control, PERMISSION_DENIED must be used.\n-    \"\"\"\n-\n-    ALREADY_EXISTS = 6\n-    \"\"\"The entity that a client attempted to create (e.g., file or directory)\n-    already exists.\n-    \"\"\"\n-\n-    PERMISSION_DENIED = 7\n-    \"\"\"The caller does not have permission to execute the specified operation.\n-\n-    PERMISSION_DENIED must not be used for rejections caused by exhausting some\n-    resource (use RESOURCE_EXHAUSTED instead for those errors).\n-    PERMISSION_DENIED must not be used if the caller can not be identified (use\n-    UNAUTHENTICATED instead for those errors). This error code does not imply\n-    the request is valid or the requested entity exists or satisfies other\n-    pre-conditions.\n-    \"\"\"\n-\n-    RESOURCE_EXHAUSTED = 8\n-    \"\"\"Some resource has been exhausted, perhaps a per-user quota, or perhaps\n-    the entire file system is out of space.\n-    \"\"\"\n-\n-    FAILED_PRECONDITION = 9\n-    \"\"\"The operation was rejected because the system is not in a state required\n-    for the operation's execution.\n-\n-    For example, the directory to be deleted is non-empty, an rmdir operation\n-    is applied to a non-directory, etc. Service implementors can use the\n-    following guidelines to decide between FAILED_PRECONDITION, ABORTED, and\n-    UNAVAILABLE:\n-\n-        (a) Use UNAVAILABLE if the client can retry just the failing call.\n-        (b) Use ABORTED if the client should retry at a higher level (e.g.,\n-            when a client-specified test-and-set fails, indicating the client\n-            should restart a read-modify-write sequence).\n-        (c) Use FAILED_PRECONDITION if the client should not retry until the\n-            system state has been explicitly fixed.\n-\n-    E.g., if an \"rmdir\" fails because the directory is non-empty,\n-    FAILED_PRECONDITION should be returned since the client should not retry\n-    unless the files are deleted from the directory.\n-    \"\"\"\n-\n-    ABORTED = 10\n-    \"\"\"The operation was aborted, typically due to a concurrency issue such as a\n-    sequencer check failure or transaction abort.\n-\n-    See the guidelines above for deciding between FAILED_PRECONDITION, ABORTED,\n-    and UNAVAILABLE.\n-    \"\"\"\n-\n-    OUT_OF_RANGE = 11\n-    \"\"\"The operation was attempted past the valid range.\n-\n-    E.g., seeking or reading past end-of-file. Unlike INVALID_ARGUMENT, this\n-    error indicates a problem that may be fixed if the system state changes.\n-    For example, a 32-bit file system will generate INVALID_ARGUMENT if asked\n-    to read at an offset that is not in the range [0,2^32-1],but it will\n-    generate OUT_OF_RANGE if asked to read from an offset past the current file\n-    size. There is a fair bit of overlap between FAILED_PRECONDITION and\n-    OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n-    when it applies so that callers who are iterating through a space can\n-    easily look for an OUT_OF_RANGE error to detect when they are done.\n-    \"\"\"\n-\n-    UNIMPLEMENTED = 12\n-    \"\"\"The operation is not implemented or is not supported/enabled in this\n-    service.\n-    \"\"\"\n-\n-    INTERNAL = 13\n-    \"\"\"Internal errors.\n-\n-    This means that some invariants expected by the underlying system have been\n-    broken. This error code is reserved for serious errors.\n-    \"\"\"\n-\n-    UNAVAILABLE = 14\n-    \"\"\"The service is currently unavailable.\n-\n-    This is most likely a transient condition, which can be corrected by\n-    retrying with a backoff.  Note that it is not always safe to retry\n-    non-idempotent operations.\n-    \"\"\"\n-\n-    DATA_LOSS = 15\n-    \"\"\"Unrecoverable data loss or corruption.\"\"\"\n-\n-    UNAUTHENTICATED = 16\n-    \"\"\"The request does not have valid authentication credentials for the\n-    operation.\n-    \"\"\"\n-\n-\n-class Status:\n-    \"\"\"Represents the status of a finished Span.\n-\n-    Args:\n-        canonical_code: The canonical status code that describes the result\n-            status of the operation.\n-        description: An optional description of the status.\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        canonical_code: \"StatusCanonicalCode\" = StatusCanonicalCode.OK,\n-        description: typing.Optional[str] = None,\n-    ):\n-        self._canonical_code = canonical_code\n-        self._description = description\n+from enum import Enum",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "347932725",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/status.py",
        "discussion_id": "347932725",
        "commented_code": "@@ -12,174 +12,224 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-import enum\n-import typing\n-\n-\n-class StatusCanonicalCode(enum.Enum):\n-    \"\"\"Represents the canonical set of status codes of a finished Span.\"\"\"\n-\n-    OK = 0\n-    \"\"\"Not an error, returned on success.\"\"\"\n-\n-    CANCELLED = 1\n-    \"\"\"The operation was cancelled, typically by the caller.\"\"\"\n-\n-    UNKNOWN = 2\n-    \"\"\"Unknown error.\n-\n-    For example, this error may be returned when a Status value received from\n-    another address space belongs to an error space that is not known in this\n-    address space. Also errors raised by APIs that do not return enough error\n-    information may be converted to this error.\n-    \"\"\"\n-\n-    INVALID_ARGUMENT = 3\n-    \"\"\"The client specified an invalid argument.\n-\n-    Note that this differs from FAILED_PRECONDITION. INVALID_ARGUMENT indicates\n-    arguments that are problematic regardless of the state of the system (e.g.,\n-    a malformed file name).\n-    \"\"\"\n-\n-    DEADLINE_EXCEEDED = 4\n-    \"\"\"The deadline expired before the operation could complete.\n-\n-    For operations that change the state of the system, this error may be\n-    returned even if the operation has completed successfully. For example, a\n-    successful response from a server could have been delayed long\n-    \"\"\"\n-\n-    NOT_FOUND = 5\n-    \"\"\"Some requested entity (e.g., file or directory) was not found.\n-\n-    Note to server developers: if a request is denied for an entire class of\n-    users, such as gradual feature rollout or undocumented whitelist, NOT_FOUND\n-    may be used. If a request is denied for some users within a class of users,\n-    such as user-based access control, PERMISSION_DENIED must be used.\n-    \"\"\"\n-\n-    ALREADY_EXISTS = 6\n-    \"\"\"The entity that a client attempted to create (e.g., file or directory)\n-    already exists.\n-    \"\"\"\n-\n-    PERMISSION_DENIED = 7\n-    \"\"\"The caller does not have permission to execute the specified operation.\n-\n-    PERMISSION_DENIED must not be used for rejections caused by exhausting some\n-    resource (use RESOURCE_EXHAUSTED instead for those errors).\n-    PERMISSION_DENIED must not be used if the caller can not be identified (use\n-    UNAUTHENTICATED instead for those errors). This error code does not imply\n-    the request is valid or the requested entity exists or satisfies other\n-    pre-conditions.\n-    \"\"\"\n-\n-    RESOURCE_EXHAUSTED = 8\n-    \"\"\"Some resource has been exhausted, perhaps a per-user quota, or perhaps\n-    the entire file system is out of space.\n-    \"\"\"\n-\n-    FAILED_PRECONDITION = 9\n-    \"\"\"The operation was rejected because the system is not in a state required\n-    for the operation's execution.\n-\n-    For example, the directory to be deleted is non-empty, an rmdir operation\n-    is applied to a non-directory, etc. Service implementors can use the\n-    following guidelines to decide between FAILED_PRECONDITION, ABORTED, and\n-    UNAVAILABLE:\n-\n-        (a) Use UNAVAILABLE if the client can retry just the failing call.\n-        (b) Use ABORTED if the client should retry at a higher level (e.g.,\n-            when a client-specified test-and-set fails, indicating the client\n-            should restart a read-modify-write sequence).\n-        (c) Use FAILED_PRECONDITION if the client should not retry until the\n-            system state has been explicitly fixed.\n-\n-    E.g., if an \"rmdir\" fails because the directory is non-empty,\n-    FAILED_PRECONDITION should be returned since the client should not retry\n-    unless the files are deleted from the directory.\n-    \"\"\"\n-\n-    ABORTED = 10\n-    \"\"\"The operation was aborted, typically due to a concurrency issue such as a\n-    sequencer check failure or transaction abort.\n-\n-    See the guidelines above for deciding between FAILED_PRECONDITION, ABORTED,\n-    and UNAVAILABLE.\n-    \"\"\"\n-\n-    OUT_OF_RANGE = 11\n-    \"\"\"The operation was attempted past the valid range.\n-\n-    E.g., seeking or reading past end-of-file. Unlike INVALID_ARGUMENT, this\n-    error indicates a problem that may be fixed if the system state changes.\n-    For example, a 32-bit file system will generate INVALID_ARGUMENT if asked\n-    to read at an offset that is not in the range [0,2^32-1],but it will\n-    generate OUT_OF_RANGE if asked to read from an offset past the current file\n-    size. There is a fair bit of overlap between FAILED_PRECONDITION and\n-    OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n-    when it applies so that callers who are iterating through a space can\n-    easily look for an OUT_OF_RANGE error to detect when they are done.\n-    \"\"\"\n-\n-    UNIMPLEMENTED = 12\n-    \"\"\"The operation is not implemented or is not supported/enabled in this\n-    service.\n-    \"\"\"\n-\n-    INTERNAL = 13\n-    \"\"\"Internal errors.\n-\n-    This means that some invariants expected by the underlying system have been\n-    broken. This error code is reserved for serious errors.\n-    \"\"\"\n-\n-    UNAVAILABLE = 14\n-    \"\"\"The service is currently unavailable.\n-\n-    This is most likely a transient condition, which can be corrected by\n-    retrying with a backoff.  Note that it is not always safe to retry\n-    non-idempotent operations.\n-    \"\"\"\n-\n-    DATA_LOSS = 15\n-    \"\"\"Unrecoverable data loss or corruption.\"\"\"\n-\n-    UNAUTHENTICATED = 16\n-    \"\"\"The request does not have valid authentication credentials for the\n-    operation.\n-    \"\"\"\n-\n-\n-class Status:\n-    \"\"\"Represents the status of a finished Span.\n-\n-    Args:\n-        canonical_code: The canonical status code that describes the result\n-            status of the operation.\n-        description: An optional description of the status.\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        canonical_code: \"StatusCanonicalCode\" = StatusCanonicalCode.OK,\n-        description: typing.Optional[str] = None,\n-    ):\n-        self._canonical_code = canonical_code\n-        self._description = description\n+from enum import Enum",
        "comment_created_at": "2019-11-19T13:50:55+00:00",
        "comment_author": "Oberon00",
        "comment_body": "Please don't change the whole Status API in a PR that should just set a certain status value in certain cases.\r\n\r\nIn particular, there is no 1:1 mapping between description and status code (e.g. see the pymongo integration which makes good use of the status description to add additional information that could not be inferred from the status code alone). I have no idea why everyone seems to think that: https://github.com/open-telemetry/opentelemetry-python/pull/213#discussion_r333791367\r\n\r\n> Description is a free-form text that can and should be specified by the user. For example I could create a status with \"NOT_FOUND\" and Text \"open: The system could not find the specified file\" or \"HTTP 404: Username does not exist\".",
        "pr_file_module": null
      },
      {
        "comment_id": "348839892",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/status.py",
        "discussion_id": "347932725",
        "commented_code": "@@ -12,174 +12,224 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n-import enum\n-import typing\n-\n-\n-class StatusCanonicalCode(enum.Enum):\n-    \"\"\"Represents the canonical set of status codes of a finished Span.\"\"\"\n-\n-    OK = 0\n-    \"\"\"Not an error, returned on success.\"\"\"\n-\n-    CANCELLED = 1\n-    \"\"\"The operation was cancelled, typically by the caller.\"\"\"\n-\n-    UNKNOWN = 2\n-    \"\"\"Unknown error.\n-\n-    For example, this error may be returned when a Status value received from\n-    another address space belongs to an error space that is not known in this\n-    address space. Also errors raised by APIs that do not return enough error\n-    information may be converted to this error.\n-    \"\"\"\n-\n-    INVALID_ARGUMENT = 3\n-    \"\"\"The client specified an invalid argument.\n-\n-    Note that this differs from FAILED_PRECONDITION. INVALID_ARGUMENT indicates\n-    arguments that are problematic regardless of the state of the system (e.g.,\n-    a malformed file name).\n-    \"\"\"\n-\n-    DEADLINE_EXCEEDED = 4\n-    \"\"\"The deadline expired before the operation could complete.\n-\n-    For operations that change the state of the system, this error may be\n-    returned even if the operation has completed successfully. For example, a\n-    successful response from a server could have been delayed long\n-    \"\"\"\n-\n-    NOT_FOUND = 5\n-    \"\"\"Some requested entity (e.g., file or directory) was not found.\n-\n-    Note to server developers: if a request is denied for an entire class of\n-    users, such as gradual feature rollout or undocumented whitelist, NOT_FOUND\n-    may be used. If a request is denied for some users within a class of users,\n-    such as user-based access control, PERMISSION_DENIED must be used.\n-    \"\"\"\n-\n-    ALREADY_EXISTS = 6\n-    \"\"\"The entity that a client attempted to create (e.g., file or directory)\n-    already exists.\n-    \"\"\"\n-\n-    PERMISSION_DENIED = 7\n-    \"\"\"The caller does not have permission to execute the specified operation.\n-\n-    PERMISSION_DENIED must not be used for rejections caused by exhausting some\n-    resource (use RESOURCE_EXHAUSTED instead for those errors).\n-    PERMISSION_DENIED must not be used if the caller can not be identified (use\n-    UNAUTHENTICATED instead for those errors). This error code does not imply\n-    the request is valid or the requested entity exists or satisfies other\n-    pre-conditions.\n-    \"\"\"\n-\n-    RESOURCE_EXHAUSTED = 8\n-    \"\"\"Some resource has been exhausted, perhaps a per-user quota, or perhaps\n-    the entire file system is out of space.\n-    \"\"\"\n-\n-    FAILED_PRECONDITION = 9\n-    \"\"\"The operation was rejected because the system is not in a state required\n-    for the operation's execution.\n-\n-    For example, the directory to be deleted is non-empty, an rmdir operation\n-    is applied to a non-directory, etc. Service implementors can use the\n-    following guidelines to decide between FAILED_PRECONDITION, ABORTED, and\n-    UNAVAILABLE:\n-\n-        (a) Use UNAVAILABLE if the client can retry just the failing call.\n-        (b) Use ABORTED if the client should retry at a higher level (e.g.,\n-            when a client-specified test-and-set fails, indicating the client\n-            should restart a read-modify-write sequence).\n-        (c) Use FAILED_PRECONDITION if the client should not retry until the\n-            system state has been explicitly fixed.\n-\n-    E.g., if an \"rmdir\" fails because the directory is non-empty,\n-    FAILED_PRECONDITION should be returned since the client should not retry\n-    unless the files are deleted from the directory.\n-    \"\"\"\n-\n-    ABORTED = 10\n-    \"\"\"The operation was aborted, typically due to a concurrency issue such as a\n-    sequencer check failure or transaction abort.\n-\n-    See the guidelines above for deciding between FAILED_PRECONDITION, ABORTED,\n-    and UNAVAILABLE.\n-    \"\"\"\n-\n-    OUT_OF_RANGE = 11\n-    \"\"\"The operation was attempted past the valid range.\n-\n-    E.g., seeking or reading past end-of-file. Unlike INVALID_ARGUMENT, this\n-    error indicates a problem that may be fixed if the system state changes.\n-    For example, a 32-bit file system will generate INVALID_ARGUMENT if asked\n-    to read at an offset that is not in the range [0,2^32-1],but it will\n-    generate OUT_OF_RANGE if asked to read from an offset past the current file\n-    size. There is a fair bit of overlap between FAILED_PRECONDITION and\n-    OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n-    when it applies so that callers who are iterating through a space can\n-    easily look for an OUT_OF_RANGE error to detect when they are done.\n-    \"\"\"\n-\n-    UNIMPLEMENTED = 12\n-    \"\"\"The operation is not implemented or is not supported/enabled in this\n-    service.\n-    \"\"\"\n-\n-    INTERNAL = 13\n-    \"\"\"Internal errors.\n-\n-    This means that some invariants expected by the underlying system have been\n-    broken. This error code is reserved for serious errors.\n-    \"\"\"\n-\n-    UNAVAILABLE = 14\n-    \"\"\"The service is currently unavailable.\n-\n-    This is most likely a transient condition, which can be corrected by\n-    retrying with a backoff.  Note that it is not always safe to retry\n-    non-idempotent operations.\n-    \"\"\"\n-\n-    DATA_LOSS = 15\n-    \"\"\"Unrecoverable data loss or corruption.\"\"\"\n-\n-    UNAUTHENTICATED = 16\n-    \"\"\"The request does not have valid authentication credentials for the\n-    operation.\n-    \"\"\"\n-\n-\n-class Status:\n-    \"\"\"Represents the status of a finished Span.\n-\n-    Args:\n-        canonical_code: The canonical status code that describes the result\n-            status of the operation.\n-        description: An optional description of the status.\n-    \"\"\"\n-\n-    def __init__(\n-        self,\n-        canonical_code: \"StatusCanonicalCode\" = StatusCanonicalCode.OK,\n-        description: typing.Optional[str] = None,\n-    ):\n-        self._canonical_code = canonical_code\n-        self._description = description\n+from enum import Enum",
        "comment_created_at": "2019-11-21T00:14:36+00:00",
        "comment_author": "ocelotl",
        "comment_body": "All right, I left the existing comments as documentation for the `XYZStatus` classes and introduced again the description field.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126904834",
    "pr_number": 4597,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
    "created_at": "2025-06-04T15:35:39+00:00",
    "commented_code": "pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "2126904834",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4597,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
        "discussion_id": "2126904834",
        "commented_code": "@@ -172,6 +176,24 @@ class LogRecord(APILogRecord):\n     pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
        "comment_created_at": "2025-06-04T15:35:39+00:00",
        "comment_author": "aabmass",
        "comment_body": "LGTM! I think we want to make the same change in the API LogRecord",
        "pr_file_module": null
      },
      {
        "comment_id": "2129398199",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4597,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
        "discussion_id": "2126904834",
        "commented_code": "@@ -172,6 +176,24 @@ class LogRecord(APILogRecord):\n     pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
        "comment_created_at": "2025-06-05T17:11:04+00:00",
        "comment_author": "tammy-baylis-swi",
        "comment_body": "Yes you're right. Updated in [172f1c5](https://github.com/open-telemetry/opentelemetry-python/pull/4597/commits/172f1c5bb19749cb8cbad47f678a0967e0c968c4) but [pyright typecheck fails](https://github.com/open-telemetry/opentelemetry-python/actions/runs/15472927464/job/43561662219?pr=4597). Will have a look",
        "pr_file_module": null
      },
      {
        "comment_id": "2129511321",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4597,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
        "discussion_id": "2126904834",
        "commented_code": "@@ -172,6 +176,24 @@ class LogRecord(APILogRecord):\n     pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
        "comment_created_at": "2025-06-05T17:35:02+00:00",
        "comment_author": "tammy-baylis-swi",
        "comment_body": "Addressed the typecheck fail by forcing kwargs-only init of LogRecord (API) in [84c6b33](https://github.com/open-telemetry/opentelemetry-python/pull/4597/commits/84c6b335841a51772d4830c946e044244d692b31) -- what do we think? Is this breaking?\r\n\r\nThe code that does init of LogRecord is SDK's [LoggingHandler._translate](https://github.com/open-telemetry/opentelemetry-python/blob/84c6b335841a51772d4830c946e044244d692b31/opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py#L598-L609) and [Event SDK](https://github.com/open-telemetry/opentelemetry-python/blob/1fb512722b357e3b1f660683077590496d022dfa/opentelemetry-sdk/src/opentelemetry/sdk/_events/__init__.py#L53-L64), which use kwargs. [Grep of LogRecord](https://github.com/search?q=repo%3Aopen-telemetry%2Fopentelemetry-python+logrecord%28&type=code) suggests the other inits are in the unit tests, and all tests pass.",
        "pr_file_module": null
      },
      {
        "comment_id": "2129630979",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4597,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
        "discussion_id": "2126904834",
        "commented_code": "@@ -172,6 +176,24 @@ class LogRecord(APILogRecord):\n     pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
        "comment_created_at": "2025-06-05T18:01:03+00:00",
        "comment_author": "tammy-baylis-swi",
        "comment_body": "I've also installed this change into my vendor's setup and Log signals are still exporting.",
        "pr_file_module": null
      },
      {
        "comment_id": "2130398536",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4597,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/__init__.py",
        "discussion_id": "2126904834",
        "commented_code": "@@ -172,6 +176,24 @@ class LogRecord(APILogRecord):\n     pertinent to the event being logged.\n     \"\"\"\n \n+    @overload\n+    def __init__(\n+        self,\n+        timestamp: int | None = None,\n+        observed_timestamp: int | None = None,\n+        context: Context | None = None,\n+        severity_text: str | None = None,\n+        severity_number: SeverityNumber | None = None,\n+        body: AnyValue | None = None,\n+        resource: Resource | None = None,\n+        attributes: _ExtendedAttributes | None = None,\n+        limits: LogLimits | None = _UnsetLogLimits,\n+    ): ...\n+\n+    @overload\n+    @deprecated(",
        "comment_created_at": "2025-06-05T21:10:41+00:00",
        "comment_author": "aabmass",
        "comment_body": "I think it's OK. IMO all optional arguments in our public APIs should be pass by name. It makes it much easier to deprecated/move things around.\r\n\r\nSo I'd like to do this regardless before we go stable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071559973",
    "pr_number": 4564,
    "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
    "created_at": "2025-05-02T12:44:00+00:00",
    "commented_code": "def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "2071559973",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T12:44:00+00:00",
        "comment_author": "emdneto",
        "comment_body": "Should we change the base classes to float? Got this when running pyright\r\n```\r\n /workspaces/opentelemetry-python/exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py:159:9 - error: Method \"export\" overrides class \"MetricExporter\" in an incompatible manner\r\n  \u00a0\u00a0Parameter 3 type mismatch: base parameter is type \"float\", override parameter is type \"int | None\"\r\n  \u00a0\u00a0\u00a0\u00a0Type \"float\" is not assignable to type \"int | None\"\r\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"float\" is not assignable to \"int\"\r\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"float\" is not assignable to \"None\" (reportIncompatibleMethodOverride)\r\n```\r\n\r\nSame for other signals",
        "pr_file_module": null
      },
      {
        "comment_id": "2071918382",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T17:16:38+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "This was mentioned in the other PR that I had to close b/c of merge conflicts, that it makes more sense for this to be an int, which means updating the interface instead of the exporters.\r\n\r\nThis brings up a bigger issue, which is that the Metric/Span/LogExporter interfaces are all out of sync. IMO what we should do is change all the interfaces to be exactly the same (agree on exact method signatures for `force_flush`, `shutdown`, `export`). In python this isn't technically \"breaking\" because all `abc.abstract_method` does is require a method with that name exists (adding / removing methods is breaking OTOH), and nothing enforces the method params. If people are using a linter, the linter will start complaining. This is arguably a good thing because it will notify people to update their signatures to be what we want them to be. Aaron I think disagrees with me on this. I'm curious what others think of this idea.\r\n\r\nThat's definitely my preference, but if we can't go that route there are some other options:\r\n\r\nAdd a new v2 of each interface with the ideal signatures... We could update all the exporter's we own to implement that interface, and then update the BatchSpan/LogRecordProcessor's with logic to check which interface the exporter implements.. This is my second favorite choice. I hope we wouldn't have to bump the SDK to version 2 just for this, because that's a significant change..\r\n\r\nWe could add a new method `export_with_timeout` to the SpanExporter/LogExporter, or just the SpanExporter if it's ok to change the param in the LogExporter b/c it's in alpha. `MetricExporter.export` already has a `timeout_millis` param. Ultimately I think `shutdown` should also have a `timeout` param, so we'd eventually have to add a new `shutdown_with_timeout` method... I don't like this approach really.\r\n\r\nAnother option Aaron mentioned is putting the timeout into a context global I think ? I'm guessing this means a global variable that we would ask all exporters to look at inside of their `export` call to figure out the timeout",
        "pr_file_module": null
      },
      {
        "comment_id": "2071973065",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T18:05:57+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "Also I could remove the timeout param to export and go ahead with the rest of this change, and we could discuss this separately.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072052221",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T19:21:41+00:00",
        "comment_author": "emdneto",
        "comment_body": "I think that adding or removing methods, moving or removing required parameters, and changing a parameter\u2019s default value are breaking changes.\r\n\r\nSimilarly, there are other changes we want to make that will break users\u2014see https://github.com/open-telemetry/opentelemetry-python/issues/4044.\r\n\r\nMaybe we can treat this as a bug fix, even though it will introduce a behavioural breaking change.\r\n\r\n>Also I could remove the timeout param to export and go ahead with the rest of this change, and we could discuss this separately.\r\n\r\nI'm ok with. Do you mean keep only the changes for the retry logic in both grpc/http exporters right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2072062271",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T19:31:42+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "> I think that adding or removing methods, moving or removing required parameters, and changing a parameter\u2019s default value are breaking changes.\r\n\r\nI'm just talking about the interfaces, i.e. [this thing](https://github.com/DylanRussell/opentelemetry-python/blob/main/opentelemetry-sdk/src/opentelemetry/sdk/_logs/_internal/export/__init__.py#L64), not the actual implementation. I don't see how it's a breaking change.\r\n\r\n> I'm ok with. Do you mean keep only the changes for the retry logic in both grpc/http exporters right?\r\n\r\nYeah, keep all the changes except for updating all `export` to accept a new `timeout` param.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072150548",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-02T21:06:47+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "I do agree that adding/removing methods from the interface is breaking, if we annotate them with the @abc.abstractclass thing..\r\n\r\nAnyway I removed all changes to the interfaces for now. I removed the new timeout param from `export`, so it just defaults to the class instance variable that it was using before..",
        "pr_file_module": null
      },
      {
        "comment_id": "2076245241",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4564,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/metric_exporter/__init__.py",
        "discussion_id": "2071559973",
        "commented_code": "@@ -158,17 +159,22 @@ def _translate_data(\n     def export(\n         self,\n         metrics_data: MetricsData,\n-        timeout_millis: float = 10_000,\n+        timeout_millis: Optional[int] = None,",
        "comment_created_at": "2025-05-06T20:38:41+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "Opened https://github.com/open-telemetry/opentelemetry-python/issues/4568 to discuss this further.. resolving this thread for now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "923643567",
    "pr_number": 2827,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
    "created_at": "2022-07-18T17:36:45+00:00",
    "commented_code": "Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "923643567",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-18T17:36:45+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Smells like an antipattern:\r\n\r\nWe should not add a `time` method to the SDK `Histogram` class, that class should represent an implementation of the API `Histogram` class which does not include a `time` method. What we are trying to do here is to add a new functionality, a new type of histogram that can time an operation.\r\n\r\nWe should not allow the user to repeatedly associate attributes to a time measurement. A time measurement is just a specialized version of `record` that measures an operation time (where an operation is a bunch of code inside a `with` context or a decorated function). We should only allow attributes to be associated once with the time measurement when we call `time` in the same way that we only allow attributes to be associated with another non-time measurement when we call `record`.\r\n\r\nThe current implementation uses [`with self._new_timer()`](\r\nhttps://github.com/open-telemetry/opentelemetry-python/pull/2827/files#diff-17a679cd897e8a5f1f65cc6034945a0714aaf212644445e44ffe04c192d0de32R219) which does not allow the user to associate attributes to a time measurement using a decorated function which should be allowed to make it functionally equivalent with using the timing-capable histogram as a context manager with `with`.\r\n\r\nI suggest this instead:\r\n\r\n``` python\r\nfrom functools import wraps\r\nfrom time import sleep\r\nfrom unittest import TestCase\r\nfrom timeit import default_timer\r\n\r\n\r\nclass Histogram:\r\n\r\n    def __init__(self):\r\n        self._records = []\r\n\r\n    def record(self, amount, attributes):\r\n        self._records.append((amount, attributes))\r\n\r\n\r\nclass TimingHistogram(Histogram):\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self._start = None\r\n        self._attributes = None\r\n\r\n    def __enter__(self):\r\n        self._start = default_timer()\r\n        return self\r\n\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        self.record(\r\n            max(round((default_timer() - self._start) * 1000), 0),\r\n            self._attributes\r\n        )\r\n        self._attributes = None\r\n\r\n    def time(self, attributes=None):\r\n        self._attributes = attributes\r\n        return self\r\n\r\n    def __call__(self, function):\r\n        @wraps(function)\r\n        def wrapped(*args, **kwargs):\r\n            with self.time(attributes=self._attributes):\r\n                return function(*args, **kwargs)\r\n\r\n        return wrapped\r\n\r\n\r\nclass TestSuite(TestCase):\r\n\r\n    def setUp(self):\r\n        self.timing_histogram = TimingHistogram()\r\n\r\n    def test_context_manager(self):\r\n\r\n        with self.timing_histogram.time(attributes={\"a\": \"b\"}):\r\n            sleep(1)\r\n\r\n        self.assertEqual(self.timing_histogram._records, [(1000, {\"a\": \"b\"})])\r\n\r\n    def test_decorator(self):\r\n\r\n        @self.timing_histogram.time(attributes={\"c\": \"d\"})\r\n        def function():\r\n            sleep(2)\r\n\r\n        function()\r\n        self.assertEqual(self.timing_histogram._records, [(2000, {\"c\": \"d\"})])\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "923790366",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-18T19:40:57+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "> We should not add a time method to the SDK Histogram class, that class should represent an implementation of the API Histogram class which does not include a time method. What we are trying to do here is to add a new functionality, a new type of histogram that can time an operation.\r\n\r\nThe timing operation is just a convenience method for the users. I do not think there should be a separate type that just adds this capability. Among other reasons, there is only one way to obtain the histogram instrument using the meter API `meter.create_histogram(...)`. A new type means an addition of new API to obtain timing histogram types which isn't really adding any value. \r\n\r\n> We should not allow the user to repeatedly associate attributes to a time measurement.\r\n\r\nYes, we don't that's why `_new_timer` create new one with not attributes.\r\n\r\n>The current implementation uses [with self._new_timer()](https://github.com/open-telemetry/opentelemetry-python/pull/2827/files#diff-17a679cd897e8a5f1f65cc6034945a0714aaf212644445e44ffe04c192d0de32R219) which does not allow the user to associate attributes to a time measurement using a decorated function which should be allowed to make it functionally equivalent with using the timing-capable histogram as a context manager with with.\r\n\r\nIsn't this contradicting with prev statement? \r\n\r\nWe can allow optional list of attributes be passed for @time. I am little confused about your stand on associate attribute with histogram. Each timing is independent and it's attributes are not associated with new one again.",
        "pr_file_module": null
      },
      {
        "comment_id": "924149817",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-19T07:24:15+00:00",
        "comment_author": "ocelotl",
        "comment_body": "> The timing operation is just a convenience method for the users. I do not think there should be a separate type that just adds this capability. Among other reasons, there is only one way to obtain the histogram instrument using the meter API `meter.create_histogram(...)`. A new type means an addition of new API to obtain timing histogram types which isn't really adding any value.\r\n\r\nThe fact that there is only an API function `create_histogram` is a good point. The issue I see here is that we are adding an \"API\" in the SDK by adding the `time` function. So, an app that uses the `time` function is now tied to that specific SDK which is not good of course. The _ideal_ thing would be that this `time` functionality is defined in the spec as part of the API, then we implement it in the SDK, etc, etc. like usual. That of course is a long and time consuming thing to do.\r\n\r\nI wonder now about a more general question, should we define API-level functionality in the SDK? :thinking: ",
        "pr_file_module": null
      },
      {
        "comment_id": "924169448",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-19T07:45:31+00:00",
        "comment_author": "ocelotl",
        "comment_body": "> We can allow optional list of attributes be passed for @time.\r\n\r\nYes, agreed, that is what I suggest in my implementation above :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "924537302",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-19T13:57:09+00:00",
        "comment_author": "srikanthccv",
        "comment_body": ">I wonder now about a more general question, should we define API-level functionality in the SDK? \ud83e\udd14\r\n\r\nI initially thought adding abstractmethod to Histogram and then decided not to because that's not in spec and they will probably not accept such thing because it's just a convenience method and some languages don't even bother about this pattern. ",
        "pr_file_module": null
      },
      {
        "comment_id": "927414452",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-22T08:23:20+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Ok, in summary, these are my concerns:\r\n\r\n1. We are adding an \"API\" in the SDK when we add `time` to the public interface of the SDK `Histogram` class, and that can make the application code dependent on a specific SDK. Since this is an \"extra\" feature that we (otel Python developers) are adding outside of any spec requirement, shouldn't it be in a util library instead?\r\n2. We try to allow the setting of attributes using both a decorator and a `set_attributes` function. They are not exactly equivalent since the former only allows for attributes to be set once and the latter multiple times. If you are ok with this its fine, I want to make sure we are aware of this difference.",
        "pr_file_module": null
      },
      {
        "comment_id": "927656577",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-22T13:32:35+00:00",
        "comment_author": "srikanthccv",
        "comment_body": ">shouldn't it be in a util library instead?\r\n\r\nHow does this look like? I am trying to understand how we add this capability without adding anything to `Histogram` class.\r\n\r\n>We try to allow the setting of attributes using both a decorator and a set_attributes function. They are not exactly equivalent since the former only allows for attributes to be set once and the latter multiple times. If you are ok with this its fine, I want to make sure we are aware of this difference.\r\n\r\nPart of it's behaviour is just mimicking the span. They might not have all attributes upfront when using context manager when this `set_attributes` is helpful. ",
        "pr_file_module": null
      },
      {
        "comment_id": "928716682",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-25T10:29:45+00:00",
        "comment_author": "ocelotl",
        "comment_body": "> > shouldn't it be in a util library instead?\r\n> \r\n> How does this look like? I am trying to understand how we add this capability without adding anything to `Histogram` class.\r\n\r\nSomething like this would work:\r\n\r\n``` python\r\nfrom functools import wraps\r\nfrom time import sleep\r\nfrom unittest import TestCase\r\nfrom timeit import default_timer\r\n\r\n\r\nclass Histogram:\r\n\r\n    def __init__(self):\r\n        self._records = []\r\n\r\n    def record(self, amount, attributes):\r\n        self._records.append((amount, attributes))\r\n\r\n\r\nclass _TimingHistogram:\r\n\r\n    def __init__(self, histogram):\r\n        super().__init__()\r\n        self._start = None\r\n        self._attributes = None\r\n        self._histogram = histogram\r\n\r\n    def __enter__(self):\r\n        self._start = default_timer()\r\n        return self\r\n\r\n    def __exit__(self, exc_type, exc_val, exc_tb):\r\n        self._histogram.record(\r\n            max(round((default_timer() - self._start) * 1000), 0),\r\n            self._attributes\r\n        )\r\n        self._attributes = None\r\n\r\n    def time(self, attributes=None):\r\n        self._attributes = attributes\r\n        return self\r\n\r\n    def __call__(self, function):\r\n        @wraps(function)\r\n        def wrapped(*args, **kwargs):\r\n            with self.time(attributes=self._attributes):\r\n                return function(*args, **kwargs)\r\n\r\n        return wrapped\r\n\r\n\r\ndef timing_histogram(histogram):\r\n\r\n    return _TimingHistogram(histogram)\r\n\r\n\r\nclass TestSuite(TestCase):\r\n\r\n    def setUp(self):\r\n        self.timing_histogram = timing_histogram(Histogram())\r\n\r\n    def test_context_manager(self):\r\n\r\n        with self.timing_histogram.time(attributes={\"a\": \"b\"}):\r\n            sleep(1)\r\n\r\n        self.assertEqual(\r\n            self.timing_histogram._histogram._records, [(1000, {\"a\": \"b\"})]\r\n        )\r\n\r\n    def test_decorator(self):\r\n\r\n        @self.timing_histogram.time(attributes={\"c\": \"d\"})\r\n        def function():\r\n            sleep(2)\r\n\r\n        function()\r\n        self.assertEqual(\r\n            self.timing_histogram._histogram._records, [(2000, {\"c\": \"d\"})]\r\n        )\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "929201233",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/instrument.py",
        "discussion_id": "923643567",
        "commented_code": "@@ -176,6 +180,47 @@ def record(\n             Measurement(amount, self, attributes)\n         )\n \n+    def time(self):\n+        return _Timer(self)\n+\n+\n+class _Timer:",
        "comment_created_at": "2022-07-25T18:57:55+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "Ok. We can do something like that.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "932494717",
    "pr_number": 2827,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/util/__init__.py",
    "created_at": "2022-07-28T17:18:50+00:00",
    "commented_code": "for key, value in mapping.items():\n             bounded_dict[key] = value\n         return bounded_dict\n+\n+\n+class _Timer:\n+    def __init__(self, histogram):\n+        super().__init__()\n+        self._start = None\n+        self._attributes = None\n+        self._histogram = histogram\n+\n+    def __enter__(self):\n+        self._start = default_timer()\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        duration = max(round((default_timer() - self._start) * 1000), 0)\n+        self._histogram.record(duration, self._attributes)\n+\n+    def time(self, attributes=None):\n+        self._attributes = attributes\n+        return self\n+\n+    def set_attributes(self, attributes):\n+        if self._attributes is None:\n+            self._attributes = attributes\n+        else:\n+            self._attributes.update(attributes)\n+\n+    def __call__(self, func):\n+        @wraps(func)\n+        def wrapped(*args, **kwargs):\n+            with self.time(attributes=self._attributes):\n+                return func(*args, **kwargs)\n+\n+        return wrapped\n+\n+\n+def get_timer(histogram):",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "932494717",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/util/__init__.py",
        "discussion_id": "932494717",
        "commented_code": "@@ -148,3 +151,46 @@ def from_map(cls, maxlen, mapping):\n         for key, value in mapping.items():\n             bounded_dict[key] = value\n         return bounded_dict\n+\n+\n+class _Timer:\n+    def __init__(self, histogram):\n+        super().__init__()\n+        self._start = None\n+        self._attributes = None\n+        self._histogram = histogram\n+\n+    def __enter__(self):\n+        self._start = default_timer()\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        duration = max(round((default_timer() - self._start) * 1000), 0)\n+        self._histogram.record(duration, self._attributes)\n+\n+    def time(self, attributes=None):\n+        self._attributes = attributes\n+        return self\n+\n+    def set_attributes(self, attributes):\n+        if self._attributes is None:\n+            self._attributes = attributes\n+        else:\n+            self._attributes.update(attributes)\n+\n+    def __call__(self, func):\n+        @wraps(func)\n+        def wrapped(*args, **kwargs):\n+            with self.time(attributes=self._attributes):\n+                return func(*args, **kwargs)\n+\n+        return wrapped\n+\n+\n+def get_timer(histogram):",
        "comment_created_at": "2022-07-28T17:18:50+00:00",
        "comment_author": "lzchen",
        "comment_body": "Does this mean that users must explicitly \"convert\" a histogram to a timing histogram to use it as a context manager?",
        "pr_file_module": null
      },
      {
        "comment_id": "933199730",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 2827,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/util/__init__.py",
        "discussion_id": "932494717",
        "commented_code": "@@ -148,3 +151,46 @@ def from_map(cls, maxlen, mapping):\n         for key, value in mapping.items():\n             bounded_dict[key] = value\n         return bounded_dict\n+\n+\n+class _Timer:\n+    def __init__(self, histogram):\n+        super().__init__()\n+        self._start = None\n+        self._attributes = None\n+        self._histogram = histogram\n+\n+    def __enter__(self):\n+        self._start = default_timer()\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: Optional[Type[BaseException]],\n+        exc_val: Optional[BaseException],\n+        exc_tb: Optional[TracebackType],\n+    ) -> None:\n+        duration = max(round((default_timer() - self._start) * 1000), 0)\n+        self._histogram.record(duration, self._attributes)\n+\n+    def time(self, attributes=None):\n+        self._attributes = attributes\n+        return self\n+\n+    def set_attributes(self, attributes):\n+        if self._attributes is None:\n+            self._attributes = attributes\n+        else:\n+            self._attributes.update(attributes)\n+\n+    def __call__(self, func):\n+        @wraps(func)\n+        def wrapped(*args, **kwargs):\n+            with self.time(attributes=self._attributes):\n+                return func(*args, **kwargs)\n+\n+        return wrapped\n+\n+\n+def get_timer(histogram):",
        "comment_created_at": "2022-07-29T12:36:17+00:00",
        "comment_author": "ocelotl",
        "comment_body": "There is no timing histogram but a different object `_Timer` that behaves as a context manager that automatically adds timing information to an existing histogram. I pushed for this idea because:\r\n\r\n1. The idea of having something that adds timing information to a histogram is outside of the spec, its something we (OTel Python) are introducing so it should be in a util library, not in the SDK itself.\r\n2. Adding another API in the SDK would couple application code that uses this API with the current SDK, which should not happen implicitly (for example, by using another SDK and getting an attribute error because the other SDK does not have a `time` method in the `Histogram` class).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1920492426",
    "pr_number": 4361,
    "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
    "created_at": "2025-01-17T17:06:25+00:00",
    "commented_code": "\"\"\"\n         return self._schema_url\n \n-    def _is_instrument_registered(\n-        self, name: str, type_: type, unit: str, description: str\n-    ) -> Tuple[bool, str]:\n+    def _register_instrument(\n+        self,\n+        name: str,\n+        type_: type,\n+        unit: str,\n+        description: str,\n+        advisory: Optional[MetricsInstrumentAdvisory] = None,\n+    ) -> Tuple[str, _InstrumentRegistrationStatus]:\n         \"\"\"\n-        Check if an instrument with the same name, type, unit and description\n-        has been registered already.\n-\n-        Returns a tuple. The first value is `True` if the instrument has been\n-        registered already, `False` otherwise. The second value is the\n-        instrument id.\n+        Register an instrument with the name, type, unit and description as\n+        identifying keys and the advisory as value.\n+\n+        Returns a tuple. The first value is the instrument id.\n+        The second value is an `_InstrumentRegistrationStatus` where\n+        `already_registered` is `True` if the instrument has been registered\n+        already.\n+        If `conflict` is set to True the `current_advisory` attribute contains\n+        the registered instrument advisory.\n         \"\"\"\n \n         instrument_id = \",\".join(\n             [name.strip().lower(), type_.__name__, unit, description]\n         )\n \n-        result = False\n+        already_registered, conflict = False, False\n+        current_advisory = None\n \n         with self._instrument_ids_lock:\n-            if instrument_id in self._instrument_ids:\n-                result = True\n+            # we are not using get because None is a valid value\n+            already_registered = instrument_id in self._instrument_ids\n+            if already_registered:\n+                current_advisory = self._instrument_ids[instrument_id]\n+                conflict = current_advisory != advisory\n             else:\n-                self._instrument_ids.add(instrument_id)\n-\n-        return (result, instrument_id)\n+                self._instrument_ids[instrument_id] = advisory\n+\n+        return (\n+            instrument_id,\n+            _InstrumentRegistrationStatus(\n+                already_registered=already_registered,\n+                conflict=conflict,\n+                current_advisory=current_advisory,\n+            ),\n+        )\n \n     @abstractmethod\n     def create_counter(\n         self,\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: None = None,",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1920492426",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1920492426",
        "commented_code": "@@ -218,38 +232,58 @@ def schema_url(self) -> Optional[str]:\n         \"\"\"\n         return self._schema_url\n \n-    def _is_instrument_registered(\n-        self, name: str, type_: type, unit: str, description: str\n-    ) -> Tuple[bool, str]:\n+    def _register_instrument(\n+        self,\n+        name: str,\n+        type_: type,\n+        unit: str,\n+        description: str,\n+        advisory: Optional[MetricsInstrumentAdvisory] = None,\n+    ) -> Tuple[str, _InstrumentRegistrationStatus]:\n         \"\"\"\n-        Check if an instrument with the same name, type, unit and description\n-        has been registered already.\n-\n-        Returns a tuple. The first value is `True` if the instrument has been\n-        registered already, `False` otherwise. The second value is the\n-        instrument id.\n+        Register an instrument with the name, type, unit and description as\n+        identifying keys and the advisory as value.\n+\n+        Returns a tuple. The first value is the instrument id.\n+        The second value is an `_InstrumentRegistrationStatus` where\n+        `already_registered` is `True` if the instrument has been registered\n+        already.\n+        If `conflict` is set to True the `current_advisory` attribute contains\n+        the registered instrument advisory.\n         \"\"\"\n \n         instrument_id = \",\".join(\n             [name.strip().lower(), type_.__name__, unit, description]\n         )\n \n-        result = False\n+        already_registered, conflict = False, False\n+        current_advisory = None\n \n         with self._instrument_ids_lock:\n-            if instrument_id in self._instrument_ids:\n-                result = True\n+            # we are not using get because None is a valid value\n+            already_registered = instrument_id in self._instrument_ids\n+            if already_registered:\n+                current_advisory = self._instrument_ids[instrument_id]\n+                conflict = current_advisory != advisory\n             else:\n-                self._instrument_ids.add(instrument_id)\n-\n-        return (result, instrument_id)\n+                self._instrument_ids[instrument_id] = advisory\n+\n+        return (\n+            instrument_id,\n+            _InstrumentRegistrationStatus(\n+                already_registered=already_registered,\n+                conflict=conflict,\n+                current_advisory=current_advisory,\n+            ),\n+        )\n \n     @abstractmethod\n     def create_counter(\n         self,\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: None = None,",
        "comment_created_at": "2025-01-17T17:06:25+00:00",
        "comment_author": "aabmass",
        "comment_body": "Wdyt of adding doing this?\r\n```suggestion\r\n        *,\r\n        advisory: None = None,\r\n```\r\n\r\nto force any new arguments to be passed by name explicitly\r\n- getting to having a lot of arguments here and IMO it is less error prone for users\r\n- that would allow us to reorder the argument list if needed in the future\r\n\r\nif we also added a trailing `**kwargs`, we could even remove parameters in the future if they get deprecated. Maybe lets discuss in the SIG but wanted to get your thoughts.",
        "pr_file_module": null
      },
      {
        "comment_id": "1922074998",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1920492426",
        "commented_code": "@@ -218,38 +232,58 @@ def schema_url(self) -> Optional[str]:\n         \"\"\"\n         return self._schema_url\n \n-    def _is_instrument_registered(\n-        self, name: str, type_: type, unit: str, description: str\n-    ) -> Tuple[bool, str]:\n+    def _register_instrument(\n+        self,\n+        name: str,\n+        type_: type,\n+        unit: str,\n+        description: str,\n+        advisory: Optional[MetricsInstrumentAdvisory] = None,\n+    ) -> Tuple[str, _InstrumentRegistrationStatus]:\n         \"\"\"\n-        Check if an instrument with the same name, type, unit and description\n-        has been registered already.\n-\n-        Returns a tuple. The first value is `True` if the instrument has been\n-        registered already, `False` otherwise. The second value is the\n-        instrument id.\n+        Register an instrument with the name, type, unit and description as\n+        identifying keys and the advisory as value.\n+\n+        Returns a tuple. The first value is the instrument id.\n+        The second value is an `_InstrumentRegistrationStatus` where\n+        `already_registered` is `True` if the instrument has been registered\n+        already.\n+        If `conflict` is set to True the `current_advisory` attribute contains\n+        the registered instrument advisory.\n         \"\"\"\n \n         instrument_id = \",\".join(\n             [name.strip().lower(), type_.__name__, unit, description]\n         )\n \n-        result = False\n+        already_registered, conflict = False, False\n+        current_advisory = None\n \n         with self._instrument_ids_lock:\n-            if instrument_id in self._instrument_ids:\n-                result = True\n+            # we are not using get because None is a valid value\n+            already_registered = instrument_id in self._instrument_ids\n+            if already_registered:\n+                current_advisory = self._instrument_ids[instrument_id]\n+                conflict = current_advisory != advisory\n             else:\n-                self._instrument_ids.add(instrument_id)\n-\n-        return (result, instrument_id)\n+                self._instrument_ids[instrument_id] = advisory\n+\n+        return (\n+            instrument_id,\n+            _InstrumentRegistrationStatus(\n+                already_registered=already_registered,\n+                conflict=conflict,\n+                current_advisory=current_advisory,\n+            ),\n+        )\n \n     @abstractmethod\n     def create_counter(\n         self,\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: None = None,",
        "comment_created_at": "2025-01-20T09:31:45+00:00",
        "comment_author": "xrmx",
        "comment_body": "I'm fine with that ",
        "pr_file_module": null
      },
      {
        "comment_id": "1930275368",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1920492426",
        "commented_code": "@@ -218,38 +232,58 @@ def schema_url(self) -> Optional[str]:\n         \"\"\"\n         return self._schema_url\n \n-    def _is_instrument_registered(\n-        self, name: str, type_: type, unit: str, description: str\n-    ) -> Tuple[bool, str]:\n+    def _register_instrument(\n+        self,\n+        name: str,\n+        type_: type,\n+        unit: str,\n+        description: str,\n+        advisory: Optional[MetricsInstrumentAdvisory] = None,\n+    ) -> Tuple[str, _InstrumentRegistrationStatus]:\n         \"\"\"\n-        Check if an instrument with the same name, type, unit and description\n-        has been registered already.\n-\n-        Returns a tuple. The first value is `True` if the instrument has been\n-        registered already, `False` otherwise. The second value is the\n-        instrument id.\n+        Register an instrument with the name, type, unit and description as\n+        identifying keys and the advisory as value.\n+\n+        Returns a tuple. The first value is the instrument id.\n+        The second value is an `_InstrumentRegistrationStatus` where\n+        `already_registered` is `True` if the instrument has been registered\n+        already.\n+        If `conflict` is set to True the `current_advisory` attribute contains\n+        the registered instrument advisory.\n         \"\"\"\n \n         instrument_id = \",\".join(\n             [name.strip().lower(), type_.__name__, unit, description]\n         )\n \n-        result = False\n+        already_registered, conflict = False, False\n+        current_advisory = None\n \n         with self._instrument_ids_lock:\n-            if instrument_id in self._instrument_ids:\n-                result = True\n+            # we are not using get because None is a valid value\n+            already_registered = instrument_id in self._instrument_ids\n+            if already_registered:\n+                current_advisory = self._instrument_ids[instrument_id]\n+                conflict = current_advisory != advisory\n             else:\n-                self._instrument_ids.add(instrument_id)\n-\n-        return (result, instrument_id)\n+                self._instrument_ids[instrument_id] = advisory\n+\n+        return (\n+            instrument_id,\n+            _InstrumentRegistrationStatus(\n+                already_registered=already_registered,\n+                conflict=conflict,\n+                current_advisory=current_advisory,\n+            ),\n+        )\n \n     @abstractmethod\n     def create_counter(\n         self,\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: None = None,",
        "comment_created_at": "2025-01-27T10:11:39+00:00",
        "comment_author": "xrmx",
        "comment_body": "Forgot to bring it at the SIG but pushed this since:\r\n- it has many advantages\r\n- we can revert it if it's a problem",
        "pr_file_module": null
      },
      {
        "comment_id": "1931057774",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1920492426",
        "commented_code": "@@ -218,38 +232,58 @@ def schema_url(self) -> Optional[str]:\n         \"\"\"\n         return self._schema_url\n \n-    def _is_instrument_registered(\n-        self, name: str, type_: type, unit: str, description: str\n-    ) -> Tuple[bool, str]:\n+    def _register_instrument(\n+        self,\n+        name: str,\n+        type_: type,\n+        unit: str,\n+        description: str,\n+        advisory: Optional[MetricsInstrumentAdvisory] = None,\n+    ) -> Tuple[str, _InstrumentRegistrationStatus]:\n         \"\"\"\n-        Check if an instrument with the same name, type, unit and description\n-        has been registered already.\n-\n-        Returns a tuple. The first value is `True` if the instrument has been\n-        registered already, `False` otherwise. The second value is the\n-        instrument id.\n+        Register an instrument with the name, type, unit and description as\n+        identifying keys and the advisory as value.\n+\n+        Returns a tuple. The first value is the instrument id.\n+        The second value is an `_InstrumentRegistrationStatus` where\n+        `already_registered` is `True` if the instrument has been registered\n+        already.\n+        If `conflict` is set to True the `current_advisory` attribute contains\n+        the registered instrument advisory.\n         \"\"\"\n \n         instrument_id = \",\".join(\n             [name.strip().lower(), type_.__name__, unit, description]\n         )\n \n-        result = False\n+        already_registered, conflict = False, False\n+        current_advisory = None\n \n         with self._instrument_ids_lock:\n-            if instrument_id in self._instrument_ids:\n-                result = True\n+            # we are not using get because None is a valid value\n+            already_registered = instrument_id in self._instrument_ids\n+            if already_registered:\n+                current_advisory = self._instrument_ids[instrument_id]\n+                conflict = current_advisory != advisory\n             else:\n-                self._instrument_ids.add(instrument_id)\n-\n-        return (result, instrument_id)\n+                self._instrument_ids[instrument_id] = advisory\n+\n+        return (\n+            instrument_id,\n+            _InstrumentRegistrationStatus(\n+                already_registered=already_registered,\n+                conflict=conflict,\n+                current_advisory=current_advisory,\n+            ),\n+        )\n \n     @abstractmethod\n     def create_counter(\n         self,\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: None = None,",
        "comment_created_at": "2025-01-27T19:09:36+00:00",
        "comment_author": "aabmass",
        "comment_body": "> * we can revert it if it's a problem\r\n\r\ntrue",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1923966116",
    "pr_number": 4361,
    "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
    "created_at": "2025-01-21T15:47:02+00:00",
    "commented_code": "name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1923966116",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-21T15:47:02+00:00",
        "comment_author": "aabmass",
        "comment_body": "What if the spec adds specification adds a new advisory type for another instrument, say `MetricsGaugeAdvisory`? I think if we changed the type here, that would be a breaking change",
        "pr_file_module": null
      },
      {
        "comment_id": "1924017729",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-21T16:18:18+00:00",
        "comment_author": "xrmx",
        "comment_body": "So are you suggesting to add preemptively a custom type for each instrumenting or having the specific dataclass inherit from the common be enough? In other words, is the issue about the name of the type or its structure?",
        "pr_file_module": null
      },
      {
        "comment_id": "1924311528",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-21T20:15:11+00:00",
        "comment_author": "aabmass",
        "comment_body": "I don't mind so much as long as we avoid introducing breaking changes. I looked at [Go](https://pkg.go.dev/go.opentelemetry.io/otel/metric#WithExplicitBucketBoundaries) and [Java](https://www.javadoc.io/static/io.opentelemetry/opentelemetry-api/1.46.0/io/opentelemetry/api/metrics/DoubleHistogramBuilder.html), they took more of a \"flat\" approach where advisory parameters are flattened into the builder or options type.",
        "pr_file_module": null
      },
      {
        "comment_id": "1924931307",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-22T08:50:25+00:00",
        "comment_author": "xrmx",
        "comment_body": "I guess the flat approach is for this very same reason of avoiding breaking compatibility by changing the layout of the advisory",
        "pr_file_module": null
      },
      {
        "comment_id": "1928999972",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-24T17:10:07+00:00",
        "comment_author": "xrmx",
        "comment_body": "Pushed the conversion to using a flattened attribute just for the histogram in 0b6f9435bba5e444d7bc094e390060ea67631e49, left a couple of FIXMEs around, PTAL!",
        "pr_file_module": null
      },
      {
        "comment_id": "1930226055",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4361,
        "pr_file": "opentelemetry-api/src/opentelemetry/metrics/_internal/__init__.py",
        "discussion_id": "1923966116",
        "commented_code": "@@ -394,6 +451,7 @@ def create_gauge(  # type: ignore # pylint: disable=no-self-use\n         name: str,\n         unit: str = \"\",\n         description: str = \"\",\n+        advisory: Optional[MetricsCommonAdvisory] = None,",
        "comment_created_at": "2025-01-27T09:38:13+00:00",
        "comment_author": "xrmx",
        "comment_body": "Kept using the _MetricsHistogramAdvisory dataclass for storing the advisory params internally 32be722277aaba507951528c36eedeb5a623ccda so that mypy is happy again",
        "pr_file_module": null
      }
    ]
  }
]