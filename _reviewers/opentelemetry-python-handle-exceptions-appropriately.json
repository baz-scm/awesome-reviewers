[
  {
    "discussion_id": "2001599281",
    "pr_number": 4494,
    "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
    "created_at": "2025-03-18T17:31:49+00:00",
    "commented_code": "finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "2001599281",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T17:31:49+00:00",
        "comment_author": "grihabor",
        "comment_body": "maybe we could add some clarifying notes, e.g. this is what the docs say about GeneratorExit:\r\n> exception GeneratorExit\r\n>    Raised when a [generator](https://docs.python.org/3/glossary.html#term-generator) or [coroutine](https://docs.python.org/3/glossary.html#term-coroutine) is closed; see [generator.close()](https://docs.python.org/3/reference/expressions.html#generator.close) and [coroutine.close()](https://docs.python.org/3/reference/datamodel.html#coroutine.close). It directly inherits from [BaseException](https://docs.python.org/3/library/exceptions.html#BaseException) instead of [Exception](https://docs.python.org/3/library/exceptions.html#Exception) since it is technically not an error.\r\n\r\n```suggestion\r\n    # Record only exceptions that inherit Exception class but not BaseException, because \r\n    # classes that directly inherit BaseException are not technically errors, e.g. GeneratorExit. \r\n    except Exception as exc:  # pylint: disable=broad-exception-caught\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2001823473",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T19:17:11+00:00",
        "comment_author": "lzchen",
        "comment_body": "Also perhaps link the issue in the comments.",
        "pr_file_module": null
      },
      {
        "comment_id": "2001846112",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T19:27:10+00:00",
        "comment_author": "emdneto",
        "comment_body": "Added. Thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1718729963",
    "pr_number": 4116,
    "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
    "created_at": "2024-08-15T17:11:36+00:00",
    "commented_code": "return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1718729963",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T17:11:36+00:00",
        "comment_author": "lzchen",
        "comment_body": "Nit: Shouldn't the exception handling occur within the `_readfile` function instead of the below?",
        "pr_file_module": null
      },
      {
        "comment_id": "1718776859",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T17:44:58+00:00",
        "comment_author": "sandy2008",
        "comment_body": "@lzchen Thank you so much for the suggestion! 😊 I see the benefit of moving the exception handling into the `_read_file` function, but I’m a little concerned that it makes the code longer and potentially less clean. Handling errors at multiple points might make the logic harder to follow.\r\n\r\nHere’s the updated code with the changes you recommended:\r\n\r\n```python\r\ndef _read_file(file_path: str) -> bytes:\r\n    try:\r\n        with open(file_path, \"rb\") as file:\r\n            return file.read()\r\n    except FileNotFoundError as e:\r\n        logger.exception(\r\n            f\"Failed to read file: {e.filename}. Please check if the file exists and is accessible.\"\r\n        )\r\n        raise  # Re-raise the exception to handle it at the call site\r\n\r\ndef _load_credentials(\r\n    certificate_file: str,\r\n    client_key_file: str,\r\n    client_certificate_file: str,\r\n) -> Optional[ChannelCredentials]:\r\n    try:\r\n        root_certificates = _read_file(certificate_file)\r\n        private_key = _read_file(client_key_file)\r\n        certificate_chain = _read_file(client_certificate_file)\r\n        return ssl_channel_credentials(\r\n            root_certificates=root_certificates,\r\n            private_key=private_key,\r\n            certificate_chain=certificate_chain,\r\n        )\r\n    except FileNotFoundError:\r\n        return None\r\n```\r\n\r\nWhat do you think about keeping the exception handling at the higher level instead? I’m just thinking it might help keep the `_read_file` function more concise and focused. \r\n\r\nLooking forward to your thoughts! 🙏",
        "pr_file_module": null
      },
      {
        "comment_id": "1718819275",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T18:23:23+00:00",
        "comment_author": "lzchen",
        "comment_body": "@sandy2008 \r\n\r\nI'm curious as to why we have to reraise the error at the higher level? Can't we remove the try except in `_load_credentials` just let `_read_file` handle the exception + return `None`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1719100809",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T23:11:15+00:00",
        "comment_author": "ocelotl",
        "comment_body": "If what we are handling is a `FileNotFoundError`, it makes more sense to do so in a function named `_read_file`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1720052171",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-16T16:18:46+00:00",
        "comment_author": "sandy2008",
        "comment_body": "@lzchen @ocelotl\r\n\r\nThank you all so much for your valuable feedback! 😊 I’ve gone ahead and made the changes to handle the `FileNotFoundError` entirely within the `_read_file` function as suggested. This keeps the exception handling localized and simplifies the `_load_credentials` function.\r\n\r\nHere’s the updated code:\r\n\r\n```python\r\ndef _read_file(file_path: str) -> Optional[bytes]:\r\n    try:\r\n        with open(file_path, \"rb\") as file:\r\n            return file.read()\r\n    except FileNotFoundError as e:\r\n        logger.exception(\r\n            f\"Failed to read file: {e.filename}. Please check if the file exists and is accessible.\"\r\n        )\r\n        return None\r\n\r\ndef _load_credentials(\r\n    certificate_file: str,\r\n    client_key_file: str,\r\n    client_certificate_file: str,\r\n) -> Optional[ChannelCredentials]:\r\n    root_certificates = _read_file(certificate_file)\r\n    private_key = _read_file(client_key_file)\r\n    certificate_chain = _read_file(client_certificate_file)\r\n\r\n    if root_certificates is None or private_key is None or certificate_chain is None:\r\n        return None\r\n\r\n    return ssl_channel_credentials(\r\n        root_certificates=root_certificates,\r\n        private_key=private_key,\r\n        certificate_chain=certificate_chain,\r\n    )\r\n```\r\n\r\nLet me know if this change looks good to you! 🙏",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347925847",
    "pr_number": 297,
    "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
    "created_at": "2019-11-19T13:37:22+00:00",
    "commented_code": "span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "347925847",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T13:37:22+00:00",
        "comment_author": "Oberon00",
        "comment_body": "Same here, `event.failure` could contain valuable information.",
        "pr_file_module": null
      },
      {
        "comment_id": "348222158",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T23:24:12+00:00",
        "comment_author": "hectorhdzg",
        "comment_body": "+1 hiding the actual error would be pretty bad",
        "pr_file_module": null
      },
      {
        "comment_id": "348222780",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T23:26:18+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Ok, adding the description field back :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1547925630",
    "pr_number": 3763,
    "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
    "created_at": "2024-04-02T13:46:43+00:00",
    "commented_code": "from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1547925630",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-02T13:46:43+00:00",
        "comment_author": "pmcollins",
        "comment_body": "Looks like the mypy check is failing because it wants to see a return statement for the case where an exception was thrown.",
        "pr_file_module": null
      },
      {
        "comment_id": "1549005382",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-03T06:49:26+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Would it be better to just throw the exception instead of catch it for **failfast**? Because the exception only happens when environment variable `OTEL_PYTHON_CONTEXT` set to unsupported value. It's also fine to **failover** to the `default_context`, however, it requires extra codes to load the `default_context` on exception catching.\r\n\r\nIn short, I prefer **failfast**, just remove `try/except`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1571344805",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-18T20:38:59+00:00",
        "comment_author": "aabmass",
        "comment_body": "It looks like we decided to return None and annotate this as `Optional[_RuntimeContext]`. There are several `type: ignore` comments below (e.g. L132) which I think are suppressing a real issue. If the user sets `OTEL_PYTHON_CONTEXT=foo`, that code would fail with `AttributeError: 'NoneType' object has no attribute 'get_current'`.\r\n\r\n> It's also fine to **failover** to the `default_context`, however, it requires extra codes to load the `default_context` on exception catching.\r\n\r\nThat would be my preference, then we can also fix the typing issues throughout this file.",
        "pr_file_module": null
      },
      {
        "comment_id": "1574604649",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-22T11:33:41+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1567689535",
    "pr_number": 3763,
    "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
    "created_at": "2024-04-16T16:59:14+00:00",
    "commented_code": "from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1567689535",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-16T16:59:14+00:00",
        "comment_author": "lzchen",
        "comment_body": "Could you keep the exception handling as is?",
        "pr_file_module": null
      },
      {
        "comment_id": "1568389472",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-17T07:52:42+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Would it be better to just throw the exception for failfast instead of catch it? Because the exception only happens when environment variable OTEL_PYTHON_CONTEXT set to unsupported value. It's also fine to failover to the default_context, however, it requires extra codes to load the default_context on exception catching.\r\n\r\nFailfast is preffered, as I mentioned before https://github.com/open-telemetry/opentelemetry-python/pull/3763#discussion_r1549005382.\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1569111398",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-17T16:13:16+00:00",
        "comment_author": "lzchen",
        "comment_body": "Design-wise that might be the case but changing this would be a breaking change. I would suggest keeping it as is and maybe down the road we can explore user experience options via configuration.",
        "pr_file_module": null
      },
      {
        "comment_id": "1569884176",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-18T03:24:56+00:00",
        "comment_author": "WqyJh",
        "comment_body": "OK, it has been restored.",
        "pr_file_module": null
      }
    ]
  }
]