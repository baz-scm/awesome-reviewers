[
  {
    "discussion_id": "2001599281",
    "pr_number": 4494,
    "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
    "created_at": "2025-03-18T17:31:49+00:00",
    "commented_code": "finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "2001599281",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T17:31:49+00:00",
        "comment_author": "grihabor",
        "comment_body": "maybe we could add some clarifying notes, e.g. this is what the docs say about GeneratorExit:\r\n> exception GeneratorExit\r\n>    Raised when a [generator](https://docs.python.org/3/glossary.html#term-generator) or [coroutine](https://docs.python.org/3/glossary.html#term-coroutine) is closed; see [generator.close()](https://docs.python.org/3/reference/expressions.html#generator.close) and [coroutine.close()](https://docs.python.org/3/reference/datamodel.html#coroutine.close). It directly inherits from [BaseException](https://docs.python.org/3/library/exceptions.html#BaseException) instead of [Exception](https://docs.python.org/3/library/exceptions.html#Exception) since it is technically not an error.\r\n\r\n```suggestion\r\n    # Record only exceptions that inherit Exception class but not BaseException, because \r\n    # classes that directly inherit BaseException are not technically errors, e.g. GeneratorExit. \r\n    except Exception as exc:  # pylint: disable=broad-exception-caught\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2001823473",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T19:17:11+00:00",
        "comment_author": "lzchen",
        "comment_body": "Also perhaps link the issue in the comments.",
        "pr_file_module": null
      },
      {
        "comment_id": "2001846112",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4494,
        "pr_file": "opentelemetry-api/src/opentelemetry/trace/__init__.py",
        "discussion_id": "2001599281",
        "commented_code": "@@ -588,7 +588,7 @@ def use_span(\n         finally:\n             context_api.detach(token)\n \n-    except BaseException as exc:  # pylint: disable=broad-exception-caught\n+    except Exception as exc:  # pylint: disable=broad-exception-caught",
        "comment_created_at": "2025-03-18T19:27:10+00:00",
        "comment_author": "emdneto",
        "comment_body": "Added. Thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1718729963",
    "pr_number": 4116,
    "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
    "created_at": "2024-08-15T17:11:36+00:00",
    "commented_code": "return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1718729963",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T17:11:36+00:00",
        "comment_author": "lzchen",
        "comment_body": "Nit: Shouldn't the exception handling occur within the `_readfile` function instead of the below?",
        "pr_file_module": null
      },
      {
        "comment_id": "1718776859",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T17:44:58+00:00",
        "comment_author": "sandy2008",
        "comment_body": "@lzchen Thank you so much for the suggestion! ðŸ˜Š I see the benefit of moving the exception handling into the `_read_file` function, but Iâ€™m a little concerned that it makes the code longer and potentially less clean. Handling errors at multiple points might make the logic harder to follow.\r\n\r\nHereâ€™s the updated code with the changes you recommended:\r\n\r\n```python\r\ndef _read_file(file_path: str) -> bytes:\r\n    try:\r\n        with open(file_path, \"rb\") as file:\r\n            return file.read()\r\n    except FileNotFoundError as e:\r\n        logger.exception(\r\n            f\"Failed to read file: {e.filename}. Please check if the file exists and is accessible.\"\r\n        )\r\n        raise  # Re-raise the exception to handle it at the call site\r\n\r\ndef _load_credentials(\r\n    certificate_file: str,\r\n    client_key_file: str,\r\n    client_certificate_file: str,\r\n) -> Optional[ChannelCredentials]:\r\n    try:\r\n        root_certificates = _read_file(certificate_file)\r\n        private_key = _read_file(client_key_file)\r\n        certificate_chain = _read_file(client_certificate_file)\r\n        return ssl_channel_credentials(\r\n            root_certificates=root_certificates,\r\n            private_key=private_key,\r\n            certificate_chain=certificate_chain,\r\n        )\r\n    except FileNotFoundError:\r\n        return None\r\n```\r\n\r\nWhat do you think about keeping the exception handling at the higher level instead? Iâ€™m just thinking it might help keep the `_read_file` function more concise and focused. \r\n\r\nLooking forward to your thoughts! ðŸ™",
        "pr_file_module": null
      },
      {
        "comment_id": "1718819275",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T18:23:23+00:00",
        "comment_author": "lzchen",
        "comment_body": "@sandy2008 \r\n\r\nI'm curious as to why we have to reraise the error at the higher level? Can't we remove the try except in `_load_credentials` just let `_read_file` handle the exception + return `None`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1719100809",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-15T23:11:15+00:00",
        "comment_author": "ocelotl",
        "comment_body": "If what we are handling is a `FileNotFoundError`, it makes more sense to do so in a function named `_read_file`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1720052171",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1718729963",
        "commented_code": "@@ -118,22 +120,48 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _read_file(file_path: str) -> bytes:\n+    with open(file_path, \"rb\") as file:\n+        return file.read()",
        "comment_created_at": "2024-08-16T16:18:46+00:00",
        "comment_author": "sandy2008",
        "comment_body": "@lzchen @ocelotl\r\n\r\nThank you all so much for your valuable feedback! ðŸ˜Š Iâ€™ve gone ahead and made the changes to handle the `FileNotFoundError` entirely within the `_read_file` function as suggested. This keeps the exception handling localized and simplifies the `_load_credentials` function.\r\n\r\nHereâ€™s the updated code:\r\n\r\n```python\r\ndef _read_file(file_path: str) -> Optional[bytes]:\r\n    try:\r\n        with open(file_path, \"rb\") as file:\r\n            return file.read()\r\n    except FileNotFoundError as e:\r\n        logger.exception(\r\n            f\"Failed to read file: {e.filename}. Please check if the file exists and is accessible.\"\r\n        )\r\n        return None\r\n\r\ndef _load_credentials(\r\n    certificate_file: str,\r\n    client_key_file: str,\r\n    client_certificate_file: str,\r\n) -> Optional[ChannelCredentials]:\r\n    root_certificates = _read_file(certificate_file)\r\n    private_key = _read_file(client_key_file)\r\n    certificate_chain = _read_file(client_certificate_file)\r\n\r\n    if root_certificates is None or private_key is None or certificate_chain is None:\r\n        return None\r\n\r\n    return ssl_channel_credentials(\r\n        root_certificates=root_certificates,\r\n        private_key=private_key,\r\n        certificate_chain=certificate_chain,\r\n    )\r\n```\r\n\r\nLet me know if this change looks good to you! ðŸ™",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "347925847",
    "pr_number": 297,
    "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
    "created_at": "2019-11-19T13:37:22+00:00",
    "commented_code": "span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "347925847",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T13:37:22+00:00",
        "comment_author": "Oberon00",
        "comment_body": "Same here, `event.failure` could contain valuable information.",
        "pr_file_module": null
      },
      {
        "comment_id": "348222158",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T23:24:12+00:00",
        "comment_author": "hectorhdzg",
        "comment_body": "+1 hiding the actual error would be pretty bad",
        "pr_file_module": null
      },
      {
        "comment_id": "348222780",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 297,
        "pr_file": "ext/opentelemetry-ext-pymongo/src/opentelemetry/ext/pymongo/__init__.py",
        "discussion_id": "347925847",
        "commented_code": "@@ -92,7 +94,7 @@ def failed(self, event: monitoring.CommandFailedEvent):\n             span.set_attribute(\n                 \"db.mongo.duration_micros\", event.duration_micros\n             )\n-            span.set_status(Status(StatusCanonicalCode.UNKNOWN, event.failure))\n+            span.set_status(UnknownStatus())",
        "comment_created_at": "2019-11-19T23:26:18+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Ok, adding the description field back :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1547925630",
    "pr_number": 3763,
    "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
    "created_at": "2024-04-02T13:46:43+00:00",
    "commented_code": "from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1547925630",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-02T13:46:43+00:00",
        "comment_author": "pmcollins",
        "comment_body": "Looks like the mypy check is failing because it wants to see a return statement for the case where an exception was thrown.",
        "pr_file_module": null
      },
      {
        "comment_id": "1549005382",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-03T06:49:26+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Would it be better to just throw the exception instead of catch it for **failfast**? Because the exception only happens when environment variable `OTEL_PYTHON_CONTEXT` set to unsupported value. It's also fine to **failover** to the `default_context`, however, it requires extra codes to load the `default_context` on exception catching.\r\n\r\nIn short, I prefer **failfast**, just remove `try/except`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1571344805",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-18T20:38:59+00:00",
        "comment_author": "aabmass",
        "comment_body": "It looks like we decided to return None and annotate this as `Optional[_RuntimeContext]`. There are several `type: ignore` comments below (e.g. L132) which I think are suppressing a real issue. If the user sets `OTEL_PYTHON_CONTEXT=foo`, that code would fail with `AttributeError: 'NoneType' object has no attribute 'get_current'`.\r\n\r\n> It's also fine to **failover** to the `default_context`, however, it requires extra codes to load the `default_context` on exception catching.\r\n\r\nThat would be my preference, then we can also fix the typing issues throughout this file.",
        "pr_file_module": null
      },
      {
        "comment_id": "1574604649",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1547925630",
        "commented_code": "@@ -25,55 +25,38 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n-\n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    try:\n+        return next(  # type: ignore\n+            iter(  # type: ignore\n+                entry_points(  # type: ignore\n+                    group=\"opentelemetry_context\",\n+                    name=configured_context,\n+                )\n+            )\n+        ).load()()\n+    except Exception:  # pylint: disable=broad-except",
        "comment_created_at": "2024-04-22T11:33:41+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1567689535",
    "pr_number": 3763,
    "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
    "created_at": "2024-04-16T16:59:14+00:00",
    "commented_code": "from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1567689535",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-16T16:59:14+00:00",
        "comment_author": "lzchen",
        "comment_body": "Could you keep the exception handling as is?",
        "pr_file_module": null
      },
      {
        "comment_id": "1568389472",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-17T07:52:42+00:00",
        "comment_author": "WqyJh",
        "comment_body": "Would it be better to just throw the exception for failfast instead of catch it? Because the exception only happens when environment variable OTEL_PYTHON_CONTEXT set to unsupported value. It's also fine to failover to the default_context, however, it requires extra codes to load the default_context on exception catching.\r\n\r\nFailfast is preffered, as I mentioned before https://github.com/open-telemetry/opentelemetry-python/pull/3763#discussion_r1549005382.\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1569111398",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-17T16:13:16+00:00",
        "comment_author": "lzchen",
        "comment_body": "Design-wise that might be the case but changing this would be a breaking change. I would suggest keeping it as is and maybe down the road we can explore user experience options via configuration.",
        "pr_file_module": null
      },
      {
        "comment_id": "1569884176",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3763,
        "pr_file": "opentelemetry-api/src/opentelemetry/context/__init__.py",
        "discussion_id": "1567689535",
        "commented_code": "@@ -25,54 +23,35 @@\n from opentelemetry.util._importlib_metadata import entry_points\n \n logger = logging.getLogger(__name__)\n-_RUNTIME_CONTEXT = None  # type: typing.Optional[_RuntimeContext]\n-_RUNTIME_CONTEXT_LOCK = threading.Lock()\n \n-_F = typing.TypeVar(\"_F\", bound=typing.Callable[..., typing.Any])\n \n-\n-def _load_runtime_context(func: _F) -> _F:\n-    \"\"\"A decorator used to initialize the global RuntimeContext\n+def _load_runtime_context() -> typing.Optional[_RuntimeContext]:\n+    \"\"\"Initialize the RuntimeContext\n \n     Returns:\n-        A wrapper of the decorated method.\n+        An instance of RuntimeContext.\n     \"\"\"\n \n-    @wraps(func)  # type: ignore[misc]\n-    def wrapper(\n-        *args: typing.Tuple[typing.Any, typing.Any],\n-        **kwargs: typing.Dict[typing.Any, typing.Any],\n-    ) -> typing.Optional[typing.Any]:\n-        global _RUNTIME_CONTEXT  # pylint: disable=global-statement\n-\n-        with _RUNTIME_CONTEXT_LOCK:\n-            if _RUNTIME_CONTEXT is None:\n-                # FIXME use a better implementation of a configuration manager\n-                # to avoid having to get configuration values straight from\n-                # environment variables\n-                default_context = \"contextvars_context\"\n-\n-                configured_context = environ.get(\n-                    OTEL_PYTHON_CONTEXT, default_context\n-                )  # type: str\n-                try:\n-\n-                    _RUNTIME_CONTEXT = next(  # type: ignore\n-                        iter(  # type: ignore\n-                            entry_points(  # type: ignore\n-                                group=\"opentelemetry_context\",\n-                                name=configured_context,\n-                            )\n-                        )\n-                    ).load()()\n-\n-                except Exception:  # pylint: disable=broad-except\n-                    logger.exception(\n-                        \"Failed to load context: %s\", configured_context\n-                    )\n-        return func(*args, **kwargs)  # type: ignore[misc]\n-\n-    return typing.cast(_F, wrapper)  # type: ignore[misc]\n+    # FIXME use a better implementation of a configuration manager\n+    # to avoid having to get configuration values straight from\n+    # environment variables\n+    default_context = \"contextvars_context\"\n+\n+    configured_context = environ.get(\n+        OTEL_PYTHON_CONTEXT, default_context\n+    )  # type: str\n+\n+    return next(  # type: ignore",
        "comment_created_at": "2024-04-18T03:24:56+00:00",
        "comment_author": "WqyJh",
        "comment_body": "OK, it has been restored.",
        "pr_file_module": null
      }
    ]
  }
]