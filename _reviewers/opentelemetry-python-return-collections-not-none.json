[
  {
    "discussion_id": "369666189",
    "pr_number": 367,
    "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
    "created_at": "2020-01-22T16:29:48+00:00",
    "commented_code": "tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "369666189",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T16:29:48+00:00",
        "comment_author": "codeboten",
        "comment_body": "It might be easier to change `_extract_tags` to always return an empty list, rather than checking this here",
        "pr_file_module": null
      },
      {
        "comment_id": "369667730",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T16:32:28+00:00",
        "comment_author": "codeboten",
        "comment_body": "And in fact we probably should since the only other place where it's used also ends up doing some juggling around this: https://github.com/open-telemetry/opentelemetry-python/blob/ed8cbdc74b24dd2d9b30477b054509c1f81a94f6/ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py#L239-L243",
        "pr_file_module": null
      },
      {
        "comment_id": "369680628",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T16:54:12+00:00",
        "comment_author": "dgzlopes",
        "comment_body": "Fixed! Added the check when `span.status` wasn't mandatory, but now it makes no sense.",
        "pr_file_module": null
      },
      {
        "comment_id": "369701496",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T17:33:22+00:00",
        "comment_author": "codeboten",
        "comment_body": "mind updating the in `_extract_logs_from_span` as well? ",
        "pr_file_module": null
      },
      {
        "comment_id": "369715838",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T18:02:04+00:00",
        "comment_author": "dgzlopes",
        "comment_body": "But if we change `_extract_logs_from_span`  to return an empty list when a span has no logs tests break because they expect logs to be None. I think that it's the same with [refs](https://github.com/open-telemetry/opentelemetry-python/blob/ed8cbdc74b24dd2d9b30477b054509c1f81a94f6/ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py#L198).\r\n\r\n```\r\n# Example output form tests\r\nSpan([348 chars]Double=None, vBool=None, vLong=None, vBinary=None)], logs=[])\r\nSpan([348 chars]Double=None, vBool=None, vLong=None, vBinary=None)], logs=None)\r\n```\r\n\r\nMaybe I'm misunderstanding something. What do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "369737295",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T18:46:21+00:00",
        "comment_author": "codeboten",
        "comment_body": "Sorry, I meant to update the code in `_extract_logs_from_span` to take advantage of this new empty list from `_extract_tags`, lines 239 and 240 are no longer needed:\r\nhttps://github.com/open-telemetry/opentelemetry-python/blob/ed8cbdc74b24dd2d9b30477b054509c1f81a94f6/ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py#L239-L243\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "369859811",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 367,
        "pr_file": "ext/opentelemetry-ext-jaeger/src/opentelemetry/ext/jaeger/__init__.py",
        "discussion_id": "369666189",
        "commented_code": "@@ -153,8 +156,19 @@ def _translate_to_jaeger(spans: Span):\n \n         tags = _extract_tags(span.attributes)\n \n-        # TODO: status is missing:\n-        # https://github.com/open-telemetry/opentelemetry-python/issues/98\n+        if tags is None:\n+            tags = []",
        "comment_created_at": "2020-01-22T23:21:40+00:00",
        "comment_author": "dgzlopes",
        "comment_body": "Oh, okay! It should be updated now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "378392461",
    "pr_number": 378,
    "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
    "created_at": "2020-02-12T17:12:21+00:00",
    "commented_code": "+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []\n+\n+    def add_metrics_data(self, metric_records: Sequence[MetricRecord]):\n+        self._metrics_to_export.append(metric_records)\n+\n+    def collect(self):\n+        \"\"\"Collect fetches the metrics from OpenTelemetry\n+        and delivers them as Prometheus Metrics.\n+        Collect is invoked every time a prometheus.Gatherer is run\n+        for example when the HTTP endpoint is invoked by Prometheus.\n+        \"\"\"\n+\n+        for metric_batch in self._metrics_to_export:\n+            for metric_record in metric_batch:\n+                prometheus_metric = self._translate_to_prometheus(\n+                    metric_record\n+                )\n+                if prometheus_metric:",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "378392461",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378392461",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.\n+        prefix: single-word application prefix relevant to the domain the metric belongs to.\n+    \"\"\"\n+\n+    def __init__(self, port: int = 8000, address: str = \"\", prefix: str = \"\"):\n+        self._port = port\n+        self._address = address\n+        self._collector = CustomCollector(prefix)\n+\n+        start_http_server(port=self._port, addr=str(self._address))\n+        REGISTRY.register(self._collector)\n+\n+    def export(\n+        self, metric_records: Sequence[MetricRecord]\n+    ) -> MetricsExportResult:\n+        self._collector.add_metrics_data(metric_records)\n+        return MetricsExportResult.SUCCESS\n+\n+    def shutdown(self) -> None:\n+        REGISTRY.unregister(self._collector)\n+\n+\n+class CustomCollector:\n+    \"\"\" CustomCollector represents the Prometheus Collector object\n+        https://github.com/prometheus/client_python#custom-collectors\n+    \"\"\"\n+\n+    def __init__(self, prefix: str = \"\"):\n+        self._prefix = prefix\n+        self._metrics_to_export = []\n+\n+    def add_metrics_data(self, metric_records: Sequence[MetricRecord]):\n+        self._metrics_to_export.append(metric_records)\n+\n+    def collect(self):\n+        \"\"\"Collect fetches the metrics from OpenTelemetry\n+        and delivers them as Prometheus Metrics.\n+        Collect is invoked every time a prometheus.Gatherer is run\n+        for example when the HTTP endpoint is invoked by Prometheus.\n+        \"\"\"\n+\n+        for metric_batch in self._metrics_to_export:\n+            for metric_record in metric_batch:\n+                prometheus_metric = self._translate_to_prometheus(\n+                    metric_record\n+                )\n+                if prometheus_metric:",
        "comment_created_at": "2020-02-12T17:12:21+00:00",
        "comment_author": "ocelotl",
        "comment_body": "Use `is not None` here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1715380271",
    "pr_number": 4116,
    "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
    "created_at": "2024-08-13T14:16:47+00:00",
    "commented_code": "return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _get_file_content(file_path: str) -> bytes:\n+    file = open(file_path, \"rb\")\n+    content = file.read()\n+    file.close()\n+    return content\n+\n+\n+def _load_credentials(\n+    certificate_file: str,\n+    client_key_file: str,\n+    client_certificate_file: str,\n+) -> ChannelCredentials:\n     try:\n-        with open(filepath, \"rb\") as creds_file:\n-            credential = creds_file.read()\n-            return ssl_channel_credentials(credential)\n-    except FileNotFoundError:\n-        logger.exception(\"Failed to read credential file\")\n+        root_certificates = _get_file_content(certificate_file)\n+        private_key = _get_file_content(client_key_file)\n+        certificate_chain = _get_file_content(client_certificate_file)\n+        return ssl_channel_credentials(\n+            root_certificates=root_certificates,\n+            private_key=private_key,\n+            certificate_chain=certificate_chain,\n+        )\n+    except FileNotFoundError as e:\n+        logger.exception(\n+            f\"Failed to read credential file: {e.filename}. Please check if the file exists and is accessible.\"\n+        )\n         return None",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1715380271",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1715380271",
        "commented_code": "@@ -118,22 +120,49 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _get_file_content(file_path: str) -> bytes:\n+    file = open(file_path, \"rb\")\n+    content = file.read()\n+    file.close()\n+    return content\n+\n+\n+def _load_credentials(\n+    certificate_file: str,\n+    client_key_file: str,\n+    client_certificate_file: str,\n+) -> ChannelCredentials:\n     try:\n-        with open(filepath, \"rb\") as creds_file:\n-            credential = creds_file.read()\n-            return ssl_channel_credentials(credential)\n-    except FileNotFoundError:\n-        logger.exception(\"Failed to read credential file\")\n+        root_certificates = _get_file_content(certificate_file)\n+        private_key = _get_file_content(client_key_file)\n+        certificate_chain = _get_file_content(client_certificate_file)\n+        return ssl_channel_credentials(\n+            root_certificates=root_certificates,\n+            private_key=private_key,\n+            certificate_chain=certificate_chain,\n+        )\n+    except FileNotFoundError as e:\n+        logger.exception(\n+            f\"Failed to read credential file: {e.filename}. Please check if the file exists and is accessible.\"\n+        )\n         return None",
        "comment_created_at": "2024-08-13T14:16:47+00:00",
        "comment_author": "pmcollins",
        "comment_body": "Should the method signature be updated to `Optional[...]`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1716513018",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4116,
        "pr_file": "exporter/opentelemetry-exporter-otlp-proto-grpc/src/opentelemetry/exporter/otlp/proto/grpc/exporter.py",
        "discussion_id": "1715380271",
        "commented_code": "@@ -118,22 +120,49 @@ def get_resource_data(\n     return _get_resource_data(sdk_resource_scope_data, resource_class, name)\n \n \n-def _load_credential_from_file(filepath) -> ChannelCredentials:\n+def _get_file_content(file_path: str) -> bytes:\n+    file = open(file_path, \"rb\")\n+    content = file.read()\n+    file.close()\n+    return content\n+\n+\n+def _load_credentials(\n+    certificate_file: str,\n+    client_key_file: str,\n+    client_certificate_file: str,\n+) -> ChannelCredentials:\n     try:\n-        with open(filepath, \"rb\") as creds_file:\n-            credential = creds_file.read()\n-            return ssl_channel_credentials(credential)\n-    except FileNotFoundError:\n-        logger.exception(\"Failed to read credential file\")\n+        root_certificates = _get_file_content(certificate_file)\n+        private_key = _get_file_content(client_key_file)\n+        certificate_chain = _get_file_content(client_certificate_file)\n+        return ssl_channel_credentials(\n+            root_certificates=root_certificates,\n+            private_key=private_key,\n+            certificate_chain=certificate_chain,\n+        )\n+    except FileNotFoundError as e:\n+        logger.exception(\n+            f\"Failed to read credential file: {e.filename}. Please check if the file exists and is accessible.\"\n+        )\n         return None",
        "comment_created_at": "2024-08-14T08:27:02+00:00",
        "comment_author": "sandy2008",
        "comment_body": "Good point, fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1686119941",
    "pr_number": 4053,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/resources/__init__.py",
    "created_at": "2024-07-22T07:52:26+00:00",
    "commented_code": "if \"otel\" not in otel_experimental_resource_detectors:\n             otel_experimental_resource_detectors.append(\"otel\")\n \n+        resource_detector: str\n         for resource_detector in otel_experimental_resource_detectors:\n             resource_detectors.append(\n                 next(\n                     iter(\n                         entry_points(\n                             group=\"opentelemetry_resource_detector\",\n                             name=resource_detector.strip(),\n-                        )\n+                        )  # type: ignore\n                     )\n                 ).load()()\n             )\n-\n         resource = get_aggregated_resources(\n             resource_detectors, _DEFAULT_RESOURCE\n         ).merge(Resource(attributes, schema_url))\n \n         if not resource.attributes.get(SERVICE_NAME, None):\n             default_service_name = \"unknown_service\"\n-            process_executable_name = resource.attributes.get(\n+            process_executable_name: Optional[Union[int, float, Sequence[str], Sequence[int], Sequence[float] ]] = resource.attributes.get(",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1686119941",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4053,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/resources/__init__.py",
        "discussion_id": "1686119941",
        "commented_code": "@@ -184,29 +193,29 @@ def create(\n         if \"otel\" not in otel_experimental_resource_detectors:\n             otel_experimental_resource_detectors.append(\"otel\")\n \n+        resource_detector: str\n         for resource_detector in otel_experimental_resource_detectors:\n             resource_detectors.append(\n                 next(\n                     iter(\n                         entry_points(\n                             group=\"opentelemetry_resource_detector\",\n                             name=resource_detector.strip(),\n-                        )\n+                        )  # type: ignore\n                     )\n                 ).load()()\n             )\n-\n         resource = get_aggregated_resources(\n             resource_detectors, _DEFAULT_RESOURCE\n         ).merge(Resource(attributes, schema_url))\n \n         if not resource.attributes.get(SERVICE_NAME, None):\n             default_service_name = \"unknown_service\"\n-            process_executable_name = resource.attributes.get(\n+            process_executable_name: Optional[Union[int, float, Sequence[str], Sequence[int], Sequence[float] ]] = resource.attributes.get(",
        "comment_created_at": "2024-07-22T07:52:26+00:00",
        "comment_author": "xrmx",
        "comment_body": "```suggestion\r\n            process_executable_name: Optional[str] = resource.attributes.get(\r\n```\r\n\r\nCan we assume that we'll have a string there?",
        "pr_file_module": null
      },
      {
        "comment_id": "1687178739",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4053,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/resources/__init__.py",
        "discussion_id": "1686119941",
        "commented_code": "@@ -184,29 +193,29 @@ def create(\n         if \"otel\" not in otel_experimental_resource_detectors:\n             otel_experimental_resource_detectors.append(\"otel\")\n \n+        resource_detector: str\n         for resource_detector in otel_experimental_resource_detectors:\n             resource_detectors.append(\n                 next(\n                     iter(\n                         entry_points(\n                             group=\"opentelemetry_resource_detector\",\n                             name=resource_detector.strip(),\n-                        )\n+                        )  # type: ignore\n                     )\n                 ).load()()\n             )\n-\n         resource = get_aggregated_resources(\n             resource_detectors, _DEFAULT_RESOURCE\n         ).merge(Resource(attributes, schema_url))\n \n         if not resource.attributes.get(SERVICE_NAME, None):\n             default_service_name = \"unknown_service\"\n-            process_executable_name = resource.attributes.get(\n+            process_executable_name: Optional[Union[int, float, Sequence[str], Sequence[int], Sequence[float] ]] = resource.attributes.get(",
        "comment_created_at": "2024-07-22T21:51:55+00:00",
        "comment_author": "asasvari",
        "comment_body": "I believe it is a string; didn't see a counter example. However, when I applied the suggestion I ran into another problem:\r\n```\r\nopentelemetry-sdk/src/opentelemetry/sdk/resources/__init__.py:214: error: Incompatible types in assignment (expression has type \"int | float | Sequence[str] | Sequence[int] | Sequence[float] | None\", variable has type \"str | None\")  [assignment]\r\nFound 1 error in 1 file (checked 1 source file)\r\n```\r\nI ended up casting the type (the value is unchanged)\r\n```py\r\n            process_executable_name = cast(Optional[str], resource.attributes.get(\r\n                PROCESS_EXECUTABLE_NAME, None\r\n            ))\r\n```\r\n\r\nDoing this also allowed to remove some unused type: ignore comments in other parts.\r\n            ",
        "pr_file_module": null
      }
    ]
  }
]