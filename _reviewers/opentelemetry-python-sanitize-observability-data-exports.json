[
  {
    "discussion_id": "1610649762",
    "pr_number": 3924,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
    "created_at": "2024-05-22T21:06:02+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1610649762",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610649762",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",",
        "comment_created_at": "2024-05-22T21:06:02+00:00",
        "comment_author": "ocelotl",
        "comment_body": "```suggestion\r\n    \"Cel\": \"degree celsius\",\r\n```\r\n\r\nFrom [this](https://www.bipm.org/documents/20126/41483022/SI-Brochure-9-concise-EN.pdf/2fda4656-e236-0fcb-3867-36ca74eea4e3).",
        "pr_file_module": null
      },
      {
        "comment_id": "1610908965",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610649762",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",",
        "comment_created_at": "2024-05-23T03:14:21+00:00",
        "comment_author": "aabmass",
        "comment_body": "The keys of this mapping are UCUM unit names and the values are the [Prometheus conventions](https://prometheus.io/docs/practices/naming/#base-units). I see `celsius` in there so I think this mapping works as expected",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1610752781",
    "pr_number": 3924,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
    "created_at": "2024-05-22T22:43:08+00:00",
    "commented_code": "pre_metric_family_ids = []\n \n-            metric_name = \"\"\n-            metric_name += self._sanitize(metric.name)\n+            metric_name = sanitize_full_name(metric.name)",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1610752781",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
        "discussion_id": "1610752781",
        "commented_code": "@@ -228,17 +230,17 @@ def _translate_to_prometheus(\n \n             pre_metric_family_ids = []\n \n-            metric_name = \"\"\n-            metric_name += self._sanitize(metric.name)\n+            metric_name = sanitize_full_name(metric.name)",
        "comment_created_at": "2024-05-22T22:43:08+00:00",
        "comment_author": "lzchen",
        "comment_body": "> The resulting unit SHOULD be added to the metric as [UNIT metadata](https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#metricfamily) and as a suffix to the metric name unless the metric name already contains the unit, or the unit MUST be omitted.\r\n\r\nDoesn't the name need to have the unit appended as a suffix if it doesn't exist already in the name?",
        "pr_file_module": null
      },
      {
        "comment_id": "1610904610",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
        "discussion_id": "1610752781",
        "commented_code": "@@ -228,17 +230,17 @@ def _translate_to_prometheus(\n \n             pre_metric_family_ids = []\n \n-            metric_name = \"\"\n-            metric_name += self._sanitize(metric.name)\n+            metric_name = sanitize_full_name(metric.name)",
        "comment_created_at": "2024-05-23T03:05:22+00:00",
        "comment_author": "aabmass",
        "comment_body": "We are using the prometheus client library to create prometheus text format. It accepts the name and unit and handles the concatenation for you.\r\n\r\nCheck the `test_metric_name_with_unit` test cases to see the full output",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1610759625",
    "pr_number": 3924,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
    "created_at": "2024-05-22T22:46:06+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)\n+\n+\n+def map_unit(unit: str) -> str:\n+    \"\"\"Maps unit to common prometheus metric names if available and sanitizes any invalid\n+    characters\n+\n+    See:\n+    - https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    - https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L108\n+    \"\"\"\n+    # remove curly brace UCUM annotations\n+    unit = _UCUM_ANNOTATION_CURLY.sub(\"\", unit)\n+\n+    if unit in _UNIT_MAPPINGS:\n+        return _UNIT_MAPPINGS[unit]\n+\n+    # replace \"/\" with \"per\" units like m/s -> meters_per_second\n+    ratio_unit_subparts = unit.split(\"/\", maxsplit=1)\n+    if len(ratio_unit_subparts) == 2:\n+        bottom = _sanitize_name(ratio_unit_subparts[1])\n+        if bottom:\n+            top = _sanitize_name(ratio_unit_subparts[0])\n+            top = _UNIT_MAPPINGS.get(top, top)\n+            bottom = _PER_UNIT_MAPPINGS.get(bottom, bottom)\n+            return f\"{top}_per_{bottom}\" if top else f\"per_{bottom}\"\n+\n+    return (\n+        # since units end up as a metric name suffix, they must be sanitized\n+        _sanitize_name(unit)\n+        # strip surrounding \"_\" chars since it will lead to consecutive underscores in the\n+        # metric name\n+        .strip(\"_\")",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1610759625",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610759625",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)\n+\n+\n+def map_unit(unit: str) -> str:\n+    \"\"\"Maps unit to common prometheus metric names if available and sanitizes any invalid\n+    characters\n+\n+    See:\n+    - https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    - https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L108\n+    \"\"\"\n+    # remove curly brace UCUM annotations\n+    unit = _UCUM_ANNOTATION_CURLY.sub(\"\", unit)\n+\n+    if unit in _UNIT_MAPPINGS:\n+        return _UNIT_MAPPINGS[unit]\n+\n+    # replace \"/\" with \"per\" units like m/s -> meters_per_second\n+    ratio_unit_subparts = unit.split(\"/\", maxsplit=1)\n+    if len(ratio_unit_subparts) == 2:\n+        bottom = _sanitize_name(ratio_unit_subparts[1])\n+        if bottom:\n+            top = _sanitize_name(ratio_unit_subparts[0])\n+            top = _UNIT_MAPPINGS.get(top, top)\n+            bottom = _PER_UNIT_MAPPINGS.get(bottom, bottom)\n+            return f\"{top}_per_{bottom}\" if top else f\"per_{bottom}\"\n+\n+    return (\n+        # since units end up as a metric name suffix, they must be sanitized\n+        _sanitize_name(unit)\n+        # strip surrounding \"_\" chars since it will lead to consecutive underscores in the\n+        # metric name\n+        .strip(\"_\")",
        "comment_created_at": "2024-05-22T22:46:06+00:00",
        "comment_author": "lzchen",
        "comment_body": "> The resulting unit SHOULD be added to the metric as [UNIT metadata](https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#metricfamily) and as a suffix to the metric name unless the metric name already contains the unit, or the unit MUST be omitted.\r\n\r\nJust to clarify, we will be checking the existence of a SANITIZED and valid unit name in a sanitized and valid metric name to determine whether or not to omit the appending of the suffix correct?\r\n\r\nThe current logic makes sense to me, just wondering if there is ever a case where the unit can be found already in the metric name in which case we DON'T have to strip leading `_` from the unit name? Not a blocker, just a small question.",
        "pr_file_module": null
      },
      {
        "comment_id": "1610943063",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610759625",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)\n+\n+\n+def map_unit(unit: str) -> str:\n+    \"\"\"Maps unit to common prometheus metric names if available and sanitizes any invalid\n+    characters\n+\n+    See:\n+    - https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    - https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L108\n+    \"\"\"\n+    # remove curly brace UCUM annotations\n+    unit = _UCUM_ANNOTATION_CURLY.sub(\"\", unit)\n+\n+    if unit in _UNIT_MAPPINGS:\n+        return _UNIT_MAPPINGS[unit]\n+\n+    # replace \"/\" with \"per\" units like m/s -> meters_per_second\n+    ratio_unit_subparts = unit.split(\"/\", maxsplit=1)\n+    if len(ratio_unit_subparts) == 2:\n+        bottom = _sanitize_name(ratio_unit_subparts[1])\n+        if bottom:\n+            top = _sanitize_name(ratio_unit_subparts[0])\n+            top = _UNIT_MAPPINGS.get(top, top)\n+            bottom = _PER_UNIT_MAPPINGS.get(bottom, bottom)\n+            return f\"{top}_per_{bottom}\" if top else f\"per_{bottom}\"\n+\n+    return (\n+        # since units end up as a metric name suffix, they must be sanitized\n+        _sanitize_name(unit)\n+        # strip surrounding \"_\" chars since it will lead to consecutive underscores in the\n+        # metric name\n+        .strip(\"_\")",
        "comment_created_at": "2024-05-23T04:20:09+00:00",
        "comment_author": "aabmass",
        "comment_body": "Good question, I haven't implemented that extra check yet. Since we are using the prometheus client to put together the pieces and not building the whole name ourselves, it's a little tricky.\r\n\r\nThat said I don't think \"unless the metric name already contains the unit\" intended for a substring match check, but rather looking for an existing `_` separated subpart containing the unit. So stripping is probably OK. I'll give it a shot",
        "pr_file_module": null
      },
      {
        "comment_id": "1610969099",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610759625",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)\n+\n+\n+def map_unit(unit: str) -> str:\n+    \"\"\"Maps unit to common prometheus metric names if available and sanitizes any invalid\n+    characters\n+\n+    See:\n+    - https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    - https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L108\n+    \"\"\"\n+    # remove curly brace UCUM annotations\n+    unit = _UCUM_ANNOTATION_CURLY.sub(\"\", unit)\n+\n+    if unit in _UNIT_MAPPINGS:\n+        return _UNIT_MAPPINGS[unit]\n+\n+    # replace \"/\" with \"per\" units like m/s -> meters_per_second\n+    ratio_unit_subparts = unit.split(\"/\", maxsplit=1)\n+    if len(ratio_unit_subparts) == 2:\n+        bottom = _sanitize_name(ratio_unit_subparts[1])\n+        if bottom:\n+            top = _sanitize_name(ratio_unit_subparts[0])\n+            top = _UNIT_MAPPINGS.get(top, top)\n+            bottom = _PER_UNIT_MAPPINGS.get(bottom, bottom)\n+            return f\"{top}_per_{bottom}\" if top else f\"per_{bottom}\"\n+\n+    return (\n+        # since units end up as a metric name suffix, they must be sanitized\n+        _sanitize_name(unit)\n+        # strip surrounding \"_\" chars since it will lead to consecutive underscores in the\n+        # metric name\n+        .strip(\"_\")",
        "comment_created_at": "2024-05-23T04:48:05+00:00",
        "comment_author": "aabmass",
        "comment_body": "> Since we are using the prometheus client to put together the pieces and not building the whole name ourselves, it's a little tricky.\r\n\r\nActually I just checked and the prometheus client already handles the case where metric name already contains the unit. Added some test cases in 39a21a31f69a61448e4a307fcfa9e15daf3f25d3. Hope that addresses your concern",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1610761291",
    "pr_number": 3924,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
    "created_at": "2024-05-22T22:48:54+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1610761291",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610761291",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)",
        "comment_created_at": "2024-05-22T22:48:54+00:00",
        "comment_author": "lzchen",
        "comment_body": "> This may cause ambiguity in scenarios where multiple similar-named attributes share invalid characters at the same location. In such unlikely cases, if multiple key-value pairs are converted to have the same Prometheus key, the values MUST be concatenated together, separated by ;, and ordered by the lexicographical order of the original keys.\r\n\r\nAre we going to be addressing this use case in the future?",
        "pr_file_module": null
      },
      {
        "comment_id": "1610932502",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3924,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/_mapping.py",
        "discussion_id": "1610761291",
        "commented_code": "@@ -0,0 +1,135 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from re import UNICODE, compile\n+\n+_SANITIZE_NAME_RE = compile(r\"([^a-zA-Z0-9:]+)|_{2,}\", UNICODE)\n+# Same as name, but doesn't allow \":\"\n+_SANITIZE_ATTRIBUTE_KEY_RE = compile(r\"([^a-zA-Z0-9]+)|_{2,}\", UNICODE)\n+\n+# UCUM annotations are ASCII chars 33-126 enclosed in curly braces\n+# https://ucum.org/ucum#para-6\n+_UCUM_ANNOTATION_CURLY = compile(r\"{[!-~]*}\")\n+\n+# Remaps common UCUM and SI units to prometheus conventions. Copied from\n+# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/v0.101.0/pkg/translator/prometheus/normalize_name.go#L19\n+# See specification:\n+# https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+_UNIT_MAPPINGS = {\n+    # Time\n+    \"d\": \"days\",\n+    \"h\": \"hours\",\n+    \"min\": \"minutes\",\n+    \"s\": \"seconds\",\n+    \"ms\": \"milliseconds\",\n+    \"us\": \"microseconds\",\n+    \"ns\": \"nanoseconds\",\n+    # Bytes\n+    \"By\": \"bytes\",\n+    \"KiBy\": \"kibibytes\",\n+    \"MiBy\": \"mebibytes\",\n+    \"GiBy\": \"gibibytes\",\n+    \"TiBy\": \"tibibytes\",\n+    \"KBy\": \"kilobytes\",\n+    \"MBy\": \"megabytes\",\n+    \"GBy\": \"gigabytes\",\n+    \"TBy\": \"terabytes\",\n+    # SI\n+    \"m\": \"meters\",\n+    \"V\": \"volts\",\n+    \"A\": \"amperes\",\n+    \"J\": \"joules\",\n+    \"W\": \"watts\",\n+    \"g\": \"grams\",\n+    # Misc\n+    \"Cel\": \"celsius\",\n+    \"Hz\": \"hertz\",\n+    # TODO: this conflicts with the spec but I think it is correct. Need to open a spec issue\n+    \"1\": \"\",\n+    \"%\": \"percent\",\n+}\n+# Similar to _UNIT_MAPPINGS, but for \"per\" unit denominator.\n+# Example: s => per second (singular)\n+# Copied from https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/80317ce83ed87a2dff0c316bb939afbfaa823d5e/pkg/translator/prometheus/normalize_name.go#L58\n+_PER_UNIT_MAPPINGS = {\n+    \"s\": \"second\",\n+    \"m\": \"minute\",\n+    \"h\": \"hour\",\n+    \"d\": \"day\",\n+    \"w\": \"week\",\n+    \"mo\": \"month\",\n+    \"y\": \"year\",\n+}\n+\n+\n+def sanitize_full_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, including sanitizing\n+    leading digits\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-metadata-1\n+    \"\"\"\n+    # Leading number special case\n+    if name and name[0].isdigit():\n+        name = \"_\" + name[1:]\n+    return _sanitize_name(name)\n+\n+\n+def _sanitize_name(name: str) -> str:\n+    \"\"\"sanitize the given metric name according to Prometheus rule, but does not handle\n+    sanitizing a leading digit.\"\"\"\n+    return _SANITIZE_NAME_RE.sub(\"_\", name)\n+\n+\n+def sanitize_attribute(key: str) -> str:\n+    \"\"\"sanitize the given metric attribute key according to Prometheus rule.\n+\n+    https://github.com/open-telemetry/opentelemetry-specification/blob/v1.33.0/specification/compatibility/prometheus_and_openmetrics.md#metric-attributes\n+    \"\"\"\n+    # Leading number special case\n+    if key and key[0].isdigit():\n+        key = \"_\" + key[1:]\n+    return _SANITIZE_ATTRIBUTE_KEY_RE.sub(\"_\", key)",
        "comment_created_at": "2024-05-23T03:58:40+00:00",
        "comment_author": "aabmass",
        "comment_body": "Ya it is an existing bug. Created https://github.com/open-telemetry/opentelemetry-python/issues/3928",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1516625148",
    "pr_number": 3698,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
    "created_at": "2024-03-07T18:22:49+00:00",
    "commented_code": "label_keys = []\n                 label_values = []\n \n-                for key, value in number_data_point.attributes.items():\n+                for key, value in sorted(number_data_point.attributes.items()):",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1516625148",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3698,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
        "discussion_id": "1516625148",
        "commented_code": "@@ -237,7 +237,7 @@ def _translate_to_prometheus(\n                 label_keys = []\n                 label_values = []\n \n-                for key, value in number_data_point.attributes.items():\n+                for key, value in sorted(number_data_point.attributes.items()):",
        "comment_created_at": "2024-03-07T18:22:49+00:00",
        "comment_author": "lzchen",
        "comment_body": "Forgive me for my lack of understanding of how Prometheus backend works but it looks like they accept a list of keys and values and they expect the indices of the pairs (key, value) to line up to represent a label. I'm not sure how sorting the original dictionary solves this issue? Isn't the logic simply pairing off each key/value?",
        "pr_file_module": null
      },
      {
        "comment_id": "1535726523",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3698,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
        "discussion_id": "1516625148",
        "commented_code": "@@ -237,7 +237,7 @@ def _translate_to_prometheus(\n                 label_keys = []\n                 label_values = []\n \n-                for key, value in number_data_point.attributes.items():\n+                for key, value in sorted(number_data_point.attributes.items()):",
        "comment_created_at": "2024-03-22T14:56:24+00:00",
        "comment_author": "soundofspace",
        "comment_body": "Indeed, but how the current logic works:\r\n- Get label_keys and labels_values, for every iteration over metrics we also store labels_values in labels_valuess\r\n- When iterating is done we label_keys, list containing order of keys of only last iteration\r\n- labels_valuess with all label values in a nested list\r\n- When creating a prometheus metric we specify labels at creation time only once, then prometheus expects all label values to have the correct order (when not using kwargs)\r\n\r\nSo to make sure label_keys is always consistent (not including missing keys), my solution was to always sort this. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1535734062",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3698,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/src/opentelemetry/exporter/prometheus/__init__.py",
        "discussion_id": "1516625148",
        "commented_code": "@@ -237,7 +237,7 @@ def _translate_to_prometheus(\n                 label_keys = []\n                 label_values = []\n \n-                for key, value in number_data_point.attributes.items():\n+                for key, value in sorted(number_data_point.attributes.items()):",
        "comment_created_at": "2024-03-22T15:01:21+00:00",
        "comment_author": "soundofspace",
        "comment_body": "It also fixes the problem of generating duplicates metrics, because label keys have a different order. This happens because this code is used to filter duplicates later on:\r\n```\r\npre_metric_family_ids.append(\r\n    \"|\".join(\r\n        [\r\n            metric_name,\r\n            metric_description,\r\n            \"%\".join(label_keys),\r\n            metric.unit,\r\n        ]\r\n    )\r\n)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1473297059",
    "pr_number": 3659,
    "pr_file": "exporter/opentelemetry-exporter-prometheus/tests/test_prometheus_exporter.py",
    "created_at": "2024-01-31T18:36:47+00:00",
    "commented_code": "counter.add(1)\n         result = list(metric_reader._collector.collect())\n \n-        for prometheus_metric in result[:0]:\n-            self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n-            self.assertEqual(prometheus_metric.name, \"target\")\n-            self.assertEqual(\n-                prometheus_metric.documentation, \"Target metadata\"\n-            )\n-            self.assertTrue(len(prometheus_metric.samples) == 1)\n-            self.assertEqual(prometheus_metric.samples[0].value, 1)\n-            self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], \"1\")\n+        self.assertEqual(len(result), 2)\n+\n+        prometheus_metric = result[0]\n+\n+        self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n+        self.assertEqual(prometheus_metric.name, \"target\")\n+        self.assertEqual(prometheus_metric.documentation, \"Target metadata\")\n+        self.assertTrue(len(prometheus_metric.samples) == 1)\n+        self.assertEqual(prometheus_metric.samples[0].value, 1)\n+        self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], 1)",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1473297059",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3659,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/tests/test_prometheus_exporter.py",
        "discussion_id": "1473297059",
        "commented_code": "@@ -358,17 +358,18 @@ def test_target_info_enabled_by_default(self):\n         counter.add(1)\n         result = list(metric_reader._collector.collect())\n \n-        for prometheus_metric in result[:0]:\n-            self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n-            self.assertEqual(prometheus_metric.name, \"target\")\n-            self.assertEqual(\n-                prometheus_metric.documentation, \"Target metadata\"\n-            )\n-            self.assertTrue(len(prometheus_metric.samples) == 1)\n-            self.assertEqual(prometheus_metric.samples[0].value, 1)\n-            self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], \"1\")\n+        self.assertEqual(len(result), 2)\n+\n+        prometheus_metric = result[0]\n+\n+        self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n+        self.assertEqual(prometheus_metric.name, \"target\")\n+        self.assertEqual(prometheus_metric.documentation, \"Target metadata\")\n+        self.assertTrue(len(prometheus_metric.samples) == 1)\n+        self.assertEqual(prometheus_metric.samples[0].value, 1)\n+        self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], 1)",
        "comment_created_at": "2024-01-31T18:36:47+00:00",
        "comment_author": "kornerc",
        "comment_body": "This label had the value of a string before `\"1\"`, but it is an integer `1`.\r\nThus, I changed it to an integer.",
        "pr_file_module": null
      },
      {
        "comment_id": "1477033869",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3659,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/tests/test_prometheus_exporter.py",
        "discussion_id": "1473297059",
        "commented_code": "@@ -358,17 +358,18 @@ def test_target_info_enabled_by_default(self):\n         counter.add(1)\n         result = list(metric_reader._collector.collect())\n \n-        for prometheus_metric in result[:0]:\n-            self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n-            self.assertEqual(prometheus_metric.name, \"target\")\n-            self.assertEqual(\n-                prometheus_metric.documentation, \"Target metadata\"\n-            )\n-            self.assertTrue(len(prometheus_metric.samples) == 1)\n-            self.assertEqual(prometheus_metric.samples[0].value, 1)\n-            self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], \"1\")\n+        self.assertEqual(len(result), 2)\n+\n+        prometheus_metric = result[0]\n+\n+        self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n+        self.assertEqual(prometheus_metric.name, \"target\")\n+        self.assertEqual(prometheus_metric.documentation, \"Target metadata\")\n+        self.assertTrue(len(prometheus_metric.samples) == 1)\n+        self.assertEqual(prometheus_metric.samples[0].value, 1)\n+        self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], 1)",
        "comment_created_at": "2024-02-03T09:56:43+00:00",
        "comment_author": "srikanthccv",
        "comment_body": "Shouldn't it be string as Prometheus format only supports string key-value for labels?",
        "pr_file_module": null
      },
      {
        "comment_id": "1478583250",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3659,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/tests/test_prometheus_exporter.py",
        "discussion_id": "1473297059",
        "commented_code": "@@ -358,17 +358,18 @@ def test_target_info_enabled_by_default(self):\n         counter.add(1)\n         result = list(metric_reader._collector.collect())\n \n-        for prometheus_metric in result[:0]:\n-            self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n-            self.assertEqual(prometheus_metric.name, \"target\")\n-            self.assertEqual(\n-                prometheus_metric.documentation, \"Target metadata\"\n-            )\n-            self.assertTrue(len(prometheus_metric.samples) == 1)\n-            self.assertEqual(prometheus_metric.samples[0].value, 1)\n-            self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], \"1\")\n+        self.assertEqual(len(result), 2)\n+\n+        prometheus_metric = result[0]\n+\n+        self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n+        self.assertEqual(prometheus_metric.name, \"target\")\n+        self.assertEqual(prometheus_metric.documentation, \"Target metadata\")\n+        self.assertTrue(len(prometheus_metric.samples) == 1)\n+        self.assertEqual(prometheus_metric.samples[0].value, 1)\n+        self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], 1)",
        "comment_created_at": "2024-02-05T16:59:17+00:00",
        "comment_author": "kornerc",
        "comment_body": "Yes you are right, this raises also an exception `AttributeError: (\"'int' object has no attribute 'replace'\", Metric(target, Target metadata, info` (`prometheus_client\\openmetrics\\exposition.py\", line 33, in <listcomp> k, v.replace('\\\\', r'\\\\').replace('\\n', r'\\n').replace('\"', r'\\\"'))`) in this minimal example:\r\n\r\n```python\r\nimport time\r\n\r\nfrom prometheus_client import start_http_server\r\n\r\nfrom opentelemetry import metrics\r\nfrom opentelemetry.exporter.prometheus import PrometheusMetricReader\r\nfrom opentelemetry.sdk.metrics import MeterProvider\r\nfrom opentelemetry.sdk.resources import SERVICE_NAME, Resource\r\n\r\nresource = Resource(attributes={\r\n    SERVICE_NAME: \"your-service-name\",\r\n    \"foo\": \"bar\",\r\n    \"hist\": 1,\r\n})\r\n\r\nstart_http_server(port=8000, addr=\"localhost\")\r\nreader = PrometheusMetricReader()\r\nprovider = MeterProvider(resource=resource, metric_readers=[reader])\r\nmetrics.set_meter_provider(provider)\r\n\r\nmeter = metrics.get_meter(\"my.meter.name\")\r\n\r\nwork_counter = meter.create_counter(\r\n    \"work.counter\", unit=\"1\", description=\"Counts the amount of work done\"\r\n)\r\n\r\nwhile True:\r\n    work_counter.add(1, {\"work.type\": \"Debug\"})\r\n    print(\"doing some work...\")\r\n    time.sleep(1)\r\n```\r\n\r\nI will write a bug report and will directly address the bug in this PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "1480377433",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 3659,
        "pr_file": "exporter/opentelemetry-exporter-prometheus/tests/test_prometheus_exporter.py",
        "discussion_id": "1473297059",
        "commented_code": "@@ -358,17 +358,18 @@ def test_target_info_enabled_by_default(self):\n         counter.add(1)\n         result = list(metric_reader._collector.collect())\n \n-        for prometheus_metric in result[:0]:\n-            self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n-            self.assertEqual(prometheus_metric.name, \"target\")\n-            self.assertEqual(\n-                prometheus_metric.documentation, \"Target metadata\"\n-            )\n-            self.assertTrue(len(prometheus_metric.samples) == 1)\n-            self.assertEqual(prometheus_metric.samples[0].value, 1)\n-            self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n-            self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], \"1\")\n+        self.assertEqual(len(result), 2)\n+\n+        prometheus_metric = result[0]\n+\n+        self.assertEqual(type(prometheus_metric), InfoMetricFamily)\n+        self.assertEqual(prometheus_metric.name, \"target\")\n+        self.assertEqual(prometheus_metric.documentation, \"Target metadata\")\n+        self.assertTrue(len(prometheus_metric.samples) == 1)\n+        self.assertEqual(prometheus_metric.samples[0].value, 1)\n+        self.assertTrue(len(prometheus_metric.samples[0].labels) == 2)\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"os\"], \"Unix\")\n+        self.assertEqual(prometheus_metric.samples[0].labels[\"histo\"], 1)",
        "comment_created_at": "2024-02-06T18:31:50+00:00",
        "comment_author": "kornerc",
        "comment_body": "@srikanthccv I modified this PR to primarily address the issue with the possible non-string representation of the `target_info` metric.\r\nNonetheless, it still includes the fix of the test `test_target_info_enabled_by_default` which contained dead code.\r\n\r\nI moved the relevant parts of the test which check for the correct representation of the `target_info` metric into the test `test_target_info_sanitize`.",
        "pr_file_module": null
      }
    ]
  }
]