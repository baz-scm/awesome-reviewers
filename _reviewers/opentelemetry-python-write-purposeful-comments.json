[
  {
    "discussion_id": "351030592",
    "pr_number": 258,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/__init__.py",
    "created_at": "2019-11-26T23:27:12+00:00",
    "commented_code": "description,\n             unit,\n             value_type,\n+            meter,\n             label_keys=label_keys,\n             enabled=enabled,\n             monotonic=monotonic,\n         )\n \n-    def record(\n-        self, label_values: Sequence[str], value: metrics_api.ValueT\n-    ) -> None:\n+    def record(self, label_set: LabelSet, value: metrics_api.ValueT) -> None:\n         \"\"\"See `opentelemetry.metrics.Measure.record`.\"\"\"\n-        self.get_handle(label_values).record(value)\n+        self.get_handle(label_set).record(value)\n \n     UPDATE_FUNCTION = record\n \n \n+# Singleton of meter.get_label_set() with zero arguments",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "351030592",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 258,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/__init__.py",
        "discussion_id": "351030592",
        "commented_code": "@@ -226,31 +262,37 @@ def __init__(\n             description,\n             unit,\n             value_type,\n+            meter,\n             label_keys=label_keys,\n             enabled=enabled,\n             monotonic=monotonic,\n         )\n \n-    def record(\n-        self, label_values: Sequence[str], value: metrics_api.ValueT\n-    ) -> None:\n+    def record(self, label_set: LabelSet, value: metrics_api.ValueT) -> None:\n         \"\"\"See `opentelemetry.metrics.Measure.record`.\"\"\"\n-        self.get_handle(label_values).record(value)\n+        self.get_handle(label_set).record(value)\n \n     UPDATE_FUNCTION = record\n \n \n+# Singleton of meter.get_label_set() with zero arguments",
        "comment_created_at": "2019-11-26T23:27:12+00:00",
        "comment_author": "c24t",
        "comment_body": "Nit: this is evident from the code, the comment would be more helpful if it described how this is used. I actually expected it to be a placeholder default arg like `Tracer.CURRENT_SPAN`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "378221805",
    "pr_number": 378,
    "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
    "created_at": "2020-02-12T12:31:57+00:00",
    "commented_code": "+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "378221805",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 378,
        "pr_file": "ext/opentelemetry-ext-prometheus/src/opentelemetry/ext/prometheus/__init__.py",
        "discussion_id": "378221805",
        "commented_code": "@@ -0,0 +1,157 @@\n+# Copyright 2020, OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"Prometheus Metrics Exporter for OpenTelemetry.\"\"\"\n+\n+import logging\n+import re\n+from typing import Sequence\n+\n+from prometheus_client import start_http_server\n+from prometheus_client.core import (\n+    REGISTRY,\n+    CollectorRegistry,\n+    CounterMetricFamily,\n+    GaugeMetricFamily,\n+    UnknownMetricFamily,\n+)\n+\n+from opentelemetry.metrics import Counter, Gauge, Measure, Metric\n+from opentelemetry.sdk.metrics.export import (\n+    MetricRecord,\n+    MetricsExporter,\n+    MetricsExportResult,\n+)\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PrometheusMetricsExporter(MetricsExporter):\n+    \"\"\"Prometheus metric exporter for OpenTelemetry.\n+\n+    Args:\n+        port: The Prometheus port to be used.\n+        address: The Prometheus address to be used.",
        "comment_created_at": "2020-02-12T12:31:57+00:00",
        "comment_author": "mauriciovasquezbernal",
        "comment_body": "Do you think we could clarify the comments on those to make it clear that they are the address & port where this listen for requests from Prometheus?.\r\n\r\nOpenCensus have \"Port number to listen\" & \"Endpoint address (default is localhost)\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2085139615",
    "pr_number": 4562,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_shared_internal/__init__.py",
    "created_at": "2025-05-12T17:30:12+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from __future__ import annotations\n+\n+import collections\n+import enum\n+import logging\n+import os\n+import threading\n+import weakref\n+from abc import abstractmethod\n+from typing import (\n+    Generic,\n+    Optional,\n+    Protocol,\n+    TypeVar,\n+)\n+\n+from opentelemetry.context import (\n+    _SUPPRESS_INSTRUMENTATION_KEY,\n+    attach,\n+    detach,\n+    set_value,\n+)\n+from opentelemetry.util._once import Once\n+\n+\n+class BatchExportStrategy(enum.Enum):\n+    EXPORT_ALL = 0\n+    EXPORT_WHILE_BATCH_EXCEEDS_THRESHOLD = 1\n+    EXPORT_AT_LEAST_ONE_BATCH = 2\n+\n+\n+Telemetry = TypeVar(\"Telemetry\")\n+\n+\n+class Exporter(Protocol[Telemetry]):\n+    @abstractmethod\n+    def export(self, data: list[Telemetry]):\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def shutdown(self):\n+        raise NotImplementedError\n+\n+\n+class BatchProcessor(Generic[Telemetry]):",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "2085139615",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4562,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_shared_internal/__init__.py",
        "discussion_id": "2085139615",
        "commented_code": "@@ -0,0 +1,194 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from __future__ import annotations\n+\n+import collections\n+import enum\n+import logging\n+import os\n+import threading\n+import weakref\n+from abc import abstractmethod\n+from typing import (\n+    Generic,\n+    Optional,\n+    Protocol,\n+    TypeVar,\n+)\n+\n+from opentelemetry.context import (\n+    _SUPPRESS_INSTRUMENTATION_KEY,\n+    attach,\n+    detach,\n+    set_value,\n+)\n+from opentelemetry.util._once import Once\n+\n+\n+class BatchExportStrategy(enum.Enum):\n+    EXPORT_ALL = 0\n+    EXPORT_WHILE_BATCH_EXCEEDS_THRESHOLD = 1\n+    EXPORT_AT_LEAST_ONE_BATCH = 2\n+\n+\n+Telemetry = TypeVar(\"Telemetry\")\n+\n+\n+class Exporter(Protocol[Telemetry]):\n+    @abstractmethod\n+    def export(self, data: list[Telemetry]):\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def shutdown(self):\n+        raise NotImplementedError\n+\n+\n+class BatchProcessor(Generic[Telemetry]):",
        "comment_created_at": "2025-05-12T17:30:12+00:00",
        "comment_author": "aabmass",
        "comment_body": "nit would you mind adding a small docstring to explain what this is and what it's used for",
        "pr_file_module": null
      },
      {
        "comment_id": "2085168876",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4562,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/_shared_internal/__init__.py",
        "discussion_id": "2085139615",
        "commented_code": "@@ -0,0 +1,194 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from __future__ import annotations\n+\n+import collections\n+import enum\n+import logging\n+import os\n+import threading\n+import weakref\n+from abc import abstractmethod\n+from typing import (\n+    Generic,\n+    Optional,\n+    Protocol,\n+    TypeVar,\n+)\n+\n+from opentelemetry.context import (\n+    _SUPPRESS_INSTRUMENTATION_KEY,\n+    attach,\n+    detach,\n+    set_value,\n+)\n+from opentelemetry.util._once import Once\n+\n+\n+class BatchExportStrategy(enum.Enum):\n+    EXPORT_ALL = 0\n+    EXPORT_WHILE_BATCH_EXCEEDS_THRESHOLD = 1\n+    EXPORT_AT_LEAST_ONE_BATCH = 2\n+\n+\n+Telemetry = TypeVar(\"Telemetry\")\n+\n+\n+class Exporter(Protocol[Telemetry]):\n+    @abstractmethod\n+    def export(self, data: list[Telemetry]):\n+        raise NotImplementedError\n+\n+    @abstractmethod\n+    def shutdown(self):\n+        raise NotImplementedError\n+\n+\n+class BatchProcessor(Generic[Telemetry]):",
        "comment_created_at": "2025-05-12T17:51:10+00:00",
        "comment_author": "DylanRussell",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1733383418",
    "pr_number": 4094,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
    "created_at": "2024-08-27T19:02:37+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (\n+            {\n+                k: v\n+                for k, v in self.__attributes.items()\n+                if k not in point_attributes\n+            }\n+            if self.__attributes\n+            else None\n+        )\n+\n+        exemplar = Exemplar(\n+            current_attributes,\n+            self.__value,\n+            self.__time_unix_nano,\n+            self.__span_id,\n+            self.__trace_id,\n+        )\n+        self.__reset()\n+        return exemplar\n+\n+    def __reset(self) -> None:\n+        self.__value = 0\n+        self.__attributes = {}\n+        self.__time_unix_nano = 0\n+        self.__span_id = None\n+        self.__trace_id = None\n+        self.__offered = False\n+\n+\n+class FixedSizeExemplarReservoirABC(ExemplarReservoir):\n+    \"\"\"Abstract class for a reservoir with fixed size.\"\"\"\n+\n+    def __init__(self, size: int, **kwargs) -> None:\n+        super().__init__(**kwargs)\n+        self._size: int = size\n+        self._reservoir_storage: list[ExemplarBucket] = [\n+            ExemplarBucket() for _ in range(self._size)\n+        ]\n+\n+    def maxSize(self) -> int:\n+        \"\"\"Reservoir maximal size\"\"\"\n+        return self._size\n+\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        exemplars = filter(\n+            lambda e: e is not None,\n+            map(\n+                lambda bucket: bucket.collect(point_attributes),\n+                self._reservoir_storage,\n+            ),\n+        )\n+        self._reset()\n+        return [*exemplars]\n+\n+    def _reset(self) -> None:\n+        \"\"\"Reset the reservoir.\"\"\"",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1733383418",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4094,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
        "discussion_id": "1733383418",
        "commented_code": "@@ -0,0 +1,263 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (\n+            {\n+                k: v\n+                for k, v in self.__attributes.items()\n+                if k not in point_attributes\n+            }\n+            if self.__attributes\n+            else None\n+        )\n+\n+        exemplar = Exemplar(\n+            current_attributes,\n+            self.__value,\n+            self.__time_unix_nano,\n+            self.__span_id,\n+            self.__trace_id,\n+        )\n+        self.__reset()\n+        return exemplar\n+\n+    def __reset(self) -> None:\n+        self.__value = 0\n+        self.__attributes = {}\n+        self.__time_unix_nano = 0\n+        self.__span_id = None\n+        self.__trace_id = None\n+        self.__offered = False\n+\n+\n+class FixedSizeExemplarReservoirABC(ExemplarReservoir):\n+    \"\"\"Abstract class for a reservoir with fixed size.\"\"\"\n+\n+    def __init__(self, size: int, **kwargs) -> None:\n+        super().__init__(**kwargs)\n+        self._size: int = size\n+        self._reservoir_storage: list[ExemplarBucket] = [\n+            ExemplarBucket() for _ in range(self._size)\n+        ]\n+\n+    def maxSize(self) -> int:\n+        \"\"\"Reservoir maximal size\"\"\"\n+        return self._size\n+\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        exemplars = filter(\n+            lambda e: e is not None,\n+            map(\n+                lambda bucket: bucket.collect(point_attributes),\n+                self._reservoir_storage,\n+            ),\n+        )\n+        self._reset()\n+        return [*exemplars]\n+\n+    def _reset(self) -> None:\n+        \"\"\"Reset the reservoir.\"\"\"",
        "comment_created_at": "2024-08-27T19:02:37+00:00",
        "comment_author": "lzchen",
        "comment_body": "Could you clarify in the docstring here that `reset` is used for resetting any stateful logic after a collection cycle?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1733396661",
    "pr_number": 4094,
    "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
    "created_at": "2024-08-27T19:13:28+00:00",
    "commented_code": "+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1733396661",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4094,
        "pr_file": "opentelemetry-sdk/src/opentelemetry/sdk/metrics/_internal/exemplar/exemplar_reservoir.py",
        "discussion_id": "1733396661",
        "commented_code": "@@ -0,0 +1,263 @@\n+# Copyright The OpenTelemetry Authors\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from abc import ABC, abstractmethod\n+from random import randrange\n+from typing import Any, Callable, Optional, Sequence, TypeAlias, Union\n+\n+from opentelemetry import trace\n+from opentelemetry.context import Context\n+from opentelemetry.trace.span import INVALID_SPAN\n+from opentelemetry.util.types import Attributes\n+\n+from .exemplar import Exemplar\n+\n+\n+class ExemplarReservoir(ABC):\n+    \"\"\"ExemplarReservoir provide a method to offer measurements to the reservoir\n+    and another to collect accumulated Exemplars.\n+\n+    Note:\n+        The constructor MUST accept ``**kwargs`` that may be set from aggregation\n+        parameters.\n+\n+    Reference:\n+        https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#exemplarreservoir\n+    \"\"\"\n+\n+    @abstractmethod\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        raise NotImplementedError(\"ExemplarReservoir.offer is not implemented\")\n+\n+    @abstractmethod\n+    def collect(self, point_attributes: Attributes) -> list[Exemplar]:\n+        \"\"\"Returns accumulated Exemplars and also resets the reservoir for the next\n+        sampling period\n+\n+        Args:\n+            point_attributes The attributes associated with metric point.\n+\n+        Returns:\n+            a list of :class:`opentelemetry.sdk.metrics.exemplar.Exemplar`s. Returned\n+            exemplars contain the attributes that were filtered out by the aggregator,\n+            but recorded alongside the original measurement.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"ExemplarReservoir.collect is not implemented\"\n+        )\n+\n+\n+class ExemplarBucket:\n+    def __init__(self) -> None:\n+        self.__value: Union[int, float] = 0\n+        self.__attributes: Attributes = None\n+        self.__time_unix_nano: int = 0\n+        self.__span_id: Optional[str] = None\n+        self.__trace_id: Optional[str] = None\n+        self.__offered: bool = False\n+\n+    def offer(\n+        self,\n+        value: Union[int, float],\n+        time_unix_nano: int,\n+        attributes: Attributes,\n+        ctx: Context,\n+    ) -> None:\n+        \"\"\"Offers a measurement to be sampled.\"\"\"\n+        self.__value = value\n+        self.__time_unix_nano = time_unix_nano\n+        self.__attributes = attributes\n+        span = trace.get_current_span(ctx)\n+        if span != INVALID_SPAN:\n+            span_context = span.get_span_context()\n+            self.__span_id = span_context.span_id\n+            self.__trace_id = span_context.trace_id\n+\n+        self.__offered = True\n+\n+    def collect(self, point_attributes: Attributes) -> Exemplar | None:\n+        \"\"\"May return an Exemplar and resets the bucket for the next sampling period.\"\"\"\n+        if not self.__offered:\n+            return None\n+\n+        current_attributes = (",
        "comment_created_at": "2024-08-27T19:13:28+00:00",
        "comment_author": "lzchen",
        "comment_body": "Nit: Maybe put a comment here to explain this logic. We are iterating through `self.__attributes` which contains the entire set of original attributes from the recorded `Measurement` and saving only the remaining attributes after filtering out the keys from the post-view filtered attributes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1765307451",
    "pr_number": 4185,
    "pr_file": "opentelemetry-api/src/opentelemetry/util/types.py",
    "created_at": "2024-09-18T15:44:29+00:00",
    "commented_code": "# limitations under the License.\n \n \n-from typing import Mapping, Optional, Sequence, Tuple, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Tuple, Union\n \n+AnyValue = Union[",
    "repo_full_name": "open-telemetry/opentelemetry-python",
    "discussion_comments": [
      {
        "comment_id": "1765307451",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4185,
        "pr_file": "opentelemetry-api/src/opentelemetry/util/types.py",
        "discussion_id": "1765307451",
        "commented_code": "@@ -13,8 +13,11 @@\n # limitations under the License.\n \n \n-from typing import Mapping, Optional, Sequence, Tuple, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Tuple, Union\n \n+AnyValue = Union[",
        "comment_created_at": "2024-09-18T15:44:29+00:00",
        "comment_author": "lzchen",
        "comment_body": "Nit: Might be nice to add a comment to link to [this](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#type-any) in the specs.",
        "pr_file_module": null
      },
      {
        "comment_id": "1771469784",
        "repo_full_name": "open-telemetry/opentelemetry-python",
        "pr_number": 4185,
        "pr_file": "opentelemetry-api/src/opentelemetry/util/types.py",
        "discussion_id": "1765307451",
        "commented_code": "@@ -13,8 +13,11 @@\n # limitations under the License.\n \n \n-from typing import Mapping, Optional, Sequence, Tuple, Union\n+from typing import Dict, List, Mapping, Optional, Sequence, Tuple, Union\n \n+AnyValue = Union[",
        "comment_created_at": "2024-09-23T13:42:06+00:00",
        "comment_author": "Ali-Alnosairi",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  }
]