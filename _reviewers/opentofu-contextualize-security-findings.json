[
  {
    "discussion_id": "2016352038",
    "pr_number": 2636,
    "pr_file": ".github/workflows/govulncheck.yml",
    "created_at": "2025-03-27T11:53:17+00:00",
    "commented_code": "+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will attempt to create an issue with the results for each scanned version\n+# in case any vulnerability is found. If the issue for the scanned branch already exists\n+# the run will just print the scan output and will leave the issue untouched.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  gather-branches:\n+    name: Collect the branches that needs to be scanned\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    outputs:\n+      branches: ${{ steps.branches.outputs.branches }}\n+    steps:\n+      - id: branches\n+        run: |\n+          ## This is using GitHub API and we manually filter out the versions that are not supported anymore\n+          # gh api \"repos/opentofu/opentofu/branches?protected=true\" --paginate | tee out \n+          # cat out | jq '.[] | select(.name != \"v1.6\") | [.name]' | jq -sc 'add' | tee branches\n+          # echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+          \n+          ## This is using https://endoflife.date since there 1.6 is already marked as it reached EOL\n+          ## This is adding manually the main branch to scan it as well\n+          curl https://endoflife.date/api/opentofu.json | tee out \n+          cat out | jq '.[] | select(.eol == false) | [\"v\" + .cycle]' | jq -sc 'add' | jq -c '[\"main\"] + .' | tee branches\n+          echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    needs: gather-branches\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    strategy:\n+      matrix:\n+        branch: ${{ fromJSON(needs.gather-branches.outputs.branches )}}\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"\n+        shell: bash\n+\n+      # Upload the artifact to make it available to the next job.\n+      # The artifact will be named as the branch name that we are scanning (\"main\" or \"v1.7\"...)\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: ${{matrix.branch}}-results\n+          path: ${{matrix.branch}}\n+\n+  create-issues:\n+    name: Compile results and create GH issues\n+    needs:\n+    - govulncheck\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    steps:\n+      # By providing the path where to download the artifacts and \"merge-multiple: true\", the downloader\n+      # will gather all the files generated in the job(s) above into a single directory flattening the file tree.\n+      # Eg: Instead of writing the results into \"results/main-results/main\" it will write the results into \"results/main\"\n+      - name: Download vulns results\n+        uses: actions/download-artifact@v4\n+        with:\n+          path: results\n+          merge-multiple: true\n+      - name: Run and report govulncheck findings\n+        run: |\n+          # Convert the results of type [\"vulnKey1\", \"vulnKey2\", ...] in files named like \"main\", \"v1.7\", etc to a struct of structure like\n+          # {\"vulnKey1\": [\"main\", \"v1.7\", ...], \"vulnKey2\": [\"main\", \"v1.7\", ...]}\n+          \n+          # Start the script with an empty json object\n+          vuln_to_versions=\"{}\"\n+          cd results\n+          for version in *; do\n+            while IFS= read -r vuln;\n+            do\n+              [[ -z \"${vuln}\" ]] && continue\n+              # Actions from this like:\n+              # * is giving the shell var for the vulnerability key to jq (--arg vl \"${vuln}\") \n+              # * is giving the shell var that contains the scanned version to jq (--arg vers \"${version}\"\n+              # * is getting from vuln_to_versions the key name that needs to be a vulnerability key and assigns to its array the currently proceesed version ('.[$vl] = .[$vl] + [$vers]')\n+              # * this is generating outputs like {\"vulnKey\": [\"version1\", \"version2\"]}. Eg: {\"GO-2024-2947\":[\"v1.7\"]}\n+              # * in the end overwrites the content of vuln_to_versions with the newly generated content \n+              vuln_to_versions=\"$(echo \"${vuln_to_versions}\" | jq -c --arg vl \"${vuln}\" --arg vers \"${version}\" '.[$vl] = .[$vl] + [$vers]')\"\n+            done <<< \"$(cat $version | jq -r '.[]')\" # This one is exploding a json array into multiple lines\n+          done\n+          \n+          # This is just using the \".key\" that is the vulnerability key and \".value\" that is the list of affected version(s)\n+          # to generate the commmands to create GitHub issues.\n+          while IFS= read -r vuln; \n+          do \n+            vuln_key=\"$(echo ${vuln} | jq -r '.key')\"\n+            affected_versions=\"$(echo ${vuln} | jq -r '.value[]' | xargs)\"\n+            ticket_title=\"${vuln_key} reported\"\n+\n+            reported_issues=\"$(gh issue -R opentofu/opentofu list --search \"\\\"${ticket_title}\\\" state:open\" --json number)\"\n+            no_of_issues=\"$(echo ${reported_issues} | jq -r '. | length')\"\n+            reported_issues=\"$(echo $reported_issues| jq -r '.[] | .number' | xargs)\"\n+            [[ ${no_of_issues} -ge 1 ]] && echo \"Vulnerabilties found but already reported for ${vuln_key} in: ${reported_issues}\" && exit 0\n+          \n+            echo \"This vulnerability is affecting the following versions: ${affected_versions}\" > ticket_content\n+            echo \"\" >> ticket_content\n+            echo \"*Vulnerability info:* https://pkg.go.dev/vuln/${vuln_key}\" >> ticket_content\n+            echo \"*Pipeline run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\" >> ticket_content\n+            # gh issue create --repo opentofu/opentofu --title \"${ticket_title}\" --body-file ticket_content",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2016352038",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2016352038",
        "commented_code": "@@ -0,0 +1,163 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will attempt to create an issue with the results for each scanned version\n+# in case any vulnerability is found. If the issue for the scanned branch already exists\n+# the run will just print the scan output and will leave the issue untouched.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  gather-branches:\n+    name: Collect the branches that needs to be scanned\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    outputs:\n+      branches: ${{ steps.branches.outputs.branches }}\n+    steps:\n+      - id: branches\n+        run: |\n+          ## This is using GitHub API and we manually filter out the versions that are not supported anymore\n+          # gh api \"repos/opentofu/opentofu/branches?protected=true\" --paginate | tee out \n+          # cat out | jq '.[] | select(.name != \"v1.6\") | [.name]' | jq -sc 'add' | tee branches\n+          # echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+          \n+          ## This is using https://endoflife.date since there 1.6 is already marked as it reached EOL\n+          ## This is adding manually the main branch to scan it as well\n+          curl https://endoflife.date/api/opentofu.json | tee out \n+          cat out | jq '.[] | select(.eol == false) | [\"v\" + .cycle]' | jq -sc 'add' | jq -c '[\"main\"] + .' | tee branches\n+          echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    needs: gather-branches\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    strategy:\n+      matrix:\n+        branch: ${{ fromJSON(needs.gather-branches.outputs.branches )}}\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"\n+        shell: bash\n+\n+      # Upload the artifact to make it available to the next job.\n+      # The artifact will be named as the branch name that we are scanning (\"main\" or \"v1.7\"...)\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: ${{matrix.branch}}-results\n+          path: ${{matrix.branch}}\n+\n+  create-issues:\n+    name: Compile results and create GH issues\n+    needs:\n+    - govulncheck\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    steps:\n+      # By providing the path where to download the artifacts and \"merge-multiple: true\", the downloader\n+      # will gather all the files generated in the job(s) above into a single directory flattening the file tree.\n+      # Eg: Instead of writing the results into \"results/main-results/main\" it will write the results into \"results/main\"\n+      - name: Download vulns results\n+        uses: actions/download-artifact@v4\n+        with:\n+          path: results\n+          merge-multiple: true\n+      - name: Run and report govulncheck findings\n+        run: |\n+          # Convert the results of type [\"vulnKey1\", \"vulnKey2\", ...] in files named like \"main\", \"v1.7\", etc to a struct of structure like\n+          # {\"vulnKey1\": [\"main\", \"v1.7\", ...], \"vulnKey2\": [\"main\", \"v1.7\", ...]}\n+          \n+          # Start the script with an empty json object\n+          vuln_to_versions=\"{}\"\n+          cd results\n+          for version in *; do\n+            while IFS= read -r vuln;\n+            do\n+              [[ -z \"${vuln}\" ]] && continue\n+              # Actions from this like:\n+              # * is giving the shell var for the vulnerability key to jq (--arg vl \"${vuln}\") \n+              # * is giving the shell var that contains the scanned version to jq (--arg vers \"${version}\"\n+              # * is getting from vuln_to_versions the key name that needs to be a vulnerability key and assigns to its array the currently proceesed version ('.[$vl] = .[$vl] + [$vers]')\n+              # * this is generating outputs like {\"vulnKey\": [\"version1\", \"version2\"]}. Eg: {\"GO-2024-2947\":[\"v1.7\"]}\n+              # * in the end overwrites the content of vuln_to_versions with the newly generated content \n+              vuln_to_versions=\"$(echo \"${vuln_to_versions}\" | jq -c --arg vl \"${vuln}\" --arg vers \"${version}\" '.[$vl] = .[$vl] + [$vers]')\"\n+            done <<< \"$(cat $version | jq -r '.[]')\" # This one is exploding a json array into multiple lines\n+          done\n+          \n+          # This is just using the \".key\" that is the vulnerability key and \".value\" that is the list of affected version(s)\n+          # to generate the commmands to create GitHub issues.\n+          while IFS= read -r vuln; \n+          do \n+            vuln_key=\"$(echo ${vuln} | jq -r '.key')\"\n+            affected_versions=\"$(echo ${vuln} | jq -r '.value[]' | xargs)\"\n+            ticket_title=\"${vuln_key} reported\"\n+\n+            reported_issues=\"$(gh issue -R opentofu/opentofu list --search \"\\\"${ticket_title}\\\" state:open\" --json number)\"\n+            no_of_issues=\"$(echo ${reported_issues} | jq -r '. | length')\"\n+            reported_issues=\"$(echo $reported_issues| jq -r '.[] | .number' | xargs)\"\n+            [[ ${no_of_issues} -ge 1 ]] && echo \"Vulnerabilties found but already reported for ${vuln_key} in: ${reported_issues}\" && exit 0\n+          \n+            echo \"This vulnerability is affecting the following versions: ${affected_versions}\" > ticket_content\n+            echo \"\" >> ticket_content\n+            echo \"*Vulnerability info:* https://pkg.go.dev/vuln/${vuln_key}\" >> ticket_content\n+            echo \"*Pipeline run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\" >> ticket_content\n+            # gh issue create --repo opentofu/opentofu --title \"${ticket_title}\" --body-file ticket_content",
        "comment_created_at": "2025-03-27T11:53:17+00:00",
        "comment_author": "yottta",
        "comment_body": "`question`\r\nI see no label that we could assign to these issues. Any idea of one? Or should we create a new one?",
        "pr_file_module": null
      },
      {
        "comment_id": "2033389227",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2016352038",
        "commented_code": "@@ -0,0 +1,163 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will attempt to create an issue with the results for each scanned version\n+# in case any vulnerability is found. If the issue for the scanned branch already exists\n+# the run will just print the scan output and will leave the issue untouched.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  gather-branches:\n+    name: Collect the branches that needs to be scanned\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    outputs:\n+      branches: ${{ steps.branches.outputs.branches }}\n+    steps:\n+      - id: branches\n+        run: |\n+          ## This is using GitHub API and we manually filter out the versions that are not supported anymore\n+          # gh api \"repos/opentofu/opentofu/branches?protected=true\" --paginate | tee out \n+          # cat out | jq '.[] | select(.name != \"v1.6\") | [.name]' | jq -sc 'add' | tee branches\n+          # echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+          \n+          ## This is using https://endoflife.date since there 1.6 is already marked as it reached EOL\n+          ## This is adding manually the main branch to scan it as well\n+          curl https://endoflife.date/api/opentofu.json | tee out \n+          cat out | jq '.[] | select(.eol == false) | [\"v\" + .cycle]' | jq -sc 'add' | jq -c '[\"main\"] + .' | tee branches\n+          echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    needs: gather-branches\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    strategy:\n+      matrix:\n+        branch: ${{ fromJSON(needs.gather-branches.outputs.branches )}}\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"\n+        shell: bash\n+\n+      # Upload the artifact to make it available to the next job.\n+      # The artifact will be named as the branch name that we are scanning (\"main\" or \"v1.7\"...)\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: ${{matrix.branch}}-results\n+          path: ${{matrix.branch}}\n+\n+  create-issues:\n+    name: Compile results and create GH issues\n+    needs:\n+    - govulncheck\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    steps:\n+      # By providing the path where to download the artifacts and \"merge-multiple: true\", the downloader\n+      # will gather all the files generated in the job(s) above into a single directory flattening the file tree.\n+      # Eg: Instead of writing the results into \"results/main-results/main\" it will write the results into \"results/main\"\n+      - name: Download vulns results\n+        uses: actions/download-artifact@v4\n+        with:\n+          path: results\n+          merge-multiple: true\n+      - name: Run and report govulncheck findings\n+        run: |\n+          # Convert the results of type [\"vulnKey1\", \"vulnKey2\", ...] in files named like \"main\", \"v1.7\", etc to a struct of structure like\n+          # {\"vulnKey1\": [\"main\", \"v1.7\", ...], \"vulnKey2\": [\"main\", \"v1.7\", ...]}\n+          \n+          # Start the script with an empty json object\n+          vuln_to_versions=\"{}\"\n+          cd results\n+          for version in *; do\n+            while IFS= read -r vuln;\n+            do\n+              [[ -z \"${vuln}\" ]] && continue\n+              # Actions from this like:\n+              # * is giving the shell var for the vulnerability key to jq (--arg vl \"${vuln}\") \n+              # * is giving the shell var that contains the scanned version to jq (--arg vers \"${version}\"\n+              # * is getting from vuln_to_versions the key name that needs to be a vulnerability key and assigns to its array the currently proceesed version ('.[$vl] = .[$vl] + [$vers]')\n+              # * this is generating outputs like {\"vulnKey\": [\"version1\", \"version2\"]}. Eg: {\"GO-2024-2947\":[\"v1.7\"]}\n+              # * in the end overwrites the content of vuln_to_versions with the newly generated content \n+              vuln_to_versions=\"$(echo \"${vuln_to_versions}\" | jq -c --arg vl \"${vuln}\" --arg vers \"${version}\" '.[$vl] = .[$vl] + [$vers]')\"\n+            done <<< \"$(cat $version | jq -r '.[]')\" # This one is exploding a json array into multiple lines\n+          done\n+          \n+          # This is just using the \".key\" that is the vulnerability key and \".value\" that is the list of affected version(s)\n+          # to generate the commmands to create GitHub issues.\n+          while IFS= read -r vuln; \n+          do \n+            vuln_key=\"$(echo ${vuln} | jq -r '.key')\"\n+            affected_versions=\"$(echo ${vuln} | jq -r '.value[]' | xargs)\"\n+            ticket_title=\"${vuln_key} reported\"\n+\n+            reported_issues=\"$(gh issue -R opentofu/opentofu list --search \"\\\"${ticket_title}\\\" state:open\" --json number)\"\n+            no_of_issues=\"$(echo ${reported_issues} | jq -r '. | length')\"\n+            reported_issues=\"$(echo $reported_issues| jq -r '.[] | .number' | xargs)\"\n+            [[ ${no_of_issues} -ge 1 ]] && echo \"Vulnerabilties found but already reported for ${vuln_key} in: ${reported_issues}\" && exit 0\n+          \n+            echo \"This vulnerability is affecting the following versions: ${affected_versions}\" > ticket_content\n+            echo \"\" >> ticket_content\n+            echo \"*Vulnerability info:* https://pkg.go.dev/vuln/${vuln_key}\" >> ticket_content\n+            echo \"*Pipeline run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\" >> ticket_content\n+            # gh issue create --repo opentofu/opentofu --title \"${ticket_title}\" --body-file ticket_content",
        "comment_created_at": "2025-04-08T14:55:39+00:00",
        "comment_author": "diofeher",
        "comment_body": "I would say it's a good idea to at least assign something like \"security\" to these issues.",
        "pr_file_module": null
      },
      {
        "comment_id": "2038857379",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2016352038",
        "commented_code": "@@ -0,0 +1,163 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will attempt to create an issue with the results for each scanned version\n+# in case any vulnerability is found. If the issue for the scanned branch already exists\n+# the run will just print the scan output and will leave the issue untouched.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  gather-branches:\n+    name: Collect the branches that needs to be scanned\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    outputs:\n+      branches: ${{ steps.branches.outputs.branches }}\n+    steps:\n+      - id: branches\n+        run: |\n+          ## This is using GitHub API and we manually filter out the versions that are not supported anymore\n+          # gh api \"repos/opentofu/opentofu/branches?protected=true\" --paginate | tee out \n+          # cat out | jq '.[] | select(.name != \"v1.6\") | [.name]' | jq -sc 'add' | tee branches\n+          # echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+          \n+          ## This is using https://endoflife.date since there 1.6 is already marked as it reached EOL\n+          ## This is adding manually the main branch to scan it as well\n+          curl https://endoflife.date/api/opentofu.json | tee out \n+          cat out | jq '.[] | select(.eol == false) | [\"v\" + .cycle]' | jq -sc 'add' | jq -c '[\"main\"] + .' | tee branches\n+          echo \"branches=$(cat branches)\">> \"$GITHUB_OUTPUT\"\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    needs: gather-branches\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    strategy:\n+      matrix:\n+        branch: ${{ fromJSON(needs.gather-branches.outputs.branches )}}\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"\n+        shell: bash\n+\n+      # Upload the artifact to make it available to the next job.\n+      # The artifact will be named as the branch name that we are scanning (\"main\" or \"v1.7\"...)\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v4\n+        with:\n+          name: ${{matrix.branch}}-results\n+          path: ${{matrix.branch}}\n+\n+  create-issues:\n+    name: Compile results and create GH issues\n+    needs:\n+    - govulncheck\n+    runs-on: ubuntu-latest\n+    #if: github.ref == 'refs/heads/main'\n+    env:\n+      GH_TOKEN: ${{ github.token }}\n+    steps:\n+      # By providing the path where to download the artifacts and \"merge-multiple: true\", the downloader\n+      # will gather all the files generated in the job(s) above into a single directory flattening the file tree.\n+      # Eg: Instead of writing the results into \"results/main-results/main\" it will write the results into \"results/main\"\n+      - name: Download vulns results\n+        uses: actions/download-artifact@v4\n+        with:\n+          path: results\n+          merge-multiple: true\n+      - name: Run and report govulncheck findings\n+        run: |\n+          # Convert the results of type [\"vulnKey1\", \"vulnKey2\", ...] in files named like \"main\", \"v1.7\", etc to a struct of structure like\n+          # {\"vulnKey1\": [\"main\", \"v1.7\", ...], \"vulnKey2\": [\"main\", \"v1.7\", ...]}\n+          \n+          # Start the script with an empty json object\n+          vuln_to_versions=\"{}\"\n+          cd results\n+          for version in *; do\n+            while IFS= read -r vuln;\n+            do\n+              [[ -z \"${vuln}\" ]] && continue\n+              # Actions from this like:\n+              # * is giving the shell var for the vulnerability key to jq (--arg vl \"${vuln}\") \n+              # * is giving the shell var that contains the scanned version to jq (--arg vers \"${version}\"\n+              # * is getting from vuln_to_versions the key name that needs to be a vulnerability key and assigns to its array the currently proceesed version ('.[$vl] = .[$vl] + [$vers]')\n+              # * this is generating outputs like {\"vulnKey\": [\"version1\", \"version2\"]}. Eg: {\"GO-2024-2947\":[\"v1.7\"]}\n+              # * in the end overwrites the content of vuln_to_versions with the newly generated content \n+              vuln_to_versions=\"$(echo \"${vuln_to_versions}\" | jq -c --arg vl \"${vuln}\" --arg vers \"${version}\" '.[$vl] = .[$vl] + [$vers]')\"\n+            done <<< \"$(cat $version | jq -r '.[]')\" # This one is exploding a json array into multiple lines\n+          done\n+          \n+          # This is just using the \".key\" that is the vulnerability key and \".value\" that is the list of affected version(s)\n+          # to generate the commmands to create GitHub issues.\n+          while IFS= read -r vuln; \n+          do \n+            vuln_key=\"$(echo ${vuln} | jq -r '.key')\"\n+            affected_versions=\"$(echo ${vuln} | jq -r '.value[]' | xargs)\"\n+            ticket_title=\"${vuln_key} reported\"\n+\n+            reported_issues=\"$(gh issue -R opentofu/opentofu list --search \"\\\"${ticket_title}\\\" state:open\" --json number)\"\n+            no_of_issues=\"$(echo ${reported_issues} | jq -r '. | length')\"\n+            reported_issues=\"$(echo $reported_issues| jq -r '.[] | .number' | xargs)\"\n+            [[ ${no_of_issues} -ge 1 ]] && echo \"Vulnerabilties found but already reported for ${vuln_key} in: ${reported_issues}\" && exit 0\n+          \n+            echo \"This vulnerability is affecting the following versions: ${affected_versions}\" > ticket_content\n+            echo \"\" >> ticket_content\n+            echo \"*Vulnerability info:* https://pkg.go.dev/vuln/${vuln_key}\" >> ticket_content\n+            echo \"*Pipeline run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\" >> ticket_content\n+            # gh issue create --repo opentofu/opentofu --title \"${ticket_title}\" --body-file ticket_content",
        "comment_created_at": "2025-04-11T06:09:10+00:00",
        "comment_author": "yottta",
        "comment_body": "@cam72cam created a new label called `govulncheck` for these. Added in 4963f351b5e15206be46ce015fcb048605810576",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2033646237",
    "pr_number": 2636,
    "pr_file": ".github/workflows/govulncheck.yml",
    "created_at": "2025-04-08T16:55:50+00:00",
    "commented_code": "+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2033646237",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-08T16:55:50+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "Would it be possible to also include the name of the affected module in this report so that we can include it in the summary of the issues that get created?\r\n\r\nOpaque identifiers like GO-2025-3588 are hard to distinguish quickly without some other context, and so I think including the name of the module that the vulnerability relates to will make it easier for us to find specific vulnerability issues once there are many of them.\r\n\r\n(However, I must admit I'm not sure how to incorporate that extra requirement into this pipeline... making this more advanced might require writing this in a different language that has better support for manipulating data structures, and so maybe better to wait and see if we need it before making things even more complicated.)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2034632151",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-09T07:08:35+00:00",
        "comment_author": "yottta",
        "comment_body": "Would be possible, indeed. That's what I wanted to do initially.\r\nThough, I opted on including the workflow run url instead in the summary of the issue. ([Example of a vulnerability affecting v1.7](https://github.com/opentofu/opentofu/actions/runs/14333067260/job/40173357398#step:6:18627))\r\nThis way, whoever is working on fixing that vulnerability, will be able to inspect the findings of govulncheck.\r\n\r\nExtracting and writing entire stacktraces might be a little bit noisy on the issues, IMO, even though it will make the life easier for the one that works on solving it.\r\nAnother thing, is that the issues are reported per vulnerability and it reports all the versions that are affected, but different versions could have different stacktraces on how is calling the affected code.\r\n\r\nAnd yes, if we want to do this, would be advisable to do it in another language.",
        "pr_file_module": null
      },
      {
        "comment_id": "2035677369",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-09T15:57:37+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "An alternative compromise I thought of is to make sure that the code which searches for an existing issue can tolerate extra text having been added manually to the issue title after it was automatically created, and then we could edit the title with a small amount of additional context after we have reviewed the report and understood what it affects, as long as we leave the vulnerability number in the issue title when we edit it. \r\n\r\nDo you think that would work?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2036744227",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-10T07:57:36+00:00",
        "comment_author": "yottta",
        "comment_body": "Yes, that will work for sure because the `--search` argument in `gh issue list` is actually a query string, not only the title.\r\nSo whatever will be added after the title or in the description of it will not affect the search.\r\n\r\nThough, I am not sure that I understand why this would be better compared with adding a comment into the issue.\r\n\r\nBTW, had a conversation with @cam72cam and we will try to use security advisories instead of issues for this functionality. I will try to do it today and also test your idea that you suggested here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2037196592",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-10T12:09:00+00:00",
        "comment_author": "yottta",
        "comment_body": "About the security advisories. Played around with the [API](https://docs.github.com/en/rest/security-advisories/repository-advisories) to see what it can do, but sadly it's quite restrictive and there is not really a  straight-forward way to test the changes. The API key that I can generate it can access only the published opentofu security advisories. Tried to test with one of my repos, but since I don't have any published/closed advisories, was returning only the draft one.\r\nEven further, the API to work with advisories is supporting filtering only on the `state` field which is not enough for our use case.\r\n\r\nTalked with @cam72cam and we are going with issues.",
        "pr_file_module": null
      },
      {
        "comment_id": "2037705833",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-10T15:38:47+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "I am particularly interested in being able to include something in the issue _title_ because that makes it easier to view many issues together in the main GitHub issues list UI, and in the \"Project\" view that we currently use for situations like triage.\r\n\r\nI don't want to have to open many different tabs to find the comments that distingish a bunch of issues whose titles are all \"GO-NNNN-NNNN reported\". However, now that you've confirmed that it's okay to modify the title as long as we preserve the keywords from the search query, I think this concern is resolved for me: I imagine that the person who responds to an issue created by this automation would add more text to the title (preserving the \"GO-NNNN-NNNN reported\" prefix) summarizing the problem that the upstream advisory described.\r\n\r\n---\r\n\r\nIn the associated RFC I had been imagining that the automated system would create issues and then [we would _manually_ create advisories based on those issues](https://github.com/opentofu/opentofu/blob/754d7eb58b737d0214f5811320e59c78445e0646/rfc/20250314-security-patch-policy.md#sharing-our-conclusions) once we've reviewed them and addressed any problems. In that sense, the issue represents the need to do the work while the advisory represents the _result_ of that work.\r\n\r\nI honestly hadn't considered the possibility of directly creating a draft advisory using automation; that does seem like an interesting idea but since you've already found the API for that is annoying to work with I don't personally have any problem with retaining the original idea of using issues as the primary way for the automation to communicate with us. At least, we could start with that and see if it seems worth doing the extra work to interact with the security advisory API.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2038868553",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2636,
        "pr_file": ".github/workflows/govulncheck.yml",
        "discussion_id": "2033646237",
        "commented_code": "@@ -0,0 +1,96 @@\n+# This workflow is meant to run govulncheck on all the branches\n+# that are containing a maintained version of OpenTofu.\n+# For more considerations about this, check this PR: https://github.com/opentofu/opentofu/pull/2600\n+#\n+# This will try to create an issue for each vulnerability key that is found.\n+# If an issue for it already exists, it will skip creating it.\n+#\n+# This is meant to run _only_ from the main branch, on a scheduled manner.\n+# All the other branches will be scanned directly by the run triggered from the main branch.\n+\n+name: Govulncheck\n+\n+on:\n+  schedule:\n+    - cron: '42 3 * * SUN'\n+  workflow_dispatch: {}\n+  push:\n+    branches:\n+      - govulncheck-action\n+\n+jobs:\n+  govulncheck:\n+    name: Run govulncheck for ${{ matrix.branch }}\n+    runs-on: ubuntu-latest\n+    strategy:\n+      matrix:\n+        include:\n+          - { branch: main }\n+          - { branch: v1.9 }\n+          - { branch: v1.8 }\n+          - { branch: v1.7 }\n+      fail-fast: false\n+    steps:\n+      - name: Checkout branch to be scanned\n+        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n+        with:\n+          ref: ${{matrix.branch}}\n+\n+      - name: Determine Go version\n+        id: go\n+        uses: ./.github/actions/go-version\n+\n+      - name: Install Go toolchain\n+        uses: actions/setup-go@f111f3307d8850f501ac008e886eec1fd1932a34 # v5.3.0\n+        with:\n+          go-version: ${{steps.go.outputs.version}}\n+\n+      - name: Install govulncheck\n+        run: go install golang.org/x/vuln/cmd/govulncheck@d1f380186385b4f64e00313f31743df8e4b89a77 # v1.1.4\n+        shell: bash\n+\n+      - name: Run and report govulncheck findings\n+        run: |\n+          govulncheck -format json ./... | tee results\n+          # This is parsing the output of govulncheck by:\n+          # * extracting only the findings that are affecting the current branch (.finding | select(.trace | length > 1))\n+          # * getting only the vulnerability key out of the objects (.osv)\n+          # * sorting and deduplicating the generated vulnerability keys (sort -u)\n+          # * compacting the result into a json array like [\"vulnKey1\", \"vulnKey2\", ...] (jq -cs '.')\n+          # * saving the results into a file which name is the version that we are scanning like \"v1.8\" (> \"${{matrix.branch}}\")\n+          cat results | jq '.finding | select(.trace | length > 1) | .osv' | sort -u | jq -cs '.' > \"${{matrix.branch}}\"",
        "comment_created_at": "2025-04-11T06:19:55+00:00",
        "comment_author": "yottta",
        "comment_body": "Great arguments for the title topic! I totally agree with the issue to advisory flow.\r\nI would like to go forward with this approach and then reiterate later if we find out that the work with this flow is hard or not clear enough.\r\n\r\nThis is rising some ideas that could help with the flow for others not involved in the development of this:\r\n* I would add in the description of the ticket a note on how to work on the issue. We can have a short file documenting this and we can point to that in each ticket description, or we can have just a small note like:\r\n   > [!NOTE] \r\n   > * _Additional information can be added to the title as long as the original keywords are kept._\r\n   > * _Check also the pipeline run linked to get a better understanding of the source of the vulnerability for each version._\r\n* I would also lock the issue. What do you think about this? This kind of ticket should be handled by the core team IMO. Therefore, locking the issue will allow conversations only from the core team, avoiding pollution of the conversation and the investigation of it.",
        "pr_file_module": null
      }
    ]
  }
]