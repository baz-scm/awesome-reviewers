[
  {
    "discussion_id": "2120972683",
    "pr_number": 2693,
    "pr_file": "internal/tofu/node_output.go",
    "created_at": "2025-06-02T12:16:21+00:00",
    "commented_code": "state.SetOutputValue(n.Addr, val, n.Config.Sensitive, n.Config.Deprecated)\n }\n+\n+func checkSensitivityOutputs(configOutputs map[string]*configs.Output, prevRunState *states.State) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n+\n+\t// Extract all Outputs from previous state\n+\tprevStateOutputs := map[string]*states.OutputValue{}\n+\tfor _, m := range prevRunState.Modules {\n+\t\tmaps.Copy(prevStateOutputs, m.OutputValues)\n+\t}\n+\n+\t// Check if any of the previous Outputs have been switched from sensitive to insensitive\n+\tfor outputName, prevStateOutput := range prevStateOutputs {\n+\t\tif prevStateOutput.Sensitive && !configOutputs[outputName].Sensitive {\n+\t\t\tdiags = diags.Append(tfdiags.Sourceless(\n+\t\t\t\ttfdiags.Warning,\n+\t\t\t\t\"Output change in sensitivity\",\n+\t\t\t\tfmt.Sprintf(\"A previously sensitive output is being changed to insensitive: %q.\", outputName),\n+\t\t\t))\n+\t\t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2120972683",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2693,
        "pr_file": "internal/tofu/node_output.go",
        "discussion_id": "2120972683",
        "commented_code": "@@ -636,3 +637,26 @@ func (n *NodeApplyableOutput) setValue(state *states.SyncState, changes *plans.C\n \n \tstate.SetOutputValue(n.Addr, val, n.Config.Sensitive, n.Config.Deprecated)\n }\n+\n+func checkSensitivityOutputs(configOutputs map[string]*configs.Output, prevRunState *states.State) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n+\n+\t// Extract all Outputs from previous state\n+\tprevStateOutputs := map[string]*states.OutputValue{}\n+\tfor _, m := range prevRunState.Modules {\n+\t\tmaps.Copy(prevStateOutputs, m.OutputValues)\n+\t}\n+\n+\t// Check if any of the previous Outputs have been switched from sensitive to insensitive\n+\tfor outputName, prevStateOutput := range prevStateOutputs {\n+\t\tif prevStateOutput.Sensitive && !configOutputs[outputName].Sensitive {\n+\t\t\tdiags = diags.Append(tfdiags.Sourceless(\n+\t\t\t\ttfdiags.Warning,\n+\t\t\t\t\"Output change in sensitivity\",\n+\t\t\t\tfmt.Sprintf(\"A previously sensitive output is being changed to insensitive: %q.\", outputName),\n+\t\t\t))\n+\t\t}",
        "comment_created_at": "2025-06-02T12:16:21+00:00",
        "comment_author": "yottta",
        "comment_body": "```suggestion\r\n\t\toc := configOutputs[outputName]\r\n\t\tif prevStateOutput.Sensitive && !oc.Sensitive {\r\n\t\t\tdiags = diags.Append(&hcl.Diagnostic{\r\n\t\t\t\tSeverity: hcl.DiagWarning,\r\n\t\t\t\tSummary:  \"Output change in sensitivity\",\r\n\t\t\t\tDetail:   fmt.Sprintf(\"Sensitivity of the output %q changed. By doing so, the value will not be obfuscated anymore.\", oc.Name),\r\n\t\t\t\tSubject:  oc.DeclRange.Ptr(),\r\n\t\t\t})\r\n\t\t}\r\n```\r\n\r\nBy using a different way to initialise a diagnostic, we can provide that `Subject` field that will allow providing a better guidance to the user.\r\nThe change above will generate a warning similar to this one:\r\n![Screenshot 2025-06-02 at 15 15 32](https://github.com/user-attachments/assets/b30521cc-2517-406c-b76b-305ccee184a4)\r\nWith that indication of where the output that the warning is talking about can be located.",
        "pr_file_module": null
      },
      {
        "comment_id": "2121117723",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2693,
        "pr_file": "internal/tofu/node_output.go",
        "discussion_id": "2120972683",
        "commented_code": "@@ -636,3 +637,26 @@ func (n *NodeApplyableOutput) setValue(state *states.SyncState, changes *plans.C\n \n \tstate.SetOutputValue(n.Addr, val, n.Config.Sensitive, n.Config.Deprecated)\n }\n+\n+func checkSensitivityOutputs(configOutputs map[string]*configs.Output, prevRunState *states.State) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n+\n+\t// Extract all Outputs from previous state\n+\tprevStateOutputs := map[string]*states.OutputValue{}\n+\tfor _, m := range prevRunState.Modules {\n+\t\tmaps.Copy(prevStateOutputs, m.OutputValues)\n+\t}\n+\n+\t// Check if any of the previous Outputs have been switched from sensitive to insensitive\n+\tfor outputName, prevStateOutput := range prevStateOutputs {\n+\t\tif prevStateOutput.Sensitive && !configOutputs[outputName].Sensitive {\n+\t\t\tdiags = diags.Append(tfdiags.Sourceless(\n+\t\t\t\ttfdiags.Warning,\n+\t\t\t\t\"Output change in sensitivity\",\n+\t\t\t\tfmt.Sprintf(\"A previously sensitive output is being changed to insensitive: %q.\", outputName),\n+\t\t\t))\n+\t\t}",
        "comment_created_at": "2025-06-02T13:13:37+00:00",
        "comment_author": "bittelc",
        "comment_body": "Ah super interesting! Moving between the different `Diagnostic` types has been a good challenge for me in picking up this codebase. So thanks for this, definitely helps.\r\n\r\nI've [committed your suggestion](https://github.com/opentofu/opentofu/pull/2693/commits/3689afba7cee4c9179adf5251358da4fa60ceaf6) verbatim.\r\n\r\nAnd thanks for the review!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2091493786",
    "pr_number": 2806,
    "pr_file": "internal/configs/resource.go",
    "created_at": "2025-05-15T15:45:16+00:00",
    "commented_code": "Detail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2091493786",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2806,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "2091493786",
        "commented_code": "@@ -814,14 +814,23 @@ func (r *ProviderConfigRef) InstanceValidation(blockType string, isInstanced boo\n \t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
        "comment_created_at": "2025-05-15T15:45:16+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "To me the `for_each` part of this at the end is largely irrelevant: it's not valid to refer to an alternative provider configuration that isn't declared _regardless of whether `for_each` is used or not_ so I think mentioning it is likely to cause more confusion than it saves.\r\n\r\nAs things are currently structured it's true that we'll only be reporting the problem this way when there's an instance key specified, but that's just an implementation detail of how this validation is implemented and not relevant to the end-user.\r\n\r\n(Folks reading error messages tend to think that everything they read is directly related to the problem at hand, so including extraneous details tends to cause people to try to solve the wrong problem.)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2091500494",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2806,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "2091493786",
        "commented_code": "@@ -814,14 +814,23 @@ func (r *ProviderConfigRef) InstanceValidation(blockType string, isInstanced boo\n \t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
        "comment_created_at": "2025-05-15T15:48:31+00:00",
        "comment_author": "cam72cam",
        "comment_body": "This requirement only exists for provider for_each however.  There are other paths through the code (aliases in required_providers) that don't hit this constraint, other than during for_each.",
        "pr_file_module": null
      },
      {
        "comment_id": "2091521599",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2806,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "2091493786",
        "commented_code": "@@ -814,14 +814,23 @@ func (r *ProviderConfigRef) InstanceValidation(blockType string, isInstanced boo\n \t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
        "comment_created_at": "2025-05-15T15:59:12+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "Perhaps, but what are you expecting that the reader of this message would do differently based on that extra clause? It doesn't seem like it adds anything the reader needs to know in order to correct the problem. :thinking: \r\n\r\nAre you worried about the hypothetical person who has a child module specifying `configuration_aliases = [postgresql.by_db]` and is expecting that to allow referring to a multi-instance provider passed from the caller? It is true that currently that situation ends up here too, but I don't think that the extra clause you added actually helps diagnose it, because it doesn't say anything at all about `configuration_aliases`...\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2091525082",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2806,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "2091493786",
        "commented_code": "@@ -814,14 +814,23 @@ func (r *ProviderConfigRef) InstanceValidation(blockType string, isInstanced boo\n \t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
        "comment_created_at": "2025-05-15T16:01:04+00:00",
        "comment_author": "cam72cam",
        "comment_body": "I was thinking more along the lines of someone who's introducing provider for_each into an existing codebase, and is confused why they are just now seeing this message.",
        "pr_file_module": null
      },
      {
        "comment_id": "2091536499",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2806,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "2091493786",
        "commented_code": "@@ -814,14 +814,23 @@ func (r *ProviderConfigRef) InstanceValidation(blockType string, isInstanced boo\n \t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration which has an alias and uses for_each.\",\n \t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n \t\t\t})\n-\t\t}\n-\t\tif !isInstanced {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  summary,\n-\t\t\t\tDetail:   \"An instance key can be specified only for a provider configuration that uses for_each.\",\n-\t\t\t\tSubject:  r.KeyExpression.Range().Ptr(),\n-\t\t\t})\n+\t\t} else if !isInstanced {\n+\t\t\tif !hasConfig {\n+\t\t\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\t\tSummary:  summary,\n+\t\t\t\t\tDetail:   fmt.Sprintf(\"This module doesn't declare a provider %q block with alias = %q, which is required for use with for_each\", r.Name, r.Alias),",
        "comment_created_at": "2025-05-15T16:07:13+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Going to resolve for now, happy to amend with further user feedback :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998304768",
    "pr_number": 2595,
    "pr_file": "internal/encryption/base.go",
    "created_at": "2025-03-17T09:24:39+00:00",
    "commented_code": "}\n \n \t// This is good enough for now until we have better/distinct errors\n-\terrMessage := \"decryption failed for all provided methods: \"\n-\tsep := \"\"\n-\tfor _, err := range errs {\n-\t\terrMessage += err.Error() + sep\n-\t\tsep = \"\n\"\n-\t}\n+\t//errMessage := \"decryption failed for all provided methods: \"\n+\t//sep := \"\"\n+\t//for _, err := range errs {\n+\t//\terrMessage += err.Error() + sep\n+\t//\tsep = \"\n\"\n+\t//}\n+\n+\terrMessage := errors.Join(errs...).Error()",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998304768",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2595,
        "pr_file": "internal/encryption/base.go",
        "discussion_id": "1998304768",
        "commented_code": "@@ -230,11 +230,14 @@ func (base *baseEncryption) decrypt(data []byte, validator func([]byte) error) (\n \t}\n \n \t// This is good enough for now until we have better/distinct errors\n-\terrMessage := \"decryption failed for all provided methods: \"\n-\tsep := \"\"\n-\tfor _, err := range errs {\n-\t\terrMessage += err.Error() + sep\n-\t\tsep = \"\\n\"\n-\t}\n+\t//errMessage := \"decryption failed for all provided methods: \"\n+\t//sep := \"\"\n+\t//for _, err := range errs {\n+\t//\terrMessage += err.Error() + sep\n+\t//\tsep = \"\\n\"\n+\t//}\n+\n+\terrMessage := errors.Join(errs...).Error()",
        "comment_created_at": "2025-03-17T09:24:39+00:00",
        "comment_author": "yottta",
        "comment_body": "Before\r\n![Screenshot 2025-03-17 at 11 20 04](https://github.com/user-attachments/assets/af02e9c1-e367-4df8-b169-fc264297c689)\r\nAfter\r\n![Screenshot 2025-03-17 at 11 22 52](https://github.com/user-attachments/assets/7ad66b64-607f-4c7d-b5f8-e8aca7b0efe3)\r\nI would suggest to enhance this to make it even better, like this:\r\n![Screenshot 2025-03-17 at 11 24 16](https://github.com/user-attachments/assets/d5fc77bc-1c4e-467d-b9bf-12da1e605924)\r\n```suggestion\r\n       \terrs = append([]error{fmt.Errorf(\"decryption failed for all provided methods\")}, errs...)\r\n\terrMessage := errors.Join(errs...).Error()\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998397104",
    "pr_number": 2595,
    "pr_file": "internal/encryption/keyprovider.go",
    "created_at": "2025-03-17T10:13:49+00:00",
    "commented_code": "Severity: hcl.DiagError,\n \t\t\t\tSummary:  \"Circular reference detected\",\n \t\t\t\t// TODO add the stack trace to the detail message\n-\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers.\", addr),\n+\t\t\t\t// not sure at all, couldn't test the circular dep stack was always empty\n+\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers. Stack trace %s\", addr, stack),",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998397104",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2595,
        "pr_file": "internal/encryption/keyprovider.go",
        "discussion_id": "1998397104",
        "commented_code": "@@ -147,7 +147,8 @@ func setupKeyProvider(enc *config.EncryptionConfig, cfg config.KeyProviderConfig\n \t\t\t\tSeverity: hcl.DiagError,\n \t\t\t\tSummary:  \"Circular reference detected\",\n \t\t\t\t// TODO add the stack trace to the detail message\n-\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers.\", addr),\n+\t\t\t\t// not sure at all, couldn't test the circular dep stack was always empty\n+\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers. Stack trace %s\", addr, stack),",
        "comment_created_at": "2025-03-17T10:13:49+00:00",
        "comment_author": "yottta",
        "comment_body": "Indeed, that will not work as expected.\r\nYou could make use of a function like this:\r\n```golang\r\nfunc keyProvidersStack(stack []config.KeyProviderConfig) ([]string, hcl.Diagnostics) {\r\n\tres := make([]string, len(stack))\r\n\tvar diags hcl.Diagnostics\r\n\tfor i, cfg := range stack {\r\n\t\taddr, diag := cfg.Addr()\r\n\t\tdiags = diags.Extend(diag)\r\n\t\tif diag.HasErrors() {\r\n\t\t\tres[i] = \"<unknown>\"\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tres[i] = string(addr)\r\n\t}\r\n\treturn res, diags\r\n}\r\n```\r\n\r\nAnd then, before this `return` statement, you can do this:\r\n```golang\r\naddr, diags := keyprovider.NewAddr(cfg.Type, cfg.Name)\r\nstackAddrs, diag := keyProvidersStack(append(stack, cfg))\r\ndiags = diags.Extend(diag)\r\n```\r\nAnd this line will become\r\n```golang\r\nDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers. Stack trace %s\", addr, strings.Join(stackAddrs, \" -> \")),\r\n```\r\n\r\nEnding up in something similar to this. _Note: the message presented is not a real use case, that cannot happen._\r\n![Screenshot 2025-03-17 at 12 13 17](https://github.com/user-attachments/assets/acb90ebd-0a9c-4e76-945c-ddec0c43a479)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1998478394",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2595,
        "pr_file": "internal/encryption/keyprovider.go",
        "discussion_id": "1998397104",
        "commented_code": "@@ -147,7 +147,8 @@ func setupKeyProvider(enc *config.EncryptionConfig, cfg config.KeyProviderConfig\n \t\t\t\tSeverity: hcl.DiagError,\n \t\t\t\tSummary:  \"Circular reference detected\",\n \t\t\t\t// TODO add the stack trace to the detail message\n-\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers.\", addr),\n+\t\t\t\t// not sure at all, couldn't test the circular dep stack was always empty\n+\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers. Stack trace %s\", addr, stack),",
        "comment_created_at": "2025-03-17T10:51:25+00:00",
        "comment_author": "Klopklopi",
        "comment_body": "Thank you for the feedback ! I was wondering if it was a problem if we couldn't properly test the circular reference ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1998499913",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2595,
        "pr_file": "internal/encryption/keyprovider.go",
        "discussion_id": "1998397104",
        "commented_code": "@@ -147,7 +147,8 @@ func setupKeyProvider(enc *config.EncryptionConfig, cfg config.KeyProviderConfig\n \t\t\t\tSeverity: hcl.DiagError,\n \t\t\t\tSummary:  \"Circular reference detected\",\n \t\t\t\t// TODO add the stack trace to the detail message\n-\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers.\", addr),\n+\t\t\t\t// not sure at all, couldn't test the circular dep stack was always empty\n+\t\t\t\tDetail: fmt.Sprintf(\"Cannot load %s due to circular reference between key providers. Stack trace %s\", addr, stack),",
        "comment_created_at": "2025-03-17T11:05:16+00:00",
        "comment_author": "yottta",
        "comment_body": "We could have done this, but right now the key provider ([XOR](https://github.com/opentofu/opentofu/tree/main/internal/encryption/keyprovider/xor)) that could have been used to reproduce this is not included in the default allowed providers.\r\nI tested this with some slight temp modifications to the source code. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2056387265",
    "pr_number": 2633,
    "pr_file": "internal/configs/named_values.go",
    "created_at": "2025-04-23T15:58:36+00:00",
    "commented_code": "o.SensitiveSet = true\n \t}\n \n+\tif attr, exists := content.Attributes[\"deprecated\"]; exists {\n+\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &o.Deprecated)\n+\t\tdiags = append(diags, valDiags...)\n+\n+\t\tif o.Deprecated == \"\" {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Invalid `deprecated` attribute\",\n+\t\t\t\tDetail:   `Attribute \"deprecated\" must be a non-empty string, please provide a suggestion for users to properly migrate from a deprecated module output.`,",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2056387265",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2633,
        "pr_file": "internal/configs/named_values.go",
        "discussion_id": "2056387265",
        "commented_code": "@@ -444,6 +445,20 @@ func decodeOutputBlock(block *hcl.Block, override bool) (*Output, hcl.Diagnostic\n \t\to.SensitiveSet = true\n \t}\n \n+\tif attr, exists := content.Attributes[\"deprecated\"]; exists {\n+\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &o.Deprecated)\n+\t\tdiags = append(diags, valDiags...)\n+\n+\t\tif o.Deprecated == \"\" {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Invalid `deprecated` attribute\",\n+\t\t\t\tDetail:   `Attribute \"deprecated\" must be a non-empty string, please provide a suggestion for users to properly migrate from a deprecated module output.`,",
        "comment_created_at": "2025-04-23T15:58:36+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "OpenTofu error messages don't usually say \"please\", so I'd suggest the following tweak for similarity to the existing \"diagnostic voice\":\r\n\r\n> The \"deprecated\" argument must not be empty, and should provide instructions on how to migrate away from usage of this deprecated output value.\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2056780439",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2633,
        "pr_file": "internal/configs/named_values.go",
        "discussion_id": "2056387265",
        "commented_code": "@@ -444,6 +445,20 @@ func decodeOutputBlock(block *hcl.Block, override bool) (*Output, hcl.Diagnostic\n \t\to.SensitiveSet = true\n \t}\n \n+\tif attr, exists := content.Attributes[\"deprecated\"]; exists {\n+\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &o.Deprecated)\n+\t\tdiags = append(diags, valDiags...)\n+\n+\t\tif o.Deprecated == \"\" {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Invalid `deprecated` attribute\",\n+\t\t\t\tDetail:   `Attribute \"deprecated\" must be a non-empty string, please provide a suggestion for users to properly migrate from a deprecated module output.`,",
        "comment_created_at": "2025-04-23T19:48:57+00:00",
        "comment_author": "ollevche",
        "comment_body": "Makes sense, changed tone of voice in d44bf936584acd2e90273774b29711082cbb7377",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998763721",
    "pr_number": 2580,
    "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
    "created_at": "2025-03-17T13:44:22+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998763721",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998763721",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")",
        "comment_created_at": "2025-03-17T13:44:22+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\n```suggestion\r\n\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type - empty\")\r\n```\r\n\r\nOr something more specific to let the user know about the actual cause? \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1999125700",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998763721",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")",
        "comment_created_at": "2025-03-17T16:12:51+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "The problem here is that because OCI was originally intended only for distributing container images there was originally no such thing as an \"artifact type\" -- container images were the only artifact type.\r\n\r\nSome projects adopted OCI for non-container-image artifacts before the OCI spec was updated to include the \"artifact type\" concept, and so the standard image layout for those projects does not include an explicit artifact type at all, and instead software \"guesses\" the artifact type based on other information in the manifest.\r\n\r\nThe fact that there's an optional `artifactType` property in the manifest format is an implementation detail of the protocol that I don't expect the reader of this error message to be aware of, and so I think it would be confusing to talk about it in the error message. Instead, this generic error message is attempting to talk about this in a way that's more likely to be relevant to the end-user: this is an artifact of a type we don't support. It's unfortunate that we can't say what type of artifact it is, but it does have an _implied_ artifact type (based on data in the manifest), so I think it would be confusing to say that this artifact does not have a type _at all_.\r\n\r\nThe main way someone would encounter this message is if they've selected a container image instead of an OpenTofu provider image, so this seems like a good situation for the error message to include a question-shaped suggestion:\r\n\r\n```\r\nunsupported OCI artifact type; is this a container image, rather than an OpenTofu provider?\r\n```\r\n\r\nPhrasing it as a question allows us to present a likely explanation even though we don't know for certain whether it's true. For example, the selected artifact might actually be a Helm chart since those _also_ don't use `artifactType`, but that seems considerably less likely for someone to select by accident.\r\n\r\nI'm going to change the error message to something similar to the above. Hopefully that's a reasonable compromise?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2000348798",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998763721",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")",
        "comment_created_at": "2025-03-18T07:09:41+00:00",
        "comment_author": "yottta",
        "comment_body": "Good arguments for this. Thanks.\r\nAnd yes, the updated message seems more suitable for the particular situation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998777566",
    "pr_number": 2580,
    "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
    "created_at": "2025-03-17T13:51:14+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)\n+\t}\n+\treturn selected, nil\n+}\n+\n+func selectOCILayerBlob(descs []ociv1.Descriptor) (ociv1.Descriptor, error) {\n+\tfoundBlobs := 0\n+\tfoundWrongMediaTypeBlobs := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageArtifactType {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif desc.MediaType != ociPackageMediaType {\n+\t\t\t// We silently ignore any \"layer\" that doesn't have both our expected\n+\t\t\t// artifact type and media type so that future versions of OpenTofu\n+\t\t\t// can potentially support additional archive formats, and so that\n+\t\t\t// artifact authors can include other non-OpenTofu-related layers\n+\t\t\t// in their manifests if needed... but we do still count them so that\n+\t\t\t// we can hint about it in an error message below.\n+\t\t\tfoundWrongMediaTypeBlobs++\n+\t\t\tcontinue\n+\t\t}\n+\t\tfoundBlobs++\n+\t\tselected = desc\n+\t}\n+\tif foundBlobs == 0 {\n+\t\tif foundWrongMediaTypeBlobs > 0 {\n+\t\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q, but has other unsupported formats; is this intended for a different version of OpenTofu?\", ociPackageArtifactType, ociPackageMediaType)\n+\t\t}\n+\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q\", ociPackageArtifactType, ociPackageMediaType)\n+\t}\n+\tif foundBlobs > 1 {\n+\t\t// There must be exactly one eligible blob, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest declares multiple eligible provider packages\")\n+\t}\n+\treturn selected, nil\n+}\n+\n+func fetchOCIManifestBlob(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) ([]byte, error) {\n+\t// We impose a size limit on the manifest just to avoid an abusive remote registry\n+\t// occupuing unbounded memory when we read the manifest content into memory below.\n+\tif (desc.Size / 1024 / 1024) > ociImageManifestSizeLimitMiB {\n+\t\treturn nil, fmt.Errorf(\"manifest size exceeds OpenTofu's size limit of %d MiB\", ociImageManifestSizeLimitMiB)\n+\t}\n+\n+\treadCloser, err := store.Fetch(ctx, desc)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer readCloser.Close()\n+\tmanifestReader := io.LimitReader(readCloser, desc.Size)\n+\n+\t// We need to verify that the content matches the digest in the descriptor,\n+\t// and we also need to parse that data as JSON. We can only read from the\n+\t// reader once, so we have no choice but to buffer it all in memory.\n+\tmanifestSrc, err := io.ReadAll(manifestReader)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"reading manifest content: %w\", err)\n+\t}\n+\n+\tgotDigest := desc.Digest.Algorithm().FromBytes(manifestSrc)\n+\tif gotDigest != desc.Digest {\n+\t\treturn nil, fmt.Errorf(\"manifest content does not match digest %s\", desc.Digest)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998777566",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998777566",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)\n+\t}\n+\treturn selected, nil\n+}\n+\n+func selectOCILayerBlob(descs []ociv1.Descriptor) (ociv1.Descriptor, error) {\n+\tfoundBlobs := 0\n+\tfoundWrongMediaTypeBlobs := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageArtifactType {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif desc.MediaType != ociPackageMediaType {\n+\t\t\t// We silently ignore any \"layer\" that doesn't have both our expected\n+\t\t\t// artifact type and media type so that future versions of OpenTofu\n+\t\t\t// can potentially support additional archive formats, and so that\n+\t\t\t// artifact authors can include other non-OpenTofu-related layers\n+\t\t\t// in their manifests if needed... but we do still count them so that\n+\t\t\t// we can hint about it in an error message below.\n+\t\t\tfoundWrongMediaTypeBlobs++\n+\t\t\tcontinue\n+\t\t}\n+\t\tfoundBlobs++\n+\t\tselected = desc\n+\t}\n+\tif foundBlobs == 0 {\n+\t\tif foundWrongMediaTypeBlobs > 0 {\n+\t\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q, but has other unsupported formats; is this intended for a different version of OpenTofu?\", ociPackageArtifactType, ociPackageMediaType)\n+\t\t}\n+\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q\", ociPackageArtifactType, ociPackageMediaType)\n+\t}\n+\tif foundBlobs > 1 {\n+\t\t// There must be exactly one eligible blob, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest declares multiple eligible provider packages\")\n+\t}\n+\treturn selected, nil\n+}\n+\n+func fetchOCIManifestBlob(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) ([]byte, error) {\n+\t// We impose a size limit on the manifest just to avoid an abusive remote registry\n+\t// occupuing unbounded memory when we read the manifest content into memory below.\n+\tif (desc.Size / 1024 / 1024) > ociImageManifestSizeLimitMiB {\n+\t\treturn nil, fmt.Errorf(\"manifest size exceeds OpenTofu's size limit of %d MiB\", ociImageManifestSizeLimitMiB)\n+\t}\n+\n+\treadCloser, err := store.Fetch(ctx, desc)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer readCloser.Close()\n+\tmanifestReader := io.LimitReader(readCloser, desc.Size)\n+\n+\t// We need to verify that the content matches the digest in the descriptor,\n+\t// and we also need to parse that data as JSON. We can only read from the\n+\t// reader once, so we have no choice but to buffer it all in memory.\n+\tmanifestSrc, err := io.ReadAll(manifestReader)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"reading manifest content: %w\", err)\n+\t}\n+\n+\tgotDigest := desc.Digest.Algorithm().FromBytes(manifestSrc)\n+\tif gotDigest != desc.Digest {\n+\t\treturn nil, fmt.Errorf(\"manifest content does not match digest %s\", desc.Digest)",
        "comment_created_at": "2025-03-17T13:51:14+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\n```suggestion\r\n\t\treturn nil, fmt.Errorf(\"manifest content digest (%s) does not match resolved digest %s\", gotDigest, desc.Digest)\r\n```\r\nNot sure about this \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1999211544",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998777566",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)\n+\t}\n+\treturn selected, nil\n+}\n+\n+func selectOCILayerBlob(descs []ociv1.Descriptor) (ociv1.Descriptor, error) {\n+\tfoundBlobs := 0\n+\tfoundWrongMediaTypeBlobs := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageArtifactType {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif desc.MediaType != ociPackageMediaType {\n+\t\t\t// We silently ignore any \"layer\" that doesn't have both our expected\n+\t\t\t// artifact type and media type so that future versions of OpenTofu\n+\t\t\t// can potentially support additional archive formats, and so that\n+\t\t\t// artifact authors can include other non-OpenTofu-related layers\n+\t\t\t// in their manifests if needed... but we do still count them so that\n+\t\t\t// we can hint about it in an error message below.\n+\t\t\tfoundWrongMediaTypeBlobs++\n+\t\t\tcontinue\n+\t\t}\n+\t\tfoundBlobs++\n+\t\tselected = desc\n+\t}\n+\tif foundBlobs == 0 {\n+\t\tif foundWrongMediaTypeBlobs > 0 {\n+\t\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q, but has other unsupported formats; is this intended for a different version of OpenTofu?\", ociPackageArtifactType, ociPackageMediaType)\n+\t\t}\n+\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q\", ociPackageArtifactType, ociPackageMediaType)\n+\t}\n+\tif foundBlobs > 1 {\n+\t\t// There must be exactly one eligible blob, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest declares multiple eligible provider packages\")\n+\t}\n+\treturn selected, nil\n+}\n+\n+func fetchOCIManifestBlob(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) ([]byte, error) {\n+\t// We impose a size limit on the manifest just to avoid an abusive remote registry\n+\t// occupuing unbounded memory when we read the manifest content into memory below.\n+\tif (desc.Size / 1024 / 1024) > ociImageManifestSizeLimitMiB {\n+\t\treturn nil, fmt.Errorf(\"manifest size exceeds OpenTofu's size limit of %d MiB\", ociImageManifestSizeLimitMiB)\n+\t}\n+\n+\treadCloser, err := store.Fetch(ctx, desc)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer readCloser.Close()\n+\tmanifestReader := io.LimitReader(readCloser, desc.Size)\n+\n+\t// We need to verify that the content matches the digest in the descriptor,\n+\t// and we also need to parse that data as JSON. We can only read from the\n+\t// reader once, so we have no choice but to buffer it all in memory.\n+\tmanifestSrc, err := io.ReadAll(manifestReader)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"reading manifest content: %w\", err)\n+\t}\n+\n+\tgotDigest := desc.Digest.Algorithm().FromBytes(manifestSrc)\n+\tif gotDigest != desc.Digest {\n+\t\treturn nil, fmt.Errorf(\"manifest content does not match digest %s\", desc.Digest)",
        "comment_created_at": "2025-03-17T16:47:12+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "I did consider this, but these digests are quite long and so can make these messages hard to read, and if we get to this point there are only a small number of explanations for this unlikely error message:\r\n\r\n1. The connection to the OCI registry server was interrupted somehow in a way that caused the received data to be truncated.\r\n2. The OCI registry server is implemented incorrectly and so is returning the wrong data.\r\n3. The OCI registry server has been compromised by an attacker and so is _intentionally_ returning the wrong data, in the hope that some client software won't actually verify the digest.\r\n\r\nOf these three explanations, only in the second case could the digest of the content we actually received be _potentially_ useful, and even then only if the reader of the error message already knows of some content with that digest that might've been somehow returned by mistake, but even that seems quite unlikely. Therefore I chose to focus this error message only on describing what OpenTofu was _intending_ to fetch, because that's an identifier that the reader of the error message can potentially try to retrieve themselves using other software to try to understand what has happened.\r\n\r\nTherefore I think the shape of the error message I wrote makes the best compromise of giving the reader the information needed to debug further, without the confusion of including two very long strings of opaque gibberish where one of them is unlikely to actually communicate anything useful.\r\n\r\nDoes that seem like a reasonable justification?",
        "pr_file_module": null
      },
      {
        "comment_id": "2000353150",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998777566",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)\n+\t}\n+\treturn selected, nil\n+}\n+\n+func selectOCILayerBlob(descs []ociv1.Descriptor) (ociv1.Descriptor, error) {\n+\tfoundBlobs := 0\n+\tfoundWrongMediaTypeBlobs := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageArtifactType {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif desc.MediaType != ociPackageMediaType {\n+\t\t\t// We silently ignore any \"layer\" that doesn't have both our expected\n+\t\t\t// artifact type and media type so that future versions of OpenTofu\n+\t\t\t// can potentially support additional archive formats, and so that\n+\t\t\t// artifact authors can include other non-OpenTofu-related layers\n+\t\t\t// in their manifests if needed... but we do still count them so that\n+\t\t\t// we can hint about it in an error message below.\n+\t\t\tfoundWrongMediaTypeBlobs++\n+\t\t\tcontinue\n+\t\t}\n+\t\tfoundBlobs++\n+\t\tselected = desc\n+\t}\n+\tif foundBlobs == 0 {\n+\t\tif foundWrongMediaTypeBlobs > 0 {\n+\t\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q, but has other unsupported formats; is this intended for a different version of OpenTofu?\", ociPackageArtifactType, ociPackageMediaType)\n+\t\t}\n+\t\treturn selected, fmt.Errorf(\"image manifest contains no %q layers of type %q\", ociPackageArtifactType, ociPackageMediaType)\n+\t}\n+\tif foundBlobs > 1 {\n+\t\t// There must be exactly one eligible blob, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest declares multiple eligible provider packages\")\n+\t}\n+\treturn selected, nil\n+}\n+\n+func fetchOCIManifestBlob(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) ([]byte, error) {\n+\t// We impose a size limit on the manifest just to avoid an abusive remote registry\n+\t// occupuing unbounded memory when we read the manifest content into memory below.\n+\tif (desc.Size / 1024 / 1024) > ociImageManifestSizeLimitMiB {\n+\t\treturn nil, fmt.Errorf(\"manifest size exceeds OpenTofu's size limit of %d MiB\", ociImageManifestSizeLimitMiB)\n+\t}\n+\n+\treadCloser, err := store.Fetch(ctx, desc)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer readCloser.Close()\n+\tmanifestReader := io.LimitReader(readCloser, desc.Size)\n+\n+\t// We need to verify that the content matches the digest in the descriptor,\n+\t// and we also need to parse that data as JSON. We can only read from the\n+\t// reader once, so we have no choice but to buffer it all in memory.\n+\tmanifestSrc, err := io.ReadAll(manifestReader)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"reading manifest content: %w\", err)\n+\t}\n+\n+\tgotDigest := desc.Digest.Algorithm().FromBytes(manifestSrc)\n+\tif gotDigest != desc.Digest {\n+\t\treturn nil, fmt.Errorf(\"manifest content does not match digest %s\", desc.Digest)",
        "comment_created_at": "2025-03-18T07:13:11+00:00",
        "comment_author": "yottta",
        "comment_body": "Yes, that's more than a reasonable justification. Thanks. As I was saying, I was not sure about this suggestion.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998797570",
    "pr_number": 2580,
    "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
    "created_at": "2025-03-17T13:59:24+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998797570",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998797570",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)",
        "comment_created_at": "2025-03-17T13:59:24+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\n```suggestion\r\n\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s and version %s\", target, version)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1999157193",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998797570",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest\n+\t\t}\n+\t\tif desc.MediaType != ociv1.MediaTypeImageManifest {\n+\t\t\t// If this descriptor claims to be for a provider target manifest then\n+\t\t\t// it MUST be declared as being an image manifest.\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest has unsupported media type %q\", desc.MediaType)\n+\t\t}\n+\t\tif desc.Platform == nil {\n+\t\t\treturn selected, fmt.Errorf(\"provider image manifest lacks the required platform constraints\")\n+\t\t}\n+\t\tif desc.Platform.OSVersion != \"\" || desc.Platform.OS != target.OS || desc.Platform.Architecture != target.Arch {\n+\t\t\t// We ignore manifests that aren't for the platform we're trying to match.\n+\t\t\t// We also ignore manifests that specify a specific OS version because we\n+\t\t\t// don't currently have any means to handle that, but we want to give\n+\t\t\t// future OpenTofu versions the option of treating that as a more specific\n+\t\t\t// match while leaving an OSVersion-free entry as a compatibility fallback.\n+\t\t\tcontinue\n+\t\t}\n+\t\t// We have found a plausible candidate!\n+\t\tfoundManifests++\n+\t\tselected = desc\n+\t}\n+\tif foundManifests == 0 {\n+\t\t// If all of the manifests were valid but none were eligible for this\n+\t\t// platform then we assume that this is a valid provider that just\n+\t\t// lacks support for the current platform, for which we have a special\n+\t\t// error type.\n+\t\treturn selected, ErrPlatformNotSupported{\n+\t\t\tProvider: provider,\n+\t\t\tVersion:  version,\n+\t\t\tPlatform: target,\n+\t\t}\n+\t}\n+\tif foundManifests > 1 {\n+\t\t// There must be exactly one eligible manifest, to avoid ambiguity.\n+\t\treturn selected, fmt.Errorf(\"ambiguous manifest has multiple descriptors for platform %s\", target)",
        "comment_created_at": "2025-03-17T16:26:36+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "By the time we reach this point the provider installer will already have reported which version it has selected for each provider -- that happens after calling `AvailableVersions` and before calling `PackageMeta` -- so we don't need to restate it in the individual error messages like this.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1976057080",
    "pr_number": 2551,
    "pr_file": "internal/encryption/keyprovider.go",
    "created_at": "2025-02-28T22:04:23+00:00",
    "commented_code": "\"errors\"\n \t\"fmt\"\n \n+\t\"github.com/hashicorp/hcl/v2\"\n+\t\"github.com/hashicorp/hcl/v2/gohcl\"\n \t\"github.com/opentofu/opentofu/internal/addrs\"\n \t\"github.com/opentofu/opentofu/internal/configs\"\n \t\"github.com/opentofu/opentofu/internal/encryption/config\"\n-\t\"github.com/opentofu/opentofu/internal/lang\"\n-\t\"github.com/opentofu/opentofu/internal/lang/marks\"\n-\n-\t\"github.com/hashicorp/hcl/v2\"\n-\t\"github.com/hashicorp/hcl/v2/gohcl\"\n \t\"github.com/opentofu/opentofu/internal/encryption/keyprovider\"\n \t\"github.com/opentofu/opentofu/internal/encryption/registry\"\n+\t\"github.com/opentofu/opentofu/internal/lang\"\n+\t\"github.com/opentofu/opentofu/internal/lang/marks\"\n \t\"github.com/zclconf/go-cty/cty\"\n )\n \n-// setupKeyProviders sets up the key providers for encryption. It returns a list of diagnostics if any of the key providers\n-// are invalid.\n-func (e *targetBuilder) setupKeyProviders() hcl.Diagnostics {\n+// valueMap is a helper type for building hcl.EvalContexts for key_providers.\n+type valueMap map[string]map[string]cty.Value\n+\n+func (v valueMap) set(first string, second string, value cty.Value) {\n+\tif _, ok := v[first]; !ok {\n+\t\tv[first] = make(map[string]cty.Value)\n+\t}\n+\tv[first][second] = value\n+}\n+\n+func (v valueMap) has(first string, second string) bool {\n+\ts, ok := v[first]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\t_, ok = s[second]\n+\treturn ok\n+}\n+\n+func (v valueMap) hclEvalContext(root string) *hcl.EvalContext {\n+\tmMap := make(map[string]cty.Value)\n+\tfor name, ms := range v {\n+\t\tmMap[name] = cty.ObjectVal(ms)\n+\t}\n+\n+\treturn &hcl.EvalContext{\n+\t\tVariables: map[string]cty.Value{root: cty.ObjectVal(mMap)},\n+\t}\n+}\n+\n+// Given a set of hcl.Traversals, determine the required key provider configs and non-key_provider references\n+func filterKeyProviderReferences(cfg *config.EncryptionConfig, deps []hcl.Traversal) ([]config.KeyProviderConfig, []*addrs.Reference, hcl.Diagnostics) {\n \tvar diags hcl.Diagnostics\n \n-\te.keyValues = make(map[string]map[string]cty.Value)\n+\tvar keyProviderDeps []config.KeyProviderConfig\n+\t// lang.References is going to fail parsing key_provider deps\n+\t// so we filter them out in nonKeyProviderDeps.\n+\tvar nonKeyProviderDeps []hcl.Traversal\n \n-\tkpMap := make(map[string]cty.Value)\n-\tfor _, keyProviderConfig := range e.cfg.KeyProviderConfigs {\n-\t\tdiags = append(diags, e.setupKeyProvider(keyProviderConfig, nil)...)\n-\t\tif diags.HasErrors() {\n-\t\t\treturn diags\n+\t// Setting up key providers from deps.\n+\tfor _, dep := range deps {\n+\t\t// Key Provider references should be in the form key_provider.type.name\n+\t\tif len(dep) != 3 { //nolint:mnd // linting\n+\t\t\tnonKeyProviderDeps = append(nonKeyProviderDeps, dep)\n+\t\t\tcontinue\n \t\t}\n-\t\tfor name, kps := range e.keyValues {\n-\t\t\tkpMap[name] = cty.ObjectVal(kps)\n+\n+\t\t//nolint:errcheck // This will always be a TraverseRoot, panic is OK if that's not the case\n+\t\tdepRoot := (dep[0].(hcl.TraverseRoot)).Name\n+\t\tif depRoot != \"key_provider\" {\n+\t\t\tnonKeyProviderDeps = append(nonKeyProviderDeps, dep)\n+\t\t\tcontinue\n+\t\t}\n+\t\tdepTypeAttr, typeOk := dep[1].(hcl.TraverseAttr)\n+\t\tdepNameAttr, nameOk := dep[2].(hcl.TraverseAttr)\n+\n+\t\tif !typeOk || !nameOk {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Invalid Key Provider expression format\",\n+\t\t\t\tDetail:   \"Expected key_provider.<type>.<name>\",\n+\t\t\t\tSubject:  dep.SourceRange().Ptr(),\n+\t\t\t})\n+\t\t\tcontinue\n \t\t}\n-\t\te.ctx.Variables[\"key_provider\"] = cty.ObjectVal(kpMap)\n+\n+\t\tdepType := depTypeAttr.Name\n+\t\tdepName := depNameAttr.Name\n+\n+\t\tkpc, ok := cfg.GetKeyProvider(depType, depName)\n+\t\tif !ok {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Undefined Key Provider\",\n+\t\t\t\tDetail:   fmt.Sprintf(\"Key provider %s.%s is missing from the encryption configuration.\", depType, depName),",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1976057080",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2551,
        "pr_file": "internal/encryption/keyprovider.go",
        "discussion_id": "1976057080",
        "commented_code": "@@ -10,61 +10,132 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \n+\t\"github.com/hashicorp/hcl/v2\"\n+\t\"github.com/hashicorp/hcl/v2/gohcl\"\n \t\"github.com/opentofu/opentofu/internal/addrs\"\n \t\"github.com/opentofu/opentofu/internal/configs\"\n \t\"github.com/opentofu/opentofu/internal/encryption/config\"\n-\t\"github.com/opentofu/opentofu/internal/lang\"\n-\t\"github.com/opentofu/opentofu/internal/lang/marks\"\n-\n-\t\"github.com/hashicorp/hcl/v2\"\n-\t\"github.com/hashicorp/hcl/v2/gohcl\"\n \t\"github.com/opentofu/opentofu/internal/encryption/keyprovider\"\n \t\"github.com/opentofu/opentofu/internal/encryption/registry\"\n+\t\"github.com/opentofu/opentofu/internal/lang\"\n+\t\"github.com/opentofu/opentofu/internal/lang/marks\"\n \t\"github.com/zclconf/go-cty/cty\"\n )\n \n-// setupKeyProviders sets up the key providers for encryption. It returns a list of diagnostics if any of the key providers\n-// are invalid.\n-func (e *targetBuilder) setupKeyProviders() hcl.Diagnostics {\n+// valueMap is a helper type for building hcl.EvalContexts for key_providers.\n+type valueMap map[string]map[string]cty.Value\n+\n+func (v valueMap) set(first string, second string, value cty.Value) {\n+\tif _, ok := v[first]; !ok {\n+\t\tv[first] = make(map[string]cty.Value)\n+\t}\n+\tv[first][second] = value\n+}\n+\n+func (v valueMap) has(first string, second string) bool {\n+\ts, ok := v[first]\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\t_, ok = s[second]\n+\treturn ok\n+}\n+\n+func (v valueMap) hclEvalContext(root string) *hcl.EvalContext {\n+\tmMap := make(map[string]cty.Value)\n+\tfor name, ms := range v {\n+\t\tmMap[name] = cty.ObjectVal(ms)\n+\t}\n+\n+\treturn &hcl.EvalContext{\n+\t\tVariables: map[string]cty.Value{root: cty.ObjectVal(mMap)},\n+\t}\n+}\n+\n+// Given a set of hcl.Traversals, determine the required key provider configs and non-key_provider references\n+func filterKeyProviderReferences(cfg *config.EncryptionConfig, deps []hcl.Traversal) ([]config.KeyProviderConfig, []*addrs.Reference, hcl.Diagnostics) {\n \tvar diags hcl.Diagnostics\n \n-\te.keyValues = make(map[string]map[string]cty.Value)\n+\tvar keyProviderDeps []config.KeyProviderConfig\n+\t// lang.References is going to fail parsing key_provider deps\n+\t// so we filter them out in nonKeyProviderDeps.\n+\tvar nonKeyProviderDeps []hcl.Traversal\n \n-\tkpMap := make(map[string]cty.Value)\n-\tfor _, keyProviderConfig := range e.cfg.KeyProviderConfigs {\n-\t\tdiags = append(diags, e.setupKeyProvider(keyProviderConfig, nil)...)\n-\t\tif diags.HasErrors() {\n-\t\t\treturn diags\n+\t// Setting up key providers from deps.\n+\tfor _, dep := range deps {\n+\t\t// Key Provider references should be in the form key_provider.type.name\n+\t\tif len(dep) != 3 { //nolint:mnd // linting\n+\t\t\tnonKeyProviderDeps = append(nonKeyProviderDeps, dep)\n+\t\t\tcontinue\n \t\t}\n-\t\tfor name, kps := range e.keyValues {\n-\t\t\tkpMap[name] = cty.ObjectVal(kps)\n+\n+\t\t//nolint:errcheck // This will always be a TraverseRoot, panic is OK if that's not the case\n+\t\tdepRoot := (dep[0].(hcl.TraverseRoot)).Name\n+\t\tif depRoot != \"key_provider\" {\n+\t\t\tnonKeyProviderDeps = append(nonKeyProviderDeps, dep)\n+\t\t\tcontinue\n+\t\t}\n+\t\tdepTypeAttr, typeOk := dep[1].(hcl.TraverseAttr)\n+\t\tdepNameAttr, nameOk := dep[2].(hcl.TraverseAttr)\n+\n+\t\tif !typeOk || !nameOk {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Invalid Key Provider expression format\",\n+\t\t\t\tDetail:   \"Expected key_provider.<type>.<name>\",\n+\t\t\t\tSubject:  dep.SourceRange().Ptr(),\n+\t\t\t})\n+\t\t\tcontinue\n \t\t}\n-\t\te.ctx.Variables[\"key_provider\"] = cty.ObjectVal(kpMap)\n+\n+\t\tdepType := depTypeAttr.Name\n+\t\tdepName := depNameAttr.Name\n+\n+\t\tkpc, ok := cfg.GetKeyProvider(depType, depName)\n+\t\tif !ok {\n+\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\t\tSeverity: hcl.DiagError,\n+\t\t\t\tSummary:  \"Undefined Key Provider\",\n+\t\t\t\tDetail:   fmt.Sprintf(\"Key provider %s.%s is missing from the encryption configuration.\", depType, depName),",
        "comment_created_at": "2025-02-28T22:04:23+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "```suggestion\r\n\t\t\t\tSummary:  \"Reference to undeclared key provider\",\r\n\t\t\t\tDetail:   fmt.Sprintf(\"There is no key_provider %q %q block declared in the encryption block.\", depType, depName),\r\n```\r\n\r\nTo make this more consistent with [the similar message for resource references](https://github.com/opentofu/opentofu/blob/35368d990955f225d0fd72ba6409563c992733e1/internal/tofu/evaluate.go#L658-L664).\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1559345733",
    "pr_number": 1458,
    "pr_file": "internal/encryption/base.go",
    "created_at": "2024-04-10T12:26:53+00:00",
    "commented_code": "return nil, fmt.Errorf(\"unable to determine data structure during decryption: %w\", verr)\n \t\t}\n \n-\t\tmethods, diags := s.buildTargetMethods(make(map[keyprovider.Addr][]byte))\n-\t\tif diags.HasErrors() {\n-\t\t\t// This cast to error here is safe as we know that at least one error exists\n-\t\t\t// This is also quite unlikely to happen as the constructor already has checked this code path\n-\t\t\treturn nil, diags\n-\t\t}\n \t\t// Yep, it's already decrypted\n-\t\tfor _, method := range methods {\n-\t\t\tif method == nil {\n-\t\t\t\t// fallback allowed\n+\t\tfor _, method := range s.encMethods {\n+\t\t\tif unencrypted.Is(method) {\n+\t\t\t\tif s.enforced {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"unable to use unencrypted method when enforced = true\")\n+\t\t\t\t}\n \t\t\t\treturn data, nil\n \t\t\t}\n \t\t}\n-\t\treturn data, fmt.Errorf(\"decrypted payload provided without fallback specified\")\n+\t\treturn nil, fmt.Errorf(\"decrypted payload provided without unencrypted method\")",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1559345733",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1458,
        "pr_file": "internal/encryption/base.go",
        "discussion_id": "1559345733",
        "commented_code": "@@ -149,20 +140,16 @@ func (s *baseEncryption) decrypt(data []byte, validator func([]byte) error) ([]b\n \t\t\treturn nil, fmt.Errorf(\"unable to determine data structure during decryption: %w\", verr)\n \t\t}\n \n-\t\tmethods, diags := s.buildTargetMethods(make(map[keyprovider.Addr][]byte))\n-\t\tif diags.HasErrors() {\n-\t\t\t// This cast to error here is safe as we know that at least one error exists\n-\t\t\t// This is also quite unlikely to happen as the constructor already has checked this code path\n-\t\t\treturn nil, diags\n-\t\t}\n \t\t// Yep, it's already decrypted\n-\t\tfor _, method := range methods {\n-\t\t\tif method == nil {\n-\t\t\t\t// fallback allowed\n+\t\tfor _, method := range s.encMethods {\n+\t\t\tif unencrypted.Is(method) {\n+\t\t\t\tif s.enforced {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"unable to use unencrypted method when enforced = true\")\n+\t\t\t\t}\n \t\t\t\treturn data, nil\n \t\t\t}\n \t\t}\n-\t\treturn data, fmt.Errorf(\"decrypted payload provided without fallback specified\")\n+\t\treturn nil, fmt.Errorf(\"decrypted payload provided without unencrypted method\")",
        "comment_created_at": "2024-04-10T12:26:53+00:00",
        "comment_author": "cube2222",
        "comment_body": "I think we should improve this error message. As a user I wouldn't understand it (I almost didn't understand it now).\r\n\r\nHow about: \"encountered unencrypted payload without unencrypted method configured\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1561134651",
    "pr_number": 1458,
    "pr_file": "internal/encryption/base.go",
    "created_at": "2024-04-11T14:36:24+00:00",
    "commented_code": "}\n \n func (s *baseEncryption) encrypt(data []byte, enhance func(basedata) interface{}) ([]byte, error) {\n-\t// No configuration provided, don't do anything\n-\tif s.target == nil {\n-\t\treturn data, nil\n-\t}\n-\n-\tvar encryptor method.Method = nil\n-\tif len(s.encMethods) != 0 {\n-\t\t// Use the pre-configured encryption method\n-\t\tencryptor = s.encMethods[0]\n-\t}\n+\t// buildTargetMethods above guarantees that there will be at least one encryption method.  They are not optional in the common target\n+\t// block, which is required to get to this code.\n+\tencryptor := s.encMethods[0]\n \n-\tif encryptor == nil {\n+\tif unencrypted.Is(encryptor) {\n \t\t// ensure that the method is defined when Enforced is true\n \t\tif s.enforced {\n-\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires a method to be provided\", s.name)\n+\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires an encryption method to be provided\", s.name)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1561134651",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1458,
        "pr_file": "internal/encryption/base.go",
        "discussion_id": "1561134651",
        "commented_code": "@@ -88,21 +90,14 @@ func IsEncryptionPayload(data []byte) (bool, error) {\n }\n \n func (s *baseEncryption) encrypt(data []byte, enhance func(basedata) interface{}) ([]byte, error) {\n-\t// No configuration provided, don't do anything\n-\tif s.target == nil {\n-\t\treturn data, nil\n-\t}\n-\n-\tvar encryptor method.Method = nil\n-\tif len(s.encMethods) != 0 {\n-\t\t// Use the pre-configured encryption method\n-\t\tencryptor = s.encMethods[0]\n-\t}\n+\t// buildTargetMethods above guarantees that there will be at least one encryption method.  They are not optional in the common target\n+\t// block, which is required to get to this code.\n+\tencryptor := s.encMethods[0]\n \n-\tif encryptor == nil {\n+\tif unencrypted.Is(encryptor) {\n \t\t// ensure that the method is defined when Enforced is true\n \t\tif s.enforced {\n-\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires a method to be provided\", s.name)\n+\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires an encryption method to be provided\", s.name)",
        "comment_created_at": "2024-04-11T14:36:24+00:00",
        "comment_author": "Evi1Pumpkin",
        "comment_body": "Maybe we should be more explicit here and tell the user that he can't use the `unencrypted` method as the \"primary\" method? Because IIUC the user can only get this error if he explicitly turned on the `enforced` flag in combination with the `unencrypted`  method.",
        "pr_file_module": null
      },
      {
        "comment_id": "1562397837",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1458,
        "pr_file": "internal/encryption/base.go",
        "discussion_id": "1561134651",
        "commented_code": "@@ -88,21 +90,14 @@ func IsEncryptionPayload(data []byte) (bool, error) {\n }\n \n func (s *baseEncryption) encrypt(data []byte, enhance func(basedata) interface{}) ([]byte, error) {\n-\t// No configuration provided, don't do anything\n-\tif s.target == nil {\n-\t\treturn data, nil\n-\t}\n-\n-\tvar encryptor method.Method = nil\n-\tif len(s.encMethods) != 0 {\n-\t\t// Use the pre-configured encryption method\n-\t\tencryptor = s.encMethods[0]\n-\t}\n+\t// buildTargetMethods above guarantees that there will be at least one encryption method.  They are not optional in the common target\n+\t// block, which is required to get to this code.\n+\tencryptor := s.encMethods[0]\n \n-\tif encryptor == nil {\n+\tif unencrypted.Is(encryptor) {\n \t\t// ensure that the method is defined when Enforced is true\n \t\tif s.enforced {\n-\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires a method to be provided\", s.name)\n+\t\t\treturn nil, fmt.Errorf(\"encryption of %q is enforced, and therefore requires an encryption method to be provided\", s.name)",
        "comment_created_at": "2024-04-12T11:01:53+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  }
]