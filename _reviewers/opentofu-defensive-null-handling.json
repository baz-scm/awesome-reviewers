[
  {
    "discussion_id": "1772971364",
    "pr_number": 2011,
    "pr_file": "internal/configs/resource.go",
    "created_at": "2024-09-24T09:15:48+00:00",
    "commented_code": "Detail:   fmt.Sprintf(\"Alias expression references 'each' without the 'for_each' declaration.%v\", didYouMean),\n \t\t\tSubject:  m.Alias.Range().Ptr(),\n \t\t})\n+\t}\n \n-\tcase refs.hasEachRef:\n-\t\tdiags = diags.Extend(m.setForEachAliases(eval, refs.filtered, countExpr))\n+\tvar instanceVariableMap map[addrs.InstanceKey]map[string]cty.Value\n+\tvar instanceDiags hcl.Diagnostics\n \n+\tswitch {\n+\tcase refInfo.hasCountRef:\n+\t\tinstanceVariableMap, instanceDiags = m.getCountValues(eval, countExpr)\n+\tcase refInfo.hasEachRef:\n+\t\tinstanceVariableMap, instanceDiags = m.getForEachValues(eval, countExpr)\n \tdefault:\n-\t\tdiags = diags.Extend(m.setNoKeyAliases(eval, refs.filtered))\n+\t\tinstanceVariableMap = map[addrs.InstanceKey]map[string]cty.Value{addrs.NoKey: nil}\n+\t}\n+\n+\tdiags = diags.Extend(instanceDiags)\n+\tif instanceDiags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\taliasStaticID := StaticIdentifier{\n+\t\tModule:    eval.call.addr,\n+\t\tSubject:   \"providers.alias\",\n+\t\tDeclRange: m.Alias.Range(),\n+\t}\n+\n+\tevalCtx, evalCtxDiags := eval.EvalContext(aliasStaticID, refInfo.filtered)\n+\tdiags = diags.Extend(evalCtxDiags)\n+\tif evalCtxDiags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\tfor k, v := range instanceVariableMap {\n+\t\tinstanceEvalCtx := evalCtx.NewChild()\n+\t\tinstanceEvalCtx.Variables = v\n+\n+\t\tvar alias string\n+\t\taliasDiags := gohcl.DecodeExpression(m.Alias, instanceEvalCtx, &alias)\n+\t\tdiags = diags.Extend(aliasDiags)\n+\t\tif aliasDiags.HasErrors() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tm.Aliases[k] = alias",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1772971364",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2011,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "1772971364",
        "commented_code": "@@ -1020,12 +900,48 @@ func (m *ProviderConfigRefMapping) decodeStaticAlias(eval *StaticEvaluator, coun\n \t\t\tDetail:   fmt.Sprintf(\"Alias expression references 'each' without the 'for_each' declaration.%v\", didYouMean),\n \t\t\tSubject:  m.Alias.Range().Ptr(),\n \t\t})\n+\t}\n \n-\tcase refs.hasEachRef:\n-\t\tdiags = diags.Extend(m.setForEachAliases(eval, refs.filtered, countExpr))\n+\tvar instanceVariableMap map[addrs.InstanceKey]map[string]cty.Value\n+\tvar instanceDiags hcl.Diagnostics\n \n+\tswitch {\n+\tcase refInfo.hasCountRef:\n+\t\tinstanceVariableMap, instanceDiags = m.getCountValues(eval, countExpr)\n+\tcase refInfo.hasEachRef:\n+\t\tinstanceVariableMap, instanceDiags = m.getForEachValues(eval, countExpr)\n \tdefault:\n-\t\tdiags = diags.Extend(m.setNoKeyAliases(eval, refs.filtered))\n+\t\tinstanceVariableMap = map[addrs.InstanceKey]map[string]cty.Value{addrs.NoKey: nil}\n+\t}\n+\n+\tdiags = diags.Extend(instanceDiags)\n+\tif instanceDiags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\n+\taliasStaticID := StaticIdentifier{\n+\t\tModule:    eval.call.addr,\n+\t\tSubject:   \"providers.alias\",\n+\t\tDeclRange: m.Alias.Range(),\n+\t}\n+\n+\tevalCtx, evalCtxDiags := eval.EvalContext(aliasStaticID, refInfo.filtered)\n+\tdiags = diags.Extend(evalCtxDiags)\n+\tif evalCtxDiags.HasErrors() {\n+\t\treturn diags\n+\t}\n+\tfor k, v := range instanceVariableMap {\n+\t\tinstanceEvalCtx := evalCtx.NewChild()\n+\t\tinstanceEvalCtx.Variables = v\n+\n+\t\tvar alias string\n+\t\taliasDiags := gohcl.DecodeExpression(m.Alias, instanceEvalCtx, &alias)\n+\t\tdiags = diags.Extend(aliasDiags)\n+\t\tif aliasDiags.HasErrors() {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tm.Aliases[k] = alias",
        "comment_created_at": "2024-09-24T09:15:48+00:00",
        "comment_author": "ollevche",
        "comment_body": "`m.Aliases` must be allocated before the loop.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1758683961",
    "pr_number": 1986,
    "pr_file": "internal/genconfig/generate_config.go",
    "created_at": "2024-09-13T11:20:32+00:00",
    "commented_code": "} else {\n \t\t\t\tval = attrS.EmptyValue()\n \t\t\t}\n-\t\t\tif val.Type() == cty.String {\n-\t\t\t\t// SHAMELESS HACK: If we have \"\" for an optional value, assume\n-\t\t\t\t// it is actually null, due to the legacy SDK.\n-\t\t\t\tif !val.IsNull() && attrS.Optional && len(val.AsString()) == 0 {\n-\t\t\t\t\tval = attrS.EmptyValue()\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tif attrS.Sensitive || val.IsMarked() {\n \t\t\t\tbuf.WriteString(\"null # sensitive\")\n \t\t\t} else {\n+\t\t\t\tif val.Type() == cty.String {\n+\t\t\t\t\t// SHAMELESS HACK: If we have \"\" for an optional value, assume\n+\t\t\t\t\t// it is actually null, due to the legacy SDK.\n+\t\t\t\t\tif !val.IsNull() && attrS.Optional && len(val.AsString()) == 0 {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1758683961",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1986,
        "pr_file": "internal/genconfig/generate_config.go",
        "discussion_id": "1758683961",
        "commented_code": "@@ -152,16 +152,17 @@ func writeConfigAttributesFromExisting(addr addrs.AbsResourceInstance, buf *stri\n \t\t\t} else {\n \t\t\t\tval = attrS.EmptyValue()\n \t\t\t}\n-\t\t\tif val.Type() == cty.String {\n-\t\t\t\t// SHAMELESS HACK: If we have \"\" for an optional value, assume\n-\t\t\t\t// it is actually null, due to the legacy SDK.\n-\t\t\t\tif !val.IsNull() && attrS.Optional && len(val.AsString()) == 0 {\n-\t\t\t\t\tval = attrS.EmptyValue()\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tif attrS.Sensitive || val.IsMarked() {\n \t\t\t\tbuf.WriteString(\"null # sensitive\")\n \t\t\t} else {\n+\t\t\t\tif val.Type() == cty.String {\n+\t\t\t\t\t// SHAMELESS HACK: If we have \"\" for an optional value, assume\n+\t\t\t\t\t// it is actually null, due to the legacy SDK.\n+\t\t\t\t\tif !val.IsNull() && attrS.Optional && len(val.AsString()) == 0 {",
        "comment_created_at": "2024-09-13T11:20:32+00:00",
        "comment_author": "ollevche",
        "comment_body": "`AsString()` panics if the value is marked so we need to call it only after the sensitivity check.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1723548995",
    "pr_number": 1911,
    "pr_file": "internal/configs/provider.go",
    "created_at": "2024-08-20T15:47:30+00:00",
    "commented_code": "}\n \n \tif attr, exists := content.Attributes[\"alias\"]; exists {\n-\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &provider.Alias)\n-\t\tdiags = append(diags, valDiags...)\n+\t\tprovider.AliasExpr = attr.Expr\n \t\tprovider.AliasRange = attr.Expr.Range().Ptr()\n+\t}\n \n-\t\tif !hclsyntax.ValidIdentifier(provider.Alias) {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid provider configuration alias\",\n-\t\t\t\tDetail:   fmt.Sprintf(\"An alias must be a valid name. %s\", badIdentifierDetail),\n-\t\t\t})\n-\t\t}\n+\tif attr, exists := content.Attributes[\"for_each\"]; exists {\n+\t\tprovider.ForEach = attr.Expr\n+\t}\n+\n+\tif attr, exists := content.Attributes[\"count\"]; exists {\n+\t\tprovider.Count = attr.Expr\n+\t}\n+\n+\tif (provider.AliasExpr != nil && provider.Count != nil) || (provider.AliasExpr != nil && provider.ForEach != nil) || (provider.Count != nil && provider.ForEach != nil) {\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid combination of \"alias\", \"count\" and \"for_each\"`,\n+\t\t\tDetail:   `The \"alias\", \"count\" and \"for_each\" arguments are mutually-exclusive, only one may be used.`,\n+\t\t\tSubject:  provider.AliasExpr.Range().Ptr(),",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1723548995",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1911,
        "pr_file": "internal/configs/provider.go",
        "discussion_id": "1723548995",
        "commented_code": "@@ -70,17 +77,25 @@ func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n \t}\n \n \tif attr, exists := content.Attributes[\"alias\"]; exists {\n-\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &provider.Alias)\n-\t\tdiags = append(diags, valDiags...)\n+\t\tprovider.AliasExpr = attr.Expr\n \t\tprovider.AliasRange = attr.Expr.Range().Ptr()\n+\t}\n \n-\t\tif !hclsyntax.ValidIdentifier(provider.Alias) {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid provider configuration alias\",\n-\t\t\t\tDetail:   fmt.Sprintf(\"An alias must be a valid name. %s\", badIdentifierDetail),\n-\t\t\t})\n-\t\t}\n+\tif attr, exists := content.Attributes[\"for_each\"]; exists {\n+\t\tprovider.ForEach = attr.Expr\n+\t}\n+\n+\tif attr, exists := content.Attributes[\"count\"]; exists {\n+\t\tprovider.Count = attr.Expr\n+\t}\n+\n+\tif (provider.AliasExpr != nil && provider.Count != nil) || (provider.AliasExpr != nil && provider.ForEach != nil) || (provider.Count != nil && provider.ForEach != nil) {\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid combination of \"alias\", \"count\" and \"for_each\"`,\n+\t\t\tDetail:   `The \"alias\", \"count\" and \"for_each\" arguments are mutually-exclusive, only one may be used.`,\n+\t\t\tSubject:  provider.AliasExpr.Range().Ptr(),",
        "comment_created_at": "2024-08-20T15:47:30+00:00",
        "comment_author": "ollevche",
        "comment_body": "`AliasExpr` could be nil here and lead to a panic.\r\n\r\nnit: it may be also useful to split the condition into multiple IFs / switch to make it easier to read and provide a more personalized error message.",
        "pr_file_module": null
      },
      {
        "comment_id": "1724753366",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1911,
        "pr_file": "internal/configs/provider.go",
        "discussion_id": "1723548995",
        "commented_code": "@@ -70,17 +77,25 @@ func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n \t}\n \n \tif attr, exists := content.Attributes[\"alias\"]; exists {\n-\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &provider.Alias)\n-\t\tdiags = append(diags, valDiags...)\n+\t\tprovider.AliasExpr = attr.Expr\n \t\tprovider.AliasRange = attr.Expr.Range().Ptr()\n+\t}\n \n-\t\tif !hclsyntax.ValidIdentifier(provider.Alias) {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid provider configuration alias\",\n-\t\t\t\tDetail:   fmt.Sprintf(\"An alias must be a valid name. %s\", badIdentifierDetail),\n-\t\t\t})\n-\t\t}\n+\tif attr, exists := content.Attributes[\"for_each\"]; exists {\n+\t\tprovider.ForEach = attr.Expr\n+\t}\n+\n+\tif attr, exists := content.Attributes[\"count\"]; exists {\n+\t\tprovider.Count = attr.Expr\n+\t}\n+\n+\tif (provider.AliasExpr != nil && provider.Count != nil) || (provider.AliasExpr != nil && provider.ForEach != nil) || (provider.Count != nil && provider.ForEach != nil) {\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid combination of \"alias\", \"count\" and \"for_each\"`,\n+\t\t\tDetail:   `The \"alias\", \"count\" and \"for_each\" arguments are mutually-exclusive, only one may be used.`,\n+\t\t\tSubject:  provider.AliasExpr.Range().Ptr(),",
        "comment_created_at": "2024-08-21T09:36:55+00:00",
        "comment_author": "Andrew-Hayes",
        "comment_body": "funny i did have them split but Christian advocated for a combined error message",
        "pr_file_module": null
      },
      {
        "comment_id": "1726690096",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1911,
        "pr_file": "internal/configs/provider.go",
        "discussion_id": "1723548995",
        "commented_code": "@@ -70,17 +77,25 @@ func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n \t}\n \n \tif attr, exists := content.Attributes[\"alias\"]; exists {\n-\t\tvalDiags := gohcl.DecodeExpression(attr.Expr, nil, &provider.Alias)\n-\t\tdiags = append(diags, valDiags...)\n+\t\tprovider.AliasExpr = attr.Expr\n \t\tprovider.AliasRange = attr.Expr.Range().Ptr()\n+\t}\n \n-\t\tif !hclsyntax.ValidIdentifier(provider.Alias) {\n-\t\t\tdiags = append(diags, &hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid provider configuration alias\",\n-\t\t\t\tDetail:   fmt.Sprintf(\"An alias must be a valid name. %s\", badIdentifierDetail),\n-\t\t\t})\n-\t\t}\n+\tif attr, exists := content.Attributes[\"for_each\"]; exists {\n+\t\tprovider.ForEach = attr.Expr\n+\t}\n+\n+\tif attr, exists := content.Attributes[\"count\"]; exists {\n+\t\tprovider.Count = attr.Expr\n+\t}\n+\n+\tif (provider.AliasExpr != nil && provider.Count != nil) || (provider.AliasExpr != nil && provider.ForEach != nil) || (provider.Count != nil && provider.ForEach != nil) {\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid combination of \"alias\", \"count\" and \"for_each\"`,\n+\t\t\tDetail:   `The \"alias\", \"count\" and \"for_each\" arguments are mutually-exclusive, only one may be used.`,\n+\t\t\tSubject:  provider.AliasExpr.Range().Ptr(),",
        "comment_created_at": "2024-08-22T09:24:32+00:00",
        "comment_author": "ollevche",
        "comment_body": "It is nit, you can just ignore that part of the comment!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1656638087",
    "pr_number": 1750,
    "pr_file": "internal/lang/eval.go",
    "created_at": "2024-06-27T07:48:38+00:00",
    "commented_code": "return s.evalContext(p, refs, s.SelfAddr)\n }\n \n-//nolint:funlen,gocyclo,cyclop // TODO: refactor this function to match linting requirements\n func (s *Scope) evalContext(parent *hcl.EvalContext, refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n \tif s == nil {\n \t\tpanic(\"attempt to construct EvalContext for nil Scope\")\n \t}\n \n \tvar diags tfdiags.Diagnostics\n \n-\tvals := make(map[string]cty.Value)\n-\tfuncs := make(map[string]function.Function)\n-\n \t// Calling NewChild() on a nil parent will\n \t// produce an EvalContext with no parent.\n \tctx := parent.NewChild()\n-\tctx.Variables = vals\n-\tctx.Functions = funcs\n+\tctx.Functions = make(map[string]function.Function)\n \n \tfor name, fn := range s.Functions() {\n-\t\tfuncs[name] = fn\n+\t\tctx.Functions[name] = fn\n \t}\n \n+\t// Easy path for common case where there are no references at all.\n \tif len(refs) == 0 {\n-\t\t// Easy path for common case where there are no references at all.\n+\t\t// We didn't populate variables yet so we just leave it empty.\n+\t\tctx.Variables = make(map[string]cty.Value)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1656638087",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1750,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1656638087",
        "commented_code": "@@ -300,29 +300,26 @@ func (s *Scope) EvalContextWithParent(p *hcl.EvalContext, refs []*addrs.Referenc\n \treturn s.evalContext(p, refs, s.SelfAddr)\n }\n \n-//nolint:funlen,gocyclo,cyclop // TODO: refactor this function to match linting requirements\n func (s *Scope) evalContext(parent *hcl.EvalContext, refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n \tif s == nil {\n \t\tpanic(\"attempt to construct EvalContext for nil Scope\")\n \t}\n \n \tvar diags tfdiags.Diagnostics\n \n-\tvals := make(map[string]cty.Value)\n-\tfuncs := make(map[string]function.Function)\n-\n \t// Calling NewChild() on a nil parent will\n \t// produce an EvalContext with no parent.\n \tctx := parent.NewChild()\n-\tctx.Variables = vals\n-\tctx.Functions = funcs\n+\tctx.Functions = make(map[string]function.Function)\n \n \tfor name, fn := range s.Functions() {\n-\t\tfuncs[name] = fn\n+\t\tctx.Functions[name] = fn\n \t}\n \n+\t// Easy path for common case where there are no references at all.\n \tif len(refs) == 0 {\n-\t\t// Easy path for common case where there are no references at all.\n+\t\t// We didn't populate variables yet so we just leave it empty.\n+\t\tctx.Variables = make(map[string]cty.Value)",
        "comment_created_at": "2024-06-27T07:48:38+00:00",
        "comment_author": "RLRabinowitz",
        "comment_body": "This isn't the only `return` statement in this function. In cases of error diags we don't make the Variables map, and this could technically lead to a regression. There could be usages attempting to use the Variables map even if there's an error diag (like [this](https://github.com/opentofu/opentofu/blob/e2b6b46d4303c52a486f578450dd55efaeba7533/internal/lang/eval.go#L263-L268), even though I think this part still works because it's just a `nil` map access which should not fail)\r\n\r\nMaybe it's worth changing the approach, by having `ctx.Variables = make(map[string]cty.Value)` higher up, next to the `ctx.Functions` assignment, and just re-assign `ctx.Variables` later on\r\n\r\nPlease correct me if I'm wrong here",
        "pr_file_module": null
      },
      {
        "comment_id": "1660729861",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1750,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1656638087",
        "commented_code": "@@ -300,29 +300,26 @@ func (s *Scope) EvalContextWithParent(p *hcl.EvalContext, refs []*addrs.Referenc\n \treturn s.evalContext(p, refs, s.SelfAddr)\n }\n \n-//nolint:funlen,gocyclo,cyclop // TODO: refactor this function to match linting requirements\n func (s *Scope) evalContext(parent *hcl.EvalContext, refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n \tif s == nil {\n \t\tpanic(\"attempt to construct EvalContext for nil Scope\")\n \t}\n \n \tvar diags tfdiags.Diagnostics\n \n-\tvals := make(map[string]cty.Value)\n-\tfuncs := make(map[string]function.Function)\n-\n \t// Calling NewChild() on a nil parent will\n \t// produce an EvalContext with no parent.\n \tctx := parent.NewChild()\n-\tctx.Variables = vals\n-\tctx.Functions = funcs\n+\tctx.Functions = make(map[string]function.Function)\n \n \tfor name, fn := range s.Functions() {\n-\t\tfuncs[name] = fn\n+\t\tctx.Functions[name] = fn\n \t}\n \n+\t// Easy path for common case where there are no references at all.\n \tif len(refs) == 0 {\n-\t\t// Easy path for common case where there are no references at all.\n+\t\t// We didn't populate variables yet so we just leave it empty.\n+\t\tctx.Variables = make(map[string]cty.Value)",
        "comment_created_at": "2024-07-01T09:13:26+00:00",
        "comment_author": "ollevche",
        "comment_body": "Yep, I completely agree with you. I moved it higher and changed `buildAllVariables` to write into an existing map so we use the same map everywhere.\r\n\r\nbadc0309785d7139b9e9b66cdd5d41714814d142",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1547866912",
    "pr_number": 1270,
    "pr_file": "internal/tofu/eval_context_builtin.go",
    "created_at": "2024-04-02T13:16:24+00:00",
    "commented_code": "return ref, replace, diags\n }\n \n+// EvaluateImportAddress takes the raw reference expression of the import address\n+// from the config, and returns the evaluated address addrs.AbsResourceInstance\n+//\n+// The implementation is inspired by config.AbsTraversalForImportToExpr, but this time we can evaluate the expression\n+// in the indexes of expressions. If we encounter a hclsyntax.IndexExpr, we can evaluate the Key expression and create\n+// an Index Traversal, adding it to the Traverser\n+func (ctx *BuiltinEvalContext) EvaluateImportAddress(expr hcl.Expression) (addrs.AbsResourceInstance, tfdiags.Diagnostics) {\n+\ttraversal, diags := ctx.traversalForImportExpr(expr)\n+\tif diags.HasErrors() {\n+\t\treturn addrs.AbsResourceInstance{}, diags\n+\t}\n+\n+\treturn addrs.ParseAbsResourceInstance(traversal)\n+}\n+\n+func (ctx *BuiltinEvalContext) traversalForImportExpr(expr hcl.Expression) (traversal hcl.Traversal, diags tfdiags.Diagnostics) {\n+\tswitch e := expr.(type) {\n+\tcase *hclsyntax.IndexExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Collection)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\n+\t\ttIndex, dIndex := ctx.parseImportIndexKeyExpr(e.Key)\n+\t\tdiags = diags.Append(dIndex)\n+\t\ttraversal = append(traversal, tIndex)\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Source)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tdefault:\n+\t\t// This should not happen, as it should have failed validation earlier, in config.AbsTraversalForImportToExpr\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Invalid import address expression\",\n+\t\t\tDetail:   \"Import address must be a reference to a resource's address, and only allows for indexing with dynamic keys. For example: module.my_module[expression1].aws_s3_bucket.my_buckets[expression2] for resources inside of modules, or simply aws_s3_bucket.my_bucket for a resource in the root module\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn\n+}\n+\n+// parseImportIndexKeyExpr parses an expression that is used as a key in an index, of an HCL expression representing an\n+// import target address, into a traversal of type hcl.TraverseIndex.\n+// After evaluation, the expression must be known, not null, not sensitive, and must be a string (for_each) or a number\n+// (count)\n+func (ctx *BuiltinEvalContext) parseImportIndexKeyExpr(expr hcl.Expression) (hcl.TraverseIndex, tfdiags.Diagnostics) {\n+\tidx := hcl.TraverseIndex{\n+\t\tSrcRange: expr.Range(),\n+\t}\n+\n+\tval, diags := ctx.EvaluateExpr(expr, cty.DynamicPseudoType, nil)\n+\tif diags.HasErrors() {\n+\t\treturn idx, diags\n+\t}\n+\n+\tif !val.IsKnown() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index will only be known after apply. Please make sure to use expressions that are known at plan time for the index of an import target address\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t\treturn idx, diags\n+\t}\n+\n+\tif val.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index which is null. Please make sure the expression for the index is not null\",",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1547866912",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1270,
        "pr_file": "internal/tofu/eval_context_builtin.go",
        "discussion_id": "1547866912",
        "commented_code": "@@ -408,6 +411,108 @@ func (ctx *BuiltinEvalContext) EvaluateReplaceTriggeredBy(expr hcl.Expression, r\n \treturn ref, replace, diags\n }\n \n+// EvaluateImportAddress takes the raw reference expression of the import address\n+// from the config, and returns the evaluated address addrs.AbsResourceInstance\n+//\n+// The implementation is inspired by config.AbsTraversalForImportToExpr, but this time we can evaluate the expression\n+// in the indexes of expressions. If we encounter a hclsyntax.IndexExpr, we can evaluate the Key expression and create\n+// an Index Traversal, adding it to the Traverser\n+func (ctx *BuiltinEvalContext) EvaluateImportAddress(expr hcl.Expression) (addrs.AbsResourceInstance, tfdiags.Diagnostics) {\n+\ttraversal, diags := ctx.traversalForImportExpr(expr)\n+\tif diags.HasErrors() {\n+\t\treturn addrs.AbsResourceInstance{}, diags\n+\t}\n+\n+\treturn addrs.ParseAbsResourceInstance(traversal)\n+}\n+\n+func (ctx *BuiltinEvalContext) traversalForImportExpr(expr hcl.Expression) (traversal hcl.Traversal, diags tfdiags.Diagnostics) {\n+\tswitch e := expr.(type) {\n+\tcase *hclsyntax.IndexExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Collection)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\n+\t\ttIndex, dIndex := ctx.parseImportIndexKeyExpr(e.Key)\n+\t\tdiags = diags.Append(dIndex)\n+\t\ttraversal = append(traversal, tIndex)\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Source)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tdefault:\n+\t\t// This should not happen, as it should have failed validation earlier, in config.AbsTraversalForImportToExpr\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Invalid import address expression\",\n+\t\t\tDetail:   \"Import address must be a reference to a resource's address, and only allows for indexing with dynamic keys. For example: module.my_module[expression1].aws_s3_bucket.my_buckets[expression2] for resources inside of modules, or simply aws_s3_bucket.my_bucket for a resource in the root module\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn\n+}\n+\n+// parseImportIndexKeyExpr parses an expression that is used as a key in an index, of an HCL expression representing an\n+// import target address, into a traversal of type hcl.TraverseIndex.\n+// After evaluation, the expression must be known, not null, not sensitive, and must be a string (for_each) or a number\n+// (count)\n+func (ctx *BuiltinEvalContext) parseImportIndexKeyExpr(expr hcl.Expression) (hcl.TraverseIndex, tfdiags.Diagnostics) {\n+\tidx := hcl.TraverseIndex{\n+\t\tSrcRange: expr.Range(),\n+\t}\n+\n+\tval, diags := ctx.EvaluateExpr(expr, cty.DynamicPseudoType, nil)\n+\tif diags.HasErrors() {\n+\t\treturn idx, diags\n+\t}\n+\n+\tif !val.IsKnown() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index will only be known after apply. Please make sure to use expressions that are known at plan time for the index of an import target address\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t\treturn idx, diags\n+\t}\n+\n+\tif val.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index which is null. Please make sure the expression for the index is not null\",",
        "comment_created_at": "2024-04-02T13:16:24+00:00",
        "comment_author": "Yantrio",
        "comment_body": "```suggestion\r\n\t\t\tSummary:  \"Import block 'to' address contains an invalid key\",\r\n\t\t\tDetail:   \"Import block contained a resource address using an index which is null. Please make sure the expression for the index is not null\",\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1554946539",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1270,
        "pr_file": "internal/tofu/eval_context_builtin.go",
        "discussion_id": "1547866912",
        "commented_code": "@@ -408,6 +411,108 @@ func (ctx *BuiltinEvalContext) EvaluateReplaceTriggeredBy(expr hcl.Expression, r\n \treturn ref, replace, diags\n }\n \n+// EvaluateImportAddress takes the raw reference expression of the import address\n+// from the config, and returns the evaluated address addrs.AbsResourceInstance\n+//\n+// The implementation is inspired by config.AbsTraversalForImportToExpr, but this time we can evaluate the expression\n+// in the indexes of expressions. If we encounter a hclsyntax.IndexExpr, we can evaluate the Key expression and create\n+// an Index Traversal, adding it to the Traverser\n+func (ctx *BuiltinEvalContext) EvaluateImportAddress(expr hcl.Expression) (addrs.AbsResourceInstance, tfdiags.Diagnostics) {\n+\ttraversal, diags := ctx.traversalForImportExpr(expr)\n+\tif diags.HasErrors() {\n+\t\treturn addrs.AbsResourceInstance{}, diags\n+\t}\n+\n+\treturn addrs.ParseAbsResourceInstance(traversal)\n+}\n+\n+func (ctx *BuiltinEvalContext) traversalForImportExpr(expr hcl.Expression) (traversal hcl.Traversal, diags tfdiags.Diagnostics) {\n+\tswitch e := expr.(type) {\n+\tcase *hclsyntax.IndexExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Collection)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\n+\t\ttIndex, dIndex := ctx.parseImportIndexKeyExpr(e.Key)\n+\t\tdiags = diags.Append(dIndex)\n+\t\ttraversal = append(traversal, tIndex)\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tt, d := ctx.traversalForImportExpr(e.Source)\n+\t\tdiags = diags.Append(d)\n+\t\ttraversal = append(traversal, t...)\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\ttraversal = append(traversal, e.Traversal...)\n+\tdefault:\n+\t\t// This should not happen, as it should have failed validation earlier, in config.AbsTraversalForImportToExpr\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Invalid import address expression\",\n+\t\t\tDetail:   \"Import address must be a reference to a resource's address, and only allows for indexing with dynamic keys. For example: module.my_module[expression1].aws_s3_bucket.my_buckets[expression2] for resources inside of modules, or simply aws_s3_bucket.my_bucket for a resource in the root module\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn\n+}\n+\n+// parseImportIndexKeyExpr parses an expression that is used as a key in an index, of an HCL expression representing an\n+// import target address, into a traversal of type hcl.TraverseIndex.\n+// After evaluation, the expression must be known, not null, not sensitive, and must be a string (for_each) or a number\n+// (count)\n+func (ctx *BuiltinEvalContext) parseImportIndexKeyExpr(expr hcl.Expression) (hcl.TraverseIndex, tfdiags.Diagnostics) {\n+\tidx := hcl.TraverseIndex{\n+\t\tSrcRange: expr.Range(),\n+\t}\n+\n+\tval, diags := ctx.EvaluateExpr(expr, cty.DynamicPseudoType, nil)\n+\tif diags.HasErrors() {\n+\t\treturn idx, diags\n+\t}\n+\n+\tif !val.IsKnown() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index will only be known after apply. Please make sure to use expressions that are known at plan time for the index of an import target address\",\n+\t\t\tSubject:  expr.Range().Ptr(),\n+\t\t})\n+\t\treturn idx, diags\n+\t}\n+\n+\tif val.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  \"Import block 'to' address contains invalid key\",\n+\t\t\tDetail:   \"Import block contained a resource address using an index which is null. Please make sure the expression for the index is not null\",",
        "comment_created_at": "2024-04-07T11:21:39+00:00",
        "comment_author": "Evi1Pumpkin",
        "comment_body": "https://github.com/opentofu/opentofu/pull/1270/commits/ac25cf3ebf6457893dfc4412ff594d38093042a6",
        "pr_file_module": null
      }
    ]
  }
]