[
  {
    "discussion_id": "2050565459",
    "pr_number": 2679,
    "pr_file": "internal/states/statefile/version4.go",
    "created_at": "2025-04-18T12:35:35+00:00",
    "commented_code": "ValueRaw     json.RawMessage `json:\"value\"`\n \tValueTypeRaw json.RawMessage `json:\"type\"`\n \tSensitive    bool            `json:\"sensitive,omitempty\"`\n+\t// TODO: Do we need to update the state schema or state documentation somewhere?",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2050565459",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2679,
        "pr_file": "internal/states/statefile/version4.go",
        "discussion_id": "2050565459",
        "commented_code": "@@ -764,6 +767,8 @@ type outputStateV4 struct {\n \tValueRaw     json.RawMessage `json:\"value\"`\n \tValueTypeRaw json.RawMessage `json:\"type\"`\n \tSensitive    bool            `json:\"sensitive,omitempty\"`\n+\t// TODO: Do we need to update the state schema or state documentation somewhere?",
        "comment_created_at": "2025-04-18T12:35:35+00:00",
        "comment_author": "cam72cam",
        "comment_body": "We typically don't suggest folks look directly at the statefile, I don't think we have these fields documented anywhere concrete.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998512458",
    "pr_number": 2580,
    "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
    "created_at": "2025-03-17T11:13:28+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998512458",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998512458",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.",
        "comment_created_at": "2025-03-17T11:13:28+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\nCould we maybe include a url here? \ud83e\udd14 \r\nMaybe? https://opencontainers.org/posts/blog/2024-03-13-image-and-distribution-1-1/#manifest-maximum-size\r\nI am not sure which is the official one.",
        "pr_file_module": null
      },
      {
        "comment_id": "1999084378",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998512458",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.",
        "comment_created_at": "2025-03-17T15:55:12+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "Unfortunately the _published_ versions of this spec seem to be available only as documents attached to GitHub releases, and the server-side for those URLs returns headers that force treating the file as a \"download\" rather than rendering it directly in the browser, so I wasn't sure how best to link to them.\r\n\r\nHowever, looking again today I notice that the specification text in the repository is also available under a git tag corresponding to the release, and so I guess this link is a plausible reference:\r\n\r\nhttps://github.com/opencontainers/distribution-spec/blob/v1.1.0/spec.md#pushing-manifests\r\n\r\n(The recommendation comes from the last paragraph of that section.)\r\n\r\nI'll push a new version with this link included. Thanks!\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1976030747",
    "pr_number": 2551,
    "pr_file": "internal/encryption/config/config_parse.go",
    "created_at": "2025-02-28T21:31:20+00:00",
    "commented_code": "break\n \t\t\t}\n \t\t}\n+",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1976030747",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2551,
        "pr_file": "internal/encryption/config/config_parse.go",
        "discussion_id": "1976030747",
        "commented_code": "@@ -36,6 +36,10 @@ func DecodeConfig(body hcl.Body, rng hcl.Range) (*EncryptionConfig, hcl.Diagnost\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n+",
        "comment_created_at": "2025-02-28T21:31:20+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "I know this outside the scope of what you were doing here, but the comment on this `DecodeConfig` function says that it's only used in tests but I can see a call to it in `configs.loadConfigFile` that seems to disagree, so maybe worth correcting that comment while you're working in this area anyway?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1977898361",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2551,
        "pr_file": "internal/encryption/config/config_parse.go",
        "discussion_id": "1976030747",
        "commented_code": "@@ -36,6 +36,10 @@ func DecodeConfig(body hcl.Body, rng hcl.Range) (*EncryptionConfig, hcl.Diagnost\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n+",
        "comment_created_at": "2025-03-03T17:23:24+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Fixed in 1c3e8c0677",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1850736303",
    "pr_number": 2186,
    "pr_file": "internal/configs/provider_validation.go",
    "created_at": "2024-11-20T17:36:57+00:00",
    "commented_code": "}\n \treturn name\n }\n+\n+func providerIterationIdenticalWarning(blockType string, sourceExpr, instanceExpr hcl.Expression) hcl.Diagnostics {\n+\tvar diags hcl.Diagnostics\n+\tif providerIterationIdentical(sourceExpr, instanceExpr) {\n+\t\t// foot, meet gun\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagWarning,\n+\t\t\tSummary:  \"Likely misconfiguration of provider iteration\",\n+\t\t\tDetail:   fmt.Sprintf(\"Provider and %s both share identical iteration expressions, this is not recommended. When a key is removed, the corresponding resources will no longer have a provider that is able to destroy them.\nInstead, it is recommended to have %s's iteration be a subset of the provider's iteration expression. See the OpenTofu documentation for more details.\n\nTo disable this warning, wrap one of the expressions in a function like coalesce() to disable the check.\", blockType, blockType),\n+\t\t\tSubject:  sourceExpr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn diags\n+}\n+\n+// Might have gone a bit overboard on this...\n+//\n+//nolint:funlen,gocognit,gocyclo,cyclop // just a lot of branches\n+func providerIterationIdentical(a, b hcl.Expression) bool {\n+\tif a == nil && b == nil {\n+\t\treturn true\n+\t}\n+\t// Remove parenthesis\n+\tif ae, ok := a.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Expression, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Expression)\n+\t}\n+\n+\tif ae, ok := a.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Wrapped, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Wrapped)\n+\t}\n+\n+\tswitch as := a.(type) {\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ScopeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal)\n+\t\t}\n+\tcase *hclsyntax.LiteralValueExpr:\n+\t\tif bs, bok := b.(*hclsyntax.LiteralValueExpr); bok {\n+\t\t\treturn as.Val.Equals(bs.Val).True()\n+\t\t}\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.RelativeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal) &&\n+\t\t\t\tproviderIterationIdentical(as.Source, bs.Source)\n+\t\t}\n+\tcase *hclsyntax.FunctionCallExpr:\n+\t\tif bs, bok := b.(*hclsyntax.FunctionCallExpr); bok {\n+\t\t\tif as.Name == bs.Name && len(as.Args) == len(bs.Args) {\n+\t\t\t\tfor i := range as.Args {\n+\t\t\t\t\tif !providerIterationIdentical(as.Args[i], bs.Args[i]) {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\tcase *hclsyntax.ConditionalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ConditionalExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Condition, bs.Condition) &&\n+\t\t\t\tproviderIterationIdentical(as.TrueResult, bs.TrueResult) &&\n+\t\t\t\tproviderIterationIdentical(as.FalseResult, bs.FalseResult)\n+\t\t}\n+\tcase *hclsyntax.IndexExpr:\n+\t\tif bs, bok := b.(*hclsyntax.IndexExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Collection, bs.Collection) &&\n+\t\t\t\tproviderIterationIdentical(as.Key, bs.Key)\n+\t\t}\n+\tcase *hclsyntax.TupleConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TupleConsExpr); bok && len(as.Exprs) == len(bs.Exprs) {\n+\t\t\tfor i := range as.Exprs {\n+\t\t\t\tif !providerIterationIdentical(as.Exprs[i], bs.Exprs[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ObjectConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ObjectConsExpr); bok && len(as.Items) == len(bs.Items) {\n+\t\t\tfor i := range as.Items {\n+\t\t\t\tif !providerIterationIdentical(as.Items[i].KeyExpr, bs.Items[i].KeyExpr) ||\n+\t\t\t\t\t!providerIterationIdentical(as.Items[i].ValueExpr, bs.Items[i].ValueExpr) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ForExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ForExpr); bok {\n+\t\t\treturn as.KeyVar == bs.KeyVar &&\n+\t\t\t\tas.ValVar == bs.ValVar &&\n+\t\t\t\tproviderIterationIdentical(as.CollExpr, bs.CollExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.KeyExpr, bs.KeyExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.ValExpr, bs.ValExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.CondExpr, bs.CondExpr) &&\n+\t\t\t\tas.Group == bs.Group\n+\t\t}\n+\tcase *hclsyntax.BinaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.BinaryOpExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.LHS, bs.LHS) &&\n+\t\t\t\tas.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.RHS, bs.RHS)\n+\t\t}\n+\tcase *hclsyntax.UnaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.UnaryOpExpr); bok {\n+\t\t\treturn as.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.Val, bs.Val)\n+\t\t}\n+\tcase *hclsyntax.TemplateExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TemplateExpr); bok && len(as.Parts) == len(bs.Parts) {\n+\t\t\tfor i := range as.Parts {\n+\t\t\t\tif !providerIterationIdentical(as.Parts[i], bs.Parts[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t// Ignored:\n+\t// case *hclsyntax.SplatExpr:\n+\t// case *hclsyntax.AnonSymbolExpr:\n+\t// case *hclsyntax.ExprSyntaxError\n+\t// case *hclsyntax.TemplateJoinExpr:\n+\t// case *hclsyntax.TemplateWrapExpr:",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1850736303",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2186,
        "pr_file": "internal/configs/provider_validation.go",
        "discussion_id": "1850736303",
        "commented_code": "@@ -831,3 +842,165 @@ func providerName(name, alias string) string {\n \t}\n \treturn name\n }\n+\n+func providerIterationIdenticalWarning(blockType string, sourceExpr, instanceExpr hcl.Expression) hcl.Diagnostics {\n+\tvar diags hcl.Diagnostics\n+\tif providerIterationIdentical(sourceExpr, instanceExpr) {\n+\t\t// foot, meet gun\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagWarning,\n+\t\t\tSummary:  \"Likely misconfiguration of provider iteration\",\n+\t\t\tDetail:   fmt.Sprintf(\"Provider and %s both share identical iteration expressions, this is not recommended. When a key is removed, the corresponding resources will no longer have a provider that is able to destroy them.\\nInstead, it is recommended to have %s's iteration be a subset of the provider's iteration expression. See the OpenTofu documentation for more details.\\n\\nTo disable this warning, wrap one of the expressions in a function like coalesce() to disable the check.\", blockType, blockType),\n+\t\t\tSubject:  sourceExpr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn diags\n+}\n+\n+// Might have gone a bit overboard on this...\n+//\n+//nolint:funlen,gocognit,gocyclo,cyclop // just a lot of branches\n+func providerIterationIdentical(a, b hcl.Expression) bool {\n+\tif a == nil && b == nil {\n+\t\treturn true\n+\t}\n+\t// Remove parenthesis\n+\tif ae, ok := a.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Expression, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Expression)\n+\t}\n+\n+\tif ae, ok := a.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Wrapped, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Wrapped)\n+\t}\n+\n+\tswitch as := a.(type) {\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ScopeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal)\n+\t\t}\n+\tcase *hclsyntax.LiteralValueExpr:\n+\t\tif bs, bok := b.(*hclsyntax.LiteralValueExpr); bok {\n+\t\t\treturn as.Val.Equals(bs.Val).True()\n+\t\t}\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.RelativeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal) &&\n+\t\t\t\tproviderIterationIdentical(as.Source, bs.Source)\n+\t\t}\n+\tcase *hclsyntax.FunctionCallExpr:\n+\t\tif bs, bok := b.(*hclsyntax.FunctionCallExpr); bok {\n+\t\t\tif as.Name == bs.Name && len(as.Args) == len(bs.Args) {\n+\t\t\t\tfor i := range as.Args {\n+\t\t\t\t\tif !providerIterationIdentical(as.Args[i], bs.Args[i]) {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\tcase *hclsyntax.ConditionalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ConditionalExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Condition, bs.Condition) &&\n+\t\t\t\tproviderIterationIdentical(as.TrueResult, bs.TrueResult) &&\n+\t\t\t\tproviderIterationIdentical(as.FalseResult, bs.FalseResult)\n+\t\t}\n+\tcase *hclsyntax.IndexExpr:\n+\t\tif bs, bok := b.(*hclsyntax.IndexExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Collection, bs.Collection) &&\n+\t\t\t\tproviderIterationIdentical(as.Key, bs.Key)\n+\t\t}\n+\tcase *hclsyntax.TupleConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TupleConsExpr); bok && len(as.Exprs) == len(bs.Exprs) {\n+\t\t\tfor i := range as.Exprs {\n+\t\t\t\tif !providerIterationIdentical(as.Exprs[i], bs.Exprs[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ObjectConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ObjectConsExpr); bok && len(as.Items) == len(bs.Items) {\n+\t\t\tfor i := range as.Items {\n+\t\t\t\tif !providerIterationIdentical(as.Items[i].KeyExpr, bs.Items[i].KeyExpr) ||\n+\t\t\t\t\t!providerIterationIdentical(as.Items[i].ValueExpr, bs.Items[i].ValueExpr) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ForExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ForExpr); bok {\n+\t\t\treturn as.KeyVar == bs.KeyVar &&\n+\t\t\t\tas.ValVar == bs.ValVar &&\n+\t\t\t\tproviderIterationIdentical(as.CollExpr, bs.CollExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.KeyExpr, bs.KeyExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.ValExpr, bs.ValExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.CondExpr, bs.CondExpr) &&\n+\t\t\t\tas.Group == bs.Group\n+\t\t}\n+\tcase *hclsyntax.BinaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.BinaryOpExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.LHS, bs.LHS) &&\n+\t\t\t\tas.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.RHS, bs.RHS)\n+\t\t}\n+\tcase *hclsyntax.UnaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.UnaryOpExpr); bok {\n+\t\t\treturn as.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.Val, bs.Val)\n+\t\t}\n+\tcase *hclsyntax.TemplateExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TemplateExpr); bok && len(as.Parts) == len(bs.Parts) {\n+\t\t\tfor i := range as.Parts {\n+\t\t\t\tif !providerIterationIdentical(as.Parts[i], bs.Parts[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t// Ignored:\n+\t// case *hclsyntax.SplatExpr:\n+\t// case *hclsyntax.AnonSymbolExpr:\n+\t// case *hclsyntax.ExprSyntaxError\n+\t// case *hclsyntax.TemplateJoinExpr:\n+\t// case *hclsyntax.TemplateWrapExpr:",
        "comment_created_at": "2024-11-20T17:36:57+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "Suggest replacing this with some words in this function's doc comment that are clear that the scope of this function is intentionally limited only to simple references and function calls with arguments that are simple references, and that everything else always returns `false`, to make it clear that we are not expecting to continue adding to this each time HCL adds a new feature upstream.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1856723707",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2186,
        "pr_file": "internal/configs/provider_validation.go",
        "discussion_id": "1850736303",
        "commented_code": "@@ -831,3 +842,165 @@ func providerName(name, alias string) string {\n \t}\n \treturn name\n }\n+\n+func providerIterationIdenticalWarning(blockType string, sourceExpr, instanceExpr hcl.Expression) hcl.Diagnostics {\n+\tvar diags hcl.Diagnostics\n+\tif providerIterationIdentical(sourceExpr, instanceExpr) {\n+\t\t// foot, meet gun\n+\t\tdiags = append(diags, &hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagWarning,\n+\t\t\tSummary:  \"Likely misconfiguration of provider iteration\",\n+\t\t\tDetail:   fmt.Sprintf(\"Provider and %s both share identical iteration expressions, this is not recommended. When a key is removed, the corresponding resources will no longer have a provider that is able to destroy them.\\nInstead, it is recommended to have %s's iteration be a subset of the provider's iteration expression. See the OpenTofu documentation for more details.\\n\\nTo disable this warning, wrap one of the expressions in a function like coalesce() to disable the check.\", blockType, blockType),\n+\t\t\tSubject:  sourceExpr.Range().Ptr(),\n+\t\t})\n+\t}\n+\treturn diags\n+}\n+\n+// Might have gone a bit overboard on this...\n+//\n+//nolint:funlen,gocognit,gocyclo,cyclop // just a lot of branches\n+func providerIterationIdentical(a, b hcl.Expression) bool {\n+\tif a == nil && b == nil {\n+\t\treturn true\n+\t}\n+\t// Remove parenthesis\n+\tif ae, ok := a.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Expression, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ParenthesesExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Expression)\n+\t}\n+\n+\tif ae, ok := a.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(ae.Wrapped, b)\n+\t}\n+\tif be, ok := b.(*hclsyntax.ObjectConsKeyExpr); ok {\n+\t\treturn providerIterationIdentical(a, be.Wrapped)\n+\t}\n+\n+\tswitch as := a.(type) {\n+\tcase *hclsyntax.ScopeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ScopeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal)\n+\t\t}\n+\tcase *hclsyntax.LiteralValueExpr:\n+\t\tif bs, bok := b.(*hclsyntax.LiteralValueExpr); bok {\n+\t\t\treturn as.Val.Equals(bs.Val).True()\n+\t\t}\n+\tcase *hclsyntax.RelativeTraversalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.RelativeTraversalExpr); bok {\n+\t\t\treturn TraversalStr(as.Traversal) == TraversalStr(bs.Traversal) &&\n+\t\t\t\tproviderIterationIdentical(as.Source, bs.Source)\n+\t\t}\n+\tcase *hclsyntax.FunctionCallExpr:\n+\t\tif bs, bok := b.(*hclsyntax.FunctionCallExpr); bok {\n+\t\t\tif as.Name == bs.Name && len(as.Args) == len(bs.Args) {\n+\t\t\t\tfor i := range as.Args {\n+\t\t\t\t\tif !providerIterationIdentical(as.Args[i], bs.Args[i]) {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\tcase *hclsyntax.ConditionalExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ConditionalExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Condition, bs.Condition) &&\n+\t\t\t\tproviderIterationIdentical(as.TrueResult, bs.TrueResult) &&\n+\t\t\t\tproviderIterationIdentical(as.FalseResult, bs.FalseResult)\n+\t\t}\n+\tcase *hclsyntax.IndexExpr:\n+\t\tif bs, bok := b.(*hclsyntax.IndexExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.Collection, bs.Collection) &&\n+\t\t\t\tproviderIterationIdentical(as.Key, bs.Key)\n+\t\t}\n+\tcase *hclsyntax.TupleConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TupleConsExpr); bok && len(as.Exprs) == len(bs.Exprs) {\n+\t\t\tfor i := range as.Exprs {\n+\t\t\t\tif !providerIterationIdentical(as.Exprs[i], bs.Exprs[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ObjectConsExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ObjectConsExpr); bok && len(as.Items) == len(bs.Items) {\n+\t\t\tfor i := range as.Items {\n+\t\t\t\tif !providerIterationIdentical(as.Items[i].KeyExpr, bs.Items[i].KeyExpr) ||\n+\t\t\t\t\t!providerIterationIdentical(as.Items[i].ValueExpr, bs.Items[i].ValueExpr) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\tcase *hclsyntax.ForExpr:\n+\t\tif bs, bok := b.(*hclsyntax.ForExpr); bok {\n+\t\t\treturn as.KeyVar == bs.KeyVar &&\n+\t\t\t\tas.ValVar == bs.ValVar &&\n+\t\t\t\tproviderIterationIdentical(as.CollExpr, bs.CollExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.KeyExpr, bs.KeyExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.ValExpr, bs.ValExpr) &&\n+\t\t\t\tproviderIterationIdentical(as.CondExpr, bs.CondExpr) &&\n+\t\t\t\tas.Group == bs.Group\n+\t\t}\n+\tcase *hclsyntax.BinaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.BinaryOpExpr); bok {\n+\t\t\treturn providerIterationIdentical(as.LHS, bs.LHS) &&\n+\t\t\t\tas.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.RHS, bs.RHS)\n+\t\t}\n+\tcase *hclsyntax.UnaryOpExpr:\n+\t\tif bs, bok := b.(*hclsyntax.UnaryOpExpr); bok {\n+\t\t\treturn as.Op == bs.Op &&\n+\t\t\t\tproviderIterationIdentical(as.Val, bs.Val)\n+\t\t}\n+\tcase *hclsyntax.TemplateExpr:\n+\t\tif bs, bok := b.(*hclsyntax.TemplateExpr); bok && len(as.Parts) == len(bs.Parts) {\n+\t\t\tfor i := range as.Parts {\n+\t\t\t\tif !providerIterationIdentical(as.Parts[i], bs.Parts[i]) {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t// Ignored:\n+\t// case *hclsyntax.SplatExpr:\n+\t// case *hclsyntax.AnonSymbolExpr:\n+\t// case *hclsyntax.ExprSyntaxError\n+\t// case *hclsyntax.TemplateJoinExpr:\n+\t// case *hclsyntax.TemplateWrapExpr:",
        "comment_created_at": "2024-11-25T14:34:10+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Fixed in e7fe712c1d7d9b97c628a4f6eb9610e650ffe54b",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1741095962",
    "pr_number": 1911,
    "pr_file": "internal/configs/provider.go",
    "created_at": "2024-09-02T15:59:01+00:00",
    "commented_code": "MockResources []*MockResource\n }\n \n-func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n+// Provider represents a \"provider\" block in a module or file. A provider\n+// block is a provider configuration\n+type ProviderBlock struct {\n+\tProviderCommon\n+\tAliasExpr  hcl.Expression // nil if no alias set\n+\tAliasRange *hcl.Range     // nil if no alias set\n+\tForEach    hcl.Expression\n+}\n+\n+type Provider struct {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1741095962",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1911,
        "pr_file": "internal/configs/provider.go",
        "discussion_id": "1741095962",
        "commented_code": "@@ -44,7 +41,22 @@ type Provider struct {\n \tMockResources []*MockResource\n }\n \n-func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n+// Provider represents a \"provider\" block in a module or file. A provider\n+// block is a provider configuration\n+type ProviderBlock struct {\n+\tProviderCommon\n+\tAliasExpr  hcl.Expression // nil if no alias set\n+\tAliasRange *hcl.Range     // nil if no alias set\n+\tForEach    hcl.Expression\n+}\n+\n+type Provider struct {",
        "comment_created_at": "2024-09-02T15:59:01+00:00",
        "comment_author": "ollevche",
        "comment_body": "nit: it is useful to have a comment here describing when/how `Provider` struct is built",
        "pr_file_module": null
      },
      {
        "comment_id": "1741713483",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1911,
        "pr_file": "internal/configs/provider.go",
        "discussion_id": "1741095962",
        "commented_code": "@@ -44,7 +41,22 @@ type Provider struct {\n \tMockResources []*MockResource\n }\n \n-func decodeProviderBlock(block *hcl.Block) (*Provider, hcl.Diagnostics) {\n+// Provider represents a \"provider\" block in a module or file. A provider\n+// block is a provider configuration\n+type ProviderBlock struct {\n+\tProviderCommon\n+\tAliasExpr  hcl.Expression // nil if no alias set\n+\tAliasRange *hcl.Range     // nil if no alias set\n+\tForEach    hcl.Expression\n+}\n+\n+type Provider struct {",
        "comment_created_at": "2024-09-03T09:11:16+00:00",
        "comment_author": "Andrew-Hayes",
        "comment_body": "seems i lied when i ticked this \r\n\r\n`I have added meaningful comments to all exported functions, variables, and structs.`\r\n\r\n\ud83d\ude28 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647438337",
    "pr_number": 1728,
    "pr_file": "internal/lang/eval.go",
    "created_at": "2024-06-20T11:39:41+00:00",
    "commented_code": "// this type offers, but this is here for less common situations where the\n // caller will handle the evaluation calls itself.\n func (s *Scope) EvalContext(refs []*addrs.Reference) (*hcl.EvalContext, tfdiags.Diagnostics) {\n-\treturn s.evalContext(refs, s.SelfAddr)\n+\treturn s.evalContext(nil, refs, s.SelfAddr)\n }\n \n-func (s *Scope) evalContext(refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n+// EvalContextWithParent is exactly the same as EvalContext except the resulting hcl.EvalContext\n+// will be derived from the given parental hcl.EvalContext.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1647438337",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1728,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1647438337",
        "commented_code": "@@ -289,21 +289,32 @@ func (s *Scope) EvalReference(ref *addrs.Reference, wantType cty.Type) (cty.Valu\n // this type offers, but this is here for less common situations where the\n // caller will handle the evaluation calls itself.\n func (s *Scope) EvalContext(refs []*addrs.Reference) (*hcl.EvalContext, tfdiags.Diagnostics) {\n-\treturn s.evalContext(refs, s.SelfAddr)\n+\treturn s.evalContext(nil, refs, s.SelfAddr)\n }\n \n-func (s *Scope) evalContext(refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n+// EvalContextWithParent is exactly the same as EvalContext except the resulting hcl.EvalContext\n+// will be derived from the given parental hcl.EvalContext.",
        "comment_created_at": "2024-06-20T11:39:41+00:00",
        "comment_author": "RLRabinowitz",
        "comment_body": "nit: I wonder if we should have a few more words here explaining what this actually means and does in effect.\r\nEven `EvalContext`'s comments on `parent` and `NewChild` don't really explain what it means to use them",
        "pr_file_module": null
      },
      {
        "comment_id": "1648933499",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1728,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1647438337",
        "commented_code": "@@ -289,21 +289,32 @@ func (s *Scope) EvalReference(ref *addrs.Reference, wantType cty.Type) (cty.Valu\n // this type offers, but this is here for less common situations where the\n // caller will handle the evaluation calls itself.\n func (s *Scope) EvalContext(refs []*addrs.Reference) (*hcl.EvalContext, tfdiags.Diagnostics) {\n-\treturn s.evalContext(refs, s.SelfAddr)\n+\treturn s.evalContext(nil, refs, s.SelfAddr)\n }\n \n-func (s *Scope) evalContext(refs []*addrs.Reference, selfAddr addrs.Referenceable) (*hcl.EvalContext, tfdiags.Diagnostics) {\n+// EvalContextWithParent is exactly the same as EvalContext except the resulting hcl.EvalContext\n+// will be derived from the given parental hcl.EvalContext.",
        "comment_created_at": "2024-06-21T13:01:24+00:00",
        "comment_author": "ollevche",
        "comment_body": "I extended the comment to describe a little more and also named a few examples: [920b9ab](https://github.com/opentofu/opentofu/pull/1728/commits/920b9ab7ad00e3ec97644ed62bcb724cc900d2fa). ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1484054960",
    "pr_number": 1242,
    "pr_file": "cmd/tofu/main_test.go",
    "created_at": "2024-02-09T09:15:37+00:00",
    "commented_code": "mode := int(info.Mode().Perm())\n \texpectedMode := 0755\n+\tif runtime.GOOS == \"windows\" {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1484054960",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1242,
        "pr_file": "cmd/tofu/main_test.go",
        "discussion_id": "1484054960",
        "commented_code": "@@ -322,6 +323,9 @@ func TestMkConfigDir_new(t *testing.T) {\n \n \tmode := int(info.Mode().Perm())\n \texpectedMode := 0755\n+\tif runtime.GOOS == \"windows\" {",
        "comment_created_at": "2024-02-09T09:15:37+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I think for our future selves it may be best if we could document why this is how it is.\r\n\r\nWould you mind adding a small comment here explaining why its 777 and not 755 please?",
        "pr_file_module": null
      },
      {
        "comment_id": "1484717151",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1242,
        "pr_file": "cmd/tofu/main_test.go",
        "discussion_id": "1484054960",
        "commented_code": "@@ -322,6 +323,9 @@ func TestMkConfigDir_new(t *testing.T) {\n \n \tmode := int(info.Mode().Perm())\n \texpectedMode := 0755\n+\tif runtime.GOOS == \"windows\" {",
        "comment_created_at": "2024-02-09T19:21:56+00:00",
        "comment_author": "lettucemode",
        "comment_body": "No problem - comment added, lemme know if you were looking for something different.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1555419428",
    "pr_number": 1439,
    "pr_file": "internal/lang/functions_descriptions_test.go",
    "created_at": "2024-04-08T08:25:55+00:00",
    "commented_code": "allFunctions := scope.Functions()\n \n \t// plantimestamp isn't available with ConsoleMode: true\n-\texpectedFunctionCount := len(funcs.DescriptionList) - 1\n+\texpectedFunctionCount := (len(funcs.DescriptionList) - 1) * 2",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1555419428",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1439,
        "pr_file": "internal/lang/functions_descriptions_test.go",
        "discussion_id": "1555419428",
        "commented_code": "@@ -20,14 +21,14 @@ func TestFunctionDescriptions(t *testing.T) {\n \tallFunctions := scope.Functions()\n \n \t// plantimestamp isn't available with ConsoleMode: true\n-\texpectedFunctionCount := len(funcs.DescriptionList) - 1\n+\texpectedFunctionCount := (len(funcs.DescriptionList) - 1) * 2",
        "comment_created_at": "2024-04-08T08:25:55+00:00",
        "comment_author": "ollevche",
        "comment_body": "Do you mind leaving a note on why do we multiply by 2?",
        "pr_file_module": null
      },
      {
        "comment_id": "1555981719",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1439,
        "pr_file": "internal/lang/functions_descriptions_test.go",
        "discussion_id": "1555419428",
        "commented_code": "@@ -20,14 +21,14 @@ func TestFunctionDescriptions(t *testing.T) {\n \tallFunctions := scope.Functions()\n \n \t// plantimestamp isn't available with ConsoleMode: true\n-\texpectedFunctionCount := len(funcs.DescriptionList) - 1\n+\texpectedFunctionCount := (len(funcs.DescriptionList) - 1) * 2",
        "comment_created_at": "2024-04-08T14:52:45+00:00",
        "comment_author": "cam72cam",
        "comment_body": "We now list all builtin functions both without a namespace and under the core:: namespace",
        "pr_file_module": null
      },
      {
        "comment_id": "1556000827",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1439,
        "pr_file": "internal/lang/functions_descriptions_test.go",
        "discussion_id": "1555419428",
        "commented_code": "@@ -20,14 +21,14 @@ func TestFunctionDescriptions(t *testing.T) {\n \tallFunctions := scope.Functions()\n \n \t// plantimestamp isn't available with ConsoleMode: true\n-\texpectedFunctionCount := len(funcs.DescriptionList) - 1\n+\texpectedFunctionCount := (len(funcs.DescriptionList) - 1) * 2",
        "comment_created_at": "2024-04-08T15:02:53+00:00",
        "comment_author": "ollevche",
        "comment_body": "Yes, sure. I mean let's add a comment to the code to make it totally clear.",
        "pr_file_module": null
      }
    ]
  }
]