[
  {
    "discussion_id": "1954742049",
    "pr_number": 2511,
    "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
    "created_at": "2025-02-13T15:33:26+00:00",
    "commented_code": "+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1954742049",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954742049",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;",
        "comment_created_at": "2025-02-13T15:33:26+00:00",
        "comment_author": "ollevche",
        "comment_body": "Another comment about the migration path - what users actually need to do? I assume this is the following flow:\r\n1. Change the configuration to enable native locking\r\n2. `tofu apply`\r\n3. Change the configuration to remove dynamodb usage\r\n\r\nHowever, I am not sure if changes to the backend configuration would trigger state write. We need to test it additionally and document properly. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1955810515",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954742049",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;",
        "comment_created_at": "2025-02-14T09:20:47+00:00",
        "comment_author": "yottta",
        "comment_body": "Thanks. Added 7b88c6f84ddb90024fff88eec0fa7f8f3fa7ad6f",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957740958",
    "pr_number": 2511,
    "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
    "created_at": "2025-02-17T07:32:20+00:00",
    "commented_code": "+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.\n+\n+#### Migration paths\n+##### I have no locking enabled\n+In this case, the user can just add the new `use_lockfile=true` and run `tofu init -reconfigure`.\n+\n+##### I have DynamoDB locking enabled\n+In case the user is having DynamoDB enabled, there are two paths forward:\n+1. Add the new attribute `use_lockfile=true` and run `tofu init -reconfigure`\n+   * Later, remove the `dynamodb_table` attribute and run `tofu init -reconfigure` again\n+2. Add the new attribute `use_lockfile=true`, remove the `dynamodb_table` one and run `tofu init -reconfigure`\n+\n+OpenTofu recommends to have both locking mechanisms enabled for a limited amount of time and later remove the DynamoDB locking.\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking object was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking object is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates\n+> [!NOTE]\n+> Right now, when locking is enabled on DynamoDB, at the moment of updating the state object content, OpenTofu also writes an entry in DynamoDB with the MD5 sum of the state object.\n+> The reason is to be able to check the integrity of the state object from the S3 bucket in a future run. This is done by reading the digest from DynamoDB and comparing it with the ETag attribute of the state object from S3. \n+\n+By moving to the S3 based locking, OpenTofu will hold no other file for the digest of the state object, since the digest is kept in `ETag` header of the object.\n+More info about this topic can be found on the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html).\n+\n+But if both locks are enabled (`use_lockfile=true` and `dynamodb_table=<actual_table_name>`), the digest file will still be stored in DynamoDB.\n+\n+> [!WARNING]\n+> \n+> By enabling the S3 locking and disabling the DynamoDB one, the digest from DynamoDB will become stale. This means that if it is desired to go back to the DynamoDB locking, the digest needs to be cleaned up or updated in order to allow the content integrity check to work.\n+\n+### Open Questions\n+\n+* Do we want to provide the option to have the lock objects into another bucket? This will break the feature parity.\n+\n+### Future Considerations\n+If this feature will prove to have a high adoption rate, later, we might consider to deprecate the DynamoDB locking mechanism.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1957740958",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1957740958",
        "commented_code": "@@ -0,0 +1,131 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.\n+\n+#### Migration paths\n+##### I have no locking enabled\n+In this case, the user can just add the new `use_lockfile=true` and run `tofu init -reconfigure`.\n+\n+##### I have DynamoDB locking enabled\n+In case the user is having DynamoDB enabled, there are two paths forward:\n+1. Add the new attribute `use_lockfile=true` and run `tofu init -reconfigure`\n+   * Later, remove the `dynamodb_table` attribute and run `tofu init -reconfigure` again\n+2. Add the new attribute `use_lockfile=true`, remove the `dynamodb_table` one and run `tofu init -reconfigure`\n+\n+OpenTofu recommends to have both locking mechanisms enabled for a limited amount of time and later remove the DynamoDB locking.\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking object was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking object is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates\n+> [!NOTE]\n+> Right now, when locking is enabled on DynamoDB, at the moment of updating the state object content, OpenTofu also writes an entry in DynamoDB with the MD5 sum of the state object.\n+> The reason is to be able to check the integrity of the state object from the S3 bucket in a future run. This is done by reading the digest from DynamoDB and comparing it with the ETag attribute of the state object from S3. \n+\n+By moving to the S3 based locking, OpenTofu will hold no other file for the digest of the state object, since the digest is kept in `ETag` header of the object.\n+More info about this topic can be found on the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html).\n+\n+But if both locks are enabled (`use_lockfile=true` and `dynamodb_table=<actual_table_name>`), the digest file will still be stored in DynamoDB.\n+\n+> [!WARNING]\n+> \n+> By enabling the S3 locking and disabling the DynamoDB one, the digest from DynamoDB will become stale. This means that if it is desired to go back to the DynamoDB locking, the digest needs to be cleaned up or updated in order to allow the content integrity check to work.\n+\n+### Open Questions\n+\n+* Do we want to provide the option to have the lock objects into another bucket? This will break the feature parity.\n+\n+### Future Considerations\n+If this feature will prove to have a high adoption rate, later, we might consider to deprecate the DynamoDB locking mechanism. ",
        "comment_created_at": "2025-02-17T07:32:20+00:00",
        "comment_author": "Gogotchuri",
        "comment_body": "This reads as adoption rate by the OpenTofu users.\nWhen in actuality to deprecate the DynamoDB locking we would need the adoption of the locking feature by the majority of S3 compatible storage services.\nWe should highlight that explicitly.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957753156",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1957740958",
        "commented_code": "@@ -0,0 +1,131 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.\n+\n+#### Migration paths\n+##### I have no locking enabled\n+In this case, the user can just add the new `use_lockfile=true` and run `tofu init -reconfigure`.\n+\n+##### I have DynamoDB locking enabled\n+In case the user is having DynamoDB enabled, there are two paths forward:\n+1. Add the new attribute `use_lockfile=true` and run `tofu init -reconfigure`\n+   * Later, remove the `dynamodb_table` attribute and run `tofu init -reconfigure` again\n+2. Add the new attribute `use_lockfile=true`, remove the `dynamodb_table` one and run `tofu init -reconfigure`\n+\n+OpenTofu recommends to have both locking mechanisms enabled for a limited amount of time and later remove the DynamoDB locking.\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking object was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking object is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates\n+> [!NOTE]\n+> Right now, when locking is enabled on DynamoDB, at the moment of updating the state object content, OpenTofu also writes an entry in DynamoDB with the MD5 sum of the state object.\n+> The reason is to be able to check the integrity of the state object from the S3 bucket in a future run. This is done by reading the digest from DynamoDB and comparing it with the ETag attribute of the state object from S3. \n+\n+By moving to the S3 based locking, OpenTofu will hold no other file for the digest of the state object, since the digest is kept in `ETag` header of the object.\n+More info about this topic can be found on the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/checking-object-integrity.html).\n+\n+But if both locks are enabled (`use_lockfile=true` and `dynamodb_table=<actual_table_name>`), the digest file will still be stored in DynamoDB.\n+\n+> [!WARNING]\n+> \n+> By enabling the S3 locking and disabling the DynamoDB one, the digest from DynamoDB will become stale. This means that if it is desired to go back to the DynamoDB locking, the digest needs to be cleaned up or updated in order to allow the content integrity check to work.\n+\n+### Open Questions\n+\n+* Do we want to provide the option to have the lock objects into another bucket? This will break the feature parity.\n+\n+### Future Considerations\n+If this feature will prove to have a high adoption rate, later, we might consider to deprecate the DynamoDB locking mechanism. ",
        "comment_created_at": "2025-02-17T07:44:09+00:00",
        "comment_author": "yottta",
        "comment_body": "Good point! Thanks for the input. Fixed in 12adf6200ff60dfe12597285173e08990cf5b3cb",
        "pr_file_module": null
      }
    ]
  }
]