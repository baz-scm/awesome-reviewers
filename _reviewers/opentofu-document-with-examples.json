[
  {
    "discussion_id": "2060004025",
    "pr_number": 2712,
    "pr_file": "CHANGELOG.md",
    "created_at": "2025-04-25T10:43:35+00:00",
    "commented_code": "* When installing a provider from a source that offers a `.zip` archive of a provider package but that cannot also offer a signed set of official checksums for the provider, OpenTofu will now include its locally-verified zip archive checksum (`zh:` scheme) in the dependency lock file in addition to the package contents checksum (`h1:` checksum) previously recorded. This makes it more likely that a future reinstall of the same package from a different source will be verified successfully. ([#2656](https://github.com/opentofu/opentofu/pull/2656))\n * The `tofu show` command now supports a new explicit and extensible usage style, with `-state` and `-plan=PLANFILE` options. The old style with zero or one positional arguments is still supported for backward-compatibility. ([#2699](https://github.com/opentofu/opentofu/pull/2699))\n * `removed` now supports `lifecycle` and `provisioner` configuration. ([#2556](https://github.com/opentofu/opentofu/issues/2556))\n+* Added\"force-unlock\" support for the HTTP backend: ([#2381](https://github.com/opentofu/opentofu/pull/2381))",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2060004025",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2712,
        "pr_file": "CHANGELOG.md",
        "discussion_id": "2060004025",
        "commented_code": "@@ -40,6 +40,7 @@ ENHANCEMENTS:\n * When installing a provider from a source that offers a `.zip` archive of a provider package but that cannot also offer a signed set of official checksums for the provider, OpenTofu will now include its locally-verified zip archive checksum (`zh:` scheme) in the dependency lock file in addition to the package contents checksum (`h1:` checksum) previously recorded. This makes it more likely that a future reinstall of the same package from a different source will be verified successfully. ([#2656](https://github.com/opentofu/opentofu/pull/2656))\n * The `tofu show` command now supports a new explicit and extensible usage style, with `-state` and `-plan=PLANFILE` options. The old style with zero or one positional arguments is still supported for backward-compatibility. ([#2699](https://github.com/opentofu/opentofu/pull/2699))\n * `removed` now supports `lifecycle` and `provisioner` configuration. ([#2556](https://github.com/opentofu/opentofu/issues/2556))\n+* Added\"force-unlock\" support for the HTTP backend: ([#2381](https://github.com/opentofu/opentofu/pull/2381))",
        "comment_created_at": "2025-04-25T10:43:35+00:00",
        "comment_author": "ollevche",
        "comment_body": "We are not consistent with those, so it is more of nit. To follow other updates tone of voice:\r\n\r\n```suggestion\r\n* \"force-unlock\" option is now supported by the HTTP backend. ([#2381](https://github.com/opentofu/opentofu/pull/2381))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2056028755",
    "pr_number": 2157,
    "pr_file": "rfc/20241108-backends-metarfc.md",
    "created_at": "2025-04-23T13:13:43+00:00",
    "commented_code": "+# Meta-RFC: The future of Backends\n+\n+Related feature requests:\n+- [Backends as plugins](https://github.com/opentofu/opentofu/issues/382)\n+- [Add workspaces support to the HTTP backend](https://github.com/opentofu/opentofu/issues/317)\n+- [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960)\n+- [Conditionally load tfvars/tf file based on Workspace](https://github.com/opentofu/opentofu/issues/1053)\n+- Various requests for specific state storage implementations:\n+  - [Add git as backend](https://github.com/opentofu/opentofu/issues/1746)\n+  - [Add OpenBao as a remote state store](https://github.com/opentofu/opentofu/issues/907)\n+  - [OpenTofu Backend with OCI Object Storage](https://github.com/opentofu/opentofu/issues/1011)\n+  - [Add Huawei Cloud OBS remote storage backend support](https://github.com/opentofu/opentofu/issues/1343)\n+  - [Bring back swift backend for tfstate](https://github.com/opentofu/opentofu/issues/549)\n+  - (and numerous potential additions to already-implemented state storage backends)\n+\n+OpenTofu's concept of \"Backends\" has recieved a lot of feature requests and other feedback, and is also a part of the system that hasn't seen significant design investment for quite some time. There are lots of different changes we could potentially make, but it's unlikely that we can make all of the changes we'd want to make in a single increment. Decisions made to solve one problem are likely to constrain how we can solve other problems though, so a _purely_ incremental approach risks \"painting ourselves into a corner\".\n+\n+This document is a \"Meta-RFC\" that aims to describe holistically what we hope to achieve in the general area of \"backends\" -- which includes state storage but also other interesting features like remote operations -- so that we can more easily consider the implications of specific technical proposals we will make later in this area.\n+\n+This document therefore doesn't propose any specific technical details itself, but instead proposes the creation of other RFCs covering the details of different parts of the overall problem. This RFC is \"done\" once those RFCs are written and accepted, and then those other RFCs will represent the actual software implementation work.\n+\n+## Background\n+\n+The set of features that we now consider to belong to the \"backend\" concept evolved considerably during the life of OpenTofu's predecessor project, Terraform. This incremental development is likely responsible, at least in part, for some of the design details as currently implemented, and so the following sections describe some of that background in the hope of helping us answer questions such as:\n+\n+- Which complexity is necessary vs. accidental?\n+- Which behaviors are important to modern OpenTofu, vs. vestigial from obsolete earlier versions?\n+- How much freedom might we have to change these historical design decisions as we try to meet newer goals?\n+\n+### In the beginning: Local State Only\n+\n+In the very earliest versions, state was literally just a file written to local disk. The `-state` command line option specified where it should be read from and written to, though there was a default path `./terraform.tfstate` which would likely seem familiar to anyone who uses OpenTofu's current \"local\" backend.\n+\n+During this period the typical practice was to commit that file to version control along with the associated configuration files. This meant a rather awkward and unconventional workflow though, because it encouraged applying configuration changes before merging those changes into a shared VCS branch and then merging both the configuration changes and the state updates together. That undermines typical code review practices because by the time the configuration changes are being reviewed it's already in some sense \"too late\": the infrastructure changes implied by the configuration changes have already been applied anyway.\n+\n+### Initial Remote State Support\n+\n+Later versions introduced the idea of \"remote state\", where the system would read and write state snapshots from some separate network service, such as Amazon S3.\n+\n+The details of exactly how these features were used evolved slightly over several versions, but what all of the variants of this incarnation had in common is that remote state was configured exclusively with CLI commands, with no settings in the root module's `.tf` files.\n+\n+The final incarnation involved subcommands of the `remote` command, with `remote config` as the main entry point:\n+\n+```shellsession\n+$ terraform remote config -backend=s3 -backend-config=bucket=example -backend-config=path=example\n+```\n+\n+Under this iteration of the design, remote state was _in addition to_ local state: the system would still write state snapshots to disk, but would _also_ write them to the configured remote location. The default on-disk location when remote state was enabled switched to `.terraform/terraform.tfstate`, which modern users might recognize as what is now just OpenTofu's record of the currently-initialized backend, without any actual state snapshot information.\n+\n+Due to the configuration settings being exclusively on the command line, this particular design was highly error-prone. A typo in a `-backend-config` argument could cause future operations to start from an effectively-empty state. Worse still, if someone ran the `remote config` subcommand with remote state already enabled it would automatically overwrite the new location with latest snapshot from the previously-configured storage, and so it was a common mistake to overwrite the production environment's state snapshot with the staging environment's state snapshot when performing deployment gradually through a series of environments.\n+\n+This era is therefore where the concept of \"state lineage\" originated: it was primarily a way to catch that mistake of accidentally overwriting one environment's snapshot with the snapshot from another environment, by having the system first check whether the new snapshot seems like it was intended to be a successor to the one previously stored.\n+\n+What was called a \"backend\" in this era was _just_ for remote state storage, with no other capabilities. Selecting a backend internally meant selecting what in today's OpenTofu we call a \"state manager\", represented today as [the `statemgr.Storage` interface](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Storage).\n+\n+### Modern \"Backends\"\n+\n+Terraform v0.9 significantly evolved the remote state mechanism, introducing the configuration-driven approach that OpenTofu uses, mostly-unchanged, today:\n+\n+```hcl\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"example\"\n+    path   = \"example\"\n+  }\n+}\n+```\n+\n+The shift to using configuration blocks in the root module instead of command line arguments was the most significant user-facing change. This also ended the practice of storing state snapshots in both the remote location _and_ on local disk, replacing `.terraform/terraform.tfstate`'s former role with what is now just a confusing name for the file where OpenTofu \"remembers\" which backend configuration it's supposed to use in a specific working directory.\n+\n+This also came with a huge overhaul in the code of what exactly the term \"backend\" means and how they were architected. This new architecture was designed so that _in theory_ choosing a backend could select more than just state storage, including the possibility of \"remote operations\". However, in practice it would be quite some years before anything other than local operations was supported and so the initial design hadn't actually been proven adequate to support that; it took some further iteration to reach a design suitable for supporting remote operations too.\n+\n+Today's OpenTofu contains the result of the various later small iterations on this initial design.\n+\n+State storage is still handled using a largely-unchanged \"state manager\" API, although it later gained support for state locking and so is most often implemented as [`statemgr.Full`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Full) which extends `statemgr.Storage` with the extra locking capabilities.\n+\n+The current \"backend\" is an extra indirection, based on implementations of [`backend.Backend`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Backend). The backend is responsible for deciding which workspaces exist and for providing the \"state manager\" for any workspace it reports as existing.\n+\n+[`backend.Enhanced`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Enhanced) is an optional extension interface that is implemented by backends that know how to perform \"operations\", which is the backend API terminology for each of the individual main workflow CLI commands: `tofu plan`, `tofu apply`, etc. In practice there are only a small number of backends that actually implement this interface: `local`, `remote`, and `cloud`. If the configuration selects any other backend then what they are really doing is selecting the `local` backend but configured in a special way to delegate all of the workspace-related methods to some other `backend.Backend` implementation.\n+\n+```mermaid\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[local backend] -->|workspaces and state| S[s3 backend]\n+```\n+\n+When selecting one of the `remote` or `cloud` backends (which both do essentially the same thing), the situation gets more complicated. These backends both implement `backend.Enhanced` and so the CLI layer delegates to them directly to perform \"operations\". Both of these backends then use information from a remote API to choose between running the requested operation locally or remotely. If the decision is to run remotely then the backend essentially just asks a remote API to begin the operation and polls for it to complete. If the decision is to run _locally_ then these backends both delegate back to the \"local\" backend, but configured to use the original remote/cloud backend for workspaces and state, leading to the following situation:\n+\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[remote backend] -->|\"operations (delegated)\"| D[local backend] -->|workspaces and state| S[remote backend]\n+\n+The remote backend here is, in some sense, talking to itself indirectly through the local backend. This particular situation is often surprising for newcomers to this codebase, because the internal modelling of these concepts is so far divorced from how they are presented to end-users.\n+\n+Most of the feature requests we currently aim to address for backends relate to using the local backend with various different kinds of state storage. The remote operations features currently support only a single vendor's proprietary API, and so are perhaps not used as much as they might be if we had a vendor-agnostic, documented API as requested in [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960).\n+\n+## Proposal\n+\n+The following sections summarize some specific changes we propose to make, likely over the course of several releases, to gradually meet the various feature requests that motivated this proposal. We also hope to improve the overall technical design of \"backends\" gradually along the way.\n+\n+Each of the following sections is expected to lead to at leasst one detailed feature RFC of its own, but we hope that summarizing them all here in one place will help in gradually building toward a better system without earlier changes significantly impeding later changes.\n+\n+### State Storage as Plugins",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2056028755",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2157,
        "pr_file": "rfc/20241108-backends-metarfc.md",
        "discussion_id": "2056028755",
        "commented_code": "@@ -0,0 +1,269 @@\n+# Meta-RFC: The future of Backends\n+\n+Related feature requests:\n+- [Backends as plugins](https://github.com/opentofu/opentofu/issues/382)\n+- [Add workspaces support to the HTTP backend](https://github.com/opentofu/opentofu/issues/317)\n+- [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960)\n+- [Conditionally load tfvars/tf file based on Workspace](https://github.com/opentofu/opentofu/issues/1053)\n+- Various requests for specific state storage implementations:\n+  - [Add git as backend](https://github.com/opentofu/opentofu/issues/1746)\n+  - [Add OpenBao as a remote state store](https://github.com/opentofu/opentofu/issues/907)\n+  - [OpenTofu Backend with OCI Object Storage](https://github.com/opentofu/opentofu/issues/1011)\n+  - [Add Huawei Cloud OBS remote storage backend support](https://github.com/opentofu/opentofu/issues/1343)\n+  - [Bring back swift backend for tfstate](https://github.com/opentofu/opentofu/issues/549)\n+  - (and numerous potential additions to already-implemented state storage backends)\n+\n+OpenTofu's concept of \"Backends\" has recieved a lot of feature requests and other feedback, and is also a part of the system that hasn't seen significant design investment for quite some time. There are lots of different changes we could potentially make, but it's unlikely that we can make all of the changes we'd want to make in a single increment. Decisions made to solve one problem are likely to constrain how we can solve other problems though, so a _purely_ incremental approach risks \"painting ourselves into a corner\".\n+\n+This document is a \"Meta-RFC\" that aims to describe holistically what we hope to achieve in the general area of \"backends\" -- which includes state storage but also other interesting features like remote operations -- so that we can more easily consider the implications of specific technical proposals we will make later in this area.\n+\n+This document therefore doesn't propose any specific technical details itself, but instead proposes the creation of other RFCs covering the details of different parts of the overall problem. This RFC is \"done\" once those RFCs are written and accepted, and then those other RFCs will represent the actual software implementation work.\n+\n+## Background\n+\n+The set of features that we now consider to belong to the \"backend\" concept evolved considerably during the life of OpenTofu's predecessor project, Terraform. This incremental development is likely responsible, at least in part, for some of the design details as currently implemented, and so the following sections describe some of that background in the hope of helping us answer questions such as:\n+\n+- Which complexity is necessary vs. accidental?\n+- Which behaviors are important to modern OpenTofu, vs. vestigial from obsolete earlier versions?\n+- How much freedom might we have to change these historical design decisions as we try to meet newer goals?\n+\n+### In the beginning: Local State Only\n+\n+In the very earliest versions, state was literally just a file written to local disk. The `-state` command line option specified where it should be read from and written to, though there was a default path `./terraform.tfstate` which would likely seem familiar to anyone who uses OpenTofu's current \"local\" backend.\n+\n+During this period the typical practice was to commit that file to version control along with the associated configuration files. This meant a rather awkward and unconventional workflow though, because it encouraged applying configuration changes before merging those changes into a shared VCS branch and then merging both the configuration changes and the state updates together. That undermines typical code review practices because by the time the configuration changes are being reviewed it's already in some sense \"too late\": the infrastructure changes implied by the configuration changes have already been applied anyway.\n+\n+### Initial Remote State Support\n+\n+Later versions introduced the idea of \"remote state\", where the system would read and write state snapshots from some separate network service, such as Amazon S3.\n+\n+The details of exactly how these features were used evolved slightly over several versions, but what all of the variants of this incarnation had in common is that remote state was configured exclusively with CLI commands, with no settings in the root module's `.tf` files.\n+\n+The final incarnation involved subcommands of the `remote` command, with `remote config` as the main entry point:\n+\n+```shellsession\n+$ terraform remote config -backend=s3 -backend-config=bucket=example -backend-config=path=example\n+```\n+\n+Under this iteration of the design, remote state was _in addition to_ local state: the system would still write state snapshots to disk, but would _also_ write them to the configured remote location. The default on-disk location when remote state was enabled switched to `.terraform/terraform.tfstate`, which modern users might recognize as what is now just OpenTofu's record of the currently-initialized backend, without any actual state snapshot information.\n+\n+Due to the configuration settings being exclusively on the command line, this particular design was highly error-prone. A typo in a `-backend-config` argument could cause future operations to start from an effectively-empty state. Worse still, if someone ran the `remote config` subcommand with remote state already enabled it would automatically overwrite the new location with latest snapshot from the previously-configured storage, and so it was a common mistake to overwrite the production environment's state snapshot with the staging environment's state snapshot when performing deployment gradually through a series of environments.\n+\n+This era is therefore where the concept of \"state lineage\" originated: it was primarily a way to catch that mistake of accidentally overwriting one environment's snapshot with the snapshot from another environment, by having the system first check whether the new snapshot seems like it was intended to be a successor to the one previously stored.\n+\n+What was called a \"backend\" in this era was _just_ for remote state storage, with no other capabilities. Selecting a backend internally meant selecting what in today's OpenTofu we call a \"state manager\", represented today as [the `statemgr.Storage` interface](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Storage).\n+\n+### Modern \"Backends\"\n+\n+Terraform v0.9 significantly evolved the remote state mechanism, introducing the configuration-driven approach that OpenTofu uses, mostly-unchanged, today:\n+\n+```hcl\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"example\"\n+    path   = \"example\"\n+  }\n+}\n+```\n+\n+The shift to using configuration blocks in the root module instead of command line arguments was the most significant user-facing change. This also ended the practice of storing state snapshots in both the remote location _and_ on local disk, replacing `.terraform/terraform.tfstate`'s former role with what is now just a confusing name for the file where OpenTofu \"remembers\" which backend configuration it's supposed to use in a specific working directory.\n+\n+This also came with a huge overhaul in the code of what exactly the term \"backend\" means and how they were architected. This new architecture was designed so that _in theory_ choosing a backend could select more than just state storage, including the possibility of \"remote operations\". However, in practice it would be quite some years before anything other than local operations was supported and so the initial design hadn't actually been proven adequate to support that; it took some further iteration to reach a design suitable for supporting remote operations too.\n+\n+Today's OpenTofu contains the result of the various later small iterations on this initial design.\n+\n+State storage is still handled using a largely-unchanged \"state manager\" API, although it later gained support for state locking and so is most often implemented as [`statemgr.Full`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Full) which extends `statemgr.Storage` with the extra locking capabilities.\n+\n+The current \"backend\" is an extra indirection, based on implementations of [`backend.Backend`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Backend). The backend is responsible for deciding which workspaces exist and for providing the \"state manager\" for any workspace it reports as existing.\n+\n+[`backend.Enhanced`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Enhanced) is an optional extension interface that is implemented by backends that know how to perform \"operations\", which is the backend API terminology for each of the individual main workflow CLI commands: `tofu plan`, `tofu apply`, etc. In practice there are only a small number of backends that actually implement this interface: `local`, `remote`, and `cloud`. If the configuration selects any other backend then what they are really doing is selecting the `local` backend but configured in a special way to delegate all of the workspace-related methods to some other `backend.Backend` implementation.\n+\n+```mermaid\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[local backend] -->|workspaces and state| S[s3 backend]\n+```\n+\n+When selecting one of the `remote` or `cloud` backends (which both do essentially the same thing), the situation gets more complicated. These backends both implement `backend.Enhanced` and so the CLI layer delegates to them directly to perform \"operations\". Both of these backends then use information from a remote API to choose between running the requested operation locally or remotely. If the decision is to run remotely then the backend essentially just asks a remote API to begin the operation and polls for it to complete. If the decision is to run _locally_ then these backends both delegate back to the \"local\" backend, but configured to use the original remote/cloud backend for workspaces and state, leading to the following situation:\n+\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[remote backend] -->|\"operations (delegated)\"| D[local backend] -->|workspaces and state| S[remote backend]\n+\n+The remote backend here is, in some sense, talking to itself indirectly through the local backend. This particular situation is often surprising for newcomers to this codebase, because the internal modelling of these concepts is so far divorced from how they are presented to end-users.\n+\n+Most of the feature requests we currently aim to address for backends relate to using the local backend with various different kinds of state storage. The remote operations features currently support only a single vendor's proprietary API, and so are perhaps not used as much as they might be if we had a vendor-agnostic, documented API as requested in [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960).\n+\n+## Proposal\n+\n+The following sections summarize some specific changes we propose to make, likely over the course of several releases, to gradually meet the various feature requests that motivated this proposal. We also hope to improve the overall technical design of \"backends\" gradually along the way.\n+\n+Each of the following sections is expected to lead to at leasst one detailed feature RFC of its own, but we hope that summarizing them all here in one place will help in gradually building toward a better system without earlier changes significantly impeding later changes.\n+\n+### State Storage as Plugins",
        "comment_created_at": "2025-04-23T13:13:43+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I wonder if we require a small bit of background here on the usage of the word `plugin` vs the usage of the word `provider` and how that relates to backends as plugins. \r\n\r\nThis will help us understand if we're pitching something new, or something as part of the provider SDK/framework etc.",
        "pr_file_module": null
      },
      {
        "comment_id": "2056300291",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2157,
        "pr_file": "rfc/20241108-backends-metarfc.md",
        "discussion_id": "2056028755",
        "commented_code": "@@ -0,0 +1,269 @@\n+# Meta-RFC: The future of Backends\n+\n+Related feature requests:\n+- [Backends as plugins](https://github.com/opentofu/opentofu/issues/382)\n+- [Add workspaces support to the HTTP backend](https://github.com/opentofu/opentofu/issues/317)\n+- [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960)\n+- [Conditionally load tfvars/tf file based on Workspace](https://github.com/opentofu/opentofu/issues/1053)\n+- Various requests for specific state storage implementations:\n+  - [Add git as backend](https://github.com/opentofu/opentofu/issues/1746)\n+  - [Add OpenBao as a remote state store](https://github.com/opentofu/opentofu/issues/907)\n+  - [OpenTofu Backend with OCI Object Storage](https://github.com/opentofu/opentofu/issues/1011)\n+  - [Add Huawei Cloud OBS remote storage backend support](https://github.com/opentofu/opentofu/issues/1343)\n+  - [Bring back swift backend for tfstate](https://github.com/opentofu/opentofu/issues/549)\n+  - (and numerous potential additions to already-implemented state storage backends)\n+\n+OpenTofu's concept of \"Backends\" has recieved a lot of feature requests and other feedback, and is also a part of the system that hasn't seen significant design investment for quite some time. There are lots of different changes we could potentially make, but it's unlikely that we can make all of the changes we'd want to make in a single increment. Decisions made to solve one problem are likely to constrain how we can solve other problems though, so a _purely_ incremental approach risks \"painting ourselves into a corner\".\n+\n+This document is a \"Meta-RFC\" that aims to describe holistically what we hope to achieve in the general area of \"backends\" -- which includes state storage but also other interesting features like remote operations -- so that we can more easily consider the implications of specific technical proposals we will make later in this area.\n+\n+This document therefore doesn't propose any specific technical details itself, but instead proposes the creation of other RFCs covering the details of different parts of the overall problem. This RFC is \"done\" once those RFCs are written and accepted, and then those other RFCs will represent the actual software implementation work.\n+\n+## Background\n+\n+The set of features that we now consider to belong to the \"backend\" concept evolved considerably during the life of OpenTofu's predecessor project, Terraform. This incremental development is likely responsible, at least in part, for some of the design details as currently implemented, and so the following sections describe some of that background in the hope of helping us answer questions such as:\n+\n+- Which complexity is necessary vs. accidental?\n+- Which behaviors are important to modern OpenTofu, vs. vestigial from obsolete earlier versions?\n+- How much freedom might we have to change these historical design decisions as we try to meet newer goals?\n+\n+### In the beginning: Local State Only\n+\n+In the very earliest versions, state was literally just a file written to local disk. The `-state` command line option specified where it should be read from and written to, though there was a default path `./terraform.tfstate` which would likely seem familiar to anyone who uses OpenTofu's current \"local\" backend.\n+\n+During this period the typical practice was to commit that file to version control along with the associated configuration files. This meant a rather awkward and unconventional workflow though, because it encouraged applying configuration changes before merging those changes into a shared VCS branch and then merging both the configuration changes and the state updates together. That undermines typical code review practices because by the time the configuration changes are being reviewed it's already in some sense \"too late\": the infrastructure changes implied by the configuration changes have already been applied anyway.\n+\n+### Initial Remote State Support\n+\n+Later versions introduced the idea of \"remote state\", where the system would read and write state snapshots from some separate network service, such as Amazon S3.\n+\n+The details of exactly how these features were used evolved slightly over several versions, but what all of the variants of this incarnation had in common is that remote state was configured exclusively with CLI commands, with no settings in the root module's `.tf` files.\n+\n+The final incarnation involved subcommands of the `remote` command, with `remote config` as the main entry point:\n+\n+```shellsession\n+$ terraform remote config -backend=s3 -backend-config=bucket=example -backend-config=path=example\n+```\n+\n+Under this iteration of the design, remote state was _in addition to_ local state: the system would still write state snapshots to disk, but would _also_ write them to the configured remote location. The default on-disk location when remote state was enabled switched to `.terraform/terraform.tfstate`, which modern users might recognize as what is now just OpenTofu's record of the currently-initialized backend, without any actual state snapshot information.\n+\n+Due to the configuration settings being exclusively on the command line, this particular design was highly error-prone. A typo in a `-backend-config` argument could cause future operations to start from an effectively-empty state. Worse still, if someone ran the `remote config` subcommand with remote state already enabled it would automatically overwrite the new location with latest snapshot from the previously-configured storage, and so it was a common mistake to overwrite the production environment's state snapshot with the staging environment's state snapshot when performing deployment gradually through a series of environments.\n+\n+This era is therefore where the concept of \"state lineage\" originated: it was primarily a way to catch that mistake of accidentally overwriting one environment's snapshot with the snapshot from another environment, by having the system first check whether the new snapshot seems like it was intended to be a successor to the one previously stored.\n+\n+What was called a \"backend\" in this era was _just_ for remote state storage, with no other capabilities. Selecting a backend internally meant selecting what in today's OpenTofu we call a \"state manager\", represented today as [the `statemgr.Storage` interface](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Storage).\n+\n+### Modern \"Backends\"\n+\n+Terraform v0.9 significantly evolved the remote state mechanism, introducing the configuration-driven approach that OpenTofu uses, mostly-unchanged, today:\n+\n+```hcl\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"example\"\n+    path   = \"example\"\n+  }\n+}\n+```\n+\n+The shift to using configuration blocks in the root module instead of command line arguments was the most significant user-facing change. This also ended the practice of storing state snapshots in both the remote location _and_ on local disk, replacing `.terraform/terraform.tfstate`'s former role with what is now just a confusing name for the file where OpenTofu \"remembers\" which backend configuration it's supposed to use in a specific working directory.\n+\n+This also came with a huge overhaul in the code of what exactly the term \"backend\" means and how they were architected. This new architecture was designed so that _in theory_ choosing a backend could select more than just state storage, including the possibility of \"remote operations\". However, in practice it would be quite some years before anything other than local operations was supported and so the initial design hadn't actually been proven adequate to support that; it took some further iteration to reach a design suitable for supporting remote operations too.\n+\n+Today's OpenTofu contains the result of the various later small iterations on this initial design.\n+\n+State storage is still handled using a largely-unchanged \"state manager\" API, although it later gained support for state locking and so is most often implemented as [`statemgr.Full`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/states/statemgr#Full) which extends `statemgr.Storage` with the extra locking capabilities.\n+\n+The current \"backend\" is an extra indirection, based on implementations of [`backend.Backend`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Backend). The backend is responsible for deciding which workspaces exist and for providing the \"state manager\" for any workspace it reports as existing.\n+\n+[`backend.Enhanced`](https://pkg.go.dev/github.com/opentofu/opentofu@v1.8.5/internal/backend#Enhanced) is an optional extension interface that is implemented by backends that know how to perform \"operations\", which is the backend API terminology for each of the individual main workflow CLI commands: `tofu plan`, `tofu apply`, etc. In practice there are only a small number of backends that actually implement this interface: `local`, `remote`, and `cloud`. If the configuration selects any other backend then what they are really doing is selecting the `local` backend but configured in a special way to delegate all of the workspace-related methods to some other `backend.Backend` implementation.\n+\n+```mermaid\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[local backend] -->|workspaces and state| S[s3 backend]\n+```\n+\n+When selecting one of the `remote` or `cloud` backends (which both do essentially the same thing), the situation gets more complicated. These backends both implement `backend.Enhanced` and so the CLI layer delegates to them directly to perform \"operations\". Both of these backends then use information from a remote API to choose between running the requested operation locally or remotely. If the decision is to run remotely then the backend essentially just asks a remote API to begin the operation and polls for it to complete. If the decision is to run _locally_ then these backends both delegate back to the \"local\" backend, but configured to use the original remote/cloud backend for workspaces and state, leading to the following situation:\n+\n+flowchart LR\n+    CLI[OpenTofu CLI] -->|operations| L[remote backend] -->|\"operations (delegated)\"| D[local backend] -->|workspaces and state| S[remote backend]\n+\n+The remote backend here is, in some sense, talking to itself indirectly through the local backend. This particular situation is often surprising for newcomers to this codebase, because the internal modelling of these concepts is so far divorced from how they are presented to end-users.\n+\n+Most of the feature requests we currently aim to address for backends relate to using the local backend with various different kinds of state storage. The remote operations features currently support only a single vendor's proprietary API, and so are perhaps not used as much as they might be if we had a vendor-agnostic, documented API as requested in [Document how someone could implement their own cloud backend](https://github.com/opentofu/opentofu/issues/960).\n+\n+## Proposal\n+\n+The following sections summarize some specific changes we propose to make, likely over the course of several releases, to gradually meet the various feature requests that motivated this proposal. We also hope to improve the overall technical design of \"backends\" gradually along the way.\n+\n+Each of the following sections is expected to lead to at leasst one detailed feature RFC of its own, but we hope that summarizing them all here in one place will help in gradually building toward a better system without earlier changes significantly impeding later changes.\n+\n+### State Storage as Plugins",
        "comment_created_at": "2025-04-23T15:19:42+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "As things currently stand, there are two kinds of plugins in OpenTofu: provider plugins and provisioner plugins. \r\n\r\nProvisioner plugins are largely a legacy system preserved as a concession for those who need to use some of the previously-builtin provisioners that were removed in an earlier release. None of the automatic installation, registry protocol, and signature-checking infrastructure that we're accustomed to for provider plugins are available for the legacy provisioner plugins.\r\n\r\nSo I think it's fair to say that _as we currently stand_, \"plugin\" and \"provider\" are _effectively_ synonymous, aside from some little callout boxes in a few spots that acknowledge the legacy provisioner plugin support such as on [Managing Plugins](https://opentofu.org/docs/cli/plugins/).\r\n\r\nThe text below intentionally asks us to reflect on whether we want that to continue to be true. There are some definite advantages on the OpenTofu CLI side in being able to reuse our existing plugin distribution infrastructure and \"just\" add a new optional extension protocol to the plugins, but we've yet to research what it would look like for a provider developer to implement an additional optional protocol alongside the provider protocol if they are using the currently-prominent libraries for plugin development; the author of an RFC on this topic would presumably investigate whether it's possible to use those libraries in conjunction with a second gRPC service that's implemented in a separate library.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1888687033",
    "pr_number": 2267,
    "pr_file": "rfc/20241206-provider-install-from-oci-registry.md",
    "created_at": "2024-12-17T15:14:45+00:00",
    "commented_code": "+# Provider Package Installation from OCI Registries\n+\n+Issue: [#308](https://github.com/opentofu/opentofu/issues/308)\n+\n+The associated issue represents support for using container image repositories in registries as defined by [The OpenContainers Distribution specification v1.0.0](https://specs.opencontainers.org/distribution-spec/?v=v1.0.0) as an alternative supported installation source location for OpenTofu module and provider packages.\n+\n+Module and provider installation in OpenTofu have enough differences that we intend to treat most of the relevant details as separate RFCs for each case, and this particular document is focused on the provider-package-specific details. It relies on some other proposals that describe some details that are common across both provider and module package installation.\n+\n+Today's OpenTofu supports provider installation by a number of different OpenTofu-specific strategies:\n+\n+- Direct installation from a provider's origin registry: The default behavior is to attempt to use the hostname given in the provider's source address (which defaults to `registry.opentofu.org` if not specified) with [the OpenTofu Provider Registry Protocol](https://opentofu.org/docs/internals/provider-registry-protocol/).\n+\n+    This makes a good default behavior because it requires no special configuration on the part of the user. The hostname in the provider source address gives us enough information to self-configure the registry client using [OpenTofu's remote service discovery protocol](https://opentofu.org/docs/internals/remote-service-discovery/).\n+\n+    However, it's not sufficient for all cases because it assumes that the client machine running OpenTofu can make a direct network connection to a server running at whatever hostname the provider source address belongs to. This is sometimes either technically impossible (for air-gapped systems) or prohibited by local policy despite being technically possible.\n+\n+    This is the only case where the hostname in the provider source address is used as a location to contact. In all other cases we use hostnames only to delegate the management of the top-level of our provider source address namespace to the domain name system.\n+\n+- Installing from a mirror server configured by the user: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a different server implementing [OpenTofu's Provider Mirror Protocol](https://opentofu.org/docs/internals/provider-network-mirror-protocol/).\n+\n+    The key difference between the Registry protocol and the Mirror protocol is that the latter includes the hostname from the provider source address as part of its requests, and so a single mirror can host packages belonging to many different hostnames at once, whereas a registry can only host packages belonging to its own hostname.\n+\n+- Treating a directory in the local filesystem as a mirror: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a directory in their local filesystem, containing copies of provider packages following one of two documented layouts.\n+\n+    This is similar to a network mirror but avoids the need to run an additional network service, as long as the mirrored packages are only needed on one system or they can be copied onto every system where they will be needed.\n+\n+The introduction of OCI Distribution repositories as a new package source is intended to meet similar goals as for the \"direct\" and \"network mirror\" strategies, but to achieve those goals by reusing existing registry infrastructure already deployed for the distribution of Docker-style container images. This means that those who are already invested in the OCI ecosystem can make further use of services they have already purchased or deployed, and that provider developers can potentially use existing container image hosting infrastructure as the primary distribution vehicle for their own providers, instead of relying on the OpenTofu-maintained registry or on some other OpenTofu-specific registry service.\n+\n+## Proposed Solution\n+\n+This proposal includes three different variations of using OCI registry infrastructure for provider package distribution, which will be described in later sections.\n+\n+What they all have in common is:\n+- Some means for translating an OpenTofu provider source address, such as `registry.opentofu.org/apparentlymart/assume`, into an OCI distribution repository address, which varies between the three methods.\n+- A convention for describing provider release versions as OCI distribution \"tags\" whose names follow a specified syntax.\n+- A convention for mapping OpenTofu platform identifiers like `linux_amd64` onto the common conventions for multi-platform container image manifests.\n+- A convention for the expected manifest and layer archive formats used to describe a single provider package, giving the filesystem contents needed to run a single version of a provider on a single platform.\n+- A way to provide OpenTofu with any credentials needed to interact with the registry that hosts the selected OCI repository.\n+\n+Some of these concerns have considerable overlap with the separate goal of installing _module packages_ from OCI registries, and so this proposal builds on two upstream proposals that are shared between those two problems:\n+\n+- [OpenTofu packages in OCI Registries](./20241206-packages-in-oci-registries.md): Describes the general conventions OpenTofu follows in interpreting the content of an OCI distribution repository as an OpenTofu-specific package format. This proposal specifies a specific application of those conventions to provider packages.\n+- [OCI Distribution Registry Authentication Configuration](./20241206-oci-registry-auth-config.md): Describes a cross-cutting approach to configuring OpenTofu to authenticate to OCI registries. This proposal relies on the preconfigured OCI Distribution client produced by that proposal, expecting that it will encapsulate all of the registry-authentication-related concerns, and so we will not discuss registry authentication any further in this document.\n+\n+### Provider Packages as OCI distribution objects\n+\n+Later sections will describe some different ways OpenTofu can translate provider source addresses into OCI distribution repository addresses, but a key goal of this proposal is for all of them to share a single convention for how that repository is used once selected, and that single convention is the focus of this section.\n+\n+Provider packages specialize [our general OCI repository conventions](./20241206-packages-in-oci-registries.md) in the following ways:\n+\n+- Each repository tag that is to be treated as a provider version must refer to a _multi-platform_ manifest, which describes in turn one child manifest for each target platform the provider supports where each describes a single container image.\n+- For the leaf manifests describing individual versions for individual platforms, the `org.opentofu.package-type` label **must** be set to `provider_binary`, so that OpenTofu can unambigously reject attempts to install generic container images or incompatible kinds of OpenTofu-specific packages with a clear error message.\n+- The union of all layers of each leaf image must represent a filesystem directory with the same content as an OpenTofu provider package distributed by other means. In particular, for a provider whose source address is `example.com/namespace/name` the resulting directory must contain an executable whose name begins with the prefix `terraform-provider-name`, which must be marked in the appropriate way to make it executable on the target platform. (e.g. executable permission on Unix-like platforms, or a `.exe` filename suffix for Windows)\n+\n+    If the same provider release is also being distributed under the same source address via other installation methods then the set of file paths in the resulting directory and the content of each file must exactly match the content of the packages delivered by the other methods, because OpenTofu will expect them all to match the same package checksums recorded in the dependency lock file.\n+\n+Those producing provider packages as container images may use any tools they wish as long as they produce manifests and layers consistent with OpenTofu's expectations.\n+\n+One possible approach is to use Docker CLI's \"buildx\" plugin to build multiple container images with a surrounding multi-platform manifest. If the provider's build process already produces `./dist/PLATFORM` directories containing the content of each platform's release package then the following `Dockerfile` would cause `docker buildx` to gather them all beneath a multi-platform manifest:\n+\n+```dockerfile\n+FROM scratch\n+LABEL org.opentofu.package-type=\"provider_binary\"\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+ARG TARGETOS\n+ARG TARGETARCH\n+COPY ./dist/${TARGETOS}_${TARGETARCH}/* /\n+```\n+\n+The following command would then build a selection of images and generate the multi-platform manifest for a specified set of platforms:\n+\n+```shell\n+docker buildx build \\\n+  --platform linux/amd64,darwin/amd64,windows/amd64,windows/arm64,linux/arm64,darwin/arm64 \\\n+  --tag example.com/namespace/opentofu-provider-name:1.0.0\n+```\n+\n+This would then build a multi-platform manifest suitable to be pushed to an OCI repository with the address `example.com/namespace/opentofu-provider-name`, under the tag `1.0.0`, using `docker push` as normal.\n+\n+This particular strategy assumes that the developer already used Go's support for cross-compilation, or some other non-Docker-specific strategy, to build native executables for each of the specified platforms into the subdirectories of `dist`. Since the `Dockerfile` only uses `COPY`, it's reusable without any virtualization or emulation to build packages for any supported platform regardless of what platform the container runtime used for building is running on.\n+\n+### \"Magic\" inference of an OCI repository address\n+\n+The first of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a \"magic\" mapping strategy based on a special reserved hostname suffix.\n+\n+The OpenTofu project will acquire a short, mnemonic domain to reserve for this mechanism. This RFC does not yet propose a specific domain, so for now we'll use `oci.opentofu.org` as a placeholder. Although that name would technically work, it's likely too long for ergonomic use and so should be replaced in a later version of this RFC once we've already purchased the intended domain.\n+\n+As a special case in the provider installation behavior, any provider belonging to a hostname that ends with the suffix `.oci.opentofu.org` will skip the normal service discovery process and will instead use a hard-coded internal mapping as follows:\n+\n+1. Trim the `.oci.opentofu.org` suffix from the hostname to obtain the OCI registry domain name.\n+2. Use the \"namespace\" portion of the provider source address, followed by the fixed delimiter `/opentofu-provider-`, and then the \"type\" portion of the provider source address as the repository name under the selected registry domain name.\n+\n+For example, the provider source address `example.com.oci.opentofu.org/foo/bar` would automatically resolve to the OCI repository address `example.com/foo/opentofu-provider-bar`.\n+\n+This particular scheme is intended for anyone who wants to use a pre-existing OCI registry to host packages for a provider without needing to set up any special OpenTofu-specific additions aside from following the designated naming scheme for the registry name. The specified repository naming scheme intentionally uses only two segments while using a fixed prefix for maximum compatibility with the naming restrictions of commonly-available public registry implementations while minimizing conflicts with non-OpenTofu-provider-related uses of those registries.\n+\n+### OCI Registry as an implementation detail of \"direct\" installation\n+\n+The second of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address uses [OpenTofu's existing service discovery mechanism](https://opentofu.org/docs/internals/remote-service-discovery/) to allow the deployment of something that behaves much like a normal OpenTofu provider registry, but uses the OCI distribution protocol instead of the OpenTofu-specific registry protocol _as a hidden implementation detail_. This compromise requires a small amount of OpenTofu-specific protocol implementation alongside a generic OCI registry, in return for hiding the implementation detail that an OCI registry is being used.\n+\n+The owner of a hostname can deploy a service discovery document which announces the new service identifier `oci-providers.v1`, with the associated value being a template for constructing an OCI repository address from the \"namespace\" and \"type\" portions of the provider source address using [RFC 6570 URI Template](https://www.rfc-editor.org/rfc/rfc6570) (level 1) syntax, which in practice means that `{namespace}` and `{type}` get substituted for the values from the provider source address:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"example.com/opentofu-providers/{namespace}/{type}\"\n+}\n+```\n+\n+If the service discovery document for `example.net` included the definition shown above, then the provider source address `example.net/foo/bar` would be translated to the OCI Distribution repository address `example.com/opentofu-providers/foo/bar`.\n+\n+This mechanism is essentially a more explicit generalization of the \"magic\" method from the previous section, allowing the owner of a hostname to customize exactly how providers belonging to that hostname are to be mapped onto OCI repository addresses.\n+\n+Note that there is no requirement that the provider source address hostname match the OCI registry domain name: it's possible for someone to project any hostname they own onto repositories in an OCI Distribution registry run by someone else if they want to. For example, the owner of `example.org` could announce the following in its service discovery document:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/example-org-otf-providers/{namespace}-{type}\"\n+}\n+```\n+\n+...and then they can rely on this third-party OCI registry implementation as an implementation detail, while using generic source addresses like `example.org/foo/bar` (mapping to `ghcr.io/example-org-otf-providers/foo-bar`) in all of their OpenTofu modules to reduce te lock-in to any specific OCI registry vendor.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1888687033",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2267,
        "pr_file": "rfc/20241206-provider-install-from-oci-registry.md",
        "discussion_id": "1888687033",
        "commented_code": "@@ -0,0 +1,249 @@\n+# Provider Package Installation from OCI Registries\n+\n+Issue: [#308](https://github.com/opentofu/opentofu/issues/308)\n+\n+The associated issue represents support for using container image repositories in registries as defined by [The OpenContainers Distribution specification v1.0.0](https://specs.opencontainers.org/distribution-spec/?v=v1.0.0) as an alternative supported installation source location for OpenTofu module and provider packages.\n+\n+Module and provider installation in OpenTofu have enough differences that we intend to treat most of the relevant details as separate RFCs for each case, and this particular document is focused on the provider-package-specific details. It relies on some other proposals that describe some details that are common across both provider and module package installation.\n+\n+Today's OpenTofu supports provider installation by a number of different OpenTofu-specific strategies:\n+\n+- Direct installation from a provider's origin registry: The default behavior is to attempt to use the hostname given in the provider's source address (which defaults to `registry.opentofu.org` if not specified) with [the OpenTofu Provider Registry Protocol](https://opentofu.org/docs/internals/provider-registry-protocol/).\n+\n+    This makes a good default behavior because it requires no special configuration on the part of the user. The hostname in the provider source address gives us enough information to self-configure the registry client using [OpenTofu's remote service discovery protocol](https://opentofu.org/docs/internals/remote-service-discovery/).\n+\n+    However, it's not sufficient for all cases because it assumes that the client machine running OpenTofu can make a direct network connection to a server running at whatever hostname the provider source address belongs to. This is sometimes either technically impossible (for air-gapped systems) or prohibited by local policy despite being technically possible.\n+\n+    This is the only case where the hostname in the provider source address is used as a location to contact. In all other cases we use hostnames only to delegate the management of the top-level of our provider source address namespace to the domain name system.\n+\n+- Installing from a mirror server configured by the user: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a different server implementing [OpenTofu's Provider Mirror Protocol](https://opentofu.org/docs/internals/provider-network-mirror-protocol/).\n+\n+    The key difference between the Registry protocol and the Mirror protocol is that the latter includes the hostname from the provider source address as part of its requests, and so a single mirror can host packages belonging to many different hostnames at once, whereas a registry can only host packages belonging to its own hostname.\n+\n+- Treating a directory in the local filesystem as a mirror: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a directory in their local filesystem, containing copies of provider packages following one of two documented layouts.\n+\n+    This is similar to a network mirror but avoids the need to run an additional network service, as long as the mirrored packages are only needed on one system or they can be copied onto every system where they will be needed.\n+\n+The introduction of OCI Distribution repositories as a new package source is intended to meet similar goals as for the \"direct\" and \"network mirror\" strategies, but to achieve those goals by reusing existing registry infrastructure already deployed for the distribution of Docker-style container images. This means that those who are already invested in the OCI ecosystem can make further use of services they have already purchased or deployed, and that provider developers can potentially use existing container image hosting infrastructure as the primary distribution vehicle for their own providers, instead of relying on the OpenTofu-maintained registry or on some other OpenTofu-specific registry service.\n+\n+## Proposed Solution\n+\n+This proposal includes three different variations of using OCI registry infrastructure for provider package distribution, which will be described in later sections.\n+\n+What they all have in common is:\n+- Some means for translating an OpenTofu provider source address, such as `registry.opentofu.org/apparentlymart/assume`, into an OCI distribution repository address, which varies between the three methods.\n+- A convention for describing provider release versions as OCI distribution \"tags\" whose names follow a specified syntax.\n+- A convention for mapping OpenTofu platform identifiers like `linux_amd64` onto the common conventions for multi-platform container image manifests.\n+- A convention for the expected manifest and layer archive formats used to describe a single provider package, giving the filesystem contents needed to run a single version of a provider on a single platform.\n+- A way to provide OpenTofu with any credentials needed to interact with the registry that hosts the selected OCI repository.\n+\n+Some of these concerns have considerable overlap with the separate goal of installing _module packages_ from OCI registries, and so this proposal builds on two upstream proposals that are shared between those two problems:\n+\n+- [OpenTofu packages in OCI Registries](./20241206-packages-in-oci-registries.md): Describes the general conventions OpenTofu follows in interpreting the content of an OCI distribution repository as an OpenTofu-specific package format. This proposal specifies a specific application of those conventions to provider packages.\n+- [OCI Distribution Registry Authentication Configuration](./20241206-oci-registry-auth-config.md): Describes a cross-cutting approach to configuring OpenTofu to authenticate to OCI registries. This proposal relies on the preconfigured OCI Distribution client produced by that proposal, expecting that it will encapsulate all of the registry-authentication-related concerns, and so we will not discuss registry authentication any further in this document.\n+\n+### Provider Packages as OCI distribution objects\n+\n+Later sections will describe some different ways OpenTofu can translate provider source addresses into OCI distribution repository addresses, but a key goal of this proposal is for all of them to share a single convention for how that repository is used once selected, and that single convention is the focus of this section.\n+\n+Provider packages specialize [our general OCI repository conventions](./20241206-packages-in-oci-registries.md) in the following ways:\n+\n+- Each repository tag that is to be treated as a provider version must refer to a _multi-platform_ manifest, which describes in turn one child manifest for each target platform the provider supports where each describes a single container image.\n+- For the leaf manifests describing individual versions for individual platforms, the `org.opentofu.package-type` label **must** be set to `provider_binary`, so that OpenTofu can unambigously reject attempts to install generic container images or incompatible kinds of OpenTofu-specific packages with a clear error message.\n+- The union of all layers of each leaf image must represent a filesystem directory with the same content as an OpenTofu provider package distributed by other means. In particular, for a provider whose source address is `example.com/namespace/name` the resulting directory must contain an executable whose name begins with the prefix `terraform-provider-name`, which must be marked in the appropriate way to make it executable on the target platform. (e.g. executable permission on Unix-like platforms, or a `.exe` filename suffix for Windows)\n+\n+    If the same provider release is also being distributed under the same source address via other installation methods then the set of file paths in the resulting directory and the content of each file must exactly match the content of the packages delivered by the other methods, because OpenTofu will expect them all to match the same package checksums recorded in the dependency lock file.\n+\n+Those producing provider packages as container images may use any tools they wish as long as they produce manifests and layers consistent with OpenTofu's expectations.\n+\n+One possible approach is to use Docker CLI's \"buildx\" plugin to build multiple container images with a surrounding multi-platform manifest. If the provider's build process already produces `./dist/PLATFORM` directories containing the content of each platform's release package then the following `Dockerfile` would cause `docker buildx` to gather them all beneath a multi-platform manifest:\n+\n+```dockerfile\n+FROM scratch\n+LABEL org.opentofu.package-type=\"provider_binary\"\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+ARG TARGETOS\n+ARG TARGETARCH\n+COPY ./dist/${TARGETOS}_${TARGETARCH}/* /\n+```\n+\n+The following command would then build a selection of images and generate the multi-platform manifest for a specified set of platforms:\n+\n+```shell\n+docker buildx build \\\n+  --platform linux/amd64,darwin/amd64,windows/amd64,windows/arm64,linux/arm64,darwin/arm64 \\\n+  --tag example.com/namespace/opentofu-provider-name:1.0.0\n+```\n+\n+This would then build a multi-platform manifest suitable to be pushed to an OCI repository with the address `example.com/namespace/opentofu-provider-name`, under the tag `1.0.0`, using `docker push` as normal.\n+\n+This particular strategy assumes that the developer already used Go's support for cross-compilation, or some other non-Docker-specific strategy, to build native executables for each of the specified platforms into the subdirectories of `dist`. Since the `Dockerfile` only uses `COPY`, it's reusable without any virtualization or emulation to build packages for any supported platform regardless of what platform the container runtime used for building is running on.\n+\n+### \"Magic\" inference of an OCI repository address\n+\n+The first of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a \"magic\" mapping strategy based on a special reserved hostname suffix.\n+\n+The OpenTofu project will acquire a short, mnemonic domain to reserve for this mechanism. This RFC does not yet propose a specific domain, so for now we'll use `oci.opentofu.org` as a placeholder. Although that name would technically work, it's likely too long for ergonomic use and so should be replaced in a later version of this RFC once we've already purchased the intended domain.\n+\n+As a special case in the provider installation behavior, any provider belonging to a hostname that ends with the suffix `.oci.opentofu.org` will skip the normal service discovery process and will instead use a hard-coded internal mapping as follows:\n+\n+1. Trim the `.oci.opentofu.org` suffix from the hostname to obtain the OCI registry domain name.\n+2. Use the \"namespace\" portion of the provider source address, followed by the fixed delimiter `/opentofu-provider-`, and then the \"type\" portion of the provider source address as the repository name under the selected registry domain name.\n+\n+For example, the provider source address `example.com.oci.opentofu.org/foo/bar` would automatically resolve to the OCI repository address `example.com/foo/opentofu-provider-bar`.\n+\n+This particular scheme is intended for anyone who wants to use a pre-existing OCI registry to host packages for a provider without needing to set up any special OpenTofu-specific additions aside from following the designated naming scheme for the registry name. The specified repository naming scheme intentionally uses only two segments while using a fixed prefix for maximum compatibility with the naming restrictions of commonly-available public registry implementations while minimizing conflicts with non-OpenTofu-provider-related uses of those registries.\n+\n+### OCI Registry as an implementation detail of \"direct\" installation\n+\n+The second of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address uses [OpenTofu's existing service discovery mechanism](https://opentofu.org/docs/internals/remote-service-discovery/) to allow the deployment of something that behaves much like a normal OpenTofu provider registry, but uses the OCI distribution protocol instead of the OpenTofu-specific registry protocol _as a hidden implementation detail_. This compromise requires a small amount of OpenTofu-specific protocol implementation alongside a generic OCI registry, in return for hiding the implementation detail that an OCI registry is being used.\n+\n+The owner of a hostname can deploy a service discovery document which announces the new service identifier `oci-providers.v1`, with the associated value being a template for constructing an OCI repository address from the \"namespace\" and \"type\" portions of the provider source address using [RFC 6570 URI Template](https://www.rfc-editor.org/rfc/rfc6570) (level 1) syntax, which in practice means that `{namespace}` and `{type}` get substituted for the values from the provider source address:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"example.com/opentofu-providers/{namespace}/{type}\"\n+}\n+```\n+\n+If the service discovery document for `example.net` included the definition shown above, then the provider source address `example.net/foo/bar` would be translated to the OCI Distribution repository address `example.com/opentofu-providers/foo/bar`.\n+\n+This mechanism is essentially a more explicit generalization of the \"magic\" method from the previous section, allowing the owner of a hostname to customize exactly how providers belonging to that hostname are to be mapped onto OCI repository addresses.\n+\n+Note that there is no requirement that the provider source address hostname match the OCI registry domain name: it's possible for someone to project any hostname they own onto repositories in an OCI Distribution registry run by someone else if they want to. For example, the owner of `example.org` could announce the following in its service discovery document:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/example-org-otf-providers/{namespace}-{type}\"\n+}\n+```\n+\n+...and then they can rely on this third-party OCI registry implementation as an implementation detail, while using generic source addresses like `example.org/foo/bar` (mapping to `ghcr.io/example-org-otf-providers/foo-bar`) in all of their OpenTofu modules to reduce te lock-in to any specific OCI registry vendor.",
        "comment_created_at": "2024-12-17T15:14:45+00:00",
        "comment_author": "yhakbar",
        "comment_body": "```suggestion\r\n...and then they can rely on this third-party OCI registry implementation as an implementation detail, while using generic source addresses like `example.org/foo/bar` (mapping to `ghcr.io/example-org-otf-providers/foo-bar`) in all of their OpenTofu modules to reduce the lock-in to any specific OCI registry vendor.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1888704736",
    "pr_number": 2267,
    "pr_file": "rfc/20241206-provider-install-from-oci-registry.md",
    "created_at": "2024-12-17T15:25:16+00:00",
    "commented_code": "+# Provider Package Installation from OCI Registries\n+\n+Issue: [#308](https://github.com/opentofu/opentofu/issues/308)\n+\n+The associated issue represents support for using container image repositories in registries as defined by [The OpenContainers Distribution specification v1.0.0](https://specs.opencontainers.org/distribution-spec/?v=v1.0.0) as an alternative supported installation source location for OpenTofu module and provider packages.\n+\n+Module and provider installation in OpenTofu have enough differences that we intend to treat most of the relevant details as separate RFCs for each case, and this particular document is focused on the provider-package-specific details. It relies on some other proposals that describe some details that are common across both provider and module package installation.\n+\n+Today's OpenTofu supports provider installation by a number of different OpenTofu-specific strategies:\n+\n+- Direct installation from a provider's origin registry: The default behavior is to attempt to use the hostname given in the provider's source address (which defaults to `registry.opentofu.org` if not specified) with [the OpenTofu Provider Registry Protocol](https://opentofu.org/docs/internals/provider-registry-protocol/).\n+\n+    This makes a good default behavior because it requires no special configuration on the part of the user. The hostname in the provider source address gives us enough information to self-configure the registry client using [OpenTofu's remote service discovery protocol](https://opentofu.org/docs/internals/remote-service-discovery/).\n+\n+    However, it's not sufficient for all cases because it assumes that the client machine running OpenTofu can make a direct network connection to a server running at whatever hostname the provider source address belongs to. This is sometimes either technically impossible (for air-gapped systems) or prohibited by local policy despite being technically possible.\n+\n+    This is the only case where the hostname in the provider source address is used as a location to contact. In all other cases we use hostnames only to delegate the management of the top-level of our provider source address namespace to the domain name system.\n+\n+- Installing from a mirror server configured by the user: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a different server implementing [OpenTofu's Provider Mirror Protocol](https://opentofu.org/docs/internals/provider-network-mirror-protocol/).\n+\n+    The key difference between the Registry protocol and the Mirror protocol is that the latter includes the hostname from the provider source address as part of its requests, and so a single mirror can host packages belonging to many different hostnames at once, whereas a registry can only host packages belonging to its own hostname.\n+\n+- Treating a directory in the local filesystem as a mirror: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a directory in their local filesystem, containing copies of provider packages following one of two documented layouts.\n+\n+    This is similar to a network mirror but avoids the need to run an additional network service, as long as the mirrored packages are only needed on one system or they can be copied onto every system where they will be needed.\n+\n+The introduction of OCI Distribution repositories as a new package source is intended to meet similar goals as for the \"direct\" and \"network mirror\" strategies, but to achieve those goals by reusing existing registry infrastructure already deployed for the distribution of Docker-style container images. This means that those who are already invested in the OCI ecosystem can make further use of services they have already purchased or deployed, and that provider developers can potentially use existing container image hosting infrastructure as the primary distribution vehicle for their own providers, instead of relying on the OpenTofu-maintained registry or on some other OpenTofu-specific registry service.\n+\n+## Proposed Solution\n+\n+This proposal includes three different variations of using OCI registry infrastructure for provider package distribution, which will be described in later sections.\n+\n+What they all have in common is:\n+- Some means for translating an OpenTofu provider source address, such as `registry.opentofu.org/apparentlymart/assume`, into an OCI distribution repository address, which varies between the three methods.\n+- A convention for describing provider release versions as OCI distribution \"tags\" whose names follow a specified syntax.\n+- A convention for mapping OpenTofu platform identifiers like `linux_amd64` onto the common conventions for multi-platform container image manifests.\n+- A convention for the expected manifest and layer archive formats used to describe a single provider package, giving the filesystem contents needed to run a single version of a provider on a single platform.\n+- A way to provide OpenTofu with any credentials needed to interact with the registry that hosts the selected OCI repository.\n+\n+Some of these concerns have considerable overlap with the separate goal of installing _module packages_ from OCI registries, and so this proposal builds on two upstream proposals that are shared between those two problems:\n+\n+- [OpenTofu packages in OCI Registries](./20241206-packages-in-oci-registries.md): Describes the general conventions OpenTofu follows in interpreting the content of an OCI distribution repository as an OpenTofu-specific package format. This proposal specifies a specific application of those conventions to provider packages.\n+- [OCI Distribution Registry Authentication Configuration](./20241206-oci-registry-auth-config.md): Describes a cross-cutting approach to configuring OpenTofu to authenticate to OCI registries. This proposal relies on the preconfigured OCI Distribution client produced by that proposal, expecting that it will encapsulate all of the registry-authentication-related concerns, and so we will not discuss registry authentication any further in this document.\n+\n+### Provider Packages as OCI distribution objects\n+\n+Later sections will describe some different ways OpenTofu can translate provider source addresses into OCI distribution repository addresses, but a key goal of this proposal is for all of them to share a single convention for how that repository is used once selected, and that single convention is the focus of this section.\n+\n+Provider packages specialize [our general OCI repository conventions](./20241206-packages-in-oci-registries.md) in the following ways:\n+\n+- Each repository tag that is to be treated as a provider version must refer to a _multi-platform_ manifest, which describes in turn one child manifest for each target platform the provider supports where each describes a single container image.\n+- For the leaf manifests describing individual versions for individual platforms, the `org.opentofu.package-type` label **must** be set to `provider_binary`, so that OpenTofu can unambigously reject attempts to install generic container images or incompatible kinds of OpenTofu-specific packages with a clear error message.\n+- The union of all layers of each leaf image must represent a filesystem directory with the same content as an OpenTofu provider package distributed by other means. In particular, for a provider whose source address is `example.com/namespace/name` the resulting directory must contain an executable whose name begins with the prefix `terraform-provider-name`, which must be marked in the appropriate way to make it executable on the target platform. (e.g. executable permission on Unix-like platforms, or a `.exe` filename suffix for Windows)\n+\n+    If the same provider release is also being distributed under the same source address via other installation methods then the set of file paths in the resulting directory and the content of each file must exactly match the content of the packages delivered by the other methods, because OpenTofu will expect them all to match the same package checksums recorded in the dependency lock file.\n+\n+Those producing provider packages as container images may use any tools they wish as long as they produce manifests and layers consistent with OpenTofu's expectations.\n+\n+One possible approach is to use Docker CLI's \"buildx\" plugin to build multiple container images with a surrounding multi-platform manifest. If the provider's build process already produces `./dist/PLATFORM` directories containing the content of each platform's release package then the following `Dockerfile` would cause `docker buildx` to gather them all beneath a multi-platform manifest:\n+\n+```dockerfile\n+FROM scratch\n+LABEL org.opentofu.package-type=\"provider_binary\"\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+ARG TARGETOS\n+ARG TARGETARCH\n+COPY ./dist/${TARGETOS}_${TARGETARCH}/* /\n+```\n+\n+The following command would then build a selection of images and generate the multi-platform manifest for a specified set of platforms:\n+\n+```shell\n+docker buildx build \\\n+  --platform linux/amd64,darwin/amd64,windows/amd64,windows/arm64,linux/arm64,darwin/arm64 \\\n+  --tag example.com/namespace/opentofu-provider-name:1.0.0\n+```\n+\n+This would then build a multi-platform manifest suitable to be pushed to an OCI repository with the address `example.com/namespace/opentofu-provider-name`, under the tag `1.0.0`, using `docker push` as normal.\n+\n+This particular strategy assumes that the developer already used Go's support for cross-compilation, or some other non-Docker-specific strategy, to build native executables for each of the specified platforms into the subdirectories of `dist`. Since the `Dockerfile` only uses `COPY`, it's reusable without any virtualization or emulation to build packages for any supported platform regardless of what platform the container runtime used for building is running on.\n+\n+### \"Magic\" inference of an OCI repository address\n+\n+The first of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a \"magic\" mapping strategy based on a special reserved hostname suffix.\n+\n+The OpenTofu project will acquire a short, mnemonic domain to reserve for this mechanism. This RFC does not yet propose a specific domain, so for now we'll use `oci.opentofu.org` as a placeholder. Although that name would technically work, it's likely too long for ergonomic use and so should be replaced in a later version of this RFC once we've already purchased the intended domain.\n+\n+As a special case in the provider installation behavior, any provider belonging to a hostname that ends with the suffix `.oci.opentofu.org` will skip the normal service discovery process and will instead use a hard-coded internal mapping as follows:\n+\n+1. Trim the `.oci.opentofu.org` suffix from the hostname to obtain the OCI registry domain name.\n+2. Use the \"namespace\" portion of the provider source address, followed by the fixed delimiter `/opentofu-provider-`, and then the \"type\" portion of the provider source address as the repository name under the selected registry domain name.\n+\n+For example, the provider source address `example.com.oci.opentofu.org/foo/bar` would automatically resolve to the OCI repository address `example.com/foo/opentofu-provider-bar`.\n+\n+This particular scheme is intended for anyone who wants to use a pre-existing OCI registry to host packages for a provider without needing to set up any special OpenTofu-specific additions aside from following the designated naming scheme for the registry name. The specified repository naming scheme intentionally uses only two segments while using a fixed prefix for maximum compatibility with the naming restrictions of commonly-available public registry implementations while minimizing conflicts with non-OpenTofu-provider-related uses of those registries.\n+\n+### OCI Registry as an implementation detail of \"direct\" installation\n+\n+The second of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address uses [OpenTofu's existing service discovery mechanism](https://opentofu.org/docs/internals/remote-service-discovery/) to allow the deployment of something that behaves much like a normal OpenTofu provider registry, but uses the OCI distribution protocol instead of the OpenTofu-specific registry protocol _as a hidden implementation detail_. This compromise requires a small amount of OpenTofu-specific protocol implementation alongside a generic OCI registry, in return for hiding the implementation detail that an OCI registry is being used.\n+\n+The owner of a hostname can deploy a service discovery document which announces the new service identifier `oci-providers.v1`, with the associated value being a template for constructing an OCI repository address from the \"namespace\" and \"type\" portions of the provider source address using [RFC 6570 URI Template](https://www.rfc-editor.org/rfc/rfc6570) (level 1) syntax, which in practice means that `{namespace}` and `{type}` get substituted for the values from the provider source address:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"example.com/opentofu-providers/{namespace}/{type}\"\n+}\n+```\n+\n+If the service discovery document for `example.net` included the definition shown above, then the provider source address `example.net/foo/bar` would be translated to the OCI Distribution repository address `example.com/opentofu-providers/foo/bar`.\n+\n+This mechanism is essentially a more explicit generalization of the \"magic\" method from the previous section, allowing the owner of a hostname to customize exactly how providers belonging to that hostname are to be mapped onto OCI repository addresses.\n+\n+Note that there is no requirement that the provider source address hostname match the OCI registry domain name: it's possible for someone to project any hostname they own onto repositories in an OCI Distribution registry run by someone else if they want to. For example, the owner of `example.org` could announce the following in its service discovery document:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/example-org-otf-providers/{namespace}-{type}\"\n+}\n+```\n+\n+...and then they can rely on this third-party OCI registry implementation as an implementation detail, while using generic source addresses like `example.org/foo/bar` (mapping to `ghcr.io/example-org-otf-providers/foo-bar`) in all of their OpenTofu modules to reduce te lock-in to any specific OCI registry vendor.\n+\n+### OCI Registry as a new kind of \"mirror\"\n+\n+The final of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a new third kind of \"mirror\" that a user can write into their local CLI configuration:\n+\n+```hcl\n+provider_installation {\n+  oci_mirror {\n+    # repository_template is an HCL-style template that can substitute the\n+    # hostname, namespace, and type portions of the provider source address\n+    # to describe how to translate to an OCI repository address.\n+    repository_template = \"example.com/opentofu-providers/${hostname}/${namespace}/${type}\"\n+  }\n+}\n+```\n+\n+Provider _mirrors_ are configured and controlled by the local user of OpenTofu rather than by the owner of the hostname in the source address, and so this mechanism is particularly useful when someone cannot (or must not) rely on external registry services for _any_ provider they need to use. Instead then, they would copy the packages for all of their desired providers into an OCI registry they control, using a methodical naming scheme that can be described as a template like the above, and OpenTofu would then use this mirror for all providers regardless of which hostname their source address belongs to.\n+\n+In the above example, a module depending on `example.net/foo/bar` would cause OpenTofu to attempt installation from the OCI Distribution repository at `example.com/opentofu-providers/example.net/foo/bar`, bypassing any attempt to contact `example.net` over the network.\n+\n+As with the other installation methods, it's possible to designate specific provider source addresses, entire namespaces, or entire hostnames as included or excluded from an `oci_mirror` block. This then allows more complicated rulesets where some providers are mirrored and others are not, or different subsets of providers are mirrored in different locations. For example:\n+\n+```hcl\n+provider_installation {\n+  oci_mirror {\n+    repository_template = \"example.com/examplenet-mirror/${namespace}-${type}\"\n+    include             = [\"example.net/*/*\"]\n+  }\n+  oci_mirror {\n+    repository_template = \"example.com/exampleorg-mirror/${namespace}-${type}\"\n+    include             = [\"example.org/*/*\"]\n+  }\n+  direct {\n+    exclude = [\"example.net/*/*\", \"example.org/*/*\"]\n+  }\n+}\n+```\n+\n+Under this configuration:\n+\n+1. `example.net/foo/bar` would be installed from the OCI distribution repository at `example.com/examplenet-mirror/foo-bar`\n+2. `example.org/foo/bar` would be installed from the OCI distribution repository at `example.com/exampleorg-mirror/foo-bar`\n+3. `registry.opentofu.org/opentofu/lua` would be installed directly from `registry.opentofu.org`'s provider registry implementation.\n+\n+The `repository_template` given in each `oci_mirror` block must include a reference to any component of the provider source address that is wildcarded in the `include` argument. In the most recent example above, the templates did not need to include `${hostname}` because both blocks force only a single specific hostname in the `include` argument, and so no other hostname could reach that installation method.\n+\n+### Package checksums and signing\n+\n+OpenTofu tracks in its [dependency lock file](https://opentofu.org/docs/language/files/dependency-lock/) the single selected version of each previously-installed provider, and a set of checksums that are considered acceptable for that version of that provider.\n+\n+Additionally, whenever possible OpenTofu retrieves a GPG signature and associated public key for a provider (with both decided by its origin registry) and uses that signature to verify that the fetched provider package matches one of the checksums that was covered by the GPG signature. If that verification succeeds, OpenTofu assumes that all other checksums covered by the same signature are also trusted, and so records _all_ of them in the dependency lock file for future use. This mechanism is important to ensure that the dependency lock file ends up recording checksums for _all_ platform-specific packages offered for that provider version, even though OpenTofu only downloads and verifies the package for the current platform.\n+\n+OpenTofu's existing provider registry protocol always uses `.zip` archives as provider packages and requires the provider developer's signature to cover a document containing SHA256 checksums of all of the `.zip` archives for a particular version. These translate into `zh:`-schemed checksums in the dependency lock file, but since those checksums can only be verified against a not-yet-unpacked `.zip` archive OpenTofu also generates a more general `h1:` checksum based on the _contents_ of the package it downloaded, which it can then use to verify already-unpacked provider packages in the local filesystem.\n+\n+The established conventions for OCI manifest signing rely on the fact that OCI repositories use content-addressable storage and so signing a manifest containing the digests of other manifests or layer archives is sufficient to sign those manifest and layer archives themselves. However, much as with the signed `.zip` checksums used in the existing registry protocol, _these_ signed checksums are only useful to verify artifacts retrieved from an OCI repository and so OpenTofu will again need to also retain `h1:` checksums of the final content of the package after installation, calculated locally.\n+\n+A new checksum scheme `ch:` will be used to track any container manifest digests mentioned in a multi-platform manifest that is covered by a supported signature. OpenTofu will record signed `ch:` checksums in the dependency lock file in a similar way to `zh:` checksums from a native OpenTofu Provider Registry, requiring that any future package retrieved for that provider version match at least one of the recorded checksums so that a previously-trusted signed provider cannot be compromised by just deleting its signing metadata.\n+\n+The `ch:` checksum scheme is followed by a manifest digest using the same syntax as in OCI distribution manifests. For example, `ch:sha256:bc66513901b81f6cf8b2cf66d7414daa874f8f717626febe8591775232fedd0f`.\n+\n+**TODO:** Define what constitutes a \"supported signature\". We are currently evaluating existing designs used in the OCI ecosystem, including Cohost and Docker Content Trust.\n+\n+### Technical Approach\n+\n+Since all three of the possible mapping methods described above result in the address of an OCI Distribution repository that is expected to follow the same conventions for its contents, we can support all three with only a single client implementation.\n+\n+**TODO:** Write out the rest of this, once we've achieved consensus on the requirements and user experience parts of the proposal. For now, refer to [the prototype implementation](https://github.com/opentofu/opentofu/pull/2170).\n+\n+### Open Questions\n+\n+#### Provider Source Addresses with Unsupported Unicode Characters\n+\n+OpenTofu's provider source address syntax allows a wide variety of Unicode characters in all three components, following the [RFC 3491 \"Nameprep\"](https://datatracker.ietf.org/doc/rfc3491/) rules.\n+\n+However, the OCI Distribution specification has a considerably more restrictive allowed character set for repository names: it supports only ASCII letters and digits along with a small set of punctuation.\n+\n+In principle then, there are some valid OpenTofu provider source addresses that cannot be translated mechanically to valid OCI Distribution repository addresses via simple template substitution alone. A provider source address that, for example, has a Japanese alphabet character in its \"type\" portion would be projected into a syntactically-invalid OCI repository address.\n+\n+Our initial prototyped assumed that in practice non-ASCII characters in these addresses are very rare, and so just returns an error message whenever this situation arises:\n+\n+```\n+requested provider address example.com/foo/ contains characters that\n+are not valid in an OCI distribution repository name, so this provider\n+cannot be installed from an OCI repository as\n+ghcr.io/examplecom-otf-providers/foo-\n+```\n+\n+Of course, we cannot see into every organization to know whether they have in-house providers that are named with non-ASCII characters, and the fact that the OpenTofu project works primarily in English means that we are less likely to hear from those whose typical working language is not English.\n+\n+If we learn in future that supporting non-ASCII characters in provider source addresses installed from OCI registries is important, we could potentially force a specific scheme for automatically transforming those names into ones that are compatible with the OCI repository name requirements, such as applying a \"[Punycode](https://en.wikipedia.org/wiki/Punycode)-like\" encoding to them before rendering them into the template.\n+\n+However, Punycode in particular is not generally human-readable and so translation strategies like this often require some UI support to automatically transcode the data back into human-readable form for display. Any OpenTofu-specific mapping strategy we might invent is unlikely to be handled automatically by the UI associated with any general-purpose OCI registry implementation.\n+\n+## Potential Alternatives\n+\n+### \"Magic\" inference of OCI repository addresses for well-known OCI registries\n+\n+In [\"Magic\" inference of an OCI repository address](#magic-inference-of-an-oci-repository-address) we discussed reserving an OpenTofu-project-owned domain name for special treatment in triggering an automatic mapping to OCI repository addresses without any special configuration outside of the source address.\n+\n+That compromise is intended to allow use of existing unmodified OCI registries while remaining consistent with the idea that we use ownership of hostnames in the domain name system to delegate management of our top-level namespace.\n+\n+There are some hostnames that are currently well-known to be OCI registries, including:\n+\n+- `docker.io`\n+- `ghcr.io`\n+- `containers.pkg.github.com`\n+- `quay.io`\n+- `gcr.io`\n+- `public.ecr.aws`\n+\n+We could potentially also treat these specific hostnames as special cases, forcing them to be transformed in a similar way as our reserved domain suffix.\n+\n+However, that would not be appropriate because these hostnames do not belong to domains that our project owns and controls. The owners of these domain names are ultimately responsible for deciding their meaning, and so they should remain free to offer OpenTofu-specific services or not on hostnames under their domains as they see fit.\n+\n+Using an OpenTofu-project-owned domain for the \"magic\" mapping gives a single fixed string that someone can search for to learn more about how it works, and is also more explicit that this mapping is something special that OpenTofu is providing rather than something offered directly by the vendor that owns the underlying registry. This will therefore hopefully reduce the risk of owners of these registries being bothered by bug reports and similar related to OpenTofu's treatment of those domains.\n+\n+If the owner of a domain offering an OCI registry decides that they'd like their domain alone to be usable as part of OpenTofu provider source addresses, they can publish an OpenTofu service discovery document as described in [OCI Registry as an implementation detail of \"direct\" installation](#oci-registry-as-an-implementation-detail-of-direct-installation), using content like the following if they _only_ want to offer provider registry services and they want to follow the same naming scheme that our \"magic\" inference would have followed:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/{namespace}/opentofu-provider-{type}\"\n+}\n+```\n+\n+If a static document like the above were placed at `https://ghcr.io/.well-known/terraform.jon` then OpenTofu would translate a source address like `ghcr.io/foo/bar` into the OCI repository address `ghcr.io/foo/opentofu-provider-bar` and then attempt installation from that repository.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1888704736",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2267,
        "pr_file": "rfc/20241206-provider-install-from-oci-registry.md",
        "discussion_id": "1888704736",
        "commented_code": "@@ -0,0 +1,249 @@\n+# Provider Package Installation from OCI Registries\n+\n+Issue: [#308](https://github.com/opentofu/opentofu/issues/308)\n+\n+The associated issue represents support for using container image repositories in registries as defined by [The OpenContainers Distribution specification v1.0.0](https://specs.opencontainers.org/distribution-spec/?v=v1.0.0) as an alternative supported installation source location for OpenTofu module and provider packages.\n+\n+Module and provider installation in OpenTofu have enough differences that we intend to treat most of the relevant details as separate RFCs for each case, and this particular document is focused on the provider-package-specific details. It relies on some other proposals that describe some details that are common across both provider and module package installation.\n+\n+Today's OpenTofu supports provider installation by a number of different OpenTofu-specific strategies:\n+\n+- Direct installation from a provider's origin registry: The default behavior is to attempt to use the hostname given in the provider's source address (which defaults to `registry.opentofu.org` if not specified) with [the OpenTofu Provider Registry Protocol](https://opentofu.org/docs/internals/provider-registry-protocol/).\n+\n+    This makes a good default behavior because it requires no special configuration on the part of the user. The hostname in the provider source address gives us enough information to self-configure the registry client using [OpenTofu's remote service discovery protocol](https://opentofu.org/docs/internals/remote-service-discovery/).\n+\n+    However, it's not sufficient for all cases because it assumes that the client machine running OpenTofu can make a direct network connection to a server running at whatever hostname the provider source address belongs to. This is sometimes either technically impossible (for air-gapped systems) or prohibited by local policy despite being technically possible.\n+\n+    This is the only case where the hostname in the provider source address is used as a location to contact. In all other cases we use hostnames only to delegate the management of the top-level of our provider source address namespace to the domain name system.\n+\n+- Installing from a mirror server configured by the user: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a different server implementing [OpenTofu's Provider Mirror Protocol](https://opentofu.org/docs/internals/provider-network-mirror-protocol/).\n+\n+    The key difference between the Registry protocol and the Mirror protocol is that the latter includes the hostname from the provider source address as part of its requests, and so a single mirror can host packages belonging to many different hostnames at once, whereas a registry can only host packages belonging to its own hostname.\n+\n+- Treating a directory in the local filesystem as a mirror: users can use [a `provider_installation` block in their CLI configuration](https://opentofu.org/docs/cli/config/config-file/#explicit-installation-method-configuration) to tell OpenTofu to install some or all providers from a directory in their local filesystem, containing copies of provider packages following one of two documented layouts.\n+\n+    This is similar to a network mirror but avoids the need to run an additional network service, as long as the mirrored packages are only needed on one system or they can be copied onto every system where they will be needed.\n+\n+The introduction of OCI Distribution repositories as a new package source is intended to meet similar goals as for the \"direct\" and \"network mirror\" strategies, but to achieve those goals by reusing existing registry infrastructure already deployed for the distribution of Docker-style container images. This means that those who are already invested in the OCI ecosystem can make further use of services they have already purchased or deployed, and that provider developers can potentially use existing container image hosting infrastructure as the primary distribution vehicle for their own providers, instead of relying on the OpenTofu-maintained registry or on some other OpenTofu-specific registry service.\n+\n+## Proposed Solution\n+\n+This proposal includes three different variations of using OCI registry infrastructure for provider package distribution, which will be described in later sections.\n+\n+What they all have in common is:\n+- Some means for translating an OpenTofu provider source address, such as `registry.opentofu.org/apparentlymart/assume`, into an OCI distribution repository address, which varies between the three methods.\n+- A convention for describing provider release versions as OCI distribution \"tags\" whose names follow a specified syntax.\n+- A convention for mapping OpenTofu platform identifiers like `linux_amd64` onto the common conventions for multi-platform container image manifests.\n+- A convention for the expected manifest and layer archive formats used to describe a single provider package, giving the filesystem contents needed to run a single version of a provider on a single platform.\n+- A way to provide OpenTofu with any credentials needed to interact with the registry that hosts the selected OCI repository.\n+\n+Some of these concerns have considerable overlap with the separate goal of installing _module packages_ from OCI registries, and so this proposal builds on two upstream proposals that are shared between those two problems:\n+\n+- [OpenTofu packages in OCI Registries](./20241206-packages-in-oci-registries.md): Describes the general conventions OpenTofu follows in interpreting the content of an OCI distribution repository as an OpenTofu-specific package format. This proposal specifies a specific application of those conventions to provider packages.\n+- [OCI Distribution Registry Authentication Configuration](./20241206-oci-registry-auth-config.md): Describes a cross-cutting approach to configuring OpenTofu to authenticate to OCI registries. This proposal relies on the preconfigured OCI Distribution client produced by that proposal, expecting that it will encapsulate all of the registry-authentication-related concerns, and so we will not discuss registry authentication any further in this document.\n+\n+### Provider Packages as OCI distribution objects\n+\n+Later sections will describe some different ways OpenTofu can translate provider source addresses into OCI distribution repository addresses, but a key goal of this proposal is for all of them to share a single convention for how that repository is used once selected, and that single convention is the focus of this section.\n+\n+Provider packages specialize [our general OCI repository conventions](./20241206-packages-in-oci-registries.md) in the following ways:\n+\n+- Each repository tag that is to be treated as a provider version must refer to a _multi-platform_ manifest, which describes in turn one child manifest for each target platform the provider supports where each describes a single container image.\n+- For the leaf manifests describing individual versions for individual platforms, the `org.opentofu.package-type` label **must** be set to `provider_binary`, so that OpenTofu can unambigously reject attempts to install generic container images or incompatible kinds of OpenTofu-specific packages with a clear error message.\n+- The union of all layers of each leaf image must represent a filesystem directory with the same content as an OpenTofu provider package distributed by other means. In particular, for a provider whose source address is `example.com/namespace/name` the resulting directory must contain an executable whose name begins with the prefix `terraform-provider-name`, which must be marked in the appropriate way to make it executable on the target platform. (e.g. executable permission on Unix-like platforms, or a `.exe` filename suffix for Windows)\n+\n+    If the same provider release is also being distributed under the same source address via other installation methods then the set of file paths in the resulting directory and the content of each file must exactly match the content of the packages delivered by the other methods, because OpenTofu will expect them all to match the same package checksums recorded in the dependency lock file.\n+\n+Those producing provider packages as container images may use any tools they wish as long as they produce manifests and layers consistent with OpenTofu's expectations.\n+\n+One possible approach is to use Docker CLI's \"buildx\" plugin to build multiple container images with a surrounding multi-platform manifest. If the provider's build process already produces `./dist/PLATFORM` directories containing the content of each platform's release package then the following `Dockerfile` would cause `docker buildx` to gather them all beneath a multi-platform manifest:\n+\n+```dockerfile\n+FROM scratch\n+LABEL org.opentofu.package-type=\"provider_binary\"\n+ARG TARGETPLATFORM\n+ARG BUILDPLATFORM\n+ARG TARGETOS\n+ARG TARGETARCH\n+COPY ./dist/${TARGETOS}_${TARGETARCH}/* /\n+```\n+\n+The following command would then build a selection of images and generate the multi-platform manifest for a specified set of platforms:\n+\n+```shell\n+docker buildx build \\\n+  --platform linux/amd64,darwin/amd64,windows/amd64,windows/arm64,linux/arm64,darwin/arm64 \\\n+  --tag example.com/namespace/opentofu-provider-name:1.0.0\n+```\n+\n+This would then build a multi-platform manifest suitable to be pushed to an OCI repository with the address `example.com/namespace/opentofu-provider-name`, under the tag `1.0.0`, using `docker push` as normal.\n+\n+This particular strategy assumes that the developer already used Go's support for cross-compilation, or some other non-Docker-specific strategy, to build native executables for each of the specified platforms into the subdirectories of `dist`. Since the `Dockerfile` only uses `COPY`, it's reusable without any virtualization or emulation to build packages for any supported platform regardless of what platform the container runtime used for building is running on.\n+\n+### \"Magic\" inference of an OCI repository address\n+\n+The first of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a \"magic\" mapping strategy based on a special reserved hostname suffix.\n+\n+The OpenTofu project will acquire a short, mnemonic domain to reserve for this mechanism. This RFC does not yet propose a specific domain, so for now we'll use `oci.opentofu.org` as a placeholder. Although that name would technically work, it's likely too long for ergonomic use and so should be replaced in a later version of this RFC once we've already purchased the intended domain.\n+\n+As a special case in the provider installation behavior, any provider belonging to a hostname that ends with the suffix `.oci.opentofu.org` will skip the normal service discovery process and will instead use a hard-coded internal mapping as follows:\n+\n+1. Trim the `.oci.opentofu.org` suffix from the hostname to obtain the OCI registry domain name.\n+2. Use the \"namespace\" portion of the provider source address, followed by the fixed delimiter `/opentofu-provider-`, and then the \"type\" portion of the provider source address as the repository name under the selected registry domain name.\n+\n+For example, the provider source address `example.com.oci.opentofu.org/foo/bar` would automatically resolve to the OCI repository address `example.com/foo/opentofu-provider-bar`.\n+\n+This particular scheme is intended for anyone who wants to use a pre-existing OCI registry to host packages for a provider without needing to set up any special OpenTofu-specific additions aside from following the designated naming scheme for the registry name. The specified repository naming scheme intentionally uses only two segments while using a fixed prefix for maximum compatibility with the naming restrictions of commonly-available public registry implementations while minimizing conflicts with non-OpenTofu-provider-related uses of those registries.\n+\n+### OCI Registry as an implementation detail of \"direct\" installation\n+\n+The second of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address uses [OpenTofu's existing service discovery mechanism](https://opentofu.org/docs/internals/remote-service-discovery/) to allow the deployment of something that behaves much like a normal OpenTofu provider registry, but uses the OCI distribution protocol instead of the OpenTofu-specific registry protocol _as a hidden implementation detail_. This compromise requires a small amount of OpenTofu-specific protocol implementation alongside a generic OCI registry, in return for hiding the implementation detail that an OCI registry is being used.\n+\n+The owner of a hostname can deploy a service discovery document which announces the new service identifier `oci-providers.v1`, with the associated value being a template for constructing an OCI repository address from the \"namespace\" and \"type\" portions of the provider source address using [RFC 6570 URI Template](https://www.rfc-editor.org/rfc/rfc6570) (level 1) syntax, which in practice means that `{namespace}` and `{type}` get substituted for the values from the provider source address:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"example.com/opentofu-providers/{namespace}/{type}\"\n+}\n+```\n+\n+If the service discovery document for `example.net` included the definition shown above, then the provider source address `example.net/foo/bar` would be translated to the OCI Distribution repository address `example.com/opentofu-providers/foo/bar`.\n+\n+This mechanism is essentially a more explicit generalization of the \"magic\" method from the previous section, allowing the owner of a hostname to customize exactly how providers belonging to that hostname are to be mapped onto OCI repository addresses.\n+\n+Note that there is no requirement that the provider source address hostname match the OCI registry domain name: it's possible for someone to project any hostname they own onto repositories in an OCI Distribution registry run by someone else if they want to. For example, the owner of `example.org` could announce the following in its service discovery document:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/example-org-otf-providers/{namespace}-{type}\"\n+}\n+```\n+\n+...and then they can rely on this third-party OCI registry implementation as an implementation detail, while using generic source addresses like `example.org/foo/bar` (mapping to `ghcr.io/example-org-otf-providers/foo-bar`) in all of their OpenTofu modules to reduce te lock-in to any specific OCI registry vendor.\n+\n+### OCI Registry as a new kind of \"mirror\"\n+\n+The final of the three supported approaches for translating an OpenTofu provider source address into an OCI repository address is a new third kind of \"mirror\" that a user can write into their local CLI configuration:\n+\n+```hcl\n+provider_installation {\n+  oci_mirror {\n+    # repository_template is an HCL-style template that can substitute the\n+    # hostname, namespace, and type portions of the provider source address\n+    # to describe how to translate to an OCI repository address.\n+    repository_template = \"example.com/opentofu-providers/${hostname}/${namespace}/${type}\"\n+  }\n+}\n+```\n+\n+Provider _mirrors_ are configured and controlled by the local user of OpenTofu rather than by the owner of the hostname in the source address, and so this mechanism is particularly useful when someone cannot (or must not) rely on external registry services for _any_ provider they need to use. Instead then, they would copy the packages for all of their desired providers into an OCI registry they control, using a methodical naming scheme that can be described as a template like the above, and OpenTofu would then use this mirror for all providers regardless of which hostname their source address belongs to.\n+\n+In the above example, a module depending on `example.net/foo/bar` would cause OpenTofu to attempt installation from the OCI Distribution repository at `example.com/opentofu-providers/example.net/foo/bar`, bypassing any attempt to contact `example.net` over the network.\n+\n+As with the other installation methods, it's possible to designate specific provider source addresses, entire namespaces, or entire hostnames as included or excluded from an `oci_mirror` block. This then allows more complicated rulesets where some providers are mirrored and others are not, or different subsets of providers are mirrored in different locations. For example:\n+\n+```hcl\n+provider_installation {\n+  oci_mirror {\n+    repository_template = \"example.com/examplenet-mirror/${namespace}-${type}\"\n+    include             = [\"example.net/*/*\"]\n+  }\n+  oci_mirror {\n+    repository_template = \"example.com/exampleorg-mirror/${namespace}-${type}\"\n+    include             = [\"example.org/*/*\"]\n+  }\n+  direct {\n+    exclude = [\"example.net/*/*\", \"example.org/*/*\"]\n+  }\n+}\n+```\n+\n+Under this configuration:\n+\n+1. `example.net/foo/bar` would be installed from the OCI distribution repository at `example.com/examplenet-mirror/foo-bar`\n+2. `example.org/foo/bar` would be installed from the OCI distribution repository at `example.com/exampleorg-mirror/foo-bar`\n+3. `registry.opentofu.org/opentofu/lua` would be installed directly from `registry.opentofu.org`'s provider registry implementation.\n+\n+The `repository_template` given in each `oci_mirror` block must include a reference to any component of the provider source address that is wildcarded in the `include` argument. In the most recent example above, the templates did not need to include `${hostname}` because both blocks force only a single specific hostname in the `include` argument, and so no other hostname could reach that installation method.\n+\n+### Package checksums and signing\n+\n+OpenTofu tracks in its [dependency lock file](https://opentofu.org/docs/language/files/dependency-lock/) the single selected version of each previously-installed provider, and a set of checksums that are considered acceptable for that version of that provider.\n+\n+Additionally, whenever possible OpenTofu retrieves a GPG signature and associated public key for a provider (with both decided by its origin registry) and uses that signature to verify that the fetched provider package matches one of the checksums that was covered by the GPG signature. If that verification succeeds, OpenTofu assumes that all other checksums covered by the same signature are also trusted, and so records _all_ of them in the dependency lock file for future use. This mechanism is important to ensure that the dependency lock file ends up recording checksums for _all_ platform-specific packages offered for that provider version, even though OpenTofu only downloads and verifies the package for the current platform.\n+\n+OpenTofu's existing provider registry protocol always uses `.zip` archives as provider packages and requires the provider developer's signature to cover a document containing SHA256 checksums of all of the `.zip` archives for a particular version. These translate into `zh:`-schemed checksums in the dependency lock file, but since those checksums can only be verified against a not-yet-unpacked `.zip` archive OpenTofu also generates a more general `h1:` checksum based on the _contents_ of the package it downloaded, which it can then use to verify already-unpacked provider packages in the local filesystem.\n+\n+The established conventions for OCI manifest signing rely on the fact that OCI repositories use content-addressable storage and so signing a manifest containing the digests of other manifests or layer archives is sufficient to sign those manifest and layer archives themselves. However, much as with the signed `.zip` checksums used in the existing registry protocol, _these_ signed checksums are only useful to verify artifacts retrieved from an OCI repository and so OpenTofu will again need to also retain `h1:` checksums of the final content of the package after installation, calculated locally.\n+\n+A new checksum scheme `ch:` will be used to track any container manifest digests mentioned in a multi-platform manifest that is covered by a supported signature. OpenTofu will record signed `ch:` checksums in the dependency lock file in a similar way to `zh:` checksums from a native OpenTofu Provider Registry, requiring that any future package retrieved for that provider version match at least one of the recorded checksums so that a previously-trusted signed provider cannot be compromised by just deleting its signing metadata.\n+\n+The `ch:` checksum scheme is followed by a manifest digest using the same syntax as in OCI distribution manifests. For example, `ch:sha256:bc66513901b81f6cf8b2cf66d7414daa874f8f717626febe8591775232fedd0f`.\n+\n+**TODO:** Define what constitutes a \"supported signature\". We are currently evaluating existing designs used in the OCI ecosystem, including Cohost and Docker Content Trust.\n+\n+### Technical Approach\n+\n+Since all three of the possible mapping methods described above result in the address of an OCI Distribution repository that is expected to follow the same conventions for its contents, we can support all three with only a single client implementation.\n+\n+**TODO:** Write out the rest of this, once we've achieved consensus on the requirements and user experience parts of the proposal. For now, refer to [the prototype implementation](https://github.com/opentofu/opentofu/pull/2170).\n+\n+### Open Questions\n+\n+#### Provider Source Addresses with Unsupported Unicode Characters\n+\n+OpenTofu's provider source address syntax allows a wide variety of Unicode characters in all three components, following the [RFC 3491 \"Nameprep\"](https://datatracker.ietf.org/doc/rfc3491/) rules.\n+\n+However, the OCI Distribution specification has a considerably more restrictive allowed character set for repository names: it supports only ASCII letters and digits along with a small set of punctuation.\n+\n+In principle then, there are some valid OpenTofu provider source addresses that cannot be translated mechanically to valid OCI Distribution repository addresses via simple template substitution alone. A provider source address that, for example, has a Japanese alphabet character in its \"type\" portion would be projected into a syntactically-invalid OCI repository address.\n+\n+Our initial prototyped assumed that in practice non-ASCII characters in these addresses are very rare, and so just returns an error message whenever this situation arises:\n+\n+```\n+requested provider address example.com/foo/ contains characters that\n+are not valid in an OCI distribution repository name, so this provider\n+cannot be installed from an OCI repository as\n+ghcr.io/examplecom-otf-providers/foo-\n+```\n+\n+Of course, we cannot see into every organization to know whether they have in-house providers that are named with non-ASCII characters, and the fact that the OpenTofu project works primarily in English means that we are less likely to hear from those whose typical working language is not English.\n+\n+If we learn in future that supporting non-ASCII characters in provider source addresses installed from OCI registries is important, we could potentially force a specific scheme for automatically transforming those names into ones that are compatible with the OCI repository name requirements, such as applying a \"[Punycode](https://en.wikipedia.org/wiki/Punycode)-like\" encoding to them before rendering them into the template.\n+\n+However, Punycode in particular is not generally human-readable and so translation strategies like this often require some UI support to automatically transcode the data back into human-readable form for display. Any OpenTofu-specific mapping strategy we might invent is unlikely to be handled automatically by the UI associated with any general-purpose OCI registry implementation.\n+\n+## Potential Alternatives\n+\n+### \"Magic\" inference of OCI repository addresses for well-known OCI registries\n+\n+In [\"Magic\" inference of an OCI repository address](#magic-inference-of-an-oci-repository-address) we discussed reserving an OpenTofu-project-owned domain name for special treatment in triggering an automatic mapping to OCI repository addresses without any special configuration outside of the source address.\n+\n+That compromise is intended to allow use of existing unmodified OCI registries while remaining consistent with the idea that we use ownership of hostnames in the domain name system to delegate management of our top-level namespace.\n+\n+There are some hostnames that are currently well-known to be OCI registries, including:\n+\n+- `docker.io`\n+- `ghcr.io`\n+- `containers.pkg.github.com`\n+- `quay.io`\n+- `gcr.io`\n+- `public.ecr.aws`\n+\n+We could potentially also treat these specific hostnames as special cases, forcing them to be transformed in a similar way as our reserved domain suffix.\n+\n+However, that would not be appropriate because these hostnames do not belong to domains that our project owns and controls. The owners of these domain names are ultimately responsible for deciding their meaning, and so they should remain free to offer OpenTofu-specific services or not on hostnames under their domains as they see fit.\n+\n+Using an OpenTofu-project-owned domain for the \"magic\" mapping gives a single fixed string that someone can search for to learn more about how it works, and is also more explicit that this mapping is something special that OpenTofu is providing rather than something offered directly by the vendor that owns the underlying registry. This will therefore hopefully reduce the risk of owners of these registries being bothered by bug reports and similar related to OpenTofu's treatment of those domains.\n+\n+If the owner of a domain offering an OCI registry decides that they'd like their domain alone to be usable as part of OpenTofu provider source addresses, they can publish an OpenTofu service discovery document as described in [OCI Registry as an implementation detail of \"direct\" installation](#oci-registry-as-an-implementation-detail-of-direct-installation), using content like the following if they _only_ want to offer provider registry services and they want to follow the same naming scheme that our \"magic\" inference would have followed:\n+\n+```json\n+{\n+    \"oci-providers.v1\": \"ghcr.io/{namespace}/opentofu-provider-{type}\"\n+}\n+```\n+\n+If a static document like the above were placed at `https://ghcr.io/.well-known/terraform.jon` then OpenTofu would translate a source address like `ghcr.io/foo/bar` into the OCI repository address `ghcr.io/foo/opentofu-provider-bar` and then attempt installation from that repository.",
        "comment_created_at": "2024-12-17T15:25:16+00:00",
        "comment_author": "yhakbar",
        "comment_body": "```suggestion\r\nIf a static document like the above were placed at `https://ghcr.io/.well-known/terraform.json` then OpenTofu would translate a source address like `ghcr.io/foo/bar` into the OCI repository address `ghcr.io/foo/opentofu-provider-bar` and then attempt installation from that repository.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1547956553",
    "pr_number": 1439,
    "pr_file": "CHANGELOG.md",
    "created_at": "2024-04-02T14:02:00+00:00",
    "commented_code": "NEW FEATURES:\n * Add support for a `removed` block that allows users to remove resources or modules from the state without destroying them. ([#1158](https://github.com/opentofu/opentofu/pull/1158))\n+* Provider defined functions are now available.  They may be referenced via `provider::alias::funcname(args)`.  ([#1439](https://github.com/opentofu/opentofu/pull/1439))",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1547956553",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1439,
        "pr_file": "CHANGELOG.md",
        "discussion_id": "1547956553",
        "commented_code": "@@ -13,6 +13,7 @@ STATE ENCRYPTION\n \n NEW FEATURES:\n * Add support for a `removed` block that allows users to remove resources or modules from the state without destroying them. ([#1158](https://github.com/opentofu/opentofu/pull/1158))\n+* Provider defined functions are now available.  They may be referenced via `provider::alias::funcname(args)`.  ([#1439](https://github.com/opentofu/opentofu/pull/1439))",
        "comment_created_at": "2024-04-02T14:02:00+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I think maybe we should specify an example here?  its not clear what `alias` is here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1550087590",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1439,
        "pr_file": "CHANGELOG.md",
        "discussion_id": "1547956553",
        "commented_code": "@@ -13,6 +13,7 @@ STATE ENCRYPTION\n \n NEW FEATURES:\n * Add support for a `removed` block that allows users to remove resources or modules from the state without destroying them. ([#1158](https://github.com/opentofu/opentofu/pull/1158))\n+* Provider defined functions are now available.  They may be referenced via `provider::alias::funcname(args)`.  ([#1439](https://github.com/opentofu/opentofu/pull/1439))",
        "comment_created_at": "2024-04-03T16:38:24+00:00",
        "comment_author": "cam72cam",
        "comment_body": "changed alias to provider_alias",
        "pr_file_module": null
      }
    ]
  }
]