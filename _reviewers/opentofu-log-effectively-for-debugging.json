[
  {
    "discussion_id": "2136928192",
    "pr_number": 2896,
    "pr_file": "internal/backend/remote-state/consul/client.go",
    "created_at": "2025-06-10T05:15:19+00:00",
    "commented_code": "// This is only cleanup, and will fail if the lock was immediately taken by\n \t// another client, so we don't report an error to the user here.\n-\tc.consulLock.Destroy()\n+\tc.consulLock.Destroy() //nolint:errcheck",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2136928192",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2896,
        "pr_file": "internal/backend/remote-state/consul/client.go",
        "discussion_id": "2136928192",
        "commented_code": "@@ -618,7 +625,7 @@ func (c *RemoteClient) unlock(id string) error {\n \n \t// This is only cleanup, and will fail if the lock was immediately taken by\n \t// another client, so we don't report an error to the user here.\n-\tc.consulLock.Destroy()\n+\tc.consulLock.Destroy() //nolint:errcheck",
        "comment_created_at": "2025-06-10T05:15:19+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\nWe could at least log the error if occurs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136949898",
    "pr_number": 2896,
    "pr_file": "internal/initwd/from_module_test.go",
    "created_at": "2025-06-10T05:36:35+00:00",
    "commented_code": "t.Fatalf(\"failed to switch to temp dir %s: %s\", tmpDir, err)\n \t}\n \tt.Cleanup(func() {\n-\t\tos.Chdir(oldDir)\n+\t\tos.Chdir(oldDir) //nolint:errcheck // don't care about errors during cleanup",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2136949898",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2896,
        "pr_file": "internal/initwd/from_module_test.go",
        "discussion_id": "2136949898",
        "commented_code": "@@ -302,7 +302,7 @@ func TestDirFromModule_rel_submodules(t *testing.T) {\n \t\tt.Fatalf(\"failed to switch to temp dir %s: %s\", tmpDir, err)\n \t}\n \tt.Cleanup(func() {\n-\t\tos.Chdir(oldDir)\n+\t\tos.Chdir(oldDir) //nolint:errcheck // don't care about errors during cleanup",
        "comment_created_at": "2025-06-10T05:36:35+00:00",
        "comment_author": "yottta",
        "comment_body": "Could we log it at least? ðŸ¤” ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046327315",
    "pr_number": 2665,
    "pr_file": "internal/tracing/utils.go",
    "created_at": "2025-04-16T07:55:33+00:00",
    "commented_code": "+package tracing\n+\n+import (\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\t\"go.opentelemetry.io/otel\"\n+\t\"go.opentelemetry.io/otel/trace\"\n+)\n+\n+func Tracer() trace.Tracer {\n+\tif !isTracingEnabled {\n+\t\treturn otel.Tracer(\"\")\n+\t}\n+\n+\tpc, _, _, ok := runtime.Caller(1)\n+\tif !ok || runtime.FuncForPC(pc) == nil {\n+\t\treturn otel.Tracer(\"\")\n+\t}\n+\n+\t// We use the import path of the caller function as the tracer name.\n+\treturn otel.GetTracerProvider().Tracer(extractImportPath(runtime.FuncForPC(pc).Name()))\n+}\n+\n+// extractImportPath extracts the import path from a full function name.\n+// the function names returned by runtime.FuncForPC(pc).Name() can be in the following formats\n+//\n+//\tmain.(*MyType).MyMethod\n+//\tgithub.com/you/pkg.(*SomeType).Method-fm\n+//\tgithub.com/you/pkg.functionName\n+func extractImportPath(fullName string) string {\n+\tlastSlash := strings.LastIndex(fullName, \"/\")\n+\tif lastSlash == -1 {\n+\t\t// When there is no slash, then use everything before the first dot\n+\t\tif dot := strings.Index(fullName, \".\"); dot != -1 {\n+\t\t\treturn fullName[:dot]\n+\t\t}\n+\t\treturn \"unknown\"",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2046327315",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/tracing/utils.go",
        "discussion_id": "2046327315",
        "commented_code": "@@ -0,0 +1,47 @@\n+package tracing\n+\n+import (\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\t\"go.opentelemetry.io/otel\"\n+\t\"go.opentelemetry.io/otel/trace\"\n+)\n+\n+func Tracer() trace.Tracer {\n+\tif !isTracingEnabled {\n+\t\treturn otel.Tracer(\"\")\n+\t}\n+\n+\tpc, _, _, ok := runtime.Caller(1)\n+\tif !ok || runtime.FuncForPC(pc) == nil {\n+\t\treturn otel.Tracer(\"\")\n+\t}\n+\n+\t// We use the import path of the caller function as the tracer name.\n+\treturn otel.GetTracerProvider().Tracer(extractImportPath(runtime.FuncForPC(pc).Name()))\n+}\n+\n+// extractImportPath extracts the import path from a full function name.\n+// the function names returned by runtime.FuncForPC(pc).Name() can be in the following formats\n+//\n+//\tmain.(*MyType).MyMethod\n+//\tgithub.com/you/pkg.(*SomeType).Method-fm\n+//\tgithub.com/you/pkg.functionName\n+func extractImportPath(fullName string) string {\n+\tlastSlash := strings.LastIndex(fullName, \"/\")\n+\tif lastSlash == -1 {\n+\t\t// When there is no slash, then use everything before the first dot\n+\t\tif dot := strings.Index(fullName, \".\"); dot != -1 {\n+\t\t\treturn fullName[:dot]\n+\t\t}\n+\t\treturn \"unknown\"",
        "comment_created_at": "2025-04-16T07:55:33+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\nFor being able to adjust this parsing in the future, we could have a trace log here writing the `fullName`. This way, in case somebody is encountering \"unknown\" traces, we could ask for the logs and adjust this parsing accordingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2070464435",
    "pr_number": 2705,
    "pr_file": "internal/tofu/evaluate.go",
    "created_at": "2025-05-01T16:13:31+00:00",
    "commented_code": "return val, diags\n }\n \n+func isCallFromRemote(parentCfg *configs.Config, moduleCall addrs.ModuleCall) bool {\n+\tif _, ok := parentCfg.SourceAddr.(addrs.ModuleSourceRemote); ok {\n+\t\treturn true\n+\t}\n+\tcalledModuleName := moduleCall.Name\n+\tparent := parentCfg.Parent\n+\tfor parent != nil {\n+\t\trefCallCfg, ok := parent.Module.ModuleCalls[calledModuleName]\n+\t\tif !ok {\n+\t\t\tlog.Printf(\"[ERROR] no module call found in %q for %q. This should not happen. Please report this to OpenTofu\", parent.Path, calledModuleName)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2070464435",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2705,
        "pr_file": "internal/tofu/evaluate.go",
        "discussion_id": "2070464435",
        "commented_code": "@@ -352,9 +357,33 @@ func (d *evaluationStateData) GetLocalValue(addr addrs.LocalValue, rng tfdiags.S\n \treturn val, diags\n }\n \n+func isCallFromRemote(parentCfg *configs.Config, moduleCall addrs.ModuleCall) bool {\n+\tif _, ok := parentCfg.SourceAddr.(addrs.ModuleSourceRemote); ok {\n+\t\treturn true\n+\t}\n+\tcalledModuleName := moduleCall.Name\n+\tparent := parentCfg.Parent\n+\tfor parent != nil {\n+\t\trefCallCfg, ok := parent.Module.ModuleCalls[calledModuleName]\n+\t\tif !ok {\n+\t\t\tlog.Printf(\"[ERROR] no module call found in %q for %q. This should not happen. Please report this to OpenTofu\", parent.Path, calledModuleName)",
        "comment_created_at": "2025-05-01T16:13:31+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "We don't typically expect end-users to notice messages in the logs, so if we want folks to report this as a bug then it should probably be either a normal error diagnostic or a panic.\r\n\r\nHowever, we do also ask folks to send us the trace logs when they report a strange behavior, so it would be a reasonable compromise to just remove the \"This should not happen...\" part of this message and rework this to be something we can notice in the trace logs that folks send us:\r\n\r\n```\r\n[ERROR] tofu.isCallFromRemote: no module call found in foo for bar\r\n```\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1998788392",
    "pr_number": 2580,
    "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
    "created_at": "2025-03-17T13:55:26+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1998788392",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998788392",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest",
        "comment_created_at": "2025-03-17T13:55:26+00:00",
        "comment_author": "yottta",
        "comment_body": "`suggestion`\r\nA trace log maybe? Maybe somebody really wants to debug this if something is not working for them.",
        "pr_file_module": null
      },
      {
        "comment_id": "1998791589",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998788392",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest",
        "comment_created_at": "2025-03-17T13:56:48+00:00",
        "comment_author": "yottta",
        "comment_body": "I am thinking that for somebody that is playing around with setting this up, could upload the artifacts with a wrong artifactType and then have a hard time figuring it out.",
        "pr_file_module": null
      },
      {
        "comment_id": "1999150098",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2580,
        "pr_file": "internal/getproviders/oci_registry_mirror_source.go",
        "discussion_id": "1998788392",
        "commented_code": "@@ -0,0 +1,608 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"github.com/apparentlymart/go-versions/versions\"\n+\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n+\torasErrors \"oras.land/oras-go/v2/errdef\"\n+\n+\t\"github.com/opentofu/opentofu/internal/addrs\"\n+)\n+\n+// ociIndexManifestArtifactType is the artifact type we expect for the top-level\n+// index manifest for an OpenTofu provider version.\n+//\n+// If a selected tag refers to a manifest that either lacks an artifact type\n+// or has a different artifact type then OpenTofu will reject it with an\n+// error indicating that it seems to be something other than an OpenTofu provider.\n+const ociIndexManifestArtifactType = \"application/vnd.opentofu.provider\"\n+\n+// ociPackageManifestArtifactType is the artifact type we expect for each of the\n+// individual manifests listed in a provider version's top-level index manifest.\n+//\n+// OpenTofu will silently ignore any listed descriptors that either lack an artifact\n+// type or use a different one, both so that future versions of OpenTofu can\n+// be sensitive to additional artifact types if needed and so that those creating\n+// an artifact can choose to blend in other non-OpenTofu-related artifacts if\n+// they have some reason to do that.\n+//\n+// All descriptors with this artifact type MUST include a \"platform\" object\n+// with \"os\" and \"architecture\" set to match the platform that the individual\n+// package is built for. OpenTofu and OCI both use Go's codenames for operating\n+// systems and CPU architectures, so these fields should exactly match the\n+// names that would be used with this package's [Platform] type.\n+//\n+// OpenTofu does not currently make any use of the other properties defined for\n+// a \"platform\" object, and so will silently ignore any descriptors that set\n+// those properties. Future versions of OpenTofu might be able to use finer-grain\n+// platform selection properties, in which case those versions should treat\n+// a descriptor that uses those additional properties as higher precedence than\n+// one that doesn't so that manifest authors can include both a specific descriptor\n+// and a fallback descriptor with only os/architecture intended for use by\n+// earlier OpenTofu versions.\n+const ociPackageManifestArtifactType = \"application/vnd.opentofu.provider-target\"\n+\n+// ociImageManifestSizeLimit is the maximum size of artifact manifest (aka \"image\n+// manifest\") we'll accept. This 4MiB value matches the recommended limit for\n+// repositories to accept on push from the OCI Distribution v1.1 spec.\n+const ociImageManifestSizeLimitMiB = 4\n+\n+// OCIRegistryMirrorSource is a source that treats one or more repositories\n+// in a registry implementing the OCI Distribution protocol as a kind of\n+// provider mirror.\n+//\n+// This is conceptually similar to [HTTPMirrorSource], but whereas that one\n+// acts as a client for the OpenTofu-specific \"provider mirror protocol\"\n+// this one instead relies on a user-configured template to map provider\n+// source addresses onto OCI repository addresses and then uses tags in\n+// the selected registry to discover the available versions, and OCI\n+// manifests to represent their metadata.\n+//\n+// This implementation is currently intended to be compatible with\n+// OCI Distribution v1.1.\n+type OCIRegistryMirrorSource struct {\n+\t// resolveOCIRepositoryAddr represents this source's rule for mapping\n+\t// OpenTofu-style provider source addresses into OCI Distribution\n+\t// repository addresses, which include both the domain name (and\n+\t// optional port number) of the registry where the repository is\n+\t// hosted and the name of the repository within that registry.\n+\t//\n+\t// This MUST behave as a pure function: a specific given provider\n+\t// address must always return the same results, because it will\n+\t// be called multiple times across the steps of selecting a provider\n+\t// version.\n+\t//\n+\t// Implementers are responsible for somehow dealing with the fact\n+\t// that OpenTofu-style provider source addresses support a\n+\t// considerably wider repertiore of Unicode characters than\n+\t// OCI Distribution repository names do. That could mean either\n+\t// translating unsupported characters into a different\n+\t// representation, or as a last resort returning an error\n+\t// message explaining the problem in terms that make sense for\n+\t// however the end user would've defined the mapping rule.\n+\t//\n+\t// If this function returns with a nil error then registryDomain\n+\t// must be a valid domain name optionally followed by a colon\n+\t// and a decimal port number, and repositoryName must be a string\n+\t// conforming to the \"<name>\" pattern defined in the OCI Distribution\n+\t// specification. The source will return low-quality error messages\n+\t// if the results are unsuitable, and so implementers should prefer\n+\t// to return their own higher-quality error diagnostics if no valid\n+\t// mapping is possible.\n+\t//\n+\t// Any situation where the requested provider cannot be supported\n+\t// _at all_ MUST return an instance of [ErrProviderNotFound] so\n+\t// that a [MultiSource] can successfully blend the results from\n+\t// this and other sources.\n+\tresolveOCIRepositoryAddr func(ctx context.Context, addr addrs.Provider) (registryDomain, repositoryName string, err error)\n+\n+\t// getOCIRepositoryStore is the dependency inversion adapter for\n+\t// obtaining a suitably-configured client for the given repository\n+\t// name on the given OCI Distribution registry domain.\n+\t//\n+\t// If successful, the returned client should be preconfigured with\n+\t// any credentials that are needed to access content from the\n+\t// given repository. Implementers can assume that the client will\n+\t// be used for only a short period after the call to this function,\n+\t// so e.g. it's valid to use time-limited credentials with a validity\n+\t// period on the order of 5 to 10 minutes if appropriate.\n+\t//\n+\t// Errors from this function should represent \"operational-related\"\n+\t// situations like a failure to execute a credentials helper or\n+\t// failure to issue a temporary access token, and will be presented\n+\t// in the UI as a diagnostic with terminology like \"Failed to access\n+\t// OCI registry\".\n+\tgetOCIRepositoryStore func(ctx context.Context, registryDomain, repositoryName string) (OCIRepositoryStore, error)\n+\n+\t// We keep an internal cache of the most-recently-instantiated\n+\t// repository store object because in the common case there will\n+\t// be call to AvailableVersions immediately followed by\n+\t// PackageMeta with the same provider address and this avoids\n+\t// us needing to repeat the translation and instantiation again.\n+\tstoreCacheMutex          sync.Mutex\n+\tstoreCacheProvider       addrs.Provider\n+\tstoreCacheStore          OCIRepositoryStore\n+\tstoreCacheRegistryDomain string\n+\tstoreCacheRepositoryName string\n+}\n+\n+var _ Source = (*OCIRegistryMirrorSource)(nil)\n+\n+// AvailableVersions implements Source.\n+func (o *OCIRegistryMirrorSource) AvailableVersions(ctx context.Context, provider addrs.Provider) (VersionList, Warnings, error) {\n+\tstore, _, _, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar ret VersionList\n+\terr = store.Tags(ctx, \"\", func(tagNames []string) error {\n+\t\tfor _, tagName := range tagNames {\n+\t\t\t// We're only interested in the subset of tag names that we can parse\n+\t\t\t// as version numbers. However, the OCI tag name syntax does not allow\n+\t\t\t// the \"+\" symbol that can appear in the version number syntax, so we\n+\t\t\t// expect the underscore to stand in for that.\n+\t\t\tmaybeVersionStr := strings.ReplaceAll(tagName, \"_\", \"+\")\n+\t\t\tversion, err := versions.ParseVersion(maybeVersionStr)\n+\t\t\tif err != nil {\n+\t\t\t\t// Not a version tag, so ignored.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tret = append(ret, version)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\t// We treat \"not found\" as special because this function might be\n+\t\t\t// called from [MultiSource.AvailableVersions] and that relies\n+\t\t\t// on us returning this specific error type to represent that this\n+\t\t\t// source can't handle the requested provider at all, so that it\n+\t\t\t// can blend the results of multiple sources and only return an\n+\t\t\t// error if _none_ of the eligible sources can handle the\n+\t\t\t// requested provider. We assume that if the given provider address\n+\t\t\t// translated to an OCI repository that doesn't exist then that\n+\t\t\t// means this source does not know anything about that provider,\n+\t\t\t// but other [MultiSource] candidates should still be offered it.\n+\t\t\treturn nil, nil, ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, nil, fmt.Errorf(\"listing tags from OCI repository: %w\", err)\n+\t}\n+\tret.Sort()\n+\treturn ret, nil, nil\n+}\n+\n+// PackageMeta implements Source.\n+func (o *OCIRegistryMirrorSource) PackageMeta(ctx context.Context, provider addrs.Provider, version Version, target Platform) (PackageMeta, error) {\n+\t// Unfortunately we need to repeat our translation from provider address to\n+\t// OCI repository address here, but getRepositoryStore has a cache that\n+\t// allows us to reuse a previously-instantiated store if there are two\n+\t// consecutive calls for the same provider, as is commonly true when first\n+\t// calling AvailableVersions and then calling PackageMeta based on its result.\n+\tstore, registryDomain, repositoryName, err := o.getRepositoryStore(ctx, provider)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The overall process here is:\n+\t// 1. Transform the version number into a tag name and resolve the descriptor\n+\t//    associated with that tag name.\n+\t// 2. Fetch the blob associated with that descriptor, which should be an\n+\t//    index manifest giving a descriptor for each platform supported by this\n+\t//    version of the provider.\n+\t// 3. Choose the descriptor that matches the requested platform.\n+\t// 4. Fetch the blob associated with that second descriptor, which should be\n+\t//    an image manifest that includes a layer descriptor for the blob containing\n+\t//    the actual zip package we need to fetch.\n+\t// 5. Return a PackageMeta whose location is that zip blob, using [PackageOCIBlobArchive].\n+\n+\t// The errors from the following helper functions must not be wrapped by this\n+\t// function because some of them are of specific types that get special\n+\t// treatment by callers.\n+\tindexDesc, err := fetchOCIDescriptorForVersion(ctx, version, store) // step 1\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tindex, err := fetchOCIIndexManifest(ctx, indexDesc, store) // step 2\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageDesc, err := selectOCIImageManifest(index.Manifests, provider, version, target) // step 3\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\timageManifest, err := fetchOCIImageManifest(ctx, imageDesc, store) // step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tblobDesc, err := selectOCILayerBlob(imageManifest.Layers) // a little more of step 4\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\n+\t// The remainder of this is \"step 5\" from the overview above, adapting the information\n+\t// we fetched to suit OpenTofu's provider installer API.\n+\n+\t// We'll announce the OpenTofu-style package hash that we're expecting as part of\n+\t// the metadata. This isn't strictly necessary since OCI blobs are content-addressed\n+\t// anyway and so we'll authenticate it using the same digest that identifies it\n+\t// during the subsequent fetch, but this makes this source consistent with\n+\t// [HTTPMirrorSource] and allows generating an explicit \"checksum verified\"\n+\t// authentication result after install.\n+\texpectedHash, err := hashFromOCIDigest(blobDesc.Digest)\n+\tif err != nil {\n+\t\treturn PackageMeta{}, err\n+\t}\n+\tauthentication := NewPackageHashAuthentication(target, []Hash{expectedHash})\n+\n+\t// If we got through all of the above then we seem to have found a suitable\n+\t// package to install, but our job is only to describe its metadata.\n+\treturn PackageMeta{\n+\t\tProvider:       provider,\n+\t\tVersion:        version,\n+\t\tTargetPlatform: target,\n+\t\tLocation: PackageOCIBlobArchive{\n+\t\t\trepoStore:      store,\n+\t\t\tblobDescriptor: blobDesc,\n+\t\t\tregistryDomain: registryDomain,\n+\t\t\trepositoryName: repositoryName,\n+\t\t},\n+\t\tAuthentication: authentication,\n+\n+\t\t// \"Filename\" isn't really a meaningful concept in an OCI registry, but\n+\t\t// that's okay because we don't care very much about it in OpenTofu\n+\t\t// either and so we can just populate something plausible here. This\n+\t\t// matches the way the package would be named in a traditional\n+\t\t// OpenTofu provider network mirror.\n+\t\tFilename: fmt.Sprintf(\"terraform-provider-%s_%s_%s_%s.zip\", provider.Type, version, target.OS, target.Arch),\n+\n+\t\t// TODO: Define an optional annotation that can announce which protocol\n+\t\t// versions are supported, so we can populate the ProtocolVersions\n+\t\t// field and can fail early if the provider clearly doesn't support\n+\t\t// any of the protocol versions that this OpenTofu version supports.\n+\t\t// Omitting this field is okay though, since some other mirror sources\n+\t\t// can't support it either: that just means that OpenTofu will discover\n+\t\t// the compatibility problem when only after executing the plugin,\n+\t\t// rather than when installing it.\n+\t}, nil\n+}\n+\n+// ForDisplay implements Source.\n+func (o *OCIRegistryMirrorSource) ForDisplay(provider addrs.Provider) string {\n+\t// We don't really have a good concise way to differentiate between\n+\t// instances of this source because the mapping from provider source\n+\t// address to OCI repository address is arbitrarily-defined by the\n+\t// user, so we'll just settle for this right now since this is result\n+\t// only typically used in error messages anyway. If this turns out to\n+\t// be too vague in practice than hopefully whatever complaint caused\n+\t// us to realize that will give a clue as to what additional information\n+\t// is worth including here and where we might derive that information\n+\t// from.\n+\treturn \"OCI registry provider mirror\"\n+}\n+\n+func (o *OCIRegistryMirrorSource) getRepositoryStore(ctx context.Context, provider addrs.Provider) (store OCIRepositoryStore, registryDomain string, repositoryName string, err error) {\n+\to.storeCacheMutex.Lock()\n+\tdefer o.storeCacheMutex.Unlock()\n+\n+\t// If our cache is for the requested provider then we can reuse the store\n+\t// we previously instantiated for this provider.\n+\tif o.storeCacheProvider == provider {\n+\t\treturn o.storeCacheStore, o.storeCacheRegistryDomain, o.storeCacheRepositoryName, nil\n+\t}\n+\n+\t// Otherwise we'll instantiate a new one and overwrite our cache with it.\n+\tregistryDomain, repositoryName, err = o.resolveOCIRepositoryAddr(ctx, provider)\n+\tif err != nil {\n+\t\tif notFoundErr, ok := err.(ErrProviderNotFound); ok {\n+\t\t\t// [MultiSource] relies on this particular error type being returned\n+\t\t\t// directly, without any wrapping.\n+\t\t\treturn nil, \"\", \"\", notFoundErr\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"selecting OCI repository address: %w\", err)\n+\t}\n+\tstore, err = o.getOCIRepositoryStore(ctx, registryDomain, repositoryName)\n+\tif err != nil {\n+\t\tif errors.Is(err, orasErrors.ErrNotFound) {\n+\t\t\treturn nil, \"\", \"\", ErrProviderNotFound{\n+\t\t\t\tProvider: provider,\n+\t\t\t}\n+\t\t}\n+\t\treturn nil, \"\", \"\", fmt.Errorf(\"accessing OCI registry at %s: %w\", registryDomain, err)\n+\t}\n+\to.storeCacheProvider = provider\n+\to.storeCacheStore = store\n+\to.storeCacheRegistryDomain = registryDomain\n+\to.storeCacheRepositoryName = repositoryName\n+\treturn store, registryDomain, repositoryName, nil\n+}\n+\n+// OCIRepositoryStore is the interface used by [OCIRegistryMirrorSource] to\n+// interact with the content in a specific OCI repository.\n+type OCIRepositoryStore interface {\n+\t// Tags lists the tag names available in the repository.\n+\t//\n+\t// The OCI Distribution protocol uses pagination for the tag list and so\n+\t// the given function will be called for each page until either it returns\n+\t// an error or there are no pages left to retrieve.\n+\t//\n+\t// \"last\" is a token used to begin at some point other than the start of\n+\t// the list, but callers in this package always set it to an empty string\n+\t// to represent intent to retrieve the entire list and so implementers are\n+\t// allowed to return an error if \"last\" is non-empty.\n+\tTags(ctx context.Context, last string, fn func(tags []string) error) error\n+\n+\t// Resolve finds the descriptor associated with the given tag name in the\n+\t// repository, if any.\n+\t//\n+\t// tagName MUST conform to the pattern defined for \"<reference> as a tag\"\n+\t// from the OCI distribution specification, or the result is unspecified.\n+\tResolve(ctx context.Context, tagName string) (ociv1.Descriptor, error)\n+\n+\t// Fetch retrieves the content of a specific blob from the repository, identified\n+\t// by the digest in the given descriptor.\n+\t//\n+\t// Implementations of this function tend not to check that the returned content\n+\t// actually matches the digest and size in the descriptor, so callers MUST\n+\t// verify that somehow themselves before making use of the resulting content.\n+\t//\n+\t// Callers MUST close the returned reader after using it, since it's typically\n+\t// connected to an active network socket or file handle.\n+\tFetch(ctx context.Context, target ociv1.Descriptor) (io.ReadCloser, error)\n+\n+\t// The design of the above intentionally matches a subset of the interfaces\n+\t// defined in the ORAS-Go library, but we have our own specific interface here\n+\t// both to clearly define the minimal interface we depend on and so that our\n+\t// use of ORAS-Go can be treated as an implementation detail rather than as\n+\t// an API contract should we need to switch to a different approach in future.\n+\t//\n+\t// If you need to expand this while we're still relying on ORAS-Go, aim to\n+\t// match the corresponding interface in that library if at all possible so\n+\t// that we can minimize the amount of adapter code we need to write.\n+}\n+\n+func fetchOCIDescriptorForVersion(ctx context.Context, version versions.Version, store OCIRepositoryStore) (ociv1.Descriptor, error) {\n+\t// We now need to reverse our convention for mapping versions to tags, in which\n+\t// we replace \"+\" with underscore to conform to the OCI tag name requirements.\n+\ttagName := strings.ReplaceAll(version.String(), \"_\", \"+\")\n+\tdesc, err := store.Resolve(ctx, tagName)\n+\tif err != nil {\n+\t\treturn ociv1.Descriptor{}, fmt.Errorf(\"resolving tag %q: %w\", tagName, err)\n+\t}\n+\tif desc.ArtifactType != ociIndexManifestArtifactType {\n+\t\tswitch desc.ArtifactType {\n+\t\tcase \"application/vnd.opentofu.provider-target\":\n+\t\t\t// We'll get here for an incorrectly-constructed artifact layout where\n+\t\t\t// the tag refers directly to a specific platform's image manifest,\n+\t\t\t// rather than to the multi-platform index manifest.\n+\t\t\treturn desc, fmt.Errorf(\"tag refers directly to image manifest, but OpenTofu providers require an index manifest for multi-platform support\")\n+\t\tcase \"application/vnd.opentofu.modulepkg\":\n+\t\t\t// If this happens to be using our artifact type for module packages then\n+\t\t\t// we'll return a specialized error, since confusion between providers\n+\t\t\t// and modules is common for those new to OpenTofu terminology.\n+\t\t\treturn desc, fmt.Errorf(\"selected OCI artifact is an OpenTofu module package, not a provider package\")\n+\t\tcase \"\":\n+\t\t\t// Prior to there being an explicit way to represent artifact types earlier\n+\t\t\t// attempts to adapt OCI Distribution to non-container-image stuff used\n+\t\t\t// custom layer media types instead. This case also deals with container images\n+\t\t\t// themselves, which are essentially the \"default\" kind of artifact. We\n+\t\t\t// haven't yet fetched the full manifest so we can't actually distinguish\n+\t\t\t// these from the descriptor alone, and so this error message is generic.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type\")\n+\t\tdefault:\n+\t\t\t// For any other artifact type we'll just mention it in the error message\n+\t\t\t// and hope the reader can figure out what that artifact type represents.\n+\t\t\treturn desc, fmt.Errorf(\"unsupported OCI artifact type %q\", desc.ArtifactType)\n+\t\t}\n+\t}\n+\tif desc.MediaType != ociv1.MediaTypeImageIndex {\n+\t\tswitch desc.MediaType {\n+\t\tcase ociv1.MediaTypeImageManifest:\n+\t\t\treturn desc, fmt.Errorf(\"selected an OCI image manifest directly, but providers must be selected through a multi-platform index manifest\")\n+\t\tcase ociv1.MediaTypeDescriptor:\n+\t\t\treturn desc, fmt.Errorf(\"found OCI descriptor but expected multi-platform index manifest\")\n+\t\tdefault:\n+\t\t\treturn desc, fmt.Errorf(\"unsupported media type %q for OCI index manifest\", desc.MediaType)\n+\t\t}\n+\t}\n+\treturn desc, nil\n+}\n+\n+func fetchOCIIndexManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Index, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Index\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an image manifest instead of an index manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Manifest\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageManifest {\n+\t\t\treturn nil, fmt.Errorf(\"found image manifest but need index manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func fetchOCIImageManifest(ctx context.Context, desc ociv1.Descriptor, store OCIRepositoryStore) (*ociv1.Manifest, error) {\n+\tmanifestSrc, err := fetchOCIManifestBlob(ctx, desc, store)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar manifest ociv1.Manifest\n+\terr = json.Unmarshal(manifestSrc, &manifest)\n+\tif err != nil {\n+\t\t// As an aid to debugging, we'll check whether we seem to have retrieved\n+\t\t// an index manifest instead of an image manifest, since an unmarshal\n+\t\t// failure could prevent us from reaching the MediaType check below.\n+\t\tvar manifest ociv1.Index\n+\t\tif err := json.Unmarshal(manifestSrc, &manifest); err == nil && manifest.MediaType == ociv1.MediaTypeImageIndex {\n+\t\t\treturn nil, fmt.Errorf(\"found index manifest but need image manifest\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"invalid manifest content: %w\", err)\n+\t}\n+\n+\t// Now we'll make sure that what we decoded seems vaguely sensible before we\n+\t// return it. Callers are allowed to rely on these checks by verifying\n+\t// that their provided descriptor specifies the wanted media and artifact\n+\t// types before they call this function and then assuming that the result\n+\t// definitely matches what they asked for.\n+\tif manifest.Versioned.SchemaVersion != 2 {\n+\t\treturn nil, fmt.Errorf(\"unsupported manifest schema version %d\", manifest.Versioned.SchemaVersion)\n+\t}\n+\tif manifest.MediaType != desc.MediaType {\n+\t\treturn nil, fmt.Errorf(\"unexpected manifest media type %q\", manifest.MediaType)\n+\t}\n+\tif manifest.ArtifactType != desc.ArtifactType {\n+\t\treturn nil, fmt.Errorf(\"unexpected artifact type %q\", manifest.ArtifactType)\n+\t}\n+\t// We intentionally leave everything else loose so that we'll have flexibility\n+\t// to extend this format in backward-compatible ways in future OpenTofu versions.\n+\treturn &manifest, nil\n+}\n+\n+func selectOCIImageManifest(descs []ociv1.Descriptor, provider addrs.Provider, version versions.Version, target Platform) (ociv1.Descriptor, error) {\n+\tfoundManifests := 0\n+\tvar selected ociv1.Descriptor\n+\tfor _, desc := range descs {\n+\t\tif desc.ArtifactType != ociPackageManifestArtifactType {\n+\t\t\tcontinue // silently ignore anything that isn't claiming to be a provider package manifest",
        "comment_created_at": "2025-03-17T16:24:37+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "I think making log noise here is a tricky tradeoff because having a mixture of OpenTofu manifests and non-OpenTofu manifests in the same index is a reasonable thing to do when integrating with other conventions in the OCI ecosystem.\r\n\r\nIf someone writes a manifest where _all_ of the artifact types are incorrect for OpenTofu then the current code would handle that by saying that the provider doesn't support the target platform, which would be confusing. So I _will_ change this, but I'm thinking about a different change similar to the approach I took for selecting from the \"layers\" in the image manifest: it'll count how many of the listed manifests have the correct artifact type but the wrong platform, and also how many listed manifests have the wrong artifact type, and then at the end of the loop if we have no manifests with the correct artifact type but we have at least one with the incorrect artifact type then we can return an error message that says that the index manifest is incorrect, instead of reporting the \"platform not supported\" error.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1990911625",
    "pr_number": 2579,
    "pr_file": "internal/getproviders/package_location_http_archive.go",
    "created_at": "2025-03-12T08:11:33+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1990911625",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2579,
        "pr_file": "internal/getproviders/package_location_http_archive.go",
        "discussion_id": "1990911625",
        "commented_code": "@@ -0,0 +1,145 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")",
        "comment_created_at": "2025-03-12T08:11:33+00:00",
        "comment_author": "yottta",
        "comment_body": "```suggestion\r\n\t\t\tlogger.Printf(\"[WARN] failed to fetch provider package; retrying\")\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1990911957",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2579,
        "pr_file": "internal/getproviders/package_location_http_archive.go",
        "discussion_id": "1990911625",
        "commented_code": "@@ -0,0 +1,145 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")",
        "comment_created_at": "2025-03-12T08:11:47+00:00",
        "comment_author": "yottta",
        "comment_body": "I would say that this is more of a warning than an info ðŸ¤” Personally, I see INFO as an action that finished and the log needs to show the output of that. Finished in this context mean one of the following:\r\n* that it finished successfully\r\n* it finished with an error but there is a another possible success case on handling that error\r\n\r\nThe fact that an action failed and it's retried, is more of a failure, but not yet an interruptible one.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1990941928",
    "pr_number": 2579,
    "pr_file": "internal/getproviders/package_location_http_archive.go",
    "created_at": "2025-03-12T08:30:34+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1990941928",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2579,
        "pr_file": "internal/getproviders/package_location_http_archive.go",
        "discussion_id": "1990941928",
        "commented_code": "@@ -0,0 +1,145 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")",
        "comment_created_at": "2025-03-12T08:30:34+00:00",
        "comment_author": "Yantrio",
        "comment_body": "food for thought: Do you think it would be nice to include the number of retries here?\r\n\r\nMaybe something like \r\n```go\r\nlogger.Printf(\"[INFO] failed to fetch provider package; retrying attempt %s/%s\", i, maxHTTPPackageRetryCount)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1990945300",
    "pr_number": 2579,
    "pr_file": "internal/getproviders/package_location_http_archive.go",
    "created_at": "2025-03-12T08:32:51+00:00",
    "commented_code": "+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")\n+\t\t}\n+\t}\n+\tretryableClient.Logger = log.New(logging.LogOutput(), \"\", log.Flags())\n+\n+\treq, err := retryablehttp.NewRequestWithContext(ctx, \"GET\", url, nil)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid provider download request: %w\", err)\n+\t}\n+\tresp, err := retryableClient.Do(req)\n+\tif err != nil {\n+\t\tif ctx.Err() == context.Canceled {\n+\t\t\t// \"context canceled\" is not a user-friendly error message,\n+\t\t\t// so we'll return a more appropriate one here.\n+\t\t\treturn nil, fmt.Errorf(\"provider download was interrupted\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"%s: %w\", HostFromRequest(req.Request), err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tif resp.StatusCode != http.StatusOK {\n+\t\treturn nil, fmt.Errorf(\"unsuccessful request to %s: %s\", url, resp.Status)\n+\t}\n+\n+\tf, err := os.CreateTemp(\"\", \"terraform-provider\")\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to open temporary file to download from %s: %w\", url, err)\n+\t}\n+\tdefer f.Close()\n+\tdefer os.Remove(f.Name())\n+\n+\t// We'll borrow go-getter's \"cancelable copy\" implementation here so that\n+\t// the download can potentially be interrupted partway through.\n+\tn, err := getter.Copy(ctx, f, resp.Body)\n+\tif err == nil && n < resp.ContentLength {\n+\t\terr = fmt.Errorf(\"incorrect response size: expected %d bytes, but got %d bytes\", resp.ContentLength, n)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tarchiveFilename := f.Name()\n+\tlocalLocation := PackageLocalArchive(archiveFilename)\n+\n+\tvar authResult *PackageAuthenticationResult\n+\tif meta.Authentication != nil {\n+\t\tif authResult, err = meta.Authentication.AuthenticatePackage(localLocation); err != nil {\n+\t\t\treturn authResult, err\n+\t\t}\n+\t}\n+\n+\t// We can now delegate to localLocation for extraction. To do so,\n+\t// we construct a new package meta description using the local archive\n+\t// path as the location, and skipping authentication. installFromLocalMeta\n+\t// is responsible for verifying that the archive matches the allowedHashes,\n+\t// though.\n+\tlocalMeta := PackageMeta{\n+\t\tProvider:         meta.Provider,\n+\t\tVersion:          meta.Version,\n+\t\tProtocolVersions: meta.ProtocolVersions,\n+\t\tTargetPlatform:   meta.TargetPlatform,\n+\t\tFilename:         meta.Filename,\n+\t\tLocation:         localLocation,\n+\t\tAuthentication:   nil,\n+\t}\n+\tif _, err := localLocation.InstallProviderPackage(ctx, localMeta, targetDir, allowedHashes); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn authResult, nil\n+}\n+\n+const (\n+\t// httpClientRetryCountEnvName is the environment variable name used to customize\n+\t// the HTTP retry count for module downloads.\n+\thttpClientRetryCountEnvName = \"TF_PROVIDER_DOWNLOAD_RETRY\"\n+)\n+\n+//nolint:gochecknoinits // this init function predates our use of this linter\n+func init() {\n+\tconfigureProviderDownloadRetry()\n+}\n+\n+var (\n+\t//nolint:gochecknoglobals // this variable predates our use of this linter\n+\tmaxHTTPPackageRetryCount int\n+)\n+\n+// will attempt for requests with retryable errors, like 502 status codes\n+func configureProviderDownloadRetry() {\n+\tmaxHTTPPackageRetryCount = defaultRetry\n+\tif v := os.Getenv(httpClientRetryCountEnvName); v != \"\" {\n+\t\tretry, err := strconv.Atoi(v)\n+\t\tif err == nil && retry > 0 {\n+\t\t\tmaxHTTPPackageRetryCount = retry\n+\t\t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1990945300",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2579,
        "pr_file": "internal/getproviders/package_location_http_archive.go",
        "discussion_id": "1990945300",
        "commented_code": "@@ -0,0 +1,145 @@\n+// Copyright (c) The OpenTofu Authors\n+// SPDX-License-Identifier: MPL-2.0\n+// Copyright (c) 2023 HashiCorp, Inc.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+package getproviders\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strconv\"\n+\n+\t\"github.com/hashicorp/go-getter\"\n+\t\"github.com/hashicorp/go-retryablehttp\"\n+\t\"github.com/opentofu/opentofu/internal/httpclient\"\n+\t\"github.com/opentofu/opentofu/internal/logging\"\n+)\n+\n+// PackageHTTPURL is a provider package location accessible via HTTP.\n+//\n+// Its value is a URL string using either the http: scheme or the https: scheme.\n+// The URL should respond with a .zip archive whose contents are to be extracted\n+// into a local package directory.\n+type PackageHTTPURL string\n+\n+var _ PackageLocation = PackageHTTPURL(\"\")\n+\n+func (p PackageHTTPURL) String() string { return string(p) }\n+\n+func (p PackageHTTPURL) InstallProviderPackage(ctx context.Context, meta PackageMeta, targetDir string, allowedHashes []Hash) (*PackageAuthenticationResult, error) {\n+\turl := meta.Location.String()\n+\n+\t// When we're installing from an HTTP URL we expect the URL to refer to\n+\t// a zip file. We'll fetch that into a temporary file here and then\n+\t// delegate to installFromLocalArchive below to actually extract it.\n+\t// (We're not using go-getter here because its HTTP getter has a bunch\n+\t// of extraneous functionality we don't need or want, like indirection\n+\t// through X-Terraform-Get header, attempting partial fetches for\n+\t// files that already exist, etc.)\n+\n+\tretryableClient := retryablehttp.NewClient()\n+\tretryableClient.HTTPClient = httpclient.New()\n+\tretryableClient.RetryMax = maxHTTPPackageRetryCount\n+\tretryableClient.RequestLogHook = func(logger retryablehttp.Logger, _ *http.Request, i int) {\n+\t\tif i > 0 {\n+\t\t\tlogger.Printf(\"[INFO] failed to fetch provider package; retrying\")\n+\t\t}\n+\t}\n+\tretryableClient.Logger = log.New(logging.LogOutput(), \"\", log.Flags())\n+\n+\treq, err := retryablehttp.NewRequestWithContext(ctx, \"GET\", url, nil)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"invalid provider download request: %w\", err)\n+\t}\n+\tresp, err := retryableClient.Do(req)\n+\tif err != nil {\n+\t\tif ctx.Err() == context.Canceled {\n+\t\t\t// \"context canceled\" is not a user-friendly error message,\n+\t\t\t// so we'll return a more appropriate one here.\n+\t\t\treturn nil, fmt.Errorf(\"provider download was interrupted\")\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"%s: %w\", HostFromRequest(req.Request), err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tif resp.StatusCode != http.StatusOK {\n+\t\treturn nil, fmt.Errorf(\"unsuccessful request to %s: %s\", url, resp.Status)\n+\t}\n+\n+\tf, err := os.CreateTemp(\"\", \"terraform-provider\")\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to open temporary file to download from %s: %w\", url, err)\n+\t}\n+\tdefer f.Close()\n+\tdefer os.Remove(f.Name())\n+\n+\t// We'll borrow go-getter's \"cancelable copy\" implementation here so that\n+\t// the download can potentially be interrupted partway through.\n+\tn, err := getter.Copy(ctx, f, resp.Body)\n+\tif err == nil && n < resp.ContentLength {\n+\t\terr = fmt.Errorf(\"incorrect response size: expected %d bytes, but got %d bytes\", resp.ContentLength, n)\n+\t}\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tarchiveFilename := f.Name()\n+\tlocalLocation := PackageLocalArchive(archiveFilename)\n+\n+\tvar authResult *PackageAuthenticationResult\n+\tif meta.Authentication != nil {\n+\t\tif authResult, err = meta.Authentication.AuthenticatePackage(localLocation); err != nil {\n+\t\t\treturn authResult, err\n+\t\t}\n+\t}\n+\n+\t// We can now delegate to localLocation for extraction. To do so,\n+\t// we construct a new package meta description using the local archive\n+\t// path as the location, and skipping authentication. installFromLocalMeta\n+\t// is responsible for verifying that the archive matches the allowedHashes,\n+\t// though.\n+\tlocalMeta := PackageMeta{\n+\t\tProvider:         meta.Provider,\n+\t\tVersion:          meta.Version,\n+\t\tProtocolVersions: meta.ProtocolVersions,\n+\t\tTargetPlatform:   meta.TargetPlatform,\n+\t\tFilename:         meta.Filename,\n+\t\tLocation:         localLocation,\n+\t\tAuthentication:   nil,\n+\t}\n+\tif _, err := localLocation.InstallProviderPackage(ctx, localMeta, targetDir, allowedHashes); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn authResult, nil\n+}\n+\n+const (\n+\t// httpClientRetryCountEnvName is the environment variable name used to customize\n+\t// the HTTP retry count for module downloads.\n+\thttpClientRetryCountEnvName = \"TF_PROVIDER_DOWNLOAD_RETRY\"\n+)\n+\n+//nolint:gochecknoinits // this init function predates our use of this linter\n+func init() {\n+\tconfigureProviderDownloadRetry()\n+}\n+\n+var (\n+\t//nolint:gochecknoglobals // this variable predates our use of this linter\n+\tmaxHTTPPackageRetryCount int\n+)\n+\n+// will attempt for requests with retryable errors, like 502 status codes\n+func configureProviderDownloadRetry() {\n+\tmaxHTTPPackageRetryCount = defaultRetry\n+\tif v := os.Getenv(httpClientRetryCountEnvName); v != \"\" {\n+\t\tretry, err := strconv.Atoi(v)\n+\t\tif err == nil && retry > 0 {\n+\t\t\tmaxHTTPPackageRetryCount = retry\n+\t\t}",
        "comment_created_at": "2025-03-12T08:32:51+00:00",
        "comment_author": "Yantrio",
        "comment_body": "Should we also log in the case of an error? (ie, if someone provided a string instead of a number here, or a negative value.",
        "pr_file_module": null
      }
    ]
  }
]