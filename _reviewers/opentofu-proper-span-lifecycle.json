[
  {
    "discussion_id": "2045497130",
    "pr_number": 2665,
    "pr_file": "internal/providercache/installer.go",
    "created_at": "2025-04-15T21:03:02+00:00",
    "commented_code": "if cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2045497130",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-15T21:03:02+00:00",
        "comment_author": "diofeher",
        "comment_body": "Quick question: why in this case are you using `span.End()` in different code paths and not using `defer span.End()` after the assignment?",
        "pr_file_module": null
      },
      {
        "comment_id": "2046319091",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-16T07:51:37+00:00",
        "comment_author": "Yantrio",
        "comment_body": "Because this is inside the loop of `for provider, version := range need {`",
        "pr_file_module": null
      },
      {
        "comment_id": "2046364668",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-16T08:16:54+00:00",
        "comment_author": "yottta",
        "comment_body": "Agree, but really error prone this part. Isn't there a way to extract the content of the `for` loop into a new function?\r\nIf somebody will ever come and add a new conditional `continue` or worse, a `break` or a `return`, that span will never be closed and will create a havoc in the traces.",
        "pr_file_module": null
      },
      {
        "comment_id": "2055656415",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-23T09:33:28+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I didn't want to do large refactorings of existing code in this codebase, plus i feel like this sets a good example of how we should be handling spans in loops anyway.",
        "pr_file_module": null
      },
      {
        "comment_id": "2056024872",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-23T13:11:43+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Another approach that could be considered is something like https://github.com/opentofu/opentofu/pull/1878/files#diff-385ff28969dc6410989718822b4c24e033e3a10d679bdd792fd2d55148c49471R456\r\n\r\nIt's a similar situation where I didn't want to heavily refactor the loop.  It mixes defer and iterative \"actions\" in a way that's comprehensive",
        "pr_file_module": null
      },
      {
        "comment_id": "2056025978",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-23T13:12:15+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Alternatively, this is now the second time we are running into this and should probably take the time to refactor it :D",
        "pr_file_module": null
      },
      {
        "comment_id": "2057854657",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2045497130",
        "commented_code": "@@ -460,6 +473,7 @@ func (i *Installer) ensureProviderVersionsInstall(\n \t\t\t\t\tif cb := evts.ProviderAlreadyInstalled; cb != nil {\n \t\t\t\t\t\tcb(provider, version)\n \t\t\t\t\t}\n+\t\t\t\t\tspan.End()",
        "comment_created_at": "2025-04-24T08:34:27+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I'll rebase ontop of this PR once it's in: https://github.com/opentofu/opentofu/pull/2695",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046346065",
    "pr_number": 2665,
    "pr_file": "internal/command/init.go",
    "created_at": "2025-04-16T08:06:40+00:00",
    "commented_code": "ShowLocalPaths: false, // since they are in a weird location for init\n \t\t}\n \n-\t\tctx, span := tracer.Start(ctx, \"-from-module=...\", trace.WithAttributes(\n-\t\t\tattribute.String(\"module_source\", src),\n+\t\tctx, span := tracing.Tracer().Start(ctx, \"opentofu.init.from_module\", trace.WithAttributes(\n+\t\t\tattribute.String(\"opentofu.module_source\", src),\n \t\t))\n+\t\tdefer span.End()",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2046346065",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/command/init.go",
        "discussion_id": "2046346065",
        "commented_code": "@@ -159,9 +164,10 @@ func (c *InitCommand) Run(args []string) int {\n \t\t\tShowLocalPaths: false, // since they are in a weird location for init\n \t\t}\n \n-\t\tctx, span := tracer.Start(ctx, \"-from-module=...\", trace.WithAttributes(\n-\t\t\tattribute.String(\"module_source\", src),\n+\t\tctx, span := tracing.Tracer().Start(ctx, \"opentofu.init.from_module\", trace.WithAttributes(\n+\t\t\tattribute.String(\"opentofu.module_source\", src),\n \t\t))\n+\t\tdefer span.End()",
        "comment_created_at": "2025-04-16T08:06:40+00:00",
        "comment_author": "yottta",
        "comment_body": "This call here should be removed. Check that `span.End()` is called a little bit down the road.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2056020177",
    "pr_number": 2665,
    "pr_file": "internal/providercache/installer.go",
    "created_at": "2025-04-23T13:09:39+00:00",
    "commented_code": "authResults := map[addrs.Provider]*getproviders.PackageAuthenticationResult{} // record auth results for all successfully fetched providers\n \n \tfor provider, version := range need {\n-\t\tif err := ctx.Err(); err != nil {\n+\t\ttraceCtx, span := tracing.Tracer().Start(ctx,\n+\t\t\t\"Install Provider\",\n+\t\t\ttrace.WithAttributes(\n+\t\t\t\tattribute.String(tracing.ProviderAddressAttributeName, provider.String()),\n+\t\t\t\tattribute.String(tracing.ProviderVersionAttributeName, version.String()),\n+\t\t\t),\n+\t\t)\n+\t\tif err := traceCtx.Err(); err != nil {\n+\t\t\tspan.SetStatus(codes.Error, \"context cancelled\")\n+\t\t\tspan.RecordError(err)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2056020177",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2056020177",
        "commented_code": "@@ -440,7 +444,16 @@ func (i *Installer) ensureProviderVersionsInstall(\n \tauthResults := map[addrs.Provider]*getproviders.PackageAuthenticationResult{} // record auth results for all successfully fetched providers\n \n \tfor provider, version := range need {\n-\t\tif err := ctx.Err(); err != nil {\n+\t\ttraceCtx, span := tracing.Tracer().Start(ctx,\n+\t\t\t\"Install Provider\",\n+\t\t\ttrace.WithAttributes(\n+\t\t\t\tattribute.String(tracing.ProviderAddressAttributeName, provider.String()),\n+\t\t\t\tattribute.String(tracing.ProviderVersionAttributeName, version.String()),\n+\t\t\t),\n+\t\t)\n+\t\tif err := traceCtx.Err(); err != nil {\n+\t\t\tspan.SetStatus(codes.Error, \"context cancelled\")\n+\t\t\tspan.RecordError(err)",
        "comment_created_at": "2025-04-23T13:09:39+00:00",
        "comment_author": "cam72cam",
        "comment_body": "Do you still need to span.End() here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2057867214",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2665,
        "pr_file": "internal/providercache/installer.go",
        "discussion_id": "2056020177",
        "commented_code": "@@ -440,7 +444,16 @@ func (i *Installer) ensureProviderVersionsInstall(\n \tauthResults := map[addrs.Provider]*getproviders.PackageAuthenticationResult{} // record auth results for all successfully fetched providers\n \n \tfor provider, version := range need {\n-\t\tif err := ctx.Err(); err != nil {\n+\t\ttraceCtx, span := tracing.Tracer().Start(ctx,\n+\t\t\t\"Install Provider\",\n+\t\t\ttrace.WithAttributes(\n+\t\t\t\tattribute.String(tracing.ProviderAddressAttributeName, provider.String()),\n+\t\t\t\tattribute.String(tracing.ProviderVersionAttributeName, version.String()),\n+\t\t\t),\n+\t\t)\n+\t\tif err := traceCtx.Err(); err != nil {\n+\t\t\tspan.SetStatus(codes.Error, \"context cancelled\")\n+\t\t\tspan.RecordError(err)",
        "comment_created_at": "2025-04-24T08:41:42+00:00",
        "comment_author": "Yantrio",
        "comment_body": "Yup! I missed this one. thanks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2068065071",
    "pr_number": 2739,
    "pr_file": "cmd/tofu/oci_distribution.go",
    "created_at": "2025-04-30T07:37:14+00:00",
    "commented_code": "// (just because this type name is very long to keep repeating in full)\n \ttype Result = ociauthconfig.DockerCredentialHelperGetResult\n \n+\tctx, span := tracing.Tracer().Start(\n+\t\tctx, \"Query Docker-style credential helper\",\n+\t\totelTrace.WithAttributes(\n+\t\t\totelAttr.String(\"opentofu.oci.docker_credential_helper.name\", helperName),\n+\t\t\totelAttr.String(\"opentofu.oci.registry.url\", serverURL),\n+\t\t),\n+\t)\n+\tdefer span.End()\n+\n \t// We currently use the ORAS-Go implementation of the Docker\n \t// credential helper protocol, because we already depend on\n \t// that library for our OCI registry interactions elsewhere.\n \t// ORAS refers to this protocol as \"native store\", rather\n \t// than \"Docker-style Credential Helper\", but it's the\n \t// same protocol nonetheless.\n \n+\tvar executeSpan otelTrace.Span // ORAS tracing API can't directly propagate span from Start to Done",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2068065071",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2739,
        "pr_file": "cmd/tofu/oci_distribution.go",
        "discussion_id": "2068065071",
        "commented_code": "@@ -120,18 +176,39 @@ func (o ociCredentialsLookupEnv) QueryDockerCredentialHelper(ctx context.Context\n \t// (just because this type name is very long to keep repeating in full)\n \ttype Result = ociauthconfig.DockerCredentialHelperGetResult\n \n+\tctx, span := tracing.Tracer().Start(\n+\t\tctx, \"Query Docker-style credential helper\",\n+\t\totelTrace.WithAttributes(\n+\t\t\totelAttr.String(\"opentofu.oci.docker_credential_helper.name\", helperName),\n+\t\t\totelAttr.String(\"opentofu.oci.registry.url\", serverURL),\n+\t\t),\n+\t)\n+\tdefer span.End()\n+\n \t// We currently use the ORAS-Go implementation of the Docker\n \t// credential helper protocol, because we already depend on\n \t// that library for our OCI registry interactions elsewhere.\n \t// ORAS refers to this protocol as \"native store\", rather\n \t// than \"Docker-style Credential Helper\", but it's the\n \t// same protocol nonetheless.\n \n+\tvar executeSpan otelTrace.Span // ORAS tracing API can't directly propagate span from Start to Done",
        "comment_created_at": "2025-04-30T07:37:14+00:00",
        "comment_author": "Yantrio",
        "comment_body": "Is there a situation where `ExecuteDone` doesn't get fired here and we need to maybe defer ending the span anyway?",
        "pr_file_module": null
      },
      {
        "comment_id": "2068957462",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2739,
        "pr_file": "cmd/tofu/oci_distribution.go",
        "discussion_id": "2068065071",
        "commented_code": "@@ -120,18 +176,39 @@ func (o ociCredentialsLookupEnv) QueryDockerCredentialHelper(ctx context.Context\n \t// (just because this type name is very long to keep repeating in full)\n \ttype Result = ociauthconfig.DockerCredentialHelperGetResult\n \n+\tctx, span := tracing.Tracer().Start(\n+\t\tctx, \"Query Docker-style credential helper\",\n+\t\totelTrace.WithAttributes(\n+\t\t\totelAttr.String(\"opentofu.oci.docker_credential_helper.name\", helperName),\n+\t\t\totelAttr.String(\"opentofu.oci.registry.url\", serverURL),\n+\t\t),\n+\t)\n+\tdefer span.End()\n+\n \t// We currently use the ORAS-Go implementation of the Docker\n \t// credential helper protocol, because we already depend on\n \t// that library for our OCI registry interactions elsewhere.\n \t// ORAS refers to this protocol as \"native store\", rather\n \t// than \"Docker-style Credential Helper\", but it's the\n \t// same protocol nonetheless.\n \n+\tvar executeSpan otelTrace.Span // ORAS tracing API can't directly propagate span from Start to Done",
        "comment_created_at": "2025-04-30T15:44:59+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "The promised behavior for ORAS-Go is that it always calls `ExecuteDone`, whether the execution succeeds or not, and [the current implementation](https://github.com/oras-project/oras-go/blob/753f8a8d98a5ed950366b5580c7edbd204fa5630/registry/remote/credentials/internal/executer/executer.go#L57-L64) seems straightforward and clearly correct in that regard, so I'm personally not concerned about this.\r\n\r\nThe Go OTel tracing documentation doesn't specify whether it's okay to call `span.End` multiple times, but if you know of some other source that promises that multiple calls are always okay then I'd be happy to _also_ include a `defer` for robustness, but in the normal case I think the `span.End` ought to be inside `ExecuteDone` because otherwise this span will be measuring more than what it claims to be measuring, and in that case it'd probably be better to just skip having it at all since it wouldn't be meaningfully different than the parent span. :thinking: \r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2068968153",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2739,
        "pr_file": "cmd/tofu/oci_distribution.go",
        "discussion_id": "2068065071",
        "commented_code": "@@ -120,18 +176,39 @@ func (o ociCredentialsLookupEnv) QueryDockerCredentialHelper(ctx context.Context\n \t// (just because this type name is very long to keep repeating in full)\n \ttype Result = ociauthconfig.DockerCredentialHelperGetResult\n \n+\tctx, span := tracing.Tracer().Start(\n+\t\tctx, \"Query Docker-style credential helper\",\n+\t\totelTrace.WithAttributes(\n+\t\t\totelAttr.String(\"opentofu.oci.docker_credential_helper.name\", helperName),\n+\t\t\totelAttr.String(\"opentofu.oci.registry.url\", serverURL),\n+\t\t),\n+\t)\n+\tdefer span.End()\n+\n \t// We currently use the ORAS-Go implementation of the Docker\n \t// credential helper protocol, because we already depend on\n \t// that library for our OCI registry interactions elsewhere.\n \t// ORAS refers to this protocol as \"native store\", rather\n \t// than \"Docker-style Credential Helper\", but it's the\n \t// same protocol nonetheless.\n \n+\tvar executeSpan otelTrace.Span // ORAS tracing API can't directly propagate span from Start to Done",
        "comment_created_at": "2025-04-30T15:48:44+00:00",
        "comment_author": "Yantrio",
        "comment_body": "That's fine by me then :D ",
        "pr_file_module": null
      }
    ]
  }
]