[
  {
    "discussion_id": "2026730898",
    "pr_number": 2634,
    "pr_file": "internal/lang/evalchecks/eval_for_each.go",
    "created_at": "2025-04-03T10:45:45+00:00",
    "commented_code": "})\n \t}\n \n-\tty := forEachVal.Type()\n-\n-\tvar isAllowedType bool\n+\tretVal := forEachVal\n+\tvar retDiags tfdiags.Diagnostics\n \tvar allowedTypesMessage string\n+\n \tif allowTuple {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType() || ty.IsTupleType()\n \t\tallowedTypesMessage = \"map, set of strings, or a tuple\"\n \t} else {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType()\n \t\tallowedTypesMessage = \"map, or set of strings\"\n \t}\n \n-\t// Check if the type is allowed whether the value is marked or not\n-\tif forEachVal.IsKnown() && !isAllowedType {\n+\tif forEachVal.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity:    hcl.DiagError,\n+\t\t\tSummary:     \"Invalid for_each argument\",\n+\t\t\tDetail:      fmt.Sprintf(`The given \"for_each\" argument value is unsuitable: the given \"for_each\" argument value is null. A %s is allowed.`, allowedTypesMessage),\n+\t\t\tSubject:     expr.Range().Ptr(),\n+\t\t\tExpression:  expr,\n+\t\t\tEvalContext: hclCtx,\n+\t\t})\n+\t}\n+\n+\t// Type Checks\n+\tswitch {\n+\tcase ty.IsSetType():\n+\t\tretVal, retDiags = performSetTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsObjectType() || ty.IsMapType():\n+\t\tretVal, retDiags = performMapTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsTupleType() && allowTuple:\n+\t\t// tuples are allowed for imports\n+\t\tretVal, retDiags = performTupleTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty == cty.DynamicPseudoType:\n+\t\tretVal, retDiags = performDynamicTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsCollectionType() && markSafeLengthInt(forEachVal) == 0:\n+\t\t// If the map is empty ({}), return an empty map, because cty will\n+\t\t// return nil when representing {} AsValueMap. This also covers an empty\n+\t\t// set (toset([]))\n+\t\treturn retVal, diags\n+\tdefault:\n+\t\tretVal = cty.NullVal(ty)",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2026730898",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2634,
        "pr_file": "internal/lang/evalchecks/eval_for_each.go",
        "discussion_id": "2026730898",
        "commented_code": "@@ -92,20 +94,45 @@ func EvaluateForEachExpressionValue(expr hcl.Expression, ctx ContextFunc, allowU\n \t\t})\n \t}\n \n-\tty := forEachVal.Type()\n-\n-\tvar isAllowedType bool\n+\tretVal := forEachVal\n+\tvar retDiags tfdiags.Diagnostics\n \tvar allowedTypesMessage string\n+\n \tif allowTuple {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType() || ty.IsTupleType()\n \t\tallowedTypesMessage = \"map, set of strings, or a tuple\"\n \t} else {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType()\n \t\tallowedTypesMessage = \"map, or set of strings\"\n \t}\n \n-\t// Check if the type is allowed whether the value is marked or not\n-\tif forEachVal.IsKnown() && !isAllowedType {\n+\tif forEachVal.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity:    hcl.DiagError,\n+\t\t\tSummary:     \"Invalid for_each argument\",\n+\t\t\tDetail:      fmt.Sprintf(`The given \"for_each\" argument value is unsuitable: the given \"for_each\" argument value is null. A %s is allowed.`, allowedTypesMessage),\n+\t\t\tSubject:     expr.Range().Ptr(),\n+\t\t\tExpression:  expr,\n+\t\t\tEvalContext: hclCtx,\n+\t\t})\n+\t}\n+\n+\t// Type Checks\n+\tswitch {\n+\tcase ty.IsSetType():\n+\t\tretVal, retDiags = performSetTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsObjectType() || ty.IsMapType():\n+\t\tretVal, retDiags = performMapTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsTupleType() && allowTuple:\n+\t\t// tuples are allowed for imports\n+\t\tretVal, retDiags = performTupleTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty == cty.DynamicPseudoType:\n+\t\tretVal, retDiags = performDynamicTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsCollectionType() && markSafeLengthInt(forEachVal) == 0:\n+\t\t// If the map is empty ({}), return an empty map, because cty will\n+\t\t// return nil when representing {} AsValueMap. This also covers an empty\n+\t\t// set (toset([]))\n+\t\treturn retVal, diags\n+\tdefault:\n+\t\tretVal = cty.NullVal(ty)",
        "comment_created_at": "2025-04-03T10:45:45+00:00",
        "comment_author": "ollevche",
        "comment_body": "we can return early here since we will return anyway right after the switch-case",
        "pr_file_module": null
      },
      {
        "comment_id": "2035436023",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2634,
        "pr_file": "internal/lang/evalchecks/eval_for_each.go",
        "discussion_id": "2026730898",
        "commented_code": "@@ -92,20 +94,45 @@ func EvaluateForEachExpressionValue(expr hcl.Expression, ctx ContextFunc, allowU\n \t\t})\n \t}\n \n-\tty := forEachVal.Type()\n-\n-\tvar isAllowedType bool\n+\tretVal := forEachVal\n+\tvar retDiags tfdiags.Diagnostics\n \tvar allowedTypesMessage string\n+\n \tif allowTuple {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType() || ty.IsTupleType()\n \t\tallowedTypesMessage = \"map, set of strings, or a tuple\"\n \t} else {\n-\t\tisAllowedType = ty.IsMapType() || ty.IsSetType() || ty.IsObjectType()\n \t\tallowedTypesMessage = \"map, or set of strings\"\n \t}\n \n-\t// Check if the type is allowed whether the value is marked or not\n-\tif forEachVal.IsKnown() && !isAllowedType {\n+\tif forEachVal.IsNull() {\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity:    hcl.DiagError,\n+\t\t\tSummary:     \"Invalid for_each argument\",\n+\t\t\tDetail:      fmt.Sprintf(`The given \"for_each\" argument value is unsuitable: the given \"for_each\" argument value is null. A %s is allowed.`, allowedTypesMessage),\n+\t\t\tSubject:     expr.Range().Ptr(),\n+\t\t\tExpression:  expr,\n+\t\t\tEvalContext: hclCtx,\n+\t\t})\n+\t}\n+\n+\t// Type Checks\n+\tswitch {\n+\tcase ty.IsSetType():\n+\t\tretVal, retDiags = performSetTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsObjectType() || ty.IsMapType():\n+\t\tretVal, retDiags = performMapTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsTupleType() && allowTuple:\n+\t\t// tuples are allowed for imports\n+\t\tretVal, retDiags = performTupleTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty == cty.DynamicPseudoType:\n+\t\tretVal, retDiags = performDynamicTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\tcase ty.IsCollectionType() && markSafeLengthInt(forEachVal) == 0:\n+\t\t// If the map is empty ({}), return an empty map, because cty will\n+\t\t// return nil when representing {} AsValueMap. This also covers an empty\n+\t\t// set (toset([]))\n+\t\treturn retVal, diags\n+\tdefault:\n+\t\tretVal = cty.NullVal(ty)",
        "comment_created_at": "2025-04-09T13:56:11+00:00",
        "comment_author": "diofeher",
        "comment_body": "Agreed! Fixed on https://github.com/opentofu/opentofu/pull/2634/commits/d4ee377e1a444442f339c842b061f751167a2d13",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1979647406",
    "pr_number": 2552,
    "pr_file": "internal/lang/evalchecks/eval_for_each.go",
    "created_at": "2025-03-04T15:05:20+00:00",
    "commented_code": "Expression:  expr,\n \t\t\tEvalContext: hclCtx,\n \t\t})\n-\t\treturn nullMap, diags\n-\tcase !forEachVal.IsKnown():\n-\t\tif !allowUnknown {\n-\t\t\tvar detailMsg string\n-\t\t\tswitch {\n-\t\t\tcase ty.IsSetType():\n-\t\t\t\tdetailMsg = errInvalidUnknownDetailSet\n-\t\t\tdefault:\n-\t\t\t\tdetailMsg = errInvalidUnknownDetailMap\n-\t\t\t}\n-\t\t\tdetailMsg += forEachCommandLineExcludeSuggestion(excludableAddr)\n-\n-\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n-\t\t\t\tSeverity:    hcl.DiagError,\n-\t\t\t\tSummary:     \"Invalid for_each argument\",\n-\t\t\t\tDetail:      detailMsg,\n-\t\t\t\tSubject:     expr.Range().Ptr(),\n-\t\t\t\tExpression:  expr,\n-\t\t\t\tEvalContext: hclCtx,\n-\t\t\t\tExtra:       DiagnosticCausedByUnknown(true),\n-\t\t\t})\n-\t\t}\n-\t\t// ensure that we have a map, and not a DynamicValue\n-\t\treturn cty.UnknownVal(cty.Map(cty.DynamicPseudoType)), diags\n+\t\treturn cty.NullVal(cty.Map(cty.DynamicPseudoType)), diags\n \tcase markSafeLengthInt(forEachVal) == 0:\n \t\t// If the map is empty ({}), return an empty map, because cty will\n \t\t// return nil when representing {} AsValueMap. This also covers an empty\n \t\t// set (toset([]))\n \t\treturn forEachVal, diags\n+\tcase ty.IsSetType():\n+\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, allowedTypesMessage, forEachVal, excludableAddr)\n+\t\tdiags = diags.Append(setTypeDiags)\n+\t\tif diags.HasErrors() {\n+\t\t\treturn setVal, diags\n+\t\t}\n \t}\n \n-\tif ty.IsSetType() {\n-\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\treturn forEachVal, diags\n+}\n+\n+func performForEachValueChecksUnknown(expr hcl.Expression, hclCtx *hcl.EvalContext, allowUnknown bool, forEachVal cty.Value, allowedTypesMessage string, excludableAddr addrs.Targetable) (cty.Value, tfdiags.Diagnostics) {\n+\tvar diags tfdiags.Diagnostics\n+\tty := forEachVal.Type()\n+\n+\tswitch {\n+\tcase !allowUnknown:\n+\t\tvar detailMsg string\n+\t\tswitch {\n+\t\tcase ty.IsSetType():\n+\t\t\tdetailMsg = errInvalidUnknownDetailSet\n+\t\tdefault:\n+\t\t\tdetailMsg = errInvalidUnknownDetailMap\n+\t\t}\n+\t\tdetailMsg += forEachCommandLineExcludeSuggestion(excludableAddr)\n+\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity:    hcl.DiagError,\n+\t\t\tSummary:     \"Invalid for_each argument\",\n+\t\t\tDetail:      detailMsg,\n+\t\t\tSubject:     expr.Range().Ptr(),\n+\t\t\tExpression:  expr,\n+\t\t\tEvalContext: hclCtx,\n+\t\t\tExtra:       DiagnosticCausedByUnknown(true),\n+\t\t})\n+\tcase ty.IsSetType():\n+\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, allowedTypesMessage, forEachVal, excludableAddr)\n \t\tdiags = diags.Append(setTypeDiags)\n \t\tif diags.HasErrors() {\n \t\t\treturn setVal, diags\n \t\t}\n+\t\t// ensure that we have a set, and not a DynamicValue\n+\t\treturn cty.UnknownVal(cty.Set(cty.DynamicPseudoType)), diags\n \t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1979647406",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2552,
        "pr_file": "internal/lang/evalchecks/eval_for_each.go",
        "discussion_id": "1979647406",
        "commented_code": "@@ -145,71 +151,94 @@ func performForEachValueChecks(expr hcl.Expression, hclCtx *hcl.EvalContext, all\n \t\t\tExpression:  expr,\n \t\t\tEvalContext: hclCtx,\n \t\t})\n-\t\treturn nullMap, diags\n-\tcase !forEachVal.IsKnown():\n-\t\tif !allowUnknown {\n-\t\t\tvar detailMsg string\n-\t\t\tswitch {\n-\t\t\tcase ty.IsSetType():\n-\t\t\t\tdetailMsg = errInvalidUnknownDetailSet\n-\t\t\tdefault:\n-\t\t\t\tdetailMsg = errInvalidUnknownDetailMap\n-\t\t\t}\n-\t\t\tdetailMsg += forEachCommandLineExcludeSuggestion(excludableAddr)\n-\n-\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n-\t\t\t\tSeverity:    hcl.DiagError,\n-\t\t\t\tSummary:     \"Invalid for_each argument\",\n-\t\t\t\tDetail:      detailMsg,\n-\t\t\t\tSubject:     expr.Range().Ptr(),\n-\t\t\t\tExpression:  expr,\n-\t\t\t\tEvalContext: hclCtx,\n-\t\t\t\tExtra:       DiagnosticCausedByUnknown(true),\n-\t\t\t})\n-\t\t}\n-\t\t// ensure that we have a map, and not a DynamicValue\n-\t\treturn cty.UnknownVal(cty.Map(cty.DynamicPseudoType)), diags\n+\t\treturn cty.NullVal(cty.Map(cty.DynamicPseudoType)), diags\n \tcase markSafeLengthInt(forEachVal) == 0:\n \t\t// If the map is empty ({}), return an empty map, because cty will\n \t\t// return nil when representing {} AsValueMap. This also covers an empty\n \t\t// set (toset([]))\n \t\treturn forEachVal, diags\n+\tcase ty.IsSetType():\n+\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, allowedTypesMessage, forEachVal, excludableAddr)\n+\t\tdiags = diags.Append(setTypeDiags)\n+\t\tif diags.HasErrors() {\n+\t\t\treturn setVal, diags\n+\t\t}\n \t}\n \n-\tif ty.IsSetType() {\n-\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, forEachVal, excludableAddr)\n+\treturn forEachVal, diags\n+}\n+\n+func performForEachValueChecksUnknown(expr hcl.Expression, hclCtx *hcl.EvalContext, allowUnknown bool, forEachVal cty.Value, allowedTypesMessage string, excludableAddr addrs.Targetable) (cty.Value, tfdiags.Diagnostics) {\n+\tvar diags tfdiags.Diagnostics\n+\tty := forEachVal.Type()\n+\n+\tswitch {\n+\tcase !allowUnknown:\n+\t\tvar detailMsg string\n+\t\tswitch {\n+\t\tcase ty.IsSetType():\n+\t\t\tdetailMsg = errInvalidUnknownDetailSet\n+\t\tdefault:\n+\t\t\tdetailMsg = errInvalidUnknownDetailMap\n+\t\t}\n+\t\tdetailMsg += forEachCommandLineExcludeSuggestion(excludableAddr)\n+\n+\t\tdiags = diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity:    hcl.DiagError,\n+\t\t\tSummary:     \"Invalid for_each argument\",\n+\t\t\tDetail:      detailMsg,\n+\t\t\tSubject:     expr.Range().Ptr(),\n+\t\t\tExpression:  expr,\n+\t\t\tEvalContext: hclCtx,\n+\t\t\tExtra:       DiagnosticCausedByUnknown(true),\n+\t\t})\n+\tcase ty.IsSetType():\n+\t\tsetVal, setTypeDiags := performSetTypeChecks(expr, hclCtx, allowUnknown, allowedTypesMessage, forEachVal, excludableAddr)\n \t\tdiags = diags.Append(setTypeDiags)\n \t\tif diags.HasErrors() {\n \t\t\treturn setVal, diags\n \t\t}\n+\t\t// ensure that we have a set, and not a DynamicValue\n+\t\treturn cty.UnknownVal(cty.Set(cty.DynamicPseudoType)), diags\n \t}",
        "comment_created_at": "2025-03-04T15:05:20+00:00",
        "comment_author": "Gogotchuri",
        "comment_body": "I understand this is moved over here from the previous version, but we should probably remove the doubly nested switch statements, in favor of if statements and early return, which will make the segment a bit more readable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1800770229",
    "pr_number": 2069,
    "pr_file": "internal/tofu/transform_provider.go",
    "created_at": "2024-10-15T09:16:19+00:00",
    "commented_code": "var diags tfdiags.Diagnostics\n \n-\t// To start, we'll collect the _requested_ provider addresses for each\n-\t// node, which we'll then resolve (handling provider inheritance, etc) in\n-\t// the next step.\n-\t// Our \"requested\" map is from graph vertices to string representations of\n-\t// provider config addresses (for deduping) to requests.\n-\ttype ProviderRequest struct {\n-\t\tAddr  addrs.AbsProviderConfig\n-\t\tExact bool // If true, inheritance from parent modules is not attempted\n-\t}\n-\trequested := map[dag.Vertex]map[string]ProviderRequest{}\n-\tneedConfigured := map[string]addrs.AbsProviderConfig{}\n+\t// Now we'll go through all the requested addresses we just collected and\n+\t// figure out which _actual_ config address each belongs to, after resolving\n+\t// for provider inheritance and passing.\n+\tm := providerVertexMap(g)\n \tfor _, v := range g.Vertices() {\n-\t\t// Does the vertex _directly_ use a provider?\n \t\tif pv, ok := v.(GraphNodeProviderConsumer); ok {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1800770229",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2069,
        "pr_file": "internal/tofu/transform_provider.go",
        "discussion_id": "1800770229",
        "commented_code": "@@ -102,147 +103,96 @@ func (t *ProviderTransformer) Transform(g *Graph) error {\n \n \tvar diags tfdiags.Diagnostics\n \n-\t// To start, we'll collect the _requested_ provider addresses for each\n-\t// node, which we'll then resolve (handling provider inheritance, etc) in\n-\t// the next step.\n-\t// Our \"requested\" map is from graph vertices to string representations of\n-\t// provider config addresses (for deduping) to requests.\n-\ttype ProviderRequest struct {\n-\t\tAddr  addrs.AbsProviderConfig\n-\t\tExact bool // If true, inheritance from parent modules is not attempted\n-\t}\n-\trequested := map[dag.Vertex]map[string]ProviderRequest{}\n-\tneedConfigured := map[string]addrs.AbsProviderConfig{}\n+\t// Now we'll go through all the requested addresses we just collected and\n+\t// figure out which _actual_ config address each belongs to, after resolving\n+\t// for provider inheritance and passing.\n+\tm := providerVertexMap(g)\n \tfor _, v := range g.Vertices() {\n-\t\t// Does the vertex _directly_ use a provider?\n \t\tif pv, ok := v.(GraphNodeProviderConsumer); ok {",
        "comment_created_at": "2024-10-15T09:16:19+00:00",
        "comment_author": "ollevche",
        "comment_body": "let's reduce nesting here:\r\n\r\n```suggestion\r\n\t\tif pv, ok := v.(GraphNodeProviderConsumer); !ok {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\t...\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1800973893",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2069,
        "pr_file": "internal/tofu/transform_provider.go",
        "discussion_id": "1800770229",
        "commented_code": "@@ -102,147 +103,96 @@ func (t *ProviderTransformer) Transform(g *Graph) error {\n \n \tvar diags tfdiags.Diagnostics\n \n-\t// To start, we'll collect the _requested_ provider addresses for each\n-\t// node, which we'll then resolve (handling provider inheritance, etc) in\n-\t// the next step.\n-\t// Our \"requested\" map is from graph vertices to string representations of\n-\t// provider config addresses (for deduping) to requests.\n-\ttype ProviderRequest struct {\n-\t\tAddr  addrs.AbsProviderConfig\n-\t\tExact bool // If true, inheritance from parent modules is not attempted\n-\t}\n-\trequested := map[dag.Vertex]map[string]ProviderRequest{}\n-\tneedConfigured := map[string]addrs.AbsProviderConfig{}\n+\t// Now we'll go through all the requested addresses we just collected and\n+\t// figure out which _actual_ config address each belongs to, after resolving\n+\t// for provider inheritance and passing.\n+\tm := providerVertexMap(g)\n \tfor _, v := range g.Vertices() {\n-\t\t// Does the vertex _directly_ use a provider?\n \t\tif pv, ok := v.(GraphNodeProviderConsumer); ok {",
        "comment_created_at": "2024-10-15T11:18:10+00:00",
        "comment_author": "cam72cam",
        "comment_body": "We use pv below and can't omit the value here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1800979367",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2069,
        "pr_file": "internal/tofu/transform_provider.go",
        "discussion_id": "1800770229",
        "commented_code": "@@ -102,147 +103,96 @@ func (t *ProviderTransformer) Transform(g *Graph) error {\n \n \tvar diags tfdiags.Diagnostics\n \n-\t// To start, we'll collect the _requested_ provider addresses for each\n-\t// node, which we'll then resolve (handling provider inheritance, etc) in\n-\t// the next step.\n-\t// Our \"requested\" map is from graph vertices to string representations of\n-\t// provider config addresses (for deduping) to requests.\n-\ttype ProviderRequest struct {\n-\t\tAddr  addrs.AbsProviderConfig\n-\t\tExact bool // If true, inheritance from parent modules is not attempted\n-\t}\n-\trequested := map[dag.Vertex]map[string]ProviderRequest{}\n-\tneedConfigured := map[string]addrs.AbsProviderConfig{}\n+\t// Now we'll go through all the requested addresses we just collected and\n+\t// figure out which _actual_ config address each belongs to, after resolving\n+\t// for provider inheritance and passing.\n+\tm := providerVertexMap(g)\n \tfor _, v := range g.Vertices() {\n-\t\t// Does the vertex _directly_ use a provider?\n \t\tif pv, ok := v.(GraphNodeProviderConsumer); ok {",
        "comment_created_at": "2024-10-15T11:22:10+00:00",
        "comment_author": "cam72cam",
        "comment_body": "[1a5e1ec](https://github.com/opentofu/opentofu/pull/2069/commits/1a5e1ec2d8b9938424e22ce2ff24936c96a769d4)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1740995152",
    "pr_number": 1959,
    "pr_file": "internal/configs/resource.go",
    "created_at": "2024-09-02T14:23:34+00:00",
    "commented_code": "})\n \t}\n \n-\t// TODO/Oleksandr: Is static identifier valid if we evaluate for_each for alias?\n-\tinstances, instancesDiags := eval.Evaluate(forEach, aliasStaticID)\n+\tinstances, instancesDiags := eval.Evaluate(instanceExpr, aliasStaticID)\n \tdiags = diags.Extend(instancesDiags)\n \tif instancesDiags.HasErrors() {\n \t\treturn diags\n \t}\n \n-\tif !instances.CanIterateElements() {\n-\t\tpanic(\"decodeStaticAlias must be called with for each expression: wrong expression?\")\n-\t}\n-\n-\taliases := make(map[addrs.InstanceKey]string)\n+\tvar aliases map[addrs.InstanceKey]string\n+\tvar aliasDiags hcl.Diagnostics\n \n-\tinstanceIter := instances.ElementIterator()\n-\tfor instanceIter.Next() {\n-\t\tk, v := instanceIter.Element()\n-\n-\t\tinstanceEvalCtx := aliasEvalCtx.NewChild()\n-\t\tinstanceEvalCtx.Variables = map[string]cty.Value{\n-\t\t\t\"each\": cty.ObjectVal(map[string]cty.Value{\n-\t\t\t\t\"key\":   k,\n-\t\t\t\t\"value\": v,\n-\t\t\t}),\n-\t\t}\n-\n-\t\taliasVal, aliasDiags := m.Alias.Value(instanceEvalCtx)\n-\t\tdiags = diags.Extend(aliasDiags)\n-\t\tif aliasDiags.HasErrors() {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif !aliasVal.Type().Equals(cty.String) {\n-\t\t\t// TODO/Oleksandr: add friendly error\n-\t\t\treturn diags.Append(&hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid alias\",\n-\t\t\t\tDetail:   \"\",\n-\t\t\t\tSubject:  m.Alias.Range().Ptr(),\n-\t\t\t})\n-\t\t}\n-\n-\t\tinstanceKey, err := addrs.ParseInstanceKey(k)\n-\t\tif err != nil {\n-\t\t\tpanic(\"decodeStaticAlias failed to parse for each instance keys: wrong expression?\")\n-\t\t}\n-\n-\t\taliases[instanceKey] = aliasVal.AsString()\n+\tswitch {\n+\tcase hasEachRefInAlias:\n+\t\taliases, aliasDiags = generateForEachAliases(instances, aliasEvalCtx, m.Alias)\n+\tcase hasCountRefInAlias:\n+\t\taliases, aliasDiags = generateCountAliases(instances, aliasEvalCtx, m.Alias)\n \t}\n \n-\tif !diags.HasErrors() {\n+\tdiags = diags.Extend(aliasDiags)\n+\tif !aliasDiags.HasErrors() {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1740995152",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1959,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "1740995152",
        "commented_code": "@@ -813,56 +929,24 @@ func (m *ProviderConfigRefMapping) decodeStaticAlias(eval *StaticEvaluator, forE\n \t\t})\n \t}\n \n-\t// TODO/Oleksandr: Is static identifier valid if we evaluate for_each for alias?\n-\tinstances, instancesDiags := eval.Evaluate(forEach, aliasStaticID)\n+\tinstances, instancesDiags := eval.Evaluate(instanceExpr, aliasStaticID)\n \tdiags = diags.Extend(instancesDiags)\n \tif instancesDiags.HasErrors() {\n \t\treturn diags\n \t}\n \n-\tif !instances.CanIterateElements() {\n-\t\tpanic(\"decodeStaticAlias must be called with for each expression: wrong expression?\")\n-\t}\n-\n-\taliases := make(map[addrs.InstanceKey]string)\n+\tvar aliases map[addrs.InstanceKey]string\n+\tvar aliasDiags hcl.Diagnostics\n \n-\tinstanceIter := instances.ElementIterator()\n-\tfor instanceIter.Next() {\n-\t\tk, v := instanceIter.Element()\n-\n-\t\tinstanceEvalCtx := aliasEvalCtx.NewChild()\n-\t\tinstanceEvalCtx.Variables = map[string]cty.Value{\n-\t\t\t\"each\": cty.ObjectVal(map[string]cty.Value{\n-\t\t\t\t\"key\":   k,\n-\t\t\t\t\"value\": v,\n-\t\t\t}),\n-\t\t}\n-\n-\t\taliasVal, aliasDiags := m.Alias.Value(instanceEvalCtx)\n-\t\tdiags = diags.Extend(aliasDiags)\n-\t\tif aliasDiags.HasErrors() {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif !aliasVal.Type().Equals(cty.String) {\n-\t\t\t// TODO/Oleksandr: add friendly error\n-\t\t\treturn diags.Append(&hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid alias\",\n-\t\t\t\tDetail:   \"\",\n-\t\t\t\tSubject:  m.Alias.Range().Ptr(),\n-\t\t\t})\n-\t\t}\n-\n-\t\tinstanceKey, err := addrs.ParseInstanceKey(k)\n-\t\tif err != nil {\n-\t\t\tpanic(\"decodeStaticAlias failed to parse for each instance keys: wrong expression?\")\n-\t\t}\n-\n-\t\taliases[instanceKey] = aliasVal.AsString()\n+\tswitch {\n+\tcase hasEachRefInAlias:\n+\t\taliases, aliasDiags = generateForEachAliases(instances, aliasEvalCtx, m.Alias)\n+\tcase hasCountRefInAlias:\n+\t\taliases, aliasDiags = generateCountAliases(instances, aliasEvalCtx, m.Alias)\n \t}\n \n-\tif !diags.HasErrors() {\n+\tdiags = diags.Extend(aliasDiags)\n+\tif !aliasDiags.HasErrors() {",
        "comment_created_at": "2024-09-02T14:23:34+00:00",
        "comment_author": "Andrew-Hayes",
        "comment_body": "this is more of a tidy up on the existing code. should we tweak this last bit to be more idiomatic? \r\n\r\n```\r\ndiags = diags.Extend(aliasDiags)\r\nif aliasDiags.HasErrors() {\r\n    return diags\r\n}\r\n\r\nm.Aliases = aliases\r\nreturn diags\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1741071564",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1959,
        "pr_file": "internal/configs/resource.go",
        "discussion_id": "1740995152",
        "commented_code": "@@ -813,56 +929,24 @@ func (m *ProviderConfigRefMapping) decodeStaticAlias(eval *StaticEvaluator, forE\n \t\t})\n \t}\n \n-\t// TODO/Oleksandr: Is static identifier valid if we evaluate for_each for alias?\n-\tinstances, instancesDiags := eval.Evaluate(forEach, aliasStaticID)\n+\tinstances, instancesDiags := eval.Evaluate(instanceExpr, aliasStaticID)\n \tdiags = diags.Extend(instancesDiags)\n \tif instancesDiags.HasErrors() {\n \t\treturn diags\n \t}\n \n-\tif !instances.CanIterateElements() {\n-\t\tpanic(\"decodeStaticAlias must be called with for each expression: wrong expression?\")\n-\t}\n-\n-\taliases := make(map[addrs.InstanceKey]string)\n+\tvar aliases map[addrs.InstanceKey]string\n+\tvar aliasDiags hcl.Diagnostics\n \n-\tinstanceIter := instances.ElementIterator()\n-\tfor instanceIter.Next() {\n-\t\tk, v := instanceIter.Element()\n-\n-\t\tinstanceEvalCtx := aliasEvalCtx.NewChild()\n-\t\tinstanceEvalCtx.Variables = map[string]cty.Value{\n-\t\t\t\"each\": cty.ObjectVal(map[string]cty.Value{\n-\t\t\t\t\"key\":   k,\n-\t\t\t\t\"value\": v,\n-\t\t\t}),\n-\t\t}\n-\n-\t\taliasVal, aliasDiags := m.Alias.Value(instanceEvalCtx)\n-\t\tdiags = diags.Extend(aliasDiags)\n-\t\tif aliasDiags.HasErrors() {\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif !aliasVal.Type().Equals(cty.String) {\n-\t\t\t// TODO/Oleksandr: add friendly error\n-\t\t\treturn diags.Append(&hcl.Diagnostic{\n-\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\tSummary:  \"Invalid alias\",\n-\t\t\t\tDetail:   \"\",\n-\t\t\t\tSubject:  m.Alias.Range().Ptr(),\n-\t\t\t})\n-\t\t}\n-\n-\t\tinstanceKey, err := addrs.ParseInstanceKey(k)\n-\t\tif err != nil {\n-\t\t\tpanic(\"decodeStaticAlias failed to parse for each instance keys: wrong expression?\")\n-\t\t}\n-\n-\t\taliases[instanceKey] = aliasVal.AsString()\n+\tswitch {\n+\tcase hasEachRefInAlias:\n+\t\taliases, aliasDiags = generateForEachAliases(instances, aliasEvalCtx, m.Alias)\n+\tcase hasCountRefInAlias:\n+\t\taliases, aliasDiags = generateCountAliases(instances, aliasEvalCtx, m.Alias)\n \t}\n \n-\tif !diags.HasErrors() {\n+\tdiags = diags.Extend(aliasDiags)\n+\tif !aliasDiags.HasErrors() {",
        "comment_created_at": "2024-09-02T15:31:03+00:00",
        "comment_author": "ollevche",
        "comment_body": "Thanks! Made it more idiomatic in [8075c3f](https://github.com/opentofu/opentofu/pull/1959/commits/8075c3f26301c29062c5e2568f6bba9a762b71c5)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1656693353",
    "pr_number": 1750,
    "pr_file": "internal/lang/eval.go",
    "created_at": "2024-06-27T08:25:47+00:00",
    "commented_code": "// it, since that allows us to gather a full set of any errors and\n \t// warnings, but once we've gathered all the data we'll then skip anything\n \t// that's redundant in the process of populating our values map.\n-\tdataResources := map[string]map[string]cty.Value{}\n-\tmanagedResources := map[string]map[string]cty.Value{}\n-\twholeModules := map[string]cty.Value{}\n-\tinputVariables := map[string]cty.Value{}\n-\tlocalValues := map[string]cty.Value{}\n-\toutputValues := map[string]cty.Value{}\n-\tpathAttrs := map[string]cty.Value{}\n-\tterraformAttrs := map[string]cty.Value{}\n-\tcountAttrs := map[string]cty.Value{}\n-\tforEachAttrs := map[string]cty.Value{}\n-\tcheckBlocks := map[string]cty.Value{}\n-\tvar self cty.Value\n+\tvarBuilder := s.newEvalVarBuilder()\n \n \tfor _, ref := range refs {\n-\t\trng := ref.SourceRange\n-\n-\t\trawSubj := ref.Subject\n-\t\tif rawSubj == addrs.Self {\n-\t\t\tif selfAddr == nil {\n-\t\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n-\t\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\t\tSummary:  `Invalid \"self\" reference`,\n-\t\t\t\t\t// This detail message mentions some current practice that\n-\t\t\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n-\t\t\t\t\t// object starts being supported in more contexts later then\n-\t\t\t\t\t// we'll need to adjust this message.\n-\t\t\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n-\t\t\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n-\t\t\t\t})\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tif ref.Subject == addrs.Self {\n+\t\t\tdiags.Append(varBuilder.putSelfValue(selfAddr, ref))\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tif selfAddr == addrs.Self {\n-\t\t\t\t// Programming error: the self address cannot alias itself.\n-\t\t\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t\tif subj, ok := ref.Subject.(addrs.ProviderFunction); ok {\n+\t\t\t// Inject function directly into context\n+\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n+\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, ref.SourceRange)\n+\t\t\t\tdiags = diags.Append(fnDiags)\n+\n+\t\t\t\tif !fnDiags.HasErrors() {\n+\t\t\t\t\tctx.Functions[subj.String()] = *fn\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\t// self can only be used within a resource instance\n-\t\t\tsubj := selfAddr.(addrs.ResourceInstance)\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj.ContainingResource(), rng))\n+\t\tdiags = diags.Append(varBuilder.putValueBySubject(ref))\n+\t}\n \n-\t\t\tdiags = diags.Append(valDiags)\n+\tctx.Variables = varBuilder.buildAllVariables()\n \n-\t\t\t// Self is an exception in that it must always resolve to a\n-\t\t\t// particular instance. We will still insert the full resource into\n-\t\t\t// the context below.\n-\t\t\tvar hclDiags hcl.Diagnostics\n-\t\t\t// We should always have a valid self index by this point, but in\n-\t\t\t// the case of an error, self may end up as a cty.DynamicValue.\n-\t\t\tswitch k := subj.Key.(type) {\n-\t\t\tcase addrs.IntKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tcase addrs.StringKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tdefault:\n-\t\t\t\tself = val\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n+\treturn ctx, diags\n+}\n \n-\t\t// This type switch must cover all of the \"Referenceable\" implementations\n-\t\t// in package addrs, however we are removing the possibility of\n-\t\t// Instances beforehand.\n-\t\tswitch addr := rawSubj.(type) {\n-\t\tcase addrs.ResourceInstance:\n-\t\t\trawSubj = addr.ContainingResource()\n-\t\tcase addrs.ModuleCallInstance:\n-\t\t\trawSubj = addr.Call\n-\t\tcase addrs.ModuleCallInstanceOutput:\n-\t\t\trawSubj = addr.Call.Call\n-\t\t}\n+type evalVarBuilder struct {\n+\ts *Scope\n+\n+\tdataResources    map[string]map[string]cty.Value\n+\tmanagedResources map[string]map[string]cty.Value\n+\twholeModules     map[string]cty.Value\n+\tinputVariables   map[string]cty.Value\n+\tlocalValues      map[string]cty.Value\n+\toutputValues     map[string]cty.Value\n+\tpathAttrs        map[string]cty.Value\n+\tterraformAttrs   map[string]cty.Value\n+\tcountAttrs       map[string]cty.Value\n+\tforEachAttrs     map[string]cty.Value\n+\tcheckBlocks      map[string]cty.Value\n+\tself             cty.Value\n+}\n \n-\t\tswitch subj := rawSubj.(type) {\n-\t\tcase addrs.Resource:\n-\t\t\tvar into map[string]map[string]cty.Value\n-\t\t\tswitch subj.Mode {\n-\t\t\tcase addrs.ManagedResourceMode:\n-\t\t\t\tinto = managedResources\n-\t\t\tcase addrs.DataResourceMode:\n-\t\t\t\tinto = dataResources\n-\t\t\tdefault:\n-\t\t\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", subj.Mode))\n-\t\t\t}\n+func (s *Scope) newEvalVarBuilder() *evalVarBuilder {\n+\treturn &evalVarBuilder{\n+\t\ts: s,\n+\n+\t\tdataResources:    map[string]map[string]cty.Value{},\n+\t\tmanagedResources: map[string]map[string]cty.Value{},\n+\t\twholeModules:     map[string]cty.Value{},\n+\t\tinputVariables:   map[string]cty.Value{},\n+\t\tlocalValues:      map[string]cty.Value{},\n+\t\toutputValues:     map[string]cty.Value{},\n+\t\tpathAttrs:        map[string]cty.Value{},\n+\t\tterraformAttrs:   map[string]cty.Value{},\n+\t\tcountAttrs:       map[string]cty.Value{},\n+\t\tforEachAttrs:     map[string]cty.Value{},\n+\t\tcheckBlocks:      map[string]cty.Value{},\n+\t}\n+}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n+func (b *evalVarBuilder) putSelfValue(selfAddr addrs.Referenceable, ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\t\tr := subj\n-\t\t\tif into[r.Type] == nil {\n-\t\t\t\tinto[r.Type] = make(map[string]cty.Value)\n-\t\t\t}\n-\t\t\tinto[r.Type][r.Name] = val\n+\tif selfAddr == nil {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.ModuleCall:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetModule(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\twholeModules[subj.Name] = val\n+\tif selfAddr == addrs.Self {\n+\t\t// Programming error: the self address cannot alias itself.\n+\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t}\n \n-\t\tcase addrs.InputVariable:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetInputVariable(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tinputVariables[subj.Name] = val\n+\t// self can only be used within a resource instance\n+\tsubj, ok := selfAddr.(addrs.ResourceInstance)\n+\tif !ok {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.LocalValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetLocalValue(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tlocalValues[subj.Name] = val\n+\tval, valDiags := normalizeRefValue(b.s.Data.GetResource(subj.ContainingResource(), ref.SourceRange))\n+\n+\tdiags = diags.Append(valDiags)\n+\n+\t// Self is an exception in that it must always resolve to a\n+\t// particular instance. We will still insert the full resource into\n+\t// the context below.\n+\tvar hclDiags hcl.Diagnostics\n+\t// We should always have a valid self index by this point, but in\n+\t// the case of an error, self may end up as a cty.DynamicValue.\n+\tswitch k := subj.Key.(type) {\n+\tcase addrs.IntKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n+\tcase addrs.StringKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n+\tdefault:\n+\t\tb.self = val\n+\t}\n+\tdiags = diags.Append(hclDiags)\n \n-\t\tcase addrs.PathAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetPathAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tpathAttrs[subj.Name] = val\n+\treturn diags\n+}\n \n-\t\tcase addrs.TerraformAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetTerraformAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tterraformAttrs[subj.Name] = val\n+func (b *evalVarBuilder) putValueBySubject(ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\tcase addrs.CountAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCountAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tcountAttrs[subj.Name] = val\n+\trawSubj := ref.Subject\n+\trng := ref.SourceRange\n+\n+\t// This type switch must cover all of the \"Referenceable\" implementations\n+\t// in package addrs, however we are removing the possibility of\n+\t// Instances beforehand.\n+\tswitch addr := rawSubj.(type) {\n+\tcase addrs.ResourceInstance:\n+\t\trawSubj = addr.ContainingResource()\n+\tcase addrs.ModuleCallInstance:\n+\t\trawSubj = addr.Call\n+\tcase addrs.ModuleCallInstanceOutput:\n+\t\trawSubj = addr.Call.Call\n+\t}\n \n-\t\tcase addrs.ForEachAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetForEachAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tforEachAttrs[subj.Name] = val\n+\tnormalizeRefValue := func(val cty.Value, inDiags tfdiags.Diagnostics) cty.Value {\n+\t\tnormV, normDiags := normalizeRefValue(val, inDiags)\n+\t\tdiags = diags.Append(normDiags)\n+\t\treturn normV\n+\t}\n \n-\t\tcase addrs.OutputValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetOutput(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n+\tswitch subj := rawSubj.(type) {\n+\tcase addrs.Resource:\n+\t\tdiags = diags.Append(b.putResourceValue(subj, rng))\n \n-\t\tcase addrs.Check:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCheckBlock(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n-\t\tcase addrs.ProviderFunction:\n-\t\t\t// Inject function directly into context\n-\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n-\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, rng)\n-\t\t\t\tdiags = diags.Append(fnDiags)\n+\tcase addrs.ModuleCall:\n+\t\tb.wholeModules[subj.Name] = normalizeRefValue(b.s.Data.GetModule(subj, rng))\n \n-\t\t\t\tif !fnDiags.HasErrors() {\n-\t\t\t\t\tctx.Functions[subj.String()] = *fn\n-\t\t\t\t}\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// Should never happen\n-\t\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n-\t\t}\n+\tcase addrs.InputVariable:\n+\t\tb.inputVariables[subj.Name] = normalizeRefValue(b.s.Data.GetInputVariable(subj, rng))\n+\n+\tcase addrs.LocalValue:\n+\t\tb.localValues[subj.Name] = normalizeRefValue(b.s.Data.GetLocalValue(subj, rng))\n+\n+\tcase addrs.PathAttr:\n+\t\tb.pathAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetPathAttr(subj, rng))\n+\n+\tcase addrs.TerraformAttr:\n+\t\tb.terraformAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetTerraformAttr(subj, rng))\n+\n+\tcase addrs.CountAttr:\n+\t\tb.countAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetCountAttr(subj, rng))\n+\n+\tcase addrs.ForEachAttr:\n+\t\tb.forEachAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetForEachAttr(subj, rng))\n+\n+\tcase addrs.OutputValue:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetOutput(subj, rng))\n+\n+\tcase addrs.Check:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetCheckBlock(subj, rng))\n+\n+\tdefault:\n+\t\t// Should never happen\n+\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n+\t}\n+\n+\treturn diags\n+}\n+\n+func (b *evalVarBuilder) putResourceValue(res addrs.Resource, rng tfdiags.SourceRange) tfdiags.Diagnostics {\n+\tvar into map[string]map[string]cty.Value\n+\n+\t//nolint:exhaustive // InvalidResourceMode is checked in default.\n+\tswitch res.Mode {\n+\tcase addrs.ManagedResourceMode:\n+\t\tinto = b.managedResources\n+\tcase addrs.DataResourceMode:\n+\t\tinto = b.dataResources\n+\tdefault:\n+\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", res.Mode))\n \t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1656693353",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1750,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1656693353",
        "commented_code": "@@ -343,196 +340,253 @@ func (s *Scope) evalContext(parent *hcl.EvalContext, refs []*addrs.Reference, se\n \t// it, since that allows us to gather a full set of any errors and\n \t// warnings, but once we've gathered all the data we'll then skip anything\n \t// that's redundant in the process of populating our values map.\n-\tdataResources := map[string]map[string]cty.Value{}\n-\tmanagedResources := map[string]map[string]cty.Value{}\n-\twholeModules := map[string]cty.Value{}\n-\tinputVariables := map[string]cty.Value{}\n-\tlocalValues := map[string]cty.Value{}\n-\toutputValues := map[string]cty.Value{}\n-\tpathAttrs := map[string]cty.Value{}\n-\tterraformAttrs := map[string]cty.Value{}\n-\tcountAttrs := map[string]cty.Value{}\n-\tforEachAttrs := map[string]cty.Value{}\n-\tcheckBlocks := map[string]cty.Value{}\n-\tvar self cty.Value\n+\tvarBuilder := s.newEvalVarBuilder()\n \n \tfor _, ref := range refs {\n-\t\trng := ref.SourceRange\n-\n-\t\trawSubj := ref.Subject\n-\t\tif rawSubj == addrs.Self {\n-\t\t\tif selfAddr == nil {\n-\t\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n-\t\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\t\tSummary:  `Invalid \"self\" reference`,\n-\t\t\t\t\t// This detail message mentions some current practice that\n-\t\t\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n-\t\t\t\t\t// object starts being supported in more contexts later then\n-\t\t\t\t\t// we'll need to adjust this message.\n-\t\t\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n-\t\t\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n-\t\t\t\t})\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tif ref.Subject == addrs.Self {\n+\t\t\tdiags.Append(varBuilder.putSelfValue(selfAddr, ref))\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tif selfAddr == addrs.Self {\n-\t\t\t\t// Programming error: the self address cannot alias itself.\n-\t\t\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t\tif subj, ok := ref.Subject.(addrs.ProviderFunction); ok {\n+\t\t\t// Inject function directly into context\n+\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n+\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, ref.SourceRange)\n+\t\t\t\tdiags = diags.Append(fnDiags)\n+\n+\t\t\t\tif !fnDiags.HasErrors() {\n+\t\t\t\t\tctx.Functions[subj.String()] = *fn\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\t// self can only be used within a resource instance\n-\t\t\tsubj := selfAddr.(addrs.ResourceInstance)\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj.ContainingResource(), rng))\n+\t\tdiags = diags.Append(varBuilder.putValueBySubject(ref))\n+\t}\n \n-\t\t\tdiags = diags.Append(valDiags)\n+\tctx.Variables = varBuilder.buildAllVariables()\n \n-\t\t\t// Self is an exception in that it must always resolve to a\n-\t\t\t// particular instance. We will still insert the full resource into\n-\t\t\t// the context below.\n-\t\t\tvar hclDiags hcl.Diagnostics\n-\t\t\t// We should always have a valid self index by this point, but in\n-\t\t\t// the case of an error, self may end up as a cty.DynamicValue.\n-\t\t\tswitch k := subj.Key.(type) {\n-\t\t\tcase addrs.IntKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tcase addrs.StringKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tdefault:\n-\t\t\t\tself = val\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n+\treturn ctx, diags\n+}\n \n-\t\t// This type switch must cover all of the \"Referenceable\" implementations\n-\t\t// in package addrs, however we are removing the possibility of\n-\t\t// Instances beforehand.\n-\t\tswitch addr := rawSubj.(type) {\n-\t\tcase addrs.ResourceInstance:\n-\t\t\trawSubj = addr.ContainingResource()\n-\t\tcase addrs.ModuleCallInstance:\n-\t\t\trawSubj = addr.Call\n-\t\tcase addrs.ModuleCallInstanceOutput:\n-\t\t\trawSubj = addr.Call.Call\n-\t\t}\n+type evalVarBuilder struct {\n+\ts *Scope\n+\n+\tdataResources    map[string]map[string]cty.Value\n+\tmanagedResources map[string]map[string]cty.Value\n+\twholeModules     map[string]cty.Value\n+\tinputVariables   map[string]cty.Value\n+\tlocalValues      map[string]cty.Value\n+\toutputValues     map[string]cty.Value\n+\tpathAttrs        map[string]cty.Value\n+\tterraformAttrs   map[string]cty.Value\n+\tcountAttrs       map[string]cty.Value\n+\tforEachAttrs     map[string]cty.Value\n+\tcheckBlocks      map[string]cty.Value\n+\tself             cty.Value\n+}\n \n-\t\tswitch subj := rawSubj.(type) {\n-\t\tcase addrs.Resource:\n-\t\t\tvar into map[string]map[string]cty.Value\n-\t\t\tswitch subj.Mode {\n-\t\t\tcase addrs.ManagedResourceMode:\n-\t\t\t\tinto = managedResources\n-\t\t\tcase addrs.DataResourceMode:\n-\t\t\t\tinto = dataResources\n-\t\t\tdefault:\n-\t\t\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", subj.Mode))\n-\t\t\t}\n+func (s *Scope) newEvalVarBuilder() *evalVarBuilder {\n+\treturn &evalVarBuilder{\n+\t\ts: s,\n+\n+\t\tdataResources:    map[string]map[string]cty.Value{},\n+\t\tmanagedResources: map[string]map[string]cty.Value{},\n+\t\twholeModules:     map[string]cty.Value{},\n+\t\tinputVariables:   map[string]cty.Value{},\n+\t\tlocalValues:      map[string]cty.Value{},\n+\t\toutputValues:     map[string]cty.Value{},\n+\t\tpathAttrs:        map[string]cty.Value{},\n+\t\tterraformAttrs:   map[string]cty.Value{},\n+\t\tcountAttrs:       map[string]cty.Value{},\n+\t\tforEachAttrs:     map[string]cty.Value{},\n+\t\tcheckBlocks:      map[string]cty.Value{},\n+\t}\n+}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n+func (b *evalVarBuilder) putSelfValue(selfAddr addrs.Referenceable, ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\t\tr := subj\n-\t\t\tif into[r.Type] == nil {\n-\t\t\t\tinto[r.Type] = make(map[string]cty.Value)\n-\t\t\t}\n-\t\t\tinto[r.Type][r.Name] = val\n+\tif selfAddr == nil {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.ModuleCall:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetModule(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\twholeModules[subj.Name] = val\n+\tif selfAddr == addrs.Self {\n+\t\t// Programming error: the self address cannot alias itself.\n+\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t}\n \n-\t\tcase addrs.InputVariable:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetInputVariable(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tinputVariables[subj.Name] = val\n+\t// self can only be used within a resource instance\n+\tsubj, ok := selfAddr.(addrs.ResourceInstance)\n+\tif !ok {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.LocalValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetLocalValue(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tlocalValues[subj.Name] = val\n+\tval, valDiags := normalizeRefValue(b.s.Data.GetResource(subj.ContainingResource(), ref.SourceRange))\n+\n+\tdiags = diags.Append(valDiags)\n+\n+\t// Self is an exception in that it must always resolve to a\n+\t// particular instance. We will still insert the full resource into\n+\t// the context below.\n+\tvar hclDiags hcl.Diagnostics\n+\t// We should always have a valid self index by this point, but in\n+\t// the case of an error, self may end up as a cty.DynamicValue.\n+\tswitch k := subj.Key.(type) {\n+\tcase addrs.IntKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n+\tcase addrs.StringKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n+\tdefault:\n+\t\tb.self = val\n+\t}\n+\tdiags = diags.Append(hclDiags)\n \n-\t\tcase addrs.PathAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetPathAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tpathAttrs[subj.Name] = val\n+\treturn diags\n+}\n \n-\t\tcase addrs.TerraformAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetTerraformAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tterraformAttrs[subj.Name] = val\n+func (b *evalVarBuilder) putValueBySubject(ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\tcase addrs.CountAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCountAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tcountAttrs[subj.Name] = val\n+\trawSubj := ref.Subject\n+\trng := ref.SourceRange\n+\n+\t// This type switch must cover all of the \"Referenceable\" implementations\n+\t// in package addrs, however we are removing the possibility of\n+\t// Instances beforehand.\n+\tswitch addr := rawSubj.(type) {\n+\tcase addrs.ResourceInstance:\n+\t\trawSubj = addr.ContainingResource()\n+\tcase addrs.ModuleCallInstance:\n+\t\trawSubj = addr.Call\n+\tcase addrs.ModuleCallInstanceOutput:\n+\t\trawSubj = addr.Call.Call\n+\t}\n \n-\t\tcase addrs.ForEachAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetForEachAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tforEachAttrs[subj.Name] = val\n+\tnormalizeRefValue := func(val cty.Value, inDiags tfdiags.Diagnostics) cty.Value {\n+\t\tnormV, normDiags := normalizeRefValue(val, inDiags)\n+\t\tdiags = diags.Append(normDiags)\n+\t\treturn normV\n+\t}\n \n-\t\tcase addrs.OutputValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetOutput(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n+\tswitch subj := rawSubj.(type) {\n+\tcase addrs.Resource:\n+\t\tdiags = diags.Append(b.putResourceValue(subj, rng))\n \n-\t\tcase addrs.Check:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCheckBlock(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n-\t\tcase addrs.ProviderFunction:\n-\t\t\t// Inject function directly into context\n-\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n-\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, rng)\n-\t\t\t\tdiags = diags.Append(fnDiags)\n+\tcase addrs.ModuleCall:\n+\t\tb.wholeModules[subj.Name] = normalizeRefValue(b.s.Data.GetModule(subj, rng))\n \n-\t\t\t\tif !fnDiags.HasErrors() {\n-\t\t\t\t\tctx.Functions[subj.String()] = *fn\n-\t\t\t\t}\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// Should never happen\n-\t\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n-\t\t}\n+\tcase addrs.InputVariable:\n+\t\tb.inputVariables[subj.Name] = normalizeRefValue(b.s.Data.GetInputVariable(subj, rng))\n+\n+\tcase addrs.LocalValue:\n+\t\tb.localValues[subj.Name] = normalizeRefValue(b.s.Data.GetLocalValue(subj, rng))\n+\n+\tcase addrs.PathAttr:\n+\t\tb.pathAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetPathAttr(subj, rng))\n+\n+\tcase addrs.TerraformAttr:\n+\t\tb.terraformAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetTerraformAttr(subj, rng))\n+\n+\tcase addrs.CountAttr:\n+\t\tb.countAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetCountAttr(subj, rng))\n+\n+\tcase addrs.ForEachAttr:\n+\t\tb.forEachAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetForEachAttr(subj, rng))\n+\n+\tcase addrs.OutputValue:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetOutput(subj, rng))\n+\n+\tcase addrs.Check:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetCheckBlock(subj, rng))\n+\n+\tdefault:\n+\t\t// Should never happen\n+\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n+\t}\n+\n+\treturn diags\n+}\n+\n+func (b *evalVarBuilder) putResourceValue(res addrs.Resource, rng tfdiags.SourceRange) tfdiags.Diagnostics {\n+\tvar into map[string]map[string]cty.Value\n+\n+\t//nolint:exhaustive // InvalidResourceMode is checked in default.\n+\tswitch res.Mode {\n+\tcase addrs.ManagedResourceMode:\n+\t\tinto = b.managedResources\n+\tcase addrs.DataResourceMode:\n+\t\tinto = b.dataResources\n+\tdefault:\n+\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", res.Mode))\n \t}",
        "comment_created_at": "2024-06-27T08:25:47+00:00",
        "comment_author": "RLRabinowitz",
        "comment_body": "nit - I think we prefer to include `InvalidResourceMode` here, instead of having a `nolint:exhaustive` here\r\n\r\n```suggestion\r\n\tswitch res.Mode {\r\n\tcase addrs.ManagedResourceMode:\r\n\t\tinto = b.managedResources\r\n\tcase addrs.DataResourceMode:\r\n\t\tinto = b.dataResources\r\n\tcase addrs.InvalidResourceMode:\r\n\t\tfallthrough\r\n\tdefault:\r\n\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", res.Mode))\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1660748481",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1750,
        "pr_file": "internal/lang/eval.go",
        "discussion_id": "1656693353",
        "commented_code": "@@ -343,196 +340,253 @@ func (s *Scope) evalContext(parent *hcl.EvalContext, refs []*addrs.Reference, se\n \t// it, since that allows us to gather a full set of any errors and\n \t// warnings, but once we've gathered all the data we'll then skip anything\n \t// that's redundant in the process of populating our values map.\n-\tdataResources := map[string]map[string]cty.Value{}\n-\tmanagedResources := map[string]map[string]cty.Value{}\n-\twholeModules := map[string]cty.Value{}\n-\tinputVariables := map[string]cty.Value{}\n-\tlocalValues := map[string]cty.Value{}\n-\toutputValues := map[string]cty.Value{}\n-\tpathAttrs := map[string]cty.Value{}\n-\tterraformAttrs := map[string]cty.Value{}\n-\tcountAttrs := map[string]cty.Value{}\n-\tforEachAttrs := map[string]cty.Value{}\n-\tcheckBlocks := map[string]cty.Value{}\n-\tvar self cty.Value\n+\tvarBuilder := s.newEvalVarBuilder()\n \n \tfor _, ref := range refs {\n-\t\trng := ref.SourceRange\n-\n-\t\trawSubj := ref.Subject\n-\t\tif rawSubj == addrs.Self {\n-\t\t\tif selfAddr == nil {\n-\t\t\t\tdiags = diags.Append(&hcl.Diagnostic{\n-\t\t\t\t\tSeverity: hcl.DiagError,\n-\t\t\t\t\tSummary:  `Invalid \"self\" reference`,\n-\t\t\t\t\t// This detail message mentions some current practice that\n-\t\t\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n-\t\t\t\t\t// object starts being supported in more contexts later then\n-\t\t\t\t\t// we'll need to adjust this message.\n-\t\t\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n-\t\t\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n-\t\t\t\t})\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tif ref.Subject == addrs.Self {\n+\t\t\tdiags.Append(varBuilder.putSelfValue(selfAddr, ref))\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tif selfAddr == addrs.Self {\n-\t\t\t\t// Programming error: the self address cannot alias itself.\n-\t\t\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t\tif subj, ok := ref.Subject.(addrs.ProviderFunction); ok {\n+\t\t\t// Inject function directly into context\n+\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n+\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, ref.SourceRange)\n+\t\t\t\tdiags = diags.Append(fnDiags)\n+\n+\t\t\t\tif !fnDiags.HasErrors() {\n+\t\t\t\t\tctx.Functions[subj.String()] = *fn\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\t// self can only be used within a resource instance\n-\t\t\tsubj := selfAddr.(addrs.ResourceInstance)\n+\t\t\tcontinue\n+\t\t}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj.ContainingResource(), rng))\n+\t\tdiags = diags.Append(varBuilder.putValueBySubject(ref))\n+\t}\n \n-\t\t\tdiags = diags.Append(valDiags)\n+\tctx.Variables = varBuilder.buildAllVariables()\n \n-\t\t\t// Self is an exception in that it must always resolve to a\n-\t\t\t// particular instance. We will still insert the full resource into\n-\t\t\t// the context below.\n-\t\t\tvar hclDiags hcl.Diagnostics\n-\t\t\t// We should always have a valid self index by this point, but in\n-\t\t\t// the case of an error, self may end up as a cty.DynamicValue.\n-\t\t\tswitch k := subj.Key.(type) {\n-\t\t\tcase addrs.IntKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tcase addrs.StringKey:\n-\t\t\t\tself, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n-\t\t\t\tdiags = diags.Append(hclDiags)\n-\t\t\tdefault:\n-\t\t\t\tself = val\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n+\treturn ctx, diags\n+}\n \n-\t\t// This type switch must cover all of the \"Referenceable\" implementations\n-\t\t// in package addrs, however we are removing the possibility of\n-\t\t// Instances beforehand.\n-\t\tswitch addr := rawSubj.(type) {\n-\t\tcase addrs.ResourceInstance:\n-\t\t\trawSubj = addr.ContainingResource()\n-\t\tcase addrs.ModuleCallInstance:\n-\t\t\trawSubj = addr.Call\n-\t\tcase addrs.ModuleCallInstanceOutput:\n-\t\t\trawSubj = addr.Call.Call\n-\t\t}\n+type evalVarBuilder struct {\n+\ts *Scope\n+\n+\tdataResources    map[string]map[string]cty.Value\n+\tmanagedResources map[string]map[string]cty.Value\n+\twholeModules     map[string]cty.Value\n+\tinputVariables   map[string]cty.Value\n+\tlocalValues      map[string]cty.Value\n+\toutputValues     map[string]cty.Value\n+\tpathAttrs        map[string]cty.Value\n+\tterraformAttrs   map[string]cty.Value\n+\tcountAttrs       map[string]cty.Value\n+\tforEachAttrs     map[string]cty.Value\n+\tcheckBlocks      map[string]cty.Value\n+\tself             cty.Value\n+}\n \n-\t\tswitch subj := rawSubj.(type) {\n-\t\tcase addrs.Resource:\n-\t\t\tvar into map[string]map[string]cty.Value\n-\t\t\tswitch subj.Mode {\n-\t\t\tcase addrs.ManagedResourceMode:\n-\t\t\t\tinto = managedResources\n-\t\t\tcase addrs.DataResourceMode:\n-\t\t\t\tinto = dataResources\n-\t\t\tdefault:\n-\t\t\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", subj.Mode))\n-\t\t\t}\n+func (s *Scope) newEvalVarBuilder() *evalVarBuilder {\n+\treturn &evalVarBuilder{\n+\t\ts: s,\n+\n+\t\tdataResources:    map[string]map[string]cty.Value{},\n+\t\tmanagedResources: map[string]map[string]cty.Value{},\n+\t\twholeModules:     map[string]cty.Value{},\n+\t\tinputVariables:   map[string]cty.Value{},\n+\t\tlocalValues:      map[string]cty.Value{},\n+\t\toutputValues:     map[string]cty.Value{},\n+\t\tpathAttrs:        map[string]cty.Value{},\n+\t\tterraformAttrs:   map[string]cty.Value{},\n+\t\tcountAttrs:       map[string]cty.Value{},\n+\t\tforEachAttrs:     map[string]cty.Value{},\n+\t\tcheckBlocks:      map[string]cty.Value{},\n+\t}\n+}\n \n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetResource(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n+func (b *evalVarBuilder) putSelfValue(selfAddr addrs.Referenceable, ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\t\tr := subj\n-\t\t\tif into[r.Type] == nil {\n-\t\t\t\tinto[r.Type] = make(map[string]cty.Value)\n-\t\t\t}\n-\t\t\tinto[r.Type][r.Name] = val\n+\tif selfAddr == nil {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.ModuleCall:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetModule(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\twholeModules[subj.Name] = val\n+\tif selfAddr == addrs.Self {\n+\t\t// Programming error: the self address cannot alias itself.\n+\t\tpanic(\"scope SelfAddr attempting to alias itself\")\n+\t}\n \n-\t\tcase addrs.InputVariable:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetInputVariable(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tinputVariables[subj.Name] = val\n+\t// self can only be used within a resource instance\n+\tsubj, ok := selfAddr.(addrs.ResourceInstance)\n+\tif !ok {\n+\t\treturn diags.Append(&hcl.Diagnostic{\n+\t\t\tSeverity: hcl.DiagError,\n+\t\t\tSummary:  `Invalid \"self\" reference`,\n+\t\t\t// This detail message mentions some current practice that\n+\t\t\t// this codepath doesn't really \"know about\". If the \"self\"\n+\t\t\t// object starts being supported in more contexts later then\n+\t\t\t// we'll need to adjust this message.\n+\t\t\tDetail:  `The \"self\" object is not available in this context. This object can be used only in resource provisioner, connection, and postcondition blocks.`,\n+\t\t\tSubject: ref.SourceRange.ToHCL().Ptr(),\n+\t\t})\n+\t}\n \n-\t\tcase addrs.LocalValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetLocalValue(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tlocalValues[subj.Name] = val\n+\tval, valDiags := normalizeRefValue(b.s.Data.GetResource(subj.ContainingResource(), ref.SourceRange))\n+\n+\tdiags = diags.Append(valDiags)\n+\n+\t// Self is an exception in that it must always resolve to a\n+\t// particular instance. We will still insert the full resource into\n+\t// the context below.\n+\tvar hclDiags hcl.Diagnostics\n+\t// We should always have a valid self index by this point, but in\n+\t// the case of an error, self may end up as a cty.DynamicValue.\n+\tswitch k := subj.Key.(type) {\n+\tcase addrs.IntKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.NumberIntVal(int64(k)), ref.SourceRange.ToHCL().Ptr())\n+\tcase addrs.StringKey:\n+\t\tb.self, hclDiags = hcl.Index(val, cty.StringVal(string(k)), ref.SourceRange.ToHCL().Ptr())\n+\tdefault:\n+\t\tb.self = val\n+\t}\n+\tdiags = diags.Append(hclDiags)\n \n-\t\tcase addrs.PathAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetPathAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tpathAttrs[subj.Name] = val\n+\treturn diags\n+}\n \n-\t\tcase addrs.TerraformAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetTerraformAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tterraformAttrs[subj.Name] = val\n+func (b *evalVarBuilder) putValueBySubject(ref *addrs.Reference) tfdiags.Diagnostics {\n+\tvar diags tfdiags.Diagnostics\n \n-\t\tcase addrs.CountAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCountAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tcountAttrs[subj.Name] = val\n+\trawSubj := ref.Subject\n+\trng := ref.SourceRange\n+\n+\t// This type switch must cover all of the \"Referenceable\" implementations\n+\t// in package addrs, however we are removing the possibility of\n+\t// Instances beforehand.\n+\tswitch addr := rawSubj.(type) {\n+\tcase addrs.ResourceInstance:\n+\t\trawSubj = addr.ContainingResource()\n+\tcase addrs.ModuleCallInstance:\n+\t\trawSubj = addr.Call\n+\tcase addrs.ModuleCallInstanceOutput:\n+\t\trawSubj = addr.Call.Call\n+\t}\n \n-\t\tcase addrs.ForEachAttr:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetForEachAttr(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\tforEachAttrs[subj.Name] = val\n+\tnormalizeRefValue := func(val cty.Value, inDiags tfdiags.Diagnostics) cty.Value {\n+\t\tnormV, normDiags := normalizeRefValue(val, inDiags)\n+\t\tdiags = diags.Append(normDiags)\n+\t\treturn normV\n+\t}\n \n-\t\tcase addrs.OutputValue:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetOutput(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n+\tswitch subj := rawSubj.(type) {\n+\tcase addrs.Resource:\n+\t\tdiags = diags.Append(b.putResourceValue(subj, rng))\n \n-\t\tcase addrs.Check:\n-\t\t\tval, valDiags := normalizeRefValue(s.Data.GetCheckBlock(subj, rng))\n-\t\t\tdiags = diags.Append(valDiags)\n-\t\t\toutputValues[subj.Name] = val\n-\t\tcase addrs.ProviderFunction:\n-\t\t\t// Inject function directly into context\n-\t\t\tif _, ok := ctx.Functions[subj.String()]; !ok {\n-\t\t\t\tfn, fnDiags := s.ProviderFunctions(subj, rng)\n-\t\t\t\tdiags = diags.Append(fnDiags)\n+\tcase addrs.ModuleCall:\n+\t\tb.wholeModules[subj.Name] = normalizeRefValue(b.s.Data.GetModule(subj, rng))\n \n-\t\t\t\tif !fnDiags.HasErrors() {\n-\t\t\t\t\tctx.Functions[subj.String()] = *fn\n-\t\t\t\t}\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// Should never happen\n-\t\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n-\t\t}\n+\tcase addrs.InputVariable:\n+\t\tb.inputVariables[subj.Name] = normalizeRefValue(b.s.Data.GetInputVariable(subj, rng))\n+\n+\tcase addrs.LocalValue:\n+\t\tb.localValues[subj.Name] = normalizeRefValue(b.s.Data.GetLocalValue(subj, rng))\n+\n+\tcase addrs.PathAttr:\n+\t\tb.pathAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetPathAttr(subj, rng))\n+\n+\tcase addrs.TerraformAttr:\n+\t\tb.terraformAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetTerraformAttr(subj, rng))\n+\n+\tcase addrs.CountAttr:\n+\t\tb.countAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetCountAttr(subj, rng))\n+\n+\tcase addrs.ForEachAttr:\n+\t\tb.forEachAttrs[subj.Name] = normalizeRefValue(b.s.Data.GetForEachAttr(subj, rng))\n+\n+\tcase addrs.OutputValue:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetOutput(subj, rng))\n+\n+\tcase addrs.Check:\n+\t\tb.outputValues[subj.Name] = normalizeRefValue(b.s.Data.GetCheckBlock(subj, rng))\n+\n+\tdefault:\n+\t\t// Should never happen\n+\t\tpanic(fmt.Errorf(\"Scope.buildEvalContext cannot handle address type %T\", rawSubj))\n+\t}\n+\n+\treturn diags\n+}\n+\n+func (b *evalVarBuilder) putResourceValue(res addrs.Resource, rng tfdiags.SourceRange) tfdiags.Diagnostics {\n+\tvar into map[string]map[string]cty.Value\n+\n+\t//nolint:exhaustive // InvalidResourceMode is checked in default.\n+\tswitch res.Mode {\n+\tcase addrs.ManagedResourceMode:\n+\t\tinto = b.managedResources\n+\tcase addrs.DataResourceMode:\n+\t\tinto = b.dataResources\n+\tdefault:\n+\t\tpanic(fmt.Errorf(\"unsupported ResourceMode %s\", res.Mode))\n \t}",
        "comment_created_at": "2024-07-01T09:26:12+00:00",
        "comment_author": "ollevche",
        "comment_body": "[354964b](https://github.com/opentofu/opentofu/pull/1750/commits/354964b836ed72308b6fc8e48f5b7d42cda7c460)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1646005903",
    "pr_number": 1738,
    "pr_file": "internal/configs/parser_config_dir.go",
    "created_at": "2024-06-19T11:37:02+00:00",
    "commented_code": "}\n \t}\n \n-\treturn\n+\treturn filterTfPathsWithTofuAlternatives(primary), filterTfPathsWithTofuAlternatives(override), filterTfPathsWithTofuAlternatives(tests), diags\n+}\n+\n+func filterTfPathsWithTofuAlternatives(paths []string) []string {\n+\tvar ignoredPaths []string\n+\tvar relevantPaths []string\n+\n+\tfor _, p := range paths {\n+\t\tif ext := tfFileExt(p); ext != \"\" {\n+\t\t\tparallelTofuExt := strings.ReplaceAll(ext, \".tf\", \".tofu\")\n+\t\t\tpathWithoutExt, _ := strings.CutSuffix(p, ext)\n+\t\t\tparallelTofuPath := pathWithoutExt + parallelTofuExt\n+\n+\t\t\t// If the .tf file has a parallel .tofu file in the directory,\n+\t\t\t// we'll ignore the .tf file and only use the .tofu file\n+\t\t\tif slices.Contains(paths, parallelTofuPath) {\n+\t\t\t\tignoredPaths = append(ignoredPaths, p)\n+\t\t\t} else {\n+\t\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t\t}\n+\t\t} else {\n+\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1646005903",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1738,
        "pr_file": "internal/configs/parser_config_dir.go",
        "discussion_id": "1646005903",
        "commented_code": "@@ -226,7 +229,36 @@ func (p *Parser) dirFiles(dir string, testsDir string) (primary, override, tests\n \t\t}\n \t}\n \n-\treturn\n+\treturn filterTfPathsWithTofuAlternatives(primary), filterTfPathsWithTofuAlternatives(override), filterTfPathsWithTofuAlternatives(tests), diags\n+}\n+\n+func filterTfPathsWithTofuAlternatives(paths []string) []string {\n+\tvar ignoredPaths []string\n+\tvar relevantPaths []string\n+\n+\tfor _, p := range paths {\n+\t\tif ext := tfFileExt(p); ext != \"\" {\n+\t\t\tparallelTofuExt := strings.ReplaceAll(ext, \".tf\", \".tofu\")\n+\t\t\tpathWithoutExt, _ := strings.CutSuffix(p, ext)\n+\t\t\tparallelTofuPath := pathWithoutExt + parallelTofuExt\n+\n+\t\t\t// If the .tf file has a parallel .tofu file in the directory,\n+\t\t\t// we'll ignore the .tf file and only use the .tofu file\n+\t\t\tif slices.Contains(paths, parallelTofuPath) {\n+\t\t\t\tignoredPaths = append(ignoredPaths, p)\n+\t\t\t} else {\n+\t\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t\t}\n+\t\t} else {\n+\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t}",
        "comment_created_at": "2024-06-19T11:37:02+00:00",
        "comment_author": "ollevche",
        "comment_body": "nit: just a bit clearer with reduced nesting\r\n\r\n```suggestion\r\n                ext := tfFileExt(p)\r\n\t\tif ext == \"\" {\r\n\t\t\trelevantPaths = append(relevantPaths, p)\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t        parallelTofuExt := strings.ReplaceAll(ext, \".tf\", \".tofu\")\r\n\t        pathWithoutExt, _ := strings.CutSuffix(p, ext)\r\n\t        parallelTofuPath := pathWithoutExt + parallelTofuExt\r\n        \r\n\t        // If the .tf file has a parallel .tofu file in the directory,\r\n\t        // we'll ignore the .tf file and only use the .tofu file\r\n\t        if slices.Contains(paths, parallelTofuPath) {\r\n\t\t        ignoredPaths = append(ignoredPaths, p)\r\n\t        } else {\r\n\t\t        relevantPaths = append(relevantPaths, p)\r\n\t        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1647406677",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1738,
        "pr_file": "internal/configs/parser_config_dir.go",
        "discussion_id": "1646005903",
        "commented_code": "@@ -226,7 +229,36 @@ func (p *Parser) dirFiles(dir string, testsDir string) (primary, override, tests\n \t\t}\n \t}\n \n-\treturn\n+\treturn filterTfPathsWithTofuAlternatives(primary), filterTfPathsWithTofuAlternatives(override), filterTfPathsWithTofuAlternatives(tests), diags\n+}\n+\n+func filterTfPathsWithTofuAlternatives(paths []string) []string {\n+\tvar ignoredPaths []string\n+\tvar relevantPaths []string\n+\n+\tfor _, p := range paths {\n+\t\tif ext := tfFileExt(p); ext != \"\" {\n+\t\t\tparallelTofuExt := strings.ReplaceAll(ext, \".tf\", \".tofu\")\n+\t\t\tpathWithoutExt, _ := strings.CutSuffix(p, ext)\n+\t\t\tparallelTofuPath := pathWithoutExt + parallelTofuExt\n+\n+\t\t\t// If the .tf file has a parallel .tofu file in the directory,\n+\t\t\t// we'll ignore the .tf file and only use the .tofu file\n+\t\t\tif slices.Contains(paths, parallelTofuPath) {\n+\t\t\t\tignoredPaths = append(ignoredPaths, p)\n+\t\t\t} else {\n+\t\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t\t}\n+\t\t} else {\n+\t\t\trelevantPaths = append(relevantPaths, p)\n+\t\t}",
        "comment_created_at": "2024-06-20T11:12:03+00:00",
        "comment_author": "Evi1Pumpkin",
        "comment_body": "https://github.com/opentofu/opentofu/pull/1738/commits/a1a6d2a1a2e71dea1a6507bda485a95e6aa69c30",
        "pr_file_module": null
      }
    ]
  }
]