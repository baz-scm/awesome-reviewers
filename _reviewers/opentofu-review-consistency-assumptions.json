[
  {
    "discussion_id": "1954426886",
    "pr_number": 2511,
    "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
    "created_at": "2025-02-13T12:41:42+00:00",
    "commented_code": "+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1954426886",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954426886",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:",
        "comment_created_at": "2025-02-13T12:41:42+00:00",
        "comment_author": "ollevche",
        "comment_body": "One more thing to keep in mind is that `s3` backend is being used with other non-AWS s3 compatible storage implementations. Those services may or may not support the conditional locking feature. Ideally, we would check somehow if that feature is supported and error otherwise. Not sure if there's an easy way to check that, but we need to at least document this pitfall.",
        "pr_file_module": null
      },
      {
        "comment_id": "1955660383",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954426886",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:",
        "comment_created_at": "2025-02-14T07:15:01+00:00",
        "comment_author": "yottta",
        "comment_body": "Really good point!\r\nFrom a quick check, I see that some already implemented it but there are still some that didn't yet.\r\nAdded a warning about it e22385a328c24a07904fa422aad15849b57ff047",
        "pr_file_module": null
      },
      {
        "comment_id": "1956043866",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954426886",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:",
        "comment_created_at": "2025-02-14T12:06:25+00:00",
        "comment_author": "ollevche",
        "comment_body": "We need not to forget to update the user-facing docs as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1954794793",
    "pr_number": 2511,
    "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
    "created_at": "2025-02-13T16:03:37+00:00",
    "commented_code": "+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1954794793",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-13T16:03:37+00:00",
        "comment_author": "ollevche",
        "comment_body": "I may be missing something, but do we need to update the digest? If I understand correctly, we could go with a `IfNoneMatch` lock creation so it would fail for any other tofu run, while the file exists. On Unlock, we could just delete it altogether. As far as I can tell, this matches the dynamodb implementation and eliminates data races via `IfNoneMatch` option. \r\n\r\nWhat do you think?",
        "pr_file_module": null
      },
      {
        "comment_id": "1954868853",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-13T16:47:56+00:00",
        "comment_author": "yottta",
        "comment_body": "I used terms like \"digest\", \"md5\" or \"digest file\" for the part where OpenTofu is writing an md5 hash of the statefile.\r\nFor example, looking into the dynamoDB, there is the md5 sum of the state file. Can be easily checked like this:\r\n![image](https://github.com/user-attachments/assets/7dc94a57-407b-4531-b6db-02bc2e24d10b)\r\n\r\n\r\n[Here](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L352C24-L374) is where this is handled in OpenTofu.\r\n\r\nIn that `Digest updates` section, I am talking about this part.",
        "pr_file_module": null
      },
      {
        "comment_id": "1955017218",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-13T18:21:30+00:00",
        "comment_author": "ollevche",
        "comment_body": "Got you, thanks! I missed that part, I will re-read it and leave another comment.",
        "pr_file_module": null
      },
      {
        "comment_id": "1955828819",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-14T09:30:35+00:00",
        "comment_author": "yottta",
        "comment_body": "Updated this section due to not needed to handle this digest file anymore.\r\nThis should be handled only when the DynamoDB locking is enabled. That's due to having two sources of information when it comes to locking and it was used to ensure that the state object from the S3 bucket was not altered separately, without acquiring a lock.",
        "pr_file_module": null
      },
      {
        "comment_id": "1956050315",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-14T12:11:23+00:00",
        "comment_author": "ollevche",
        "comment_body": "After some digging, I think this option is unnecessary even for dynamodb locking. This feature was introduced to workaround the eventual consistency nature of s3 (before 2020). It is checking if the read state file is the latest written one and we no longer need to check this since s3 become strongly consistent ([blogpost](https://aws.amazon.com/blogs/aws/amazon-s3-update-strong-read-after-write-consistency/)) in 2020.",
        "pr_file_module": null
      },
      {
        "comment_id": "1956052099",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-14T12:13:05+00:00",
        "comment_author": "ollevche",
        "comment_body": "This is something only slightly relevant for this RFC, so I think we can tackle it separately. Alternatively, we can leave it as is if we plan to deprecate dynamodb locking completely. Otherwise, removing md5 write / read from dynamodb locking will positively affect the performance.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957710913",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1954794793",
        "commented_code": "@@ -0,0 +1,148 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking and state digest from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+When OpenTofu will find the above attribute in the backend configuration, it will handle the state locking and the digest of the state file in the same bucket as configured for the state file.\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will behave as normal:\n+  * The only thing that will have to do extra, is to ensure that the MD5 file is there and if not, to create it.\n+    * The generation of the MD5 checksum is already part of the [implementation](https://github.com/opentofu/opentofu/blob/6614782/internal/backend/remote-state/s3/client.go#L178).\n+    * We just need to store it in a new file in the configured S3 bucket (file name: <state-file-path>-md5)\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Get the digest of the statefile from S3. If missing:\n+    * Acquire the lock in DynamoDB table; \n+    * Get the digest of the statefile from DynamoDB and migrate it to the S3 bucket;\n+    * Release the lock from DynamoDB table;\n+  * Perform the requested sub-command\n+  * Release the lock from the S3 bucket;\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state files.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that file could grow significantly.\n+> Even though the cost should be negligible for the locking files, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of a file.\n+\n+### Technical Approach\n+\n+In order to achieve and ensure a proper state locking via S3 bucket, we want to attempt to create the locking object only when it is missing. \n+In order to do so we need to call `s3client.PutObject` with the property `IfNoneMatch: \"*\"`.\n+For more information, please check the [official documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html#conditional-write-key-names).\n+\n+But the simplified implementation would look like this:\n+```go\n+input := &s3.PutObjectInput{\n+    Bucket:            aws.String(bucket),\n+    Key:               aws.String(key),\n+    Body:              bytes.NewReader([]byte(lockInfo)),\n+    IfNoneMatch:       aws.String(\"*\"),\n+}\n+_, err := actor.S3Client.PutObject(ctx, input)\n+```\n+\n+The `err` returned above should be handled accordingly with the [behaviour defined](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html) in the official docs:\n+* HTTP 200 (OK) - Means that the locking file was not existing. Therefore, the lock can be considered as acquired.\n+  * For buckets with versioning enabled, if there's no current object version with the same name, or if the current object version is a delete marker, the write operation succeeds.\n+* HTTP 412 (Precondition Failed) - Means that the locking file is already there. Therefore, the whole process should exit because the lock couldn't be acquired.\n+* HTTP 409 (Conflict) - Means that the there was a conflict of concurrent requests. AWS recommends to retry the request in such cases, but we could just handle this similarly to the 412 case.\n+\n+#### Digest updates",
        "comment_created_at": "2025-02-17T07:00:48+00:00",
        "comment_author": "yottta",
        "comment_body": "Added in 38f1eb921775d9ac783fffe8c8cb3d2b11a67419",
        "pr_file_module": null
      }
    ]
  }
]