[
  {
    "discussion_id": "2088314224",
    "pr_number": 2800,
    "pr_file": "rfc/20250514-variables-locals-unused-detection.md",
    "created_at": "2025-05-14T07:56:10+00:00",
    "commented_code": "+# Variables and Locals unused detection\n+\n+Issue: [2583](https://github.com/opentofu/opentofu/issues/2583)\n+\n+## Summary\n+\n+This proposal introduces warnings during validation when an input variable (`variable`) or a local value (`local`) is declared in a module but never referenced. The aim is to improve readability, maintainability, and code quality by identifying unused definitions.\n+\n+Currently, OpenTofu does not emit any warning when an input variable or local value is declared but unused. This can lead to configuration bloat, making codebases harder to read and maintain. By warning on unused values, developers are encouraged to clean up stale or redundant code, enhancing the overall quality of OpenTofu configurations.\n+\n+## Proposed Solution\n+\n+* **Input Variables**:\n+  During validation, if an input variable is declared in a module but never referenced, a warning is emitted\u2014except when the variable is marked as `deprecated`. In that case, the warning is only emitted if a value is assigned to the variable by a caller.\n+\n+* **Local Values**:\n+  If a value declared inside a `locals` block is not referenced elsewhere in the module, a warning is emitted during validation.\n+\n+### User Documentation\n+\n+```bash\n+tofu validate\n+[Warning]  variable xxx defined but not used inside code",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2088314224",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2800,
        "pr_file": "rfc/20250514-variables-locals-unused-detection.md",
        "discussion_id": "2088314224",
        "commented_code": "@@ -0,0 +1,44 @@\n+# Variables and Locals unused detection\n+\n+Issue: [2583](https://github.com/opentofu/opentofu/issues/2583)\n+\n+## Summary\n+\n+This proposal introduces warnings during validation when an input variable (`variable`) or a local value (`local`) is declared in a module but never referenced. The aim is to improve readability, maintainability, and code quality by identifying unused definitions.\n+\n+Currently, OpenTofu does not emit any warning when an input variable or local value is declared but unused. This can lead to configuration bloat, making codebases harder to read and maintain. By warning on unused values, developers are encouraged to clean up stale or redundant code, enhancing the overall quality of OpenTofu configurations.\n+\n+## Proposed Solution\n+\n+* **Input Variables**:\n+  During validation, if an input variable is declared in a module but never referenced, a warning is emitted\u2014except when the variable is marked as `deprecated`. In that case, the warning is only emitted if a value is assigned to the variable by a caller.\n+\n+* **Local Values**:\n+  If a value declared inside a `locals` block is not referenced elsewhere in the module, a warning is emitted during validation.\n+\n+### User Documentation\n+\n+```bash\n+tofu validate\n+[Warning]  variable xxx defined but not used inside code",
        "comment_created_at": "2025-05-14T07:56:10+00:00",
        "comment_author": "Yantrio",
        "comment_body": "If a variable is used deep within a nest of modules, how do you feel is best to help the end user running something like `tofu validate` find that variable in the code? Do we link to the file, do we try and construct an address for this variable? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2089463863",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2800,
        "pr_file": "rfc/20250514-variables-locals-unused-detection.md",
        "discussion_id": "2088314224",
        "commented_code": "@@ -0,0 +1,44 @@\n+# Variables and Locals unused detection\n+\n+Issue: [2583](https://github.com/opentofu/opentofu/issues/2583)\n+\n+## Summary\n+\n+This proposal introduces warnings during validation when an input variable (`variable`) or a local value (`local`) is declared in a module but never referenced. The aim is to improve readability, maintainability, and code quality by identifying unused definitions.\n+\n+Currently, OpenTofu does not emit any warning when an input variable or local value is declared but unused. This can lead to configuration bloat, making codebases harder to read and maintain. By warning on unused values, developers are encouraged to clean up stale or redundant code, enhancing the overall quality of OpenTofu configurations.\n+\n+## Proposed Solution\n+\n+* **Input Variables**:\n+  During validation, if an input variable is declared in a module but never referenced, a warning is emitted\u2014except when the variable is marked as `deprecated`. In that case, the warning is only emitted if a value is assigned to the variable by a caller.\n+\n+* **Local Values**:\n+  If a value declared inside a `locals` block is not referenced elsewhere in the module, a warning is emitted during validation.\n+\n+### User Documentation\n+\n+```bash\n+tofu validate\n+[Warning]  variable xxx defined but not used inside code",
        "comment_created_at": "2025-05-14T17:56:16+00:00",
        "comment_author": "jgalais",
        "comment_body": "I think that we must to check the variable in a level where she must defined.\r\n\r\nIdea:\r\n- Check variable.tf in a root module (Check unused variable in this level)\r\n- Check unused locals in a root module\r\n\r\n- Check variable.tf in a sub-module (Check unused variable in the sub-module level)\r\n- Check unused locals in a sub module\r\n\r\nWhat do you think about that ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2109272038",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2800,
        "pr_file": "rfc/20250514-variables-locals-unused-detection.md",
        "discussion_id": "2088314224",
        "commented_code": "@@ -0,0 +1,44 @@\n+# Variables and Locals unused detection\n+\n+Issue: [2583](https://github.com/opentofu/opentofu/issues/2583)\n+\n+## Summary\n+\n+This proposal introduces warnings during validation when an input variable (`variable`) or a local value (`local`) is declared in a module but never referenced. The aim is to improve readability, maintainability, and code quality by identifying unused definitions.\n+\n+Currently, OpenTofu does not emit any warning when an input variable or local value is declared but unused. This can lead to configuration bloat, making codebases harder to read and maintain. By warning on unused values, developers are encouraged to clean up stale or redundant code, enhancing the overall quality of OpenTofu configurations.\n+\n+## Proposed Solution\n+\n+* **Input Variables**:\n+  During validation, if an input variable is declared in a module but never referenced, a warning is emitted\u2014except when the variable is marked as `deprecated`. In that case, the warning is only emitted if a value is assigned to the variable by a caller.\n+\n+* **Local Values**:\n+  If a value declared inside a `locals` block is not referenced elsewhere in the module, a warning is emitted during validation.\n+\n+### User Documentation\n+\n+```bash\n+tofu validate\n+[Warning]  variable xxx defined but not used inside code",
        "comment_created_at": "2025-05-27T13:56:48+00:00",
        "comment_author": "jgalais",
        "comment_body": "@Yantrio What do you think about my proposal ?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084686767",
    "pr_number": 2793,
    "pr_file": "rfc/20250317-ephemeral-resources.md",
    "created_at": "2025-05-12T13:31:45+00:00",
    "commented_code": "+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2084686767",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084686767",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.",
        "comment_created_at": "2025-05-12T13:31:45+00:00",
        "comment_author": "Yantrio",
        "comment_body": "We should reference that work has already been done to decouple the idea of something having a mark and something being sensitive.",
        "pr_file_module": null
      },
      {
        "comment_id": "2086360208",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084686767",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.",
        "comment_created_at": "2025-05-13T09:30:04+00:00",
        "comment_author": "yottta",
        "comment_body": "I am not aware of this. Could you expand it a little bit please?",
        "pr_file_module": null
      },
      {
        "comment_id": "2095580684",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084686767",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.",
        "comment_created_at": "2025-05-19T12:18:09+00:00",
        "comment_author": "Yantrio",
        "comment_body": "https://github.com/opentofu/opentofu/pull/2503 This PR. \r\n\r\nPreviously in the codebase there was only one type of mark. So you could check if something was sensitive by ensuring that it was marked or not. \r\n\r\nThis had to be refactored a little to allow multiple marks (first deprecated, and now this)",
        "pr_file_module": null
      },
      {
        "comment_id": "2095625834",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084686767",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.",
        "comment_created_at": "2025-05-19T12:41:43+00:00",
        "comment_author": "yottta",
        "comment_body": "Oh, this is what you meant! Ok. I misread your initial comment.\r\nUpdated in 2695d6c58dc739ceae192242733ddea987cdf450",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084690725",
    "pr_number": 2793,
    "pr_file": "rfc/20250317-ephemeral-resources.md",
    "created_at": "2025-05-12T13:33:49+00:00",
    "commented_code": "+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2084690725",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084690725",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.",
        "comment_created_at": "2025-05-12T13:33:49+00:00",
        "comment_author": "Yantrio",
        "comment_body": "do we also need to introduce some checks/tests to ensure that functions such as `sensitive()` do not accidentally strip the ephemeral mark too?",
        "pr_file_module": null
      },
      {
        "comment_id": "2086370094",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084690725",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.",
        "comment_created_at": "2025-05-13T09:35:00+00:00",
        "comment_author": "yottta",
        "comment_body": "3fe9247caedeef0099138111dece7a18065cda2b",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084696667",
    "pr_number": 2793,
    "pr_file": "rfc/20250317-ephemeral-resources.md",
    "created_at": "2025-05-12T13:36:39+00:00",
    "commented_code": "+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2084696667",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084696667",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+",
        "comment_created_at": "2025-05-12T13:36:39+00:00",
        "comment_author": "Yantrio",
        "comment_body": "let's not forget to document here that variables that take in ephemeral marked values should also be implicitly marked as ephemeral",
        "pr_file_module": null
      },
      {
        "comment_id": "2086538413",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084696667",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+",
        "comment_created_at": "2025-05-13T10:58:53+00:00",
        "comment_author": "yottta",
        "comment_body": "Added information in 11a29cb050fd95ab55b5f6d5df01bba3c73af854.\r\nA variable will not become ephemeral strictly from referencing an ephemeral value. In order for it to be able to work with ephemeral values, it needs to be configured specifically.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084716880",
    "pr_number": 2793,
    "pr_file": "rfc/20250317-ephemeral-resources.md",
    "created_at": "2025-05-12T13:46:29+00:00",
    "commented_code": "+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+\n+### Ephemeral resources\n+Due to the fact ephemeral resources are not stored in the state/plan file, this block is not creating a diff in the OpenTofu's UI.\n+Instead, OpenTofu will notify the user of opening/renewing/closing an ephemeral resource with messages similar to the following:\n+```bash\n+ephemeral.playground_random.password: Opening...\n+ephemeral.playground_random.password: Opening succeeded after 0s\n+ephemeral.playground_random.password: Closing...\n+ephemeral.playground_random.password: Closing succeeded after 0s\n+```\n+\n+Ephemeral resources lifecycle is similar with the data blocks:\n+* Both basic implementations require the same methods (`Metadata` and `Schema`) while datasource is defining `Read` compared with the ephemeral resource that is defining `Open`. When talking about the basic functionality of the ephemeral resources, the `Read` method will behave similarly with the `Read` on a datasource, where it reads the data.\n+* Also, both blocks support `Configure`, `ConfigValidators` and `ValidateConfig` as extensions of the basic definition.\n+* Ephemeral resources do support two more operations in contrast with datasources:\n+  * `Renew`\n+    * Together with the data returned by the `Open` method call, the provider can also specify a `RenewAt` which will be a specific moment in time when OpenTofu should call the `Renew` method to get an updated information from the ephemeral resource. OpenTofu will have to check for `RenewAt` value anytime it intends to use the value returned by the ephemeral resource.\n+  * `Close`\n+    * When an ephemeral resource is having this method defined, it is expecting it to be called in order to release a possible held resource. A good example of this is with a Vault provider that could provide a secret by obtaining a lease, and when the secret is done being used, OpenTofu should call `Close` on that ephemeral resource to instruct on releasing the lease and revoking the secret.\n+\n+To sum the above details, ephemeral resources are having 1 mandatory method and several optional methods:\n+* required\n+  * Schema - will not get in details of this in this RFC since the usage of this is similar with what we are doing for any other data types from a provider\n+  * Open\n+* optional\n+  * Renew\n+  * Close\n+\n+#### Basic OpenTofu handling of ephemeral resources\n+As per an initial analysis, the ephemeral blocks should be handled similarly to a data source block by allowing [ConfigTransformer](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/tofu/transform_config.go#L100) to generate a NodeAbstractResource. This is needed because ephemeral resources lifecycle needs to follow the ones for resources and data sources where they need to have a graph vertices in order to allow other concepts of OpenTofu to create depedencies on it. \n+\n+The gRPC proto schema is already updated in the OpenTofu project and contains the methods and data structures necessary for the epehemeral resources.\n+In order to make that available to be used, [providers.Interface](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/providers/provider.go#L109) needs to get the necessary methods and implement those in [GRPCProviderPlugin (V5)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin/grpc_provider.go#L31) and [GRPCProviderPlugin (V6)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin6/grpc_provider.go#L31).\n+\n+#### Configuration model\n+Beside the attributes that are defined by the provider for an ephemeral resource, the following meta-arguments needs to be supported by any ephemeral block:\n+* lifecycle\n+* count\n+* for_each\n+* depends_on\n+* provider\n+\n+#### `Open` method details\n+When OpenTofu will have to use an ephemeral resource, it needs to call its `Open` method, passing over the config of the ephemeral resource.\n+\n+The call to the `Open` method will return the following data:\n+* `Private` that OpenTofu is not going to use in other contexts than calling the provider `Close` or `Renew` optionally defined methods.\n+* `Result` that will contain the actual ephemeral information. This is what OpenTofu needs to handle to make it available to other ephemeral contexts to reference.\n+* `RenewAt` being an optional timestamp indicating when OpenTofu will have to call `Renew` method on the provider before using again the data from the `Result`.\n+\n+Observations:\n+* In the `Result`, OpenTofu is epecting to find any non-computed given values in the request, otherwise will return an error.\n+* In the `Result`, the fields marked as computed can be either null or have an actual value. If an unknown if found, OpenTofu will return an error.\n+\n+> [!NOTE]\n+>\n+> If any information in the configuration of an ephemeral resource is unknown during the `plan` phase, OpenTofu will defer the provisioning of the resource for the `apply` phase.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2084716880",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084716880",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+\n+### Ephemeral resources\n+Due to the fact ephemeral resources are not stored in the state/plan file, this block is not creating a diff in the OpenTofu's UI.\n+Instead, OpenTofu will notify the user of opening/renewing/closing an ephemeral resource with messages similar to the following:\n+```bash\n+ephemeral.playground_random.password: Opening...\n+ephemeral.playground_random.password: Opening succeeded after 0s\n+ephemeral.playground_random.password: Closing...\n+ephemeral.playground_random.password: Closing succeeded after 0s\n+```\n+\n+Ephemeral resources lifecycle is similar with the data blocks:\n+* Both basic implementations require the same methods (`Metadata` and `Schema`) while datasource is defining `Read` compared with the ephemeral resource that is defining `Open`. When talking about the basic functionality of the ephemeral resources, the `Read` method will behave similarly with the `Read` on a datasource, where it reads the data.\n+* Also, both blocks support `Configure`, `ConfigValidators` and `ValidateConfig` as extensions of the basic definition.\n+* Ephemeral resources do support two more operations in contrast with datasources:\n+  * `Renew`\n+    * Together with the data returned by the `Open` method call, the provider can also specify a `RenewAt` which will be a specific moment in time when OpenTofu should call the `Renew` method to get an updated information from the ephemeral resource. OpenTofu will have to check for `RenewAt` value anytime it intends to use the value returned by the ephemeral resource.\n+  * `Close`\n+    * When an ephemeral resource is having this method defined, it is expecting it to be called in order to release a possible held resource. A good example of this is with a Vault provider that could provide a secret by obtaining a lease, and when the secret is done being used, OpenTofu should call `Close` on that ephemeral resource to instruct on releasing the lease and revoking the secret.\n+\n+To sum the above details, ephemeral resources are having 1 mandatory method and several optional methods:\n+* required\n+  * Schema - will not get in details of this in this RFC since the usage of this is similar with what we are doing for any other data types from a provider\n+  * Open\n+* optional\n+  * Renew\n+  * Close\n+\n+#### Basic OpenTofu handling of ephemeral resources\n+As per an initial analysis, the ephemeral blocks should be handled similarly to a data source block by allowing [ConfigTransformer](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/tofu/transform_config.go#L100) to generate a NodeAbstractResource. This is needed because ephemeral resources lifecycle needs to follow the ones for resources and data sources where they need to have a graph vertices in order to allow other concepts of OpenTofu to create depedencies on it. \n+\n+The gRPC proto schema is already updated in the OpenTofu project and contains the methods and data structures necessary for the epehemeral resources.\n+In order to make that available to be used, [providers.Interface](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/providers/provider.go#L109) needs to get the necessary methods and implement those in [GRPCProviderPlugin (V5)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin/grpc_provider.go#L31) and [GRPCProviderPlugin (V6)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin6/grpc_provider.go#L31).\n+\n+#### Configuration model\n+Beside the attributes that are defined by the provider for an ephemeral resource, the following meta-arguments needs to be supported by any ephemeral block:\n+* lifecycle\n+* count\n+* for_each\n+* depends_on\n+* provider\n+\n+#### `Open` method details\n+When OpenTofu will have to use an ephemeral resource, it needs to call its `Open` method, passing over the config of the ephemeral resource.\n+\n+The call to the `Open` method will return the following data:\n+* `Private` that OpenTofu is not going to use in other contexts than calling the provider `Close` or `Renew` optionally defined methods.\n+* `Result` that will contain the actual ephemeral information. This is what OpenTofu needs to handle to make it available to other ephemeral contexts to reference.\n+* `RenewAt` being an optional timestamp indicating when OpenTofu will have to call `Renew` method on the provider before using again the data from the `Result`.\n+\n+Observations:\n+* In the `Result`, OpenTofu is epecting to find any non-computed given values in the request, otherwise will return an error.\n+* In the `Result`, the fields marked as computed can be either null or have an actual value. If an unknown if found, OpenTofu will return an error.\n+\n+> [!NOTE]\n+>\n+> If any information in the configuration of an ephemeral resource is unknown during the `plan` phase, OpenTofu will defer the provisioning of the resource for the `apply` phase.",
        "comment_created_at": "2025-05-12T13:46:29+00:00",
        "comment_author": "Yantrio",
        "comment_body": "```suggestion\r\n> If any information in the configuration of an ephemeral resource is unknown during the `plan` phase, OpenTofu will defer the provisioning of the resource for the `apply` phase. This means that inconsistency can occur between the plan and the apply phase.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2086709035",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2793,
        "pr_file": "rfc/20250317-ephemeral-resources.md",
        "discussion_id": "2084716880",
        "commented_code": "@@ -0,0 +1,646 @@\n+# Ephemeral resources, variables, outputs, locals and write-only arguments\n+\n+Issue: https://github.com/opentofu/opentofu/issues/1996\n+\n+Right now, OpenTofu information for resources and outputs are written to state as it is. This is presenting a security risk\n+as some of the information from the stored objects can contain sensitive bits that can become visible to whoever is having access to the state file.\n+\n+In order to provide a better solution for the aforementioned situation, OpenTofu introduces the concept of \"ephemerality\".\n+Any new feature under this new concept will provide ways to skip values from being written to the state and plan files.\n+\n+To make this work seamlessly with most of the blocks that OpenTofu supports, the following functionalities need to be able to work with the ephemeral concept:\n+* `resource`'s `write-only` attributes\n+* variables\n+* outputs\n+* locals\n+* `ephemeral` resources\n+* providers\n+* provisioners\n+* `connection` block\n+\n+## Proposed Solution\n+\n+In the attempt of providing to the reader an in-depth understanding of the ephemerality implications in OpenTofu,\n+this section will try to explain the functional approach of the new concept in each existing feature.\n+\n+### Write-only attributes\n+This is a new concept that allows any existing `resource` to define attributes in its schema that can be only written without the ability to retrieve the value afterwards.\n+\n+By not being readable, this also means that an attribute configured by a provider this way, will not be written to the state or plan file either.\n+Therefore, these attributes are suitable for configuring specific resources with sensitive data, like passwords, access keys, etc.\n+\n+A write-only attribute can accept an ephemeral or a non-ephemeral value, even though it's recommended to use ephemeral values for such attributes.\n+\n+Because these attributes are not written to the plan file, the update of a write-only attribute it's getting a little bit trickier.\n+Provider implementations do generally include also a \"version\" argument linked to the write-only one.\n+For example having a write-only argument called `secret`, providers should also include\n+a non-write-only argument called `secret_version`. Every time the user wants to update the value of `secret`, it needs to change the value of `secret_version` to trigger a change.\n+The provider implementation is responsible with handling this particular case: because the version attribute is stored also in the state, the provider needs to compare the value from the state with the one from the configuration and in case it differs, it will trigger the update of the `secret` attribute.\n+\n+The write-only attributes are supported momentarily by a low number of providers and resources.\n+Having the `aws_db_instance` as one of those, here is an example on how to use the write-only attributes:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"your-initial-password\"\n+  password_wo_version = 1\n+  // ...\n+}\n+```\n+By updating **only** the `password_wo`, on the `tofu apply`, the password will not be updated.\n+To do so, the `password_wo_version` needs to be incremented too:\n+```hcl\n+resource \"aws_db_instance\" \"example\" {\n+  // ...\n+  password_wo         = \"new-password\"\n+  password_wo_version = 2\n+  // ...\n+}\n+```\n+\n+As seen in this particular change of the [terraform-plugin-framework](https://github.com/hashicorp/terraform-plugin-framework/commit/ecd80f67daed0b92b243ae59bb1ee2077f8077c7), the write-only attribute cannot be configured for set attributes, set nested attributes and set nested blocks.\n+\n+Write-only attributes cannot generate a plan diff because the prior state does not contain a value that OpenTofu can use to compare the new value against and also the planned value of a write-only argument will always be empty.\n+### Variables\n+Any `variable` block can be marked as ephemeral.\n+```hcl\n+variable \"ephemeral_var\" {\n+  type      = string\n+  ephemeral = true\n+}\n+```\n+OpenTofu will allow usage of these variables only in other ephemeral contexts:\n+* write-only arguments\n+* other ephemeral variables\n+* ephemeral outputs\n+* local values\n+* ephemeral resources\n+* provisioner blocks\n+* connection blocks\n+* provider configuration\n+\n+Usage in any other place will raise an error:\n+```shell\n+\u2502 Error: Invalid use of an ephemeral value\n+\u2502\n+\u2502   with playground_secret.store_secret,\n+\u2502   on main.tf line 30, in resource \"playground_secret\" \"store_secret\":\n+\u2502   30:   secret_name = var.password\n+\u2502\n+\u2502 \"secret_name\" cannot accept an ephemeral value because it is not a write-only attribute which means that will be written to the state.\n+\u2575\n+```\n+\n+OpenTofu will not store ephemeral variable(s) in plan files. \n+If a plan is generated from a configuration that is having at least one ephemeral variable, \n+when the planfile will be applied, the value(s) for the ephemeral variable(s) needs to passed again by \n+using `-var` or `-var-file` arguments.\n+\n+### Outputs\n+An `output` block can be configured as ephemeral as long as it's\n+not from the root module. \n+This limitation is natural since ephemeral outputs are meant to be skipped from the state file. Therefore, there is no usage of such a defined output block in a root module.\n+\n+Ephemeral outputs are useful when a child module returns sensitive data, allowing the caller to use the value of that output in other ephemeral contexts.\n+\n+To mark an output as ephemeral, use the following syntax:\n+```hcl\n+output \"test\" {\n+  // ...\n+  ephemeral = true\n+}\n+```\n+\n+The ephemeral outputs are available during plan and apply phase and can be accessed only in specific contexts:\n+* ephemeral variables\n+* other ephemeral outputs\n+* write-only attributes\n+* ephemeral resources\n+* `provisioner` block\n+* `connection` block\n+\n+### Locals\n+Local values are automatically marked as ephemeral if any of the value that is used to compute the local is already an ephemeral one.\n+\n+Eg:\n+```hcl\n+variable \"a\" {\n+  type = string\n+  default = \"a value\"\n+}\n+\n+variable \"b\" {\n+  type = string\n+  default = \"b value\"\n+  ephemeral = true\n+}\n+\n+locals {\n+  a_and_b = \"${var.a}_${var.b}\"\n+}\n+```\n+Because variable `b` is marked as `ephemeral`, then the local `a_and_b` is marked as `ephemeral` too.\n+\n+Locals marked as ephemeral are available during plan and apply phase and can be referenced only in specific contexts:\n+* ephemeral variables\n+* other ephemeral locals\n+* write-only attributes\n+* ephemeral resources\n+* `provider` blocks configuration\n+* `connection` and `provisioner` blocks\n+\n+### Ephemeral resource\n+In contrast with the write-only arguments where only specifically tagged attributes are skipped from the state/plan file, `ephemeral` resources are skipped entirely.\n+The ephemeral blocks are behaving similar to `data`, where it reads the indicated resource and once it's done with it, is going to close it.\n+\n+For example, you can have an ephemeral resource that is retrieving the password from a secret manager, password that can be passed later into a write-only attribute of another normal `resource`.\n+\n+Ephemeral resources can be referenced only in specific contexts:\n+* other ephemeral resources\n+* ephemeral variables\n+* ephemeral outputs\n+* locals\n+* to configure `provider` blocks\n+* in `provisioner` and `connection` blocks\n+* in write-only arguments\n+\n+### Providers\n+`provider` block is ephemeral by nature, meaning that the configuration of this is never stored into state/plan file.\n+\n+Therefore, this block should be configurable by using ephemeral values.\n+\n+### `provisioner` block\n+As `provisioner` information is not stored into the plan/state file, this can reference ephemeral values like ephemeral variables, outputs, locals and values from ephemeral resources.\n+\n+Whenever doing so, the output of the provisioner execution should be suppressed:\n+```shell\n+(local-exec): (output suppressed due to ephemeral value in config)\n+```\n+### `connection` block\n+When the `connection` block is configured, this will be allowed to use ephemeral values from variables, outputs, locals and values from ephemeral resources. \n+\n+## User Documentation\n+For a better understanding on what to expect from this proposal, let's start with an example.\n+### Configuration\n+#### `./mod/main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+\n+variable \"secret_map\" {\n+  type      = map(string)\n+  default   = {\n+    \"key_from_module\": \"default value from module\"\n+  }\n+  ephemeral = true # (1)\n+}\n+\n+variable \"secret_version\" { # (2)\n+  type    = number\n+  default = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"manager\" {\n+  name = \"ephemeral-rfc-example\"\n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+  secret_id                = aws_secretsmanager_secret.manager.arn\n+  secret_string_wo         = jsonencode(var.secret_map)\n+  secret_string_wo_version = var.secret_version\n+}\n+\n+ephemeral \"aws_secretsmanager_secret_version\" \"secret_retrieval\" { # (3)\n+  secret_id  = aws_secretsmanager_secret.manager.arn\n+  depends_on = [\n+    aws_secretsmanager_secret_version.secret_creation\n+  ]\n+}\n+\n+output \"secrets\" {\n+  ephemeral = true # (4)\n+  value     = jsondecode(ephemeral.aws_secretsmanager_secret_version.secret_retrieval.secret_string)\n+}\n+```\n+\n+#### `./main.tf`\n+```hcl\n+terraform {\n+  required_providers {\n+    aws = {\n+      source  = \"hashicorp/aws\"\n+      version = \"6.0.0-beta1\"\n+    }\n+  }\n+}\n+provider \"aws\" {}\n+\n+variable \"secrets\" {\n+  type = map(string)\n+  default = {\n+    \"key_from_root\" : \"default value from root\"\n+  }\n+  ephemeral = false # (5)\n+}\n+\n+module \"secret_management\" {\n+  source         = \"./mod\"\n+  secret_map     = var.secrets\n+  secret_version = 1\n+}\n+\n+resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" { # (6)\n+  name = \"ephemeral-rfc-example-just-store\" \n+}\n+\n+resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+  secret_id                = aws_secretsmanager_secret.store_ephemeral_in_here.arn\n+  secret_string_wo         = jsonencode(module.secret_management.secrets) # (7)\n+  secret_string_wo_version = 1\n+}\n+\n+output \"write_only_out\" { # (8)\n+  value     = aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo\n+  sensitive = true\n+}\n+\n+resource \"aws_s3_object\" \"obj\" {\n+  bucket = \"opentofu-yottta-tofu-state\"\n+  key    = \"test\"\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral value: ${aws_secretsmanager_secret.store_ephemeral_in_here.arn}\"\n+  }\n+\n+  # provisioner \"local-exec\" { # (9)\n+  #   when    = create\n+  #   command = \"echo write-only value: ${aws_secretsmanager_secret_version.store_from_ephemeral_output.secret_string_wo}\"\n+  # }\n+\n+  provisioner \"local-exec\" { # (10)\n+    when    = create\n+    command = \"echo ephemeral value from module: #${jsonencode(module.secret_management.secrets)}#\"\n+  }\n+\n+  provisioner \"local-exec\" {\n+    when    = create\n+    command = \"echo non-ephemeral variable from root: #${jsonencode(var.secrets)}#\"\n+  }\n+}\n+```\n+\n+- (1) Variables will be able to be marked as ephemeral. By doing so, those will be able to be used only in ephemeral contexts.\n+- (2) Version field that is going together with the actual write-only argument to be able to update the value of it. To upgrade the secret, the version field needs to be updated, otherwise OpenTofu will generate no diff for it.\n+- (3) Using ephemeral resource to retrieve the secret. Maybe looks a little bit weird, because right above we are having the resource of the same type that is looking like it should be able to be used to get the secret. In reality, because that `resource` is using `secret_string_wo` to store the information, that field is going to be null when referenced. Check (9) for more details.\n+- (4) Module output that is referencing an ephemeral value, it needs to be marked as ephemeral too. Otherwise, OpenTofu will generate an error.\n+- (5) The variable that is going to be used in an ephemeral variable, is not required to be ephemeral. The value can also be a hardcoded value without being ephemeral.\n+- (6) Here we used another `aws_secretsmanager_secret` just to have an easier example on how ephemeral/write-only/(ephemeral variables)/(ephemeral outputs) are working together. But there will be more and more resources that will allow to work with this new concept.\n+- (7) Referencing a module ephemeral output to ensure that the ephemeral information is passed correctly between two modules.\n+- (8) Creating an output that is referencing a write-only argument *requires* the output to be marked as sensitive. \n+  > [!WARNING]\n+  >\n+  > Shouldn't we also show an error similar to the error that is proposed to be shown when the root module is having an output marked as ephemeral?\n+- (9) That is commented out because interpolation on null values is not allowed in OpenTofu. Reminder: a write-only argument will always be returned as null from the provider even when the configuration is actually having a value.\n+- (10) A provisioner that is referencing an ephemeral value (module output) will have its output supressed. See more details in the next section.\n+\n+### CLI Output\n+\n+```\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Configuration unknown, deferring... <--- (11)\n+\n+  # aws_s3_object.obj will be created\n+  + resource \"aws_s3_object\" \"obj\" {\n+      + bucket                 = \"bucket-name\"\n+      + force_destroy          = false\n+      + key                    = \"test\"\n+      + region                 = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret.store_ephemeral_in_here will be created\n+  + resource \"aws_secretsmanager_secret\" \"store_ephemeral_in_here\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example-just-store\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # aws_secretsmanager_secret_version.store_from_ephemeral_output will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"store_from_ephemeral_output\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 1\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret.manager will be created\n+  + resource \"aws_secretsmanager_secret\" \"manager\" {\n+      + force_overwrite_replica_secret = false\n+      + name                           = \"ephemeral-rfc-example\"\n+      + recovery_window_in_days        = 30\n+      + region                         = \"eu-central-1\"\n+      # ...\n+    }\n+\n+  # module.secret_management.aws_secretsmanager_secret_version.secret_creation will be created\n+  + resource \"aws_secretsmanager_secret_version\" \"secret_creation\" {\n+      + region                   = \"eu-central-1\"\n+      + secret_string_wo         = (write-only attribute)\n+      + secret_string_wo_version = 2\n+      # ...\n+    } \n+^^^ (12)\n+\n+Plan: 5 to add, 0 to change, 0 to destroy.\n+\n+module.secret_management.aws_secretsmanager_secret.manager: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creating...\n+module.secret_management.aws_secretsmanager_secret.manager: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creating...\n+aws_secretsmanager_secret.store_ephemeral_in_here: Creation complete after 1s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+module.secret_management.aws_secretsmanager_secret_version.secret_creation: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-xxxxxx]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening... <--- (13)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Opening complete after 0s\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creating...\n+aws_s3_object.obj: Creating...\n+aws_secretsmanager_secret_version.store_from_ephemeral_output: Creation complete after 0s [id=arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx]\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\"]\n+aws_s3_object.obj (local-exec): non-ephemeral value: arn:aws:secretsmanager:eu-central-1:ACC_ID:secret:ephemeral-rfc-example-just-store-xxxxxx\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config) <--- (14)\n+aws_s3_object.obj (local-exec): (output suppressed due to ephemeral value in config)\n+aws_s3_object.obj: Provisioning with 'local-exec'...\n+aws_s3_object.obj (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ephemeral value from root: #{\\\"key_from_root\\\":\\\"default value from root\\\"}#\"]\n+aws_s3_object.obj (local-exec): ephemeral value from root:\n+aws_s3_object.obj: Creation complete after 0s [id=test]\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing... <--- (15)\n+module.secret_management.ephemeral.aws_secretsmanager_secret_version.secret_retrieval: Closing complete after 0s\n+\n+Apply complete! Resources: 5 added, 0 changed, 0 destroyed.\n+```\n+\n+Breakdown:\n+- (11) - If an ephemeral block is referencing any unknown value, the opening is deferred for later, when the value will be known.\n+- (12).  As can be seen, the ephemeral resources are not shown in the list of changes. The only mention of those is in the actual action logs where we can see that it opens and closing those.\n+- (13).  This will be visible in the action logs, while an ephemeral resource will be opened.\n+- (14).  This is how a provisioner output should look like when an ephemeral value is used inside.\n+- (15).  This will be visible in the action logs, while an ephemeral resource will be closed.\n+\n+## Technical Approach\n+In this section, as in the \"Proposed Solution\" section, we'll go over each concept, but this time with a more technical focus.\n+\n+### Write-only arguments\n+Most of the write-only arguments logic is already in the [provider-framework](https://github.com/hashicorp/terraform-plugin-framework):\n+* [Initial implementation](https://github.com/hashicorp/terraform-plugin-framework/pull/1044)\n+* [Sets comparisson enhancement](https://github.com/hashicorp/terraform-plugin-framework/pull/1064)\n+  * This seems to be related to the reason why sets of any kind are not allowed to be marked as write-only\n+* [Dynamic attribute validation](https://github.com/hashicorp/terraform-plugin-framework/pull/1090)\n+* [Prevent write-only for sets](https://github.com/hashicorp/terraform-plugin-framework/pull/1095)\n+* [Nullifying write-only attributes moved to an earlier stage](https://github.com/hashicorp/terraform-plugin-framework/pull/1097)\n+\n+On the OpenTofu side the following needs to be tackled:\n+* Update [Attribute](https://github.com/opentofu/opentofu/blob/ff4c84055065fa2d83d318155b72aef6434d99e4/internal/configs/configschema/schema.go#L44) to add a field for the WriteOnly flag.\n+* Update the validation of the provider generated plan in such a way to allow nil values for the fields that are actually having a value defined in the configuration. This is necessary because the plugin framework is setting nil any values that are marked as write-only.\n+  * Test this in-depth for all the block types except sets of any kind (Investigate and understand why sets are not allowed by the plugin framework).\n+    * Add a new validation on the provider schema to check against, set nested attributes and set nested blocks with writeOnly=true. Tested this with a version of terraform-plugin-framework that allowed writeOnly on sets and there is an error returned. (set attributes are allowed based on my tests)\n+    In order to understand this better, maybe we should allow this for the moment and test OpenTofu with the [plugin-framework version](https://github.com/hashicorp/terraform-plugin-framework/commit/0724df105602e6b6676e201b7c0c5e1d187df990) that allows sets to be write-only=true.\n+\n+> [!NOTE]\n+>\n+> Write-only attributes will be presented in the OpenTofu's UI as `(write-only attribute)` instead of the actual value.\n+\n+### Variables\n+\n+For enabling ephemeral variables, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the variables with a new mark ensure that the marks are propagated correctly.\n+* Based on the marks, ensure that the variable cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+* Check the state of [#1998](https://github.com/opentofu/opentofu/pull/1998). If that is merged, in the changes where variables from plan are verified against the configuration ones, we also need to add a validation on the ephemerality of variables. If the variable is marked as ephemeral, then the plan value is allowed (expected) to be missing. \n+* Ensure that when the prompt is shown for an ephemeral variable there is an indication of that:\n+  ```hcl\n+  var.password (ephemeral)\n+     Enter a value:\n+  ````\n+* If a module is having an ephemeral variable declared, that variable can get values from any source, even another non-ephemeral variable.\n+\n+We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+\n+### Outputs\n+\n+For enabling ephemeral outputs, these are the basic steps that need to be taken:\n+* Update config to support the `ephemeral` attribute.\n+* Mark the outputs with a new mark and ensure that the marks are propagated correctly.\n+  * We should use boolean marks, as no additional information is required to be carried. When introducing the marks for these, extra care should be taken in *all* the places marks are handled and ensure that the existing implementation around marks is not affected.\n+* Based on the marks, ensure that the output cannot be used in other contexts than the ephemeral ones (see the User Documentation section for more details on where this is allowed).\n+\n+> [!TIP]\n+>\n+> For an example on how to properly introduce a new mark in the outputs, you can check the [PR](https://github.com/opentofu/opentofu/pull/2633) for the deprecated outputs.\n+\n+Strict rules:\n+* A root module cannot define ephemeral outputs since are useless.\n+* Any output that wants to use an ephemeral value, it needs to be marked as ephemeral too. Otherwise, it needs to show an error:\n+   ```hcl\n+    \u2502 Error: Output not marked as ephemeral\n+    \u2502\n+    \u2502   on mod/main.tf line 33, in output \"password\":\n+    \u2502   33:   value = reference.to.ephemeral.value\n+    \u2502\n+    \u2502 In order to allow this output to store ephemeral values add `ephemeral = true` attribute to it.\n+   ```\n+* Any output from a root module that is referencing a write only attribute needs to be marked as sensitive too. Otherwise, an error should be raised\n+  ```hcl\n+    \u2502 Error: An output referencing a sensitive value needs to be marked with sensitive too\n+    \u2502\n+    \u2502   on main.tf line 32:\n+    \u2502   32: output \"write_only_out\" {\n+    \u2502\n+    \u2502 For security reasons, OpenTofu requires any output that is referencing a sensitive value to also be configured the same. If the root module really wants to export this sensitive value, you need to annotate it with the following argument:\n+    \u2502     sensitive = true\n+  ```\n+\n+Considering the rules above, root modules cannot have any ephemeral outputs defined.\n+\n+### Locals\n+Any `local` declaration will be marked as ephemeral if in the expression that initialises it an ephemeral value is used:\n+```hcl\n+variable \"var1\" {\n+  type = string\n+}\n+\n+variable \"var2\" {\n+  type = string\n+}\n+\n+variable \"var3\" {\n+  type      = string\n+  ephemeral = true\n+}\n+\n+locals {\n+  eg1 = var.var1 == \"\" ? var.var2 : var.var1 // not ephemeral\n+  eg2 = var.var2 // not ephemeral\n+  eg3 = var.var3 == \"\" ? var.var2 : var.var1 // ephemeral because of var3 conditional\n+  eg4 = var.var1 == \"\" ? var.var2 : var.var3 // ephemeral because of var3 usage\n+  eg5 = \"${var.var3}-${var.var1}\" // ephemeral because of var3 usage\n+  eg6 = local.eg4 // ephemeral because of eg4 is ephemeral\n+}\n+```\n+\n+Once a local is marked as ephemeral, this can be used only in other ephemeral contexts. Check the `User Documentation` section for more details on the allowed contexts.\n+\n+### Ephemeral resources\n+Due to the fact ephemeral resources are not stored in the state/plan file, this block is not creating a diff in the OpenTofu's UI.\n+Instead, OpenTofu will notify the user of opening/renewing/closing an ephemeral resource with messages similar to the following:\n+```bash\n+ephemeral.playground_random.password: Opening...\n+ephemeral.playground_random.password: Opening succeeded after 0s\n+ephemeral.playground_random.password: Closing...\n+ephemeral.playground_random.password: Closing succeeded after 0s\n+```\n+\n+Ephemeral resources lifecycle is similar with the data blocks:\n+* Both basic implementations require the same methods (`Metadata` and `Schema`) while datasource is defining `Read` compared with the ephemeral resource that is defining `Open`. When talking about the basic functionality of the ephemeral resources, the `Read` method will behave similarly with the `Read` on a datasource, where it reads the data.\n+* Also, both blocks support `Configure`, `ConfigValidators` and `ValidateConfig` as extensions of the basic definition.\n+* Ephemeral resources do support two more operations in contrast with datasources:\n+  * `Renew`\n+    * Together with the data returned by the `Open` method call, the provider can also specify a `RenewAt` which will be a specific moment in time when OpenTofu should call the `Renew` method to get an updated information from the ephemeral resource. OpenTofu will have to check for `RenewAt` value anytime it intends to use the value returned by the ephemeral resource.\n+  * `Close`\n+    * When an ephemeral resource is having this method defined, it is expecting it to be called in order to release a possible held resource. A good example of this is with a Vault provider that could provide a secret by obtaining a lease, and when the secret is done being used, OpenTofu should call `Close` on that ephemeral resource to instruct on releasing the lease and revoking the secret.\n+\n+To sum the above details, ephemeral resources are having 1 mandatory method and several optional methods:\n+* required\n+  * Schema - will not get in details of this in this RFC since the usage of this is similar with what we are doing for any other data types from a provider\n+  * Open\n+* optional\n+  * Renew\n+  * Close\n+\n+#### Basic OpenTofu handling of ephemeral resources\n+As per an initial analysis, the ephemeral blocks should be handled similarly to a data source block by allowing [ConfigTransformer](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/tofu/transform_config.go#L100) to generate a NodeAbstractResource. This is needed because ephemeral resources lifecycle needs to follow the ones for resources and data sources where they need to have a graph vertices in order to allow other concepts of OpenTofu to create depedencies on it. \n+\n+The gRPC proto schema is already updated in the OpenTofu project and contains the methods and data structures necessary for the epehemeral resources.\n+In order to make that available to be used, [providers.Interface](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/providers/provider.go#L109) needs to get the necessary methods and implement those in [GRPCProviderPlugin (V5)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin/grpc_provider.go#L31) and [GRPCProviderPlugin (V6)](https://github.com/opentofu/opentofu/blob/26a77c91560d51f951aa760bdcbeecd93f9ef6b0/internal/plugin6/grpc_provider.go#L31).\n+\n+#### Configuration model\n+Beside the attributes that are defined by the provider for an ephemeral resource, the following meta-arguments needs to be supported by any ephemeral block:\n+* lifecycle\n+* count\n+* for_each\n+* depends_on\n+* provider\n+\n+#### `Open` method details\n+When OpenTofu will have to use an ephemeral resource, it needs to call its `Open` method, passing over the config of the ephemeral resource.\n+\n+The call to the `Open` method will return the following data:\n+* `Private` that OpenTofu is not going to use in other contexts than calling the provider `Close` or `Renew` optionally defined methods.\n+* `Result` that will contain the actual ephemeral information. This is what OpenTofu needs to handle to make it available to other ephemeral contexts to reference.\n+* `RenewAt` being an optional timestamp indicating when OpenTofu will have to call `Renew` method on the provider before using again the data from the `Result`.\n+\n+Observations:\n+* In the `Result`, OpenTofu is epecting to find any non-computed given values in the request, otherwise will return an error.\n+* In the `Result`, the fields marked as computed can be either null or have an actual value. If an unknown if found, OpenTofu will return an error.\n+\n+> [!NOTE]\n+>\n+> If any information in the configuration of an ephemeral resource is unknown during the `plan` phase, OpenTofu will defer the provisioning of the resource for the `apply` phase.",
        "comment_created_at": "2025-05-13T12:31:37+00:00",
        "comment_author": "yottta",
        "comment_body": "f603db886aa3d830534b5cc68f7e415e58e3d343",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1958118010",
    "pr_number": 2511,
    "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
    "created_at": "2025-02-17T12:02:49+00:00",
    "commented_code": "+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1958118010",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1958118010",
        "commented_code": "@@ -0,0 +1,133 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.",
        "comment_created_at": "2025-02-17T12:02:49+00:00",
        "comment_author": "ollevche",
        "comment_body": "```suggestion\r\n> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider supports conditional writes in the same way AWS S3 is offering.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1958210530",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2511,
        "pr_file": "rfc/20250211-s3-locking-with-conditional-writes.md",
        "discussion_id": "1958118010",
        "commented_code": "@@ -0,0 +1,133 @@\n+# S3 Backend: Locking by using the recently released feature of conditional writes\n+\n+Issue: https://github.com/opentofu/opentofu/issues/599\n+\n+Considering the request from the ticket above, and the newly AWS released S3 feature, we can now have state locking without relying on DynamoDB.\n+\n+The main reasons for such a change could be summarized as follows:\n+* Less resources to maintain.\n+* Potentially reducing costs by eliminating usage of dynamo db.\n+* One less point of failure (removing DynamoDB from the state management)\n+\n+The most important things that need to be handled during this implementation:\n+* A simple way to enable/disable locking by using S3 conditional writes.\n+* A path forward to migrate the locking from DynamoDB to S3.\n+* The default behavior should be untouched as long as the `backend` block configuration contains no attributes related to the new locking option.\n+\n+## Proposed Solution\n+\n+Until recently, most of the approaches that could have been taken for this implementation, could have been prone to data races.\n+But AWS has released new functionality for S3, supporting conditional writes on objects in any S3 bucket.\n+\n+For more details on the AWS S3 feature and the way it works, you can read more on the [official docs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/conditional-writes.html).\n+\n+> By using conditional writes, you can add an additional header to your WRITE requests to specify preconditions for your Amazon S3 operation. To conditionally write objects, add the HTTP `If-None-Match` or `If-Match` header.\n+> \n+> The `If-None-Match` header prevents overwrites of existing data by validating that there's not an object with the same key name already in your bucket.\n+>\n+> Alternatively, you can add the `If-Match` header to check an object's entity tag (`ETag`) before writing an object. With this header, Amazon S3 compares the provided `ETag` value with the `ETag` value of the object in S3. If the `ETag` values don't match, the operation fails.\n+\n+\n+To allow this in OpenTofu, the `backend \"s3\"` will receive one new attribute:\n+* `use_lockfile` `bool` (Default: `false`) - Flag to indicate if the locking should be performed by using strictly the S3 bucket.\n+\n+> [!NOTE]\n+>\n+> The name `use_lockfile` was selected this way to keep the [feature parity with Terraform](https://developer.hashicorp.com/terraform/language/backend/s3#state-locking).\n+\n+### User Documentation\n+\n+In order to make use of this new feature, the users will have to add the attribute in the `backend` block:\n+```terraform\n+terraform {\n+  backend \"s3\" {\n+    bucket = \"tofu-state-backend\"\n+    key = \"statefile\"\n+    region = \"us-east-1\"\n+    dynamodb_table = \"tofu_locking\"\n+    use_lockfile = true\n+  }\n+}\n+```\n+\n+* When the new attribute `use_lockfile` exists and `dynamodb_table` is missing, OpenTofu will try to acquire the lock inside the configured S3 bucket.\n+* When the new attribute `use_lockfile` will exist **alongside** `dynamodb_table`, OpenTofu will:\n+  * Acquire the lock in the S3 bucket;\n+  * Acquire the lock in DynamoDB table;\n+  * Get the digest of the state object from DynamoDB and ensure the state object content integrity;\n+  * Perform the requested sub-command;\n+  * Release the lock from the S3 bucket;\n+  * Release the lock from DynamoDB table.\n+\n+The usage of [workspaces](https://opentofu.org/docs/language/state/workspaces/) will not impact this new way of locking. The locking object will always be stored right next to its related state object.\n+\n+> [!NOTE]\n+>\n+> OpenTofu [recommends](https://opentofu.org/docs/language/settings/backends/s3/) to have versioning enabled for the S3 buckets used to store state objects.\n+>\n+> Acquiring and releasing locks will add a good amount of writes and reads to the bucket. Therefore, for a versioning-enabled S3 bucket, the number of versions for that object could grow significantly.\n+> Even though the cost should be negligible for the locking objects, any user using this feature could consider configuring the lifecycle of the S3 bucket to limit the number of versions of an object.\n+\n+> [!WARNING]\n+> \n+> When OpenTofu S3 backend is used with an S3 compatible provider, it needs to be checked that the provider is supporting conditional writes in the same way AWS S3 is offering.",
        "comment_created_at": "2025-02-17T13:10:49+00:00",
        "comment_author": "yottta",
        "comment_body": "Applied in 6c43f94d46a40ebf22b652cb08d42bd5ba7f4179",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1820638536",
    "pr_number": 2115,
    "pr_file": "rfc/20240513-static-evaluation-providers.md",
    "created_at": "2024-10-29T11:42:45+00:00",
    "commented_code": "}\n \n provider \"aws\" {\n+  alias    = \"by_region\"\n   for_each = local.regions\n+\n   region = each.value\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   for_each = local.regions\n-  provider = aws[each.key]\n+  provider = aws.by_region[each.key]\n+\n+  # ...\n }\n \n module \"mod\" {\n+  source   = \"./mod\"\n   for_each = local.regions\n-  source = \"./mod\"\n-  providers {\n-    aws = aws[each.key]\n+  providers = {\n+    aws = aws.by_region[each.key]\n   }\n+\n+  # ...\n }\n ```\n \n+This use of `each.key` is familiar from its existing use in `resource`, `data`, and `module` blocks that use `for_each`. The bracketed portion of the address is evaluated dynamically by the main language runtime, and so (unlike the `for_each` argument in `provider` blocks) this particular expression is _not_ constrained to only static-eval-compatible symbols.\n+\n From a user perspective, this provider mapping is fairly simple to understand. As we will show in the Technical Approach, this will be quite difficult to implement.\n \n \n #### What's not currently allowed\n \n-There are scenarios that users might think could work, but we don't want to support at this time.\n+There are scenarios that module authors might think could work, but that we don't intend to support initially so that we can release an initial increment and then react to feedback.\n \n+##### Provider references as normal values\n \n-Storing a provider reference in a local or passing it as a variable\n ```hcl\n locals {\n-  my_provider = aws[\"us\"]\n+  my_provider = aws.by_region[\"us\"]\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   provider = local.my_provider\n }\n ```\n-It's not well defined what a \"provider reference\" is outside of a \"provider/providers\" block. All of the provider references are built as special cases that are handled beside the code and not as part of it directly.\n \n+It's not currenly well-defined what a \"provider reference\" is outside of a `provider` or `providers` argument. All of the provider references are built as special cases that are handled using HCL static analysis.\n+\n+Additionally, the OpenTofu language would currently recognize `aws.by_region` as a reference to a `resource \"aws\" \"by_region\"` block in any normal expression context, so we cannot easily redefine that existing meaning while retaining backward compatibility.\n+\n+Syntax compatibility concerns aside, it would be technically possible to treat a provider configuration reference as a value using a concept in the upstream library that provides the low-level building blocks of OpenTofu's type system: [`cty Capsule Types`](https://github.com/zclconf/go-cty/blob/main/docs/types.md#capsule-types). Assuming we also defined a suitable syntax for declaring a new kind of type constraint and referring to a provider in a normal expression, we could technically allow provider instance references to be passed around in a similar way as other values are passed around.\n+\n+##### One resource with multiple provider configurations\n+\n+OpenTofu's existing graph construction logic fundamentally assumes that each `resource` block is associated with exactly one provider configuration. This proposal introduces the possibility of a single provider configuration generating multiple provider _instances_, but since this initial proposal aims to avoid making significant changes to the graph transformation logic we will initially require that all instances of a particular resource refer to (potentially different) instances of the _same_ provider configuration.\n+\n+That restriction is most obvious in the simplest case where a `resource` block has `provider` directly referring to a provider instance in the same module:\n \n-Using the \"splat/*\" operator in module providers block:\n ```hcl\n-module \"mod\" {\n-  source = \"./mod\"\n-  providers {\n-    aws[*] = aws[*]\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"example\" {\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # The part in brackets is dynamic, but the initial reference to the\n+  # provider configuration block remains static, so effectively all\n+  # of the instances of this resource _must_ belong to the one\n+  # single provider configuration block above.\n+  provider = example.foo[each.key]\n+}\n+```\n+\n+This restriction also applies when passing provider configurations indirectly through module calls. Each instance of a module can have its own provider configuration namespace populated with different provider instances defined in the parent, but they must still all refer to the same configuration block:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+module \"example\" {\n+  source   = \"./example\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  providers = {\n+    # All of the resource blocks in this module can just assume there's\n+    # a default (unaliased) \"example\" provider instance available to\n+    # use. Each one is bound to a different instance from the provider\n+    # block above, but they must still nonetheless all be bound to\n+    # the same block.\n+    example = example.foo[each.key]\n   }\n }\n ```\n-This implies that all aliased aws providers would be passed into the child module. This is confusing as it conflicts with the existing idea of providers configs passed implicitly to child modules with the same names.\n \n-### Technical Approach\n+We should be able to loosen this restriction in a future RFC, either as part of a fully-dynamic design where provider references are normal expressions as described in the previous section or via some specialized syntax that's only used for provider configurations. The main requirement, regardless of how the surface syntax is designed, is that the graph builder change to support creating multiple dependency edges from a single resource node to multiple provider configuration nodes, so that evaluation of the resource node is delayed until after all of the possibly-referred-to provider configurations have been visited and thus their provider instances are running.\n \n-#### Provider Configuration Expansion\n+##### Passing collections of provider instances between modules.\n \n-##### Expansion\n+There was previously no syntax for causing a single provider configuration to produce multiple provider instances, and so we also have no existing syntax to use to differentiate between a reference to one provider instance v.s a reference to a collection of provider instances.\n \n-Expanding provider configurations can be done using the StaticContext available in [configs.NewModule()](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L122) as defined in the Static Evaluation RFC.\n+In this first implementation it's forbidden to refer to a multi-instance provider configuration without specifying an instance key.\n \n-At the end of the NewModule constructor, the configured provider's aliases can be expanded using the each/count, similar to how [module.ProviderLocalNames](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L186) is generated. This does not require any special workarounds and will resemble most other applications of the StaticContext.\n+For example, consider the following configuration:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"a\" {\n+  # The following is invalid: must include the instance key part to\n+  # tell OpenTofu how to select exactly one provider instance.\n+  provider = example.foo\n+}\n \n-```go\n-// Pseudocode\n-func NewModule(files []configs.File, ctx StaticContext) {\n-  module = &Module{}\n-  for _, file := range files {\n-    module.Append(file)\n+module \"child\" {\n+  source = \"./child\"\n+  providers = {\n+    # The right-hand side of this item is invalid: must include the\n+    # instance key part to tell OpenTofu how to select exactly one\n+    # provider instance.\n+    example.foo = example.foo\n   }\n+}\n+```\n+\n+The consequences of `example.foo` being invalid don't really matter for the `resource` block because it doesn't make sense to specify multiple provider instances for a single resource anyway.\n+\n+It _would_ be useful to be able to pass a collection of provider instances to a child module as shown in the second example, but that raises various new design questions about how the child module should declare that it's expecting to be passed a collection of provider instances, since today provider instance references are not normal values and so it isn't really meaningful to describe \"a map of `example` provider instances\".\n+\n+Leaving this unsupported for the first release again gives us room to consider various different design options in later RFCs as our understanding of the use-cases grows based on feedback. The following are some early potential designs we've considered so far, but it isn't clear yet which (if any) is the best fit:\n+\n+- Borrow the \"splat operator\" syntax to talk about recieving a collection of provider instances in the `configuration_aliases` argument of a module's `required_providers` block:\n \n-  ctx.AddVariables(module.Variables)\n-  ctx.AddLocals(module.Locals)\n+    ```hcl\n+    terraform {\n+      required_providers {\n+        example = {\n+          source = \"tf.example.com/example/example\"\n \n-  // Re-build the ProviderConfigs map with expansion\n-  newProviderConfigs := make(map)\n-  for _, cfg := range module.ProviderConfigs {\n-    for key, expanded := range cfg.expand(ctx) {\n-      newProviderConfigs[key] = expanded\n+          configuration_aliases = [\n+            # The following could potentially mean something similar to\n+            # a provider \"example\" block with alias = \"foo\" and a\n+            # for_each argument, specifying that this module expects its\n+            # caller to provide a collection of provider instances.\n+            example.foo[*]\n+          ]\n+        }\n+      }\n     }\n-  }\n-  module.ProviderConfigs = newProviderConfigs\n+    ```\n \n+- Borrow the \"splat operator\" syntax instead for use at the _call site_, so the calling module can declare that it's intending to pass a collection of instances:\n \n-  // Generate the FQN -> LocalProviderName map\n-  module.ProviderLocalNames()\n-}\n-```\n+    ```hcl\n+    module \"child\" {\n+      # ...\n+      providers = {\n+        aws.each_region[*] = aws.by_region[*]\n+      }\n+    }\n+    ```\n+\n+    This is similar to the previous idea except that it makes the assertion of intent to pass multiple instances appear on the caller side rather than on the callee side. It's technically redundant to use extra syntax here since the presence or absense of `for_each` in the `provider \"aws\"` block that has `alias = \"by_region\"` is already sufficient to represent whether `aws.by_region` is a single instance or a collection of instances, \n+\n+    (This and the previous option could potentially be combined together to allow both caller and callee to explicitly declare what they are intending to do.)\n+\n+- Wait until we're ready to support provider instance references being treated as normal values of a new type, and then encourage module authors to pass collections of provider configurations via input variables that use a new type constraint syntax, effectively deprecating the current provider-specific sidechannel.\n+\n+    This generalized approach would allow for various more interesting combinations, such as sending provider instances along with other data as part of a single object per region:\n+\n+    ```hcl\n+    variable \"aws_regions\" {\n+      type = map(object({\n+        cidr_block        = string\n+        provider_instance = providerinst(aws)\n+      }))\n+    }\n+\n+    resource \"aws_vpc\" \"example\" {\n+      for_each = var.aws_regions\n+      provider = each.value.provider_instance\n+\n+      cidr_block = each.value.cidr_block\n+    }\n+    ```\n+\n+    ```hcl\n+    module \"example\" {\n+      # ...\n+\n+      aws_regions = {\n+        us-west-2 = {\n+          cidr_block        = \"10.1.0.0/16\"\n+          provider_instance = aws.usw2\n+        }\n+        eu-west-1 = {\n+          cidr_block        = \"10.2.0.0/16\"\n+          provider_instance = aws.euw2\n+        }\n+      }\n+    }\n+    ```\n+\n+##### Using the `count` meta-argument in `provider` blocks\n+\n+The existing `resource`, `data`, and `module` blocks support either `count` or `for_each` as two different strategies for causing a single configuration block to dynamically declare multiple instances.\n+\n+`count` is most appropriate for situations where the multiple instances are \"fungible\". For example, the instances could be considered \"fungible\" if the process of reducing the number of instances doesn't need to consider which of the instances will be destroyed. A collection of virtual machines all booted from the same disk image, with the same configuration, and running the same software could be considered fungible.\n+\n+`for_each` is the better option when each instance has at least one unique characteristic that makes it functionally or meaningfully distinct from the others. A collection of virtual network objects where each is used to host different services are _not_ fungible because each network has its own separate role to play in the overall system.\n+\n+The technical design we've adopted here could potentially allow supporting `count` in `provider` blocks, generating instances with integer numbers as keys just as with `count` in other blocks. However, we don't yet know of any clear use-case for a collection of \"fungible\" provider configurations: the only reasons we know of to have multiple instances of a provider involve each one being configured differently, such as using a different AWS region. It's important for correctness for the resource instances associated with these provider instances to retain their individual bindings as the set of provider instances changes, because an object created using one provider instance will often appear to be non-existent if requested with another provider instance.\n+\n+Because of how crucial it is to preserve the relationships between resource instances and provider instances between runs, we've chosen to intentionally exclude `count` support from the initial design. However, the `count` argument remains reserved in `provider` blocks so that we can potentially implement it in future if feedback suggests a significant use-case for it. We hope that the future discovered use-case(s) will also give us some ideas on how we could help protect against the inevitable misbehavior caused by a resource instance getting accidentally reassociated with the wrong provider instance.",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1820638536",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2115,
        "pr_file": "rfc/20240513-static-evaluation-providers.md",
        "discussion_id": "1820638536",
        "commented_code": "@@ -116,167 +117,325 @@ locals {\n }\n \n provider \"aws\" {\n+  alias    = \"by_region\"\n   for_each = local.regions\n+\n   region = each.value\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   for_each = local.regions\n-  provider = aws[each.key]\n+  provider = aws.by_region[each.key]\n+\n+  # ...\n }\n \n module \"mod\" {\n+  source   = \"./mod\"\n   for_each = local.regions\n-  source = \"./mod\"\n-  providers {\n-    aws = aws[each.key]\n+  providers = {\n+    aws = aws.by_region[each.key]\n   }\n+\n+  # ...\n }\n ```\n \n+This use of `each.key` is familiar from its existing use in `resource`, `data`, and `module` blocks that use `for_each`. The bracketed portion of the address is evaluated dynamically by the main language runtime, and so (unlike the `for_each` argument in `provider` blocks) this particular expression is _not_ constrained to only static-eval-compatible symbols.\n+\n From a user perspective, this provider mapping is fairly simple to understand. As we will show in the Technical Approach, this will be quite difficult to implement.\n \n \n #### What's not currently allowed\n \n-There are scenarios that users might think could work, but we don't want to support at this time.\n+There are scenarios that module authors might think could work, but that we don't intend to support initially so that we can release an initial increment and then react to feedback.\n \n+##### Provider references as normal values\n \n-Storing a provider reference in a local or passing it as a variable\n ```hcl\n locals {\n-  my_provider = aws[\"us\"]\n+  my_provider = aws.by_region[\"us\"]\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   provider = local.my_provider\n }\n ```\n-It's not well defined what a \"provider reference\" is outside of a \"provider/providers\" block. All of the provider references are built as special cases that are handled beside the code and not as part of it directly.\n \n+It's not currenly well-defined what a \"provider reference\" is outside of a `provider` or `providers` argument. All of the provider references are built as special cases that are handled using HCL static analysis.\n+\n+Additionally, the OpenTofu language would currently recognize `aws.by_region` as a reference to a `resource \"aws\" \"by_region\"` block in any normal expression context, so we cannot easily redefine that existing meaning while retaining backward compatibility.\n+\n+Syntax compatibility concerns aside, it would be technically possible to treat a provider configuration reference as a value using a concept in the upstream library that provides the low-level building blocks of OpenTofu's type system: [`cty Capsule Types`](https://github.com/zclconf/go-cty/blob/main/docs/types.md#capsule-types). Assuming we also defined a suitable syntax for declaring a new kind of type constraint and referring to a provider in a normal expression, we could technically allow provider instance references to be passed around in a similar way as other values are passed around.\n+\n+##### One resource with multiple provider configurations\n+\n+OpenTofu's existing graph construction logic fundamentally assumes that each `resource` block is associated with exactly one provider configuration. This proposal introduces the possibility of a single provider configuration generating multiple provider _instances_, but since this initial proposal aims to avoid making significant changes to the graph transformation logic we will initially require that all instances of a particular resource refer to (potentially different) instances of the _same_ provider configuration.\n+\n+That restriction is most obvious in the simplest case where a `resource` block has `provider` directly referring to a provider instance in the same module:\n \n-Using the \"splat/*\" operator in module providers block:\n ```hcl\n-module \"mod\" {\n-  source = \"./mod\"\n-  providers {\n-    aws[*] = aws[*]\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"example\" {\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # The part in brackets is dynamic, but the initial reference to the\n+  # provider configuration block remains static, so effectively all\n+  # of the instances of this resource _must_ belong to the one\n+  # single provider configuration block above.\n+  provider = example.foo[each.key]\n+}\n+```\n+\n+This restriction also applies when passing provider configurations indirectly through module calls. Each instance of a module can have its own provider configuration namespace populated with different provider instances defined in the parent, but they must still all refer to the same configuration block:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+module \"example\" {\n+  source   = \"./example\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  providers = {\n+    # All of the resource blocks in this module can just assume there's\n+    # a default (unaliased) \"example\" provider instance available to\n+    # use. Each one is bound to a different instance from the provider\n+    # block above, but they must still nonetheless all be bound to\n+    # the same block.\n+    example = example.foo[each.key]\n   }\n }\n ```\n-This implies that all aliased aws providers would be passed into the child module. This is confusing as it conflicts with the existing idea of providers configs passed implicitly to child modules with the same names.\n \n-### Technical Approach\n+We should be able to loosen this restriction in a future RFC, either as part of a fully-dynamic design where provider references are normal expressions as described in the previous section or via some specialized syntax that's only used for provider configurations. The main requirement, regardless of how the surface syntax is designed, is that the graph builder change to support creating multiple dependency edges from a single resource node to multiple provider configuration nodes, so that evaluation of the resource node is delayed until after all of the possibly-referred-to provider configurations have been visited and thus their provider instances are running.\n \n-#### Provider Configuration Expansion\n+##### Passing collections of provider instances between modules.\n \n-##### Expansion\n+There was previously no syntax for causing a single provider configuration to produce multiple provider instances, and so we also have no existing syntax to use to differentiate between a reference to one provider instance v.s a reference to a collection of provider instances.\n \n-Expanding provider configurations can be done using the StaticContext available in [configs.NewModule()](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L122) as defined in the Static Evaluation RFC.\n+In this first implementation it's forbidden to refer to a multi-instance provider configuration without specifying an instance key.\n \n-At the end of the NewModule constructor, the configured provider's aliases can be expanded using the each/count, similar to how [module.ProviderLocalNames](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L186) is generated. This does not require any special workarounds and will resemble most other applications of the StaticContext.\n+For example, consider the following configuration:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"a\" {\n+  # The following is invalid: must include the instance key part to\n+  # tell OpenTofu how to select exactly one provider instance.\n+  provider = example.foo\n+}\n \n-```go\n-// Pseudocode\n-func NewModule(files []configs.File, ctx StaticContext) {\n-  module = &Module{}\n-  for _, file := range files {\n-    module.Append(file)\n+module \"child\" {\n+  source = \"./child\"\n+  providers = {\n+    # The right-hand side of this item is invalid: must include the\n+    # instance key part to tell OpenTofu how to select exactly one\n+    # provider instance.\n+    example.foo = example.foo\n   }\n+}\n+```\n+\n+The consequences of `example.foo` being invalid don't really matter for the `resource` block because it doesn't make sense to specify multiple provider instances for a single resource anyway.\n+\n+It _would_ be useful to be able to pass a collection of provider instances to a child module as shown in the second example, but that raises various new design questions about how the child module should declare that it's expecting to be passed a collection of provider instances, since today provider instance references are not normal values and so it isn't really meaningful to describe \"a map of `example` provider instances\".\n+\n+Leaving this unsupported for the first release again gives us room to consider various different design options in later RFCs as our understanding of the use-cases grows based on feedback. The following are some early potential designs we've considered so far, but it isn't clear yet which (if any) is the best fit:\n+\n+- Borrow the \"splat operator\" syntax to talk about recieving a collection of provider instances in the `configuration_aliases` argument of a module's `required_providers` block:\n \n-  ctx.AddVariables(module.Variables)\n-  ctx.AddLocals(module.Locals)\n+    ```hcl\n+    terraform {\n+      required_providers {\n+        example = {\n+          source = \"tf.example.com/example/example\"\n \n-  // Re-build the ProviderConfigs map with expansion\n-  newProviderConfigs := make(map)\n-  for _, cfg := range module.ProviderConfigs {\n-    for key, expanded := range cfg.expand(ctx) {\n-      newProviderConfigs[key] = expanded\n+          configuration_aliases = [\n+            # The following could potentially mean something similar to\n+            # a provider \"example\" block with alias = \"foo\" and a\n+            # for_each argument, specifying that this module expects its\n+            # caller to provide a collection of provider instances.\n+            example.foo[*]\n+          ]\n+        }\n+      }\n     }\n-  }\n-  module.ProviderConfigs = newProviderConfigs\n+    ```\n \n+- Borrow the \"splat operator\" syntax instead for use at the _call site_, so the calling module can declare that it's intending to pass a collection of instances:\n \n-  // Generate the FQN -> LocalProviderName map\n-  module.ProviderLocalNames()\n-}\n-```\n+    ```hcl\n+    module \"child\" {\n+      # ...\n+      providers = {\n+        aws.each_region[*] = aws.by_region[*]\n+      }\n+    }\n+    ```\n+\n+    This is similar to the previous idea except that it makes the assertion of intent to pass multiple instances appear on the caller side rather than on the callee side. It's technically redundant to use extra syntax here since the presence or absense of `for_each` in the `provider \"aws\"` block that has `alias = \"by_region\"` is already sufficient to represent whether `aws.by_region` is a single instance or a collection of instances, \n+\n+    (This and the previous option could potentially be combined together to allow both caller and callee to explicitly declare what they are intending to do.)\n+\n+- Wait until we're ready to support provider instance references being treated as normal values of a new type, and then encourage module authors to pass collections of provider configurations via input variables that use a new type constraint syntax, effectively deprecating the current provider-specific sidechannel.\n+\n+    This generalized approach would allow for various more interesting combinations, such as sending provider instances along with other data as part of a single object per region:\n+\n+    ```hcl\n+    variable \"aws_regions\" {\n+      type = map(object({\n+        cidr_block        = string\n+        provider_instance = providerinst(aws)\n+      }))\n+    }\n+\n+    resource \"aws_vpc\" \"example\" {\n+      for_each = var.aws_regions\n+      provider = each.value.provider_instance\n+\n+      cidr_block = each.value.cidr_block\n+    }\n+    ```\n+\n+    ```hcl\n+    module \"example\" {\n+      # ...\n+\n+      aws_regions = {\n+        us-west-2 = {\n+          cidr_block        = \"10.1.0.0/16\"\n+          provider_instance = aws.usw2\n+        }\n+        eu-west-1 = {\n+          cidr_block        = \"10.2.0.0/16\"\n+          provider_instance = aws.euw2\n+        }\n+      }\n+    }\n+    ```\n+\n+##### Using the `count` meta-argument in `provider` blocks\n+\n+The existing `resource`, `data`, and `module` blocks support either `count` or `for_each` as two different strategies for causing a single configuration block to dynamically declare multiple instances.\n+\n+`count` is most appropriate for situations where the multiple instances are \"fungible\". For example, the instances could be considered \"fungible\" if the process of reducing the number of instances doesn't need to consider which of the instances will be destroyed. A collection of virtual machines all booted from the same disk image, with the same configuration, and running the same software could be considered fungible.\n+\n+`for_each` is the better option when each instance has at least one unique characteristic that makes it functionally or meaningfully distinct from the others. A collection of virtual network objects where each is used to host different services are _not_ fungible because each network has its own separate role to play in the overall system.\n+\n+The technical design we've adopted here could potentially allow supporting `count` in `provider` blocks, generating instances with integer numbers as keys just as with `count` in other blocks. However, we don't yet know of any clear use-case for a collection of \"fungible\" provider configurations: the only reasons we know of to have multiple instances of a provider involve each one being configured differently, such as using a different AWS region. It's important for correctness for the resource instances associated with these provider instances to retain their individual bindings as the set of provider instances changes, because an object created using one provider instance will often appear to be non-existent if requested with another provider instance.\n+\n+Because of how crucial it is to preserve the relationships between resource instances and provider instances between runs, we've chosen to intentionally exclude `count` support from the initial design. However, the `count` argument remains reserved in `provider` blocks so that we can potentially implement it in future if feedback suggests a significant use-case for it. We hope that the future discovered use-case(s) will also give us some ideas on how we could help protect against the inevitable misbehavior caused by a resource instance getting accidentally reassociated with the wrong provider instance.",
        "comment_created_at": "2024-10-29T11:42:45+00:00",
        "comment_author": "cam72cam",
        "comment_body": "This was implemented in the implementation PR with a few lines.  It's easy to back out, but I'm not sure if it's more confusing to intentionally exclude it here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1820944319",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2115,
        "pr_file": "rfc/20240513-static-evaluation-providers.md",
        "discussion_id": "1820638536",
        "commented_code": "@@ -116,167 +117,325 @@ locals {\n }\n \n provider \"aws\" {\n+  alias    = \"by_region\"\n   for_each = local.regions\n+\n   region = each.value\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   for_each = local.regions\n-  provider = aws[each.key]\n+  provider = aws.by_region[each.key]\n+\n+  # ...\n }\n \n module \"mod\" {\n+  source   = \"./mod\"\n   for_each = local.regions\n-  source = \"./mod\"\n-  providers {\n-    aws = aws[each.key]\n+  providers = {\n+    aws = aws.by_region[each.key]\n   }\n+\n+  # ...\n }\n ```\n \n+This use of `each.key` is familiar from its existing use in `resource`, `data`, and `module` blocks that use `for_each`. The bracketed portion of the address is evaluated dynamically by the main language runtime, and so (unlike the `for_each` argument in `provider` blocks) this particular expression is _not_ constrained to only static-eval-compatible symbols.\n+\n From a user perspective, this provider mapping is fairly simple to understand. As we will show in the Technical Approach, this will be quite difficult to implement.\n \n \n #### What's not currently allowed\n \n-There are scenarios that users might think could work, but we don't want to support at this time.\n+There are scenarios that module authors might think could work, but that we don't intend to support initially so that we can release an initial increment and then react to feedback.\n \n+##### Provider references as normal values\n \n-Storing a provider reference in a local or passing it as a variable\n ```hcl\n locals {\n-  my_provider = aws[\"us\"]\n+  my_provider = aws.by_region[\"us\"]\n }\n \n resource \"aws_s3_bucket\" \"primary\" {\n   provider = local.my_provider\n }\n ```\n-It's not well defined what a \"provider reference\" is outside of a \"provider/providers\" block. All of the provider references are built as special cases that are handled beside the code and not as part of it directly.\n \n+It's not currenly well-defined what a \"provider reference\" is outside of a `provider` or `providers` argument. All of the provider references are built as special cases that are handled using HCL static analysis.\n+\n+Additionally, the OpenTofu language would currently recognize `aws.by_region` as a reference to a `resource \"aws\" \"by_region\"` block in any normal expression context, so we cannot easily redefine that existing meaning while retaining backward compatibility.\n+\n+Syntax compatibility concerns aside, it would be technically possible to treat a provider configuration reference as a value using a concept in the upstream library that provides the low-level building blocks of OpenTofu's type system: [`cty Capsule Types`](https://github.com/zclconf/go-cty/blob/main/docs/types.md#capsule-types). Assuming we also defined a suitable syntax for declaring a new kind of type constraint and referring to a provider in a normal expression, we could technically allow provider instance references to be passed around in a similar way as other values are passed around.\n+\n+##### One resource with multiple provider configurations\n+\n+OpenTofu's existing graph construction logic fundamentally assumes that each `resource` block is associated with exactly one provider configuration. This proposal introduces the possibility of a single provider configuration generating multiple provider _instances_, but since this initial proposal aims to avoid making significant changes to the graph transformation logic we will initially require that all instances of a particular resource refer to (potentially different) instances of the _same_ provider configuration.\n+\n+That restriction is most obvious in the simplest case where a `resource` block has `provider` directly referring to a provider instance in the same module:\n \n-Using the \"splat/*\" operator in module providers block:\n ```hcl\n-module \"mod\" {\n-  source = \"./mod\"\n-  providers {\n-    aws[*] = aws[*]\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"example\" {\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # The part in brackets is dynamic, but the initial reference to the\n+  # provider configuration block remains static, so effectively all\n+  # of the instances of this resource _must_ belong to the one\n+  # single provider configuration block above.\n+  provider = example.foo[each.key]\n+}\n+```\n+\n+This restriction also applies when passing provider configurations indirectly through module calls. Each instance of a module can have its own provider configuration namespace populated with different provider instances defined in the parent, but they must still all refer to the same configuration block:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+module \"example\" {\n+  source   = \"./example\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  providers = {\n+    # All of the resource blocks in this module can just assume there's\n+    # a default (unaliased) \"example\" provider instance available to\n+    # use. Each one is bound to a different instance from the provider\n+    # block above, but they must still nonetheless all be bound to\n+    # the same block.\n+    example = example.foo[each.key]\n   }\n }\n ```\n-This implies that all aliased aws providers would be passed into the child module. This is confusing as it conflicts with the existing idea of providers configs passed implicitly to child modules with the same names.\n \n-### Technical Approach\n+We should be able to loosen this restriction in a future RFC, either as part of a fully-dynamic design where provider references are normal expressions as described in the previous section or via some specialized syntax that's only used for provider configurations. The main requirement, regardless of how the surface syntax is designed, is that the graph builder change to support creating multiple dependency edges from a single resource node to multiple provider configuration nodes, so that evaluation of the resource node is delayed until after all of the possibly-referred-to provider configurations have been visited and thus their provider instances are running.\n \n-#### Provider Configuration Expansion\n+##### Passing collections of provider instances between modules.\n \n-##### Expansion\n+There was previously no syntax for causing a single provider configuration to produce multiple provider instances, and so we also have no existing syntax to use to differentiate between a reference to one provider instance v.s a reference to a collection of provider instances.\n \n-Expanding provider configurations can be done using the StaticContext available in [configs.NewModule()](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L122) as defined in the Static Evaluation RFC.\n+In this first implementation it's forbidden to refer to a multi-instance provider configuration without specifying an instance key.\n \n-At the end of the NewModule constructor, the configured provider's aliases can be expanded using the each/count, similar to how [module.ProviderLocalNames](https://github.com/opentofu/opentofu/blob/290fbd66d3f95d3fa413534c4d5e14ef7d95ea2e/internal/configs/module.go#L186) is generated. This does not require any special workarounds and will resemble most other applications of the StaticContext.\n+For example, consider the following configuration:\n+\n+```hcl\n+provider \"example\" {\n+  alias    = \"foo\"\n+  for_each = toset([\"bar\", \"baz\"])\n+\n+  # ...\n+}\n+\n+resource \"example_thing\" \"a\" {\n+  # The following is invalid: must include the instance key part to\n+  # tell OpenTofu how to select exactly one provider instance.\n+  provider = example.foo\n+}\n \n-```go\n-// Pseudocode\n-func NewModule(files []configs.File, ctx StaticContext) {\n-  module = &Module{}\n-  for _, file := range files {\n-    module.Append(file)\n+module \"child\" {\n+  source = \"./child\"\n+  providers = {\n+    # The right-hand side of this item is invalid: must include the\n+    # instance key part to tell OpenTofu how to select exactly one\n+    # provider instance.\n+    example.foo = example.foo\n   }\n+}\n+```\n+\n+The consequences of `example.foo` being invalid don't really matter for the `resource` block because it doesn't make sense to specify multiple provider instances for a single resource anyway.\n+\n+It _would_ be useful to be able to pass a collection of provider instances to a child module as shown in the second example, but that raises various new design questions about how the child module should declare that it's expecting to be passed a collection of provider instances, since today provider instance references are not normal values and so it isn't really meaningful to describe \"a map of `example` provider instances\".\n+\n+Leaving this unsupported for the first release again gives us room to consider various different design options in later RFCs as our understanding of the use-cases grows based on feedback. The following are some early potential designs we've considered so far, but it isn't clear yet which (if any) is the best fit:\n+\n+- Borrow the \"splat operator\" syntax to talk about recieving a collection of provider instances in the `configuration_aliases` argument of a module's `required_providers` block:\n \n-  ctx.AddVariables(module.Variables)\n-  ctx.AddLocals(module.Locals)\n+    ```hcl\n+    terraform {\n+      required_providers {\n+        example = {\n+          source = \"tf.example.com/example/example\"\n \n-  // Re-build the ProviderConfigs map with expansion\n-  newProviderConfigs := make(map)\n-  for _, cfg := range module.ProviderConfigs {\n-    for key, expanded := range cfg.expand(ctx) {\n-      newProviderConfigs[key] = expanded\n+          configuration_aliases = [\n+            # The following could potentially mean something similar to\n+            # a provider \"example\" block with alias = \"foo\" and a\n+            # for_each argument, specifying that this module expects its\n+            # caller to provide a collection of provider instances.\n+            example.foo[*]\n+          ]\n+        }\n+      }\n     }\n-  }\n-  module.ProviderConfigs = newProviderConfigs\n+    ```\n \n+- Borrow the \"splat operator\" syntax instead for use at the _call site_, so the calling module can declare that it's intending to pass a collection of instances:\n \n-  // Generate the FQN -> LocalProviderName map\n-  module.ProviderLocalNames()\n-}\n-```\n+    ```hcl\n+    module \"child\" {\n+      # ...\n+      providers = {\n+        aws.each_region[*] = aws.by_region[*]\n+      }\n+    }\n+    ```\n+\n+    This is similar to the previous idea except that it makes the assertion of intent to pass multiple instances appear on the caller side rather than on the callee side. It's technically redundant to use extra syntax here since the presence or absense of `for_each` in the `provider \"aws\"` block that has `alias = \"by_region\"` is already sufficient to represent whether `aws.by_region` is a single instance or a collection of instances, \n+\n+    (This and the previous option could potentially be combined together to allow both caller and callee to explicitly declare what they are intending to do.)\n+\n+- Wait until we're ready to support provider instance references being treated as normal values of a new type, and then encourage module authors to pass collections of provider configurations via input variables that use a new type constraint syntax, effectively deprecating the current provider-specific sidechannel.\n+\n+    This generalized approach would allow for various more interesting combinations, such as sending provider instances along with other data as part of a single object per region:\n+\n+    ```hcl\n+    variable \"aws_regions\" {\n+      type = map(object({\n+        cidr_block        = string\n+        provider_instance = providerinst(aws)\n+      }))\n+    }\n+\n+    resource \"aws_vpc\" \"example\" {\n+      for_each = var.aws_regions\n+      provider = each.value.provider_instance\n+\n+      cidr_block = each.value.cidr_block\n+    }\n+    ```\n+\n+    ```hcl\n+    module \"example\" {\n+      # ...\n+\n+      aws_regions = {\n+        us-west-2 = {\n+          cidr_block        = \"10.1.0.0/16\"\n+          provider_instance = aws.usw2\n+        }\n+        eu-west-1 = {\n+          cidr_block        = \"10.2.0.0/16\"\n+          provider_instance = aws.euw2\n+        }\n+      }\n+    }\n+    ```\n+\n+##### Using the `count` meta-argument in `provider` blocks\n+\n+The existing `resource`, `data`, and `module` blocks support either `count` or `for_each` as two different strategies for causing a single configuration block to dynamically declare multiple instances.\n+\n+`count` is most appropriate for situations where the multiple instances are \"fungible\". For example, the instances could be considered \"fungible\" if the process of reducing the number of instances doesn't need to consider which of the instances will be destroyed. A collection of virtual machines all booted from the same disk image, with the same configuration, and running the same software could be considered fungible.\n+\n+`for_each` is the better option when each instance has at least one unique characteristic that makes it functionally or meaningfully distinct from the others. A collection of virtual network objects where each is used to host different services are _not_ fungible because each network has its own separate role to play in the overall system.\n+\n+The technical design we've adopted here could potentially allow supporting `count` in `provider` blocks, generating instances with integer numbers as keys just as with `count` in other blocks. However, we don't yet know of any clear use-case for a collection of \"fungible\" provider configurations: the only reasons we know of to have multiple instances of a provider involve each one being configured differently, such as using a different AWS region. It's important for correctness for the resource instances associated with these provider instances to retain their individual bindings as the set of provider instances changes, because an object created using one provider instance will often appear to be non-existent if requested with another provider instance.\n+\n+Because of how crucial it is to preserve the relationships between resource instances and provider instances between runs, we've chosen to intentionally exclude `count` support from the initial design. However, the `count` argument remains reserved in `provider` blocks so that we can potentially implement it in future if feedback suggests a significant use-case for it. We hope that the future discovered use-case(s) will also give us some ideas on how we could help protect against the inevitable misbehavior caused by a resource instance getting accidentally reassociated with the wrong provider instance.",
        "comment_created_at": "2024-10-29T14:42:38+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "Given that everything we add in a stable release is forever, I would strongly recommend _not_ adding things that don't have a clear use-case just because they seem easy to implement.",
        "pr_file_module": null
      }
    ]
  }
]