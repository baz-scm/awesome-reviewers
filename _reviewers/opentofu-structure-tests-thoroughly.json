[
  {
    "discussion_id": "2047910590",
    "pr_number": 2673,
    "pr_file": "internal/tofu/marks_test.go",
    "created_at": "2025-04-16T23:08:55+00:00",
    "commented_code": "})\n \t}\n }\n+\n+func TestSensitiveMarksEqual(t *testing.T) {\n+\tfor i, tc := range []struct {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2047910590",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2673,
        "pr_file": "internal/tofu/marks_test.go",
        "discussion_id": "2047910590",
        "commented_code": "@@ -204,3 +204,106 @@ func TestCombinePathValueMarks(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSensitiveMarksEqual(t *testing.T) {\n+\tfor i, tc := range []struct {",
        "comment_created_at": "2025-04-16T23:08:55+00:00",
        "comment_author": "diofeher",
        "comment_body": "Do you think it could make sense to add a descriptive name to the test so we know the context for each test? Using a `map[string]struct` instead of a `[]struct` so we can have something like:\r\n\r\n```\r\n\"duplicated marks\": {\r\n   ...\r\n}",
        "pr_file_module": null
      },
      {
        "comment_id": "2048579928",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2673,
        "pr_file": "internal/tofu/marks_test.go",
        "discussion_id": "2047910590",
        "commented_code": "@@ -204,3 +204,106 @@ func TestCombinePathValueMarks(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+func TestSensitiveMarksEqual(t *testing.T) {\n+\tfor i, tc := range []struct {",
        "comment_created_at": "2025-04-17T09:23:54+00:00",
        "comment_author": "ollevche",
        "comment_body": "Makes sense, I added names for test cases in [9d345f3](https://github.com/opentofu/opentofu/pull/2673/commits/9d345f3385a809b204485d667b1c7b5b0d77a370)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2037881519",
    "pr_number": 2620,
    "pr_file": "internal/command/arguments/plan_test.go",
    "created_at": "2025-04-10T17:00:52+00:00",
    "commented_code": "})\n \t}\n }\n+\n+// Don't forget to os.Remove(file) for each file after calling this function",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "2037881519",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2620,
        "pr_file": "internal/command/arguments/plan_test.go",
        "discussion_id": "2037881519",
        "commented_code": "@@ -300,3 +627,34 @@ func TestParsePlan_vars(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Don't forget to os.Remove(file) for each file after calling this function",
        "comment_created_at": "2025-04-10T17:00:52+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "One way to avoid the potential pitfall here would be to have this function also take a `t *testing.T` argument and then use `t.TempDir()` to get a directory to place all of the files into. The Go test harness will automatically clean those up itself when the test ends.\r\n\r\nI think we can call `t.TempDir` just once before the loop and then use `filepath.Join` on each iteration to append a filename derived from `filepath.Base(file.filePath)` (assuming that `filePath` is set) to that single temporary directory, which would then have the nice advantage of the temporary files having a more meaningful filename in case they appear in any test failure messages.\r\n\r\nHaving a `*testing.T` in here also means that we can use `t.Fatal` instead of `log.Fatal` so that an error will only abort the current test, rather than aborting the entire test run. Make sure to call `t.Helper()` as the first statement in the function so that the test harness knows that it should treat this as a test helper function when it is choosing a source line to report in its generated error message.\r\n\r\n(Similar idea for the `testFile.tempFileWriter` method below too, though of course that one will need to make a separate temp directory for each file since it only works on one file at a time.)",
        "pr_file_module": null
      },
      {
        "comment_id": "2039766047",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2620,
        "pr_file": "internal/command/arguments/plan_test.go",
        "discussion_id": "2037881519",
        "commented_code": "@@ -300,3 +627,34 @@ func TestParsePlan_vars(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Don't forget to os.Remove(file) for each file after calling this function",
        "comment_created_at": "2025-04-11T15:27:59+00:00",
        "comment_author": "bittelc",
        "comment_body": "I actually intended to delete the function, and just leave the `testFile.TempFileWriter` method, and have now applied what you've written here.\r\nI had no idea `TempDir()` existed! That's pretty cool! Thank you!",
        "pr_file_module": null
      },
      {
        "comment_id": "2039844665",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2620,
        "pr_file": "internal/command/arguments/plan_test.go",
        "discussion_id": "2037881519",
        "commented_code": "@@ -300,3 +627,34 @@ func TestParsePlan_vars(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Don't forget to os.Remove(file) for each file after calling this function",
        "comment_created_at": "2025-04-11T15:57:41+00:00",
        "comment_author": "apparentlymart",
        "comment_body": "`t.TempDir` is a relatively recent addition to the Go standard library. We have _lots_ of old code that predates it being there and handles temporary directories in some other manual way, so certainly no judgement from me for this being new to you... it's pretty new to _us_ too. :grinning: \r\n\r\nIn case it's interesting for your future endeavors (since I don't think we really need it _here_), there is also the more general [`testing.T.Cleanup`](https://pkg.go.dev/testing#T.Cleanup) which arranges for an arbitrary function to be called at the conclusion of the calling test, and so this can be used for resources other than temporary directories that nonetheless ought not to outlive the scope of a single test run.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1796719655",
    "pr_number": 1900,
    "pr_file": "internal/command/arguments/plan_test.go",
    "created_at": "2024-10-11T09:52:06+00:00",
    "commented_code": "}\n }\n \n+func TestParsePlan_excludes(t *testing.T) {\n+\tfoobarbaz, _ := addrs.ParseTargetStr(\"foo_bar.baz\")\n+\tboop, _ := addrs.ParseTargetStr(\"module.boop\")\n+\ttestCases := map[string]struct {\n+\t\targs    []string\n+\t\twant    []addrs.Targetable\n+\t\twantErr string\n+\t}{\n+\t\t\"no excludes by default\": {\n+\t\t\targs: nil,\n+\t\t\twant: nil,\n+\t\t},\n+\t\t\"one exclude\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject},\n+\t\t},\n+\t\t\"two excludes\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\", \"-exclude\", \"module.boop\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject, boop.Subject},\n+\t\t},\n+\t\t\"invalid traversal\": {\n+\t\t\targs:    []string{\"-exclude=foo.\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"Dot must be followed by attribute name\",\n+\t\t},\n+\t\t\"invalid target\": {\n+\t\t\targs:    []string{\"-exclude=data[0].foo\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"A data source name is required\",\n+\t\t},\n+\t}\n+\n+\tfor name, tc := range testCases {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tgot, diags := ParsePlan(tc.args)\n+\t\t\tif len(diags) > 0 {\n+\t\t\t\tif tc.wantErr == \"\" {\n+\t\t\t\t\tt.Fatalf(\"unexpected diags: %v\", diags)\n+\t\t\t\t} else if got := diags.Err().Error(); !strings.Contains(got, tc.wantErr) {\n+\t\t\t\t\tt.Fatalf(\"wrong diags\n got: %s\nwant: %s\", got, tc.wantErr)\n+\t\t\t\t}",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1796719655",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1900,
        "pr_file": "internal/command/arguments/plan_test.go",
        "discussion_id": "1796719655",
        "commented_code": "@@ -160,6 +162,79 @@ func TestParsePlan_targets(t *testing.T) {\n \t}\n }\n \n+func TestParsePlan_excludes(t *testing.T) {\n+\tfoobarbaz, _ := addrs.ParseTargetStr(\"foo_bar.baz\")\n+\tboop, _ := addrs.ParseTargetStr(\"module.boop\")\n+\ttestCases := map[string]struct {\n+\t\targs    []string\n+\t\twant    []addrs.Targetable\n+\t\twantErr string\n+\t}{\n+\t\t\"no excludes by default\": {\n+\t\t\targs: nil,\n+\t\t\twant: nil,\n+\t\t},\n+\t\t\"one exclude\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject},\n+\t\t},\n+\t\t\"two excludes\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\", \"-exclude\", \"module.boop\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject, boop.Subject},\n+\t\t},\n+\t\t\"invalid traversal\": {\n+\t\t\targs:    []string{\"-exclude=foo.\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"Dot must be followed by attribute name\",\n+\t\t},\n+\t\t\"invalid target\": {\n+\t\t\targs:    []string{\"-exclude=data[0].foo\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"A data source name is required\",\n+\t\t},\n+\t}\n+\n+\tfor name, tc := range testCases {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tgot, diags := ParsePlan(tc.args)\n+\t\t\tif len(diags) > 0 {\n+\t\t\t\tif tc.wantErr == \"\" {\n+\t\t\t\t\tt.Fatalf(\"unexpected diags: %v\", diags)\n+\t\t\t\t} else if got := diags.Err().Error(); !strings.Contains(got, tc.wantErr) {\n+\t\t\t\t\tt.Fatalf(\"wrong diags\\n got: %s\\nwant: %s\", got, tc.wantErr)\n+\t\t\t\t}",
        "comment_created_at": "2024-10-11T09:52:06+00:00",
        "comment_author": "Yantrio",
        "comment_body": "this isn't testing the possible failure case where we want an error but it's actually returned 0 diags.\r\n\r\nI think something like \r\n```go\r\nif tc.wantErr != == && len(diags) == 0 {\r\n  t.Fatalf(\"expected error but got none\")\r\n}\r\n```\r\n\r\nshould cover us\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1818140120",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1900,
        "pr_file": "internal/command/arguments/plan_test.go",
        "discussion_id": "1796719655",
        "commented_code": "@@ -160,6 +162,79 @@ func TestParsePlan_targets(t *testing.T) {\n \t}\n }\n \n+func TestParsePlan_excludes(t *testing.T) {\n+\tfoobarbaz, _ := addrs.ParseTargetStr(\"foo_bar.baz\")\n+\tboop, _ := addrs.ParseTargetStr(\"module.boop\")\n+\ttestCases := map[string]struct {\n+\t\targs    []string\n+\t\twant    []addrs.Targetable\n+\t\twantErr string\n+\t}{\n+\t\t\"no excludes by default\": {\n+\t\t\targs: nil,\n+\t\t\twant: nil,\n+\t\t},\n+\t\t\"one exclude\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject},\n+\t\t},\n+\t\t\"two excludes\": {\n+\t\t\targs: []string{\"-exclude=foo_bar.baz\", \"-exclude\", \"module.boop\"},\n+\t\t\twant: []addrs.Targetable{foobarbaz.Subject, boop.Subject},\n+\t\t},\n+\t\t\"invalid traversal\": {\n+\t\t\targs:    []string{\"-exclude=foo.\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"Dot must be followed by attribute name\",\n+\t\t},\n+\t\t\"invalid target\": {\n+\t\t\targs:    []string{\"-exclude=data[0].foo\"},\n+\t\t\twant:    nil,\n+\t\t\twantErr: \"A data source name is required\",\n+\t\t},\n+\t}\n+\n+\tfor name, tc := range testCases {\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tgot, diags := ParsePlan(tc.args)\n+\t\t\tif len(diags) > 0 {\n+\t\t\t\tif tc.wantErr == \"\" {\n+\t\t\t\t\tt.Fatalf(\"unexpected diags: %v\", diags)\n+\t\t\t\t} else if got := diags.Err().Error(); !strings.Contains(got, tc.wantErr) {\n+\t\t\t\t\tt.Fatalf(\"wrong diags\\n got: %s\\nwant: %s\", got, tc.wantErr)\n+\t\t\t\t}",
        "comment_created_at": "2024-10-27T16:51:23+00:00",
        "comment_author": "RLRabinowitz",
        "comment_body": "a2bbdf7f08eddcd42e88bc6a75a4e635597fe172",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1646504150",
    "pr_number": 1728,
    "pr_file": "internal/encryption/targets_test.go",
    "created_at": "2024-06-19T16:39:36+00:00",
    "commented_code": null,
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1646504150",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1728,
        "pr_file": "internal/encryption/targets_test.go",
        "discussion_id": "1646504150",
        "commented_code": null,
        "comment_created_at": "2024-06-19T16:39:36+00:00",
        "comment_author": "RLRabinowitz",
        "comment_body": "We might also want to test a case where the variable could not be resolved",
        "pr_file_module": null
      },
      {
        "comment_id": "1646606835",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1728,
        "pr_file": "internal/encryption/targets_test.go",
        "discussion_id": "1646504150",
        "commented_code": null,
        "comment_created_at": "2024-06-19T19:01:27+00:00",
        "comment_author": "ollevche",
        "comment_body": "Thanks, added in [a4f25c2](https://github.com/opentofu/opentofu/pull/1728/commits/a4f25c288cf40005fb55b8f6be479d540716acc2)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1568358506",
    "pr_number": 1492,
    "pr_file": "internal/tofu/context_plan2_test.go",
    "created_at": "2024-04-17T07:29:08+00:00",
    "commented_code": "}\n }\n \n+func TestContext2Plan_importForEach(t *testing.T) {",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1568358506",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1492,
        "pr_file": "internal/tofu/context_plan2_test.go",
        "discussion_id": "1568358506",
        "commented_code": "@@ -4533,6 +4533,191 @@ import {\n \t}\n }\n \n+func TestContext2Plan_importForEach(t *testing.T) {",
        "comment_created_at": "2024-04-17T07:29:08+00:00",
        "comment_author": "Evi1Pumpkin",
        "comment_body": "I didn't include \"unhappy\" tests like having a null key/value, sensitive key/value, or unknown key/value, as they fall under existing tests in either `eval_for_each_test.go` `TestEvaluateForEachExpression_errors()` and `context_plan2_test.go` `TestContext2Plan_importToInvalidDynamicAddress()`.\r\nI tested them all manually with all possible for_each types (`map`, `object`, `set`, `tuple`), but didn't want to bloat our existing test cases with duplicated cases. Let me know if you still think we should add these tests for the for_each scenario.",
        "pr_file_module": null
      },
      {
        "comment_id": "1568473376",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1492,
        "pr_file": "internal/tofu/context_plan2_test.go",
        "discussion_id": "1568358506",
        "commented_code": "@@ -4533,6 +4533,191 @@ import {\n \t}\n }\n \n+func TestContext2Plan_importForEach(t *testing.T) {",
        "comment_created_at": "2024-04-17T08:53:52+00:00",
        "comment_author": "Yantrio",
        "comment_body": "I think we should add them, mainly because it would help us identify regressions in the future, especially if eval_for_each_test.go somehow gets refactored. I would rather have some duplication of tests if it gives us faith that we're testing properly.",
        "pr_file_module": null
      },
      {
        "comment_id": "1568487687",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1492,
        "pr_file": "internal/tofu/context_plan2_test.go",
        "discussion_id": "1568358506",
        "commented_code": "@@ -4533,6 +4533,191 @@ import {\n \t}\n }\n \n+func TestContext2Plan_importForEach(t *testing.T) {",
        "comment_created_at": "2024-04-17T09:03:37+00:00",
        "comment_author": "cube2222",
        "comment_body": "Though I think this doesn't block the PR from the beta, and we can possibly add it in a follow-up PR (if it's a lot of work; if it's not let's just do it).",
        "pr_file_module": null
      },
      {
        "comment_id": "1568709773",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 1492,
        "pr_file": "internal/tofu/context_plan2_test.go",
        "discussion_id": "1568358506",
        "commented_code": "@@ -4533,6 +4533,191 @@ import {\n \t}\n }\n \n+func TestContext2Plan_importForEach(t *testing.T) {",
        "comment_created_at": "2024-04-17T11:45:18+00:00",
        "comment_author": "Evi1Pumpkin",
        "comment_body": "It shouldn't take long, but I'll push those tests as part of a different PR since we want this one merged by tomorrow.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1836554444",
    "pr_number": 2090,
    "pr_file": "internal/backend/remote-state/http/client_test.go",
    "created_at": "2024-11-11T11:52:12+00:00",
    "commented_code": "})\n \t}\n }\n+\n+// Tests the Lock method for the HTTP client.\n+// Test to see correct lock info is returned\n+func TestHttpClient_lock(t *testing.T) {\n+\tstateLockInfoA := statemgr.LockInfo{\n+\t\tID:        \"ada-lovelace-state-lock-id\",\n+\t\tWho:       \"AdaLovelace\",\n+\t\tOperation: \"TestTypePlan\",\n+\t}\n+\n+\ttrimString := func(str string) string {\n+\t\t// Anonymous Helper function to remove new line, tab\n+\t\t// and space characters from a string\n+\t\tspace := regexp.MustCompile(`\\s+`)\n+\t\treturn space.ReplaceAllString(str, \" \")\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tlockMethod     string\n+\t\tlockInfo       *statemgr.LockInfo\n+\t\thandler        http.HandlerFunc\n+\t\tvalidateResult func(lockID string, errorMessage error)\n+\t}{",
    "repo_full_name": "opentofu/opentofu",
    "discussion_comments": [
      {
        "comment_id": "1836554444",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2090,
        "pr_file": "internal/backend/remote-state/http/client_test.go",
        "discussion_id": "1836554444",
        "commented_code": "@@ -251,3 +255,136 @@ func TestHttpClient_IsLockingEnabled(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Tests the Lock method for the HTTP client.\n+// Test to see correct lock info is returned\n+func TestHttpClient_lock(t *testing.T) {\n+\tstateLockInfoA := statemgr.LockInfo{\n+\t\tID:        \"ada-lovelace-state-lock-id\",\n+\t\tWho:       \"AdaLovelace\",\n+\t\tOperation: \"TestTypePlan\",\n+\t}\n+\n+\ttrimString := func(str string) string {\n+\t\t// Anonymous Helper function to remove new line, tab\n+\t\t// and space characters from a string\n+\t\tspace := regexp.MustCompile(`\\s+`)\n+\t\treturn space.ReplaceAllString(str, \" \")\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tlockMethod     string\n+\t\tlockInfo       *statemgr.LockInfo\n+\t\thandler        http.HandlerFunc\n+\t\tvalidateResult func(lockID string, errorMessage error)\n+\t}{",
        "comment_created_at": "2024-11-11T11:52:12+00:00",
        "comment_author": "ollevche",
        "comment_body": "I would prefer a more clear separation between test logic and test data (inputs and outputs). I think the following structure covers test needs in a slightly simpler way (you would also need to change test run logic inside a loop):\r\n\r\n```suggestion\r\n\tinputLockInfo := statemgr.LockInfo{\r\n\t\tID:        \"ada-lovelace-state-lock-id\",\r\n\t\tWho:       \"AdaLovelace\",\r\n\t\tOperation: \"TestTypePlan\",\r\n\t}\r\n\r\n\ttestCases := []struct {\r\n\t\tname\t\t\t\tstring\r\n\t\tlockResponseStatus\tint\r\n\t\tlockResponseBody\t\t[]byte\r\n\t\texpectedLockInfo\t\t*statemgr.LockInfo // or just an ID\r\n\t\texpectedErrorMsg\t\tstring\r\n\t}{\r\n\t...\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1838186474",
        "repo_full_name": "opentofu/opentofu",
        "pr_number": 2090,
        "pr_file": "internal/backend/remote-state/http/client_test.go",
        "discussion_id": "1836554444",
        "commented_code": "@@ -251,3 +255,136 @@ func TestHttpClient_IsLockingEnabled(t *testing.T) {\n \t\t})\n \t}\n }\n+\n+// Tests the Lock method for the HTTP client.\n+// Test to see correct lock info is returned\n+func TestHttpClient_lock(t *testing.T) {\n+\tstateLockInfoA := statemgr.LockInfo{\n+\t\tID:        \"ada-lovelace-state-lock-id\",\n+\t\tWho:       \"AdaLovelace\",\n+\t\tOperation: \"TestTypePlan\",\n+\t}\n+\n+\ttrimString := func(str string) string {\n+\t\t// Anonymous Helper function to remove new line, tab\n+\t\t// and space characters from a string\n+\t\tspace := regexp.MustCompile(`\\s+`)\n+\t\treturn space.ReplaceAllString(str, \" \")\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tname           string\n+\t\tlockMethod     string\n+\t\tlockInfo       *statemgr.LockInfo\n+\t\thandler        http.HandlerFunc\n+\t\tvalidateResult func(lockID string, errorMessage error)\n+\t}{",
        "comment_created_at": "2024-11-12T14:19:34+00:00",
        "comment_author": "haiderbari",
        "comment_body": "I have updated the tests base your suggestion",
        "pr_file_module": null
      }
    ]
  }
]