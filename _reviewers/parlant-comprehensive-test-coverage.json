[
  {
    "discussion_id": "2016471107",
    "pr_number": 327,
    "pr_file": "tests/core/common/engines/alpha/steps/events.py",
    "created_at": "2025-03-27T12:28:31+00:00",
    "commented_code": "]\n \n     assert len(matching_tool_calls) > 0, f\"No tool call found for {tool_name}\"\n+\n+@step(then, parsers.parse(\"the number of missing parameters is smaller than {number_of_missing:d}\"))",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "2016471107",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 327,
        "pr_file": "tests/core/common/engines/alpha/steps/events.py",
        "discussion_id": "2016471107",
        "commented_code": "@@ -527,3 +527,19 @@ def then_the_tool_calls_event_contains_call(\n     ]\n \n     assert len(matching_tool_calls) > 0, f\"No tool call found for {tool_name}\"\n+\n+@step(then, parsers.parse(\"the number of missing parameters is smaller than {number_of_missing:d}\"))",
        "comment_created_at": "2025-03-27T12:28:31+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "I think the step would have been a bit more readable/usable if we said\r\n`\"no more than {number_of_missing:d} missing parameters are communicated\"`\r\n\r\nSuch that it's `X <= number_of_missing`\r\n\r\nBut regardless concretely, for our tests it may be better to be more explicit about the expected outcome, to ensure we get what we want as well as protecting from regressions. For example, in the current assertion, if the implementation communicated *no* missing parameters it would still pass. So I suggest:\r\n`\"{number_of_missing:d} parameters are reported to be missing`\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1822803078",
    "pr_number": 120,
    "pr_file": "server/tests/api/test_guidelines.py",
    "created_at": "2024-10-30T14:51:39+00:00",
    "commented_code": "associations_after = await association_store.list_associations()\n     assert not any(assoc.guideline_id == guideline.id for assoc in associations_after)\n+\n+\n+async def test_that_an_existing_guideline_can_be_updated(\n+    client: TestClient,\n+    container: Container,\n+    agent_id: AgentId,\n+) -> None:\n+    guideline_store = container[GuidelineStore]\n+    connection_store = container[GuidelineConnectionStore]\n+\n+    existing_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"the user greets you\",\n+        action=\"reply with 'Hello'\",\n+    )\n+    connected_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Hello'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    connected_guideline_post_update = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Howdy!'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    await connection_store.create_connection(\n+        source=existing_guideline.id,\n+        target=connected_guideline.id,\n+        kind=ConnectionKind.ENTAILS,\n+    )\n+\n+    new_action = \"reply with 'Howdy!'\"\n+\n+    request_data = {\n+        \"invoices\": [\n+            {\n+                \"payload\": {\n+                    \"kind\": \"guideline\",\n+                    \"content\": {\n+                        \"predicate\": \"the user greets you\",\n+                        \"action\": new_action,\n+                    },\n+                    \"operation\": \"update\",\n+                    \"coherence_check\": True,\n+                    \"connection_proposition\": True,\n+                    \"updated_id\": existing_guideline.id,\n+                },\n+                \"checksum\": \"checksum_new\",\n+                \"approved\": True,\n+                \"data\": {\n+                    \"coherence_checks\": [],\n+                    \"connection_propositions\": [\n+                        {\n+                            \"check_kind\": \"connection_with_existing_guideline\",\n+                            \"source\": {\n+                                \"predicate\": \"the user greets you\",\n+                                \"action\": new_action,\n+                            },\n+                            \"target\": {\n+                                \"predicate\": connected_guideline_post_update.content.predicate,\n+                                \"action\": connected_guideline_post_update.content.action,\n+                            },\n+                            \"connection_kind\": \"entails\",\n+                        }\n+                    ],\n+                },\n+                \"error\": None,\n+            }\n+        ]\n+    }\n+\n+    items = (\n+        client.post(f\"/agents/{agent_id}/guidelines/\", json=request_data)\n+        .raise_for_status()\n+        .json()[\"items\"]\n+    )\n+\n+    assert len(items) == 1\n+    updated_guideline = items[0][\"guideline\"]\n+    assert updated_guideline[\"id\"] == existing_guideline.id\n+    assert updated_guideline[\"predicate\"] == \"the user greets you\"\n+    assert updated_guideline[\"action\"] == new_action\n+\n+    updated_connections = await connection_store.list_connections(\n+        indirect=False, source=existing_guideline.id\n+    )\n+    assert len(updated_connections) == 1\n+    assert updated_connections[0].source == existing_guideline.id\n+    assert updated_connections[0].target == connected_guideline_post_update.id\n+    assert updated_connections[0].kind == ConnectionKind.ENTAILS\n+\n+",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "1822803078",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 120,
        "pr_file": "server/tests/api/test_guidelines.py",
        "discussion_id": "1822803078",
        "commented_code": "@@ -684,3 +717,168 @@ async def test_that_guideline_deletion_removes_tool_associations(\n \n     associations_after = await association_store.list_associations()\n     assert not any(assoc.guideline_id == guideline.id for assoc in associations_after)\n+\n+\n+async def test_that_an_existing_guideline_can_be_updated(\n+    client: TestClient,\n+    container: Container,\n+    agent_id: AgentId,\n+) -> None:\n+    guideline_store = container[GuidelineStore]\n+    connection_store = container[GuidelineConnectionStore]\n+\n+    existing_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"the user greets you\",\n+        action=\"reply with 'Hello'\",\n+    )\n+    connected_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Hello'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    connected_guideline_post_update = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Howdy!'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    await connection_store.create_connection(\n+        source=existing_guideline.id,\n+        target=connected_guideline.id,\n+        kind=ConnectionKind.ENTAILS,\n+    )\n+\n+    new_action = \"reply with 'Howdy!'\"\n+\n+    request_data = {\n+        \"invoices\": [\n+            {\n+                \"payload\": {\n+                    \"kind\": \"guideline\",\n+                    \"content\": {\n+                        \"predicate\": \"the user greets you\",\n+                        \"action\": new_action,\n+                    },\n+                    \"operation\": \"update\",\n+                    \"coherence_check\": True,\n+                    \"connection_proposition\": True,\n+                    \"updated_id\": existing_guideline.id,\n+                },\n+                \"checksum\": \"checksum_new\",\n+                \"approved\": True,\n+                \"data\": {\n+                    \"coherence_checks\": [],\n+                    \"connection_propositions\": [\n+                        {\n+                            \"check_kind\": \"connection_with_existing_guideline\",\n+                            \"source\": {\n+                                \"predicate\": \"the user greets you\",\n+                                \"action\": new_action,\n+                            },\n+                            \"target\": {\n+                                \"predicate\": connected_guideline_post_update.content.predicate,\n+                                \"action\": connected_guideline_post_update.content.action,\n+                            },\n+                            \"connection_kind\": \"entails\",\n+                        }\n+                    ],\n+                },\n+                \"error\": None,\n+            }\n+        ]\n+    }\n+\n+    items = (\n+        client.post(f\"/agents/{agent_id}/guidelines/\", json=request_data)\n+        .raise_for_status()\n+        .json()[\"items\"]\n+    )\n+\n+    assert len(items) == 1\n+    updated_guideline = items[0][\"guideline\"]\n+    assert updated_guideline[\"id\"] == existing_guideline.id\n+    assert updated_guideline[\"predicate\"] == \"the user greets you\"\n+    assert updated_guideline[\"action\"] == new_action\n+\n+    updated_connections = await connection_store.list_connections(\n+        indirect=False, source=existing_guideline.id\n+    )\n+    assert len(updated_connections) == 1\n+    assert updated_connections[0].source == existing_guideline.id\n+    assert updated_connections[0].target == connected_guideline_post_update.id\n+    assert updated_connections[0].kind == ConnectionKind.ENTAILS\n+\n+",
        "comment_created_at": "2024-10-30T14:51:39+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "We need to add a test where we update one and add another one, and see that the updated one is checked against the added one, and that the old version of the guideline isn't considered in the check process.",
        "pr_file_module": null
      },
      {
        "comment_id": "1824132701",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 120,
        "pr_file": "server/tests/api/test_guidelines.py",
        "discussion_id": "1822803078",
        "commented_code": "@@ -684,3 +717,168 @@ async def test_that_guideline_deletion_removes_tool_associations(\n \n     associations_after = await association_store.list_associations()\n     assert not any(assoc.guideline_id == guideline.id for assoc in associations_after)\n+\n+\n+async def test_that_an_existing_guideline_can_be_updated(\n+    client: TestClient,\n+    container: Container,\n+    agent_id: AgentId,\n+) -> None:\n+    guideline_store = container[GuidelineStore]\n+    connection_store = container[GuidelineConnectionStore]\n+\n+    existing_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"the user greets you\",\n+        action=\"reply with 'Hello'\",\n+    )\n+    connected_guideline = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Hello'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    connected_guideline_post_update = await guideline_store.create_guideline(\n+        guideline_set=agent_id,\n+        predicate=\"reply with 'Howdy!'\",\n+        action=\"finish with a smile\",\n+    )\n+\n+    await connection_store.create_connection(\n+        source=existing_guideline.id,\n+        target=connected_guideline.id,\n+        kind=ConnectionKind.ENTAILS,\n+    )\n+\n+    new_action = \"reply with 'Howdy!'\"\n+\n+    request_data = {\n+        \"invoices\": [\n+            {\n+                \"payload\": {\n+                    \"kind\": \"guideline\",\n+                    \"content\": {\n+                        \"predicate\": \"the user greets you\",\n+                        \"action\": new_action,\n+                    },\n+                    \"operation\": \"update\",\n+                    \"coherence_check\": True,\n+                    \"connection_proposition\": True,\n+                    \"updated_id\": existing_guideline.id,\n+                },\n+                \"checksum\": \"checksum_new\",\n+                \"approved\": True,\n+                \"data\": {\n+                    \"coherence_checks\": [],\n+                    \"connection_propositions\": [\n+                        {\n+                            \"check_kind\": \"connection_with_existing_guideline\",\n+                            \"source\": {\n+                                \"predicate\": \"the user greets you\",\n+                                \"action\": new_action,\n+                            },\n+                            \"target\": {\n+                                \"predicate\": connected_guideline_post_update.content.predicate,\n+                                \"action\": connected_guideline_post_update.content.action,\n+                            },\n+                            \"connection_kind\": \"entails\",\n+                        }\n+                    ],\n+                },\n+                \"error\": None,\n+            }\n+        ]\n+    }\n+\n+    items = (\n+        client.post(f\"/agents/{agent_id}/guidelines/\", json=request_data)\n+        .raise_for_status()\n+        .json()[\"items\"]\n+    )\n+\n+    assert len(items) == 1\n+    updated_guideline = items[0][\"guideline\"]\n+    assert updated_guideline[\"id\"] == existing_guideline.id\n+    assert updated_guideline[\"predicate\"] == \"the user greets you\"\n+    assert updated_guideline[\"action\"] == new_action\n+\n+    updated_connections = await connection_store.list_connections(\n+        indirect=False, source=existing_guideline.id\n+    )\n+    assert len(updated_connections) == 1\n+    assert updated_connections[0].source == existing_guideline.id\n+    assert updated_connections[0].target == connected_guideline_post_update.id\n+    assert updated_connections[0].kind == ConnectionKind.ENTAILS\n+\n+",
        "comment_created_at": "2024-10-31T09:21:34+00:00",
        "comment_author": "mc-dorzo",
        "comment_body": "from what I understand you request a test in the test_indexes, where we test the check process.\nanyway, I added a test here that check that updated and added guidelines are creating a connection between themselves",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1709687932",
    "pr_number": 41,
    "pr_file": "server/tests/api/test_sessions.py",
    "created_at": "2024-08-08T14:52:39+00:00",
    "commented_code": "return True\n \n \n-def test_that_a_session_can_be_created(client: TestClient) -> None:\n+def test_that_a_session_can_be_created(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n     response = client.post(\n         \"/sessions\",\n         json={\n             \"end_user_id\": \"test_user\",\n-            \"agent_id\": \"test_agent\",\n+            \"agent_id\": agent_id,\n+        },\n+    )\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert \"session_id\" in data\n+    assert \"title\" in data\n+    assert data[\"title\"] is None\n+\n+\n+def test_that_a_session_can_be_created_with_title(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    title = \"Test Session Title\"\n+\n+    response = client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user\",\n+            \"agent_id\": agent_id,\n+            \"title\": title,\n         },\n     )\n     assert response.status_code == status.HTTP_200_OK\n     data = response.json()\n \n     assert \"session_id\" in data\n+    assert data[\"title\"] == title\n+\n+\n+def test_that_sessions_can_be_listed(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user1\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session1 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    response = client.get(f\"/sessions/?agent_id={agent_id}\")\n+\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert data\n+\n+    sessions = data[\"sessions\"]\n+\n+    assert len(sessions) == 3\n+\n+    assert sessions[0][\"title\"] == \"Test Session1 Title\"\n+    assert sessions[1][\"title\"] == \"Test Session2 Title\"\n+    assert sessions[2][\"title\"] == \"Test Session2 Title\"\n+\n+    assert sessions[0][\"end_user_id\"] == \"test_user1\"\n+    assert sessions[1][\"end_user_id\"] == \"test_user2\"\n+    assert sessions[2][\"end_user_id\"] == \"test_user2\"\n+\n+\n+def test_that_sessions_can_be_listed(",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "1709687932",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 41,
        "pr_file": "server/tests/api/test_sessions.py",
        "discussion_id": "1709687932",
        "commented_code": "@@ -108,18 +108,146 @@ def event_is_according_to_params(\n     return True\n \n \n-def test_that_a_session_can_be_created(client: TestClient) -> None:\n+def test_that_a_session_can_be_created(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n     response = client.post(\n         \"/sessions\",\n         json={\n             \"end_user_id\": \"test_user\",\n-            \"agent_id\": \"test_agent\",\n+            \"agent_id\": agent_id,\n+        },\n+    )\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert \"session_id\" in data\n+    assert \"title\" in data\n+    assert data[\"title\"] is None\n+\n+\n+def test_that_a_session_can_be_created_with_title(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    title = \"Test Session Title\"\n+\n+    response = client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user\",\n+            \"agent_id\": agent_id,\n+            \"title\": title,\n         },\n     )\n     assert response.status_code == status.HTTP_200_OK\n     data = response.json()\n \n     assert \"session_id\" in data\n+    assert data[\"title\"] == title\n+\n+\n+def test_that_sessions_can_be_listed(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user1\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session1 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    response = client.get(f\"/sessions/?agent_id={agent_id}\")\n+\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert data\n+\n+    sessions = data[\"sessions\"]\n+\n+    assert len(sessions) == 3\n+\n+    assert sessions[0][\"title\"] == \"Test Session1 Title\"\n+    assert sessions[1][\"title\"] == \"Test Session2 Title\"\n+    assert sessions[2][\"title\"] == \"Test Session2 Title\"\n+\n+    assert sessions[0][\"end_user_id\"] == \"test_user1\"\n+    assert sessions[1][\"end_user_id\"] == \"test_user2\"\n+    assert sessions[2][\"end_user_id\"] == \"test_user2\"\n+\n+\n+def test_that_sessions_can_be_listed(",
        "comment_created_at": "2024-08-08T14:52:39+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "1. Is it just me or is this test duplicated?\r\n2. I think you're not testing the use case where an agent ID is not provided\r\n3. I think if in the backend you completely ignore the agent ID provided, your tests will still pass. This is because as far as I can see you're not testing the filtering logic with multiple agent IDs",
        "pr_file_module": null
      },
      {
        "comment_id": "1709809193",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 41,
        "pr_file": "server/tests/api/test_sessions.py",
        "discussion_id": "1709687932",
        "commented_code": "@@ -108,18 +108,146 @@ def event_is_according_to_params(\n     return True\n \n \n-def test_that_a_session_can_be_created(client: TestClient) -> None:\n+def test_that_a_session_can_be_created(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n     response = client.post(\n         \"/sessions\",\n         json={\n             \"end_user_id\": \"test_user\",\n-            \"agent_id\": \"test_agent\",\n+            \"agent_id\": agent_id,\n+        },\n+    )\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert \"session_id\" in data\n+    assert \"title\" in data\n+    assert data[\"title\"] is None\n+\n+\n+def test_that_a_session_can_be_created_with_title(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    title = \"Test Session Title\"\n+\n+    response = client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user\",\n+            \"agent_id\": agent_id,\n+            \"title\": title,\n         },\n     )\n     assert response.status_code == status.HTTP_200_OK\n     data = response.json()\n \n     assert \"session_id\" in data\n+    assert data[\"title\"] == title\n+\n+\n+def test_that_sessions_can_be_listed(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user1\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session1 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    response = client.get(f\"/sessions/?agent_id={agent_id}\")\n+\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert data\n+\n+    sessions = data[\"sessions\"]\n+\n+    assert len(sessions) == 3\n+\n+    assert sessions[0][\"title\"] == \"Test Session1 Title\"\n+    assert sessions[1][\"title\"] == \"Test Session2 Title\"\n+    assert sessions[2][\"title\"] == \"Test Session2 Title\"\n+\n+    assert sessions[0][\"end_user_id\"] == \"test_user1\"\n+    assert sessions[1][\"end_user_id\"] == \"test_user2\"\n+    assert sessions[2][\"end_user_id\"] == \"test_user2\"\n+\n+\n+def test_that_sessions_can_be_listed(",
        "comment_created_at": "2024-08-08T15:48:41+00:00",
        "comment_author": "mc-dorzo",
        "comment_body": "1 + 2. True, and changed testing for the use case where an Agentd is not provided.\r\n3. not sure I follow. you can pass only one agent id. not multiple to the api.",
        "pr_file_module": null
      },
      {
        "comment_id": "1713974520",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 41,
        "pr_file": "server/tests/api/test_sessions.py",
        "discussion_id": "1709687932",
        "commented_code": "@@ -108,18 +108,146 @@ def event_is_according_to_params(\n     return True\n \n \n-def test_that_a_session_can_be_created(client: TestClient) -> None:\n+def test_that_a_session_can_be_created(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n     response = client.post(\n         \"/sessions\",\n         json={\n             \"end_user_id\": \"test_user\",\n-            \"agent_id\": \"test_agent\",\n+            \"agent_id\": agent_id,\n+        },\n+    )\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert \"session_id\" in data\n+    assert \"title\" in data\n+    assert data[\"title\"] is None\n+\n+\n+def test_that_a_session_can_be_created_with_title(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    title = \"Test Session Title\"\n+\n+    response = client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user\",\n+            \"agent_id\": agent_id,\n+            \"title\": title,\n         },\n     )\n     assert response.status_code == status.HTTP_200_OK\n     data = response.json()\n \n     assert \"session_id\" in data\n+    assert data[\"title\"] == title\n+\n+\n+def test_that_sessions_can_be_listed(\n+    client: TestClient,\n+    agent_id: AgentId,\n+) -> None:\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user1\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session1 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    client.post(\n+        \"/sessions\",\n+        json={\n+            \"end_user_id\": \"test_user2\",\n+            \"agent_id\": agent_id,\n+            \"title\": \"Test Session2 Title\",\n+        },\n+    )\n+\n+    response = client.get(f\"/sessions/?agent_id={agent_id}\")\n+\n+    assert response.status_code == status.HTTP_200_OK\n+    data = response.json()\n+\n+    assert data\n+\n+    sessions = data[\"sessions\"]\n+\n+    assert len(sessions) == 3\n+\n+    assert sessions[0][\"title\"] == \"Test Session1 Title\"\n+    assert sessions[1][\"title\"] == \"Test Session2 Title\"\n+    assert sessions[2][\"title\"] == \"Test Session2 Title\"\n+\n+    assert sessions[0][\"end_user_id\"] == \"test_user1\"\n+    assert sessions[1][\"end_user_id\"] == \"test_user2\"\n+    assert sessions[2][\"end_user_id\"] == \"test_user2\"\n+\n+\n+def test_that_sessions_can_be_listed(",
        "comment_created_at": "2024-08-12T15:17:27+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "@mc-dorzo re 3, you can have multiple sessions with different agents",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1720689245",
    "pr_number": 46,
    "pr_file": "server/src/emcie/server/core/guideline_connections.py",
    "created_at": "2024-08-17T07:07:53+00:00",
    "commented_code": "async def list_connections(\n         self,\n-        source: GuidelineId,\n         indirect: bool,\n+        source: Optional[GuidelineId] = None,\n+        target: Optional[GuidelineId] = None,\n     ) -> Sequence[GuidelineConnection]:\n-        graph = await self._get_graph()\n+        assert source or target\n \n-        if not graph.has_node(source):\n-            return []\n+        async def get_node_connections(node: GuidelineId) -> Sequence[GuidelineConnection]:",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "1720689245",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 46,
        "pr_file": "server/src/emcie/server/core/guideline_connections.py",
        "discussion_id": "1720689245",
        "commented_code": "@@ -144,54 +145,68 @@ async def delete_connection(\n \n     async def list_connections(\n         self,\n-        source: GuidelineId,\n         indirect: bool,\n+        source: Optional[GuidelineId] = None,\n+        target: Optional[GuidelineId] = None,\n     ) -> Sequence[GuidelineConnection]:\n-        graph = await self._get_graph()\n+        assert source or target\n \n-        if not graph.has_node(source):\n-            return []\n+        async def get_node_connections(node: GuidelineId) -> Sequence[GuidelineConnection]:",
        "comment_created_at": "2024-08-17T07:07:53+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "@mc-dorzo Why are there no added tests for this class and this change of behavior?\nI.e. tests that check what happens when you only specify the target, or both source and target?\nI'm also asking because I think I see a bug here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1677867507",
    "pr_number": 29,
    "pr_file": "server/tests/engines/alpha/test_supervision.py",
    "created_at": "2024-07-15T13:50:50+00:00",
    "commented_code": "def when_processing_is_triggered(\n     context: _TestContext,\n ) -> list[ProducedEvent]:\n+    agents = [",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "1677867507",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 29,
        "pr_file": "server/tests/engines/alpha/test_supervision.py",
        "discussion_id": "1677867507",
        "commented_code": "@@ -134,10 +135,20 @@ def given_a_guideline_proposition(\n def when_processing_is_triggered(\n     context: _TestContext,\n ) -> list[ProducedEvent]:\n+    agents = [",
        "comment_created_at": "2024-07-15T13:50:50+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "We need to add a test case that tests this new feature.\r\nSpecify a BDD test scenario that takes agent identity into consideration.\r\n\r\nProcess:\r\n1. Create a test scenario that is supposed to lean on agent description to verify its outcome (e.g., specify in the identity that it's an agent that sells pizza, then specify a guideline that says \"do your job when a user says hello\", and then `nlp_test` that it's trying to sell pizza.\r\n2. Don't yet add the correct agent description to the test code. First, let's ensure that the test fails after it was first written.\r\n3. Add the proper agent description in the test code.\r\n4. Make sure that the test passes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1668039453",
    "pr_number": 18,
    "pr_file": "server/src/emcie/server/core/persistence.py",
    "created_at": "2024-07-08T06:06:09+00:00",
    "commented_code": "self._lock = asyncio.Lock()\n         if not self.file_path.exists():\n             self.file_path.write_text(json.dumps({}))\n+        self.transient_db: Optional[TransientDocumentDatabase]\n+\n+    async def __aenter__(self) -> JSONFileDocumentDatabase:\n+        self.transient_db = TransientDocumentDatabase()\n+        self.transient_db.load_collections(await self._load_data())",
    "repo_full_name": "emcie-co/parlant",
    "discussion_comments": [
      {
        "comment_id": "1668039453",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 18,
        "pr_file": "server/src/emcie/server/core/persistence.py",
        "discussion_id": "1668039453",
        "commented_code": "@@ -171,6 +181,21 @@ def __init__(self, file_path: Path) -> None:\n         self._lock = asyncio.Lock()\n         if not self.file_path.exists():\n             self.file_path.write_text(json.dumps({}))\n+        self.transient_db: Optional[TransientDocumentDatabase]\n+\n+    async def __aenter__(self) -> JSONFileDocumentDatabase:\n+        self.transient_db = TransientDocumentDatabase()\n+        self.transient_db.load_collections(await self._load_data())",
        "comment_created_at": "2024-07-08T06:06:09+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "Please add a test to check what happens if the file exists and is empty (no content at all, just returns an empty string when read)",
        "pr_file_module": null
      },
      {
        "comment_id": "1668040015",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 18,
        "pr_file": "server/src/emcie/server/core/persistence.py",
        "discussion_id": "1668039453",
        "commented_code": "@@ -171,6 +181,21 @@ def __init__(self, file_path: Path) -> None:\n         self._lock = asyncio.Lock()\n         if not self.file_path.exists():\n             self.file_path.write_text(json.dumps({}))\n+        self.transient_db: Optional[TransientDocumentDatabase]\n+\n+    async def __aenter__(self) -> JSONFileDocumentDatabase:\n+        self.transient_db = TransientDocumentDatabase()\n+        self.transient_db.load_collections(await self._load_data())",
        "comment_created_at": "2024-07-08T06:06:50+00:00",
        "comment_author": "kichanyurd",
        "comment_body": "I.e. the JSON file you're trying to open in _load_data()",
        "pr_file_module": null
      },
      {
        "comment_id": "1668390791",
        "repo_full_name": "emcie-co/parlant",
        "pr_number": 18,
        "pr_file": "server/src/emcie/server/core/persistence.py",
        "discussion_id": "1668039453",
        "commented_code": "@@ -171,6 +181,21 @@ def __init__(self, file_path: Path) -> None:\n         self._lock = asyncio.Lock()\n         if not self.file_path.exists():\n             self.file_path.write_text(json.dumps({}))\n+        self.transient_db: Optional[TransientDocumentDatabase]\n+\n+    async def __aenter__(self) -> JSONFileDocumentDatabase:\n+        self.transient_db = TransientDocumentDatabase()\n+        self.transient_db.load_collections(await self._load_data())",
        "comment_created_at": "2024-07-08T10:30:40+00:00",
        "comment_author": "mc-dorzo",
        "comment_body": "Great test! ",
        "pr_file_module": null
      }
    ]
  }
]