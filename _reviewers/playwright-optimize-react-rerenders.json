[
  {
    "discussion_id": "2205227532",
    "pr_number": 36677,
    "pr_file": "packages/trace-viewer/src/ui/snapshotTab.tsx",
    "created_at": "2025-07-14T15:32:14+00:00",
    "commented_code": "React.useEffect(() => {\n     (async () => {\n+      if (snapshotInfo.snapshotInfoUrl === snapshotUrls?.snapshotInfoUrl)",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2205227532",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 36677,
        "pr_file": "packages/trace-viewer/src/ui/snapshotTab.tsx",
        "discussion_id": "2205227532",
        "commented_code": "@@ -110,6 +110,9 @@ export const SnapshotView: React.FunctionComponent<{\n \n   React.useEffect(() => {\n     (async () => {\n+      if (snapshotInfo.snapshotInfoUrl === snapshotUrls?.snapshotInfoUrl)",
        "comment_created_at": "2025-07-14T15:32:14+00:00",
        "comment_author": "pavelfeldman",
        "comment_body": "This effect only depends on the `snapshotUrls` instance, so Reacty fix would be on the call site. I can see that \r\n\r\n```js\r\n  const snapshotUrls = React.useMemo(() => {\r\n    const snapshot = snapshots[snapshotTab];\r\n    return snapshot ? extendSnapshot(snapshot, shouldPopulateCanvasFromScreenshot) : undefined;\r\n  }, [snapshots, snapshotTab, shouldPopulateCanvasFromScreenshot]);\r\n```\r\n\r\nso the `snapshots` array is new, which is because `action` is new, etc. If we want to be reacty, we should make sure that those objects \"stay the same\" in the live mode, that way all the little refreshes go away, not just the snapshot one.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164038097",
    "pr_number": 36251,
    "pr_file": "packages/web/src/components/tabbedPane.tsx",
    "created_at": "2025-06-24T13:39:32+00:00",
    "commented_code": "setSelectedTab?: (tab: string) => void,\n   dataTestId?: string,\n   mode?: 'default' | 'select',\n-}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode }) => {\n+  overflowMode?: 'none' | 'select'\n+}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode, overflowMode }) => {\n   const id = React.useId();\n   if (!selectedTab)\n     selectedTab = tabs[0].id;\n   if (!mode)\n     mode = 'default';\n-  return <div className='tabbed-pane' data-testid={dataTestId}>\n+  if (!overflowMode)\n+    overflowMode = 'none';\n+\n+  const containerRef = React.useRef<HTMLDivElement>(null);\n+  const [visibleTabs, setVisibleTabs] = React.useState<TabbedPaneTabModel[]>(mode !== 'select' ? tabs : []);\n+  const [overflowTabs, setOverflowTabs] = React.useState<TabbedPaneTabModel[]>(mode === 'select' ? tabs : []);\n+  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n+  const [, setContainerWidth] = React.useState<number>(0);",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2164038097",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 36251,
        "pr_file": "packages/web/src/components/tabbedPane.tsx",
        "discussion_id": "2164038097",
        "commented_code": "@@ -36,37 +36,164 @@ export const TabbedPane: React.FunctionComponent<{\n   setSelectedTab?: (tab: string) => void,\n   dataTestId?: string,\n   mode?: 'default' | 'select',\n-}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode }) => {\n+  overflowMode?: 'none' | 'select'\n+}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode, overflowMode }) => {\n   const id = React.useId();\n   if (!selectedTab)\n     selectedTab = tabs[0].id;\n   if (!mode)\n     mode = 'default';\n-  return <div className='tabbed-pane' data-testid={dataTestId}>\n+  if (!overflowMode)\n+    overflowMode = 'none';\n+\n+  const containerRef = React.useRef<HTMLDivElement>(null);\n+  const [visibleTabs, setVisibleTabs] = React.useState<TabbedPaneTabModel[]>(mode !== 'select' ? tabs : []);\n+  const [overflowTabs, setOverflowTabs] = React.useState<TabbedPaneTabModel[]>(mode === 'select' ? tabs : []);\n+  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n+  const [, setContainerWidth] = React.useState<number>(0);",
        "comment_created_at": "2025-06-24T13:39:32+00:00",
        "comment_author": "agg23",
        "comment_body": "Are you using this for rerender management? Why does it matter, given you're also setting other state every time this is set? Those other sets will always be new/unique as well, so they will also cause a rerender.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176578570",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 36251,
        "pr_file": "packages/web/src/components/tabbedPane.tsx",
        "discussion_id": "2164038097",
        "commented_code": "@@ -36,37 +36,164 @@ export const TabbedPane: React.FunctionComponent<{\n   setSelectedTab?: (tab: string) => void,\n   dataTestId?: string,\n   mode?: 'default' | 'select',\n-}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode }) => {\n+  overflowMode?: 'none' | 'select'\n+}> = ({ tabs, selectedTab, setSelectedTab, leftToolbar, rightToolbar, dataTestId, mode, overflowMode }) => {\n   const id = React.useId();\n   if (!selectedTab)\n     selectedTab = tabs[0].id;\n   if (!mode)\n     mode = 'default';\n-  return <div className='tabbed-pane' data-testid={dataTestId}>\n+  if (!overflowMode)\n+    overflowMode = 'none';\n+\n+  const containerRef = React.useRef<HTMLDivElement>(null);\n+  const [visibleTabs, setVisibleTabs] = React.useState<TabbedPaneTabModel[]>(mode !== 'select' ? tabs : []);\n+  const [overflowTabs, setOverflowTabs] = React.useState<TabbedPaneTabModel[]>(mode === 'select' ? tabs : []);\n+  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n+  const [, setContainerWidth] = React.useState<number>(0);",
        "comment_created_at": "2025-07-01T06:53:52+00:00",
        "comment_author": "Zemotacqy",
        "comment_body": "Thanks @agg23 , This makes sense. I verified, containerWidth wasn't to re-render other states. It was only used for calculation of available space. Have pushed a commit to remove it usage.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021738458",
    "pr_number": 35344,
    "pr_file": "packages/trace-viewer/src/ui/uiModeTraceView.tsx",
    "created_at": "2025-03-31T20:42:04+00:00",
    "commented_code": "pollTimer.current = setTimeout(async () => {\n       try {\n         const model = await loadSingleTraceFile(traceLocation);\n-        setModel({ model, isLive: true });\n-      } catch {\n-        setModel(undefined);\n+        setTrace({ type: 'success', model, isLive: true });\n+      } catch (e) {\n+        const errors = result.errors.flatMap(error => !!error.message ? [error.message] : []);",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2021738458",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35344,
        "pr_file": "packages/trace-viewer/src/ui/uiModeTraceView.tsx",
        "discussion_id": "2021738458",
        "commented_code": "@@ -73,9 +77,34 @@ export const TraceView: React.FC<{\n     pollTimer.current = setTimeout(async () => {\n       try {\n         const model = await loadSingleTraceFile(traceLocation);\n-        setModel({ model, isLive: true });\n-      } catch {\n-        setModel(undefined);\n+        setTrace({ type: 'success', model, isLive: true });\n+      } catch (e) {\n+        const errors = result.errors.flatMap(error => !!error.message ? [error.message] : []);",
        "comment_created_at": "2025-03-31T20:42:04+00:00",
        "comment_author": "pavelfeldman",
        "comment_body": "So I wonder why something like this instead of this change does not work:\r\n```js\r\nconst errors = result.errors.flatMap(error => !!error.message ? [error.message] : []);\r\nconst modelWithErrors = new MultiTraceModel([]);\r\nmodelWithErrors.errorDescriptors.push(...errors.map(message => ({ message })));\r\nsetModel({ model: modelWithErrors, isLive: false });\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2023400251",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35344,
        "pr_file": "packages/trace-viewer/src/ui/uiModeTraceView.tsx",
        "discussion_id": "2021738458",
        "commented_code": "@@ -73,9 +77,34 @@ export const TraceView: React.FC<{\n     pollTimer.current = setTimeout(async () => {\n       try {\n         const model = await loadSingleTraceFile(traceLocation);\n-        setModel({ model, isLive: true });\n-      } catch {\n-        setModel(undefined);\n+        setTrace({ type: 'success', model, isLive: true });\n+      } catch (e) {\n+        const errors = result.errors.flatMap(error => !!error.message ? [error.message] : []);",
        "comment_created_at": "2025-04-01T17:52:56+00:00",
        "comment_author": "agg23",
        "comment_body": "I have updated the PR to have that form. By doing so, you lose:\r\n1. Expressiveness in having a discriminated union enumerate possible states (no data vs we have data (live or not) vs we have failed to get data).\r\n2. `model` stability in the error case; it will create a new error model every 500ms and React will do a full rerender of the child tree.\r\n3. A more complete failure error message next to the actions (which you probably didn't like anyway).",
        "pr_file_module": null
      }
    ]
  }
]