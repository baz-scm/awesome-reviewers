[
  {
    "discussion_id": "2142107461",
    "pr_number": 36158,
    "pr_file": "packages/playwright-core/src/server/dispatchers/androidDispatcher.ts",
    "created_at": "2025-06-12T08:58:12+00:00",
    "commented_code": "}\n }\n \n-export class AndroidSocketDispatcher extends Dispatcher<SocketBackend, channels.AndroidSocketChannel, AndroidDeviceDispatcher> implements channels.AndroidSocketChannel {\n+class SocketSdkObject extends SdkObject implements SocketBackend {\n+  private _socket: SocketBackend;\n+  private _eventListeners;\n+\n+  constructor(parent: SdkObject, socket: SocketBackend) {\n+    super(parent, 'socket');\n+    this._socket = socket;\n+    this._eventListeners = [\n+      eventsHelper.addEventListener(socket, 'data', data => this.emit('data', data)),\n+      eventsHelper.addEventListener(socket, 'close', () => this.emit('close')),\n+    ];\n+  }\n+\n+  async write(data: Buffer) {\n+    await this._socket.write(data);\n+  }\n+\n+  close() {\n+    this._socket.close();\n+    eventsHelper.removeEventListeners(this._eventListeners);",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2142107461",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 36158,
        "pr_file": "packages/playwright-core/src/server/dispatchers/androidDispatcher.ts",
        "discussion_id": "2142107461",
        "commented_code": "@@ -170,10 +172,33 @@ export class AndroidDeviceDispatcher extends Dispatcher<AndroidDevice, channels.\n   }\n }\n \n-export class AndroidSocketDispatcher extends Dispatcher<SocketBackend, channels.AndroidSocketChannel, AndroidDeviceDispatcher> implements channels.AndroidSocketChannel {\n+class SocketSdkObject extends SdkObject implements SocketBackend {\n+  private _socket: SocketBackend;\n+  private _eventListeners;\n+\n+  constructor(parent: SdkObject, socket: SocketBackend) {\n+    super(parent, 'socket');\n+    this._socket = socket;\n+    this._eventListeners = [\n+      eventsHelper.addEventListener(socket, 'data', data => this.emit('data', data)),\n+      eventsHelper.addEventListener(socket, 'close', () => this.emit('close')),\n+    ];\n+  }\n+\n+  async write(data: Buffer) {\n+    await this._socket.write(data);\n+  }\n+\n+  close() {\n+    this._socket.close();\n+    eventsHelper.removeEventListeners(this._eventListeners);",
        "comment_created_at": "2025-06-12T08:58:12+00:00",
        "comment_author": "mxschmitt",
        "comment_body": "This causes `DEBUG=pw:api npm run atest android/device.spec.ts:26` to fail:\r\n1. `SocketSdkObject.close()` gets called\r\n2. `'close'` event listeners get immediately removed\r\n3. The client never receives the actual `'close'` event.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2053934467",
    "pr_number": 35670,
    "pr_file": "packages/playwright/src/errorContext.ts",
    "created_at": "2025-04-22T11:39:17+00:00",
    "commented_code": "const parsedError = error.stack ? parseErrorStack(error.stack, path.sep) : undefined;\n     const inlineMessage = stripAnsiEscapes(parsedError?.message || error.message || '').split('\n')[0];\n-    const location = parsedError?.location || { file: testInfo.file, line: testInfo.line, column: testInfo.column };\n+    const location = (parsedError?.location && await existsAsync(parsedError.location.file)) ? parsedError.location : { file: testInfo.file, line: testInfo.line, column: testInfo.column };",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2053934467",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35670,
        "pr_file": "packages/playwright/src/errorContext.ts",
        "discussion_id": "2053934467",
        "commented_code": "@@ -91,7 +91,7 @@ export async function attachErrorContext(testInfo: TestInfoImpl, format: 'markdo\n \n     const parsedError = error.stack ? parseErrorStack(error.stack, path.sep) : undefined;\n     const inlineMessage = stripAnsiEscapes(parsedError?.message || error.message || '').split('\\n')[0];\n-    const location = parsedError?.location || { file: testInfo.file, line: testInfo.line, column: testInfo.column };\n+    const location = (parsedError?.location && await existsAsync(parsedError.location.file)) ? parsedError.location : { file: testInfo.file, line: testInfo.line, column: testInfo.column };",
        "comment_created_at": "2025-04-22T11:39:17+00:00",
        "comment_author": "dgozman",
        "comment_body": "This is prone to race conditions and probably `EPERM` as well. Let's make it a try/catch inside `loadSource` instead?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1939117960",
    "pr_number": 34520,
    "pr_file": "packages/playwright-core/src/client/browserContext.ts",
    "created_at": "2025-02-03T10:10:29+00:00",
    "commented_code": "this.tracing._tracesDir = browserOptions.tracesDir;\n   }\n \n-  private _onPage(page: Page): void {\n+  private async _onPage(page: Page): Promise<void>{\n     this._pages.add(page);\n     this.emit(Events.BrowserContext.Page, page);\n+    await this._mockingProxy?.instrumentPage(page);",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "1939117960",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 34520,
        "pr_file": "packages/playwright-core/src/client/browserContext.ts",
        "discussion_id": "1939117960",
        "commented_code": "@@ -157,9 +165,10 @@ export class BrowserContext extends ChannelOwner<channels.BrowserContextChannel>\n     this.tracing._tracesDir = browserOptions.tracesDir;\n   }\n \n-  private _onPage(page: Page): void {\n+  private async _onPage(page: Page): Promise<void>{\n     this._pages.add(page);\n     this.emit(Events.BrowserContext.Page, page);\n+    await this._mockingProxy?.instrumentPage(page);",
        "comment_created_at": "2025-02-03T10:10:29+00:00",
        "comment_author": "dgozman",
        "comment_body": "As a rule thumb, we can not afford async handling in an event handler. For example, the `popup` event below should be fired synchronously.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086519220",
    "pr_number": 35933,
    "pr_file": "packages/playwright/src/transform/esmLoader.ts",
    "created_at": "2025-05-13T10:49:11+00:00",
    "commented_code": "const transformed = transformHook(code, filename, moduleUrl);\n \n   // Flush the source maps to the main thread, so that errors during import() are source-mapped.\n-  if (transformed.serializedCache)\n-    await transport?.send('pushToCompilationCache', { cache: transformed.serializedCache });\n+  // Under certain conditions with ESM -> CJS -> CJS imports, we can enter deadlock awaiting the\n+  // MessagePort transfer simultaneously with the Node.js worker thread that is performing the load().\n+  // Purposefully do not await\n+  if (transformed.serializedCache) {\n+    transport?.send('pushToCompilationCache', { cache: transformed.serializedCache })",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2086519220",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35933,
        "pr_file": "packages/playwright/src/transform/esmLoader.ts",
        "discussion_id": "2086519220",
        "commented_code": "@@ -72,8 +72,14 @@ async function load(moduleUrl: string, context: { format?: string }, defaultLoad\n   const transformed = transformHook(code, filename, moduleUrl);\n \n   // Flush the source maps to the main thread, so that errors during import() are source-mapped.\n-  if (transformed.serializedCache)\n-    await transport?.send('pushToCompilationCache', { cache: transformed.serializedCache });\n+  // Under certain conditions with ESM -> CJS -> CJS imports, we can enter deadlock awaiting the\n+  // MessagePort transfer simultaneously with the Node.js worker thread that is performing the load().\n+  // Purposefully do not await\n+  if (transformed.serializedCache) {\n+    transport?.send('pushToCompilationCache', { cache: transformed.serializedCache })",
        "comment_created_at": "2025-05-13T10:49:11+00:00",
        "comment_author": "dgozman",
        "comment_body": "Perhaps we can not await only when `format` is `commonjs` or something like that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2087337627",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35933,
        "pr_file": "packages/playwright/src/transform/esmLoader.ts",
        "discussion_id": "2086519220",
        "commented_code": "@@ -72,8 +72,14 @@ async function load(moduleUrl: string, context: { format?: string }, defaultLoad\n   const transformed = transformHook(code, filename, moduleUrl);\n \n   // Flush the source maps to the main thread, so that errors during import() are source-mapped.\n-  if (transformed.serializedCache)\n-    await transport?.send('pushToCompilationCache', { cache: transformed.serializedCache });\n+  // Under certain conditions with ESM -> CJS -> CJS imports, we can enter deadlock awaiting the\n+  // MessagePort transfer simultaneously with the Node.js worker thread that is performing the load().\n+  // Purposefully do not await\n+  if (transformed.serializedCache) {\n+    transport?.send('pushToCompilationCache', { cache: transformed.serializedCache })",
        "comment_created_at": "2025-05-13T17:36:10+00:00",
        "comment_author": "agg23",
        "comment_body": "Discussed offline. We're going to use a 1s timeout, and only then stop awaiting.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2089109450",
    "pr_number": 35933,
    "pr_file": "packages/playwright/src/transform/esmLoader.ts",
    "created_at": "2025-05-14T14:37:20+00:00",
    "commented_code": "};\n }\n \n+// Under certain conditions with ESM -> CJS -> any imports, we can enter deadlock awaiting the\n+// MessagePort transfer simultaneously with the Node.js worker thread that is performing the load().\n+// Attempt to await the IPC transfer, and if it takes too long, fallback to a non-awaiting transfer\n+async function pushToCompilationCache(transport: PortTransport, cache: any) {\n+  if (workerShouldFallbackCompilationCache) {\n+    transport.send('pushToCompilationCache', { cache })\n+        .catch(e => debugTest('Failed to push compilation cache', e));\n+    return;\n+  }\n+\n+  const { timedOut } = await raceAgainstDeadline(() => transport.send('pushToCompilationCache', { cache }), 1000);",
    "repo_full_name": "microsoft/playwright",
    "discussion_comments": [
      {
        "comment_id": "2089109450",
        "repo_full_name": "microsoft/playwright",
        "pr_number": 35933,
        "pr_file": "packages/playwright/src/transform/esmLoader.ts",
        "discussion_id": "2089109450",
        "commented_code": "@@ -84,6 +90,23 @@ async function load(moduleUrl: string, context: { format?: string }, defaultLoad\n   };\n }\n \n+// Under certain conditions with ESM -> CJS -> any imports, we can enter deadlock awaiting the\n+// MessagePort transfer simultaneously with the Node.js worker thread that is performing the load().\n+// Attempt to await the IPC transfer, and if it takes too long, fallback to a non-awaiting transfer\n+async function pushToCompilationCache(transport: PortTransport, cache: any) {\n+  if (workerShouldFallbackCompilationCache) {\n+    transport.send('pushToCompilationCache', { cache })\n+        .catch(e => debugTest('Failed to push compilation cache', e));\n+    return;\n+  }\n+\n+  const { timedOut } = await raceAgainstDeadline(() => transport.send('pushToCompilationCache', { cache }), 1000);",
        "comment_created_at": "2025-05-14T14:37:20+00:00",
        "comment_author": "dgozman",
        "comment_body": "```suggestion\r\n  const { timedOut } = await raceAgainstDeadline(() => transport.send('pushToCompilationCache', { cache }), monotonicTime() + 1000);\r\n```",
        "pr_file_module": null
      }
    ]
  }
]