[
  {
    "discussion_id": "1929952677",
    "pr_number": 10097,
    "pr_file": "src/poetry/utils/env/python_manager.py",
    "created_at": "2025-01-27T03:27:11+00:00",
    "commented_code": "from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1929955488",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10097,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1929952677",
        "commented_code": "@@ -1,52 +1,88 @@\n from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:",
        "comment_created_at": "2025-01-27T03:27:11+00:00",
        "comment_author": "abn",
        "comment_body": "This would be the desired solution. Unfortunately, we need to maintain backwards compatibility. Hence we are using the overload.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1930216559",
    "pr_number": 10097,
    "pr_file": "src/poetry/utils/env/python_manager.py",
    "created_at": "2025-01-27T09:31:10+00:00",
    "commented_code": "from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:\n-    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n-        self.executable = Path(executable)\n-        self._version = version\n+    @overload\n+    def __init__(self, *, python: findpython.PythonVersion) -> None: ...\n+\n+    @overload\n+    def __init__(\n+        self, executable: str | Path, version: Version | None = None\n+    ) -> None: ...\n+\n+    # we overload __init__ to ensure we do not break any downstream plugins\n+    # that use the this\n+    def __init__(\n+        self,\n+        executable: str | Path | None = None,\n+        version: Version | None = None,\n+        python: findpython.PythonVersion | None = None,\n+    ) -> None:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1930216559",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10097,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1930216559",
        "commented_code": "@@ -1,52 +1,88 @@\n from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:\n-    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n-        self.executable = Path(executable)\n-        self._version = version\n+    @overload\n+    def __init__(self, *, python: findpython.PythonVersion) -> None: ...\n+\n+    @overload\n+    def __init__(\n+        self, executable: str | Path, version: Version | None = None\n+    ) -> None: ...\n+\n+    # we overload __init__ to ensure we do not break any downstream plugins\n+    # that use the this\n+    def __init__(\n+        self,\n+        executable: str | Path | None = None,\n+        version: Version | None = None,\n+        python: findpython.PythonVersion | None = None,\n+    ) -> None:",
        "comment_created_at": "2025-01-27T09:31:10+00:00",
        "comment_author": "finswimmer",
        "comment_body": "I would like to keep `findpython` as an implementation detail of the `Python` class, therefor we should avoid `findpython` in the public \"API\" (like here in `__init__()`).\r\n\r\nAs far as I can see passing `python` on init is only done by several classmethods. Those method could pass the executable instead and the `PythonVersion` object is then (re)created. (Yes, recreating might be some overhead but it shouldn't be that much and for the sake of separating the implementation details I clearly prefer that). Not sure if the version should than also be passed through, because it looks like it's lazy loaded in `PythonVersion`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1930292145",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10097,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1930216559",
        "commented_code": "@@ -1,52 +1,88 @@\n from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:\n-    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n-        self.executable = Path(executable)\n-        self._version = version\n+    @overload\n+    def __init__(self, *, python: findpython.PythonVersion) -> None: ...\n+\n+    @overload\n+    def __init__(\n+        self, executable: str | Path, version: Version | None = None\n+    ) -> None: ...\n+\n+    # we overload __init__ to ensure we do not break any downstream plugins\n+    # that use the this\n+    def __init__(\n+        self,\n+        executable: str | Path | None = None,\n+        version: Version | None = None,\n+        python: findpython.PythonVersion | None = None,\n+    ) -> None:",
        "comment_created_at": "2025-01-27T10:23:41+00:00",
        "comment_author": "abn",
        "comment_body": "It will trigger unnecessary subprocess overheads (when initialized and lazily on certain property access) and is not recommended. I don't think there is anything wrong with using it as an init var.",
        "pr_file_module": null
      },
      {
        "comment_id": "1935880343",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 10097,
        "pr_file": "src/poetry/utils/env/python_manager.py",
        "discussion_id": "1930216559",
        "commented_code": "@@ -1,52 +1,88 @@\n from __future__ import annotations\n \n import shutil\n-import subprocess\n import sys\n \n from functools import cached_property\n from pathlib import Path\n from typing import TYPE_CHECKING\n+from typing import cast\n+from typing import overload\n+\n+import findpython\n+import packaging.version\n \n from cleo.io.null_io import NullIO\n from cleo.io.outputs.output import Verbosity\n from poetry.core.constraints.version import Version\n-from poetry.core.constraints.version import parse_constraint\n \n-from poetry.utils._compat import decode\n from poetry.utils.env.exceptions import NoCompatiblePythonVersionFoundError\n-from poetry.utils.env.script_strings import GET_PYTHON_VERSION_ONELINER\n \n \n if TYPE_CHECKING:\n+    from collections.abc import Iterable\n+\n     from cleo.io.io import IO\n+    from typing_extensions import Self\n \n     from poetry.config.config import Config\n     from poetry.poetry import Poetry\n \n \n+class ShutilWhichPythonProvider(findpython.BaseProvider):  # type: ignore[misc]\n+    @classmethod\n+    def create(cls) -> Self | None:\n+        return cls()\n+\n+    def find_pythons(self) -> Iterable[findpython.PythonVersion]:\n+        if path := shutil.which(\"python\"):\n+            return [findpython.PythonVersion(executable=Path(path))]\n+        return []\n+\n+\n class Python:\n-    def __init__(self, executable: str | Path, version: Version | None = None) -> None:\n-        self.executable = Path(executable)\n-        self._version = version\n+    @overload\n+    def __init__(self, *, python: findpython.PythonVersion) -> None: ...\n+\n+    @overload\n+    def __init__(\n+        self, executable: str | Path, version: Version | None = None\n+    ) -> None: ...\n+\n+    # we overload __init__ to ensure we do not break any downstream plugins\n+    # that use the this\n+    def __init__(\n+        self,\n+        executable: str | Path | None = None,\n+        version: Version | None = None,\n+        python: findpython.PythonVersion | None = None,\n+    ) -> None:",
        "comment_created_at": "2025-01-30T16:08:05+00:00",
        "comment_author": "abn",
        "comment_body": "Resolving this, I do not think I want to remove the ability to pass in an already instantiated `PythonVersion` instance.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1067243665",
    "pr_number": 6879,
    "pr_file": "src/poetry/repositories/repository_pool.py",
    "created_at": "2023-01-11T17:02:33+00:00",
    "commented_code": "raise IndexError(f'Repository \"{name}\" does not exist.')\n \n     def add_repository(\n-        self, repository: Repository, default: bool = False, secondary: bool = False\n+        self,\n+        repository: Repository,\n+        priority: Priority = Priority.PRIMARY,",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1067243665",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 6879,
        "pr_file": "src/poetry/repositories/repository_pool.py",
        "discussion_id": "1067243665",
        "commented_code": "@@ -77,7 +85,9 @@ def repository(self, name: str) -> Repository:\n         raise IndexError(f'Repository \"{name}\" does not exist.')\n \n     def add_repository(\n-        self, repository: Repository, default: bool = False, secondary: bool = False\n+        self,\n+        repository: Repository,\n+        priority: Priority = Priority.PRIMARY,",
        "comment_created_at": "2023-01-11T17:02:33+00:00",
        "comment_author": "radoering",
        "comment_body": "If I remember correctly, this function is used by plugin authors (not only poetry-plugin-export). Maybe, we should deprecate the parameters, keep them functional and add `priority` as keyword-only argument for now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1193148473",
    "pr_number": 7922,
    "pr_file": "src/poetry/toml/file.py",
    "created_at": "2023-05-14T13:32:53+00:00",
    "commented_code": "except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
    "repo_full_name": "python-poetry/poetry",
    "discussion_comments": [
      {
        "comment_id": "1193148473",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7922,
        "pr_file": "src/poetry/toml/file.py",
        "discussion_id": "1193148473",
        "commented_code": "@@ -34,8 +33,5 @@ def read(self) -> TOMLDocument:\n         except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
        "comment_created_at": "2023-05-14T13:32:53+00:00",
        "comment_author": "radoering",
        "comment_body": "I suppose this will break some plugins. I'd like to deprecate it first.",
        "pr_file_module": null
      },
      {
        "comment_id": "1193149885",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7922,
        "pr_file": "src/poetry/toml/file.py",
        "discussion_id": "1193148473",
        "commented_code": "@@ -34,8 +33,5 @@ def read(self) -> TOMLDocument:\n         except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
        "comment_created_at": "2023-05-14T13:40:58+00:00",
        "comment_author": "dimbleby",
        "comment_body": "this was previously available via the poetry-core object, and you've just released poetry-core 1.6.0 on which this no longer exists...\r\n\r\nie any plugins that were relying on this were going to have to switch from the `poetry.core.toml.file` to the `poetry.toml.file` anyway, IMO they might just as well make both changes at the same time\r\n\r\n(probably not worth much of an argument, if you _really_ want this back but deprecated then say so)",
        "pr_file_module": null
      },
      {
        "comment_id": "1193153163",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7922,
        "pr_file": "src/poetry/toml/file.py",
        "discussion_id": "1193148473",
        "commented_code": "@@ -34,8 +33,5 @@ def read(self) -> TOMLDocument:\n         except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
        "comment_created_at": "2023-05-14T14:01:18+00:00",
        "comment_author": "radoering",
        "comment_body": "It's not the import, I'm concerned about. It's `PyProjectTOML.file`. Correct me if I'm wrong, but plugins relying on `PyProjectTOML.file.parent` will still work if we keep `__getattr__()`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1193154049",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7922,
        "pr_file": "src/poetry/toml/file.py",
        "discussion_id": "1193148473",
        "commented_code": "@@ -34,8 +33,5 @@ def read(self) -> TOMLDocument:\n         except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
        "comment_created_at": "2023-05-14T14:06:23+00:00",
        "comment_author": "dimbleby",
        "comment_body": "my point is they already will have had to change the import, and in that context it's not too objectionable also to have them conform to a very slightly changed API.  \r\n\r\nThe code that you are asking to be deprecated is in some sense brand new - it hasn't even been released yet - so it's a little unexpected to be deprecated immediately.\r\n\r\nBut like I say I don't care much to argue about it",
        "pr_file_module": null
      },
      {
        "comment_id": "1193161619",
        "repo_full_name": "python-poetry/poetry",
        "pr_number": 7922,
        "pr_file": "src/poetry/toml/file.py",
        "discussion_id": "1193148473",
        "commented_code": "@@ -34,8 +33,5 @@ def read(self) -> TOMLDocument:\n         except (ValueError, TOMLKitError) as e:\n             raise TOMLError(f\"Invalid TOML file {self.path.as_posix()}: {e}\")\n \n-    def __getattr__(self, item: str) -> Any:",
        "comment_created_at": "2023-05-14T14:54:48+00:00",
        "comment_author": "radoering",
        "comment_body": "You may not have to change the import if there is no import. Let's just look at the [docs](https://python-poetry.org/docs/plugins/#generic-plugins). You have an instance of the `Poetry` class in your hand and just could do `poetry.pyproject.file.parent`. I suppose many users will not import `PyProjectTOML` or `TOMLFile` but just use the instance they get from the Poetry object.",
        "pr_file_module": null
      }
    ]
  }
]